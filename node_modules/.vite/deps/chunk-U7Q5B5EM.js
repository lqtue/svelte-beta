// node_modules/@allmaps/stdlib/dist/fetch.js
async function fetchUrl(input, init, fetchFn) {
  let response;
  if (typeof fetchFn === "function") {
    response = await fetchFn(input, init);
  } else {
    response = await fetch(input, init);
  }
  if (!response.ok) {
    const json = await response.json();
    if (json && json.error) {
      throw new Error(json.error);
    } else if (response.statusText) {
      throw new Error(response.statusText);
    } else if (response.status === 404) {
      throw new Error(`Not found: ${input} (404)`);
    } else if (response.status === 500) {
      throw new Error("Internal server error (500)");
    } else {
      throw new Error(`Failed to fetch: ${input} (${response.status})`);
    }
  }
  return response;
}
async function fetchJson(input, init, fetchFn) {
  const response = await fetchUrl(input, init, fetchFn);
  return await response.json();
}
async function fetchImageInfo(imageUri, init, fetchFn) {
  return await fetchJson(`${imageUri}/info.json`, init, fetchFn);
}
async function fetchImageBitmap(input, init, fetchFn) {
  const response = await fetchUrl(input, init, fetchFn);
  const blob = await response.blob();
  return await createImageBitmap(blob);
}

// node_modules/@allmaps/stdlib/dist/api.js
function fetchAnnotationsByIiifUrl(url) {
  return fetchJson(`https://annotations.allmaps.org/?url=${url}`);
}
async function fetchAnnotationsForImage(parsedImage) {
  try {
    const annotations = await fetchAnnotationsByIiifUrl(`${parsedImage.uri}/info.json`);
    return [annotations];
  } catch (err) {
    return [];
  }
}
async function fetchAnnotationsForManifest(parsedManifest) {
  try {
    const annotations = await fetchAnnotationsByIiifUrl(parsedManifest.uri);
    return [annotations];
  } catch (err) {
    const annotations = [];
    for (const canvas of parsedManifest.canvases) {
      const imageAnnotations = await fetchAnnotationsForImage(canvas.image);
      annotations.push(...imageAnnotations);
    }
    return annotations;
  }
}
async function fetchAnnotationsForCollection(parsedCollection) {
  try {
    const annotations = await fetchAnnotationsByIiifUrl(parsedCollection.uri);
    return [annotations];
  } catch (err) {
    const annotations = [];
    if ("items" in parsedCollection) {
      for (const item of parsedCollection.items) {
        if (item.type === "collection") {
          const itemAnnotations = await fetchAnnotationsForCollection(item);
          annotations.push(...itemAnnotations);
        } else if (item.type === "manifest" && "canvases" in item) {
          const itemAnnotations = await fetchAnnotationsForManifest(item);
          annotations.push(...itemAnnotations);
        }
      }
    }
    return annotations;
  }
}
function fetchAnnotationsFromApi(parsedIiif) {
  if (parsedIiif.type === "image") {
    return fetchAnnotationsForImage(parsedIiif);
  } else if (parsedIiif.type === "manifest") {
    return fetchAnnotationsForManifest(parsedIiif);
  } else if (parsedIiif.type === "collection") {
    return fetchAnnotationsForCollection(parsedIiif);
  } else {
    throw new Error("Unsupported IIIF resource");
  }
}

// node_modules/@allmaps/stdlib/dist/background-color.js
var DEFAULT_BIN_SIZE = 5;
var DEFAULT_RESOLUTION = 2;
function getImageData(imageBitmap, mask) {
  const canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
  const context = canvas.getContext("2d");
  if (!context) {
    throw new Error("Could not create OffscreenCanvas context");
  }
  if (mask) {
    context.fillStyle = "rgba(0, 0, 0, 0)";
    context.fillRect(0, 0, imageBitmap.width, imageBitmap.height);
    context.beginPath();
    context.moveTo(mask[0][0], mask[0][1]);
    mask.slice(1).forEach((point2) => context.lineTo(point2[0], point2[1]));
    context.closePath();
    context.clip();
  }
  context.drawImage(imageBitmap, 0, 0);
  return context.getImageData(0, 0, imageBitmap.width, imageBitmap.height);
}
function getColorsArray(imageData, resolution = DEFAULT_RESOLUTION) {
  const colors = [];
  for (let x = 0; x < imageData.width; x += resolution) {
    for (let y = 0; y < imageData.height; y += resolution) {
      const startIndex = (x + y * imageData.width) * 4;
      const opacity = imageData.data[startIndex + 3];
      if (opacity > 0) {
        const color = [
          imageData.data[startIndex],
          imageData.data[startIndex + 1],
          imageData.data[startIndex + 2]
        ];
        colors.push(color);
      }
    }
  }
  return colors;
}
function getColorHistogram(colors, binSize = DEFAULT_BIN_SIZE) {
  const histogram = {};
  for (const color of colors) {
    const bin = createColorBin(color, binSize);
    if (!histogram[bin]) {
      histogram[bin] = {
        count: 0,
        color
      };
    }
    histogram[bin].count += 1;
  }
  return histogram;
}
function getMaxOccurringColor(histogram) {
  let max = Number.NEGATIVE_INFINITY;
  let maxOccurringColor;
  for (const { count, color } of Object.values(histogram)) {
    if (count > max) {
      max = count;
      maxOccurringColor = color;
    }
  }
  if (!maxOccurringColor) {
    throw new Error("Histogram is empty");
  }
  return {
    count: max,
    color: maxOccurringColor
  };
}
function createColorBin(color, binSize) {
  return color.map((c) => Math.round(c / binSize)).toString();
}

// node_modules/monotone-chain-convex-hull/lib-esm/index.js
function monotoneChainConvexHull(points, options = {}) {
  const { sorted } = options;
  if (!sorted) {
    points = points.slice().sort(byXThenY);
  }
  const n = points.length;
  const result = new Array(n * 2);
  let k = 0;
  for (let i = 0; i < n; i++) {
    const point2 = points[i];
    while (k >= 2 && cw(result[k - 2], result[k - 1], point2) <= 0) {
      k--;
    }
    result[k++] = point2;
  }
  const t = k + 1;
  for (let i = n - 2; i >= 0; i--) {
    const point2 = points[i];
    while (k >= t && cw(result[k - 2], result[k - 1], point2) <= 0) {
      k--;
    }
    result[k++] = point2;
  }
  return result.slice(0, k - 1);
}
function cw(p1, p2, p3) {
  return (p2[1] - p1[1]) * (p3[0] - p1[0]) - (p2[0] - p1[0]) * (p3[1] - p1[1]);
}
function byXThenY(point1, point2) {
  if (point1[0] === point2[0]) {
    return point1[1] - point2[1];
  }
  return point1[0] - point2[0];
}

// node_modules/@turf/clone/dist/esm/index.js
function clone(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(geojson) {
  const cloned = { type: "Feature" };
  Object.keys(geojson).forEach((key) => {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  if (geojson.geometry == null) {
    cloned.geometry = null;
  } else {
    cloned.geometry = cloneGeometry(geojson.geometry);
  }
  return cloned;
}
function cloneProperties(properties) {
  const cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach((key) => {
    const value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (Array.isArray(value)) {
        cloned[key] = value.map((item) => {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else {
      cloned[key] = value;
    }
  });
  return cloned;
}
function cloneFeatureCollection(geojson) {
  const cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach((key) => {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map((feature2) => {
    return cloneFeature(feature2);
  });
  return cloned;
}
function cloneGeometry(geometry) {
  const geom = { type: geometry.type };
  if (geometry.bbox) {
    geom.bbox = geometry.bbox;
  }
  if (geometry.type === "GeometryCollection") {
    geom.geometries = geometry.geometries.map((g) => {
      return cloneGeometry(g);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry.coordinates);
  return geom;
}
function deepSlice(coords) {
  const cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map((coord) => {
    return deepSlice(coord);
  });
}

// node_modules/@turf/helpers/dist/esm/index.js
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: 360 / (2 * Math.PI),
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
function feature(geom, properties, options = {}) {
  const feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function point(coordinates, properties, options = {}) {
  if (!coordinates) {
    throw new Error("coordinates is required");
  }
  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }
  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }
  const geom = {
    type: "Point",
    coordinates
  };
  return feature(geom, properties, options);
}
function featureCollection(features, options = {}) {
  const fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function radiansToLength(radians, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians * factor;
}
function lengthToRadians(distance2, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance2 / factor;
}
function radiansToDegrees(radians) {
  const normalisedRadians = radians % (2 * Math.PI);
  return normalisedRadians * 180 / Math.PI;
}
function degreesToRadians(degrees) {
  const normalisedDegrees = degrees % 360;
  return normalisedDegrees * Math.PI / 180;
}
function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject(input) {
  return input !== null && typeof input === "object" && !Array.isArray(input);
}

// node_modules/@turf/invariant/dist/esm/index.js
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return [...coord.geometry.coordinates];
    }
    if (coord.type === "Point") {
      return [...coord.coordinates];
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return [...coord];
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}

// node_modules/@turf/boolean-clockwise/dist/esm/index.js
function booleanClockwise(line) {
  const ring = getCoords(line);
  let sum = 0;
  let i = 1;
  let prev;
  let cur;
  while (i < ring.length) {
    prev = cur || ring[0];
    cur = ring[i];
    sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
    i++;
  }
  return sum > 0;
}

// node_modules/@turf/meta/dist/esm/index.js
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false) break;
    }
  }
}
function geomEach(geojson, callback) {
  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry.geometries.length; j++) {
            if (callback(
              geometry.geometries[j],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}

// node_modules/@turf/rewind/dist/esm/index.js
function rewind(geojson, options = {}) {
  var _a, _b;
  options = options || {};
  if (!isObject(options)) throw new Error("options is invalid");
  const mutate = (_a = options.mutate) != null ? _a : false;
  const reverse = (_b = options.reverse) != null ? _b : false;
  if (!geojson) throw new Error("<geojson> is required");
  if (typeof reverse !== "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof mutate !== "boolean")
    throw new Error("<mutate> must be a boolean");
  if (!mutate && geojson.type !== "Point" && geojson.type !== "MultiPoint") {
    geojson = clone(geojson);
  }
  const results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse);
      });
      return geojson;
    case "FeatureCollection":
      featureEach(geojson, function(feature2) {
        const rewoundFeature = rewindFeature(feature2, reverse);
        featureEach(rewoundFeature, function(result) {
          results.push(result);
        });
      });
      return featureCollection(results);
  }
  return rewindFeature(geojson, reverse);
}
function rewindFeature(geojson, reverse) {
  const type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse);
      });
      return geojson;
    case "LineString":
      rewindLineString(getCoords(geojson), reverse);
      return geojson;
    case "Polygon":
      rewindPolygon(getCoords(geojson), reverse);
      return geojson;
    case "MultiLineString":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindLineString(lineCoords, reverse);
      });
      return geojson;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindPolygon(lineCoords, reverse);
      });
      return geojson;
    case "Point":
    case "MultiPoint":
      return geojson;
  }
}
function rewindLineString(coords, reverse) {
  if (booleanClockwise(coords) === reverse) coords.reverse();
}
function rewindPolygon(coords, reverse) {
  if (booleanClockwise(coords[0]) !== reverse) {
    coords[0].reverse();
  }
  for (let i = 1; i < coords.length; i++) {
    if (booleanClockwise(coords[i]) === reverse) {
      coords[i].reverse();
    }
  }
}

// node_modules/@allmaps/stdlib/dist/geometry.js
function isPoint(input) {
  return Array.isArray(input) && input.length >= 2 && typeof input[0] === "number" && typeof input[1] === "number";
}
function isLineString(input) {
  return Array.isArray(input) && input.every(isPoint);
}
function isRing(input) {
  return Array.isArray(input) && input.every(isPoint);
}
function isPolygon(input) {
  return Array.isArray(input) && input.every(isRing);
}
function isMultiPoint(input) {
  return Array.isArray(input) && input.every(isPoint);
}
function isMultiLineString(input) {
  return Array.isArray(input) && input.every(isLineString);
}
function isMultiPolygon(input) {
  return Array.isArray(input) && input.every(isPolygon);
}
function isGeometry(input) {
  return isPoint(input) || isLineString(input) || isPolygon(input) || isMultiPoint(input) || isMultiLineString(input) || isMultiPolygon(input);
}
function closeRing(ring) {
  return [...ring, ring[0]];
}
function uncloseRing(ring) {
  ring.splice(-1);
  return ring;
}
function closePolygon(polygon) {
  return polygon.map((ring) => closeRing(ring));
}
function unclosePolygon(polygon) {
  return polygon.map((ring) => uncloseRing(ring));
}
function closeMultiPolygon(multiPolygon) {
  return multiPolygon.map((polygon) => closePolygon(polygon));
}
function uncloseMultiPolygon(multiPolygon) {
  return multiPolygon.map((polygon) => unclosePolygon(polygon));
}
function conformLineString(lineString2) {
  lineString2 = lineString2.filter(function(point2, i, originalLineString) {
    return i === 0 || !isEqualPoint(point2, originalLineString[i - 1]);
  });
  if (lineString2.length < 2) {
    throw new Error("LineString should contain at least 2 points");
  }
  return lineString2;
}
function conformRing(ring) {
  ring = ring.filter(function(point2, i, originalRing) {
    return i === 0 || !isEqualPoint(point2, originalRing[i - 1]);
  });
  if (isClosed(ring)) {
    uncloseRing(ring);
  }
  if (ring.length < 3) {
    throw new Error("Ring should contain at least 3 points");
  }
  return ring;
}
function conformPolygon(polygon) {
  return polygon.map((ring) => {
    return conformRing(ring);
  });
}
function conformMultiLineString(multiLineString) {
  return multiLineString.map((lineString2) => conformLineString(lineString2));
}
function conformMultiPolygon(multiPolygon) {
  return multiPolygon.map((polygon) => conformPolygon(polygon));
}
function pointToGeojsonPoint(point2) {
  return {
    type: "Point",
    coordinates: point2
  };
}
function lineStringToGeojsonLineString(lineString2) {
  return {
    type: "LineString",
    coordinates: lineString2
  };
}
function ringToGeojsonPolygon(ring, close = true) {
  const geometry = {
    type: "Polygon",
    coordinates: close ? [closeRing(ring)] : [ring]
  };
  return rewind(geometry);
}
function polygonToGeojsonPolygon(polygon, close = true) {
  const geometry = {
    type: "Polygon",
    coordinates: close ? closePolygon(polygon) : polygon
  };
  return rewind(geometry);
}
function multiPointToGeojsonMultiPoint(multiPoint) {
  return {
    type: "MultiPoint",
    coordinates: multiPoint
  };
}
function multiLineStringToGeojsonMultiLineString(multiLineString) {
  return {
    type: "MultiLineString",
    coordinates: multiLineString
  };
}
function multiPolygonToGeojsonMultiPolygon(multiPolygon, close = true) {
  const geometry = {
    type: "MultiPolygon",
    coordinates: close ? closeMultiPolygon(multiPolygon) : multiPolygon
  };
  return rewind(geometry);
}
function geometryToGeojsonGeometry(geometry, options) {
  if (!options || !options.isMultiGeometry) {
    if (isPoint(geometry)) {
      return pointToGeojsonPoint(geometry);
    } else if (isLineString(geometry)) {
      return lineStringToGeojsonLineString(geometry);
    } else if (isPolygon(geometry)) {
      return polygonToGeojsonPolygon(geometry);
    } else {
      throw new Error("Geometry type not supported");
    }
  } else {
    if (isMultiPoint(geometry)) {
      return multiPointToGeojsonMultiPoint(geometry);
    } else if (isMultiLineString(geometry)) {
      return multiLineStringToGeojsonMultiLineString(geometry);
    } else if (isMultiPolygon(geometry)) {
      return multiPolygonToGeojsonMultiPolygon(geometry);
    } else {
      throw new Error("Geometry type not supported");
    }
  }
}
function pointToSvgCircle(point2) {
  return {
    type: "circle",
    coordinates: point2
  };
}
function lineStringToSvgPolyLine(lineString2) {
  return {
    type: "polyline",
    coordinates: lineString2
  };
}
function polygonToSvgPolygon(polygon) {
  return {
    type: "polygon",
    coordinates: polygon[0]
  };
}
function geometryToSvgGeometry(geometry) {
  if (isPoint(geometry)) {
    return pointToSvgCircle(geometry);
  } else if (isLineString(geometry)) {
    return lineStringToSvgPolyLine(geometry);
  } else if (isPolygon(geometry)) {
    return polygonToSvgPolygon(geometry);
  } else {
    throw new Error(`Unsupported GeoJSON Geometry`);
  }
}
function isClosed(input) {
  return Array.isArray(input) && input.length >= 2 && isEqualPoint(input[0], input[input.length - 1]);
}
function isEqualPoint(point0, point1) {
  if (point0 === point1)
    return true;
  if (point0 === null || point1 === null)
    return false;
  return point0[0] === point1[0] && point0[1] === point1[1];
}
function isEqualPointArray(pointArray0, pointArray1) {
  if (pointArray0 === pointArray1)
    return true;
  if (!pointArray0 || !pointArray1)
    return false;
  if (pointArray0.length !== pointArray1.length)
    return false;
  for (let i = 0; i < pointArray0.length; ++i) {
    if (isEqualPoint(pointArray0[i], pointArray1[i]))
      return false;
  }
  return true;
}
function isEqualPointArrayArray(pointArrayArray0, pointArrayArray1) {
  if (pointArrayArray0 === pointArrayArray1)
    return true;
  if (!pointArrayArray0 || !pointArrayArray1)
    return false;
  if (pointArrayArray0.length !== pointArrayArray1.length)
    return false;
  for (let i = 0; i < pointArrayArray0.length; ++i) {
    if (isEqualPointArray(pointArrayArray0[i], pointArrayArray1[i]))
      return false;
  }
  return true;
}
function pointsAndPointsToLines(points0, points1) {
  if (points0.length !== points1.length)
    throw new Error("Point arrays should be of same length");
  return points0.map((point0, index) => [point0, points1[index]]);
}
function lineStringToLines(lineString2) {
  return lineString2.reduce((accumulator, point2, index) => [
    ...accumulator,
    [point2, lineString2[(index + 1) % lineString2.length]]
  ], []);
}
function pointToPixel(point2, translate = [0, 0]) {
  return point2.map((coordinate, index) => {
    return Math.floor(coordinate + translate[index]);
  });
}
function pixelToIntArrayIndex(pixel, size, channels, flipY2 = false) {
  const column = pixel[0];
  const row = flipY2 ? size[1] - 1 - pixel[1] : pixel[1];
  return (row * size[0] + column) * channels;
}
function flipX(point2) {
  return [-point2[0], point2[1]];
}
function flipY(point2) {
  return [point2[0], -point2[1]];
}
function mixNumbers(number0, number1, t) {
  return number0 * (1 - t) + number1 * t;
}
function mixPoints(point0, point1, t) {
  return [
    mixNumbers(point0[0], point1[0], t),
    mixNumbers(point0[1], point1[1], t)
  ];
}
function midPoint(...points) {
  const result = [0, 0];
  for (let i = 0; i < points.length; i++) {
    result[0] += points[i][0];
    result[1] += points[i][1];
  }
  result[0] = result[0] / points.length;
  result[1] = result[1] / points.length;
  return result;
}
function lineAngle(line) {
  return Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]);
}
function stepDistanceAngle(point2, dist, angle) {
  return [point2[0] + Math.cos(angle) * dist, point2[1] + Math.sin(angle) * dist];
}
function distance(from, to) {
  if (isLineString(from) && from.length === 2) {
    return distance(from[0], from[1]);
  } else if (isPoint(from) && to === void 0) {
    return distance(from, [0, 0]);
  } else if (isPoint(from) && isPoint(to)) {
    return Math.sqrt(squaredDistance(from, to));
  } else {
    throw new Error("Input type not supported");
  }
}
function squaredDistance(from, to) {
  if (isLineString(from) && from.length === 2) {
    return squaredDistance(from[0], from[1]);
  } else if (isPoint(from) && to === void 0) {
    return squaredDistance(from, [0, 0]);
  } else if (isPoint(from) && isPoint(to)) {
    return (to[0] - from[0]) ** 2 + (to[1] - from[1]) ** 2;
  } else {
    throw new Error("Input type not supported");
  }
}
function rms(from, to) {
  if (from.length !== to.length) {
    throw new Error("Arrays need to be of same length");
  }
  const squaredDistances = from.map((fromPoint, index) => squaredDistance(fromPoint, to[index]));
  const meanSquaredDistances = squaredDistances.reduce((sum, squaredDistace) => sum + squaredDistace, 0) / squaredDistances.length;
  const rootMeanSquaredDistances = Math.sqrt(meanSquaredDistances);
  return rootMeanSquaredDistances;
}
function triangleArea(triangle) {
  return 0.5 * Math.abs(triangle[0][0] * (triangle[1][1] - triangle[2][1]) + triangle[1][0] * (triangle[2][1] - triangle[0][1]) + triangle[2][0] * (triangle[0][1] - triangle[1][1]));
}
function invertPoint(point2) {
  return [-point2[0], -point2[1]];
}
function invertPoints(points) {
  return points.map((point2) => invertPoint(point2));
}
function scalePoint(point2, scale) {
  if (scale === 1) {
    return point2;
  }
  return [point2[0] * scale, point2[1] * scale];
}
function scalePoints(points, scale) {
  if (scale === 1) {
    return points;
  }
  return points.map((point2) => scalePoint(point2, scale));
}
function translatePoint(point2, translationPoint, addOrSubstract = "add") {
  if (addOrSubstract === "add") {
    return [point2[0] + translationPoint[0], point2[1] + translationPoint[1]];
  } else {
    return [point2[0] - translationPoint[0], point2[1] - translationPoint[1]];
  }
}
function translatePoints(points, point2, addOrSubstract = "add") {
  if (isEqualPoint(point2, [0, 0])) {
    return points;
  }
  return points.map((p) => translatePoint(p, point2, addOrSubstract));
}
function rotatePoint(point2, angle = 0, anchor = void 0, cosAngle, sinAngle) {
  if (angle === 0 || angle === void 0) {
    return point2;
  }
  if (anchor) {
    return translatePoint(rotatePoint(translatePoint(point2, anchor, "substract"), angle, void 0, cosAngle, sinAngle), anchor);
  } else {
    cosAngle = cosAngle || Math.cos(angle);
    sinAngle = sinAngle || Math.sin(angle);
    return [
      point2[0] * cosAngle - point2[1] * sinAngle,
      point2[0] * sinAngle + point2[1] * cosAngle
    ];
  }
}
function rotatePoints(points, angle = 0, anchor = void 0, cosAngle, sinAngle) {
  if (angle === 0 || angle === void 0) {
    return points;
  }
  cosAngle = cosAngle || Math.cos(angle);
  sinAngle = sinAngle || Math.sin(angle);
  return points.map((point2) => rotatePoint(point2, angle, anchor, cosAngle, sinAngle));
}
function triangleAngles(triangle) {
  return [
    threePointsToAngle(triangle[0], triangle[1], triangle[2]),
    threePointsToAngle(triangle[1], triangle[2], triangle[0]),
    threePointsToAngle(triangle[2], triangle[0], triangle[1])
  ];
}
function threePointsToAngle(pointA, pointB, pointC) {
  const AB = distance(pointA, pointB);
  const BC = distance(pointB, pointC);
  const AC = distance(pointA, pointC);
  return Math.acos((AB ** 2 + AC ** 2 - BC ** 2) / (2 * AB * AC));
}

// node_modules/@allmaps/stdlib/dist/geojson.js
function isGeojsonPointCoordinates(input) {
  return Array.isArray(input) && input.length >= 2 && input.every((item) => typeof item === "number");
}
function isGeojsonLineStringCoordinates(input) {
  return Array.isArray(input) && input.every(isGeojsonPointCoordinates);
}
function isGeojsonRingCoordinates(input) {
  return Array.isArray(input) && input.every(isGeojsonPointCoordinates);
}
function isGeojsonPolygonCoordinates(input) {
  return Array.isArray(input) && input.every(isGeojsonRingCoordinates);
}
function isGeojsonMultiPointCoordinates(input) {
  return Array.isArray(input) && input.every(isGeojsonPointCoordinates);
}
function isGeojsonMultiLineStringCoordinates(input) {
  return Array.isArray(input) && input.every(isGeojsonLineStringCoordinates);
}
function isGeojsonMultiPolygonCoordinates(input) {
  return Array.isArray(input) && input.every(isGeojsonPolygonCoordinates);
}
function isGeojsonPoint(input) {
  return typeof input === "object" && input !== null && "type" in input && input.type === "Point" && "coordinates" in input && isGeojsonPointCoordinates(input.coordinates);
}
function isGeojsonLineString(input) {
  return typeof input === "object" && input !== null && "type" in input && input.type === "LineString" && "coordinates" in input && isGeojsonLineStringCoordinates(input.coordinates);
}
function isGeojsonPolygon(input) {
  return typeof input === "object" && input !== null && "type" in input && input.type === "Polygon" && "coordinates" in input && Array.isArray(input.coordinates) && isGeojsonPolygonCoordinates(input.coordinates);
}
function isGeojsonMultiPoint(input) {
  return typeof input === "object" && input !== null && "type" in input && input.type === "MultiPoint" && "coordinates" in input && isGeojsonMultiPointCoordinates(input.coordinates);
}
function isGeojsonMultiLineString(input) {
  return typeof input === "object" && input !== null && "type" in input && input.type === "MultiLineString" && "coordinates" in input && isGeojsonMultiLineStringCoordinates(input.coordinates);
}
function isGeojsonMultiPolygon(input) {
  return typeof input === "object" && input !== null && "type" in input && input.type === "MultiPolygon" && "coordinates" in input && Array.isArray(input.coordinates) && isGeojsonMultiPolygonCoordinates(input.coordinates);
}
function isGeojsonGeometry(obj) {
  const isObject2 = typeof obj === "object" && obj !== null;
  const hasStringType = isObject2 && "type" in obj && typeof obj.type === "string";
  const isValidType = hasStringType && (obj.type === "Point" || obj.type === "LineString" || obj.type === "Polygon" || obj.type === "MultiPoint" || obj.type === "MultiLineString" || obj.type === "MultiPolygon");
  const hasCoordinatesArray = isObject2 && "coordinates" in obj && Array.isArray(obj.coordinates);
  return isValidType && hasCoordinatesArray;
}
function isGeojsonMultiGeometry(obj) {
  const isObject2 = typeof obj === "object" && obj !== null;
  const hasStringType = isObject2 && "type" in obj && typeof obj.type === "string";
  const isValidType = hasStringType && (obj.type === "MultiPoint" || obj.type === "MultiLineString" || obj.type === "MultiPolygon");
  const hasCoordinatesArray = isObject2 && "coordinates" in obj && Array.isArray(obj.coordinates);
  return isValidType && hasCoordinatesArray;
}
function geojsonPointCoordinatesToPoint(geojsonPointCoordinates) {
  return geojsonPointCoordinates.slice(0, 2);
}
function geojsonPointToPoint(geojsonPoint) {
  return geojsonPointCoordinatesToPoint(geojsonPoint.coordinates);
}
function geojsonLineStringToLineString(geojsonLineString) {
  return conformLineString(geojsonLineString.coordinates.map(geojsonPointCoordinatesToPoint));
}
function geojsonPolygonToRing(geojsonPolygon, close = false) {
  const outerRing = conformRing(geojsonPolygon.coordinates[0].map(geojsonPointCoordinatesToPoint));
  return close ? [...outerRing, outerRing[0]] : outerRing;
}
function geojsonPolygonToPolygon(geojsonPolygon, close = false) {
  const polygon = conformPolygon(geojsonPolygon.coordinates.map((ring) => ring.map(geojsonPointCoordinatesToPoint)));
  return close ? polygon.map((ring) => [...ring, ring[0]]) : polygon;
}
function geojsonMultiPointToMultiPoint(geojsonMultiPoint) {
  return geojsonMultiPoint.coordinates.map(geojsonPointCoordinatesToPoint);
}
function geojsonMultiLineStringToMultiLineString(geojsonMultiLineString) {
  return conformMultiLineString(geojsonMultiLineString.coordinates.map((l) => l.map(geojsonPointCoordinatesToPoint)));
}
function geojsonMultiPolygonToMultiPolygon(geojsonMultiPolygon, close = false) {
  const multipolygon = conformMultiPolygon(geojsonMultiPolygon.coordinates.map((p) => p.map((l) => l.map(geojsonPointCoordinatesToPoint))));
  return close ? multipolygon.map((polygon) => polygon.map((ring) => [...ring, ring[0]])) : multipolygon;
}
function geojsonGeometryToGeometry(geojsonGeometry) {
  if (isGeojsonPoint(geojsonGeometry)) {
    return geojsonPointToPoint(geojsonGeometry);
  } else if (isGeojsonLineString(geojsonGeometry)) {
    return geojsonLineStringToLineString(geojsonGeometry);
  } else if (isGeojsonPolygon(geojsonGeometry)) {
    return geojsonPolygonToPolygon(geojsonGeometry);
  } else if (isGeojsonMultiPoint(geojsonGeometry)) {
    return geojsonMultiPointToMultiPoint(geojsonGeometry);
  } else if (isGeojsonMultiLineString(geojsonGeometry)) {
    return geojsonMultiLineStringToMultiLineString(geojsonGeometry);
  } else if (isGeojsonMultiPolygon(geojsonGeometry)) {
    return geojsonMultiPolygonToMultiPolygon(geojsonGeometry);
  } else {
    throw new Error("Geometry type not supported");
  }
}
function geojsonGeometryToSvgGeometry(geojsonGeometry) {
  return geometryToSvgGeometry(geojsonGeometryToGeometry(geojsonGeometry));
}
function geojsonGeometryToGeojsonFeature(geojsonGeometry, properties) {
  return {
    type: "Feature",
    properties: properties ? properties : {},
    geometry: geojsonGeometry
  };
}
function geojsonFeaturesToGeojsonFeatureCollection(geojsonFeatures) {
  if (!Array.isArray(geojsonFeatures)) {
    geojsonFeatures = [geojsonFeatures];
  }
  return {
    type: "FeatureCollection",
    features: geojsonFeatures
  };
}
function geojsonGeometriesToGeojsonFeatureCollection(geojsonGeometries, properties) {
  return {
    type: "FeatureCollection",
    features: geojsonGeometries.map((geometry, i) => properties ? geojsonGeometryToGeojsonFeature(geometry, properties[i]) : geojsonGeometryToGeojsonFeature(geometry))
  };
}
function geojsonFeatureToGeojsonGeometry(geojsonFeature) {
  return geojsonFeature.geometry;
}
function geojsonFeatureCollectionToGeojsonGeometries(geojsonFeatureCollection) {
  return geojsonFeatureCollection.features.map(geojsonFeatureToGeojsonGeometry);
}
function expandGeojsonMultiPointToGeojsonPoints(geojsonMultiPoint) {
  return geojsonMultiPoint.coordinates.map((point2) => {
    return {
      type: "Point",
      coordinates: point2
    };
  });
}
function expandGeojsonMultiLineStringToGeojsonLineStrings(geojsonMultiLineString) {
  return geojsonMultiLineString.coordinates.map((lineString2) => {
    return {
      type: "LineString",
      coordinates: lineString2
    };
  });
}
function expandGeojsonMultiPolygonToGeojsonPolygons(geojsonMultiPolygon) {
  return geojsonMultiPolygon.coordinates.map((polygon) => {
    return {
      type: "Polygon",
      coordinates: polygon
    };
  });
}
function expandGeojsonMultiGeometryToGeojsonGeometries(geojsonMultiGeometry) {
  if (isGeojsonMultiPoint(geojsonMultiGeometry)) {
    return expandGeojsonMultiPointToGeojsonPoints(geojsonMultiGeometry);
  } else if (isGeojsonMultiLineString(geojsonMultiGeometry)) {
    return expandGeojsonMultiLineStringToGeojsonLineStrings(geojsonMultiGeometry);
  } else if (isGeojsonMultiPolygon(geojsonMultiGeometry)) {
    return expandGeojsonMultiPolygonToGeojsonPolygons(geojsonMultiGeometry);
  } else {
    throw new Error("Geometry type not supported");
  }
}
function contractGeojsonPointsToGeojsonMultiPoint(geojsonPoints) {
  return {
    type: "MultiPoint",
    coordinates: geojsonPoints.map((geojsonPoint) => geojsonPoint.coordinates)
  };
}
function contractGeojsonLineStringsToGeojsonMultiLineString(geojsonLineStrings) {
  return {
    type: "MultiLineString",
    coordinates: geojsonLineStrings.map((geojsonLineString) => geojsonLineString.coordinates)
  };
}
function contractGeojsonPolygonsToGeojsonMultiPolygon(geojsonPolygons) {
  return {
    type: "MultiPolygon",
    coordinates: geojsonPolygons.map((geojsonPolygon) => geojsonPolygon.coordinates)
  };
}
function contractGeojsonGeometriesToGeojsonMultiGeometry(geojsonGeometries) {
  if (geojsonGeometries.every(isGeojsonPoint)) {
    return contractGeojsonPointsToGeojsonMultiPoint(geojsonGeometries);
  } else if (geojsonGeometries.every(isGeojsonLineString)) {
    return contractGeojsonLineStringsToGeojsonMultiLineString(geojsonGeometries);
  } else if (geojsonGeometries.every(isGeojsonPolygon)) {
    return contractGeojsonPolygonsToGeojsonMultiPolygon(geojsonGeometries);
  } else {
    throw new Error("Geometry type not supported");
  }
}
function mergeGeojsonFeaturesCollections(geojsonFeatureCollections) {
  return {
    type: "FeatureCollection",
    features: geojsonFeatureCollections.map((geojsonFeatureCollection) => geojsonFeatureCollection.features).flat(1)
  };
}

// node_modules/@allmaps/stdlib/dist/bbox.js
function computeMinMax(values) {
  let min = Number.POSITIVE_INFINITY;
  let max = Number.NEGATIVE_INFINITY;
  for (const value of values) {
    if (min === void 0) {
      if (value >= value)
        min = max = value;
    } else {
      if (min > value)
        min = value;
      if (max < value)
        max = value;
    }
  }
  return [min, max];
}
function computeBbox(points) {
  if (isPoint(points)) {
    points = [points];
  }
  if (isPolygon(points)) {
    points = points.flat();
  }
  if (isMultiPolygon(points)) {
    points = points.flat();
  }
  if (isGeojsonGeometry(points)) {
    return computeBbox(geojsonGeometryToGeometry(points));
  }
  const xs = [];
  const ys = [];
  for (const point2 of points) {
    xs.push(point2[0]);
    ys.push(point2[1]);
  }
  const [minX, maxX] = computeMinMax(xs);
  const [minY, maxY] = computeMinMax(ys);
  return [minX, minY, maxX, maxY];
}
function combineBboxes(...bboxes) {
  if (bboxes.length === 0) {
    return void 0;
  }
  return [
    Math.min(...bboxes.map((bbox) => bbox[0])),
    Math.min(...bboxes.map((bbox) => bbox[1])),
    Math.max(...bboxes.map((bbox) => bbox[2])),
    Math.max(...bboxes.map((bbox) => bbox[3]))
  ];
}
function doBboxesIntersect(bbox0, bbox1) {
  const isOverlappingInX = bbox0[2] >= bbox1[0] && bbox1[2] >= bbox0[0];
  const isOverlappingInY = bbox0[3] >= bbox1[1] && bbox1[3] >= bbox0[1];
  return isOverlappingInX && isOverlappingInY;
}
function intersectBboxes(bbox0, bbox1) {
  const minX = Math.max(bbox0[0], bbox1[0]);
  const maxX = Math.min(bbox0[2], bbox1[2]);
  const minY = Math.max(bbox0[1], bbox1[1]);
  const maxY = Math.min(bbox0[3], bbox1[3]);
  if (minX < maxX && minY < maxY) {
    return [minX, minY, maxX, maxY];
  } else {
    return void 0;
  }
}
function pointInBbox(point2, bbox) {
  return doBboxesIntersect([point2[0], point2[1], point2[0], point2[1]], bbox);
}
function bufferBbox(bbox, dist0, dist1) {
  if (dist1 === void 0) {
    dist1 = dist0;
  }
  return [bbox[0] - dist0, bbox[1] - dist1, bbox[2] + dist0, bbox[3] + dist1];
}
function bufferBboxByRatio(bbox, ratio) {
  if (ratio === 0) {
    return bbox;
  }
  const size = bboxToSize(bbox);
  return bufferBbox(bbox, ...size.map((widthOrHeigth) => widthOrHeigth * ratio / 2));
}
function bboxToRectangle(bbox) {
  return [
    [bbox[0], bbox[1]],
    [bbox[2], bbox[1]],
    [bbox[2], bbox[3]],
    [bbox[0], bbox[3]]
  ];
}
function bboxToPolygon(bbox) {
  return [bboxToRectangle(bbox)];
}
function bboxToLine(bbox) {
  return [
    [bbox[0], bbox[1]],
    [bbox[2], bbox[3]]
  ];
}
function bboxToDiameter(bbox) {
  return distance(bboxToLine(bbox));
}
function geometryToDiameter(geometry) {
  return distance(bboxToLine(computeBbox(geometry)));
}
function bboxToCenter(bbox) {
  return [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];
}
function bboxToSize(bbox) {
  return [bbox[2] - bbox[0], bbox[3] - bbox[1]];
}
function bboxToResolution(bbox) {
  return sizeToResolution(bboxToSize(bbox));
}
function rectangleToSize(rectangle) {
  return [
    0.5 * (distance(rectangle[0], rectangle[1]) + distance(rectangle[2], rectangle[3])),
    0.5 * (distance(rectangle[1], rectangle[2]) + distance(rectangle[3], rectangle[0]))
  ];
}
function convexHull(points) {
  if (points.length === 0) {
    return void 0;
  }
  return monotoneChainConvexHull(points);
}
function sizesToScale(size0, size1, fit) {
  if (!fit) {
    return Math.sqrt(size0[0] * size0[1] / (size1[0] * size1[1]));
  } else if (fit === "contain") {
    return size0[0] / size0[1] >= size1[0] / size1[1] ? size0[0] / size1[0] : size0[1] / size1[1];
  } else {
    return size0[0] / size0[1] >= size1[0] / size1[1] ? size0[1] / size1[1] : size0[0] / size1[0];
  }
}
function scaleSize(size, scale) {
  return [size[0] * scale, size[1] * scale];
}
function sizeToResolution(size) {
  return size[0] * size[1];
}
function sizeToCenter(size) {
  return [size[0] / 2, size[1] / 2];
}
function sizeToBbox(size) {
  return [0, 0, ...size];
}
function sizeToRectangle(size) {
  return bboxToRectangle(sizeToBbox(size));
}
function bboxesToScale(bbox0, bbox1) {
  return sizesToScale(bboxToSize(bbox0), bboxToSize(bbox1));
}
function rectanglesToScale(rectangle0, rectangle1) {
  return sizesToScale(rectangleToSize(rectangle0), rectangleToSize(rectangle1));
}

// node_modules/@allmaps/stdlib/dist/cache.js
function getPropertyFromCacheOrComputation(cache, key, computation, checkUse = () => true, checkStore = () => true) {
  if (cache.has(key) && checkUse(cache.get(key))) {
    return cache.get(key);
  } else {
    const result = computation();
    if (checkStore(result)) {
      cache.set(key, result);
    }
    return result;
  }
}
function getPropertyFromDoubleCacheOrComputation(cache, key0, key1, computation, checkUse = () => true, checkStore = () => true) {
  if (cache.get(key0)?.has(key1) && checkUse(cache.get(key0)?.get(key1))) {
    return cache.get(key0)?.get(key1);
  } else {
    const result = computation();
    if (checkStore(result)) {
      if (!cache.get(key0)) {
        cache.set(key0, /* @__PURE__ */ new Map());
      }
      cache.get(key0)?.set(key1, result);
    }
    return result;
  }
}
function getPropertyFromTripleCacheOrComputation(cache, key0, key1, key2, computation, checkUse = () => true, checkStore = () => true) {
  if (cache.get(key0)?.get(key1)?.has(key2) && checkUse(cache.get(key0)?.get(key1)?.get(key2))) {
    return cache.get(key0)?.get(key1)?.get(key2);
  } else {
    const result = computation();
    if (checkStore(result)) {
      if (!cache.get(key0)) {
        cache.set(key0, /* @__PURE__ */ new Map());
      }
      if (!cache.get(key0)?.get(key1)) {
        cache.get(key0)?.set(key1, /* @__PURE__ */ new Map());
      }
      cache.get(key0)?.get(key1)?.set(key2, result);
    }
    return result;
  }
}

// node_modules/hex-rgb/index.js
var hexCharacters = "a-f\\d";
var match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;
var match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;
var nonHexChars = new RegExp(`[^#${hexCharacters}]`, "gi");
var validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, "i");
function hexRgb(hex, options = {}) {
  if (typeof hex !== "string" || nonHexChars.test(hex) || !validHexSize.test(hex)) {
    throw new TypeError("Expected a valid hex string");
  }
  hex = hex.replace(/^#/, "");
  let alphaFromHex = 1;
  if (hex.length === 8) {
    alphaFromHex = Number.parseInt(hex.slice(6, 8), 16) / 255;
    hex = hex.slice(0, 6);
  }
  if (hex.length === 4) {
    alphaFromHex = Number.parseInt(hex.slice(3, 4).repeat(2), 16) / 255;
    hex = hex.slice(0, 3);
  }
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  const number = Number.parseInt(hex, 16);
  const red = number >> 16;
  const green = number >> 8 & 255;
  const blue = number & 255;
  const alpha = typeof options.alpha === "number" ? options.alpha : alphaFromHex;
  if (options.format === "array") {
    return [red, green, blue, alpha];
  }
  if (options.format === "css") {
    const alphaString = alpha === 1 ? "" : ` / ${Number((alpha * 100).toFixed(2))}%`;
    return `rgb(${red} ${green} ${blue}${alphaString})`;
  }
  return { red, green, blue, alpha };
}

// node_modules/rgb-hex/index.js
var toHex = (red, green, blue, alpha) => (blue | green << 8 | red << 16 | 1 << 24).toString(16).slice(1) + alpha;
function rgbHex(red, green, blue, alpha) {
  let isPercent = (red + (alpha || "")).toString().includes("%");
  if (typeof red === "string" && !green) {
    const parsed = parseCssRgbString(red);
    if (!parsed) {
      throw new TypeError("Invalid or unsupported color format.");
    }
    isPercent = false;
    [red, green, blue, alpha] = parsed;
  } else if (alpha !== void 0) {
    alpha = Number.parseFloat(alpha);
  }
  if (typeof red !== "number" || typeof green !== "number" || typeof blue !== "number" || red > 255 || green > 255 || blue > 255) {
    throw new TypeError("Expected three numbers below 256");
  }
  if (typeof alpha === "number") {
    if (!isPercent && alpha >= 0 && alpha <= 1) {
      alpha = Math.round(255 * alpha);
    } else if (isPercent && alpha >= 0 && alpha <= 100) {
      alpha = Math.round(255 * alpha / 100);
    } else {
      throw new TypeError(`Expected alpha value (${alpha}) as a fraction or percentage`);
    }
    alpha = (alpha | 1 << 8).toString(16).slice(1);
  } else {
    alpha = "";
  }
  return toHex(red, green, blue, alpha);
}
var parseCssRgbString = (input) => {
  const parts = input.replace(/rgba?\(([^)]+)\)/, "$1").split(/[,\s/]+/).filter(Boolean);
  if (parts.length < 3) {
    return;
  }
  const parseValue = (value, max) => {
    value = value.trim();
    if (value.endsWith("%")) {
      return Math.min(Number.parseFloat(value) * max / 100, max);
    }
    return Math.min(Number.parseFloat(value), max);
  };
  const red = parseValue(parts[0], 255);
  const green = parseValue(parts[1], 255);
  const blue = parseValue(parts[2], 255);
  let alpha;
  if (parts.length === 4) {
    alpha = parseValue(parts[3], 1);
  }
  return [red, green, blue, alpha];
};

// node_modules/@allmaps/stdlib/dist/color.js
function rgbToHex(color) {
  return "#" + rgbHex(...color);
}
function rgbaToHex(color) {
  return "#" + rgbHex(...color);
}
function hexToRgb(hex) {
  return hexRgb(hex, { format: "array" }).slice(0, 3);
}
function hexToRgba(hex) {
  const color = hexRgb(hex, { format: "array" });
  if (color.length < 4) {
    color[3] = 255;
  }
  return color;
}
function hexToOpaqueRgba(hex) {
  const color = hexRgb(hex, { format: "array" });
  color[3] = 255;
  return color;
}
function hexToFractionalRgb(hex) {
  return hexToRgb(hex).map((c) => c / 255);
}
function hexToFractionalRgba(hex) {
  return hexToRgba(hex).map((c) => c / 255);
}
function hexToFractionalOpaqueRgba(hex) {
  return hexToOpaqueRgba(hex).map((c) => c / 255);
}

// node_modules/@allmaps/stdlib/dist/main.js
function degreesToRadians2(degrees) {
  return degrees * (Math.PI / 180);
}
function groupBy(arr, key) {
  return arr.reduce((groups, item) => {
    ;
    (groups[key(item)] ||= []).push(item);
    return groups;
  }, {});
}
function isEqualArray(array0, array1, isEqualObject = (t0, t1) => t0 == t1) {
  if (array0.length !== array1.length) {
    return false;
  }
  for (let i = 0; i < array0.length; i++) {
    if (!isEqualObject(array0[i], array1[i])) {
      return false;
    }
  }
  return true;
}
function arrayDifference(array0, array1, isEqualObject = (t0, t1) => t0 == t1) {
  const result = [];
  for (let i = 0; i < array0.length; i++) {
    let found = false;
    for (let j = 0; j < array1.length; j++) {
      if (isEqualObject(array0[i], array1[j])) {
        found = true;
        break;
      }
    }
    if (!found) {
      result.push(array0[i]);
    }
  }
  return result;
}
function arrayUnique(array, isEqualObject = (t0, t1) => t0 == t1) {
  const result = [];
  for (let i = 0; i < array.length; i++) {
    let found = false;
    for (let j = 0; j < i; j++) {
      if (isEqualObject(array[i], array[j])) {
        found = true;
        break;
      }
    }
    if (!found) {
      result.push(array[i]);
    }
  }
  return result;
}
function arrayRepeated(array, isEqualObject = (t0, t1) => t0 == t1) {
  const result = [];
  for (let i = 0; i < array.length; i++) {
    let found = false;
    for (let j = 0; j < i; j++) {
      if (isEqualObject(array[i], array[j])) {
        found = true;
        break;
      }
    }
    if (found) {
      result.push(array[i]);
    }
  }
  return result;
}
function subSetArray(arr1, arr2) {
  for (let i = 0; i < arr2.length; i++) {
    if (arr1.indexOf(arr2[i]) === -1) {
      return false;
    }
  }
  return true;
}
function equalSet(set1, set2) {
  if (!set1 || !set2) {
    return false;
  }
  if (set1.size !== set2.size) {
    return false;
  }
  return [...set1].every((x) => set2.has(x));
}
function maxOfNumberOrUndefined(number1, number2) {
  if (number1 !== void 0 && number2 !== void 0) {
    return Math.max(number1, number2);
  } else if (number1 !== void 0) {
    return number1;
  } else if (number2 !== void 0) {
    return number2;
  }
}
function isValidHttpUrl(string) {
  let url;
  try {
    url = new URL(string);
  } catch (_) {
    return false;
  }
  return url.protocol === "http:" || url.protocol === "https:";
}

// node_modules/@allmaps/stdlib/dist/masks.js
function getFullResourceMask(imageWidth, imageHeight) {
  return [
    [0, 0],
    [imageWidth, 0],
    [imageWidth, imageHeight],
    [0, imageHeight]
  ];
}

// node_modules/@allmaps/stdlib/dist/matrix.js
function newArrayMatrix(rows, cols, value = 0) {
  if (rows <= 0 || cols <= 0) {
    throw new Error("Empty ArrayMatrix not supported");
  }
  return Array.from(Array(rows), (_) => Array(cols).fill(value));
}
function arrayMatrixSize(arrayMatrix) {
  if (arrayMatrix.length === 0) {
    throw new Error("ArrayMatrix may not be empty, but rows are empty");
  }
  const rowLengths = arrayMatrix.map((row) => row.length);
  if (rowLengths.some((rowLength) => rowLength === 0)) {
    throw new Error("ArrayMatrix may not be empty, but at least one row is empty");
  }
  if (!rowLengths.every((rowLength) => rowLength === rowLengths[0])) {
    throw new Error("Rows of unequal length");
  }
  const rows = arrayMatrix.length;
  const cols = rowLengths[0];
  return [rows, cols];
}
function shallowCopyArrayMatrix(arrayMatrix) {
  return arrayMatrix.map((row) => [...row]);
}
function sliceArrayMatrix(arrayMatrix, rowsStart, colsStart, rowsEnd, colsEnd) {
  return arrayMatrix.slice(rowsStart, rowsEnd).map((row) => row.slice(colsStart, colsEnd));
}
function subArrayMatrix(arrayMatrix, rows, cols) {
  const size = [rows.length, cols.length];
  const result = newArrayMatrix(...size);
  for (let i = 0; i < size[0]; i++) {
    for (let j = 0; j < size[1]; j++) {
      result[i][j] = arrayMatrix[rows[i]][cols[j]];
    }
  }
  return result;
}
function multiplyArrayMatrix(arrayMatrix, factor) {
  const size = arrayMatrixSize(arrayMatrix);
  const result = newArrayMatrix(...size);
  for (let i = 0; i < size[0]; i++) {
    for (let j = 0; j < size[1]; j++) {
      result[i][j] = factor * arrayMatrix[i][j];
    }
  }
  return result;
}
function pasteArrayMatrix(arrayMatrix, rowsStart, colsStart, subArrayMatrix2) {
  const subSize = arrayMatrixSize(subArrayMatrix2);
  const result = shallowCopyArrayMatrix(arrayMatrix);
  for (let i = 0; i < subSize[0]; i++) {
    for (let j = 0; j < subSize[1]; j++) {
      result[rowsStart + i][colsStart + j] = subArrayMatrix2[i][j];
    }
  }
  return result;
}
function transposeArrayMatrix(arrayMatrix) {
  return arrayMatrix[0].map((_, colIndex) => arrayMatrix.map((row) => row[colIndex]));
}
function newBlockArrayMatrix(blocks, emptyValue = 0) {
  const size = arrayMatrixSize(blocks);
  const sizesArrayMatrix = blocks.map((row) => row.map((block) => arrayMatrixSize(block)));
  const rowsArrayMatrix = sizesArrayMatrix.map((row) => row.map((dims) => dims[0]));
  const transposedRowsArrayMatrix = transposeArrayMatrix(rowsArrayMatrix);
  const rowsArray = transposedRowsArrayMatrix[0];
  if (!transposedRowsArrayMatrix.every((array) => isEqualArray(array, transposedRowsArrayMatrix[0]))) {
    throw new Error("The blocks, by block column, must have the same sequence of rows.");
  }
  const rowsTrailingCumulativeArray = [];
  let sum = 0;
  rowsArray.forEach((e) => {
    rowsTrailingCumulativeArray.push(sum);
    sum = sum + e;
  });
  const rowsCumulative = sum;
  const colsArrayMatrix = sizesArrayMatrix.map((row) => row.map((dims) => dims[1]));
  const colsArray = colsArrayMatrix[0];
  if (!colsArrayMatrix.every((array) => isEqualArray(array, colsArray))) {
    throw new Error("The blocks, by block row, must have the same sequence of columns.");
  }
  const colsTrailingCumulativeArray = [];
  sum = 0;
  colsArrayMatrix[0].forEach((e) => {
    colsTrailingCumulativeArray.push(sum);
    sum = sum + e;
  });
  const colsCumulative = sum;
  let result = newArrayMatrix(rowsCumulative, colsCumulative, emptyValue);
  for (let i = 0; i < size[0]; i++) {
    for (let j = 0; j < size[1]; j++) {
      result = pasteArrayMatrix(result, rowsTrailingCumulativeArray[i], rowsTrailingCumulativeArray[j], blocks[i][j]);
    }
  }
  return result;
}

// node_modules/@allmaps/stdlib/dist/options.js
function mergeOptions(options0, options1) {
  if (!options1) {
    return options0;
  }
  return {
    ...options0,
    ...options1
  };
}
function mergeOptionsUnlessUndefined(options0, options1) {
  if (!options1) {
    return options0;
  }
  for (const key in options1) {
    const value = options1[key];
    if (value !== void 0) {
      ;
      options0[key] = value;
    }
  }
  return options0;
}
function mergePartialOptions(...partialOptionsArray) {
  const definedPartialOptionsArray = partialOptionsArray.filter((partialOptions) => partialOptions !== void 0 && partialOptions !== null);
  if (definedPartialOptionsArray.length === 0) {
    return {};
  } else if (definedPartialOptionsArray.length === 1) {
    return definedPartialOptionsArray[0];
  } else {
    return Object.assign({}, ...definedPartialOptionsArray);
  }
}

// node_modules/svg-parser/dist/svg-parser.esm.js
function getLocator(source, options) {
  if (options === void 0) {
    options = {};
  }
  var offsetLine = options.offsetLine || 0;
  var offsetColumn = options.offsetColumn || 0;
  var originalLines = source.split("\n");
  var start = 0;
  var lineRanges = originalLines.map(function(line, i2) {
    var end = start + line.length + 1;
    var range = { start, end, line: i2 };
    start = end;
    return range;
  });
  var i = 0;
  function rangeContains(range, index) {
    return range.start <= index && index < range.end;
  }
  function getLocation(range, index) {
    return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };
  }
  function locate2(search, startIndex) {
    if (typeof search === "string") {
      search = source.indexOf(search, startIndex || 0);
    }
    var range = lineRanges[i];
    var d = search >= range.end ? 1 : -1;
    while (range) {
      if (rangeContains(range, search))
        return getLocation(range, search);
      i += d;
      range = lineRanges[i];
    }
  }
  return locate2;
}
function locate(source, search, options) {
  if (typeof options === "number") {
    throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
  }
  return getLocator(source, options)(search, options && options.startIndex);
}
var validNameCharacters = /[a-zA-Z0-9:_-]/;
var whitespace = /[\s\t\r\n]/;
var quotemark = /['"]/;
function repeat(str, i) {
  var result = "";
  while (i--) {
    result += str;
  }
  return result;
}
function parse(source) {
  var header = "";
  var stack = [];
  var state = metadata;
  var currentElement = null;
  var root = null;
  function error(message) {
    var ref = locate(source, i);
    var line = ref.line;
    var column = ref.column;
    var before = source.slice(0, i);
    var beforeLine = /(^|\n).*$/.exec(before)[0].replace(/\t/g, "  ");
    var after = source.slice(i);
    var afterLine = /.*(\n|$)/.exec(after)[0];
    var snippet = "" + beforeLine + afterLine + "\n" + repeat(" ", beforeLine.length) + "^";
    throw new Error(
      message + " (" + line + ":" + column + "). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues  thanks!\n\n" + snippet
    );
  }
  function metadata() {
    while (i < source.length && source[i] !== "<" || !validNameCharacters.test(source[i + 1])) {
      header += source[i++];
    }
    return neutral();
  }
  function neutral() {
    var text = "";
    while (i < source.length && source[i] !== "<") {
      text += source[i++];
    }
    if (/\S/.test(text)) {
      currentElement.children.push({ type: "text", value: text });
    }
    if (source[i] === "<") {
      return tag;
    }
    return neutral;
  }
  function tag() {
    var char = source[i];
    if (char === "?") {
      return neutral;
    }
    if (char === "!") {
      if (source.slice(i + 1, i + 3) === "--") {
        return comment;
      }
      if (source.slice(i + 1, i + 8) === "[CDATA[") {
        return cdata;
      }
      if (/doctype/i.test(source.slice(i + 1, i + 8))) {
        return neutral;
      }
    }
    if (char === "/") {
      return closingTag;
    }
    var tagName = getName();
    var element = {
      type: "element",
      tagName,
      properties: {},
      children: []
    };
    if (currentElement) {
      currentElement.children.push(element);
    } else {
      root = element;
    }
    var attribute;
    while (i < source.length && (attribute = getAttribute())) {
      element.properties[attribute.name] = attribute.value;
    }
    var selfClosing = false;
    if (source[i] === "/") {
      i += 1;
      selfClosing = true;
    }
    if (source[i] !== ">") {
      error("Expected >");
    }
    if (!selfClosing) {
      currentElement = element;
      stack.push(element);
    }
    return neutral;
  }
  function comment() {
    var index = source.indexOf("-->", i);
    if (!~index) {
      error("expected -->");
    }
    i = index + 2;
    return neutral;
  }
  function cdata() {
    var index = source.indexOf("]]>", i);
    if (!~index) {
      error("expected ]]>");
    }
    currentElement.children.push(source.slice(i + 7, index));
    i = index + 2;
    return neutral;
  }
  function closingTag() {
    var tagName = getName();
    if (!tagName) {
      error("Expected tag name");
    }
    if (tagName !== currentElement.tagName) {
      error("Expected closing tag </" + tagName + "> to match opening tag <" + currentElement.tagName + ">");
    }
    allowSpaces();
    if (source[i] !== ">") {
      error("Expected >");
    }
    stack.pop();
    currentElement = stack[stack.length - 1];
    return neutral;
  }
  function getName() {
    var name = "";
    while (i < source.length && validNameCharacters.test(source[i])) {
      name += source[i++];
    }
    return name;
  }
  function getAttribute() {
    if (!whitespace.test(source[i])) {
      return null;
    }
    allowSpaces();
    var name = getName();
    if (!name) {
      return null;
    }
    var value = true;
    allowSpaces();
    if (source[i] === "=") {
      i += 1;
      allowSpaces();
      value = getAttributeValue();
      if (!isNaN(value) && value.trim() !== "") {
        value = +value;
      }
    }
    return { name, value };
  }
  function getAttributeValue() {
    return quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();
  }
  function getUnquotedAttributeValue() {
    var value = "";
    do {
      var char = source[i];
      if (char === " " || char === ">" || char === "/") {
        return value;
      }
      value += char;
      i += 1;
    } while (i < source.length);
    return value;
  }
  function getQuotedAttributeValue() {
    var quotemark2 = source[i++];
    var value = "";
    var escaped = false;
    while (i < source.length) {
      var char = source[i++];
      if (char === quotemark2 && !escaped) {
        return value;
      }
      if (char === "\\" && !escaped) {
        escaped = true;
      }
      value += escaped ? "\\" + char : char;
      escaped = false;
    }
  }
  function allowSpaces() {
    while (i < source.length && whitespace.test(source[i])) {
      i += 1;
    }
  }
  var i = metadata.length;
  while (i < source.length) {
    if (!state) {
      error("Unexpected character");
    }
    state = state();
    i += 1;
  }
  if (state !== neutral) {
    error("Unexpected end of input");
  }
  if (root.tagName === "svg") {
    root.metadata = header;
  }
  return {
    type: "root",
    children: [root]
  };
}

// node_modules/@allmaps/stdlib/dist/svg.js
function isSvgCircle(input) {
  return input.type === "circle";
}
function isSvgLine(input) {
  return input.type === "line";
}
function isSvgPolyLine(input) {
  return input.type === "polyline";
}
function isSvgRect(input) {
  return input.type === "rect";
}
function isSvgPolygon(input) {
  return input.type === "polygon";
}
function* stringToSvgGeometriesGenerator(svg) {
  function* helper(node) {
    if ("children" in node) {
      for (const childNode of node.children) {
        if (typeof childNode !== "string") {
          yield* helper(childNode);
        }
      }
    }
    yield node;
  }
  const parsedSvg = parse(svg);
  for (const node of helper(parsedSvg)) {
    if ("tagName" in node) {
      if (node.tagName !== "svg" && node.tagName !== "g") {
        const geometry = getNodeSvgGeometry(node);
        if (geometry) {
          yield geometry;
        }
      }
    }
  }
}
function getNodeSvgGeometry(node) {
  const tag = node?.tagName?.toLowerCase();
  if (tag === "circle") {
    return {
      type: "circle",
      coordinates: [
        getNodeNumberProperty(node, "cx"),
        getNodeNumberProperty(node, "cy")
      ]
    };
  } else if (tag === "line") {
    return {
      type: "line",
      coordinates: [
        [getNodeNumberProperty(node, "x1"), getNodeNumberProperty(node, "y1")],
        [getNodeNumberProperty(node, "x2"), getNodeNumberProperty(node, "y2")]
      ]
    };
  } else if (tag === "polyline") {
    return {
      type: "polyline",
      coordinates: getNodePoints(node)
    };
  } else if (tag === "polygon") {
    return {
      type: "polygon",
      coordinates: getNodePoints(node)
    };
  } else if (tag === "rect") {
    return {
      type: "rect",
      coordinates: [
        [getNodeNumberProperty(node, "x"), getNodeNumberProperty(node, "y")],
        [
          getNodeNumberProperty(node, "x") + getNodeNumberProperty(node, "width"),
          getNodeNumberProperty(node, "y")
        ],
        [
          getNodeNumberProperty(node, "x") + getNodeNumberProperty(node, "width"),
          getNodeNumberProperty(node, "y") + getNodeNumberProperty(node, "height")
        ],
        [
          getNodeNumberProperty(node, "x"),
          getNodeNumberProperty(node, "y") + getNodeNumberProperty(node, "height")
        ],
        [getNodeNumberProperty(node, "x"), getNodeNumberProperty(node, "y")]
      ]
    };
  } else {
    throw new Error(`Unsupported SVG element: ${tag}`);
  }
}
function getNodeNumberProperty(node, prop) {
  const value = node?.properties?.[prop];
  return Number(value) || 0;
}
function getNodePoints(node) {
  const points = node?.properties?.points;
  if (points) {
    return String(points).trim().split(/\s+/).map((coordStr) => {
      const coord = coordStr.split(",").map((numberStr) => Number(numberStr));
      return [coord[0], coord[1]];
    });
  }
  return [];
}
function pointsToString(coordinates) {
  return coordinates.map((coordinate) => coordinate.join(",")).join(" ");
}
function svgGeometriesToSvgString(geometries) {
  return `<svg xmlns="http://www.w3.org/2000/svg">
  ${geometries.map(svgGeometryToString).join("\n")}
</svg>`;
}
function svgGeometryToString(geometry) {
  if (geometry.type === "circle") {
    return elementToString("circle", {
      ...geometry.attributes,
      cx: geometry.coordinates[0],
      cy: geometry.coordinates[1]
    });
  } else if (geometry.type === "line") {
    return elementToString("line", {
      ...geometry.attributes,
      x1: geometry.coordinates[0][0],
      y1: geometry.coordinates[0][1],
      x2: geometry.coordinates[1][0],
      y2: geometry.coordinates[1][1]
    });
  } else if (geometry.type === "polyline") {
    return elementToString("polyline", {
      ...geometry.attributes,
      points: pointsToString(geometry.coordinates)
    });
  } else if (geometry.type === "polygon") {
    return elementToString("polygon", {
      ...geometry.attributes,
      points: pointsToString(geometry.coordinates)
    });
  } else if (geometry.type === "rect") {
    return elementToString("rect", {
      ...geometry.attributes,
      x: geometry.coordinates[0][0],
      y: geometry.coordinates[0][1],
      width: geometry.coordinates[1][0] - geometry.coordinates[0][0],
      height: geometry.coordinates[2][1] - geometry.coordinates[0][1]
    });
  } else {
    throw new Error("Unknown SVG element");
  }
}
function elementToString(tag, attributes) {
  const attributeStrings = Object.entries(attributes).map(([key, value]) => `${key}="${value}"`);
  return `<${tag} ${attributeStrings.join(" ")} />`;
}
function mapToResourceMaskSvgPolygon(map) {
  return {
    type: "polygon",
    attributes: {
      "data-image-id": encodeURIComponent(map.resource.id)
    },
    coordinates: map.resourceMask
  };
}
function svgGeometryToGeometry(svgGeometry) {
  if (isSvgCircle(svgGeometry)) {
    return svgGeometry.coordinates;
  } else if (isSvgLine(svgGeometry)) {
    return svgGeometry.coordinates;
  } else if (isSvgPolyLine(svgGeometry)) {
    return svgGeometry.coordinates;
  } else if (isSvgRect(svgGeometry)) {
    return [svgGeometry.coordinates];
  } else if (isSvgPolygon(svgGeometry)) {
    return [svgGeometry.coordinates];
  } else {
    throw new Error(`Unsupported SVG geometry`);
  }
}

// node_modules/@allmaps/stdlib/dist/self-intersect.js
var EPSILON = 0;
function polygonSelfIntersectionPoints(polygon, options) {
  const intersectionPoints = [];
  polygon = conformPolygon(polygon);
  polygon = polygon.map((ring) => [...ring, ring[0]]);
  for (let ringIndex0 = 0; ringIndex0 < polygon.length; ringIndex0++) {
    for (let lineIndex0 = 0; lineIndex0 < polygon[ringIndex0].length - 1; lineIndex0++) {
      for (let ringIndex1 = ringIndex0; ringIndex1 < polygon.length; ringIndex1++) {
        for (let lineIndex1 = lineIndex0 + 1; lineIndex1 < polygon[ringIndex1].length - 1; lineIndex1++) {
          const line0 = [
            polygon[ringIndex0][lineIndex0],
            polygon[ringIndex0][lineIndex0 + 1]
          ];
          const line1 = [
            polygon[ringIndex1][lineIndex1],
            polygon[ringIndex1][lineIndex1 + 1]
          ];
          const intersectionPoint = linesIntersectionPoint(line0, line1, options);
          if (intersectionPoint) {
            intersectionPoints.push(intersectionPoint);
          }
        }
      }
    }
  }
  const selfIntersectionPoints = arrayDifference(intersectionPoints, polygon.flat(), isEqualPoint);
  return arrayUnique(selfIntersectionPoints, isEqualPoint);
}
function linesIntersectionPoint(line0, line1, options) {
  options = {
    reportVertexOnVertex: false,
    reportVertexOnEdge: false,
    ...options
  };
  const intersectionPoint = prolongedLinesIntersectionPoint(line0, line1);
  if (intersectionPoint === void 0)
    return void 0;
  let frac0, frac1;
  if (line0[1][0] != line0[0][0]) {
    frac0 = (intersectionPoint[0] - line0[0][0]) / (line0[1][0] - line0[0][0]);
  } else {
    frac0 = (intersectionPoint[1] - line0[0][1]) / (line0[1][1] - line0[0][1]);
  }
  if (line1[1][0] != line1[0][0]) {
    frac1 = (intersectionPoint[0] - line1[0][0]) / (line1[1][0] - line1[0][0]);
  } else {
    frac1 = (intersectionPoint[1] - line1[0][1]) / (line1[1][1] - line1[0][1]);
  }
  if (isOutside(frac0, options.epsilon) || isOutside(frac1, options.epsilon)) {
    return void 0;
  }
  if (options.reportVertexOnVertex && isBoundaryCase(frac0, options.epsilon) && isBoundaryCase(frac1, options.epsilon)) {
    return intersectionPoint;
  }
  if (options.reportVertexOnEdge && (isBoundaryCase(frac0, options.epsilon) || isBoundaryCase(frac1, options.epsilon))) {
    return intersectionPoint;
  }
  return intersectionPoint;
}
function prolongedLinesIntersectionPoint(line0, line1) {
  const denom = (line0[0][0] - line0[1][0]) * (line1[0][1] - line1[1][1]) - (line0[0][1] - line0[1][1]) * (line1[0][0] - line1[1][0]);
  if (denom === 0)
    return void 0;
  const x = ((line0[0][0] * line0[1][1] - line0[0][1] * line0[1][0]) * (line1[0][0] - line1[1][0]) - (line0[0][0] - line0[1][0]) * (line1[0][0] * line1[1][1] - line1[0][1] * line1[1][0])) / denom;
  const y = ((line0[0][0] * line0[1][1] - line0[0][1] * line0[1][0]) * (line1[0][1] - line1[1][1]) - (line0[0][1] - line0[1][1]) * (line1[0][0] * line1[1][1] - line1[0][1] * line1[1][0])) / denom;
  return [x, y];
}
function isBoundaryCase(fraction, epsilon) {
  epsilon = epsilon || EPSILON;
  const e2 = epsilon * epsilon;
  return e2 >= (fraction - 1) * (fraction - 1) || e2 >= fraction * fraction;
}
function isOutside(fraction, epsilon) {
  epsilon = epsilon || EPSILON;
  return fraction < 0 - epsilon || fraction > 1 + epsilon;
}

export {
  fetchUrl,
  fetchJson,
  fetchImageInfo,
  fetchImageBitmap,
  fetchAnnotationsFromApi,
  getImageData,
  getColorsArray,
  getColorHistogram,
  getMaxOccurringColor,
  point,
  radiansToLength,
  lengthToRadians,
  radiansToDegrees,
  degreesToRadians,
  getCoord,
  isPoint,
  isLineString,
  isRing,
  isPolygon,
  isMultiPoint,
  isMultiLineString,
  isMultiPolygon,
  isGeometry,
  closeRing,
  uncloseRing,
  closePolygon,
  unclosePolygon,
  closeMultiPolygon,
  uncloseMultiPolygon,
  conformLineString,
  conformRing,
  conformPolygon,
  conformMultiLineString,
  conformMultiPolygon,
  pointToGeojsonPoint,
  lineStringToGeojsonLineString,
  ringToGeojsonPolygon,
  polygonToGeojsonPolygon,
  multiPointToGeojsonMultiPoint,
  multiLineStringToGeojsonMultiLineString,
  multiPolygonToGeojsonMultiPolygon,
  geometryToGeojsonGeometry,
  geometryToSvgGeometry,
  isClosed,
  isEqualPoint,
  isEqualPointArray,
  isEqualPointArrayArray,
  pointsAndPointsToLines,
  lineStringToLines,
  pointToPixel,
  pixelToIntArrayIndex,
  flipX,
  flipY,
  mixNumbers,
  mixPoints,
  midPoint,
  lineAngle,
  stepDistanceAngle,
  distance,
  squaredDistance,
  rms,
  triangleArea,
  invertPoint,
  invertPoints,
  scalePoint,
  scalePoints,
  translatePoint,
  translatePoints,
  rotatePoint,
  rotatePoints,
  triangleAngles,
  threePointsToAngle,
  isGeojsonPoint,
  isGeojsonLineString,
  isGeojsonPolygon,
  isGeojsonMultiPoint,
  isGeojsonMultiLineString,
  isGeojsonMultiPolygon,
  isGeojsonGeometry,
  isGeojsonMultiGeometry,
  geojsonPointToPoint,
  geojsonLineStringToLineString,
  geojsonPolygonToRing,
  geojsonPolygonToPolygon,
  geojsonMultiPointToMultiPoint,
  geojsonMultiLineStringToMultiLineString,
  geojsonMultiPolygonToMultiPolygon,
  geojsonGeometryToGeometry,
  geojsonGeometryToSvgGeometry,
  geojsonGeometryToGeojsonFeature,
  geojsonFeaturesToGeojsonFeatureCollection,
  geojsonGeometriesToGeojsonFeatureCollection,
  geojsonFeatureToGeojsonGeometry,
  geojsonFeatureCollectionToGeojsonGeometries,
  expandGeojsonMultiPointToGeojsonPoints,
  expandGeojsonMultiLineStringToGeojsonLineStrings,
  expandGeojsonMultiPolygonToGeojsonPolygons,
  expandGeojsonMultiGeometryToGeojsonGeometries,
  contractGeojsonPointsToGeojsonMultiPoint,
  contractGeojsonLineStringsToGeojsonMultiLineString,
  contractGeojsonPolygonsToGeojsonMultiPolygon,
  contractGeojsonGeometriesToGeojsonMultiGeometry,
  mergeGeojsonFeaturesCollections,
  computeMinMax,
  computeBbox,
  combineBboxes,
  doBboxesIntersect,
  intersectBboxes,
  pointInBbox,
  bufferBbox,
  bufferBboxByRatio,
  bboxToRectangle,
  bboxToPolygon,
  bboxToLine,
  bboxToDiameter,
  geometryToDiameter,
  bboxToCenter,
  bboxToSize,
  bboxToResolution,
  rectangleToSize,
  convexHull,
  sizesToScale,
  scaleSize,
  sizeToResolution,
  sizeToCenter,
  sizeToBbox,
  sizeToRectangle,
  bboxesToScale,
  rectanglesToScale,
  getPropertyFromCacheOrComputation,
  getPropertyFromDoubleCacheOrComputation,
  getPropertyFromTripleCacheOrComputation,
  rgbToHex,
  rgbaToHex,
  hexToRgb,
  hexToRgba,
  hexToOpaqueRgba,
  hexToFractionalRgb,
  hexToFractionalRgba,
  hexToFractionalOpaqueRgba,
  degreesToRadians2,
  groupBy,
  isEqualArray,
  arrayRepeated,
  subSetArray,
  equalSet,
  maxOfNumberOrUndefined,
  isValidHttpUrl,
  getFullResourceMask,
  newArrayMatrix,
  arrayMatrixSize,
  shallowCopyArrayMatrix,
  sliceArrayMatrix,
  subArrayMatrix,
  multiplyArrayMatrix,
  pasteArrayMatrix,
  transposeArrayMatrix,
  newBlockArrayMatrix,
  mergeOptions,
  mergeOptionsUnlessUndefined,
  mergePartialOptions,
  isSvgCircle,
  isSvgLine,
  isSvgPolyLine,
  isSvgRect,
  isSvgPolygon,
  stringToSvgGeometriesGenerator,
  svgGeometriesToSvgString,
  svgGeometryToString,
  mapToResourceMaskSvgPolygon,
  svgGeometryToGeometry,
  polygonSelfIntersectionPoints,
  linesIntersectionPoint,
  prolongedLinesIntersectionPoint
};
//# sourceMappingURL=chunk-U7Q5B5EM.js.map
