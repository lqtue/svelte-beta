import {
  arrayMatrixSize,
  bboxToCenter,
  bboxToRectangle,
  bboxToSize,
  bufferBboxByRatio,
  closePolygon,
  closeRing,
  computeBbox,
  conformLineString,
  conformPolygon,
  conformRing,
  convexHull,
  degreesToRadians,
  distance,
  doBboxesIntersect,
  equalSet,
  fetchImageInfo,
  flipY,
  geojsonFeatureCollectionToGeojsonGeometries,
  geojsonGeometriesToGeojsonFeatureCollection,
  geojsonGeometryToGeometry,
  geometryToGeojsonGeometry,
  geometryToSvgGeometry,
  getCoord,
  getPropertyFromCacheOrComputation,
  getPropertyFromTripleCacheOrComputation,
  hexToFractionalOpaqueRgba,
  hexToFractionalRgb,
  intersectBboxes,
  isLineString,
  isMultiLineString,
  isMultiPoint,
  isMultiPolygon,
  isPoint,
  isPolygon,
  lengthToRadians,
  lineAngle,
  lineStringToLines,
  maxOfNumberOrUndefined,
  mergeOptions,
  mergeOptionsUnlessUndefined,
  mergePartialOptions,
  midPoint,
  mixNumbers,
  mixPoints,
  newArrayMatrix,
  newBlockArrayMatrix,
  pasteArrayMatrix,
  point,
  pointsAndPointsToLines,
  radiansToDegrees,
  radiansToLength,
  rectanglesToScale,
  rms,
  rotatePoint,
  rotatePoints,
  scalePoint,
  scalePoints,
  scaleSize,
  sizeToBbox,
  sizeToCenter,
  sizeToRectangle,
  sizeToResolution,
  sizesToScale,
  squaredDistance,
  stepDistanceAngle,
  stringToSvgGeometriesGenerator,
  subSetArray,
  svgGeometriesToSvgString,
  svgGeometryToGeometry,
  translatePoints,
  transposeArrayMatrix,
  triangleAngles
} from "./chunk-U7Q5B5EM.js";
import {
  Image as Image2,
  external_exports
} from "./chunk-WNZSJ6TY.js";
import {
  RBush
} from "./chunk-RW3V7S4F.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/is-any-array/lib-esm/index.js
var lib_esm_exports = {};
__export(lib_esm_exports, {
  isAnyArray: () => isAnyArray
});
function isAnyArray(value) {
  const tag = toString2.call(value);
  return tag.endsWith("Array]") && !tag.includes("Big");
}
var toString2;
var init_lib_esm = __esm({
  "node_modules/is-any-array/lib-esm/index.js"() {
    toString2 = Object.prototype.toString;
  }
});

// node_modules/ml-array-max/lib-es6/index.js
function max2(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var maxValue = input[fromIndex];
  for (var i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] > maxValue) maxValue = input[i];
  }
  return maxValue;
}
var init_lib_es6 = __esm({
  "node_modules/ml-array-max/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-min/lib-es6/index.js
function min2(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var minValue = input[fromIndex];
  for (var i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] < minValue) minValue = input[i];
  }
  return minValue;
}
var init_lib_es62 = __esm({
  "node_modules/ml-array-min/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-rescale/lib-es6/index.js
var lib_es6_exports = {};
__export(lib_es6_exports, {
  default: () => rescale
});
function rescale(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  } else if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var output;
  if (options.output !== void 0) {
    if (!isAnyArray(options.output)) {
      throw new TypeError("output option must be an array if specified");
    }
    output = options.output;
  } else {
    output = new Array(input.length);
  }
  var currentMin = min2(input);
  var currentMax = max2(input);
  if (currentMin === currentMax) {
    throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");
  }
  var _options$min = options.min, minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min, _options$max = options.max, maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;
  if (minValue >= maxValue) {
    throw new RangeError("min option must be smaller than max option");
  }
  var factor = (maxValue - minValue) / (currentMax - currentMin);
  for (var i = 0; i < input.length; i++) {
    output[i] = (input[i] - currentMin) * factor + minValue;
  }
  return output;
}
var init_lib_es63 = __esm({
  "node_modules/ml-array-rescale/lib-es6/index.js"() {
    init_lib_esm();
    init_lib_es6();
    init_lib_es62();
  }
});

// node_modules/ml-matrix/matrix.js
var require_matrix = __commonJS({
  "node_modules/ml-matrix/matrix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isAnyArray2 = (init_lib_esm(), __toCommonJS(lib_esm_exports));
    var rescale2 = (init_lib_es63(), __toCommonJS(lib_es6_exports));
    var indent = " ".repeat(2);
    var indentData = " ".repeat(4);
    function inspectMatrix() {
      return inspectMatrixWithOptions(this);
    }
    function inspectMatrixWithOptions(matrix2, options = {}) {
      const {
        maxRows = 15,
        maxColumns = 10,
        maxNumSize = 8,
        padMinus = "auto"
      } = options;
      return `${matrix2.constructor.name} {
${indent}[
${indentData}${inspectData(matrix2, maxRows, maxColumns, maxNumSize, padMinus)}
${indent}]
${indent}rows: ${matrix2.rows}
${indent}columns: ${matrix2.columns}
}`;
    }
    function inspectData(matrix2, maxRows, maxColumns, maxNumSize, padMinus) {
      const { rows, columns } = matrix2;
      const maxI = Math.min(rows, maxRows);
      const maxJ = Math.min(columns, maxColumns);
      const result2 = [];
      if (padMinus === "auto") {
        padMinus = false;
        loop: for (let i = 0; i < maxI; i++) {
          for (let j = 0; j < maxJ; j++) {
            if (matrix2.get(i, j) < 0) {
              padMinus = true;
              break loop;
            }
          }
        }
      }
      for (let i = 0; i < maxI; i++) {
        let line = [];
        for (let j = 0; j < maxJ; j++) {
          line.push(formatNumber(matrix2.get(i, j), maxNumSize, padMinus));
        }
        result2.push(`${line.join(" ")}`);
      }
      if (maxJ !== columns) {
        result2[result2.length - 1] += ` ... ${columns - maxColumns} more columns`;
      }
      if (maxI !== rows) {
        result2.push(`... ${rows - maxRows} more rows`);
      }
      return result2.join(`
${indentData}`);
    }
    function formatNumber(num, maxNumSize, padMinus) {
      return (num >= 0 && padMinus ? ` ${formatNumber2(num, maxNumSize - 1)}` : formatNumber2(num, maxNumSize)).padEnd(maxNumSize);
    }
    function formatNumber2(num, len) {
      let str = num.toString();
      if (str.length <= len) return str;
      let fix = num.toFixed(len);
      if (fix.length > len) {
        fix = num.toFixed(Math.max(0, len - (fix.length - len)));
      }
      if (fix.length <= len && !fix.startsWith("0.000") && !fix.startsWith("-0.000")) {
        return fix;
      }
      let exp = num.toExponential(len);
      if (exp.length > len) {
        exp = num.toExponential(Math.max(0, len - (exp.length - len)));
      }
      return exp.slice(0);
    }
    function installMathOperations(AbstractMatrix3, Matrix3) {
      AbstractMatrix3.prototype.add = function add6(value) {
        if (typeof value === "number") return this.addS(value);
        return this.addM(value);
      };
      AbstractMatrix3.prototype.addS = function addS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) + value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.addM = function addM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) + matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.add = function add6(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.add(value);
      };
      AbstractMatrix3.prototype.sub = function sub(value) {
        if (typeof value === "number") return this.subS(value);
        return this.subM(value);
      };
      AbstractMatrix3.prototype.subS = function subS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) - value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.subM = function subM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) - matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.sub = function sub(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.sub(value);
      };
      AbstractMatrix3.prototype.subtract = AbstractMatrix3.prototype.sub;
      AbstractMatrix3.prototype.subtractS = AbstractMatrix3.prototype.subS;
      AbstractMatrix3.prototype.subtractM = AbstractMatrix3.prototype.subM;
      AbstractMatrix3.subtract = AbstractMatrix3.sub;
      AbstractMatrix3.prototype.mul = function mul(value) {
        if (typeof value === "number") return this.mulS(value);
        return this.mulM(value);
      };
      AbstractMatrix3.prototype.mulS = function mulS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) * value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.mulM = function mulM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) * matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.mul = function mul(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.mul(value);
      };
      AbstractMatrix3.prototype.multiply = AbstractMatrix3.prototype.mul;
      AbstractMatrix3.prototype.multiplyS = AbstractMatrix3.prototype.mulS;
      AbstractMatrix3.prototype.multiplyM = AbstractMatrix3.prototype.mulM;
      AbstractMatrix3.multiply = AbstractMatrix3.mul;
      AbstractMatrix3.prototype.div = function div(value) {
        if (typeof value === "number") return this.divS(value);
        return this.divM(value);
      };
      AbstractMatrix3.prototype.divS = function divS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) / value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.divM = function divM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) / matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.div = function div(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.div(value);
      };
      AbstractMatrix3.prototype.divide = AbstractMatrix3.prototype.div;
      AbstractMatrix3.prototype.divideS = AbstractMatrix3.prototype.divS;
      AbstractMatrix3.prototype.divideM = AbstractMatrix3.prototype.divM;
      AbstractMatrix3.divide = AbstractMatrix3.div;
      AbstractMatrix3.prototype.mod = function mod(value) {
        if (typeof value === "number") return this.modS(value);
        return this.modM(value);
      };
      AbstractMatrix3.prototype.modS = function modS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) % value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.modM = function modM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) % matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.mod = function mod(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.mod(value);
      };
      AbstractMatrix3.prototype.modulus = AbstractMatrix3.prototype.mod;
      AbstractMatrix3.prototype.modulusS = AbstractMatrix3.prototype.modS;
      AbstractMatrix3.prototype.modulusM = AbstractMatrix3.prototype.modM;
      AbstractMatrix3.modulus = AbstractMatrix3.mod;
      AbstractMatrix3.prototype.and = function and(value) {
        if (typeof value === "number") return this.andS(value);
        return this.andM(value);
      };
      AbstractMatrix3.prototype.andS = function andS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) & value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.andM = function andM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) & matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.and = function and(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.and(value);
      };
      AbstractMatrix3.prototype.or = function or(value) {
        if (typeof value === "number") return this.orS(value);
        return this.orM(value);
      };
      AbstractMatrix3.prototype.orS = function orS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) | value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.orM = function orM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) | matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.or = function or(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.or(value);
      };
      AbstractMatrix3.prototype.xor = function xor2(value) {
        if (typeof value === "number") return this.xorS(value);
        return this.xorM(value);
      };
      AbstractMatrix3.prototype.xorS = function xorS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) ^ value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.xorM = function xorM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) ^ matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.xor = function xor2(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.xor(value);
      };
      AbstractMatrix3.prototype.leftShift = function leftShift(value) {
        if (typeof value === "number") return this.leftShiftS(value);
        return this.leftShiftM(value);
      };
      AbstractMatrix3.prototype.leftShiftS = function leftShiftS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) << value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.leftShiftM = function leftShiftM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) << matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.leftShift = function leftShift(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.leftShift(value);
      };
      AbstractMatrix3.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
        if (typeof value === "number") return this.signPropagatingRightShiftS(value);
        return this.signPropagatingRightShiftM(value);
      };
      AbstractMatrix3.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) >> value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) >> matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.signPropagatingRightShift = function signPropagatingRightShift(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.signPropagatingRightShift(value);
      };
      AbstractMatrix3.prototype.rightShift = function rightShift(value) {
        if (typeof value === "number") return this.rightShiftS(value);
        return this.rightShiftM(value);
      };
      AbstractMatrix3.prototype.rightShiftS = function rightShiftS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) >>> value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.rightShiftM = function rightShiftM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) >>> matrix2.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.rightShift = function rightShift(matrix2, value) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.rightShift(value);
      };
      AbstractMatrix3.prototype.zeroFillRightShift = AbstractMatrix3.prototype.rightShift;
      AbstractMatrix3.prototype.zeroFillRightShiftS = AbstractMatrix3.prototype.rightShiftS;
      AbstractMatrix3.prototype.zeroFillRightShiftM = AbstractMatrix3.prototype.rightShiftM;
      AbstractMatrix3.zeroFillRightShift = AbstractMatrix3.rightShift;
      AbstractMatrix3.prototype.not = function not() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, ~this.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix3.not = function not(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.not();
      };
      AbstractMatrix3.prototype.abs = function abs() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.abs(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.abs = function abs(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.abs();
      };
      AbstractMatrix3.prototype.acos = function acos() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.acos(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.acos = function acos(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.acos();
      };
      AbstractMatrix3.prototype.acosh = function acosh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.acosh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.acosh = function acosh(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.acosh();
      };
      AbstractMatrix3.prototype.asin = function asin() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.asin(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.asin = function asin(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.asin();
      };
      AbstractMatrix3.prototype.asinh = function asinh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.asinh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.asinh = function asinh(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.asinh();
      };
      AbstractMatrix3.prototype.atan = function atan() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.atan(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.atan = function atan(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.atan();
      };
      AbstractMatrix3.prototype.atanh = function atanh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.atanh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.atanh = function atanh(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.atanh();
      };
      AbstractMatrix3.prototype.cbrt = function cbrt() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.cbrt(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.cbrt = function cbrt(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.cbrt();
      };
      AbstractMatrix3.prototype.ceil = function ceil2() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.ceil(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.ceil = function ceil2(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.ceil();
      };
      AbstractMatrix3.prototype.clz32 = function clz32() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.clz32(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.clz32 = function clz32(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.clz32();
      };
      AbstractMatrix3.prototype.cos = function cos() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.cos(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.cos = function cos(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.cos();
      };
      AbstractMatrix3.prototype.cosh = function cosh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.cosh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.cosh = function cosh(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.cosh();
      };
      AbstractMatrix3.prototype.exp = function exp() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.exp(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.exp = function exp(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.exp();
      };
      AbstractMatrix3.prototype.expm1 = function expm1() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.expm1(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.expm1 = function expm1(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.expm1();
      };
      AbstractMatrix3.prototype.floor = function floor2() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.floor(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.floor = function floor2(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.floor();
      };
      AbstractMatrix3.prototype.fround = function fround() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.fround(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.fround = function fround(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.fround();
      };
      AbstractMatrix3.prototype.log = function log() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.log(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.log = function log(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.log();
      };
      AbstractMatrix3.prototype.log1p = function log1p() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.log1p(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.log1p = function log1p(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.log1p();
      };
      AbstractMatrix3.prototype.log10 = function log10() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.log10(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.log10 = function log10(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.log10();
      };
      AbstractMatrix3.prototype.log2 = function log2() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.log2(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.log2 = function log2(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.log2();
      };
      AbstractMatrix3.prototype.round = function round2() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.round(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.round = function round2(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.round();
      };
      AbstractMatrix3.prototype.sign = function sign() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.sign(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.sign = function sign(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.sign();
      };
      AbstractMatrix3.prototype.sin = function sin() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.sin(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.sin = function sin(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.sin();
      };
      AbstractMatrix3.prototype.sinh = function sinh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.sinh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.sinh = function sinh(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.sinh();
      };
      AbstractMatrix3.prototype.sqrt = function sqrt() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.sqrt(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.sqrt = function sqrt(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.sqrt();
      };
      AbstractMatrix3.prototype.tan = function tan() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.tan(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.tan = function tan(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.tan();
      };
      AbstractMatrix3.prototype.tanh = function tanh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.tanh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.tanh = function tanh(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.tanh();
      };
      AbstractMatrix3.prototype.trunc = function trunc() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.trunc(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix3.trunc = function trunc(matrix2) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.trunc();
      };
      AbstractMatrix3.pow = function pow(matrix2, arg0) {
        const newMatrix = new Matrix3(matrix2);
        return newMatrix.pow(arg0);
      };
      AbstractMatrix3.prototype.pow = function pow(value) {
        if (typeof value === "number") return this.powS(value);
        return this.powM(value);
      };
      AbstractMatrix3.prototype.powS = function powS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) ** value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.powM = function powM(matrix2) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) ** matrix2.get(i, j));
          }
        }
        return this;
      };
    }
    function checkRowIndex(matrix2, index, outer) {
      let max3 = outer ? matrix2.rows : matrix2.rows - 1;
      if (index < 0 || index > max3) {
        throw new RangeError("Row index out of range");
      }
    }
    function checkColumnIndex(matrix2, index, outer) {
      let max3 = outer ? matrix2.columns : matrix2.columns - 1;
      if (index < 0 || index > max3) {
        throw new RangeError("Column index out of range");
      }
    }
    function checkRowVector(matrix2, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix2.columns) {
        throw new RangeError(
          "vector size must be the same as the number of columns"
        );
      }
      return vector;
    }
    function checkColumnVector(matrix2, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix2.rows) {
        throw new RangeError("vector size must be the same as the number of rows");
      }
      return vector;
    }
    function checkRowIndices(matrix2, rowIndices) {
      if (!isAnyArray2.isAnyArray(rowIndices)) {
        throw new TypeError("row indices must be an array");
      }
      for (let i = 0; i < rowIndices.length; i++) {
        if (rowIndices[i] < 0 || rowIndices[i] >= matrix2.rows) {
          throw new RangeError("row indices are out of range");
        }
      }
    }
    function checkColumnIndices(matrix2, columnIndices) {
      if (!isAnyArray2.isAnyArray(columnIndices)) {
        throw new TypeError("column indices must be an array");
      }
      for (let i = 0; i < columnIndices.length; i++) {
        if (columnIndices[i] < 0 || columnIndices[i] >= matrix2.columns) {
          throw new RangeError("column indices are out of range");
        }
      }
    }
    function checkRange(matrix2, startRow, endRow, startColumn, endColumn) {
      if (arguments.length !== 5) {
        throw new RangeError("expected 4 arguments");
      }
      checkNumber("startRow", startRow);
      checkNumber("endRow", endRow);
      checkNumber("startColumn", startColumn);
      checkNumber("endColumn", endColumn);
      if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix2.rows || endRow < 0 || endRow >= matrix2.rows || startColumn < 0 || startColumn >= matrix2.columns || endColumn < 0 || endColumn >= matrix2.columns) {
        throw new RangeError("Submatrix indices are out of range");
      }
    }
    function newArray(length, value = 0) {
      let array = [];
      for (let i = 0; i < length; i++) {
        array.push(value);
      }
      return array;
    }
    function checkNumber(name, value) {
      if (typeof value !== "number") {
        throw new TypeError(`${name} must be a number`);
      }
    }
    function checkNonEmpty(matrix2) {
      if (matrix2.isEmpty()) {
        throw new Error("Empty matrix has no elements to index");
      }
    }
    function sumByRow(matrix2) {
      let sum3 = newArray(matrix2.rows);
      for (let i = 0; i < matrix2.rows; ++i) {
        for (let j = 0; j < matrix2.columns; ++j) {
          sum3[i] += matrix2.get(i, j);
        }
      }
      return sum3;
    }
    function sumByColumn(matrix2) {
      let sum3 = newArray(matrix2.columns);
      for (let i = 0; i < matrix2.rows; ++i) {
        for (let j = 0; j < matrix2.columns; ++j) {
          sum3[j] += matrix2.get(i, j);
        }
      }
      return sum3;
    }
    function sumAll(matrix2) {
      let v2 = 0;
      for (let i = 0; i < matrix2.rows; i++) {
        for (let j = 0; j < matrix2.columns; j++) {
          v2 += matrix2.get(i, j);
        }
      }
      return v2;
    }
    function productByRow(matrix2) {
      let sum3 = newArray(matrix2.rows, 1);
      for (let i = 0; i < matrix2.rows; ++i) {
        for (let j = 0; j < matrix2.columns; ++j) {
          sum3[i] *= matrix2.get(i, j);
        }
      }
      return sum3;
    }
    function productByColumn(matrix2) {
      let sum3 = newArray(matrix2.columns, 1);
      for (let i = 0; i < matrix2.rows; ++i) {
        for (let j = 0; j < matrix2.columns; ++j) {
          sum3[j] *= matrix2.get(i, j);
        }
      }
      return sum3;
    }
    function productAll(matrix2) {
      let v2 = 1;
      for (let i = 0; i < matrix2.rows; i++) {
        for (let j = 0; j < matrix2.columns; j++) {
          v2 *= matrix2.get(i, j);
        }
      }
      return v2;
    }
    function varianceByRow(matrix2, unbiased, mean2) {
      const rows = matrix2.rows;
      const cols = matrix2.columns;
      const variance = [];
      for (let i = 0; i < rows; i++) {
        let sum1 = 0;
        let sum22 = 0;
        let x = 0;
        for (let j = 0; j < cols; j++) {
          x = matrix2.get(i, j) - mean2[i];
          sum1 += x;
          sum22 += x * x;
        }
        if (unbiased) {
          variance.push((sum22 - sum1 * sum1 / cols) / (cols - 1));
        } else {
          variance.push((sum22 - sum1 * sum1 / cols) / cols);
        }
      }
      return variance;
    }
    function varianceByColumn(matrix2, unbiased, mean2) {
      const rows = matrix2.rows;
      const cols = matrix2.columns;
      const variance = [];
      for (let j = 0; j < cols; j++) {
        let sum1 = 0;
        let sum22 = 0;
        let x = 0;
        for (let i = 0; i < rows; i++) {
          x = matrix2.get(i, j) - mean2[j];
          sum1 += x;
          sum22 += x * x;
        }
        if (unbiased) {
          variance.push((sum22 - sum1 * sum1 / rows) / (rows - 1));
        } else {
          variance.push((sum22 - sum1 * sum1 / rows) / rows);
        }
      }
      return variance;
    }
    function varianceAll(matrix2, unbiased, mean2) {
      const rows = matrix2.rows;
      const cols = matrix2.columns;
      const size2 = rows * cols;
      let sum1 = 0;
      let sum22 = 0;
      let x = 0;
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          x = matrix2.get(i, j) - mean2;
          sum1 += x;
          sum22 += x * x;
        }
      }
      if (unbiased) {
        return (sum22 - sum1 * sum1 / size2) / (size2 - 1);
      } else {
        return (sum22 - sum1 * sum1 / size2) / size2;
      }
    }
    function centerByRow(matrix2, mean2) {
      for (let i = 0; i < matrix2.rows; i++) {
        for (let j = 0; j < matrix2.columns; j++) {
          matrix2.set(i, j, matrix2.get(i, j) - mean2[i]);
        }
      }
    }
    function centerByColumn(matrix2, mean2) {
      for (let i = 0; i < matrix2.rows; i++) {
        for (let j = 0; j < matrix2.columns; j++) {
          matrix2.set(i, j, matrix2.get(i, j) - mean2[j]);
        }
      }
    }
    function centerAll(matrix2, mean2) {
      for (let i = 0; i < matrix2.rows; i++) {
        for (let j = 0; j < matrix2.columns; j++) {
          matrix2.set(i, j, matrix2.get(i, j) - mean2);
        }
      }
    }
    function getScaleByRow(matrix2) {
      const scale3 = [];
      for (let i = 0; i < matrix2.rows; i++) {
        let sum3 = 0;
        for (let j = 0; j < matrix2.columns; j++) {
          sum3 += matrix2.get(i, j) ** 2 / (matrix2.columns - 1);
        }
        scale3.push(Math.sqrt(sum3));
      }
      return scale3;
    }
    function scaleByRow(matrix2, scale3) {
      for (let i = 0; i < matrix2.rows; i++) {
        for (let j = 0; j < matrix2.columns; j++) {
          matrix2.set(i, j, matrix2.get(i, j) / scale3[i]);
        }
      }
    }
    function getScaleByColumn(matrix2) {
      const scale3 = [];
      for (let j = 0; j < matrix2.columns; j++) {
        let sum3 = 0;
        for (let i = 0; i < matrix2.rows; i++) {
          sum3 += matrix2.get(i, j) ** 2 / (matrix2.rows - 1);
        }
        scale3.push(Math.sqrt(sum3));
      }
      return scale3;
    }
    function scaleByColumn(matrix2, scale3) {
      for (let i = 0; i < matrix2.rows; i++) {
        for (let j = 0; j < matrix2.columns; j++) {
          matrix2.set(i, j, matrix2.get(i, j) / scale3[j]);
        }
      }
    }
    function getScaleAll(matrix2) {
      const divider = matrix2.size - 1;
      let sum3 = 0;
      for (let j = 0; j < matrix2.columns; j++) {
        for (let i = 0; i < matrix2.rows; i++) {
          sum3 += matrix2.get(i, j) ** 2 / divider;
        }
      }
      return Math.sqrt(sum3);
    }
    function scaleAll(matrix2, scale3) {
      for (let i = 0; i < matrix2.rows; i++) {
        for (let j = 0; j < matrix2.columns; j++) {
          matrix2.set(i, j, matrix2.get(i, j) / scale3);
        }
      }
    }
    var AbstractMatrix2 = class _AbstractMatrix {
      static from1DArray(newRows, newColumns, newData) {
        let length = newRows * newColumns;
        if (length !== newData.length) {
          throw new RangeError("data length does not match given dimensions");
        }
        let newMatrix = new Matrix2(newRows, newColumns);
        for (let row = 0; row < newRows; row++) {
          for (let column = 0; column < newColumns; column++) {
            newMatrix.set(row, column, newData[row * newColumns + column]);
          }
        }
        return newMatrix;
      }
      static rowVector(newData) {
        let vector = new Matrix2(1, newData.length);
        for (let i = 0; i < newData.length; i++) {
          vector.set(0, i, newData[i]);
        }
        return vector;
      }
      static columnVector(newData) {
        let vector = new Matrix2(newData.length, 1);
        for (let i = 0; i < newData.length; i++) {
          vector.set(i, 0, newData[i]);
        }
        return vector;
      }
      static zeros(rows, columns) {
        return new Matrix2(rows, columns);
      }
      static ones(rows, columns) {
        return new Matrix2(rows, columns).fill(1);
      }
      static rand(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { random: random2 = Math.random } = options;
        let matrix2 = new Matrix2(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            matrix2.set(i, j, random2());
          }
        }
        return matrix2;
      }
      static randInt(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min3 = 0, max: max3 = 1e3, random: random2 = Math.random } = options;
        if (!Number.isInteger(min3)) throw new TypeError("min must be an integer");
        if (!Number.isInteger(max3)) throw new TypeError("max must be an integer");
        if (min3 >= max3) throw new RangeError("min must be smaller than max");
        let interval = max3 - min3;
        let matrix2 = new Matrix2(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            let value = min3 + Math.round(random2() * interval);
            matrix2.set(i, j, value);
          }
        }
        return matrix2;
      }
      static eye(rows, columns, value) {
        if (columns === void 0) columns = rows;
        if (value === void 0) value = 1;
        let min3 = Math.min(rows, columns);
        let matrix2 = this.zeros(rows, columns);
        for (let i = 0; i < min3; i++) {
          matrix2.set(i, i, value);
        }
        return matrix2;
      }
      static diag(data, rows, columns) {
        let l = data.length;
        if (rows === void 0) rows = l;
        if (columns === void 0) columns = rows;
        let min3 = Math.min(l, rows, columns);
        let matrix2 = this.zeros(rows, columns);
        for (let i = 0; i < min3; i++) {
          matrix2.set(i, i, data[i]);
        }
        return matrix2;
      }
      static min(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result2 = new Matrix2(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            result2.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
          }
        }
        return result2;
      }
      static max(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result2 = new this(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            result2.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
          }
        }
        return result2;
      }
      static checkMatrix(value) {
        return _AbstractMatrix.isMatrix(value) ? value : new Matrix2(value);
      }
      static isMatrix(value) {
        return value != null && value.klass === "Matrix";
      }
      get size() {
        return this.rows * this.columns;
      }
      apply(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            callback.call(this, i, j);
          }
        }
        return this;
      }
      to1DArray() {
        let array = [];
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            array.push(this.get(i, j));
          }
        }
        return array;
      }
      to2DArray() {
        let copy = [];
        for (let i = 0; i < this.rows; i++) {
          copy.push([]);
          for (let j = 0; j < this.columns; j++) {
            copy[i].push(this.get(i, j));
          }
        }
        return copy;
      }
      toJSON() {
        return this.to2DArray();
      }
      isRowVector() {
        return this.rows === 1;
      }
      isColumnVector() {
        return this.columns === 1;
      }
      isVector() {
        return this.rows === 1 || this.columns === 1;
      }
      isSquare() {
        return this.rows === this.columns;
      }
      isEmpty() {
        return this.rows === 0 || this.columns === 0;
      }
      isSymmetric() {
        if (this.isSquare()) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j <= i; j++) {
              if (this.get(i, j) !== this.get(j, i)) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      isDistance() {
        if (!this.isSymmetric()) return false;
        for (let i = 0; i < this.rows; i++) {
          if (this.get(i, i) !== 0) return false;
        }
        return true;
      }
      isEchelonForm() {
        let i = 0;
        let j = 0;
        let previousColumn = -1;
        let isEchelonForm = true;
        let checked = false;
        while (i < this.rows && isEchelonForm) {
          j = 0;
          checked = false;
          while (j < this.columns && checked === false) {
            if (this.get(i, j) === 0) {
              j++;
            } else if (this.get(i, j) === 1 && j > previousColumn) {
              checked = true;
              previousColumn = j;
            } else {
              isEchelonForm = false;
              checked = true;
            }
          }
          i++;
        }
        return isEchelonForm;
      }
      isReducedEchelonForm() {
        let i = 0;
        let j = 0;
        let previousColumn = -1;
        let isReducedEchelonForm = true;
        let checked = false;
        while (i < this.rows && isReducedEchelonForm) {
          j = 0;
          checked = false;
          while (j < this.columns && checked === false) {
            if (this.get(i, j) === 0) {
              j++;
            } else if (this.get(i, j) === 1 && j > previousColumn) {
              checked = true;
              previousColumn = j;
            } else {
              isReducedEchelonForm = false;
              checked = true;
            }
          }
          for (let k = j + 1; k < this.rows; k++) {
            if (this.get(i, k) !== 0) {
              isReducedEchelonForm = false;
            }
          }
          i++;
        }
        return isReducedEchelonForm;
      }
      echelonForm() {
        let result2 = this.clone();
        let h = 0;
        let k = 0;
        while (h < result2.rows && k < result2.columns) {
          let iMax = h;
          for (let i = h; i < result2.rows; i++) {
            if (result2.get(i, k) > result2.get(iMax, k)) {
              iMax = i;
            }
          }
          if (result2.get(iMax, k) === 0) {
            k++;
          } else {
            result2.swapRows(h, iMax);
            let tmp = result2.get(h, k);
            for (let j = k; j < result2.columns; j++) {
              result2.set(h, j, result2.get(h, j) / tmp);
            }
            for (let i = h + 1; i < result2.rows; i++) {
              let factor = result2.get(i, k) / result2.get(h, k);
              result2.set(i, k, 0);
              for (let j = k + 1; j < result2.columns; j++) {
                result2.set(i, j, result2.get(i, j) - result2.get(h, j) * factor);
              }
            }
            h++;
            k++;
          }
        }
        return result2;
      }
      reducedEchelonForm() {
        let result2 = this.echelonForm();
        let m = result2.columns;
        let n = result2.rows;
        let h = n - 1;
        while (h >= 0) {
          if (result2.maxRow(h) === 0) {
            h--;
          } else {
            let p = 0;
            let pivot = false;
            while (p < n && pivot === false) {
              if (result2.get(h, p) === 1) {
                pivot = true;
              } else {
                p++;
              }
            }
            for (let i = 0; i < h; i++) {
              let factor = result2.get(i, p);
              for (let j = p; j < m; j++) {
                let tmp = result2.get(i, j) - factor * result2.get(h, j);
                result2.set(i, j, tmp);
              }
            }
            h--;
          }
        }
        return result2;
      }
      set() {
        throw new Error("set method is unimplemented");
      }
      get() {
        throw new Error("get method is unimplemented");
      }
      repeat(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { rows = 1, columns = 1 } = options;
        if (!Number.isInteger(rows) || rows <= 0) {
          throw new TypeError("rows must be a positive integer");
        }
        if (!Number.isInteger(columns) || columns <= 0) {
          throw new TypeError("columns must be a positive integer");
        }
        let matrix2 = new Matrix2(this.rows * rows, this.columns * columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            matrix2.setSubMatrix(this, this.rows * i, this.columns * j);
          }
        }
        return matrix2;
      }
      fill(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, value);
          }
        }
        return this;
      }
      neg() {
        return this.mulS(-1);
      }
      getRow(index) {
        checkRowIndex(this, index);
        let row = [];
        for (let i = 0; i < this.columns; i++) {
          row.push(this.get(index, i));
        }
        return row;
      }
      getRowVector(index) {
        return Matrix2.rowVector(this.getRow(index));
      }
      setRow(index, array) {
        checkRowIndex(this, index);
        array = checkRowVector(this, array);
        for (let i = 0; i < this.columns; i++) {
          this.set(index, i, array[i]);
        }
        return this;
      }
      swapRows(row1, row2) {
        checkRowIndex(this, row1);
        checkRowIndex(this, row2);
        for (let i = 0; i < this.columns; i++) {
          let temp = this.get(row1, i);
          this.set(row1, i, this.get(row2, i));
          this.set(row2, i, temp);
        }
        return this;
      }
      getColumn(index) {
        checkColumnIndex(this, index);
        let column = [];
        for (let i = 0; i < this.rows; i++) {
          column.push(this.get(i, index));
        }
        return column;
      }
      getColumnVector(index) {
        return Matrix2.columnVector(this.getColumn(index));
      }
      setColumn(index, array) {
        checkColumnIndex(this, index);
        array = checkColumnVector(this, array);
        for (let i = 0; i < this.rows; i++) {
          this.set(i, index, array[i]);
        }
        return this;
      }
      swapColumns(column1, column2) {
        checkColumnIndex(this, column1);
        checkColumnIndex(this, column2);
        for (let i = 0; i < this.rows; i++) {
          let temp = this.get(i, column1);
          this.set(i, column1, this.get(i, column2));
          this.set(i, column2, temp);
        }
        return this;
      }
      addRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) + vector[j]);
          }
        }
        return this;
      }
      subRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) - vector[j]);
          }
        }
        return this;
      }
      mulRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) * vector[j]);
          }
        }
        return this;
      }
      divRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) / vector[j]);
          }
        }
        return this;
      }
      addColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) + vector[i]);
          }
        }
        return this;
      }
      subColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) - vector[i]);
          }
        }
        return this;
      }
      mulColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) * vector[i]);
          }
        }
        return this;
      }
      divColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) / vector[i]);
          }
        }
        return this;
      }
      mulRow(index, value) {
        checkRowIndex(this, index);
        for (let i = 0; i < this.columns; i++) {
          this.set(index, i, this.get(index, i) * value);
        }
        return this;
      }
      mulColumn(index, value) {
        checkColumnIndex(this, index);
        for (let i = 0; i < this.rows; i++) {
          this.set(i, index, this.get(i, index) * value);
        }
        return this;
      }
      max(by) {
        if (this.isEmpty()) {
          return NaN;
        }
        switch (by) {
          case "row": {
            const max3 = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max3[row]) {
                  max3[row] = this.get(row, column);
                }
              }
            }
            return max3;
          }
          case "column": {
            const max3 = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max3[column]) {
                  max3[column] = this.get(row, column);
                }
              }
            }
            return max3;
          }
          case void 0: {
            let max3 = this.get(0, 0);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max3) {
                  max3 = this.get(row, column);
                }
              }
            }
            return max3;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      maxIndex() {
        checkNonEmpty(this);
        let v2 = this.get(0, 0);
        let idx = [0, 0];
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            if (this.get(i, j) > v2) {
              v2 = this.get(i, j);
              idx[0] = i;
              idx[1] = j;
            }
          }
        }
        return idx;
      }
      min(by) {
        if (this.isEmpty()) {
          return NaN;
        }
        switch (by) {
          case "row": {
            const min3 = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min3[row]) {
                  min3[row] = this.get(row, column);
                }
              }
            }
            return min3;
          }
          case "column": {
            const min3 = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min3[column]) {
                  min3[column] = this.get(row, column);
                }
              }
            }
            return min3;
          }
          case void 0: {
            let min3 = this.get(0, 0);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min3) {
                  min3 = this.get(row, column);
                }
              }
            }
            return min3;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      minIndex() {
        checkNonEmpty(this);
        let v2 = this.get(0, 0);
        let idx = [0, 0];
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            if (this.get(i, j) < v2) {
              v2 = this.get(i, j);
              idx[0] = i;
              idx[1] = j;
            }
          }
        }
        return idx;
      }
      maxRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(row, 0);
        for (let i = 1; i < this.columns; i++) {
          if (this.get(row, i) > v2) {
            v2 = this.get(row, i);
          }
        }
        return v2;
      }
      maxRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v2 = this.get(row, 0);
        let idx = [row, 0];
        for (let i = 1; i < this.columns; i++) {
          if (this.get(row, i) > v2) {
            v2 = this.get(row, i);
            idx[1] = i;
          }
        }
        return idx;
      }
      minRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(row, 0);
        for (let i = 1; i < this.columns; i++) {
          if (this.get(row, i) < v2) {
            v2 = this.get(row, i);
          }
        }
        return v2;
      }
      minRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v2 = this.get(row, 0);
        let idx = [row, 0];
        for (let i = 1; i < this.columns; i++) {
          if (this.get(row, i) < v2) {
            v2 = this.get(row, i);
            idx[1] = i;
          }
        }
        return idx;
      }
      maxColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(0, column);
        for (let i = 1; i < this.rows; i++) {
          if (this.get(i, column) > v2) {
            v2 = this.get(i, column);
          }
        }
        return v2;
      }
      maxColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v2 = this.get(0, column);
        let idx = [0, column];
        for (let i = 1; i < this.rows; i++) {
          if (this.get(i, column) > v2) {
            v2 = this.get(i, column);
            idx[0] = i;
          }
        }
        return idx;
      }
      minColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(0, column);
        for (let i = 1; i < this.rows; i++) {
          if (this.get(i, column) < v2) {
            v2 = this.get(i, column);
          }
        }
        return v2;
      }
      minColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v2 = this.get(0, column);
        let idx = [0, column];
        for (let i = 1; i < this.rows; i++) {
          if (this.get(i, column) < v2) {
            v2 = this.get(i, column);
            idx[0] = i;
          }
        }
        return idx;
      }
      diag() {
        let min3 = Math.min(this.rows, this.columns);
        let diag = [];
        for (let i = 0; i < min3; i++) {
          diag.push(this.get(i, i));
        }
        return diag;
      }
      norm(type = "frobenius") {
        switch (type) {
          case "max":
            return this.max();
          case "frobenius":
            return Math.sqrt(this.dot(this));
          default:
            throw new RangeError(`unknown norm type: ${type}`);
        }
      }
      cumulativeSum() {
        let sum3 = 0;
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            sum3 += this.get(i, j);
            this.set(i, j, sum3);
          }
        }
        return this;
      }
      dot(vector2) {
        if (_AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
        let vector1 = this.to1DArray();
        if (vector1.length !== vector2.length) {
          throw new RangeError("vectors do not have the same size");
        }
        let dot = 0;
        for (let i = 0; i < vector1.length; i++) {
          dot += vector1[i] * vector2[i];
        }
        return dot;
      }
      mmul(other) {
        other = Matrix2.checkMatrix(other);
        let m = this.rows;
        let n = this.columns;
        let p = other.columns;
        let result2 = new Matrix2(m, p);
        let Bcolj = new Float64Array(n);
        for (let j = 0; j < p; j++) {
          for (let k = 0; k < n; k++) {
            Bcolj[k] = other.get(k, j);
          }
          for (let i = 0; i < m; i++) {
            let s = 0;
            for (let k = 0; k < n; k++) {
              s += this.get(i, k) * Bcolj[k];
            }
            result2.set(i, j, s);
          }
        }
        return result2;
      }
      mpow(scalar) {
        if (!this.isSquare()) {
          throw new RangeError("Matrix must be square");
        }
        if (!Number.isInteger(scalar) || scalar < 0) {
          throw new RangeError("Exponent must be a non-negative integer");
        }
        let result2 = Matrix2.eye(this.rows);
        let bb2 = this;
        for (let e = scalar; e >= 1; e /= 2) {
          if ((e & 1) !== 0) {
            result2 = result2.mmul(bb2);
          }
          bb2 = bb2.mmul(bb2);
        }
        return result2;
      }
      strassen2x2(other) {
        other = Matrix2.checkMatrix(other);
        let result2 = new Matrix2(2, 2);
        const a11 = this.get(0, 0);
        const b11 = other.get(0, 0);
        const a12 = this.get(0, 1);
        const b12 = other.get(0, 1);
        const a21 = this.get(1, 0);
        const b21 = other.get(1, 0);
        const a22 = this.get(1, 1);
        const b22 = other.get(1, 1);
        const m1 = (a11 + a22) * (b11 + b22);
        const m2 = (a21 + a22) * b11;
        const m3 = a11 * (b12 - b22);
        const m4 = a22 * (b21 - b11);
        const m5 = (a11 + a12) * b22;
        const m6 = (a21 - a11) * (b11 + b12);
        const m7 = (a12 - a22) * (b21 + b22);
        const c00 = m1 + m4 - m5 + m7;
        const c01 = m3 + m5;
        const c10 = m2 + m4;
        const c11 = m1 - m2 + m3 + m6;
        result2.set(0, 0, c00);
        result2.set(0, 1, c01);
        result2.set(1, 0, c10);
        result2.set(1, 1, c11);
        return result2;
      }
      strassen3x3(other) {
        other = Matrix2.checkMatrix(other);
        let result2 = new Matrix2(3, 3);
        const a00 = this.get(0, 0);
        const a01 = this.get(0, 1);
        const a02 = this.get(0, 2);
        const a10 = this.get(1, 0);
        const a11 = this.get(1, 1);
        const a12 = this.get(1, 2);
        const a20 = this.get(2, 0);
        const a21 = this.get(2, 1);
        const a22 = this.get(2, 2);
        const b00 = other.get(0, 0);
        const b01 = other.get(0, 1);
        const b02 = other.get(0, 2);
        const b10 = other.get(1, 0);
        const b11 = other.get(1, 1);
        const b12 = other.get(1, 2);
        const b20 = other.get(2, 0);
        const b21 = other.get(2, 1);
        const b22 = other.get(2, 2);
        const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
        const m2 = (a00 - a10) * (-b01 + b11);
        const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
        const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
        const m5 = (a10 + a11) * (-b00 + b01);
        const m6 = a00 * b00;
        const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
        const m8 = (-a00 + a20) * (b02 - b12);
        const m9 = (a20 + a21) * (-b00 + b02);
        const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
        const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
        const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
        const m13 = (a02 - a22) * (b11 - b21);
        const m14 = a02 * b20;
        const m15 = (a21 + a22) * (-b20 + b21);
        const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
        const m17 = (a02 - a12) * (b12 - b22);
        const m18 = (a11 + a12) * (-b20 + b22);
        const m19 = a01 * b10;
        const m20 = a12 * b21;
        const m21 = a10 * b02;
        const m22 = a20 * b01;
        const m23 = a22 * b22;
        const c00 = m6 + m14 + m19;
        const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
        const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
        const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
        const c11 = m2 + m4 + m5 + m6 + m20;
        const c12 = m14 + m16 + m17 + m18 + m21;
        const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
        const c21 = m12 + m13 + m14 + m15 + m22;
        const c22 = m6 + m7 + m8 + m9 + m23;
        result2.set(0, 0, c00);
        result2.set(0, 1, c01);
        result2.set(0, 2, c02);
        result2.set(1, 0, c10);
        result2.set(1, 1, c11);
        result2.set(1, 2, c12);
        result2.set(2, 0, c20);
        result2.set(2, 1, c21);
        result2.set(2, 2, c22);
        return result2;
      }
      mmulStrassen(y) {
        y = Matrix2.checkMatrix(y);
        let x = this.clone();
        let r1 = x.rows;
        let c1 = x.columns;
        let r2 = y.rows;
        let c2 = y.columns;
        if (c1 !== r2) {
          console.warn(
            `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`
          );
        }
        function embed(mat, rows, cols) {
          let r3 = mat.rows;
          let c3 = mat.columns;
          if (r3 === rows && c3 === cols) {
            return mat;
          } else {
            let resultat = _AbstractMatrix.zeros(rows, cols);
            resultat = resultat.setSubMatrix(mat, 0, 0);
            return resultat;
          }
        }
        let r = Math.max(r1, r2);
        let c = Math.max(c1, c2);
        x = embed(x, r, c);
        y = embed(y, r, c);
        function blockMult(a, b, rows, cols) {
          if (rows <= 512 || cols <= 512) {
            return a.mmul(b);
          }
          if (rows % 2 === 1 && cols % 2 === 1) {
            a = embed(a, rows + 1, cols + 1);
            b = embed(b, rows + 1, cols + 1);
          } else if (rows % 2 === 1) {
            a = embed(a, rows + 1, cols);
            b = embed(b, rows + 1, cols);
          } else if (cols % 2 === 1) {
            a = embed(a, rows, cols + 1);
            b = embed(b, rows, cols + 1);
          }
          let halfRows = parseInt(a.rows / 2, 10);
          let halfCols = parseInt(a.columns / 2, 10);
          let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
          let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);
          let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
          let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);
          let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
          let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);
          let m1 = blockMult(
            _AbstractMatrix.add(a11, a22),
            _AbstractMatrix.add(b11, b22),
            halfRows,
            halfCols
          );
          let m2 = blockMult(_AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
          let m3 = blockMult(a11, _AbstractMatrix.sub(b12, b22), halfRows, halfCols);
          let m4 = blockMult(a22, _AbstractMatrix.sub(b21, b11), halfRows, halfCols);
          let m5 = blockMult(_AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
          let m6 = blockMult(
            _AbstractMatrix.sub(a21, a11),
            _AbstractMatrix.add(b11, b12),
            halfRows,
            halfCols
          );
          let m7 = blockMult(
            _AbstractMatrix.sub(a12, a22),
            _AbstractMatrix.add(b21, b22),
            halfRows,
            halfCols
          );
          let c11 = _AbstractMatrix.add(m1, m4);
          c11.sub(m5);
          c11.add(m7);
          let c12 = _AbstractMatrix.add(m3, m5);
          let c21 = _AbstractMatrix.add(m2, m4);
          let c22 = _AbstractMatrix.sub(m1, m2);
          c22.add(m3);
          c22.add(m6);
          let result2 = _AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
          result2 = result2.setSubMatrix(c11, 0, 0);
          result2 = result2.setSubMatrix(c12, c11.rows, 0);
          result2 = result2.setSubMatrix(c21, 0, c11.columns);
          result2 = result2.setSubMatrix(c22, c11.rows, c11.columns);
          return result2.subMatrix(0, rows - 1, 0, cols - 1);
        }
        return blockMult(x, y, r, c);
      }
      scaleRows(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min3 = 0, max: max3 = 1 } = options;
        if (!Number.isFinite(min3)) throw new TypeError("min must be a number");
        if (!Number.isFinite(max3)) throw new TypeError("max must be a number");
        if (min3 >= max3) throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix2(this.rows, this.columns);
        for (let i = 0; i < this.rows; i++) {
          const row = this.getRow(i);
          if (row.length > 0) {
            rescale2(row, { min: min3, max: max3, output: row });
          }
          newMatrix.setRow(i, row);
        }
        return newMatrix;
      }
      scaleColumns(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min3 = 0, max: max3 = 1 } = options;
        if (!Number.isFinite(min3)) throw new TypeError("min must be a number");
        if (!Number.isFinite(max3)) throw new TypeError("max must be a number");
        if (min3 >= max3) throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix2(this.rows, this.columns);
        for (let i = 0; i < this.columns; i++) {
          const column = this.getColumn(i);
          if (column.length) {
            rescale2(column, {
              min: min3,
              max: max3,
              output: column
            });
          }
          newMatrix.setColumn(i, column);
        }
        return newMatrix;
      }
      flipRows() {
        const middle = Math.ceil(this.columns / 2);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < middle; j++) {
            let first = this.get(i, j);
            let last2 = this.get(i, this.columns - 1 - j);
            this.set(i, j, last2);
            this.set(i, this.columns - 1 - j, first);
          }
        }
        return this;
      }
      flipColumns() {
        const middle = Math.ceil(this.rows / 2);
        for (let j = 0; j < this.columns; j++) {
          for (let i = 0; i < middle; i++) {
            let first = this.get(i, j);
            let last2 = this.get(this.rows - 1 - i, j);
            this.set(i, j, last2);
            this.set(this.rows - 1 - i, j, first);
          }
        }
        return this;
      }
      kroneckerProduct(other) {
        other = Matrix2.checkMatrix(other);
        let m = this.rows;
        let n = this.columns;
        let p = other.rows;
        let q = other.columns;
        let result2 = new Matrix2(m * p, n * q);
        for (let i = 0; i < m; i++) {
          for (let j = 0; j < n; j++) {
            for (let k = 0; k < p; k++) {
              for (let l = 0; l < q; l++) {
                result2.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));
              }
            }
          }
        }
        return result2;
      }
      kroneckerSum(other) {
        other = Matrix2.checkMatrix(other);
        if (!this.isSquare() || !other.isSquare()) {
          throw new Error("Kronecker Sum needs two Square Matrices");
        }
        let m = this.rows;
        let n = other.rows;
        let AxI = this.kroneckerProduct(Matrix2.eye(n, n));
        let IxB = Matrix2.eye(m, m).kroneckerProduct(other);
        return AxI.add(IxB);
      }
      transpose() {
        let result2 = new Matrix2(this.columns, this.rows);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            result2.set(j, i, this.get(i, j));
          }
        }
        return result2;
      }
      sortRows(compareFunction = compareNumbers) {
        for (let i = 0; i < this.rows; i++) {
          this.setRow(i, this.getRow(i).sort(compareFunction));
        }
        return this;
      }
      sortColumns(compareFunction = compareNumbers) {
        for (let i = 0; i < this.columns; i++) {
          this.setColumn(i, this.getColumn(i).sort(compareFunction));
        }
        return this;
      }
      subMatrix(startRow, endRow, startColumn, endColumn) {
        checkRange(this, startRow, endRow, startColumn, endColumn);
        let newMatrix = new Matrix2(
          endRow - startRow + 1,
          endColumn - startColumn + 1
        );
        for (let i = startRow; i <= endRow; i++) {
          for (let j = startColumn; j <= endColumn; j++) {
            newMatrix.set(i - startRow, j - startColumn, this.get(i, j));
          }
        }
        return newMatrix;
      }
      subMatrixRow(indices, startColumn, endColumn) {
        if (startColumn === void 0) startColumn = 0;
        if (endColumn === void 0) endColumn = this.columns - 1;
        if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix2(indices.length, endColumn - startColumn + 1);
        for (let i = 0; i < indices.length; i++) {
          for (let j = startColumn; j <= endColumn; j++) {
            if (indices[i] < 0 || indices[i] >= this.rows) {
              throw new RangeError(`Row index out of range: ${indices[i]}`);
            }
            newMatrix.set(i, j - startColumn, this.get(indices[i], j));
          }
        }
        return newMatrix;
      }
      subMatrixColumn(indices, startRow, endRow) {
        if (startRow === void 0) startRow = 0;
        if (endRow === void 0) endRow = this.rows - 1;
        if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix2(endRow - startRow + 1, indices.length);
        for (let i = 0; i < indices.length; i++) {
          for (let j = startRow; j <= endRow; j++) {
            if (indices[i] < 0 || indices[i] >= this.columns) {
              throw new RangeError(`Column index out of range: ${indices[i]}`);
            }
            newMatrix.set(j - startRow, i, this.get(j, indices[i]));
          }
        }
        return newMatrix;
      }
      setSubMatrix(matrix2, startRow, startColumn) {
        matrix2 = Matrix2.checkMatrix(matrix2);
        if (matrix2.isEmpty()) {
          return this;
        }
        let endRow = startRow + matrix2.rows - 1;
        let endColumn = startColumn + matrix2.columns - 1;
        checkRange(this, startRow, endRow, startColumn, endColumn);
        for (let i = 0; i < matrix2.rows; i++) {
          for (let j = 0; j < matrix2.columns; j++) {
            this.set(startRow + i, startColumn + j, matrix2.get(i, j));
          }
        }
        return this;
      }
      selection(rowIndices, columnIndices) {
        checkRowIndices(this, rowIndices);
        checkColumnIndices(this, columnIndices);
        let newMatrix = new Matrix2(rowIndices.length, columnIndices.length);
        for (let i = 0; i < rowIndices.length; i++) {
          let rowIndex = rowIndices[i];
          for (let j = 0; j < columnIndices.length; j++) {
            let columnIndex = columnIndices[j];
            newMatrix.set(i, j, this.get(rowIndex, columnIndex));
          }
        }
        return newMatrix;
      }
      trace() {
        let min3 = Math.min(this.rows, this.columns);
        let trace = 0;
        for (let i = 0; i < min3; i++) {
          trace += this.get(i, i);
        }
        return trace;
      }
      clone() {
        return this.constructor.copy(this, new Matrix2(this.rows, this.columns));
      }
      /**
       * @template {AbstractMatrix} M
       * @param {AbstractMatrix} from
       * @param {M} to
       * @return {M}
       */
      static copy(from, to) {
        for (const [row, column, value] of from.entries()) {
          to.set(row, column, value);
        }
        return to;
      }
      sum(by) {
        switch (by) {
          case "row":
            return sumByRow(this);
          case "column":
            return sumByColumn(this);
          case void 0:
            return sumAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      product(by) {
        switch (by) {
          case "row":
            return productByRow(this);
          case "column":
            return productByColumn(this);
          case void 0:
            return productAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      mean(by) {
        const sum3 = this.sum(by);
        switch (by) {
          case "row": {
            for (let i = 0; i < this.rows; i++) {
              sum3[i] /= this.columns;
            }
            return sum3;
          }
          case "column": {
            for (let i = 0; i < this.columns; i++) {
              sum3[i] /= this.rows;
            }
            return sum3;
          }
          case void 0:
            return sum3 / this.size;
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      variance(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { unbiased = true, mean: mean2 = this.mean(by) } = options;
        if (typeof unbiased !== "boolean") {
          throw new TypeError("unbiased must be a boolean");
        }
        switch (by) {
          case "row": {
            if (!isAnyArray2.isAnyArray(mean2)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByRow(this, unbiased, mean2);
          }
          case "column": {
            if (!isAnyArray2.isAnyArray(mean2)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByColumn(this, unbiased, mean2);
          }
          case void 0: {
            if (typeof mean2 !== "number") {
              throw new TypeError("mean must be a number");
            }
            return varianceAll(this, unbiased, mean2);
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      standardDeviation(by, options) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        const variance = this.variance(by, options);
        if (by === void 0) {
          return Math.sqrt(variance);
        } else {
          for (let i = 0; i < variance.length; i++) {
            variance[i] = Math.sqrt(variance[i]);
          }
          return variance;
        }
      }
      center(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { center = this.mean(by) } = options;
        switch (by) {
          case "row": {
            if (!isAnyArray2.isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByRow(this, center);
            return this;
          }
          case "column": {
            if (!isAnyArray2.isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByColumn(this, center);
            return this;
          }
          case void 0: {
            if (typeof center !== "number") {
              throw new TypeError("center must be a number");
            }
            centerAll(this, center);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      scale(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        let scale3 = options.scale;
        switch (by) {
          case "row": {
            if (scale3 === void 0) {
              scale3 = getScaleByRow(this);
            } else if (!isAnyArray2.isAnyArray(scale3)) {
              throw new TypeError("scale must be an array");
            }
            scaleByRow(this, scale3);
            return this;
          }
          case "column": {
            if (scale3 === void 0) {
              scale3 = getScaleByColumn(this);
            } else if (!isAnyArray2.isAnyArray(scale3)) {
              throw new TypeError("scale must be an array");
            }
            scaleByColumn(this, scale3);
            return this;
          }
          case void 0: {
            if (scale3 === void 0) {
              scale3 = getScaleAll(this);
            } else if (typeof scale3 !== "number") {
              throw new TypeError("scale must be a number");
            }
            scaleAll(this, scale3);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      toString(options) {
        return inspectMatrixWithOptions(this, options);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * iterator from left to right, from top to bottom
       * yield [row, column, value]
       * @returns {Generator<[number, number, number], void, void>}
       */
      *entries() {
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.columns; col++) {
            yield [row, col, this.get(row, col)];
          }
        }
      }
      /**
       * iterator from left to right, from top to bottom
       * yield value
       * @returns {Generator<number, void, void>}
       */
      *values() {
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.columns; col++) {
            yield this.get(row, col);
          }
        }
      }
    };
    AbstractMatrix2.prototype.klass = "Matrix";
    if (typeof Symbol !== "undefined") {
      AbstractMatrix2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspectMatrix;
    }
    function compareNumbers(a, b) {
      return a - b;
    }
    function isArrayOfNumbers(array) {
      return array.every((element) => {
        return typeof element === "number";
      });
    }
    AbstractMatrix2.random = AbstractMatrix2.rand;
    AbstractMatrix2.randomInt = AbstractMatrix2.randInt;
    AbstractMatrix2.diagonal = AbstractMatrix2.diag;
    AbstractMatrix2.prototype.diagonal = AbstractMatrix2.prototype.diag;
    AbstractMatrix2.identity = AbstractMatrix2.eye;
    AbstractMatrix2.prototype.negate = AbstractMatrix2.prototype.neg;
    AbstractMatrix2.prototype.tensorProduct = AbstractMatrix2.prototype.kroneckerProduct;
    var Matrix2 = class _Matrix extends AbstractMatrix2 {
      /**
       * @type {Float64Array[]}
       */
      data;
      /**
       * Init an empty matrix
       * @param {number} nRows
       * @param {number} nColumns
       */
      #initData(nRows, nColumns) {
        this.data = [];
        if (Number.isInteger(nColumns) && nColumns >= 0) {
          for (let i = 0; i < nRows; i++) {
            this.data.push(new Float64Array(nColumns));
          }
        } else {
          throw new TypeError("nColumns must be a positive integer");
        }
        this.rows = nRows;
        this.columns = nColumns;
      }
      constructor(nRows, nColumns) {
        super();
        if (_Matrix.isMatrix(nRows)) {
          this.#initData(nRows.rows, nRows.columns);
          _Matrix.copy(nRows, this);
        } else if (Number.isInteger(nRows) && nRows >= 0) {
          this.#initData(nRows, nColumns);
        } else if (isAnyArray2.isAnyArray(nRows)) {
          const arrayData = nRows;
          nRows = arrayData.length;
          nColumns = nRows ? arrayData[0].length : 0;
          if (typeof nColumns !== "number") {
            throw new TypeError(
              "Data must be a 2D array with at least one element"
            );
          }
          this.data = [];
          for (let i = 0; i < nRows; i++) {
            if (arrayData[i].length !== nColumns) {
              throw new RangeError("Inconsistent array dimensions");
            }
            if (!isArrayOfNumbers(arrayData[i])) {
              throw new TypeError("Input data contains non-numeric values");
            }
            this.data.push(Float64Array.from(arrayData[i]));
          }
          this.rows = nRows;
          this.columns = nColumns;
        } else {
          throw new TypeError(
            "First argument must be a positive number or an array"
          );
        }
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
      removeRow(index) {
        checkRowIndex(this, index);
        this.data.splice(index, 1);
        this.rows -= 1;
        return this;
      }
      addRow(index, array) {
        if (array === void 0) {
          array = index;
          index = this.rows;
        }
        checkRowIndex(this, index, true);
        array = Float64Array.from(checkRowVector(this, array));
        this.data.splice(index, 0, array);
        this.rows += 1;
        return this;
      }
      removeColumn(index) {
        checkColumnIndex(this, index);
        for (let i = 0; i < this.rows; i++) {
          const newRow = new Float64Array(this.columns - 1);
          for (let j = 0; j < index; j++) {
            newRow[j] = this.data[i][j];
          }
          for (let j = index + 1; j < this.columns; j++) {
            newRow[j - 1] = this.data[i][j];
          }
          this.data[i] = newRow;
        }
        this.columns -= 1;
        return this;
      }
      addColumn(index, array) {
        if (typeof array === "undefined") {
          array = index;
          index = this.columns;
        }
        checkColumnIndex(this, index, true);
        array = checkColumnVector(this, array);
        for (let i = 0; i < this.rows; i++) {
          const newRow = new Float64Array(this.columns + 1);
          let j = 0;
          for (; j < index; j++) {
            newRow[j] = this.data[i][j];
          }
          newRow[j++] = array[i];
          for (; j < this.columns + 1; j++) {
            newRow[j] = this.data[i][j - 1];
          }
          this.data[i] = newRow;
        }
        this.columns += 1;
        return this;
      }
    };
    installMathOperations(AbstractMatrix2, Matrix2);
    var SymmetricMatrix2 = class _SymmetricMatrix extends AbstractMatrix2 {
      /** @type {Matrix} */
      #matrix;
      get size() {
        return this.#matrix.size;
      }
      get rows() {
        return this.#matrix.rows;
      }
      get columns() {
        return this.#matrix.columns;
      }
      get diagonalSize() {
        return this.rows;
      }
      /**
       * not the same as matrix.isSymmetric()
       * Here is to check if it's instanceof SymmetricMatrix without bundling issues
       *
       * @param value
       * @returns {boolean}
       */
      static isSymmetricMatrix(value) {
        return Matrix2.isMatrix(value) && value.klassType === "SymmetricMatrix";
      }
      /**
       * @param diagonalSize
       * @return {SymmetricMatrix}
       */
      static zeros(diagonalSize) {
        return new this(diagonalSize);
      }
      /**
       * @param diagonalSize
       * @return {SymmetricMatrix}
       */
      static ones(diagonalSize) {
        return new this(diagonalSize).fill(1);
      }
      /**
       * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
       * @return {this}
       */
      constructor(diagonalSize) {
        super();
        if (Matrix2.isMatrix(diagonalSize)) {
          if (!diagonalSize.isSymmetric()) {
            throw new TypeError("not symmetric data");
          }
          this.#matrix = Matrix2.copy(
            diagonalSize,
            new Matrix2(diagonalSize.rows, diagonalSize.rows)
          );
        } else if (Number.isInteger(diagonalSize) && diagonalSize >= 0) {
          this.#matrix = new Matrix2(diagonalSize, diagonalSize);
        } else {
          this.#matrix = new Matrix2(diagonalSize);
          if (!this.isSymmetric()) {
            throw new TypeError("not symmetric data");
          }
        }
      }
      clone() {
        const matrix2 = new _SymmetricMatrix(this.diagonalSize);
        for (const [row, col, value] of this.upperRightEntries()) {
          matrix2.set(row, col, value);
        }
        return matrix2;
      }
      toMatrix() {
        return new Matrix2(this);
      }
      get(rowIndex, columnIndex) {
        return this.#matrix.get(rowIndex, columnIndex);
      }
      set(rowIndex, columnIndex, value) {
        this.#matrix.set(rowIndex, columnIndex, value);
        this.#matrix.set(columnIndex, rowIndex, value);
        return this;
      }
      removeCross(index) {
        this.#matrix.removeRow(index);
        this.#matrix.removeColumn(index);
        return this;
      }
      addCross(index, array) {
        if (array === void 0) {
          array = index;
          index = this.diagonalSize;
        }
        const row = array.slice();
        row.splice(index, 1);
        this.#matrix.addRow(index, row);
        this.#matrix.addColumn(index, array);
        return this;
      }
      /**
       * @param {Mask[]} mask
       */
      applyMask(mask) {
        if (mask.length !== this.diagonalSize) {
          throw new RangeError("Mask size do not match with matrix size");
        }
        const sidesToRemove = [];
        for (const [index, passthroughs] of mask.entries()) {
          if (passthroughs) continue;
          sidesToRemove.push(index);
        }
        sidesToRemove.reverse();
        for (const sideIndex of sidesToRemove) {
          this.removeCross(sideIndex);
        }
        return this;
      }
      /**
       * Compact format upper-right corner of matrix
       * iterate from left to right, from top to bottom.
       *
       * ```
       *   A B C D
       * A 1 2 3 4
       * B 2 5 6 7
       * C 3 6 8 9
       * D 4 7 9 10
       * ```
       *
       * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
       *
       * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
       *
       * @returns {number[]}
       */
      toCompact() {
        const { diagonalSize } = this;
        const compact2 = new Array(diagonalSize * (diagonalSize + 1) / 2);
        for (let col = 0, row = 0, index = 0; index < compact2.length; index++) {
          compact2[index] = this.get(row, col);
          if (++col >= diagonalSize) col = ++row;
        }
        return compact2;
      }
      /**
       * @param {number[]} compact
       * @return {SymmetricMatrix}
       */
      static fromCompact(compact2) {
        const compactSize = compact2.length;
        const diagonalSize = (Math.sqrt(8 * compactSize + 1) - 1) / 2;
        if (!Number.isInteger(diagonalSize)) {
          throw new TypeError(
            `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(
              compact2
            )}`
          );
        }
        const matrix2 = new _SymmetricMatrix(diagonalSize);
        for (let col = 0, row = 0, index = 0; index < compactSize; index++) {
          matrix2.set(col, row, compact2[index]);
          if (++col >= diagonalSize) col = ++row;
        }
        return matrix2;
      }
      /**
       * half iterator upper-right-corner from left to right, from top to bottom
       * yield [row, column, value]
       *
       * @returns {Generator<[number, number, number], void, void>}
       */
      *upperRightEntries() {
        for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
          const value = this.get(row, col);
          yield [row, col, value];
          if (++col >= this.diagonalSize) col = ++row;
        }
      }
      /**
       * half iterator upper-right-corner from left to right, from top to bottom
       * yield value
       *
       * @returns {Generator<[number, number, number], void, void>}
       */
      *upperRightValues() {
        for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
          const value = this.get(row, col);
          yield value;
          if (++col >= this.diagonalSize) col = ++row;
        }
      }
    };
    SymmetricMatrix2.prototype.klassType = "SymmetricMatrix";
    var DistanceMatrix2 = class _DistanceMatrix extends SymmetricMatrix2 {
      /**
       * not the same as matrix.isSymmetric()
       * Here is to check if it's instanceof SymmetricMatrix without bundling issues
       *
       * @param value
       * @returns {boolean}
       */
      static isDistanceMatrix(value) {
        return SymmetricMatrix2.isSymmetricMatrix(value) && value.klassSubType === "DistanceMatrix";
      }
      constructor(sideSize) {
        super(sideSize);
        if (!this.isDistance()) {
          throw new TypeError("Provided arguments do no produce a distance matrix");
        }
      }
      set(rowIndex, columnIndex, value) {
        if (rowIndex === columnIndex) value = 0;
        return super.set(rowIndex, columnIndex, value);
      }
      addCross(index, array) {
        if (array === void 0) {
          array = index;
          index = this.diagonalSize;
        }
        array = array.slice();
        array[index] = 0;
        return super.addCross(index, array);
      }
      toSymmetricMatrix() {
        return new SymmetricMatrix2(this);
      }
      clone() {
        const matrix2 = new _DistanceMatrix(this.diagonalSize);
        for (const [row, col, value] of this.upperRightEntries()) {
          if (row === col) continue;
          matrix2.set(row, col, value);
        }
        return matrix2;
      }
      /**
       * Compact format upper-right corner of matrix
       * no diagonal (only zeros)
       * iterable from left to right, from top to bottom.
       *
       * ```
       *   A B C D
       * A 0 1 2 3
       * B 1 0 4 5
       * C 2 4 0 6
       * D 3 5 6 0
       * ```
       *
       * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
       *
       * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
       *
       * @returns {number[]}
       */
      toCompact() {
        const { diagonalSize } = this;
        const compactLength = (diagonalSize - 1) * diagonalSize / 2;
        const compact2 = new Array(compactLength);
        for (let col = 1, row = 0, index = 0; index < compact2.length; index++) {
          compact2[index] = this.get(row, col);
          if (++col >= diagonalSize) col = ++row + 1;
        }
        return compact2;
      }
      /**
       * @param {number[]} compact
       */
      static fromCompact(compact2) {
        const compactSize = compact2.length;
        if (compactSize === 0) {
          return new this(0);
        }
        const diagonalSize = (Math.sqrt(8 * compactSize + 1) + 1) / 2;
        if (!Number.isInteger(diagonalSize)) {
          throw new TypeError(
            `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(
              compact2
            )}`
          );
        }
        const matrix2 = new this(diagonalSize);
        for (let col = 1, row = 0, index = 0; index < compactSize; index++) {
          matrix2.set(col, row, compact2[index]);
          if (++col >= diagonalSize) col = ++row + 1;
        }
        return matrix2;
      }
    };
    DistanceMatrix2.prototype.klassSubType = "DistanceMatrix";
    var BaseView = class extends AbstractMatrix2 {
      constructor(matrix2, rows, columns) {
        super();
        this.matrix = matrix2;
        this.rows = rows;
        this.columns = columns;
      }
    };
    var MatrixColumnView2 = class extends BaseView {
      constructor(matrix2, column) {
        checkColumnIndex(matrix2, column);
        super(matrix2, matrix2.rows, 1);
        this.column = column;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }
      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    };
    var MatrixColumnSelectionView2 = class extends BaseView {
      constructor(matrix2, columnIndices) {
        checkColumnIndices(matrix2, columnIndices);
        super(matrix2, matrix2.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    };
    var MatrixFlipColumnView2 = class extends BaseView {
      constructor(matrix2) {
        super(matrix2, matrix2.rows, matrix2.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    };
    var MatrixFlipRowView2 = class extends BaseView {
      constructor(matrix2) {
        super(matrix2, matrix2.rows, matrix2.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    };
    var MatrixRowView2 = class extends BaseView {
      constructor(matrix2, row) {
        checkRowIndex(matrix2, row);
        super(matrix2, 1, matrix2.columns);
        this.row = row;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    };
    var MatrixRowSelectionView2 = class extends BaseView {
      constructor(matrix2, rowIndices) {
        checkRowIndices(matrix2, rowIndices);
        super(matrix2, rowIndices.length, matrix2.columns);
        this.rowIndices = rowIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    };
    var MatrixSelectionView2 = class extends BaseView {
      constructor(matrix2, rowIndices, columnIndices) {
        checkRowIndices(matrix2, rowIndices);
        checkColumnIndices(matrix2, columnIndices);
        super(matrix2, rowIndices.length, columnIndices.length);
        this.rowIndices = rowIndices;
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex],
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex]
        );
      }
    };
    var MatrixSubView2 = class extends BaseView {
      constructor(matrix2, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix2, startRow, endRow, startColumn, endColumn);
        super(matrix2, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.startRow + rowIndex,
          this.startColumn + columnIndex,
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.startRow + rowIndex,
          this.startColumn + columnIndex
        );
      }
    };
    var MatrixTransposeView2 = class extends BaseView {
      constructor(matrix2) {
        super(matrix2, matrix2.columns, matrix2.rows);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    };
    var WrapperMatrix1D2 = class extends AbstractMatrix2 {
      constructor(data, options = {}) {
        const { rows = 1 } = options;
        if (data.length % rows !== 0) {
          throw new Error("the data length is not divisible by the number of rows");
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }
      set(rowIndex, columnIndex, value) {
        let index = this._calculateIndex(rowIndex, columnIndex);
        this.data[index] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        let index = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index];
      }
      _calculateIndex(row, column) {
        return row * this.columns + column;
      }
    };
    var WrapperMatrix2D2 = class extends AbstractMatrix2 {
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
    };
    function wrap4(array, options) {
      if (isAnyArray2.isAnyArray(array)) {
        if (array[0] && isAnyArray2.isAnyArray(array[0])) {
          return new WrapperMatrix2D2(array);
        } else {
          return new WrapperMatrix1D2(array, options);
        }
      } else {
        throw new Error("the argument is not an array");
      }
    }
    var LuDecomposition2 = class {
      constructor(matrix2) {
        matrix2 = WrapperMatrix2D2.checkMatrix(matrix2);
        let lu = matrix2.clone();
        let rows = lu.rows;
        let columns = lu.columns;
        let pivotVector = new Float64Array(rows);
        let pivotSign = 1;
        let i, j, k, p, s, t, v2;
        let LUcolj, kmax;
        for (i = 0; i < rows; i++) {
          pivotVector[i] = i;
        }
        LUcolj = new Float64Array(rows);
        for (j = 0; j < columns; j++) {
          for (i = 0; i < rows; i++) {
            LUcolj[i] = lu.get(i, j);
          }
          for (i = 0; i < rows; i++) {
            kmax = Math.min(i, j);
            s = 0;
            for (k = 0; k < kmax; k++) {
              s += lu.get(i, k) * LUcolj[k];
            }
            LUcolj[i] -= s;
            lu.set(i, j, LUcolj[i]);
          }
          p = j;
          for (i = j + 1; i < rows; i++) {
            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
              p = i;
            }
          }
          if (p !== j) {
            for (k = 0; k < columns; k++) {
              t = lu.get(p, k);
              lu.set(p, k, lu.get(j, k));
              lu.set(j, k, t);
            }
            v2 = pivotVector[p];
            pivotVector[p] = pivotVector[j];
            pivotVector[j] = v2;
            pivotSign = -pivotSign;
          }
          if (j < rows && lu.get(j, j) !== 0) {
            for (i = j + 1; i < rows; i++) {
              lu.set(i, j, lu.get(i, j) / lu.get(j, j));
            }
          }
        }
        this.LU = lu;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }
      isSingular() {
        let data = this.LU;
        let col = data.columns;
        for (let j = 0; j < col; j++) {
          if (data.get(j, j) === 0) {
            return true;
          }
        }
        return false;
      }
      solve(value) {
        value = Matrix2.checkMatrix(value);
        let lu = this.LU;
        let rows = lu.rows;
        if (rows !== value.rows) {
          throw new Error("Invalid matrix dimensions");
        }
        if (this.isSingular()) {
          throw new Error("LU matrix is singular");
        }
        let count = value.columns;
        let X = value.subMatrixRow(this.pivotVector, 0, count - 1);
        let columns = lu.columns;
        let i, j, k;
        for (k = 0; k < columns; k++) {
          for (i = k + 1; i < columns; i++) {
            for (j = 0; j < count; j++) {
              X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
            }
          }
        }
        for (k = columns - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X.set(k, j, X.get(k, j) / lu.get(k, k));
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
            }
          }
        }
        return X;
      }
      get determinant() {
        let data = this.LU;
        if (!data.isSquare()) {
          throw new Error("Matrix must be square");
        }
        let determinant3 = this.pivotSign;
        let col = data.columns;
        for (let j = 0; j < col; j++) {
          determinant3 *= data.get(j, j);
        }
        return determinant3;
      }
      get lowerTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X = new Matrix2(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            if (i > j) {
              X.set(i, j, data.get(i, j));
            } else if (i === j) {
              X.set(i, j, 1);
            } else {
              X.set(i, j, 0);
            }
          }
        }
        return X;
      }
      get upperTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X = new Matrix2(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            if (i <= j) {
              X.set(i, j, data.get(i, j));
            } else {
              X.set(i, j, 0);
            }
          }
        }
        return X;
      }
      get pivotPermutationVector() {
        return Array.from(this.pivotVector);
      }
    };
    function hypotenuse(a, b) {
      let r = 0;
      if (Math.abs(a) > Math.abs(b)) {
        r = b / a;
        return Math.abs(a) * Math.sqrt(1 + r * r);
      }
      if (b !== 0) {
        r = a / b;
        return Math.abs(b) * Math.sqrt(1 + r * r);
      }
      return 0;
    }
    var QrDecomposition2 = class {
      constructor(value) {
        value = WrapperMatrix2D2.checkMatrix(value);
        let qr = value.clone();
        let m = value.rows;
        let n = value.columns;
        let rdiag = new Float64Array(n);
        let i, j, k, s;
        for (k = 0; k < n; k++) {
          let nrm = 0;
          for (i = k; i < m; i++) {
            nrm = hypotenuse(nrm, qr.get(i, k));
          }
          if (nrm !== 0) {
            if (qr.get(k, k) < 0) {
              nrm = -nrm;
            }
            for (i = k; i < m; i++) {
              qr.set(i, k, qr.get(i, k) / nrm);
            }
            qr.set(k, k, qr.get(k, k) + 1);
            for (j = k + 1; j < n; j++) {
              s = 0;
              for (i = k; i < m; i++) {
                s += qr.get(i, k) * qr.get(i, j);
              }
              s = -s / qr.get(k, k);
              for (i = k; i < m; i++) {
                qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
              }
            }
          }
          rdiag[k] = -nrm;
        }
        this.QR = qr;
        this.Rdiag = rdiag;
      }
      solve(value) {
        value = Matrix2.checkMatrix(value);
        let qr = this.QR;
        let m = qr.rows;
        if (value.rows !== m) {
          throw new Error("Matrix row dimensions must agree");
        }
        if (!this.isFullRank()) {
          throw new Error("Matrix is rank deficient");
        }
        let count = value.columns;
        let X = value.clone();
        let n = qr.columns;
        let i, j, k, s;
        for (k = 0; k < n; k++) {
          for (j = 0; j < count; j++) {
            s = 0;
            for (i = k; i < m; i++) {
              s += qr.get(i, k) * X.get(i, j);
            }
            s = -s / qr.get(k, k);
            for (i = k; i < m; i++) {
              X.set(i, j, X.get(i, j) + s * qr.get(i, k));
            }
          }
        }
        for (k = n - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X.set(k, j, X.get(k, j) / this.Rdiag[k]);
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));
            }
          }
        }
        return X.subMatrix(0, n - 1, 0, count - 1);
      }
      isFullRank() {
        let columns = this.QR.columns;
        for (let i = 0; i < columns; i++) {
          if (this.Rdiag[i] === 0) {
            return false;
          }
        }
        return true;
      }
      get upperTriangularMatrix() {
        let qr = this.QR;
        let n = qr.columns;
        let X = new Matrix2(n, n);
        let i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            if (i < j) {
              X.set(i, j, qr.get(i, j));
            } else if (i === j) {
              X.set(i, j, this.Rdiag[i]);
            } else {
              X.set(i, j, 0);
            }
          }
        }
        return X;
      }
      get orthogonalMatrix() {
        let qr = this.QR;
        let rows = qr.rows;
        let columns = qr.columns;
        let X = new Matrix2(rows, columns);
        let i, j, k, s;
        for (k = columns - 1; k >= 0; k--) {
          for (i = 0; i < rows; i++) {
            X.set(i, k, 0);
          }
          X.set(k, k, 1);
          for (j = k; j < columns; j++) {
            if (qr.get(k, k) !== 0) {
              s = 0;
              for (i = k; i < rows; i++) {
                s += qr.get(i, k) * X.get(i, j);
              }
              s = -s / qr.get(k, k);
              for (i = k; i < rows; i++) {
                X.set(i, j, X.get(i, j) + s * qr.get(i, k));
              }
            }
          }
        }
        return X;
      }
    };
    var SingularValueDecomposition3 = class {
      constructor(value, options = {}) {
        value = WrapperMatrix2D2.checkMatrix(value);
        if (value.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let m = value.rows;
        let n = value.columns;
        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;
        let wantu = Boolean(computeLeftSingularVectors);
        let wantv = Boolean(computeRightSingularVectors);
        let swapped = false;
        let a;
        if (m < n) {
          if (!autoTranspose) {
            a = value.clone();
            console.warn(
              "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
            );
          } else {
            a = value.transpose();
            m = a.rows;
            n = a.columns;
            swapped = true;
            let aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a = value.clone();
        }
        let nu = Math.min(m, n);
        let ni = Math.min(m + 1, n);
        let s = new Float64Array(ni);
        let U = new Matrix2(m, nu);
        let V2 = new Matrix2(n, n);
        let e = new Float64Array(n);
        let work = new Float64Array(m);
        let si = new Float64Array(ni);
        for (let i = 0; i < ni; i++) si[i] = i;
        let nct = Math.min(m - 1, n);
        let nrt = Math.max(0, Math.min(n - 2, m));
        let mrc = Math.max(nct, nrt);
        for (let k = 0; k < mrc; k++) {
          if (k < nct) {
            s[k] = 0;
            for (let i = k; i < m; i++) {
              s[k] = hypotenuse(s[k], a.get(i, k));
            }
            if (s[k] !== 0) {
              if (a.get(k, k) < 0) {
                s[k] = -s[k];
              }
              for (let i = k; i < m; i++) {
                a.set(i, k, a.get(i, k) / s[k]);
              }
              a.set(k, k, a.get(k, k) + 1);
            }
            s[k] = -s[k];
          }
          for (let j = k + 1; j < n; j++) {
            if (k < nct && s[k] !== 0) {
              let t = 0;
              for (let i = k; i < m; i++) {
                t += a.get(i, k) * a.get(i, j);
              }
              t = -t / a.get(k, k);
              for (let i = k; i < m; i++) {
                a.set(i, j, a.get(i, j) + t * a.get(i, k));
              }
            }
            e[j] = a.get(k, j);
          }
          if (wantu && k < nct) {
            for (let i = k; i < m; i++) {
              U.set(i, k, a.get(i, k));
            }
          }
          if (k < nrt) {
            e[k] = 0;
            for (let i = k + 1; i < n; i++) {
              e[k] = hypotenuse(e[k], e[i]);
            }
            if (e[k] !== 0) {
              if (e[k + 1] < 0) {
                e[k] = 0 - e[k];
              }
              for (let i = k + 1; i < n; i++) {
                e[i] /= e[k];
              }
              e[k + 1] += 1;
            }
            e[k] = -e[k];
            if (k + 1 < m && e[k] !== 0) {
              for (let i = k + 1; i < m; i++) {
                work[i] = 0;
              }
              for (let i = k + 1; i < m; i++) {
                for (let j = k + 1; j < n; j++) {
                  work[i] += e[j] * a.get(i, j);
                }
              }
              for (let j = k + 1; j < n; j++) {
                let t = -e[j] / e[k + 1];
                for (let i = k + 1; i < m; i++) {
                  a.set(i, j, a.get(i, j) + t * work[i]);
                }
              }
            }
            if (wantv) {
              for (let i = k + 1; i < n; i++) {
                V2.set(i, k, e[i]);
              }
            }
          }
        }
        let p = Math.min(n, m + 1);
        if (nct < n) {
          s[nct] = a.get(nct, nct);
        }
        if (m < p) {
          s[p - 1] = 0;
        }
        if (nrt + 1 < p) {
          e[nrt] = a.get(nrt, p - 1);
        }
        e[p - 1] = 0;
        if (wantu) {
          for (let j = nct; j < nu; j++) {
            for (let i = 0; i < m; i++) {
              U.set(i, j, 0);
            }
            U.set(j, j, 1);
          }
          for (let k = nct - 1; k >= 0; k--) {
            if (s[k] !== 0) {
              for (let j = k + 1; j < nu; j++) {
                let t = 0;
                for (let i = k; i < m; i++) {
                  t += U.get(i, k) * U.get(i, j);
                }
                t = -t / U.get(k, k);
                for (let i = k; i < m; i++) {
                  U.set(i, j, U.get(i, j) + t * U.get(i, k));
                }
              }
              for (let i = k; i < m; i++) {
                U.set(i, k, -U.get(i, k));
              }
              U.set(k, k, 1 + U.get(k, k));
              for (let i = 0; i < k - 1; i++) {
                U.set(i, k, 0);
              }
            } else {
              for (let i = 0; i < m; i++) {
                U.set(i, k, 0);
              }
              U.set(k, k, 1);
            }
          }
        }
        if (wantv) {
          for (let k = n - 1; k >= 0; k--) {
            if (k < nrt && e[k] !== 0) {
              for (let j = k + 1; j < n; j++) {
                let t = 0;
                for (let i = k + 1; i < n; i++) {
                  t += V2.get(i, k) * V2.get(i, j);
                }
                t = -t / V2.get(k + 1, k);
                for (let i = k + 1; i < n; i++) {
                  V2.set(i, j, V2.get(i, j) + t * V2.get(i, k));
                }
              }
            }
            for (let i = 0; i < n; i++) {
              V2.set(i, k, 0);
            }
            V2.set(k, k, 1);
          }
        }
        let pp = p - 1;
        let eps = Number.EPSILON;
        while (p > 0) {
          let k, kase;
          for (k = p - 2; k >= -1; k--) {
            if (k === -1) {
              break;
            }
            const alpha = Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
            if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
              e[k] = 0;
              break;
            }
          }
          if (k === p - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p - 1; ks >= k; ks--) {
              if (ks === k) {
                break;
              }
              let t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
              if (Math.abs(s[ks]) <= eps * t) {
                s[ks] = 0;
                break;
              }
            }
            if (ks === k) {
              kase = 3;
            } else if (ks === p - 1) {
              kase = 1;
            } else {
              kase = 2;
              k = ks;
            }
          }
          k++;
          switch (kase) {
            case 1: {
              let f = e[p - 2];
              e[p - 2] = 0;
              for (let j = p - 2; j >= k; j--) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                if (j !== k) {
                  f = -sn * e[j - 1];
                  e[j - 1] = cs * e[j - 1];
                }
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V2.get(i, j) + sn * V2.get(i, p - 1);
                    V2.set(i, p - 1, -sn * V2.get(i, j) + cs * V2.get(i, p - 1));
                    V2.set(i, j, t);
                  }
                }
              }
              break;
            }
            case 2: {
              let f = e[k - 1];
              e[k - 1] = 0;
              for (let j = k; j < p; j++) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                f = -sn * e[j];
                e[j] = cs * e[j];
                if (wantu) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U.get(i, j) + sn * U.get(i, k - 1);
                    U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));
                    U.set(i, j, t);
                  }
                }
              }
              break;
            }
            case 3: {
              const scale3 = Math.max(
                Math.abs(s[p - 1]),
                Math.abs(s[p - 2]),
                Math.abs(e[p - 2]),
                Math.abs(s[k]),
                Math.abs(e[k])
              );
              const sp = s[p - 1] / scale3;
              const spm1 = s[p - 2] / scale3;
              const epm1 = e[p - 2] / scale3;
              const sk = s[k] / scale3;
              const ek = e[k] / scale3;
              const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b !== 0 || c !== 0) {
                if (b < 0) {
                  shift = 0 - Math.sqrt(b * b + c);
                } else {
                  shift = Math.sqrt(b * b + c);
                }
                shift = c / (b + shift);
              }
              let f = (sk + sp) * (sk - sp) + shift;
              let g = sk * ek;
              for (let j = k; j < p - 1; j++) {
                let t = hypotenuse(f, g);
                if (t === 0) t = Number.MIN_VALUE;
                let cs = f / t;
                let sn = g / t;
                if (j !== k) {
                  e[j - 1] = t;
                }
                f = cs * s[j] + sn * e[j];
                e[j] = cs * e[j] - sn * s[j];
                g = sn * s[j + 1];
                s[j + 1] = cs * s[j + 1];
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V2.get(i, j) + sn * V2.get(i, j + 1);
                    V2.set(i, j + 1, -sn * V2.get(i, j) + cs * V2.get(i, j + 1));
                    V2.set(i, j, t);
                  }
                }
                t = hypotenuse(f, g);
                if (t === 0) t = Number.MIN_VALUE;
                cs = f / t;
                sn = g / t;
                s[j] = t;
                f = cs * e[j] + sn * s[j + 1];
                s[j + 1] = -sn * e[j] + cs * s[j + 1];
                g = sn * e[j + 1];
                e[j + 1] = cs * e[j + 1];
                if (wantu && j < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U.get(i, j) + sn * U.get(i, j + 1);
                    U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));
                    U.set(i, j, t);
                  }
                }
              }
              e[p - 2] = f;
              break;
            }
            case 4: {
              if (s[k] <= 0) {
                s[k] = s[k] < 0 ? -s[k] : 0;
                if (wantv) {
                  for (let i = 0; i <= pp; i++) {
                    V2.set(i, k, -V2.get(i, k));
                  }
                }
              }
              while (k < pp) {
                if (s[k] >= s[k + 1]) {
                  break;
                }
                let t = s[k];
                s[k] = s[k + 1];
                s[k + 1] = t;
                if (wantv && k < n - 1) {
                  for (let i = 0; i < n; i++) {
                    t = V2.get(i, k + 1);
                    V2.set(i, k + 1, V2.get(i, k));
                    V2.set(i, k, t);
                  }
                }
                if (wantu && k < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = U.get(i, k + 1);
                    U.set(i, k + 1, U.get(i, k));
                    U.set(i, k, t);
                  }
                }
                k++;
              }
              p--;
              break;
            }
          }
        }
        if (swapped) {
          let tmp = V2;
          V2 = U;
          U = tmp;
        }
        this.m = m;
        this.n = n;
        this.s = s;
        this.U = U;
        this.V = V2;
      }
      solve(value) {
        let Y = value;
        let e = this.threshold;
        let scols = this.s.length;
        let Ls = Matrix2.zeros(scols, scols);
        for (let i = 0; i < scols; i++) {
          if (Math.abs(this.s[i]) <= e) {
            Ls.set(i, i, 0);
          } else {
            Ls.set(i, i, 1 / this.s[i]);
          }
        }
        let U = this.U;
        let V2 = this.rightSingularVectors;
        let VL = V2.mmul(Ls);
        let vrows = V2.rows;
        let urows = U.rows;
        let VLU = Matrix2.zeros(vrows, urows);
        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum3 = 0;
            for (let k = 0; k < scols; k++) {
              sum3 += VL.get(i, k) * U.get(j, k);
            }
            VLU.set(i, j, sum3);
          }
        }
        return VLU.mmul(Y);
      }
      solveForDiagonal(value) {
        return this.solve(Matrix2.diag(value));
      }
      inverse() {
        let V2 = this.V;
        let e = this.threshold;
        let vrows = V2.rows;
        let vcols = V2.columns;
        let X = new Matrix2(vrows, this.s.length);
        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < vcols; j++) {
            if (Math.abs(this.s[j]) > e) {
              X.set(i, j, V2.get(i, j) / this.s[j]);
            }
          }
        }
        let U = this.U;
        let urows = U.rows;
        let ucols = U.columns;
        let Y = new Matrix2(vrows, urows);
        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum3 = 0;
            for (let k = 0; k < ucols; k++) {
              sum3 += X.get(i, k) * U.get(j, k);
            }
            Y.set(i, j, sum3);
          }
        }
        return Y;
      }
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }
      get norm2() {
        return this.s[0];
      }
      get rank() {
        let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        let r = 0;
        let s = this.s;
        for (let i = 0, ii = s.length; i < ii; i++) {
          if (s[i] > tol) {
            r++;
          }
        }
        return r;
      }
      get diagonal() {
        return Array.from(this.s);
      }
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }
      get leftSingularVectors() {
        return this.U;
      }
      get rightSingularVectors() {
        return this.V;
      }
      get diagonalMatrix() {
        return Matrix2.diag(this.s);
      }
    };
    function inverse35(matrix2, useSVD = false) {
      matrix2 = WrapperMatrix2D2.checkMatrix(matrix2);
      if (useSVD) {
        return new SingularValueDecomposition3(matrix2).inverse();
      } else {
        return solve2(matrix2, Matrix2.eye(matrix2.rows));
      }
    }
    function solve2(leftHandSide, rightHandSide, useSVD = false) {
      leftHandSide = WrapperMatrix2D2.checkMatrix(leftHandSide);
      rightHandSide = WrapperMatrix2D2.checkMatrix(rightHandSide);
      if (useSVD) {
        return new SingularValueDecomposition3(leftHandSide).solve(rightHandSide);
      } else {
        return leftHandSide.isSquare() ? new LuDecomposition2(leftHandSide).solve(rightHandSide) : new QrDecomposition2(leftHandSide).solve(rightHandSide);
      }
    }
    function determinant2(matrix2) {
      matrix2 = Matrix2.checkMatrix(matrix2);
      if (matrix2.isSquare()) {
        if (matrix2.columns === 0) {
          return 1;
        }
        let a, b, c, d;
        if (matrix2.columns === 2) {
          a = matrix2.get(0, 0);
          b = matrix2.get(0, 1);
          c = matrix2.get(1, 0);
          d = matrix2.get(1, 1);
          return a * d - b * c;
        } else if (matrix2.columns === 3) {
          let subMatrix0, subMatrix1, subMatrix2;
          subMatrix0 = new MatrixSelectionView2(matrix2, [1, 2], [1, 2]);
          subMatrix1 = new MatrixSelectionView2(matrix2, [1, 2], [0, 2]);
          subMatrix2 = new MatrixSelectionView2(matrix2, [1, 2], [0, 1]);
          a = matrix2.get(0, 0);
          b = matrix2.get(0, 1);
          c = matrix2.get(0, 2);
          return a * determinant2(subMatrix0) - b * determinant2(subMatrix1) + c * determinant2(subMatrix2);
        } else {
          return new LuDecomposition2(matrix2).determinant;
        }
      } else {
        throw Error("determinant can only be calculated for a square matrix");
      }
    }
    function xrange(n, exception) {
      let range2 = [];
      for (let i = 0; i < n; i++) {
        if (i !== exception) {
          range2.push(i);
        }
      }
      return range2;
    }
    function dependenciesOneRow(error, matrix2, index, thresholdValue = 1e-9, thresholdError = 1e-9) {
      if (error > thresholdError) {
        return new Array(matrix2.rows + 1).fill(0);
      } else {
        let returnArray = matrix2.addRow(index, [0]);
        for (let i = 0; i < returnArray.rows; i++) {
          if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {
            returnArray.set(i, 0, 0);
          }
        }
        return returnArray.to1DArray();
      }
    }
    function linearDependencies2(matrix2, options = {}) {
      const { thresholdValue = 1e-9, thresholdError = 1e-9 } = options;
      matrix2 = Matrix2.checkMatrix(matrix2);
      let n = matrix2.rows;
      let results = new Matrix2(n, n);
      for (let i = 0; i < n; i++) {
        let b = Matrix2.columnVector(matrix2.getRow(i));
        let Abis = matrix2.subMatrixRow(xrange(n, i)).transpose();
        let svd = new SingularValueDecomposition3(Abis);
        let x = svd.solve(b);
        let error = Matrix2.sub(b, Abis.mmul(x)).abs().max();
        results.setRow(
          i,
          dependenciesOneRow(error, x, i, thresholdValue, thresholdError)
        );
      }
      return results;
    }
    function pseudoInverse3(matrix2, threshold = Number.EPSILON) {
      matrix2 = Matrix2.checkMatrix(matrix2);
      if (matrix2.isEmpty()) {
        return matrix2.transpose();
      }
      let svdSolution = new SingularValueDecomposition3(matrix2, { autoTranspose: true });
      let U = svdSolution.leftSingularVectors;
      let V2 = svdSolution.rightSingularVectors;
      let s = svdSolution.diagonal;
      for (let i = 0; i < s.length; i++) {
        if (Math.abs(s[i]) > threshold) {
          s[i] = 1 / s[i];
        } else {
          s[i] = 0;
        }
      }
      return V2.mmul(Matrix2.diag(s).mmul(U.transpose()));
    }
    function covariance2(xMatrix, yMatrix = xMatrix, options = {}) {
      xMatrix = new Matrix2(xMatrix);
      let yIsSame = false;
      if (typeof yMatrix === "object" && !Matrix2.isMatrix(yMatrix) && !isAnyArray2.isAnyArray(yMatrix)) {
        options = yMatrix;
        yMatrix = xMatrix;
        yIsSame = true;
      } else {
        yMatrix = new Matrix2(yMatrix);
      }
      if (xMatrix.rows !== yMatrix.rows) {
        throw new TypeError("Both matrices must have the same number of rows");
      }
      const { center = true } = options;
      if (center) {
        xMatrix = xMatrix.center("column");
        if (!yIsSame) {
          yMatrix = yMatrix.center("column");
        }
      }
      const cov = xMatrix.transpose().mmul(yMatrix);
      for (let i = 0; i < cov.rows; i++) {
        for (let j = 0; j < cov.columns; j++) {
          cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));
        }
      }
      return cov;
    }
    function correlation2(xMatrix, yMatrix = xMatrix, options = {}) {
      xMatrix = new Matrix2(xMatrix);
      let yIsSame = false;
      if (typeof yMatrix === "object" && !Matrix2.isMatrix(yMatrix) && !isAnyArray2.isAnyArray(yMatrix)) {
        options = yMatrix;
        yMatrix = xMatrix;
        yIsSame = true;
      } else {
        yMatrix = new Matrix2(yMatrix);
      }
      if (xMatrix.rows !== yMatrix.rows) {
        throw new TypeError("Both matrices must have the same number of rows");
      }
      const { center = true, scale: scale3 = true } = options;
      if (center) {
        xMatrix.center("column");
        if (!yIsSame) {
          yMatrix.center("column");
        }
      }
      if (scale3) {
        xMatrix.scale("column");
        if (!yIsSame) {
          yMatrix.scale("column");
        }
      }
      const sdx = xMatrix.standardDeviation("column", { unbiased: true });
      const sdy = yIsSame ? sdx : yMatrix.standardDeviation("column", { unbiased: true });
      const corr = xMatrix.transpose().mmul(yMatrix);
      for (let i = 0; i < corr.rows; i++) {
        for (let j = 0; j < corr.columns; j++) {
          corr.set(
            i,
            j,
            corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1))
          );
        }
      }
      return corr;
    }
    var EigenvalueDecomposition2 = class {
      constructor(matrix2, options = {}) {
        const { assumeSymmetric = false } = options;
        matrix2 = WrapperMatrix2D2.checkMatrix(matrix2);
        if (!matrix2.isSquare()) {
          throw new Error("Matrix is not a square matrix");
        }
        if (matrix2.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let n = matrix2.columns;
        let V2 = new Matrix2(n, n);
        let d = new Float64Array(n);
        let e = new Float64Array(n);
        let value = matrix2;
        let i, j;
        let isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix2.isSymmetric();
        }
        if (isSymmetric) {
          for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
              V2.set(i, j, value.get(i, j));
            }
          }
          tred2(n, e, d, V2);
          tql2(n, e, d, V2);
        } else {
          let H = new Matrix2(n, n);
          let ort = new Float64Array(n);
          for (j = 0; j < n; j++) {
            for (i = 0; i < n; i++) {
              H.set(i, j, value.get(i, j));
            }
          }
          orthes(n, H, ort, V2);
          hqr2(n, e, d, V2, H);
        }
        this.n = n;
        this.e = e;
        this.d = d;
        this.V = V2;
      }
      get realEigenvalues() {
        return Array.from(this.d);
      }
      get imaginaryEigenvalues() {
        return Array.from(this.e);
      }
      get eigenvectorMatrix() {
        return this.V;
      }
      get diagonalMatrix() {
        let n = this.n;
        let e = this.e;
        let d = this.d;
        let X = new Matrix2(n, n);
        let i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            X.set(i, j, 0);
          }
          X.set(i, i, d[i]);
          if (e[i] > 0) {
            X.set(i, i + 1, e[i]);
          } else if (e[i] < 0) {
            X.set(i, i - 1, e[i]);
          }
        }
        return X;
      }
    };
    function tred2(n, e, d, V2) {
      let f, g, h, i, j, k, hh, scale3;
      for (j = 0; j < n; j++) {
        d[j] = V2.get(n - 1, j);
      }
      for (i = n - 1; i > 0; i--) {
        scale3 = 0;
        h = 0;
        for (k = 0; k < i; k++) {
          scale3 = scale3 + Math.abs(d[k]);
        }
        if (scale3 === 0) {
          e[i] = d[i - 1];
          for (j = 0; j < i; j++) {
            d[j] = V2.get(i - 1, j);
            V2.set(i, j, 0);
            V2.set(j, i, 0);
          }
        } else {
          for (k = 0; k < i; k++) {
            d[k] /= scale3;
            h += d[k] * d[k];
          }
          f = d[i - 1];
          g = Math.sqrt(h);
          if (f > 0) {
            g = -g;
          }
          e[i] = scale3 * g;
          h = h - f * g;
          d[i - 1] = f - g;
          for (j = 0; j < i; j++) {
            e[j] = 0;
          }
          for (j = 0; j < i; j++) {
            f = d[j];
            V2.set(j, i, f);
            g = e[j] + V2.get(j, j) * f;
            for (k = j + 1; k <= i - 1; k++) {
              g += V2.get(k, j) * d[k];
              e[k] += V2.get(k, j) * f;
            }
            e[j] = g;
          }
          f = 0;
          for (j = 0; j < i; j++) {
            e[j] /= h;
            f += e[j] * d[j];
          }
          hh = f / (h + h);
          for (j = 0; j < i; j++) {
            e[j] -= hh * d[j];
          }
          for (j = 0; j < i; j++) {
            f = d[j];
            g = e[j];
            for (k = j; k <= i - 1; k++) {
              V2.set(k, j, V2.get(k, j) - (f * e[k] + g * d[k]));
            }
            d[j] = V2.get(i - 1, j);
            V2.set(i, j, 0);
          }
        }
        d[i] = h;
      }
      for (i = 0; i < n - 1; i++) {
        V2.set(n - 1, i, V2.get(i, i));
        V2.set(i, i, 1);
        h = d[i + 1];
        if (h !== 0) {
          for (k = 0; k <= i; k++) {
            d[k] = V2.get(k, i + 1) / h;
          }
          for (j = 0; j <= i; j++) {
            g = 0;
            for (k = 0; k <= i; k++) {
              g += V2.get(k, i + 1) * V2.get(k, j);
            }
            for (k = 0; k <= i; k++) {
              V2.set(k, j, V2.get(k, j) - g * d[k]);
            }
          }
        }
        for (k = 0; k <= i; k++) {
          V2.set(k, i + 1, 0);
        }
      }
      for (j = 0; j < n; j++) {
        d[j] = V2.get(n - 1, j);
        V2.set(n - 1, j, 0);
      }
      V2.set(n - 1, n - 1, 1);
      e[0] = 0;
    }
    function tql2(n, e, d, V2) {
      let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;
      for (i = 1; i < n; i++) {
        e[i - 1] = e[i];
      }
      e[n - 1] = 0;
      let f = 0;
      let tst1 = 0;
      let eps = Number.EPSILON;
      for (l = 0; l < n; l++) {
        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
        m = l;
        while (m < n) {
          if (Math.abs(e[m]) <= eps * tst1) {
            break;
          }
          m++;
        }
        if (m > l) {
          do {
            g = d[l];
            p = (d[l + 1] - g) / (2 * e[l]);
            r = hypotenuse(p, 1);
            if (p < 0) {
              r = -r;
            }
            d[l] = e[l] / (p + r);
            d[l + 1] = e[l] * (p + r);
            dl1 = d[l + 1];
            h = g - d[l];
            for (i = l + 2; i < n; i++) {
              d[i] -= h;
            }
            f = f + h;
            p = d[m];
            c = 1;
            c2 = c;
            c3 = c;
            el1 = e[l + 1];
            s = 0;
            s2 = 0;
            for (i = m - 1; i >= l; i--) {
              c3 = c2;
              c2 = c;
              s2 = s;
              g = c * e[i];
              h = c * p;
              r = hypotenuse(p, e[i]);
              e[i + 1] = s * r;
              s = e[i] / r;
              c = p / r;
              p = c * d[i] - s * g;
              d[i + 1] = h + s * (c * g + s * d[i]);
              for (k = 0; k < n; k++) {
                h = V2.get(k, i + 1);
                V2.set(k, i + 1, s * V2.get(k, i) + c * h);
                V2.set(k, i, c * V2.get(k, i) - s * h);
              }
            }
            p = -s * s2 * c3 * el1 * e[l] / dl1;
            e[l] = s * p;
            d[l] = c * p;
          } while (Math.abs(e[l]) > eps * tst1);
        }
        d[l] = d[l] + f;
        e[l] = 0;
      }
      for (i = 0; i < n - 1; i++) {
        k = i;
        p = d[i];
        for (j = i + 1; j < n; j++) {
          if (d[j] < p) {
            k = j;
            p = d[j];
          }
        }
        if (k !== i) {
          d[k] = d[i];
          d[i] = p;
          for (j = 0; j < n; j++) {
            p = V2.get(j, i);
            V2.set(j, i, V2.get(j, k));
            V2.set(j, k, p);
          }
        }
      }
    }
    function orthes(n, H, ort, V2) {
      let low = 0;
      let high = n - 1;
      let f, g, h, i, j, m;
      let scale3;
      for (m = low + 1; m <= high - 1; m++) {
        scale3 = 0;
        for (i = m; i <= high; i++) {
          scale3 = scale3 + Math.abs(H.get(i, m - 1));
        }
        if (scale3 !== 0) {
          h = 0;
          for (i = high; i >= m; i--) {
            ort[i] = H.get(i, m - 1) / scale3;
            h += ort[i] * ort[i];
          }
          g = Math.sqrt(h);
          if (ort[m] > 0) {
            g = -g;
          }
          h = h - ort[m] * g;
          ort[m] = ort[m] - g;
          for (j = m; j < n; j++) {
            f = 0;
            for (i = high; i >= m; i--) {
              f += ort[i] * H.get(i, j);
            }
            f = f / h;
            for (i = m; i <= high; i++) {
              H.set(i, j, H.get(i, j) - f * ort[i]);
            }
          }
          for (i = 0; i <= high; i++) {
            f = 0;
            for (j = high; j >= m; j--) {
              f += ort[j] * H.get(i, j);
            }
            f = f / h;
            for (j = m; j <= high; j++) {
              H.set(i, j, H.get(i, j) - f * ort[j]);
            }
          }
          ort[m] = scale3 * ort[m];
          H.set(m, m - 1, scale3 * g);
        }
      }
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          V2.set(i, j, i === j ? 1 : 0);
        }
      }
      for (m = high - 1; m >= low + 1; m--) {
        if (H.get(m, m - 1) !== 0) {
          for (i = m + 1; i <= high; i++) {
            ort[i] = H.get(i, m - 1);
          }
          for (j = m; j <= high; j++) {
            g = 0;
            for (i = m; i <= high; i++) {
              g += ort[i] * V2.get(i, j);
            }
            g = g / ort[m] / H.get(m, m - 1);
            for (i = m; i <= high; i++) {
              V2.set(i, j, V2.get(i, j) + g * ort[i]);
            }
          }
        }
      }
    }
    function hqr2(nn, e, d, V2, H) {
      let n = nn - 1;
      let low = 0;
      let high = nn - 1;
      let eps = Number.EPSILON;
      let exshift = 0;
      let norm = 0;
      let p = 0;
      let q = 0;
      let r = 0;
      let s = 0;
      let z = 0;
      let iter = 0;
      let i, j, k, l, m, t, w, x, y;
      let ra, sa, vr, vi;
      let notlast, cdivres;
      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          d[i] = H.get(i, i);
          e[i] = 0;
        }
        for (j = Math.max(i - 1, 0); j < nn; j++) {
          norm = norm + Math.abs(H.get(i, j));
        }
      }
      while (n >= low) {
        l = n;
        while (l > low) {
          s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));
          if (s === 0) {
            s = norm;
          }
          if (Math.abs(H.get(l, l - 1)) < eps * s) {
            break;
          }
          l--;
        }
        if (l === n) {
          H.set(n, n, H.get(n, n) + exshift);
          d[n] = H.get(n, n);
          e[n] = 0;
          n--;
          iter = 0;
        } else if (l === n - 1) {
          w = H.get(n, n - 1) * H.get(n - 1, n);
          p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;
          q = p * p + w;
          z = Math.sqrt(Math.abs(q));
          H.set(n, n, H.get(n, n) + exshift);
          H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);
          x = H.get(n, n);
          if (q >= 0) {
            z = p >= 0 ? p + z : p - z;
            d[n - 1] = x + z;
            d[n] = d[n - 1];
            if (z !== 0) {
              d[n] = x - w / z;
            }
            e[n - 1] = 0;
            e[n] = 0;
            x = H.get(n, n - 1);
            s = Math.abs(x) + Math.abs(z);
            p = x / s;
            q = z / s;
            r = Math.sqrt(p * p + q * q);
            p = p / r;
            q = q / r;
            for (j = n - 1; j < nn; j++) {
              z = H.get(n - 1, j);
              H.set(n - 1, j, q * z + p * H.get(n, j));
              H.set(n, j, q * H.get(n, j) - p * z);
            }
            for (i = 0; i <= n; i++) {
              z = H.get(i, n - 1);
              H.set(i, n - 1, q * z + p * H.get(i, n));
              H.set(i, n, q * H.get(i, n) - p * z);
            }
            for (i = low; i <= high; i++) {
              z = V2.get(i, n - 1);
              V2.set(i, n - 1, q * z + p * V2.get(i, n));
              V2.set(i, n, q * V2.get(i, n) - p * z);
            }
          } else {
            d[n - 1] = x + p;
            d[n] = x + p;
            e[n - 1] = z;
            e[n] = -z;
          }
          n = n - 2;
          iter = 0;
        } else {
          x = H.get(n, n);
          y = 0;
          w = 0;
          if (l < n) {
            y = H.get(n - 1, n - 1);
            w = H.get(n, n - 1) * H.get(n - 1, n);
          }
          if (iter === 10) {
            exshift += x;
            for (i = low; i <= n; i++) {
              H.set(i, i, H.get(i, i) - x);
            }
            s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));
            x = y = 0.75 * s;
            w = -0.4375 * s * s;
          }
          if (iter === 30) {
            s = (y - x) / 2;
            s = s * s + w;
            if (s > 0) {
              s = Math.sqrt(s);
              if (y < x) {
                s = -s;
              }
              s = x - w / ((y - x) / 2 + s);
              for (i = low; i <= n; i++) {
                H.set(i, i, H.get(i, i) - s);
              }
              exshift += s;
              x = y = w = 0.964;
            }
          }
          iter = iter + 1;
          m = n - 2;
          while (m >= l) {
            z = H.get(m, m);
            r = x - z;
            s = y - z;
            p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);
            q = H.get(m + 1, m + 1) - z - r - s;
            r = H.get(m + 2, m + 1);
            s = Math.abs(p) + Math.abs(q) + Math.abs(r);
            p = p / s;
            q = q / s;
            r = r / s;
            if (m === l) {
              break;
            }
            if (Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H.get(m - 1, m - 1)) + Math.abs(z) + Math.abs(H.get(m + 1, m + 1))))) {
              break;
            }
            m--;
          }
          for (i = m + 2; i <= n; i++) {
            H.set(i, i - 2, 0);
            if (i > m + 2) {
              H.set(i, i - 3, 0);
            }
          }
          for (k = m; k <= n - 1; k++) {
            notlast = k !== n - 1;
            if (k !== m) {
              p = H.get(k, k - 1);
              q = H.get(k + 1, k - 1);
              r = notlast ? H.get(k + 2, k - 1) : 0;
              x = Math.abs(p) + Math.abs(q) + Math.abs(r);
              if (x !== 0) {
                p = p / x;
                q = q / x;
                r = r / x;
              }
            }
            if (x === 0) {
              break;
            }
            s = Math.sqrt(p * p + q * q + r * r);
            if (p < 0) {
              s = -s;
            }
            if (s !== 0) {
              if (k !== m) {
                H.set(k, k - 1, -s * x);
              } else if (l !== m) {
                H.set(k, k - 1, -H.get(k, k - 1));
              }
              p = p + s;
              x = p / s;
              y = q / s;
              z = r / s;
              q = q / p;
              r = r / p;
              for (j = k; j < nn; j++) {
                p = H.get(k, j) + q * H.get(k + 1, j);
                if (notlast) {
                  p = p + r * H.get(k + 2, j);
                  H.set(k + 2, j, H.get(k + 2, j) - p * z);
                }
                H.set(k, j, H.get(k, j) - p * x);
                H.set(k + 1, j, H.get(k + 1, j) - p * y);
              }
              for (i = 0; i <= Math.min(n, k + 3); i++) {
                p = x * H.get(i, k) + y * H.get(i, k + 1);
                if (notlast) {
                  p = p + z * H.get(i, k + 2);
                  H.set(i, k + 2, H.get(i, k + 2) - p * r);
                }
                H.set(i, k, H.get(i, k) - p);
                H.set(i, k + 1, H.get(i, k + 1) - p * q);
              }
              for (i = low; i <= high; i++) {
                p = x * V2.get(i, k) + y * V2.get(i, k + 1);
                if (notlast) {
                  p = p + z * V2.get(i, k + 2);
                  V2.set(i, k + 2, V2.get(i, k + 2) - p * r);
                }
                V2.set(i, k, V2.get(i, k) - p);
                V2.set(i, k + 1, V2.get(i, k + 1) - p * q);
              }
            }
          }
        }
      }
      if (norm === 0) {
        return;
      }
      for (n = nn - 1; n >= 0; n--) {
        p = d[n];
        q = e[n];
        if (q === 0) {
          l = n;
          H.set(n, n, 1);
          for (i = n - 1; i >= 0; i--) {
            w = H.get(i, i) - p;
            r = 0;
            for (j = l; j <= n; j++) {
              r = r + H.get(i, j) * H.get(j, n);
            }
            if (e[i] < 0) {
              z = w;
              s = r;
            } else {
              l = i;
              if (e[i] === 0) {
                H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));
              } else {
                x = H.get(i, i + 1);
                y = H.get(i + 1, i);
                q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                t = (x * s - z * r) / q;
                H.set(i, n, t);
                H.set(
                  i + 1,
                  n,
                  Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z
                );
              }
              t = Math.abs(H.get(i, n));
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H.set(j, n, H.get(j, n) / t);
                }
              }
            }
          }
        } else if (q < 0) {
          l = n - 1;
          if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {
            H.set(n - 1, n - 1, q / H.get(n, n - 1));
            H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));
          } else {
            cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);
            H.set(n - 1, n - 1, cdivres[0]);
            H.set(n - 1, n, cdivres[1]);
          }
          H.set(n, n - 1, 0);
          H.set(n, n, 1);
          for (i = n - 2; i >= 0; i--) {
            ra = 0;
            sa = 0;
            for (j = l; j <= n; j++) {
              ra = ra + H.get(i, j) * H.get(j, n - 1);
              sa = sa + H.get(i, j) * H.get(j, n);
            }
            w = H.get(i, i) - p;
            if (e[i] < 0) {
              z = w;
              r = ra;
              s = sa;
            } else {
              l = i;
              if (e[i] === 0) {
                cdivres = cdiv(-ra, -sa, w, q);
                H.set(i, n - 1, cdivres[0]);
                H.set(i, n, cdivres[1]);
              } else {
                x = H.get(i, i + 1);
                y = H.get(i + 1, i);
                vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
                vi = (d[i] - p) * 2 * q;
                if (vr === 0 && vi === 0) {
                  vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));
                }
                cdivres = cdiv(
                  x * r - z * ra + q * sa,
                  x * s - z * sa - q * ra,
                  vr,
                  vi
                );
                H.set(i, n - 1, cdivres[0]);
                H.set(i, n, cdivres[1]);
                if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
                  H.set(
                    i + 1,
                    n - 1,
                    (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x
                  );
                  H.set(
                    i + 1,
                    n,
                    (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x
                  );
                } else {
                  cdivres = cdiv(
                    -r - y * H.get(i, n - 1),
                    -s - y * H.get(i, n),
                    z,
                    q
                  );
                  H.set(i + 1, n - 1, cdivres[0]);
                  H.set(i + 1, n, cdivres[1]);
                }
              }
              t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H.set(j, n - 1, H.get(j, n - 1) / t);
                  H.set(j, n, H.get(j, n) / t);
                }
              }
            }
          }
        }
      }
      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          for (j = i; j < nn; j++) {
            V2.set(i, j, H.get(i, j));
          }
        }
      }
      for (j = nn - 1; j >= low; j--) {
        for (i = low; i <= high; i++) {
          z = 0;
          for (k = low; k <= Math.min(j, high); k++) {
            z = z + V2.get(i, k) * H.get(k, j);
          }
          V2.set(i, j, z);
        }
      }
    }
    function cdiv(xr, xi, yr, yi) {
      let r, d;
      if (Math.abs(yr) > Math.abs(yi)) {
        r = yi / yr;
        d = yr + r * yi;
        return [(xr + r * xi) / d, (xi - r * xr) / d];
      } else {
        r = yr / yi;
        d = yi + r * yr;
        return [(r * xr + xi) / d, (r * xi - xr) / d];
      }
    }
    var CholeskyDecomposition2 = class {
      constructor(value) {
        value = WrapperMatrix2D2.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error("Matrix is not symmetric");
        }
        let a = value;
        let dimension = a.rows;
        let l = new Matrix2(dimension, dimension);
        let positiveDefinite = true;
        let i, j, k;
        for (j = 0; j < dimension; j++) {
          let d = 0;
          for (k = 0; k < j; k++) {
            let s = 0;
            for (i = 0; i < k; i++) {
              s += l.get(k, i) * l.get(j, i);
            }
            s = (a.get(j, k) - s) / l.get(k, k);
            l.set(j, k, s);
            d = d + s * s;
          }
          d = a.get(j, j) - d;
          positiveDefinite &&= d > 0;
          l.set(j, j, Math.sqrt(Math.max(d, 0)));
          for (k = j + 1; k < dimension; k++) {
            l.set(j, k, 0);
          }
        }
        this.L = l;
        this.positiveDefinite = positiveDefinite;
      }
      isPositiveDefinite() {
        return this.positiveDefinite;
      }
      solve(value) {
        value = WrapperMatrix2D2.checkMatrix(value);
        let l = this.L;
        let dimension = l.rows;
        if (value.rows !== dimension) {
          throw new Error("Matrix dimensions do not match");
        }
        if (this.isPositiveDefinite() === false) {
          throw new Error("Matrix is not positive definite");
        }
        let count = value.columns;
        let B2 = value.clone();
        let i, j, k;
        for (k = 0; k < dimension; k++) {
          for (j = 0; j < count; j++) {
            for (i = 0; i < k; i++) {
              B2.set(k, j, B2.get(k, j) - B2.get(i, j) * l.get(k, i));
            }
            B2.set(k, j, B2.get(k, j) / l.get(k, k));
          }
        }
        for (k = dimension - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            for (i = k + 1; i < dimension; i++) {
              B2.set(k, j, B2.get(k, j) - B2.get(i, j) * l.get(i, k));
            }
            B2.set(k, j, B2.get(k, j) / l.get(k, k));
          }
        }
        return B2;
      }
      get lowerTriangularMatrix() {
        return this.L;
      }
    };
    var nipals = class {
      constructor(X, options = {}) {
        X = WrapperMatrix2D2.checkMatrix(X);
        let { Y } = options;
        const {
          scaleScores = false,
          maxIterations = 1e3,
          terminationCriteria = 1e-10
        } = options;
        let u4;
        if (Y) {
          if (isAnyArray2.isAnyArray(Y) && typeof Y[0] === "number") {
            Y = Matrix2.columnVector(Y);
          } else {
            Y = WrapperMatrix2D2.checkMatrix(Y);
          }
          if (Y.rows !== X.rows) {
            throw new Error("Y should have the same number of rows as X");
          }
          u4 = Y.getColumnVector(0);
        } else {
          u4 = X.getColumnVector(0);
        }
        let diff = 1;
        let t, q, w, tOld;
        for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {
          w = X.transpose().mmul(u4).div(u4.transpose().mmul(u4).get(0, 0));
          w = w.div(w.norm());
          t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));
          if (counter > 0) {
            diff = t.clone().sub(tOld).pow(2).sum();
          }
          tOld = t.clone();
          if (Y) {
            q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
            q = q.div(q.norm());
            u4 = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));
          } else {
            u4 = t;
          }
        }
        if (Y) {
          let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
          p = p.div(p.norm());
          let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));
          let residual = u4.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
          let yResidual = Y.clone().sub(
            t.clone().mulS(residual.get(0, 0)).mmul(q.transpose())
          );
          this.t = t;
          this.p = p.transpose();
          this.w = w.transpose();
          this.q = q;
          this.u = u4;
          this.s = t.transpose().mmul(t);
          this.xResidual = xResidual;
          this.yResidual = yResidual;
          this.betas = residual;
        } else {
          this.w = w.transpose();
          this.s = t.transpose().mmul(t).sqrt();
          if (scaleScores) {
            this.t = t.clone().div(this.s.get(0, 0));
          } else {
            this.t = t;
          }
          this.xResidual = X.sub(t.mmul(w.transpose()));
        }
      }
    };
    exports2.AbstractMatrix = AbstractMatrix2;
    exports2.CHO = CholeskyDecomposition2;
    exports2.CholeskyDecomposition = CholeskyDecomposition2;
    exports2.DistanceMatrix = DistanceMatrix2;
    exports2.EVD = EigenvalueDecomposition2;
    exports2.EigenvalueDecomposition = EigenvalueDecomposition2;
    exports2.LU = LuDecomposition2;
    exports2.LuDecomposition = LuDecomposition2;
    exports2.Matrix = Matrix2;
    exports2.MatrixColumnSelectionView = MatrixColumnSelectionView2;
    exports2.MatrixColumnView = MatrixColumnView2;
    exports2.MatrixFlipColumnView = MatrixFlipColumnView2;
    exports2.MatrixFlipRowView = MatrixFlipRowView2;
    exports2.MatrixRowSelectionView = MatrixRowSelectionView2;
    exports2.MatrixRowView = MatrixRowView2;
    exports2.MatrixSelectionView = MatrixSelectionView2;
    exports2.MatrixSubView = MatrixSubView2;
    exports2.MatrixTransposeView = MatrixTransposeView2;
    exports2.NIPALS = nipals;
    exports2.Nipals = nipals;
    exports2.QR = QrDecomposition2;
    exports2.QrDecomposition = QrDecomposition2;
    exports2.SVD = SingularValueDecomposition3;
    exports2.SingularValueDecomposition = SingularValueDecomposition3;
    exports2.SymmetricMatrix = SymmetricMatrix2;
    exports2.WrapperMatrix1D = WrapperMatrix1D2;
    exports2.WrapperMatrix2D = WrapperMatrix2D2;
    exports2.correlation = correlation2;
    exports2.covariance = covariance2;
    exports2.default = Matrix2;
    exports2.determinant = determinant2;
    exports2.inverse = inverse35;
    exports2.linearDependencies = linearDependencies2;
    exports2.pseudoInverse = pseudoInverse3;
    exports2.solve = solve2;
    exports2.wrap = wrap4;
  }
});

// node_modules/@allmaps/openlayers/node_modules/ol/events/Event.js
var BaseEvent = class {
  /**
   * @param {string} type Type.
   */
  constructor(type) {
    this.propagationStopped;
    this.defaultPrevented;
    this.type = type;
    this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = true;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
};
var Event_default = BaseEvent;

// node_modules/@allmaps/openlayers/node_modules/ol/ObjectEventType.js
var ObjectEventType_default = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};

// node_modules/@allmaps/openlayers/node_modules/ol/Disposable.js
var Disposable = class {
  constructor() {
    this.disposed = false;
  }
  /**
   * Clean up.
   */
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
};
var Disposable_default = Disposable;

// node_modules/@allmaps/openlayers/node_modules/ol/array.js
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@allmaps/openlayers/node_modules/ol/functions.js
function VOID() {
}
function memoizeOne(fn) {
  let called = false;
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}

// node_modules/@allmaps/openlayers/node_modules/ol/obj.js
function clear(object) {
  for (const property2 in object) {
    delete object[property2];
  }
}
function isEmpty(object) {
  let property2;
  for (property2 in object) {
    return false;
  }
  return !property2;
}

// node_modules/@allmaps/openlayers/node_modules/ol/events/Target.js
var Target = class extends Disposable_default {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(target) {
    super();
    this.eventTarget_ = target;
    this.pendingRemovals_ = null;
    this.dispatching_ = null;
    this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(type, listener) {
    if (!type || !listener) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener)) {
      listenersForType.push(listener);
    }
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(event) {
    const isString2 = typeof event === "string";
    const type = isString2 ? event : event.type;
    const listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }
    const evt = isString2 ? new Event_default(event) : (
      /** @type {Event} */
      event
    );
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    const dispatching = this.dispatching_ || (this.dispatching_ = {});
    const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    let propagate;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      if ("handleEvent" in listeners[i]) {
        propagate = /** @type {import("../events.js").ListenerObject} */
        listeners[i].handleEvent(evt);
      } else {
        propagate = /** @type {import("../events.js").ListenerFunction} */
        listeners[i].call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      let pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && clear(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(type) {
    return this.listeners_ && this.listeners_[type] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(type) {
    if (!this.listeners_) {
      return false;
    }
    return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(type, listener) {
    if (!this.listeners_) {
      return;
    }
    const listeners = this.listeners_[type];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      if (this.pendingRemovals_ && type in this.pendingRemovals_) {
        listeners[index] = VOID;
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  }
};
var Target_default = Target;

// node_modules/@allmaps/openlayers/node_modules/ol/events/EventType.js
var EventType_default = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};

// node_modules/@allmaps/openlayers/node_modules/ol/events.js
function listen(target, type, listener, thisArg, once2) {
  if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  if (once2) {
    const originalListener = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}

// node_modules/@allmaps/openlayers/node_modules/ol/Observable.js
var Observable = class extends Target_default {
  constructor() {
    super();
    this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal;
    this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal;
    this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal;
    this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_;
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(type, listener) {
    if (Array.isArray(type)) {
      const len = type.length;
      const keys2 = new Array(len);
      for (let i = 0; i < len; ++i) {
        keys2[i] = listen(this, type[i], listener);
      }
      return keys2;
    }
    return listen(
      this,
      /** @type {string} */
      type,
      listener
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(type, listener) {
    let key;
    if (Array.isArray(type)) {
      const len = type.length;
      key = new Array(len);
      for (let i = 0; i < len; ++i) {
        key[i] = listenOnce(this, type[i], listener);
      }
    } else {
      key = listenOnce(
        this,
        /** @type {string} */
        type,
        listener
      );
    }
    listener.ol_key = key;
    return key;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(type, listener) {
    const key = (
      /** @type {Object} */
      listener.ol_key
    );
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (let i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  }
};
Observable.prototype.on;
Observable.prototype.once;
Observable.prototype.un;
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
var Observable_default = Observable;

// node_modules/@allmaps/openlayers/node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
var uidCounter_ = 0;
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

// node_modules/@allmaps/openlayers/node_modules/ol/Object.js
var ObjectEvent = class extends Event_default {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(type, key, oldValue) {
    super(type);
    this.key = key;
    this.oldValue = oldValue;
  }
};
var BaseObject = class extends Observable_default {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(values2) {
    super();
    this.on;
    this.once;
    this.un;
    getUid(this);
    this.values_ = null;
    if (values2 !== void 0) {
      this.setProperties(values2);
    }
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(key) {
    let value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(key, oldValue) {
    let eventType;
    eventType = `change:${key}`;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = ObjectEventType_default.PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(key, listener) {
    this.addEventListener(`change:${key}`, listener);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(key, listener) {
    this.removeEventListener(`change:${key}`, listener);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(key, value, silent) {
    const values2 = this.values_ || (this.values_ = {});
    if (silent) {
      values2[key] = value;
    } else {
      const oldValue = values2[key];
      values2[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(values2, silent) {
    for (const key in values2) {
      this.set(key, values2[key], silent);
    }
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(source) {
    if (!source.values_) {
      return;
    }
    Object.assign(this.values_ || (this.values_ = {}), source.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(key, silent) {
    if (this.values_ && key in this.values_) {
      const oldValue = this.values_[key];
      delete this.values_[key];
      if (isEmpty(this.values_)) {
        this.values_ = null;
      }
      if (!silent) {
        this.notify(key, oldValue);
      }
    }
  }
};
var Object_default = BaseObject;

// node_modules/@allmaps/openlayers/node_modules/ol/layer/Property.js
var Property_default = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};

// node_modules/@allmaps/openlayers/node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}

// node_modules/@allmaps/openlayers/node_modules/ol/math.js
function clamp(value, min3, max3) {
  return Math.min(Math.max(value, min3), max3);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance2(x, y, x1, y1);
}
function squaredDistance2(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}

// node_modules/@allmaps/openlayers/node_modules/ol/layer/Base.js
var BaseLayer = class extends Object_default {
  /**
   * @param {Options} options Layer options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.background_ = options.background;
    const properties = Object.assign({}, options);
    if (typeof options.properties === "object") {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }
    properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
    assert(
      typeof properties[Property_default.OPACITY] === "number",
      "Layer opacity must be a number"
    );
    properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
    properties[Property_default.Z_INDEX] = options.zIndex;
    properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
    properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
    properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
    properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
    this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
    delete properties.className;
    this.setProperties(properties);
    this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(managed) {
    const state = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: managed === void 0 ? true : managed
    };
    const zIndex = this.getZIndex();
    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    return abstract();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(states) {
    return abstract();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(Property_default.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(Property_default.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(Property_default.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(Property_default.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(Property_default.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(Property_default.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return abstract();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(Property_default.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(Property_default.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(background) {
    this.background_ = background;
    this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(extent) {
    this.set(Property_default.EXTENT, extent);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(maxResolution) {
    this.set(Property_default.MAX_RESOLUTION, maxResolution);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(minResolution) {
    this.set(Property_default.MIN_RESOLUTION, minResolution);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(maxZoom) {
    this.set(Property_default.MAX_ZOOM, maxZoom);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(minZoom) {
    this.set(Property_default.MIN_ZOOM, minZoom);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(opacity) {
    assert(typeof opacity === "number", "Layer opacity must be a number");
    this.set(Property_default.OPACITY, opacity);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(visible) {
    this.set(Property_default.VISIBLE, visible);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(zindex) {
    this.set(Property_default.Z_INDEX, zindex);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }
    super.disposeInternal();
  }
};
var Base_default = BaseLayer;

// node_modules/@allmaps/openlayers/node_modules/ol/render/EventType.js
var EventType_default2 = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
};

// node_modules/@allmaps/openlayers/node_modules/ol/ViewHint.js
var ViewHint_default = {
  ANIMATING: 0,
  INTERACTING: 1
};

// node_modules/@allmaps/openlayers/node_modules/ol/ViewProperty.js
var ViewProperty_default = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};

// node_modules/@allmaps/openlayers/node_modules/ol/tilegrid/common.js
var DEFAULT_TILE_SIZE = 256;

// node_modules/@allmaps/openlayers/node_modules/ol/proj/Units.js
var METERS_PER_UNIT = {
  // use the radius of the Normal sphere
  "radians": 6370997 / (2 * Math.PI),
  "degrees": 2 * Math.PI * 6370997 / 360,
  "ft": 0.3048,
  "m": 1,
  "us-ft": 1200 / 3937
};

// node_modules/@allmaps/openlayers/node_modules/ol/proj/Projection.js
var Projection = class {
  /**
   * @param {Options} options Projection options.
   */
  constructor(options) {
    this.code_ = options.code;
    this.units_ = /** @type {import("./Units.js").Units} */
    options.units;
    this.extent_ = options.extent !== void 0 ? options.extent : null;
    this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
    this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
    this.global_ = options.global !== void 0 ? options.global : false;
    this.canWrapX_ = !!(this.global_ && this.extent_);
    this.getPointResolutionFunc_ = options.getPointResolution;
    this.defaultTileGrid_ = null;
    this.metersPerUnit_ = options.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(global2) {
    this.global_ = global2;
    this.canWrapX_ = !!(global2 && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(worldExtent) {
    this.worldExtent_ = worldExtent;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(func) {
    this.getPointResolutionFunc_ = func;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
var Projection_default = Projection;

// node_modules/@allmaps/openlayers/node_modules/ol/proj/epsg3857.js
var RADIUS = 6378137;
var HALF_SIZE = Math.PI * RADIUS;
var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
var WORLD_EXTENT = [-180, -85, 180, 85];
var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
var EPSG3857Projection = class extends Projection_default {
  /**
   * @param {string} code Code.
   */
  constructor(code) {
    super({
      code,
      units: "m",
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point2) {
        return resolution / Math.cosh(point2[1] / RADIUS);
      }
    });
  }
};
var PROJECTIONS = [
  new EPSG3857Projection("EPSG:3857"),
  new EPSG3857Projection("EPSG:102100"),
  new EPSG3857Projection("EPSG:102113"),
  new EPSG3857Projection("EPSG:900913"),
  new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

// node_modules/@allmaps/openlayers/node_modules/ol/proj/epsg4326.js
var RADIUS2 = 6378137;
var EXTENT2 = [-180, -90, 180, 90];
var METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
var EPSG4326Projection = class extends Projection_default {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(code, axisOrientation) {
    super({
      code,
      units: "degrees",
      extent: EXTENT2,
      axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT2,
      worldExtent: EXTENT2
    });
  }
};
var PROJECTIONS2 = [
  new EPSG4326Projection("CRS:84"),
  new EPSG4326Projection("EPSG:4326", "neu"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];

// node_modules/@allmaps/openlayers/node_modules/ol/proj/projections.js
var cache = {};
function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add(code, projection) {
  cache[code] = projection;
}

// node_modules/@allmaps/openlayers/node_modules/ol/proj/transforms.js
var transforms = {};
function add2(source, destination2, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination2.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get2(sourceCode, destinationCode) {
  let transform4;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform4 = transforms[sourceCode][destinationCode];
  }
  return transform4;
}

// node_modules/@allmaps/openlayers/node_modules/ol/extent/Relationship.js
var Relationship_default = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};

// node_modules/@allmaps/openlayers/node_modules/ol/extent.js
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset2, end, stride);
}
function extendFlatCoordinates(extent, flatCoordinates, offset2, end, stride) {
  for (; offset2 < end; offset2 += stride) {
    extendXY(extent, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);
  }
  return extent;
}
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getForViewAndSize(center, resolution, rotation, size2, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size2
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size2) {
  const dx = resolution * size2[0] / 2;
  const dy = resolution * size2[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty2(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function intersectsSegment(extent, start2, end) {
  let intersects2 = false;
  const startRel = coordinateRelationship(extent, start2);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects2 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start2[0];
    const startY = start2[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
    if (!intersects2 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
  }
  return intersects2;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty2(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates2.push(
        extent[0] + width * i / stops,
        extent[1],
        extent[2],
        extent[1] + height * i / stops,
        extent[2] - width * i / stops,
        extent[3],
        extent[0],
        extent[3] - height * i / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates2.length; i < l; i += 2) {
    xs.push(coordinates2[i]);
    ys.push(coordinates2[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}

// node_modules/@allmaps/openlayers/node_modules/ol/coordinate.js
function add3(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function equals2(coordinate1, coordinate2) {
  let equals3 = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals3 = false;
      break;
    }
  }
  return equals3;
}
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}

// node_modules/@allmaps/openlayers/node_modules/ol/console.js
var levels = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
var level = levels.info;
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}

// node_modules/@allmaps/openlayers/node_modules/ol/proj.js
var showCoordinateWarning = true;
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, output) {
  if (output !== void 0 && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}
function addProjection(projection) {
  add(projection.getCode(), projection);
  add2(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get3(projectionLike) {
  return typeof projectionLike === "string" ? get(
    /** @type {string} */
    projectionLike
  ) : (
    /** @type {Projection} */
    projectionLike || null
  );
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination2) {
      if (source !== destination2) {
        add2(source, destination2, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add2(projection1, projection2, forwardTransform);
      add2(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get3(defaultCode);
  }
  if (typeof projection === "string") {
    return get3(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = get2(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination2) {
  const sourceProjection = get3(source);
  const destinationProjection = get3(destination2);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination2) {
  const transformFunc = getTransform(source, destination2);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source, destination2, stops) {
  const transformFunc = getTransform(source, destination2);
  return applyTransform(extent, transformFunc, void 0, stops);
}
var userProjection = null;
function getUserProjection() {
  return userProjection;
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals2(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
addCommon();

// node_modules/@allmaps/openlayers/node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    (function(center, resolution, size2, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size2[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size2[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x = clamp(center[0], minX, maxX);
      let y = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    })
  );
}
function none(center) {
  return center;
}

// node_modules/@allmaps/openlayers/node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result2 = Math.min(resolution, maxResolution);
  const ratio = 50;
  result2 *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result2 = Math.max(result2, minResolution);
    result2 /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result2, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    (function(resolution, direction, size2, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size2,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return void 0;
    })
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    (function(resolution, direction, size2, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size2,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset2 = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset2
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    })
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    (function(resolution, direction, size2, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size2,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    })
  );
}

// node_modules/@allmaps/openlayers/node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n) {
  const theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    (function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    })
  );
}
function createSnapToZero(tolerance) {
  const t = tolerance === void 0 ? toRadians(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    (function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t) {
        return 0;
      }
      return rotation;
    })
  );
}

// node_modules/@allmaps/openlayers/node_modules/ol/easing.js
function easeIn(t) {
  return Math.pow(t, 3);
}
function easeOut(t) {
  return 1 - easeIn(1 - t);
}
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}

// node_modules/@allmaps/openlayers/node_modules/ol/has.js
var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
var FIREFOX = ua.includes("firefox");
var SAFARI = ua.includes("safari") && !ua.includes("chrom");
var SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
var WEBKIT = ua.includes("webkit") && !ua.includes("edge");
var MAC = ua.includes("macintosh");
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
var PASSIVE_EVENT_LISTENERS = (function() {
  let passive = false;
  try {
    const options = Object.defineProperty({}, "passive", {
      get: function() {
        passive = true;
      }
    });
    window.addEventListener("_", null, options);
    window.removeEventListener("_", null, options);
  } catch (error) {
  }
  return passive;
})();

// node_modules/@allmaps/openlayers/node_modules/ol/transform.js
var tmp_ = new Array(6);
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function compose(transform4, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform4[0] = sx * cos;
  transform4[1] = sy * sin;
  transform4[2] = -sx * sin;
  transform4[3] = sy * cos;
  transform4[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform4[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform4;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset2, end, stride, transform4, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform4[0] * x + transform4[2] * y + transform4[4];
    dest[i++] = transform4[1] * x + transform4[3] * y + transform4[5];
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate2(flatCoordinates, offset2, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale(flatCoordinates, offset2, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate(flatCoordinates, offset2, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/Geometry.js
var tmpTransform = create();
var Geometry = class extends Object_default {
  constructor() {
    super();
    this.extent_ = createEmpty();
    this.extentRevision_ = -1;
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = 0;
    this.simplifyTransformedInternal = memoizeOne(
      (revision, squaredTolerance, transform4) => {
        if (!transform4) {
          return this.getSimplifiedGeometry(squaredTolerance);
        }
        const clone2 = this.clone();
        clone2.applyTransform(transform4);
        return clone2.getSimplifiedGeometry(squaredTolerance);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(squaredTolerance, transform4) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      squaredTolerance,
      transform4
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return abstract();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    return abstract();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    const coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(point2, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point2[0], point2[1], closestPoint, Infinity);
    return closestPoint;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return abstract();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(extent) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent2 = this.computeExtent(this.extent_);
      if (isNaN(extent2[0]) || isNaN(extent2[1])) {
        createOrUpdateEmpty(extent2);
      }
      this.extentRevision_ = this.getRevision();
    }
    return returnOrUpdate(this.extent_, extent);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    abstract();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    abstract();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    return abstract();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return abstract();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(transformFn) {
    abstract();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(extent) {
    return abstract();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    abstract();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(source, destination2) {
    const sourceProj = get3(source);
    const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
      const pixelExtent = sourceProj.getExtent();
      const projectedExtent = sourceProj.getWorldExtent();
      const scale3 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(
        tmpTransform,
        projectedExtent[0],
        projectedExtent[3],
        scale3,
        -scale3,
        0,
        0,
        0
      );
      transform2D(
        inCoordinates,
        0,
        inCoordinates.length,
        stride,
        tmpTransform,
        outCoordinates
      );
      return getTransform(sourceProj, destination2)(
        inCoordinates,
        outCoordinates,
        stride
      );
    } : getTransform(sourceProj, destination2);
    this.applyTransform(transformFn);
    return this;
  }
};
var Geometry_default = Geometry;

// node_modules/@allmaps/openlayers/node_modules/ol/geom/SimpleGeometry.js
var SimpleGeometry = class extends Geometry_default {
  constructor() {
    super();
    this.layout = "XY";
    this.stride = 2;
    this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return createOrUpdateFromFlatCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return abstract();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(coordinates2, layout) {
    abstract();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(layout, coordinates2, nesting) {
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i = 0; i < nesting; ++i) {
        if (coordinates2.length === 0) {
          this.layout = "XY";
          this.stride = 2;
          return;
        }
        coordinates2 = /** @type {Array<unknown>} */
        coordinates2[0];
      }
      stride = coordinates2.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      rotate2(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        angle,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    if (sy === void 0) {
      sy = sx;
    }
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      scale(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        sx,
        sy,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      translate(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        deltaX,
        deltaY,
        flatCoordinates
      );
      this.changed();
    }
  }
};
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
var SimpleGeometry_default = SimpleGeometry;

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset3;
  if (dx === 0 && dy === 0) {
    offset3 = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset3 = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset3 = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset3 + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset2, end, stride, max3) {
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  for (offset2 += stride; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    const squaredDelta = squaredDistance2(x1, y1, x2, y2);
    if (squaredDelta > max3) {
      max3 = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max3;
}
function arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max3) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max3 = maxSquaredDelta(flatCoordinates, offset2, end, stride, max3);
    offset2 = end;
  }
  return max3;
}
function assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset2 == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance3;
  if (maxDelta === 0) {
    squaredDistance3 = squaredDistance2(
      x,
      y,
      flatCoordinates[offset2],
      flatCoordinates[offset2 + 1]
    );
    if (squaredDistance3 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset2 + i];
      }
      closestPoint.length = stride;
      return squaredDistance3;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset2 + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance3 = squaredDistance2(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max(
        (Math.sqrt(squaredDistance3) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset2,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance3 = squaredDistance2(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset2,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset2 = end;
  }
  return minSquaredDistance;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset2, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset2++] = coordinate[i];
  }
  return offset2;
}
function deflateCoordinates(flatCoordinates, offset2, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset2++] = coordinate[j];
    }
  }
  return offset2;
}
function deflateCoordinatesArray(flatCoordinates, offset2, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset2,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset2 = end;
  }
  ends.length = i;
  return ends;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/simplify.js
function douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n = (end - offset2) / stride;
  if (n < 3) {
    for (; offset2 < end; offset2 += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  const stack = [offset2, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last2 = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last2];
    const y2 = flatCoordinates[last2 + 1];
    for (let i = first + stride; i < last2; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance3 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance3 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance3;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset2) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last2) {
        stack.push(index, last2);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset2 == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset2], tolerance);
  let y1 = snap(flatCoordinates[offset2 + 1], tolerance);
  offset2 += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset2], tolerance);
    y2 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (offset2 == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset2 < end) {
    const x3 = snap(flatCoordinates[offset2], tolerance);
    const y3 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset2,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset2, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset2,
      end,
      stride,
      coordinatess[i]
    );
    offset2 = end;
  }
  coordinatess.length = i;
  return coordinatess;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset2, end, stride) {
  let twiceArea = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset2, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset2, end, stride);
    offset2 = end;
  }
  return area;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/LinearRing.js
var LinearRing = class _LinearRing extends SimpleGeometry_default {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates2, layout) {
    super();
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */
        coordinates2
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        coordinates2,
        layout
      );
    }
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new _LinearRing(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        maxSquaredDelta(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return linearRing(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return inflateCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new _LinearRing(simplifiedFlatCoordinates, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return false;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var LinearRing_default = LinearRing;

// node_modules/@allmaps/openlayers/node_modules/ol/geom/Point.js
var Point = class _Point extends SimpleGeometry_default {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates2, layout) {
    super();
    this.setCoordinates(coordinates2, layout);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const point2 = new _Point(this.flatCoordinates.slice(), this.layout);
    point2.applyProperties(this);
    return point2;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance3 = squaredDistance2(
      x,
      y,
      flatCoordinates[0],
      flatCoordinates[1]
    );
    if (squaredDistance3 < minSquaredDistance) {
      const stride = this.stride;
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance3;
    }
    return minSquaredDistance;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinate(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var Point_default = Point;

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset2, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset2,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset2, end, stride, x, y) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset2, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset2; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset2, end, stride, callback) {
  let ret;
  offset2 += stride;
  for (; offset2 < end; offset2 += stride) {
    ret = callback(
      flatCoordinates.slice(offset2 - stride, offset2),
      flatCoordinates.slice(offset2, offset2 + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset2, end, stride, extent) {
  const coordinatesExtent = extendFlatCoordinates(
    createEmpty(),
    flatCoordinates,
    offset2,
    end,
    stride
  );
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset2,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLinearRing(flatCoordinates, offset2, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset2, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset2, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i - 1],
      ends[i],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset2, end, stride) {
  while (offset2 < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset2 + i];
      flatCoordinates[offset2 + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset2 += stride;
    end -= stride;
  }
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset2, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset2,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset2 = end;
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset2,
      end,
      stride
    );
    const reverse2 = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse2) {
      coordinates(flatCoordinates, offset2, end, stride);
    }
    offset2 = end;
  }
  return offset2;
}

// node_modules/@allmaps/openlayers/node_modules/ol/geom/Polygon.js
var Polygon = class _Polygon extends SimpleGeometry_default {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(coordinates2, layout, ends) {
    super();
    this.ends_ = [];
    this.flatInteriorPointRevision_ = -1;
    this.flatInteriorPoint_ = null;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    this.orientedRevision_ = -1;
    this.orientedFlatCoordinates_ = null;
    if (layout !== void 0 && ends) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */
        coordinates2
      );
      this.ends_ = ends;
    } else {
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        coordinates2,
        layout
      );
    }
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(linearRing2) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
    } else {
      extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const polygon = new _Polygon(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    polygon.applyProperties(this);
    return polygon;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        arrayMaxSquaredDelta(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    return linearRingsContainsXY(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      x,
      y
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return linearRings(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoint_ = getInteriorPointOfArray(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        flatCenter,
        0
      );
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Point_default(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new LinearRing_default(
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings2 = [];
    let offset2 = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const linearRing2 = new LinearRing_default(
        flatCoordinates.slice(offset2, end),
        layout
      );
      linearRings2.push(linearRing2);
      offset2 = end;
    }
    return linearRings2;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRings(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = quantizeArray(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return intersectsLinearRingArray(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      extent
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = deflateCoordinatesArray(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
function fromExtent(extent) {
  if (isEmpty2(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}

// node_modules/@allmaps/openlayers/node_modules/ol/View.js
var DEFAULT_MIN_ZOOM = 0;
var View = class extends Object_default {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = Object.assign({}, options);
    this.hints_ = [0, 0];
    this.animations_ = [];
    this.updateAnimationKey_;
    this.projection_ = createProjection(options.projection, "EPSG:3857");
    this.viewportSize_ = [100, 100];
    this.targetCenter_ = null;
    this.targetResolution_;
    this.targetRotation_;
    this.nextCenter_ = null;
    this.nextResolution_;
    this.nextRotation_;
    this.cancelAnchor_ = void 0;
    if (options.projection) {
      disableCoordinateWarning();
    }
    if (options.center) {
      options.center = fromUserCoordinate(options.center, this.projection_);
    }
    if (options.extent) {
      options.extent = fromUserExtent(options.extent, this.projection_);
    }
    this.applyOptions_(options);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(options) {
    const properties = Object.assign({}, options);
    for (const key in ViewProperty_default) {
      delete properties[key];
    }
    this.setProperties(properties, true);
    const resolutionConstraintInfo = createResolutionConstraint(options);
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    this.minResolution_ = resolutionConstraintInfo.minResolution;
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    this.resolutions_ = options.resolutions;
    this.padding_ = options.padding;
    this.minZoom_ = resolutionConstraintInfo.minZoom;
    const centerConstraint = createCenterConstraint(options);
    const resolutionConstraint = resolutionConstraintInfo.constraint;
    const rotationConstraint = createRotationConstraint(options);
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
    this.setCenterInternal(
      options.center !== void 0 ? options.center : null
    );
    if (options.resolution !== void 0) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== void 0) {
      this.setZoom(options.zoom);
    }
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(padding) {
    let oldPadding = this.padding_;
    this.padding_ = padding;
    const center = this.getCenterInternal();
    if (center) {
      const newPadding = padding || [0, 0, 0, 0];
      oldPadding = oldPadding || [0, 0, 0, 0];
      const resolution = this.getResolution();
      const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
      const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(newOptions) {
    const options = this.getProperties();
    if (options.resolution !== void 0) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }
    options.center = this.getCenterInternal();
    options.rotation = this.getRotation();
    return Object.assign({}, options, newOptions);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    const args = new Array(arguments.length);
    for (let i = 0; i < args.length; ++i) {
      let options = arguments[i];
      if (options.center) {
        options = Object.assign({}, options);
        options.center = fromUserCoordinate(
          options.center,
          this.getProjection()
        );
      }
      if (options.anchor) {
        options = Object.assign({}, options);
        options.anchor = fromUserCoordinate(
          options.anchor,
          this.getProjection()
        );
      }
      args[i] = options;
    }
    this.animateInternal.apply(this, args);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(var_args) {
    let animationCount = arguments.length;
    let callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    let i = 0;
    for (; i < animationCount && !this.isDef(); ++i) {
      const state = arguments[i];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== void 0) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== void 0) {
        this.setRotation(state.rotation);
      }
    }
    if (i === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    let start2 = Date.now();
    let center = this.targetCenter_.slice();
    let resolution = this.targetResolution_;
    let rotation = this.targetRotation_;
    const series = [];
    for (; i < animationCount; ++i) {
      const options = (
        /** @type {AnimationOptions} */
        arguments[i]
      );
      const animation = {
        start: start2,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== void 0 ? options.duration : 1e3,
        easing: options.easing || inAndOut,
        callback
      };
      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }
      if (options.zoom !== void 0) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }
      if (options.rotation !== void 0) {
        animation.sourceRotation = rotation;
        const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }
      if (isNoopAnimation(animation)) {
        animation.complete = true;
      } else {
        start2 += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(ViewHint_default.ANIMATING, 1);
    this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[ViewHint_default.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[ViewHint_default.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
    let anchor;
    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
      const series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (let j = 0, jj = series.length; j < jj; ++j) {
          const animation = series[j];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = void 0;
    }
    if (!this.getAnimating()) {
      return;
    }
    const now2 = Date.now();
    let more = false;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const series = this.animations_[i];
      let seriesComplete = true;
      for (let j = 0, jj = series.length; j < jj; ++j) {
        const animation = series[j];
        if (animation.complete) {
          continue;
        }
        const elapsed = now2 - animation.start;
        let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        const progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          const x0 = animation.sourceCenter[0];
          const y0 = animation.sourceCenter[1];
          const x1 = animation.targetCenter[0];
          const y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          const x = x0 + progress * (x1 - x0);
          const y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            const size2 = this.getViewportSize_(this.getRotation());
            const constrainedResolution = this.constraints_.resolution(
              resolution,
              0,
              size2,
              true
            );
            this.targetCenter_ = this.calculateCenterZoom(
              constrainedResolution,
              animation.anchor
            );
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
          const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            const constrainedRotation = this.constraints_.rotation(
              rotation,
              true
            );
            this.targetCenter_ = this.calculateCenterRotate(
              constrainedRotation,
              animation.anchor
            );
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(ViewHint_default.ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        const callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === void 0) {
      this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this)
      );
    }
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(rotation, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    if (currentCenter !== void 0) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      rotate(center, rotation - this.getRotation());
      add3(center, anchor);
    }
    return center;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(resolution, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    const currentResolution = this.getResolution();
    if (currentCenter !== void 0 && currentResolution !== void 0) {
      const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }
    return center;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(rotation) {
    const size2 = this.viewportSize_;
    if (rotation) {
      const w = size2[0];
      const h = size2[1];
      return [
        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
      ];
    }
    return size2;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(size2) {
    this.viewportSize_ = Array.isArray(size2) ? size2.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return toUserCoordinate(center, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(ViewProperty_default.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(hints) {
    if (hints !== void 0) {
      hints[0] = this.hints_[0];
      hints[1] = this.hints_[1];
      return hints;
    }
    return this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(size2) {
    const extent = this.calculateExtentInternal(size2);
    return toUserExtent(extent, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(size2) {
    size2 = size2 || this.getViewportSizeMinusPadding_();
    const center = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    assert(center, "The view center is not defined");
    const resolution = (
      /** @type {!number} */
      this.getResolution()
    );
    assert(resolution !== void 0, "The view resolution is not defined");
    const rotation = (
      /** @type {!number} */
      this.getRotation()
    );
    assert(rotation !== void 0, "The view rotation is not defined");
    return getForViewAndSize(center, resolution, rotation, size2);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(ViewProperty_default.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(extent, size2) {
    return this.getResolutionForExtentInternal(
      fromUserExtent(extent, this.getProjection()),
      size2
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(extent, size2) {
    size2 = size2 || this.getViewportSizeMinusPadding_();
    const xResolution = getWidth(extent) / size2[0];
    const yResolution = getHeight(extent) / size2[1];
    return Math.max(xResolution, yResolution);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(power) {
    power = power || 2;
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max3 = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      (function(value) {
        const resolution = maxResolution / Math.pow(power, value * max3);
        return resolution;
      })
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(ViewProperty_default.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(power) {
    const logPower = Math.log(power || 2);
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max3 = Math.log(maxResolution / minResolution) / logPower;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      (function(resolution) {
        const value = Math.log(maxResolution / resolution) / logPower / max3;
        return value;
      })
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(rotation) {
    let size2 = this.getViewportSize_(rotation);
    const padding = this.padding_;
    if (padding) {
      size2 = [
        size2[0] - padding[1] - padding[3],
        size2[1] - padding[0] - padding[2]
      ];
    }
    return size2;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const projection = this.getProjection();
    const resolution = this.getResolution();
    const rotation = this.getRotation();
    let center = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const padding = this.padding_;
    if (padding) {
      const reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(
        center,
        this.getViewportSize_(),
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
    }
    return {
      center: center.slice(0),
      projection: projection !== void 0 ? projection : null,
      resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let zoom;
    const resolution = this.getResolution();
    if (resolution !== void 0) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(resolution) {
    let offset2 = this.minZoom_ || 0;
    let max3, zoomFactor;
    if (this.resolutions_) {
      const nearest = linearFindNearest(this.resolutions_, resolution, 1);
      offset2 = nearest;
      max3 = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max3 / this.resolutions_[nearest + 1];
      }
    } else {
      max3 = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset2 + Math.log(max3 / resolution) / Math.log(zoomFactor);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(zoom) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1) {
        return 0;
      }
      const baseLevel = clamp(
        Math.floor(zoom),
        0,
        this.resolutions_.length - 2
      );
      const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(geometryOrExtent, options) {
    let geometry;
    assert(
      Array.isArray(geometryOrExtent) || typeof /** @type {?} */
      geometryOrExtent.getSimplifiedGeometry === "function",
      "Invalid extent or geometry provided as `geometry`"
    );
    if (Array.isArray(geometryOrExtent)) {
      assert(
        !isEmpty2(geometryOrExtent),
        "Cannot fit empty extent provided as `geometry`"
      );
      const extent = fromUserExtent(geometryOrExtent, this.getProjection());
      geometry = fromExtent(extent);
    } else if (geometryOrExtent.getType() === "Circle") {
      const extent = fromUserExtent(
        geometryOrExtent.getExtent(),
        this.getProjection()
      );
      geometry = fromExtent(extent);
      geometry.rotate(this.getRotation(), getCenter(extent));
    } else {
      const userProjection2 = getUserProjection();
      if (userProjection2) {
        geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
        geometryOrExtent.clone().transform(userProjection2, this.getProjection());
      } else {
        geometry = geometryOrExtent;
      }
    }
    this.fitInternal(geometry, options);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(geometry) {
    const rotation = this.getRotation();
    const cosAngle = Math.cos(rotation);
    const sinAngle = Math.sin(-rotation);
    const coords = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    let minRotX = Infinity;
    let minRotY = Infinity;
    let maxRotX = -Infinity;
    let maxRotY = -Infinity;
    for (let i = 0, ii = coords.length; i < ii; i += stride) {
      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(geometry, options) {
    options = options || {};
    let size2 = options.size;
    if (!size2) {
      size2 = this.getViewportSizeMinusPadding_();
    }
    const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
    const nearest = options.nearest !== void 0 ? options.nearest : false;
    let minResolution;
    if (options.minResolution !== void 0) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== void 0) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }
    const rotatedExtent = this.rotatedExtentForGeometry(geometry);
    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size2[0] - padding[1] - padding[3],
      size2[1] - padding[0] - padding[2]
    ]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
    const rotation = this.getRotation();
    const sinAngle = Math.sin(rotation);
    const cosAngle = Math.cos(rotation);
    const centerRot = getCenter(rotatedExtent);
    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    const center = this.getConstrainedCenter([centerX, centerY], resolution);
    const callback = options.callback ? options.callback : VOID;
    if (options.duration !== void 0) {
      this.animateInternal(
        {
          resolution,
          center,
          duration: options.duration,
          easing: options.easing
        },
        callback
      );
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(coordinate, size2, position) {
    this.centerOnInternal(
      fromUserCoordinate(coordinate, this.getProjection()),
      size2,
      position
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(coordinate, size2, position) {
    this.setCenterInternal(
      calculateCenterOn(
        coordinate,
        size2,
        position,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(center, resolution, rotation, size2) {
    let centerShift;
    const padding = this.padding_;
    if (padding && center) {
      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      const shiftedCenter = calculateCenterOn(
        center,
        size2,
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1]
      ];
    }
    return centerShift;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(deltaCoordinates) {
    const center = toUserCoordinate(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(deltaCoordinates) {
    const center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(ratio, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(ratio, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const size2 = this.getViewportSize_(this.getRotation());
    const newResolution = this.constraints_.resolution(
      this.targetResolution_ * ratio,
      0,
      size2,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
    }
    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(delta, anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(delta, anchor) {
    if (anchor) {
      anchor = fromUserCoordinate(anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, anchor);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(delta, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const newRotation = this.constraints_.rotation(
      this.targetRotation_ + delta,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(center) {
    this.setCenterInternal(
      center ? fromUserCoordinate(center, this.getProjection()) : center
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(doNotCancelAnims, forceMoving) {
    const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
    const newRotation = this.constraints_.rotation(
      this.targetRotation_,
      isMoving
    );
    const size2 = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      0,
      size2,
      isMoving
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size2,
      isMoving,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size2
      )
    );
    if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
      this.set(ViewProperty_default.ROTATION, newRotation);
    }
    if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
      this.set(ViewProperty_default.RESOLUTION, newResolution);
      this.set("zoom", this.getZoom(), true);
    }
    if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals2(this.get(ViewProperty_default.CENTER), newCenter)) {
      this.set(ViewProperty_default.CENTER, newCenter);
    }
    if (this.getAnimating() && !doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(duration, resolutionDirection, anchor) {
    duration = duration !== void 0 ? duration : 200;
    const direction = resolutionDirection || 0;
    const newRotation = this.constraints_.rotation(this.targetRotation_);
    const size2 = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      direction,
      size2
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size2,
      false,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size2
      )
    );
    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }
    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
    this.cancelAnchor_ = void 0;
    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals2(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }
      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration,
        easing: easeOut,
        anchor
      });
    }
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0);
    this.setHint(ViewHint_default.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(duration, resolutionDirection, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.endInteractionInternal(duration, resolutionDirection, anchor);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(duration, resolutionDirection, anchor) {
    if (!this.getInteracting()) {
      return;
    }
    this.setHint(ViewHint_default.INTERACTING, -1);
    this.resolveConstraints(duration, resolutionDirection, anchor);
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(targetCenter, targetResolution) {
    const size2 = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      targetCenter,
      targetResolution || this.getResolution(),
      size2
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(targetZoom, direction) {
    const targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(
      this.getConstrainedResolution(targetRes, direction)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(targetResolution, direction) {
    direction = direction || 0;
    const size2 = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction, size2);
  }
};
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size2 = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size2 / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals2(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size2, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size2[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size2[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var View_default = View;

// node_modules/@allmaps/openlayers/node_modules/ol/layer/Layer.js
var Layer = class extends Base_default {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    delete baseOptions.source;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.mapPrecomposeKey_ = null;
    this.mapRenderKey_ = null;
    this.sourceChangeKey_ = null;
    this.renderer_ = null;
    this.sourceReady_ = false;
    this.rendered = false;
    if (options.render) {
      this.render = options.render;
    }
    if (options.map) {
      this.setMap(options.map);
    }
    this.addChangeListener(
      Property_default.SOURCE,
      this.handleSourcePropertyChange_
    );
    const source = options.source ? (
      /** @type {SourceType} */
      options.source
    ) : null;
    this.setSource(source);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    array = array ? array : [];
    array.push(this);
    return array;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(states) {
    states = states ? states : [];
    states.push(this.getLayerState());
    return states;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(Property_default.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const source = this.getSource();
    return !source ? "undefined" : source.getState();
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed();
    if (this.sourceReady_ || this.getSource().getState() !== "ready") {
      return;
    }
    this.sourceReady_ = true;
    this.dispatchEvent("sourceready");
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    if (this.sourceChangeKey_) {
      unlistenByKey(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    this.sourceReady_ = false;
    const source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = listen(
        source,
        EventType_default.CHANGE,
        this.handleSourceChange_,
        this
      );
      if (source.getState() === "ready") {
        this.sourceReady_ = true;
        setTimeout(() => {
          this.dispatchEvent("sourceready");
        }, 0);
      }
    }
    this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    if (!this.renderer_) {
      return Promise.resolve([]);
    }
    return this.renderer_.getFeatures(pixel);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }
    return this.renderer_.getData(pixel);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(view) {
    let frameState;
    const map2 = this.getMapInternal();
    if (!view && map2) {
      view = map2.getView();
    }
    if (view instanceof View_default) {
      frameState = {
        viewState: view.getState(),
        extent: view.calculateExtent()
      };
    } else {
      frameState = view;
    }
    if (!frameState.layerStatesArray && map2) {
      frameState.layerStatesArray = map2.getLayerGroup().getLayerStatesArray();
    }
    let layerState;
    if (frameState.layerStatesArray) {
      layerState = frameState.layerStatesArray.find(
        (layerState2) => layerState2.layer === this
      );
    } else {
      layerState = this.getLayerState();
    }
    const layerExtent = this.getExtent();
    return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(view) {
    if (!this.isVisible(view)) {
      return [];
    }
    let getAttributions;
    const source = this.getSource();
    if (source) {
      getAttributions = source.getAttributions();
    }
    if (!getAttributions) {
      return [];
    }
    const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
    let attributions = getAttributions(frameState);
    if (!Array.isArray(attributions)) {
      attributions = [attributions];
    }
    return attributions;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(frameState, target) {
    const layerRenderer = this.getRenderer();
    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
    return null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = false;
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(map2) {
    if (!map2) {
      this.unrender();
    }
    this.set(Property_default.MAP, map2);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(Property_default.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map2) {
    if (this.mapPrecomposeKey_) {
      unlistenByKey(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map2) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      unlistenByKey(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map2) {
      this.mapPrecomposeKey_ = listen(
        map2,
        EventType_default2.PRECOMPOSE,
        function(evt) {
          const renderEvent = (
            /** @type {import("../render/Event.js").default} */
            evt
          );
          const layerStatesArray = renderEvent.frameState.layerStatesArray;
          const layerState = this.getLayerState(false);
          assert(
            !layerStatesArray.some(function(arrayLayerState) {
              return arrayLayerState.layer === layerState.layer;
            }),
            "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
          );
          layerStatesArray.push(layerState);
        },
        this
      );
      this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map2.render, map2);
      this.changed();
    }
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(source) {
    this.set(Property_default.SOURCE, source);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }
    this.setSource(null);
    super.disposeInternal();
  }
};
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer_default = Layer;

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result2;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_baseToNumber.js
var NAN = 0 / 0;
function baseToNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  return +value;
}
var baseToNumber_default = baseToNumber;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee2) {
  var index = -1, length = array == null ? 0 : array.length, result2 = Array(length);
  while (++index < length) {
    result2[index] = iteratee2(array[index], index, array);
  }
  return result2;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_createMathOperation.js
function createMathOperation(operator, defaultValue) {
  return function(value, other) {
    var result2;
    if (value === void 0 && other === void 0) {
      return defaultValue;
    }
    if (value !== void 0) {
      result2 = value;
    }
    if (other !== void 0) {
      if (result2 === void 0) {
        return other;
      }
      if (typeof value == "string" || typeof other == "string") {
        value = baseToString_default(value);
        other = baseToString_default(other);
      } else {
        value = baseToNumber_default(value);
        other = baseToNumber_default(other);
      }
      result2 = operator(value, other);
    }
    return result2;
  };
}
var createMathOperation_default = createMathOperation;

// node_modules/lodash-es/add.js
var add4 = createMathOperation_default(function(augend, addend) {
  return augend + addend;
}, 0);
var add_default = add4;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN2 = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN2;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN2 : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result2 = toFinite_default(value), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
var toInteger_default = toInteger;

// node_modules/lodash-es/after.js
var FUNC_ERROR_TEXT = "Expected a function";
function after(n, func) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger_default(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}
var after_default = after;

// node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
})();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// node_modules/lodash-es/_baseSetData.js
var baseSetData = !metaMap_default ? identity_default : function(func, data) {
  metaMap_default.set(func, data);
  return func;
};
var baseSetData_default = baseSetData;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ (function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
})();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_createCtor.js
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate_default(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject_default(result2) ? result2 : thisBinding;
  };
}
var createCtor_default = createCtor;

// node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
  function wrapper() {
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var createBind_default = createBind;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/_composeArgs.js
var nativeMax = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var composeArgs_default = composeArgs;

// node_modules/lodash-es/_composeArgsRight.js
var nativeMax2 = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset2 = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset2 + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
var composeArgsRight_default = composeArgsRight;

// node_modules/lodash-es/_countHolders.js
function countHolders(array, placeholder) {
  var length = array.length, result2 = 0;
  while (length--) {
    if (array[length] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
var countHolders_default = countHolders;

// node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// node_modules/lodash-es/noop.js
function noop() {
}
var noop_default = noop;

// node_modules/lodash-es/_getData.js
var getData = !metaMap_default ? noop_default : function(func) {
  return metaMap_default.get(func);
};
var getData_default = getData;

// node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// node_modules/lodash-es/_getFuncName.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function getFuncName(func) {
  var result2 = func.name + "", array = realNames_default[result2], length = hasOwnProperty3.call(realNames_default, result2) ? array.length : 0;
  while (length--) {
    var data = array[length], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result2;
}
var getFuncName_default = getFuncName;

// node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray_default(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var wrapperClone_default = wrapperClone;

// node_modules/lodash-es/wrapperLodash.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function lodash(value) {
  if (isObjectLike_default(value) && !isArray_default(value) && !(value instanceof LazyWrapper_default)) {
    if (value instanceof LodashWrapper_default) {
      return value;
    }
    if (hasOwnProperty4.call(value, "__wrapped__")) {
      return wrapperClone_default(value);
    }
  }
  return new LodashWrapper_default(value);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// node_modules/lodash-es/_isLaziable.js
function isLaziable(func) {
  var funcName = getFuncName_default(func), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData_default(other);
  return !!data && func === data[0];
}
var isLaziable_default = isLaziable;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/_setData.js
var setData = shortOut_default(baseSetData_default);
var setData_default = setData;

// node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
var reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match2 = source.match(reWrapDetails);
  return match2 ? match2[1].split(reSplitDetails) : [];
}
var getWrapDetails_default = getWrapDetails;

// node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var insertWrapDetails_default = insertWrapDetails;

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = (function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
})();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee2) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee2(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf_default(array, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_updateWrapDetails.js
var WRAP_BIND_FLAG2 = 1;
var WRAP_BIND_KEY_FLAG = 2;
var WRAP_CURRY_FLAG = 8;
var WRAP_CURRY_RIGHT_FLAG = 16;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
var WRAP_FLIP_FLAG = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG],
  ["bind", WRAP_BIND_FLAG2],
  ["bindKey", WRAP_BIND_KEY_FLAG],
  ["curry", WRAP_CURRY_FLAG],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
  ["flip", WRAP_FLIP_FLAG],
  ["partial", WRAP_PARTIAL_FLAG],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
  ["rearg", WRAP_REARG_FLAG]
];
function updateWrapDetails(details, bitmask) {
  arrayEach_default(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes_default(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var updateWrapDetails_default = updateWrapDetails;

// node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
}
var setWrapToString_default = setWrapToString;

// node_modules/lodash-es/_createRecurry.js
var WRAP_BIND_FLAG3 = 1;
var WRAP_BIND_KEY_FLAG2 = 2;
var WRAP_CURRY_BOUND_FLAG = 4;
var WRAP_CURRY_FLAG2 = 8;
var WRAP_PARTIAL_FLAG2 = 32;
var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary2,
    arity
  ];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable_default(func)) {
    setData_default(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString_default(result2, func, bitmask);
}
var createRecurry_default = createRecurry;

// node_modules/lodash-es/_getHolder.js
function getHolder(func) {
  var object = func;
  return object.placeholder;
}
var getHolder_default = getHolder;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_reorder.js
var nativeMin = Math.min;
function reorder(array, indexes) {
  var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray_default(array);
  while (length--) {
    var index = indexes[length];
    array[length] = isIndex_default(index, arrLength) ? oldArray[index] : void 0;
  }
  return array;
}
var reorder_default = reorder;

// node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER = "__lodash_placeholder__";
function replaceHolders(array, placeholder) {
  var index = -1, length = array.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result2[resIndex++] = index;
    }
  }
  return result2;
}
var replaceHolders_default = replaceHolders;

// node_modules/lodash-es/_createHybrid.js
var WRAP_BIND_FLAG4 = 1;
var WRAP_BIND_KEY_FLAG3 = 2;
var WRAP_CURRY_FLAG3 = 8;
var WRAP_CURRY_RIGHT_FLAG2 = 16;
var WRAP_ARY_FLAG2 = 128;
var WRAP_FLIP_FLAG2 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length;
    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
    }
    if (partials) {
      args = composeArgs_default(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders_default(args, placeholder);
      return createRecurry_default(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary2,
        arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length = args.length;
    if (argPos) {
      args = reorder_default(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length) {
      args.length = ary2;
    }
    if (this && this !== root_default && this instanceof wrapper) {
      fn = Ctor || createCtor_default(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var createHybrid_default = createHybrid;

// node_modules/lodash-es/_createCurry.js
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length, placeholder = getHolder_default(wrapper);
    while (index--) {
      args[index] = arguments[index];
    }
    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
    length -= holders.length;
    if (length < arity) {
      return createRecurry_default(
        func,
        bitmask,
        createHybrid_default,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length
      );
    }
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return apply_default(fn, this, args);
  }
  return wrapper;
}
var createCurry_default = createCurry;

// node_modules/lodash-es/_createPartial.js
var WRAP_BIND_FLAG5 = 1;
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply_default(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var createPartial_default = createPartial;

// node_modules/lodash-es/_mergeData.js
var PLACEHOLDER2 = "__lodash_placeholder__";
var WRAP_BIND_FLAG6 = 1;
var WRAP_BIND_KEY_FLAG4 = 2;
var WRAP_CURRY_BOUND_FLAG2 = 4;
var WRAP_CURRY_FLAG4 = 8;
var WRAP_ARY_FLAG3 = 128;
var WRAP_REARG_FLAG2 = 256;
var nativeMin2 = Math.min;
function mergeData(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
  var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG6) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
  }
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs_default(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders_default(data[3], PLACEHOLDER2) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight_default(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders_default(data[5], PLACEHOLDER2) : source[6];
  }
  value = source[7];
  if (value) {
    data[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG3) {
    data[8] = data[8] == null ? source[8] : nativeMin2(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var mergeData_default = mergeData;

// node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_BIND_FLAG7 = 1;
var WRAP_BIND_KEY_FLAG5 = 2;
var WRAP_CURRY_FLAG5 = 8;
var WRAP_CURRY_RIGHT_FLAG3 = 16;
var WRAP_PARTIAL_FLAG3 = 32;
var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
var nativeMax3 = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax3(toInteger_default(ary2), 0);
  arity = arity === void 0 ? arity : toInteger_default(arity);
  length -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData_default(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary2,
    arity
  ];
  if (data) {
    mergeData_default(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
    bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
    var result2 = createBind_default(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
    result2 = createCurry_default(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
    result2 = createPartial_default(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid_default.apply(void 0, newData);
  }
  var setter = data ? baseSetData_default : setData_default;
  return setWrapToString_default(setter(result2, newData), func, bitmask);
}
var createWrap_default = createWrap;

// node_modules/lodash-es/ary.js
var WRAP_ARY_FLAG4 = 128;
function ary(func, n, guard) {
  n = guard ? void 0 : n;
  n = func && n == null ? func.length : n;
  return createWrap_default(func, WRAP_ARY_FLAG4, void 0, void 0, void 0, void 0, n);
}
var ary_default = ary;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto6 = Object.prototype;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty5.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax4 = Math.max;
function overRest(func, start2, transform4) {
  start2 = nativeMax4(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax4(args.length - start2, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start2 + index];
    }
    index = -1;
    var otherArgs = Array(start2 + 1);
    while (++index < start2) {
      otherArgs[index] = args[index];
    }
    otherArgs[start2] = transform4(array);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start2) {
  return setToString_default(overRest_default(func, start2, identity_default), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto7 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto7;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee2) {
  var index = -1, result2 = Array(n);
  while (++index < n) {
    result2[index] = iteratee2(index);
  }
  return result2;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
var propertyIsEnumerable = objectProto8.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ (function() {
  return arguments;
})()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty6.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = (function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
})();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes_default(value.length, String) : [], length = result2.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result2.push(key);
    }
  }
  return result2;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform4) {
  return function(arg) {
    return func(transform4(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result2 = [];
  for (var key in Object(object)) {
    if (hasOwnProperty8.call(object, key) && key != "constructor") {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/assign.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
var assign = createAssigner_default(function(object, source) {
  if (isPrototype_default(source) || isArrayLike_default(source)) {
    copyObject_default(source, keys_default(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty9.call(source, key)) {
      assignValue_default(object, key, source[key]);
    }
  }
});
var assign_default = assign;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto12 = Object.prototype;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty10.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object, source) {
  copyObject_default(source, keysIn_default(source), object);
});
var assignIn_default = assignIn;

// node_modules/lodash-es/assignInWith.js
var assignInWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keysIn_default(source), object, customizer);
});
var assignInWith_default = assignInWith;

// node_modules/lodash-es/assignWith.js
var assignWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keys_default(source), object, customizer);
});
var assignWith_default = assignWith;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto13 = Object.prototype;
var hasOwnProperty11 = objectProto13.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result2 = data[key];
    return result2 === HASH_UNDEFINED ? void 0 : result2;
  }
  return hasOwnProperty11.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto14 = Object.prototype;
var hasOwnProperty12 = objectProto14.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty12.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result2 = getMapData_default(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result2 = func.apply(this, args);
    memoized.cache = cache2.set(key, result2) || cache2;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize_default(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result2.cache;
  return result2;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result2 = [];
  if (string.charCodeAt(0) === 46) {
    result2.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result2;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY3 ? "-0" : result2;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get4(object, path, defaultValue) {
  var result2 = object == null ? void 0 : baseGet_default(object, path);
  return result2 === void 0 ? defaultValue : result2;
}
var get_default = get4;

// node_modules/lodash-es/_baseAt.js
function baseAt(object, paths) {
  var index = -1, length = paths.length, result2 = Array(length), skip = object == null;
  while (++index < length) {
    result2[index] = skip ? void 0 : get_default(object, paths[index]);
  }
  return result2;
}
var baseAt_default = baseAt;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values2) {
  var index = -1, length = values2.length, offset2 = array.length;
  while (++index < length) {
    array[offset2 + index] = values2[index];
  }
  return array;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result2) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable_default);
  result2 || (result2 = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result2);
      } else {
        arrayPush_default(result2, value);
      }
    } else if (!isStrict) {
      result2[result2.length] = value;
    }
  }
  return result2;
}
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/flatten.js
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, 1) : [];
}
var flatten_default = flatten;

// node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
}
var flatRest_default = flatRest;

// node_modules/lodash-es/at.js
var at = flatRest_default(baseAt_default);
var at_default = at;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto15 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty13 = objectProto15.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty13.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value) {
  if (!isObjectLike_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject_default(value);
}
var isError_default = isError;

// node_modules/lodash-es/attempt.js
var attempt = baseRest_default(function(func, args) {
  try {
    return apply_default(func, void 0, args);
  } catch (e) {
    return isError_default(e) ? e : new Error(e);
  }
});
var attempt_default = attempt;

// node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function before(n, func) {
  var result2;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT4);
  }
  n = toInteger_default(n);
  return function() {
    if (--n > 0) {
      result2 = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = void 0;
    }
    return result2;
  };
}
var before_default = before;

// node_modules/lodash-es/bind.js
var WRAP_BIND_FLAG8 = 1;
var WRAP_PARTIAL_FLAG4 = 32;
var bind = baseRest_default(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG8;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bind));
    bitmask |= WRAP_PARTIAL_FLAG4;
  }
  return createWrap_default(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bind_default = bind;

// node_modules/lodash-es/bindAll.js
var bindAll = flatRest_default(function(object, methodNames) {
  arrayEach_default(methodNames, function(key) {
    key = toKey_default(key);
    baseAssignValue_default(object, key, bind_default(object[key], object));
  });
  return object;
});
var bindAll_default = bindAll;

// node_modules/lodash-es/bindKey.js
var WRAP_BIND_FLAG9 = 1;
var WRAP_BIND_KEY_FLAG6 = 2;
var WRAP_PARTIAL_FLAG5 = 32;
var bindKey = baseRest_default(function(object, key, partials) {
  var bitmask = WRAP_BIND_FLAG9 | WRAP_BIND_KEY_FLAG6;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG5;
  }
  return createWrap_default(key, bitmask, object, partials, holders);
});
bindKey.placeholder = {};
var bindKey_default = bindKey;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start2, end) {
  var index = -1, length = array.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result2 = Array(length);
  while (++index < length) {
    result2[index] = array[index + start2];
  }
  return result2;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_castSlice.js
function castSlice(array, start2, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start2 && end >= length ? array : baseSlice_default(array, start2, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string) {
  return string.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string) {
  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string) {
    string = toString_default(string);
    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst;

// node_modules/lodash-es/capitalize.js
function capitalize(string) {
  return upperFirst_default(toString_default(string).toLowerCase());
}
var capitalize_default = capitalize;

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array, iteratee2, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee2(accumulator, array[index], index, array);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "À": "A",
  "Á": "A",
  "Â": "A",
  "Ã": "A",
  "Ä": "A",
  "Å": "A",
  "à": "a",
  "á": "a",
  "â": "a",
  "ã": "a",
  "ä": "a",
  "å": "a",
  "Ç": "C",
  "ç": "c",
  "Ð": "D",
  "ð": "d",
  "È": "E",
  "É": "E",
  "Ê": "E",
  "Ë": "E",
  "è": "e",
  "é": "e",
  "ê": "e",
  "ë": "e",
  "Ì": "I",
  "Í": "I",
  "Î": "I",
  "Ï": "I",
  "ì": "i",
  "í": "i",
  "î": "i",
  "ï": "i",
  "Ñ": "N",
  "ñ": "n",
  "Ò": "O",
  "Ó": "O",
  "Ô": "O",
  "Õ": "O",
  "Ö": "O",
  "Ø": "O",
  "ò": "o",
  "ó": "o",
  "ô": "o",
  "õ": "o",
  "ö": "o",
  "ø": "o",
  "Ù": "U",
  "Ú": "U",
  "Û": "U",
  "Ü": "U",
  "ù": "u",
  "ú": "u",
  "û": "u",
  "ü": "u",
  "Ý": "Y",
  "ý": "y",
  "ÿ": "y",
  "Æ": "Ae",
  "æ": "ae",
  "Þ": "Th",
  "þ": "th",
  "ß": "ss",
  // Latin Extended-A block.
  "Ā": "A",
  "Ă": "A",
  "Ą": "A",
  "ā": "a",
  "ă": "a",
  "ą": "a",
  "Ć": "C",
  "Ĉ": "C",
  "Ċ": "C",
  "Č": "C",
  "ć": "c",
  "ĉ": "c",
  "ċ": "c",
  "č": "c",
  "Ď": "D",
  "Đ": "D",
  "ď": "d",
  "đ": "d",
  "Ē": "E",
  "Ĕ": "E",
  "Ė": "E",
  "Ę": "E",
  "Ě": "E",
  "ē": "e",
  "ĕ": "e",
  "ė": "e",
  "ę": "e",
  "ě": "e",
  "Ĝ": "G",
  "Ğ": "G",
  "Ġ": "G",
  "Ģ": "G",
  "ĝ": "g",
  "ğ": "g",
  "ġ": "g",
  "ģ": "g",
  "Ĥ": "H",
  "Ħ": "H",
  "ĥ": "h",
  "ħ": "h",
  "Ĩ": "I",
  "Ī": "I",
  "Ĭ": "I",
  "Į": "I",
  "İ": "I",
  "ĩ": "i",
  "ī": "i",
  "ĭ": "i",
  "į": "i",
  "ı": "i",
  "Ĵ": "J",
  "ĵ": "j",
  "Ķ": "K",
  "ķ": "k",
  "ĸ": "k",
  "Ĺ": "L",
  "Ļ": "L",
  "Ľ": "L",
  "Ŀ": "L",
  "Ł": "L",
  "ĺ": "l",
  "ļ": "l",
  "ľ": "l",
  "ŀ": "l",
  "ł": "l",
  "Ń": "N",
  "Ņ": "N",
  "Ň": "N",
  "Ŋ": "N",
  "ń": "n",
  "ņ": "n",
  "ň": "n",
  "ŋ": "n",
  "Ō": "O",
  "Ŏ": "O",
  "Ő": "O",
  "ō": "o",
  "ŏ": "o",
  "ő": "o",
  "Ŕ": "R",
  "Ŗ": "R",
  "Ř": "R",
  "ŕ": "r",
  "ŗ": "r",
  "ř": "r",
  "Ś": "S",
  "Ŝ": "S",
  "Ş": "S",
  "Š": "S",
  "ś": "s",
  "ŝ": "s",
  "ş": "s",
  "š": "s",
  "Ţ": "T",
  "Ť": "T",
  "Ŧ": "T",
  "ţ": "t",
  "ť": "t",
  "ŧ": "t",
  "Ũ": "U",
  "Ū": "U",
  "Ŭ": "U",
  "Ů": "U",
  "Ű": "U",
  "Ų": "U",
  "ũ": "u",
  "ū": "u",
  "ŭ": "u",
  "ů": "u",
  "ű": "u",
  "ų": "u",
  "Ŵ": "W",
  "ŵ": "w",
  "Ŷ": "Y",
  "ŷ": "y",
  "Ÿ": "Y",
  "Ź": "Z",
  "Ż": "Z",
  "Ž": "Z",
  "ź": "z",
  "ż": "z",
  "ž": "z",
  "Ĳ": "IJ",
  "ĳ": "ij",
  "Œ": "Oe",
  "œ": "oe",
  "ŉ": "'n",
  "ſ": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string) {
  string = toString_default(string);
  return string && string.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var hasUnicodeWord_default = hasUnicodeWord;

// node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "['’]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// node_modules/lodash-es/words.js
function words(string, pattern, guard) {
  string = toString_default(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string) ? unicodeWords_default(string) : asciiWords_default(string);
  }
  return string.match(pattern) || [];
}
var words_default = words;

// node_modules/lodash-es/_createCompounder.js
var rsApos2 = "['’]";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce_default(words_default(deburr_default(string).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// node_modules/lodash-es/camelCase.js
var camelCase = createCompounder_default(function(result2, word, index) {
  word = word.toLowerCase();
  return result2 + (index ? capitalize_default(word) : word);
});
var camelCase_default = camelCase;

// node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_default(value) ? value : [value];
}
var castArray_default = castArray;

// node_modules/lodash-es/_createRound.js
var nativeIsFinite = root_default.isFinite;
var nativeMin3 = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber_default(number);
    precision = precision == null ? 0 : nativeMin3(toInteger_default(precision), 292);
    if (precision && nativeIsFinite(number)) {
      var pair = (toString_default(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString_default(value) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number);
  };
}
var createRound_default = createRound;

// node_modules/lodash-es/ceil.js
var ceil = createRound_default("ceil");
var ceil_default = ceil;

// node_modules/lodash-es/chain.js
function chain(value) {
  var result2 = wrapperLodash_default(value);
  result2.__chain__ = true;
  return result2;
}
var chain_default = chain;

// node_modules/lodash-es/chunk.js
var nativeCeil = Math.ceil;
var nativeMax5 = Math.max;
function chunk(array, size2, guard) {
  if (guard ? isIterateeCall_default(array, size2, guard) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = nativeMax5(toInteger_default(size2), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size2 < 1) {
    return [];
  }
  var index = 0, resIndex = 0, result2 = Array(nativeCeil(length / size2));
  while (index < length) {
    result2[resIndex++] = baseSlice_default(array, index, index += size2);
  }
  return result2;
}
var chunk_default = chunk;

// node_modules/lodash-es/_baseClamp.js
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var baseClamp_default = baseClamp;

// node_modules/lodash-es/clamp.js
function clamp2(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_default(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber_default(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp_default(toNumber_default(number), lower, upper);
}
var clamp_default = clamp2;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result2 = data["delete"](key);
  this.size = data.size;
  return result2;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer2 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result2);
  return result2;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto16 = Object.prototype;
var propertyIsEnumerable2 = objectProto16.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result2 = [];
  while (object) {
    arrayPush_default(result2, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result2;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object);
  return isArray_default(object) ? result2 : arrayPush_default(result2, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result2 = baseGetTag_default(value), Ctor = result2 == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result2;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto17 = Object.prototype;
var hasOwnProperty14 = objectProto17.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result2 = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty14.call(array, "index")) {
    result2.index = array.index;
    result2.input = array.input;
  }
  return result2;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result2).set(new Uint8Array_default(arrayBuffer));
  return result2;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag3 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result2 = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result2 = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result2);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
      result2 = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result2, value)) : copySymbols_default(value, baseAssign_default(result2, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result2 = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result2);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result2;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var clone_default = clone;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// node_modules/lodash-es/cloneWith.js
var CLONE_SYMBOLS_FLAG5 = 4;
function cloneWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_SYMBOLS_FLAG5, customizer);
}
var cloneWith_default = cloneWith;

// node_modules/lodash-es/commit.js
function wrapperCommit() {
  return new LodashWrapper_default(this.value(), this.__chain__);
}
var commit_default = wrapperCommit;

// node_modules/lodash-es/compact.js
function compact(array) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array[index];
    if (value) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var compact_default = compact;

// node_modules/lodash-es/concat.js
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1), array = arguments[0], index = length;
  while (index--) {
    args[index - 1] = arguments[index];
  }
  return arrayPush_default(isArray_default(array) ? copyArray_default(array) : [array], baseFlatten_default(args, 1));
}
var concat_default = concat;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values2[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result2 = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result2;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map2) {
  var index = -1, result2 = Array(map2.size);
  map2.forEach(function(value, key) {
    result2[++index] = [key, value];
  });
  return result2;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set2) {
  var index = -1, result2 = Array(set2.size);
  set2.forEach(function(value) {
    result2[++index] = value;
  });
  return result2;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag4 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag4:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result2 = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result2;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto18 = Object.prototype;
var hasOwnProperty15 = objectProto18.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty15.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result2 = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result2;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto19 = Object.prototype;
var hasOwnProperty16 = objectProto19.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty16.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty16.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result2 = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result2 === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result2)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result2 = keys_default(object), length = result2.length;
  while (length--) {
    var key = result2[length], value = object[key];
    result2[length] = [key, value, isStrictComparable_default(value)];
  }
  return result2;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1, length = path.length, result2 = false;
  while (++index < length) {
    var key = toKey_default(path[index]);
    if (!(result2 = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result2 || ++index != length) {
    return result2;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/cond.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function cond(pairs) {
  var length = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee_default;
  pairs = !length ? [] : arrayMap_default(pairs, function(pair) {
    if (typeof pair[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT5);
    }
    return [toIteratee(pair[0]), pair[1]];
  });
  return baseRest_default(function(args) {
    var index = -1;
    while (++index < length) {
      var pair = pairs[index];
      if (apply_default(pair[0], this, args)) {
        return apply_default(pair[1], this, args);
      }
    }
  });
}
var cond_default = cond;

// node_modules/lodash-es/_baseConformsTo.js
function baseConformsTo(object, source, props) {
  var length = props.length;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (length--) {
    var key = props[length], predicate = source[key], value = object[key];
    if (value === void 0 && !(key in object) || !predicate(value)) {
      return false;
    }
  }
  return true;
}
var baseConformsTo_default = baseConformsTo;

// node_modules/lodash-es/_baseConforms.js
function baseConforms(source) {
  var props = keys_default(source);
  return function(object) {
    return baseConformsTo_default(object, source, props);
  };
}
var baseConforms_default = baseConforms;

// node_modules/lodash-es/conforms.js
var CLONE_DEEP_FLAG4 = 1;
function conforms(source) {
  return baseConforms_default(baseClone_default(source, CLONE_DEEP_FLAG4));
}
var conforms_default = conforms;

// node_modules/lodash-es/conformsTo.js
function conformsTo(object, source) {
  return source == null || baseConformsTo_default(object, source, keys_default(source));
}
var conformsTo_default = conformsTo;

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array, setter, iteratee2, accumulator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee2(value), array);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee2) {
  return object && baseFor_default(object, iteratee2, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee2(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee2, accumulator) {
  baseEach_default(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee2(value), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee2) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee2, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// node_modules/lodash-es/countBy.js
var objectProto20 = Object.prototype;
var hasOwnProperty17 = objectProto20.hasOwnProperty;
var countBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty17.call(result2, key)) {
    ++result2[key];
  } else {
    baseAssignValue_default(result2, key, 1);
  }
});
var countBy_default = countBy;

// node_modules/lodash-es/create.js
function create2(prototype, properties) {
  var result2 = baseCreate_default(prototype);
  return properties == null ? result2 : baseAssign_default(result2, properties);
}
var create_default = create2;

// node_modules/lodash-es/curry.js
var WRAP_CURRY_FLAG6 = 8;
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_FLAG6, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
curry.placeholder = {};
var curry_default = curry;

// node_modules/lodash-es/curryRight.js
var WRAP_CURRY_RIGHT_FLAG4 = 16;
function curryRight(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var curryRight_default = curryRight;

// node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT6 = "Expected a function";
var nativeMax6 = Math.max;
var nativeMin4 = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT6);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax6(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result2 = func.apply(thisArg, args);
    return result2;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result2;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin4(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result2 : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result2;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// node_modules/lodash-es/defaultTo.js
function defaultTo(value, defaultValue) {
  return value == null || value !== value ? defaultValue : value;
}
var defaultTo_default = defaultTo;

// node_modules/lodash-es/defaults.js
var objectProto21 = Object.prototype;
var hasOwnProperty18 = objectProto21.hasOwnProperty;
var defaults = baseRest_default(function(object, sources) {
  object = Object(object);
  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index < length) {
    var source = sources[index];
    var props = keysIn_default(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];
      if (value === void 0 || eq_default(value, objectProto21[key]) && !hasOwnProperty18.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_default = defaults;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_customDefaultsMerge.js
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject_default(objValue) && isObject_default(srcValue)) {
    stack.set(srcValue, objValue);
    baseMerge_default(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var customDefaultsMerge_default = customDefaultsMerge;

// node_modules/lodash-es/mergeWith.js
var mergeWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  baseMerge_default(object, source, srcIndex, customizer);
});
var mergeWith_default = mergeWith;

// node_modules/lodash-es/defaultsDeep.js
var defaultsDeep = baseRest_default(function(args) {
  args.push(void 0, customDefaultsMerge_default);
  return apply_default(mergeWith_default, void 0, args);
});
var defaultsDeep_default = defaultsDeep;

// node_modules/lodash-es/_baseDelay.js
var FUNC_ERROR_TEXT7 = "Expected a function";
function baseDelay(func, wait, args) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT7);
  }
  return setTimeout(function() {
    func.apply(void 0, args);
  }, wait);
}
var baseDelay_default = baseDelay;

// node_modules/lodash-es/defer.js
var defer = baseRest_default(function(func, args) {
  return baseDelay_default(func, 1, args);
});
var defer_default = defer;

// node_modules/lodash-es/delay.js
var delay = baseRest_default(function(func, wait, args) {
  return baseDelay_default(func, toNumber_default(wait) || 0, args);
});
var delay_default = delay;

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array, value, comparator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE2 = 200;
function baseDifference(array, values2, iteratee2, comparator) {
  var index = -1, includes2 = arrayIncludes_default, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
  if (!length) {
    return result2;
  }
  if (iteratee2) {
    values2 = arrayMap_default(values2, baseUnary_default(iteratee2));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values2 = new SetCache_default(values2);
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed) {
            continue outer;
          }
        }
        result2.push(value);
      } else if (!includes2(values2, computed, comparator)) {
        result2.push(value);
      }
    }
  return result2;
}
var baseDifference_default = baseDifference;

// node_modules/lodash-es/difference.js
var difference = baseRest_default(function(array, values2) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];
});
var difference_default = difference;

// node_modules/lodash-es/last.js
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_default = last;

// node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array, values2) {
  var iteratee2 = last_default(values2);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2)) : [];
});
var differenceBy_default = differenceBy;

// node_modules/lodash-es/differenceWith.js
var differenceWith = baseRest_default(function(array, values2) {
  var comparator = last_default(values2);
  if (isArrayLikeObject_default(comparator)) {
    comparator = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), void 0, comparator) : [];
});
var differenceWith_default = differenceWith;

// node_modules/lodash-es/divide.js
var divide = createMathOperation_default(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
var divide_default = divide;

// node_modules/lodash-es/drop.js
function drop(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array, n < 0 ? 0 : n, length);
}
var drop_default = drop;

// node_modules/lodash-es/dropRight.js
function dropRight(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length - n;
  return baseSlice_default(array, 0, n < 0 ? 0 : n);
}
var dropRight_default = dropRight;

// node_modules/lodash-es/_baseWhile.js
function baseWhile(array, predicate, isDrop, fromRight) {
  var length = array.length, index = fromRight ? length : -1;
  while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
  }
  return isDrop ? baseSlice_default(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice_default(array, fromRight ? index + 1 : 0, fromRight ? length : index);
}
var baseWhile_default = baseWhile;

// node_modules/lodash-es/dropRightWhile.js
function dropRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true, true) : [];
}
var dropRightWhile_default = dropRightWhile;

// node_modules/lodash-es/dropWhile.js
function dropWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true) : [];
}
var dropWhile_default = dropWhile;

// node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach2(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEach_default = forEach2;

// node_modules/lodash-es/_arrayEachRight.js
function arrayEachRight(array, iteratee2) {
  var length = array == null ? 0 : array.length;
  while (length--) {
    if (iteratee2(array[length], length, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEachRight_default = arrayEachRight;

// node_modules/lodash-es/_baseForRight.js
var baseForRight = createBaseFor_default(true);
var baseForRight_default = baseForRight;

// node_modules/lodash-es/_baseForOwnRight.js
function baseForOwnRight(object, iteratee2) {
  return object && baseForRight_default(object, iteratee2, keys_default);
}
var baseForOwnRight_default = baseForOwnRight;

// node_modules/lodash-es/_baseEachRight.js
var baseEachRight = createBaseEach_default(baseForOwnRight_default, true);
var baseEachRight_default = baseEachRight;

// node_modules/lodash-es/forEachRight.js
function forEachRight(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEachRight_default : baseEachRight_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEachRight_default = forEachRight;

// node_modules/lodash-es/endsWith.js
function endsWith(string, target, position) {
  string = toString_default(string);
  target = baseToString_default(target);
  var length = string.length;
  position = position === void 0 ? length : baseClamp_default(toInteger_default(position), 0, length);
  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}
var endsWith_default = endsWith;

// node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object, props) {
  return arrayMap_default(props, function(key) {
    return [key, object[key]];
  });
}
var baseToPairs_default = baseToPairs;

// node_modules/lodash-es/_setToPairs.js
function setToPairs(set2) {
  var index = -1, result2 = Array(set2.size);
  set2.forEach(function(value) {
    result2[++index] = [value, value];
  });
  return result2;
}
var setToPairs_default = setToPairs;

// node_modules/lodash-es/_createToPairs.js
var mapTag7 = "[object Map]";
var setTag7 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag_default(object);
    if (tag == mapTag7) {
      return mapToArray_default(object);
    }
    if (tag == setTag7) {
      return setToPairs_default(object);
    }
    return baseToPairs_default(object, keysFunc(object));
  };
}
var createToPairs_default = createToPairs;

// node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default);
var toPairs_default = toPairs;

// node_modules/lodash-es/toPairsIn.js
var toPairsIn = createToPairs_default(keysIn_default);
var toPairsIn_default = toPairsIn;

// node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string) {
  string = toString_default(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar_default) : string;
}
var escape_default = escape;

// node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string) {
  string = toString_default(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
}
var escapeRegExp_default = escapeRegExp;

// node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default = arrayEvery;

// node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result2 = true;
  baseEach_default(collection, function(value, index, collection2) {
    result2 = !!predicate(value, index, collection2);
    return result2;
  });
  return result2;
}
var baseEvery_default = baseEvery;

// node_modules/lodash-es/every.js
function every(collection, predicate, guard) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default = every;

// node_modules/lodash-es/toLength.js
var MAX_ARRAY_LENGTH2 = 4294967295;
function toLength(value) {
  return value ? baseClamp_default(toInteger_default(value), 0, MAX_ARRAY_LENGTH2) : 0;
}
var toLength_default = toLength;

// node_modules/lodash-es/_baseFill.js
function baseFill(array, value, start2, end) {
  var length = array.length;
  start2 = toInteger_default(start2);
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end = end === void 0 || end > length ? length : toInteger_default(end);
  if (end < 0) {
    end += length;
  }
  end = start2 > end ? 0 : toLength_default(end);
  while (start2 < end) {
    array[start2++] = value;
  }
  return array;
}
var baseFill_default = baseFill;

// node_modules/lodash-es/fill.js
function fill(array, value, start2, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  if (start2 && typeof start2 != "number" && isIterateeCall_default(array, value, start2)) {
    start2 = 0;
    end = length;
  }
  return baseFill_default(array, value, start2, end);
}
var fill_default = fill;

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result2 = [];
  baseEach_default(collection, function(value, index, collection2) {
    if (predicate(value, index, collection2)) {
      result2.push(value);
    }
  });
  return result2;
}
var baseFilter_default = baseFilter;

// node_modules/lodash-es/filter.js
function filter(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default = filter;

// node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee2 = baseIteratee_default(predicate, 3);
      collection = keys_default(collection);
      predicate = function(key) {
        return iteratee2(iterable[key], key, iterable);
      };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee2 ? collection[index] : index] : void 0;
  };
}
var createFind_default = createFind;

// node_modules/lodash-es/findIndex.js
var nativeMax7 = Math.max;
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax7(length + index, 0);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index);
}
var findIndex_default = findIndex;

// node_modules/lodash-es/find.js
var find = createFind_default(findIndex_default);
var find_default = find;

// node_modules/lodash-es/_baseFindKey.js
function baseFindKey(collection, predicate, eachFunc) {
  var result2;
  eachFunc(collection, function(value, key, collection2) {
    if (predicate(value, key, collection2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
}
var baseFindKey_default = baseFindKey;

// node_modules/lodash-es/findKey.js
function findKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwn_default);
}
var findKey_default = findKey;

// node_modules/lodash-es/findLastIndex.js
var nativeMax8 = Math.max;
var nativeMin5 = Math.min;
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = fromIndex < 0 ? nativeMax8(length + index, 0) : nativeMin5(index, length - 1);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index, true);
}
var findLastIndex_default = findLastIndex;

// node_modules/lodash-es/findLast.js
var findLast = createFind_default(findLastIndex_default);
var findLast_default = findLast;

// node_modules/lodash-es/findLastKey.js
function findLastKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwnRight_default);
}
var findLastKey_default = findLastKey;

// node_modules/lodash-es/head.js
function head(array) {
  return array && array.length ? array[0] : void 0;
}
var head_default = head;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee2) {
  var index = -1, result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result2[++index] = iteratee2(value, key, collection2);
  });
  return result2;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee2, 3));
}
var map_default = map;

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), 1);
}
var flatMap_default = flatMap;

// node_modules/lodash-es/flatMapDeep.js
var INFINITY4 = 1 / 0;
function flatMapDeep(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), INFINITY4);
}
var flatMapDeep_default = flatMapDeep;

// node_modules/lodash-es/flatMapDepth.js
function flatMapDepth(collection, iteratee2, depth) {
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(map_default(collection, iteratee2), depth);
}
var flatMapDepth_default = flatMapDepth;

// node_modules/lodash-es/flattenDeep.js
var INFINITY5 = 1 / 0;
function flattenDeep(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, INFINITY5) : [];
}
var flattenDeep_default = flattenDeep;

// node_modules/lodash-es/flattenDepth.js
function flattenDepth(array, depth) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(array, depth);
}
var flattenDepth_default = flattenDepth;

// node_modules/lodash-es/flip.js
var WRAP_FLIP_FLAG3 = 512;
function flip(func) {
  return createWrap_default(func, WRAP_FLIP_FLAG3);
}
var flip_default = flip;

// node_modules/lodash-es/floor.js
var floor = createRound_default("floor");
var floor_default = floor;

// node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT8 = "Expected a function";
var WRAP_CURRY_FLAG7 = 8;
var WRAP_PARTIAL_FLAG6 = 32;
var WRAP_ARY_FLAG5 = 128;
var WRAP_REARG_FLAG3 = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length = funcs.length, index = length, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func = funcs[index];
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT8);
      }
      if (prereq && !wrapper && getFuncName_default(func) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func = funcs[index];
      var funcName = getFuncName_default(func), data = funcName == "wrapper" ? getData_default(func) : void 0;
      if (data && isLaziable_default(data[0]) && data[1] == (WRAP_ARY_FLAG5 | WRAP_CURRY_FLAG7 | WRAP_PARTIAL_FLAG6 | WRAP_REARG_FLAG3) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName_default(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func.length == 1 && isLaziable_default(func) ? wrapper[funcName]() : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments, value = args[0];
      if (wrapper && args.length == 1 && isArray_default(value)) {
        return wrapper.plant(value).value();
      }
      var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
      while (++index2 < length) {
        result2 = funcs[index2].call(this, result2);
      }
      return result2;
    };
  });
}
var createFlow_default = createFlow;

// node_modules/lodash-es/flow.js
var flow = createFlow_default();
var flow_default = flow;

// node_modules/lodash-es/flowRight.js
var flowRight = createFlow_default(true);
var flowRight_default = flowRight;

// node_modules/lodash-es/forIn.js
function forIn(object, iteratee2) {
  return object == null ? object : baseFor_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forIn_default = forIn;

// node_modules/lodash-es/forInRight.js
function forInRight(object, iteratee2) {
  return object == null ? object : baseForRight_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forInRight_default = forInRight;

// node_modules/lodash-es/forOwn.js
function forOwn(object, iteratee2) {
  return object && baseForOwn_default(object, castFunction_default(iteratee2));
}
var forOwn_default = forOwn;

// node_modules/lodash-es/forOwnRight.js
function forOwnRight(object, iteratee2) {
  return object && baseForOwnRight_default(object, castFunction_default(iteratee2));
}
var forOwnRight_default = forOwnRight;

// node_modules/lodash-es/fromPairs.js
function fromPairs(pairs) {
  var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
  while (++index < length) {
    var pair = pairs[index];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
var fromPairs_default = fromPairs;

// node_modules/lodash-es/_baseFunctions.js
function baseFunctions(object, props) {
  return arrayFilter_default(props, function(key) {
    return isFunction_default(object[key]);
  });
}
var baseFunctions_default = baseFunctions;

// node_modules/lodash-es/functions.js
function functions(object) {
  return object == null ? [] : baseFunctions_default(object, keys_default(object));
}
var functions_default = functions;

// node_modules/lodash-es/functionsIn.js
function functionsIn(object) {
  return object == null ? [] : baseFunctions_default(object, keysIn_default(object));
}
var functionsIn_default = functionsIn;

// node_modules/lodash-es/groupBy.js
var objectProto22 = Object.prototype;
var hasOwnProperty19 = objectProto22.hasOwnProperty;
var groupBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty19.call(result2, key)) {
    result2[key].push(value);
  } else {
    baseAssignValue_default(result2, key, [value]);
  }
});
var groupBy_default = groupBy;

// node_modules/lodash-es/_baseGt.js
function baseGt(value, other) {
  return value > other;
}
var baseGt_default = baseGt;

// node_modules/lodash-es/_createRelationalOperation.js
function createRelationalOperation(operator) {
  return function(value, other) {
    if (!(typeof value == "string" && typeof other == "string")) {
      value = toNumber_default(value);
      other = toNumber_default(other);
    }
    return operator(value, other);
  };
}
var createRelationalOperation_default = createRelationalOperation;

// node_modules/lodash-es/gt.js
var gt = createRelationalOperation_default(baseGt_default);
var gt_default = gt;

// node_modules/lodash-es/gte.js
var gte = createRelationalOperation_default(function(value, other) {
  return value >= other;
});
var gte_default = gte;

// node_modules/lodash-es/_baseHas.js
var objectProto23 = Object.prototype;
var hasOwnProperty20 = objectProto23.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty20.call(object, key);
}
var baseHas_default = baseHas;

// node_modules/lodash-es/has.js
function has(object, path) {
  return object != null && hasPath_default(object, path, baseHas_default);
}
var has_default = has;

// node_modules/lodash-es/_baseInRange.js
var nativeMax9 = Math.max;
var nativeMin6 = Math.min;
function baseInRange(number, start2, end) {
  return number >= nativeMin6(start2, end) && number < nativeMax9(start2, end);
}
var baseInRange_default = baseInRange;

// node_modules/lodash-es/inRange.js
function inRange(number, start2, end) {
  start2 = toFinite_default(start2);
  if (end === void 0) {
    end = start2;
    start2 = 0;
  } else {
    end = toFinite_default(end);
  }
  number = toNumber_default(number);
  return baseInRange_default(number, start2, end);
}
var inRange_default = inRange;

// node_modules/lodash-es/isString.js
var stringTag5 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag5;
}
var isString_default = isString;

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default = values;

// node_modules/lodash-es/includes.js
var nativeMax10 = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax10(length + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/indexOf.js
var nativeMax11 = Math.max;
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax11(length + index, 0);
  }
  return baseIndexOf_default(array, value, index);
}
var indexOf_default = indexOf;

// node_modules/lodash-es/initial.js
function initial(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice_default(array, 0, -1) : [];
}
var initial_default = initial;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin7 = Math.min;
function baseIntersection(arrays, iteratee2, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee2) {
      array = arrayMap_default(array, baseUnary_default(iteratee2));
    }
    maxLength = nativeMin7(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache_default(othIndex && array) : void 0;
  }
  array = arrays[0];
  var index = -1, seen = caches[0];
  outer:
    while (++index < length && result2.length < maxLength) {
      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result2, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache2 = caches[othIndex];
          if (!(cache2 ? cacheHas_default(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result2.push(value);
      }
    }
  return result2;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value) {
  return isArrayLikeObject_default(value) ? value : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersection.js
var intersection = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection;

// node_modules/lodash-es/intersectionBy.js
var intersectionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  if (iteratee2 === last_default(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, baseIteratee_default(iteratee2, 2)) : [];
});
var intersectionBy_default = intersectionBy;

// node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// node_modules/lodash-es/_baseInverter.js
function baseInverter(object, setter, iteratee2, accumulator) {
  baseForOwn_default(object, function(value, key, object2) {
    setter(accumulator, iteratee2(value), key, object2);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object, iteratee2) {
    return baseInverter_default(object, setter, toIteratee(iteratee2), {});
  };
}
var createInverter_default = createInverter;

// node_modules/lodash-es/invert.js
var objectProto24 = Object.prototype;
var nativeObjectToString3 = objectProto24.toString;
var invert = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString3.call(value);
  }
  result2[value] = key;
}, constant_default(identity_default));
var invert_default = invert;

// node_modules/lodash-es/invertBy.js
var objectProto25 = Object.prototype;
var hasOwnProperty21 = objectProto25.hasOwnProperty;
var nativeObjectToString4 = objectProto25.toString;
var invertBy = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString4.call(value);
  }
  if (hasOwnProperty21.call(result2, value)) {
    result2[value].push(key);
  } else {
    result2[value] = [key];
  }
}, baseIteratee_default);
var invertBy_default = invertBy;

// node_modules/lodash-es/_parent.js
function parent(object, path) {
  return path.length < 2 ? object : baseGet_default(object, baseSlice_default(path, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/_baseInvoke.js
function baseInvoke(object, path, args) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  var func = object == null ? object : object[toKey_default(last_default(path))];
  return func == null ? void 0 : apply_default(func, object, args);
}
var baseInvoke_default = baseInvoke;

// node_modules/lodash-es/invoke.js
var invoke = baseRest_default(baseInvoke_default);
var invoke_default = invoke;

// node_modules/lodash-es/invokeMap.js
var invokeMap = baseRest_default(function(collection, path, args) {
  var index = -1, isFunc = typeof path == "function", result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value) {
    result2[++index] = isFunc ? apply_default(path, value, args) : baseInvoke_default(value, path, args);
  });
  return result2;
});
var invokeMap_default = invokeMap;

// node_modules/lodash-es/_baseIsArrayBuffer.js
var arrayBufferTag5 = "[object ArrayBuffer]";
function baseIsArrayBuffer(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == arrayBufferTag5;
}
var baseIsArrayBuffer_default = baseIsArrayBuffer;

// node_modules/lodash-es/isArrayBuffer.js
var nodeIsArrayBuffer = nodeUtil_default && nodeUtil_default.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary_default(nodeIsArrayBuffer) : baseIsArrayBuffer_default;
var isArrayBuffer_default = isArrayBuffer;

// node_modules/lodash-es/isBoolean.js
var boolTag5 = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike_default(value) && baseGetTag_default(value) == boolTag5;
}
var isBoolean_default = isBoolean;

// node_modules/lodash-es/_baseIsDate.js
var dateTag5 = "[object Date]";
function baseIsDate(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == dateTag5;
}
var baseIsDate_default = baseIsDate;

// node_modules/lodash-es/isDate.js
var nodeIsDate = nodeUtil_default && nodeUtil_default.isDate;
var isDate = nodeIsDate ? baseUnary_default(nodeIsDate) : baseIsDate_default;
var isDate_default = isDate;

// node_modules/lodash-es/isElement.js
function isElement(value) {
  return isObjectLike_default(value) && value.nodeType === 1 && !isPlainObject_default(value);
}
var isElement_default = isElement;

// node_modules/lodash-es/isEmpty.js
var mapTag8 = "[object Map]";
var setTag8 = "[object Set]";
var objectProto26 = Object.prototype;
var hasOwnProperty22 = objectProto26.hasOwnProperty;
function isEmpty3(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag8 || tag == setTag8) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty22.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty3;

// node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default = isEqual;

// node_modules/lodash-es/isEqualWith.js
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value, other) : void 0;
  return result2 === void 0 ? baseIsEqual_default(value, other, void 0, customizer) : !!result2;
}
var isEqualWith_default = isEqualWith;

// node_modules/lodash-es/isFinite.js
var nativeIsFinite2 = root_default.isFinite;
function isFinite2(value) {
  return typeof value == "number" && nativeIsFinite2(value);
}
var isFinite_default = isFinite2;

// node_modules/lodash-es/isInteger.js
function isInteger(value) {
  return typeof value == "number" && value == toInteger_default(value);
}
var isInteger_default = isInteger;

// node_modules/lodash-es/isMatch.js
function isMatch(object, source) {
  return object === source || baseIsMatch_default(object, source, getMatchData_default(source));
}
var isMatch_default = isMatch;

// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch_default(object, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;

// node_modules/lodash-es/isNumber.js
var numberTag5 = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike_default(value) && baseGetTag_default(value) == numberTag5;
}
var isNumber_default = isNumber;

// node_modules/lodash-es/isNaN.js
function isNaN2(value) {
  return isNumber_default(value) && value != +value;
}
var isNaN_default = isNaN2;

// node_modules/lodash-es/_isMaskable.js
var isMaskable = coreJsData_default ? isFunction_default : stubFalse_default;
var isMaskable_default = isMaskable;

// node_modules/lodash-es/isNative.js
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value) {
  if (isMaskable_default(value)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative_default(value);
}
var isNative_default = isNative;

// node_modules/lodash-es/isNil.js
function isNil(value) {
  return value == null;
}
var isNil_default = isNil;

// node_modules/lodash-es/isNull.js
function isNull(value) {
  return value === null;
}
var isNull_default = isNull;

// node_modules/lodash-es/_baseIsRegExp.js
var regexpTag5 = "[object RegExp]";
function baseIsRegExp(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == regexpTag5;
}
var baseIsRegExp_default = baseIsRegExp;

// node_modules/lodash-es/isRegExp.js
var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
var isRegExp_default = isRegExp;

// node_modules/lodash-es/isSafeInteger.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
function isSafeInteger(value) {
  return isInteger_default(value) && value >= -MAX_SAFE_INTEGER3 && value <= MAX_SAFE_INTEGER3;
}
var isSafeInteger_default = isSafeInteger;

// node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined;

// node_modules/lodash-es/isWeakMap.js
var weakMapTag4 = "[object WeakMap]";
function isWeakMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == weakMapTag4;
}
var isWeakMap_default = isWeakMap;

// node_modules/lodash-es/isWeakSet.js
var weakSetTag = "[object WeakSet]";
function isWeakSet(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == weakSetTag;
}
var isWeakSet_default = isWeakSet;

// node_modules/lodash-es/iteratee.js
var CLONE_DEEP_FLAG5 = 1;
function iteratee(func) {
  return baseIteratee_default(typeof func == "function" ? func : baseClone_default(func, CLONE_DEEP_FLAG5));
}
var iteratee_default = iteratee;

// node_modules/lodash-es/join.js
var arrayProto2 = Array.prototype;
var nativeJoin = arrayProto2.join;
function join(array, separator) {
  return array == null ? "" : nativeJoin.call(array, separator);
}
var join_default = join;

// node_modules/lodash-es/kebabCase.js
var kebabCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_default = kebabCase;

// node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result2, value, key) {
  baseAssignValue_default(result2, key, value);
});
var keyBy_default = keyBy;

// node_modules/lodash-es/_strictLastIndexOf.js
function strictLastIndexOf(array, value, fromIndex) {
  var index = fromIndex + 1;
  while (index--) {
    if (array[index] === value) {
      return index;
    }
  }
  return index;
}
var strictLastIndexOf_default = strictLastIndexOf;

// node_modules/lodash-es/lastIndexOf.js
var nativeMax12 = Math.max;
var nativeMin8 = Math.min;
function lastIndexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = index < 0 ? nativeMax12(length + index, 0) : nativeMin8(index, length - 1);
  }
  return value === value ? strictLastIndexOf_default(array, value, index) : baseFindIndex_default(array, baseIsNaN_default, index, true);
}
var lastIndexOf_default = lastIndexOf;

// node_modules/lodash-es/lowerCase.js
var lowerCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? " " : "") + word.toLowerCase();
});
var lowerCase_default = lowerCase;

// node_modules/lodash-es/lowerFirst.js
var lowerFirst = createCaseFirst_default("toLowerCase");
var lowerFirst_default = lowerFirst;

// node_modules/lodash-es/_baseLt.js
function baseLt(value, other) {
  return value < other;
}
var baseLt_default = baseLt;

// node_modules/lodash-es/lt.js
var lt = createRelationalOperation_default(baseLt_default);
var lt_default = lt;

// node_modules/lodash-es/lte.js
var lte = createRelationalOperation_default(function(value, other) {
  return value <= other;
});
var lte_default = lte;

// node_modules/lodash-es/mapKeys.js
function mapKeys(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, iteratee2(value, key, object2), value);
  });
  return result2;
}
var mapKeys_default = mapKeys;

// node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, key, iteratee2(value, key, object2));
  });
  return result2;
}
var mapValues_default = mapValues;

// node_modules/lodash-es/matches.js
var CLONE_DEEP_FLAG6 = 1;
function matches(source) {
  return baseMatches_default(baseClone_default(source, CLONE_DEEP_FLAG6));
}
var matches_default = matches;

// node_modules/lodash-es/matchesProperty.js
var CLONE_DEEP_FLAG7 = 1;
function matchesProperty(path, srcValue) {
  return baseMatchesProperty_default(path, baseClone_default(srcValue, CLONE_DEEP_FLAG7));
}
var matchesProperty_default = matchesProperty;

// node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array, iteratee2, comparator) {
  var index = -1, length = array.length;
  while (++index < length) {
    var value = array[index], current2 = iteratee2(value);
    if (current2 != null && (computed === void 0 ? current2 === current2 && !isSymbol_default(current2) : comparator(current2, computed))) {
      var computed = current2, result2 = value;
    }
  }
  return result2;
}
var baseExtremum_default = baseExtremum;

// node_modules/lodash-es/max.js
function max(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseGt_default) : void 0;
}
var max_default = max;

// node_modules/lodash-es/maxBy.js
function maxBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseGt_default) : void 0;
}
var maxBy_default = maxBy;

// node_modules/lodash-es/_baseSum.js
function baseSum(array, iteratee2) {
  var result2, index = -1, length = array.length;
  while (++index < length) {
    var current2 = iteratee2(array[index]);
    if (current2 !== void 0) {
      result2 = result2 === void 0 ? current2 : result2 + current2;
    }
  }
  return result2;
}
var baseSum_default = baseSum;

// node_modules/lodash-es/_baseMean.js
var NAN3 = 0 / 0;
function baseMean(array, iteratee2) {
  var length = array == null ? 0 : array.length;
  return length ? baseSum_default(array, iteratee2) / length : NAN3;
}
var baseMean_default = baseMean;

// node_modules/lodash-es/mean.js
function mean(array) {
  return baseMean_default(array, identity_default);
}
var mean_default = mean;

// node_modules/lodash-es/meanBy.js
function meanBy(array, iteratee2) {
  return baseMean_default(array, baseIteratee_default(iteratee2, 2));
}
var meanBy_default = meanBy;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// node_modules/lodash-es/method.js
var method = baseRest_default(function(path, args) {
  return function(object) {
    return baseInvoke_default(object, path, args);
  };
});
var method_default = method;

// node_modules/lodash-es/methodOf.js
var methodOf = baseRest_default(function(object, args) {
  return function(path) {
    return baseInvoke_default(object, path, args);
  };
});
var methodOf_default = methodOf;

// node_modules/lodash-es/min.js
function min(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseLt_default) : void 0;
}
var min_default = min;

// node_modules/lodash-es/minBy.js
function minBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// node_modules/lodash-es/mixin.js
function mixin(object, source, options) {
  var props = keys_default(source), methodNames = baseFunctions_default(source, props);
  var chain2 = !(isObject_default(options) && "chain" in options) || !!options.chain, isFunc = isFunction_default(object);
  arrayEach_default(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray_default(this.__actions__);
          actions.push({ "func": func, "args": arguments, "thisArg": object });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func.apply(object, arrayPush_default([this.value()], arguments));
      };
    }
  });
  return object;
}
var mixin_default = mixin;

// node_modules/lodash-es/multiply.js
var multiply = createMathOperation_default(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
var multiply_default = multiply;

// node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT9 = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT9);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_default = negate;

// node_modules/lodash-es/_iteratorToArray.js
function iteratorToArray(iterator) {
  var data, result2 = [];
  while (!(data = iterator.next()).done) {
    result2.push(data.value);
  }
  return result2;
}
var iteratorToArray_default = iteratorToArray;

// node_modules/lodash-es/toArray.js
var mapTag9 = "[object Map]";
var setTag9 = "[object Set]";
var symIterator = Symbol_default ? Symbol_default.iterator : void 0;
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike_default(value)) {
    return isString_default(value) ? stringToArray_default(value) : copyArray_default(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray_default(value[symIterator]());
  }
  var tag = getTag_default(value), func = tag == mapTag9 ? mapToArray_default : tag == setTag9 ? setToArray_default : values_default;
  return func(value);
}
var toArray_default = toArray;

// node_modules/lodash-es/next.js
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray_default(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
  return { "done": done, "value": value };
}
var next_default = wrapperNext;

// node_modules/lodash-es/_baseNth.js
function baseNth(array, n) {
  var length = array.length;
  if (!length) {
    return;
  }
  n += n < 0 ? length : 0;
  return isIndex_default(n, length) ? array[n] : void 0;
}
var baseNth_default = baseNth;

// node_modules/lodash-es/nth.js
function nth(array, n) {
  return array && array.length ? baseNth_default(array, toInteger_default(n)) : void 0;
}
var nth_default = nth;

// node_modules/lodash-es/nthArg.js
function nthArg(n) {
  n = toInteger_default(n);
  return baseRest_default(function(args) {
    return baseNth_default(args, n);
  });
}
var nthArg_default = nthArg;

// node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  return object == null || delete object[toKey_default(last_default(path))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_customOmitClone.js
function customOmitClone(value) {
  return isPlainObject_default(value) ? void 0 : value;
}
var customOmitClone_default = customOmitClone;

// node_modules/lodash-es/omit.js
var CLONE_DEEP_FLAG8 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG6 = 4;
var omit = flatRest_default(function(object, paths) {
  var result2 = {};
  if (object == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap_default(paths, function(path) {
    path = castPath_default(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject_default(object, getAllKeysIn_default(object), result2);
  if (isDeep) {
    result2 = baseClone_default(result2, CLONE_DEEP_FLAG8 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG6, customOmitClone_default);
  }
  var length = paths.length;
  while (length--) {
    baseUnset_default(result2, paths[length]);
  }
  return result2;
});
var omit_default = omit;

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index = -1, length = paths.length, result2 = {};
  while (++index < length) {
    var path = paths[index], value = baseGet_default(object, path);
    if (predicate(value, path)) {
      baseSet_default(result2, castPath_default(path, object), value);
    }
  }
  return result2;
}
var basePickBy_default = basePickBy;

// node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_default = pickBy;

// node_modules/lodash-es/omitBy.js
function omitBy(object, predicate) {
  return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

// node_modules/lodash-es/once.js
function once(func) {
  return before_default(2, func);
}
var once_default = once;

// node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareAscending.js
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index < length) {
    var result2 = compareAscending_default(objCriteria[index], othCriteria[index]);
    if (result2) {
      if (index >= ordersLength) {
        return result2;
      }
      var order = orders[index];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee2) {
      if (isArray_default(iteratee2)) {
        return function(value) {
          return baseGet_default(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity_default];
  }
  var index = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result2 = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee2) {
      return iteratee2(value);
    });
    return { "criteria": criteria, "index": ++index, "value": value };
  });
  return baseSortBy_default(result2, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/orderBy.js
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray_default(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? void 0 : orders;
  if (!isArray_default(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy_default(collection, iteratees, orders);
}
var orderBy_default = orderBy;

// node_modules/lodash-es/_createOver.js
function createOver(arrayFunc) {
  return flatRest_default(function(iteratees) {
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    return baseRest_default(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply_default(iteratee2, thisArg, args);
      });
    });
  });
}
var createOver_default = createOver;

// node_modules/lodash-es/over.js
var over = createOver_default(arrayMap_default);
var over_default = over;

// node_modules/lodash-es/_castRest.js
var castRest = baseRest_default;
var castRest_default = castRest;

// node_modules/lodash-es/overArgs.js
var nativeMin9 = Math.min;
var overArgs = castRest_default(function(func, transforms2) {
  transforms2 = transforms2.length == 1 && isArray_default(transforms2[0]) ? arrayMap_default(transforms2[0], baseUnary_default(baseIteratee_default)) : arrayMap_default(baseFlatten_default(transforms2, 1), baseUnary_default(baseIteratee_default));
  var funcsLength = transforms2.length;
  return baseRest_default(function(args) {
    var index = -1, length = nativeMin9(args.length, funcsLength);
    while (++index < length) {
      args[index] = transforms2[index].call(this, args[index]);
    }
    return apply_default(func, this, args);
  });
});
var overArgs_default = overArgs;

// node_modules/lodash-es/overEvery.js
var overEvery = createOver_default(arrayEvery_default);
var overEvery_default = overEvery;

// node_modules/lodash-es/overSome.js
var overSome = createOver_default(arraySome_default);
var overSome_default = overSome;

// node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER4 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string, n) {
  var result2 = "";
  if (!string || n < 1 || n > MAX_SAFE_INTEGER4) {
    return result2;
  }
  do {
    if (n % 2) {
      result2 += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);
  return result2;
}
var baseRepeat_default = baseRepeat;

// node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// node_modules/lodash-es/_unicodeSize.js
var rsAstralRange4 = "\\ud800-\\udfff";
var rsComboMarksRange5 = "\\u0300-\\u036f";
var reComboHalfMarksRange5 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange5 = "\\u20d0-\\u20ff";
var rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5;
var rsVarRange4 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange4 + "]";
var rsCombo4 = "[" + rsComboRange5 + "]";
var rsFitz3 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")";
var rsNonAstral3 = "[^" + rsAstralRange4 + "]";
var rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ4 = "\\u200d";
var reOptMod3 = rsModifier3 + "?";
var rsOptVar3 = "[" + rsVarRange4 + "]?";
var rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*";
var rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3;
var rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
function unicodeSize(string) {
  var result2 = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string)) {
    ++result2;
  }
  return result2;
}
var unicodeSize_default = unicodeSize;

// node_modules/lodash-es/_stringSize.js
function stringSize(string) {
  return hasUnicode_default(string) ? unicodeSize_default(string) : asciiSize_default(string);
}
var stringSize_default = stringSize;

// node_modules/lodash-es/_createPadding.js
var nativeCeil2 = Math.ceil;
function createPadding(length, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length) : chars;
  }
  var result2 = baseRepeat_default(chars, nativeCeil2(length / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result2), 0, length).join("") : result2.slice(0, length);
}
var createPadding_default = createPadding;

// node_modules/lodash-es/pad.js
var nativeCeil3 = Math.ceil;
var nativeFloor2 = Math.floor;
function pad(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  if (!length || strLength >= length) {
    return string;
  }
  var mid = (length - strLength) / 2;
  return createPadding_default(nativeFloor2(mid), chars) + string + createPadding_default(nativeCeil3(mid), chars);
}
var pad_default = pad;

// node_modules/lodash-es/padEnd.js
function padEnd(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  return length && strLength < length ? string + createPadding_default(length - strLength, chars) : string;
}
var padEnd_default = padEnd;

// node_modules/lodash-es/padStart.js
function padStart(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  return length && strLength < length ? createPadding_default(length - strLength, chars) + string : string;
}
var padStart_default = padStart;

// node_modules/lodash-es/parseInt.js
var reTrimStart2 = /^\s+/;
var nativeParseInt = root_default.parseInt;
function parseInt2(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString_default(string).replace(reTrimStart2, ""), radix || 0);
}
var parseInt_default = parseInt2;

// node_modules/lodash-es/partial.js
var WRAP_PARTIAL_FLAG7 = 32;
var partial = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partial));
  return createWrap_default(func, WRAP_PARTIAL_FLAG7, void 0, partials, holders);
});
partial.placeholder = {};
var partial_default = partial;

// node_modules/lodash-es/partialRight.js
var WRAP_PARTIAL_RIGHT_FLAG4 = 64;
var partialRight = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partialRight));
  return createWrap_default(func, WRAP_PARTIAL_RIGHT_FLAG4, void 0, partials, holders);
});
partialRight.placeholder = {};
var partialRight_default = partialRight;

// node_modules/lodash-es/partition.js
var partition = createAggregator_default(function(result2, value, key) {
  result2[key ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
var partition_default = partition;

// node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value, path) {
    return hasIn_default(object, path);
  });
}
var basePick_default = basePick;

// node_modules/lodash-es/pick.js
var pick = flatRest_default(function(object, paths) {
  return object == null ? {} : basePick_default(object, paths);
});
var pick_default = pick;

// node_modules/lodash-es/plant.js
function wrapperPlant(value) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash_default) {
    var clone2 = wrapperClone_default(parent2);
    clone2.__index__ = 0;
    clone2.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone2;
    } else {
      result2 = clone2;
    }
    var previous = clone2;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value;
  return result2;
}
var plant_default = wrapperPlant;

// node_modules/lodash-es/propertyOf.js
function propertyOf(object) {
  return function(path) {
    return object == null ? void 0 : baseGet_default(object, path);
  };
}
var propertyOf_default = propertyOf;

// node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// node_modules/lodash-es/_basePullAll.js
var arrayProto3 = Array.prototype;
var splice2 = arrayProto3.splice;
function basePullAll(array, values2, iteratee2, comparator) {
  var indexOf2 = comparator ? baseIndexOfWith_default : baseIndexOf_default, index = -1, length = values2.length, seen = array;
  if (array === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee2) {
    seen = arrayMap_default(array, baseUnary_default(iteratee2));
  }
  while (++index < length) {
    var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice2.call(seen, fromIndex, 1);
      }
      splice2.call(array, fromIndex, 1);
    }
  }
  return array;
}
var basePullAll_default = basePullAll;

// node_modules/lodash-es/pullAll.js
function pullAll(array, values2) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2) : array;
}
var pullAll_default = pullAll;

// node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default = pull;

// node_modules/lodash-es/pullAllBy.js
function pullAllBy(array, values2, iteratee2) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2, baseIteratee_default(iteratee2, 2)) : array;
}
var pullAllBy_default = pullAllBy;

// node_modules/lodash-es/pullAllWith.js
function pullAllWith(array, values2, comparator) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2, void 0, comparator) : array;
}
var pullAllWith_default = pullAllWith;

// node_modules/lodash-es/_basePullAt.js
var arrayProto4 = Array.prototype;
var splice3 = arrayProto4.splice;
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0, lastIndex = length - 1;
  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex_default(index)) {
        splice3.call(array, index, 1);
      } else {
        baseUnset_default(array, index);
      }
    }
  }
  return array;
}
var basePullAt_default = basePullAt;

// node_modules/lodash-es/pullAt.js
var pullAt = flatRest_default(function(array, indexes) {
  var length = array == null ? 0 : array.length, result2 = baseAt_default(array, indexes);
  basePullAt_default(array, arrayMap_default(indexes, function(index) {
    return isIndex_default(index, length) ? +index : index;
  }).sort(compareAscending_default));
  return result2;
});
var pullAt_default = pullAt;

// node_modules/lodash-es/_baseRandom.js
var nativeFloor3 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor3(nativeRandom() * (upper - lower + 1));
}
var baseRandom_default = baseRandom;

// node_modules/lodash-es/random.js
var freeParseFloat = parseFloat;
var nativeMin10 = Math.min;
var nativeRandom2 = Math.random;
function random(lower, upper, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall_default(lower, upper, floating)) {
    upper = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper == "boolean") {
      floating = upper;
      upper = void 0;
    } else if (typeof lower == "boolean") {
      floating = lower;
      lower = void 0;
    }
  }
  if (lower === void 0 && upper === void 0) {
    lower = 0;
    upper = 1;
  } else {
    lower = toFinite_default(lower);
    if (upper === void 0) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite_default(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom2();
    return nativeMin10(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
  }
  return baseRandom_default(lower, upper);
}
var random_default = random;

// node_modules/lodash-es/_baseRange.js
var nativeCeil4 = Math.ceil;
var nativeMax13 = Math.max;
function baseRange(start2, end, step, fromRight) {
  var index = -1, length = nativeMax13(nativeCeil4((end - start2) / (step || 1)), 0), result2 = Array(length);
  while (length--) {
    result2[fromRight ? length : ++index] = start2;
    start2 += step;
  }
  return result2;
}
var baseRange_default = baseRange;

// node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start2, end, step) {
    if (step && typeof step != "number" && isIterateeCall_default(start2, end, step)) {
      end = step = void 0;
    }
    start2 = toFinite_default(start2);
    if (end === void 0) {
      end = start2;
      start2 = 0;
    } else {
      end = toFinite_default(end);
    }
    step = step === void 0 ? start2 < end ? 1 : -1 : toFinite_default(step);
    return baseRange_default(start2, end, step, fromRight);
  };
}
var createRange_default = createRange;

// node_modules/lodash-es/range.js
var range = createRange_default();
var range_default = range;

// node_modules/lodash-es/rangeRight.js
var rangeRight = createRange_default(true);
var rangeRight_default = rangeRight;

// node_modules/lodash-es/rearg.js
var WRAP_REARG_FLAG4 = 256;
var rearg = flatRest_default(function(func, indexes) {
  return createWrap_default(func, WRAP_REARG_FLAG4, void 0, void 0, void 0, indexes);
});
var rearg_default = rearg;

// node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index, collection2);
  });
  return accumulator;
}
var baseReduce_default = baseReduce;

// node_modules/lodash-es/reduce.js
function reduce(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default = reduce;

// node_modules/lodash-es/_arrayReduceRight.js
function arrayReduceRight(array, iteratee2, accumulator, initAccum) {
  var length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[--length];
  }
  while (length--) {
    accumulator = iteratee2(accumulator, array[length], length, array);
  }
  return accumulator;
}
var arrayReduceRight_default = arrayReduceRight;

// node_modules/lodash-es/reduceRight.js
function reduceRight(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduceRight_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEachRight_default);
}
var reduceRight_default = reduceRight;

// node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default = reject;

// node_modules/lodash-es/remove.js
function remove(array, predicate) {
  var result2 = [];
  if (!(array && array.length)) {
    return result2;
  }
  var index = -1, indexes = [], length = array.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result2.push(value);
      indexes.push(index);
    }
  }
  basePullAt_default(array, indexes);
  return result2;
}
var remove_default = remove;

// node_modules/lodash-es/repeat.js
function repeat(string, n, guard) {
  if (guard ? isIterateeCall_default(string, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  return baseRepeat_default(toString_default(string), n);
}
var repeat_default = repeat;

// node_modules/lodash-es/replace.js
function replace() {
  var args = arguments, string = toString_default(args[0]);
  return args.length < 3 ? string : string.replace(args[1], args[2]);
}
var replace_default = replace;

// node_modules/lodash-es/rest.js
var FUNC_ERROR_TEXT10 = "Expected a function";
function rest(func, start2) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT10);
  }
  start2 = start2 === void 0 ? start2 : toInteger_default(start2);
  return baseRest_default(func, start2);
}
var rest_default = rest;

// node_modules/lodash-es/result.js
function result(object, path, defaultValue) {
  path = castPath_default(path, object);
  var index = -1, length = path.length;
  if (!length) {
    length = 1;
    object = void 0;
  }
  while (++index < length) {
    var value = object == null ? void 0 : object[toKey_default(path[index])];
    if (value === void 0) {
      index = length;
      value = defaultValue;
    }
    object = isFunction_default(value) ? value.call(object) : value;
  }
  return object;
}
var result_default = result;

// node_modules/lodash-es/reverse.js
var arrayProto5 = Array.prototype;
var nativeReverse = arrayProto5.reverse;
function reverse(array) {
  return array == null ? array : nativeReverse.call(array);
}
var reverse_default = reverse;

// node_modules/lodash-es/round.js
var round = createRound_default("round");
var round_default = round;

// node_modules/lodash-es/_arraySample.js
function arraySample(array) {
  var length = array.length;
  return length ? array[baseRandom_default(0, length - 1)] : void 0;
}
var arraySample_default = arraySample;

// node_modules/lodash-es/_baseSample.js
function baseSample(collection) {
  return arraySample_default(values_default(collection));
}
var baseSample_default = baseSample;

// node_modules/lodash-es/sample.js
function sample(collection) {
  var func = isArray_default(collection) ? arraySample_default : baseSample_default;
  return func(collection);
}
var sample_default = sample;

// node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array, size2) {
  var index = -1, length = array.length, lastIndex = length - 1;
  size2 = size2 === void 0 ? length : size2;
  while (++index < size2) {
    var rand = baseRandom_default(index, lastIndex), value = array[rand];
    array[rand] = array[index];
    array[index] = value;
  }
  array.length = size2;
  return array;
}
var shuffleSelf_default = shuffleSelf;

// node_modules/lodash-es/_arraySampleSize.js
function arraySampleSize(array, n) {
  return shuffleSelf_default(copyArray_default(array), baseClamp_default(n, 0, array.length));
}
var arraySampleSize_default = arraySampleSize;

// node_modules/lodash-es/_baseSampleSize.js
function baseSampleSize(collection, n) {
  var array = values_default(collection);
  return shuffleSelf_default(array, baseClamp_default(n, 0, array.length));
}
var baseSampleSize_default = baseSampleSize;

// node_modules/lodash-es/sampleSize.js
function sampleSize(collection, n, guard) {
  if (guard ? isIterateeCall_default(collection, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  var func = isArray_default(collection) ? arraySampleSize_default : baseSampleSize_default;
  return func(collection, n);
}
var sampleSize_default = sampleSize;

// node_modules/lodash-es/set.js
function set(object, path, value) {
  return object == null ? object : baseSet_default(object, path, value);
}
var set_default = set;

// node_modules/lodash-es/setWith.js
function setWith(object, path, value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseSet_default(object, path, value, customizer);
}
var setWith_default = setWith;

// node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array) {
  return shuffleSelf_default(copyArray_default(array));
}
var arrayShuffle_default = arrayShuffle;

// node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default(collection));
}
var baseShuffle_default = baseShuffle;

// node_modules/lodash-es/shuffle.js
function shuffle(collection) {
  var func = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func(collection);
}
var shuffle_default = shuffle;

// node_modules/lodash-es/size.js
var mapTag10 = "[object Map]";
var setTag10 = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_default(collection)) {
    return isString_default(collection) ? stringSize_default(collection) : collection.length;
  }
  var tag = getTag_default(collection);
  if (tag == mapTag10 || tag == setTag10) {
    return collection.size;
  }
  return baseKeys_default(collection).length;
}
var size_default = size;

// node_modules/lodash-es/slice.js
function slice(array, start2, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall_default(array, start2, end)) {
    start2 = 0;
    end = length;
  } else {
    start2 = start2 == null ? 0 : toInteger_default(start2);
    end = end === void 0 ? length : toInteger_default(end);
  }
  return baseSlice_default(array, start2, end);
}
var slice_default = slice;

// node_modules/lodash-es/snakeCase.js
var snakeCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? "_" : "") + word.toLowerCase();
});
var snakeCase_default = snakeCase;

// node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result2;
  baseEach_default(collection, function(value, index, collection2) {
    result2 = predicate(value, index, collection2);
    return !result2;
  });
  return !!result2;
}
var baseSome_default = baseSome;

// node_modules/lodash-es/some.js
function some(collection, predicate, guard) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default = some;

// node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// node_modules/lodash-es/_baseSortedIndexBy.js
var MAX_ARRAY_LENGTH3 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH3 - 1;
var nativeFloor4 = Math.floor;
var nativeMin11 = Math.min;
function baseSortedIndexBy(array, value, iteratee2, retHighest) {
  var low = 0, high = array == null ? 0 : array.length;
  if (high === 0) {
    return 0;
  }
  value = iteratee2(value);
  var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol_default(value), valIsUndefined = value === void 0;
  while (low < high) {
    var mid = nativeFloor4((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_default(computed);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value : computed < value;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin11(high, MAX_ARRAY_INDEX);
}
var baseSortedIndexBy_default = baseSortedIndexBy;

// node_modules/lodash-es/_baseSortedIndex.js
var MAX_ARRAY_LENGTH4 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH4 >>> 1;
function baseSortedIndex(array, value, retHighest) {
  var low = 0, high = array == null ? low : array.length;
  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1, computed = array[mid];
      if (computed !== null && !isSymbol_default(computed) && (retHighest ? computed <= value : computed < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy_default(array, value, identity_default, retHighest);
}
var baseSortedIndex_default = baseSortedIndex;

// node_modules/lodash-es/sortedIndex.js
function sortedIndex(array, value) {
  return baseSortedIndex_default(array, value);
}
var sortedIndex_default = sortedIndex;

// node_modules/lodash-es/sortedIndexBy.js
function sortedIndexBy(array, value, iteratee2) {
  return baseSortedIndexBy_default(array, value, baseIteratee_default(iteratee2, 2));
}
var sortedIndexBy_default = sortedIndexBy;

// node_modules/lodash-es/sortedIndexOf.js
function sortedIndexOf(array, value) {
  var length = array == null ? 0 : array.length;
  if (length) {
    var index = baseSortedIndex_default(array, value);
    if (index < length && eq_default(array[index], value)) {
      return index;
    }
  }
  return -1;
}
var sortedIndexOf_default = sortedIndexOf;

// node_modules/lodash-es/sortedLastIndex.js
function sortedLastIndex(array, value) {
  return baseSortedIndex_default(array, value, true);
}
var sortedLastIndex_default = sortedLastIndex;

// node_modules/lodash-es/sortedLastIndexBy.js
function sortedLastIndexBy(array, value, iteratee2) {
  return baseSortedIndexBy_default(array, value, baseIteratee_default(iteratee2, 2), true);
}
var sortedLastIndexBy_default = sortedLastIndexBy;

// node_modules/lodash-es/sortedLastIndexOf.js
function sortedLastIndexOf(array, value) {
  var length = array == null ? 0 : array.length;
  if (length) {
    var index = baseSortedIndex_default(array, value, true) - 1;
    if (eq_default(array[index], value)) {
      return index;
    }
  }
  return -1;
}
var sortedLastIndexOf_default = sortedLastIndexOf;

// node_modules/lodash-es/_baseSortedUniq.js
function baseSortedUniq(array, iteratee2) {
  var index = -1, length = array.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
    if (!index || !eq_default(computed, seen)) {
      var seen = computed;
      result2[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result2;
}
var baseSortedUniq_default = baseSortedUniq;

// node_modules/lodash-es/sortedUniq.js
function sortedUniq(array) {
  return array && array.length ? baseSortedUniq_default(array) : [];
}
var sortedUniq_default = sortedUniq;

// node_modules/lodash-es/sortedUniqBy.js
function sortedUniqBy(array, iteratee2) {
  return array && array.length ? baseSortedUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var sortedUniqBy_default = sortedUniqBy;

// node_modules/lodash-es/split.js
var MAX_ARRAY_LENGTH5 = 4294967295;
function split(string, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall_default(string, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString_default(string);
  if (string && (typeof separator == "string" || separator != null && !isRegExp_default(separator))) {
    separator = baseToString_default(separator);
    if (!separator && hasUnicode_default(string)) {
      return castSlice_default(stringToArray_default(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}
var split_default = split;

// node_modules/lodash-es/spread.js
var FUNC_ERROR_TEXT11 = "Expected a function";
var nativeMax14 = Math.max;
function spread(func, start2) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT11);
  }
  start2 = start2 == null ? 0 : nativeMax14(toInteger_default(start2), 0);
  return baseRest_default(function(args) {
    var array = args[start2], otherArgs = castSlice_default(args, 0, start2);
    if (array) {
      arrayPush_default(otherArgs, array);
    }
    return apply_default(func, this, otherArgs);
  });
}
var spread_default = spread;

// node_modules/lodash-es/startCase.js
var startCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? " " : "") + upperFirst_default(word);
});
var startCase_default = startCase;

// node_modules/lodash-es/startsWith.js
function startsWith(string, target, position) {
  string = toString_default(string);
  position = position == null ? 0 : baseClamp_default(toInteger_default(position), 0, string.length);
  target = baseToString_default(target);
  return string.slice(position, position + target.length) == target;
}
var startsWith_default = startsWith;

// node_modules/lodash-es/stubObject.js
function stubObject() {
  return {};
}
var stubObject_default = stubObject;

// node_modules/lodash-es/stubString.js
function stubString() {
  return "";
}
var stubString_default = stubString;

// node_modules/lodash-es/stubTrue.js
function stubTrue() {
  return true;
}
var stubTrue_default = stubTrue;

// node_modules/lodash-es/subtract.js
var subtract = createMathOperation_default(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
var subtract_default = subtract;

// node_modules/lodash-es/sum.js
function sum(array) {
  return array && array.length ? baseSum_default(array, identity_default) : 0;
}
var sum_default = sum;

// node_modules/lodash-es/sumBy.js
function sumBy(array, iteratee2) {
  return array && array.length ? baseSum_default(array, baseIteratee_default(iteratee2, 2)) : 0;
}
var sumBy_default = sumBy;

// node_modules/lodash-es/tail.js
function tail(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice_default(array, 1, length) : [];
}
var tail_default = tail;

// node_modules/lodash-es/take.js
function take(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array, 0, n < 0 ? 0 : n);
}
var take_default = take;

// node_modules/lodash-es/takeRight.js
function takeRight(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length - n;
  return baseSlice_default(array, n < 0 ? 0 : n, length);
}
var takeRight_default = takeRight;

// node_modules/lodash-es/takeRightWhile.js
function takeRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), false, true) : [];
}
var takeRightWhile_default = takeRightWhile;

// node_modules/lodash-es/takeWhile.js
function takeWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3)) : [];
}
var takeWhile_default = takeWhile;

// node_modules/lodash-es/tap.js
function tap(value, interceptor) {
  interceptor(value);
  return value;
}
var tap_default = tap;

// node_modules/lodash-es/_customDefaultsAssignIn.js
var objectProto27 = Object.prototype;
var hasOwnProperty23 = objectProto27.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq_default(objValue, objectProto27[key]) && !hasOwnProperty23.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var customDefaultsAssignIn_default = customDefaultsAssignIn;

// node_modules/lodash-es/_escapeStringChar.js
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var escapeStringChar_default = escapeStringChar;

// node_modules/lodash-es/_reInterpolate.js
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate_default = reInterpolate;

// node_modules/lodash-es/_reEscape.js
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape_default = reEscape;

// node_modules/lodash-es/_reEvaluate.js
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate_default = reEvaluate;

// node_modules/lodash-es/templateSettings.js
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape_default,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate_default,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate_default,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape_default }
  }
};
var templateSettings_default = templateSettings;

// node_modules/lodash-es/template.js
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto28 = Object.prototype;
var hasOwnProperty24 = objectProto28.hasOwnProperty;
function template(string, options, guard) {
  var settings = templateSettings_default.imports._.templateSettings || templateSettings_default;
  if (guard && isIterateeCall_default(string, options, guard)) {
    options = void 0;
  }
  string = toString_default(string);
  options = assignInWith_default({}, options, settings, customDefaultsAssignIn_default);
  var imports = assignInWith_default({}, options.imports, settings.imports, customDefaultsAssignIn_default), importsKeys = keys_default(imports), importsValues = baseValues_default(imports, importsKeys);
  var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate_default ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty24.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string.slice(index, offset2).replace(reUnescapedString, escapeStringChar_default);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset2 + match2.length;
    return match2;
  });
  source += "';\n";
  var variable = hasOwnProperty24.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt_default(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError_default(result2)) {
    throw result2;
  }
  return result2;
}
var template_default = template;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT12 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT12);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle;

// node_modules/lodash-es/thru.js
function thru(value, interceptor) {
  return interceptor(value);
}
var thru_default = thru;

// node_modules/lodash-es/times.js
var MAX_SAFE_INTEGER5 = 9007199254740991;
var MAX_ARRAY_LENGTH6 = 4294967295;
var nativeMin12 = Math.min;
function times(n, iteratee2) {
  n = toInteger_default(n);
  if (n < 1 || n > MAX_SAFE_INTEGER5) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH6, length = nativeMin12(n, MAX_ARRAY_LENGTH6);
  iteratee2 = castFunction_default(iteratee2);
  n -= MAX_ARRAY_LENGTH6;
  var result2 = baseTimes_default(length, iteratee2);
  while (++index < n) {
    iteratee2(index);
  }
  return result2;
}
var times_default = times;

// node_modules/lodash-es/toIterator.js
function wrapperToIterator() {
  return this;
}
var toIterator_default = wrapperToIterator;

// node_modules/lodash-es/_baseWrapperValue.js
function baseWrapperValue(value, actions) {
  var result2 = value;
  if (result2 instanceof LazyWrapper_default) {
    result2 = result2.value();
  }
  return arrayReduce_default(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush_default([result3], action.args));
  }, result2);
}
var baseWrapperValue_default = baseWrapperValue;

// node_modules/lodash-es/wrapperValue.js
function wrapperValue() {
  return baseWrapperValue_default(this.__wrapped__, this.__actions__);
}
var wrapperValue_default = wrapperValue;

// node_modules/lodash-es/toLower.js
function toLower(value) {
  return toString_default(value).toLowerCase();
}
var toLower_default = toLower;

// node_modules/lodash-es/toPath.js
function toPath(value) {
  if (isArray_default(value)) {
    return arrayMap_default(value, toKey_default);
  }
  return isSymbol_default(value) ? [value] : copyArray_default(stringToPath_default(toString_default(value)));
}
var toPath_default = toPath;

// node_modules/lodash-es/toSafeInteger.js
var MAX_SAFE_INTEGER6 = 9007199254740991;
function toSafeInteger(value) {
  return value ? baseClamp_default(toInteger_default(value), -MAX_SAFE_INTEGER6, MAX_SAFE_INTEGER6) : value === 0 ? value : 0;
}
var toSafeInteger_default = toSafeInteger;

// node_modules/lodash-es/toUpper.js
function toUpper(value) {
  return toString_default(value).toUpperCase();
}
var toUpper_default = toUpper;

// node_modules/lodash-es/transform.js
function transform2(object, iteratee2, accumulator) {
  var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
  iteratee2 = baseIteratee_default(iteratee2, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value, index, object2) {
    return iteratee2(accumulator, value, index, object2);
  });
  return accumulator;
}
var transform_default = transform2;

// node_modules/lodash-es/_charsEndIndex.js
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;
  while (index-- && baseIndexOf_default(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var charsEndIndex_default = charsEndIndex;

// node_modules/lodash-es/_charsStartIndex.js
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1, length = strSymbols.length;
  while (++index < length && baseIndexOf_default(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var charsStartIndex_default = charsStartIndex;

// node_modules/lodash-es/trim.js
function trim(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return baseTrim_default(string);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), chrSymbols = stringToArray_default(chars), start2 = charsStartIndex_default(strSymbols, chrSymbols), end = charsEndIndex_default(strSymbols, chrSymbols) + 1;
  return castSlice_default(strSymbols, start2, end).join("");
}
var trim_default = trim;

// node_modules/lodash-es/trimEnd.js
function trimEnd(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.slice(0, trimmedEndIndex_default(string) + 1);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), end = charsEndIndex_default(strSymbols, stringToArray_default(chars)) + 1;
  return castSlice_default(strSymbols, 0, end).join("");
}
var trimEnd_default = trimEnd;

// node_modules/lodash-es/trimStart.js
var reTrimStart3 = /^\s+/;
function trimStart(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.replace(reTrimStart3, "");
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), start2 = charsStartIndex_default(strSymbols, stringToArray_default(chars));
  return castSlice_default(strSymbols, start2).join("");
}
var trimStart_default = trimStart;

// node_modules/lodash-es/truncate.js
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = "...";
var reFlags2 = /\w*$/;
function truncate(string, options) {
  var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject_default(options)) {
    var separator = "separator" in options ? options.separator : separator;
    length = "length" in options ? toInteger_default(options.length) : length;
    omission = "omission" in options ? baseToString_default(options.omission) : omission;
  }
  string = toString_default(string);
  var strLength = string.length;
  if (hasUnicode_default(string)) {
    var strSymbols = stringToArray_default(string);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string;
  }
  var end = length - stringSize_default(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice_default(strSymbols, 0, end).join("") : string.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp_default(separator)) {
    if (string.slice(end).search(separator)) {
      var match2, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString_default(reFlags2.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match2 = separator.exec(substring)) {
        var newEnd = match2.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string.indexOf(baseToString_default(separator), end) != end) {
    var index = result2.lastIndexOf(separator);
    if (index > -1) {
      result2 = result2.slice(0, index);
    }
  }
  return result2 + omission;
}
var truncate_default = truncate;

// node_modules/lodash-es/unary.js
function unary(func) {
  return ary_default(func, 1);
}
var unary_default = unary;

// node_modules/lodash-es/_unescapeHtmlChar.js
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
var unescapeHtmlChar_default = unescapeHtmlChar;

// node_modules/lodash-es/unescape.js
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape(string) {
  string = toString_default(string);
  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar_default) : string;
}
var unescape_default = unescape;

// node_modules/lodash-es/_createSet.js
var INFINITY6 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY6) ? noop_default : function(values2) {
  return new Set_default(values2);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE3 = 200;
function baseUniq(array, iteratee2, comparator) {
  var index = -1, includes2 = arrayIncludes_default, length = array.length, isCommon = true, result2 = [], seen = result2;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE3) {
    var set2 = iteratee2 ? null : createSet_default(array);
    if (set2) {
      return setToArray_default(set2);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee2 ? [] : result2;
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee2) {
          seen.push(computed);
        }
        result2.push(value);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result2) {
          seen.push(computed);
        }
        result2.push(value);
      }
    }
  return result2;
}
var baseUniq_default = baseUniq;

// node_modules/lodash-es/union.js
var union = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default = union;

// node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2));
});
var unionBy_default = unionBy;

// node_modules/lodash-es/unionWith.js
var unionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), void 0, comparator);
});
var unionWith_default = unionWith;

// node_modules/lodash-es/uniq.js
function uniq(array) {
  return array && array.length ? baseUniq_default(array) : [];
}
var uniq_default = uniq;

// node_modules/lodash-es/uniqBy.js
function uniqBy(array, iteratee2) {
  return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var uniqBy_default = uniqBy;

// node_modules/lodash-es/uniqWith.js
function uniqWith(array, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array && array.length ? baseUniq_default(array, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// node_modules/lodash-es/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString_default(prefix) + id;
}
var uniqueId_default = uniqueId;

// node_modules/lodash-es/unset.js
function unset(object, path) {
  return object == null ? true : baseUnset_default(object, path);
}
var unset_default = unset;

// node_modules/lodash-es/unzip.js
var nativeMax15 = Math.max;
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = arrayFilter_default(array, function(group) {
    if (isArrayLikeObject_default(group)) {
      length = nativeMax15(group.length, length);
      return true;
    }
  });
  return baseTimes_default(length, function(index) {
    return arrayMap_default(array, baseProperty_default(index));
  });
}
var unzip_default = unzip;

// node_modules/lodash-es/unzipWith.js
function unzipWith(array, iteratee2) {
  if (!(array && array.length)) {
    return [];
  }
  var result2 = unzip_default(array);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap_default(result2, function(group) {
    return apply_default(iteratee2, void 0, group);
  });
}
var unzipWith_default = unzipWith;

// node_modules/lodash-es/_baseUpdate.js
function baseUpdate(object, path, updater, customizer) {
  return baseSet_default(object, path, updater(baseGet_default(object, path)), customizer);
}
var baseUpdate_default = baseUpdate;

// node_modules/lodash-es/update.js
function update(object, path, updater) {
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater));
}
var update_default = update;

// node_modules/lodash-es/updateWith.js
function updateWith(object, path, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater), customizer);
}
var updateWith_default = updateWith;

// node_modules/lodash-es/upperCase.js
var upperCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? " " : "") + word.toUpperCase();
});
var upperCase_default = upperCase;

// node_modules/lodash-es/valuesIn.js
function valuesIn(object) {
  return object == null ? [] : baseValues_default(object, keysIn_default(object));
}
var valuesIn_default = valuesIn;

// node_modules/lodash-es/without.js
var without = baseRest_default(function(array, values2) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, values2) : [];
});
var without_default = without;

// node_modules/lodash-es/wrap.js
function wrap(value, wrapper) {
  return partial_default(castFunction_default(wrapper), value);
}
var wrap_default = wrap;

// node_modules/lodash-es/wrapperAt.js
var wrapperAt = flatRest_default(function(paths) {
  var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
    return baseAt_default(object, paths);
  };
  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper_default) || !isIndex_default(start2)) {
    return this.thru(interceptor);
  }
  value = value.slice(start2, +start2 + (length ? 1 : 0));
  value.__actions__.push({
    "func": thru_default,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper_default(value, this.__chain__).thru(function(array) {
    if (length && !array.length) {
      array.push(void 0);
    }
    return array;
  });
});
var wrapperAt_default = wrapperAt;

// node_modules/lodash-es/wrapperChain.js
function wrapperChain() {
  return chain_default(this);
}
var wrapperChain_default = wrapperChain;

// node_modules/lodash-es/wrapperReverse.js
function wrapperReverse() {
  var value = this.__wrapped__;
  if (value instanceof LazyWrapper_default) {
    var wrapped = value;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper_default(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru_default,
      "args": [reverse_default],
      "thisArg": void 0
    });
    return new LodashWrapper_default(wrapped, this.__chain__);
  }
  return this.thru(reverse_default);
}
var wrapperReverse_default = wrapperReverse;

// node_modules/lodash-es/_baseXor.js
function baseXor(arrays, iteratee2, comparator) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq_default(arrays[0]) : [];
  }
  var index = -1, result2 = Array(length);
  while (++index < length) {
    var array = arrays[index], othIndex = -1;
    while (++othIndex < length) {
      if (othIndex != index) {
        result2[index] = baseDifference_default(result2[index] || array, arrays[othIndex], iteratee2, comparator);
      }
    }
  }
  return baseUniq_default(baseFlatten_default(result2, 1), iteratee2, comparator);
}
var baseXor_default = baseXor;

// node_modules/lodash-es/xor.js
var xor = baseRest_default(function(arrays) {
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default));
});
var xor_default = xor;

// node_modules/lodash-es/xorBy.js
var xorBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), baseIteratee_default(iteratee2, 2));
});
var xorBy_default = xorBy;

// node_modules/lodash-es/xorWith.js
var xorWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), void 0, comparator);
});
var xorWith_default = xorWith;

// node_modules/lodash-es/zip.js
var zip = baseRest_default(unzip_default);
var zip_default = zip;

// node_modules/lodash-es/_baseZipObject.js
function baseZipObject(props, values2, assignFunc) {
  var index = -1, length = props.length, valsLength = values2.length, result2 = {};
  while (++index < length) {
    var value = index < valsLength ? values2[index] : void 0;
    assignFunc(result2, props[index], value);
  }
  return result2;
}
var baseZipObject_default = baseZipObject;

// node_modules/lodash-es/zipObject.js
function zipObject(props, values2) {
  return baseZipObject_default(props || [], values2 || [], assignValue_default);
}
var zipObject_default = zipObject;

// node_modules/lodash-es/zipObjectDeep.js
function zipObjectDeep(props, values2) {
  return baseZipObject_default(props || [], values2 || [], baseSet_default);
}
var zipObjectDeep_default = zipObjectDeep;

// node_modules/lodash-es/zipWith.js
var zipWith = baseRest_default(function(arrays) {
  var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith_default(arrays, iteratee2);
});
var zipWith_default = zipWith;

// node_modules/lodash-es/array.default.js
var array_default_default = {
  chunk: chunk_default,
  compact: compact_default,
  concat: concat_default,
  difference: difference_default,
  differenceBy: differenceBy_default,
  differenceWith: differenceWith_default,
  drop: drop_default,
  dropRight: dropRight_default,
  dropRightWhile: dropRightWhile_default,
  dropWhile: dropWhile_default,
  fill: fill_default,
  findIndex: findIndex_default,
  findLastIndex: findLastIndex_default,
  first: head_default,
  flatten: flatten_default,
  flattenDeep: flattenDeep_default,
  flattenDepth: flattenDepth_default,
  fromPairs: fromPairs_default,
  head: head_default,
  indexOf: indexOf_default,
  initial: initial_default,
  intersection: intersection_default,
  intersectionBy: intersectionBy_default,
  intersectionWith: intersectionWith_default,
  join: join_default,
  last: last_default,
  lastIndexOf: lastIndexOf_default,
  nth: nth_default,
  pull: pull_default,
  pullAll: pullAll_default,
  pullAllBy: pullAllBy_default,
  pullAllWith: pullAllWith_default,
  pullAt: pullAt_default,
  remove: remove_default,
  reverse: reverse_default,
  slice: slice_default,
  sortedIndex: sortedIndex_default,
  sortedIndexBy: sortedIndexBy_default,
  sortedIndexOf: sortedIndexOf_default,
  sortedLastIndex: sortedLastIndex_default,
  sortedLastIndexBy: sortedLastIndexBy_default,
  sortedLastIndexOf: sortedLastIndexOf_default,
  sortedUniq: sortedUniq_default,
  sortedUniqBy: sortedUniqBy_default,
  tail: tail_default,
  take: take_default,
  takeRight: takeRight_default,
  takeRightWhile: takeRightWhile_default,
  takeWhile: takeWhile_default,
  union: union_default,
  unionBy: unionBy_default,
  unionWith: unionWith_default,
  uniq: uniq_default,
  uniqBy: uniqBy_default,
  uniqWith: uniqWith_default,
  unzip: unzip_default,
  unzipWith: unzipWith_default,
  without: without_default,
  xor: xor_default,
  xorBy: xorBy_default,
  xorWith: xorWith_default,
  zip: zip_default,
  zipObject: zipObject_default,
  zipObjectDeep: zipObjectDeep_default,
  zipWith: zipWith_default
};

// node_modules/lodash-es/collection.default.js
var collection_default_default = {
  countBy: countBy_default,
  each: forEach_default,
  eachRight: forEachRight_default,
  every: every_default,
  filter: filter_default,
  find: find_default,
  findLast: findLast_default,
  flatMap: flatMap_default,
  flatMapDeep: flatMapDeep_default,
  flatMapDepth: flatMapDepth_default,
  forEach: forEach_default,
  forEachRight: forEachRight_default,
  groupBy: groupBy_default,
  includes: includes_default,
  invokeMap: invokeMap_default,
  keyBy: keyBy_default,
  map: map_default,
  orderBy: orderBy_default,
  partition: partition_default,
  reduce: reduce_default,
  reduceRight: reduceRight_default,
  reject: reject_default,
  sample: sample_default,
  sampleSize: sampleSize_default,
  shuffle: shuffle_default,
  size: size_default,
  some: some_default,
  sortBy: sortBy_default
};

// node_modules/lodash-es/date.default.js
var date_default_default = {
  now: now_default
};

// node_modules/lodash-es/function.default.js
var function_default_default = {
  after: after_default,
  ary: ary_default,
  before: before_default,
  bind: bind_default,
  bindKey: bindKey_default,
  curry: curry_default,
  curryRight: curryRight_default,
  debounce: debounce_default,
  defer: defer_default,
  delay: delay_default,
  flip: flip_default,
  memoize: memoize_default,
  negate: negate_default,
  once: once_default,
  overArgs: overArgs_default,
  partial: partial_default,
  partialRight: partialRight_default,
  rearg: rearg_default,
  rest: rest_default,
  spread: spread_default,
  throttle: throttle_default,
  unary: unary_default,
  wrap: wrap_default
};

// node_modules/lodash-es/lang.default.js
var lang_default_default = {
  castArray: castArray_default,
  clone: clone_default,
  cloneDeep: cloneDeep_default,
  cloneDeepWith: cloneDeepWith_default,
  cloneWith: cloneWith_default,
  conformsTo: conformsTo_default,
  eq: eq_default,
  gt: gt_default,
  gte: gte_default,
  isArguments: isArguments_default,
  isArray: isArray_default,
  isArrayBuffer: isArrayBuffer_default,
  isArrayLike: isArrayLike_default,
  isArrayLikeObject: isArrayLikeObject_default,
  isBoolean: isBoolean_default,
  isBuffer: isBuffer_default,
  isDate: isDate_default,
  isElement: isElement_default,
  isEmpty: isEmpty_default,
  isEqual: isEqual_default,
  isEqualWith: isEqualWith_default,
  isError: isError_default,
  isFinite: isFinite_default,
  isFunction: isFunction_default,
  isInteger: isInteger_default,
  isLength: isLength_default,
  isMap: isMap_default,
  isMatch: isMatch_default,
  isMatchWith: isMatchWith_default,
  isNaN: isNaN_default,
  isNative: isNative_default,
  isNil: isNil_default,
  isNull: isNull_default,
  isNumber: isNumber_default,
  isObject: isObject_default,
  isObjectLike: isObjectLike_default,
  isPlainObject: isPlainObject_default,
  isRegExp: isRegExp_default,
  isSafeInteger: isSafeInteger_default,
  isSet: isSet_default,
  isString: isString_default,
  isSymbol: isSymbol_default,
  isTypedArray: isTypedArray_default,
  isUndefined: isUndefined_default,
  isWeakMap: isWeakMap_default,
  isWeakSet: isWeakSet_default,
  lt: lt_default,
  lte: lte_default,
  toArray: toArray_default,
  toFinite: toFinite_default,
  toInteger: toInteger_default,
  toLength: toLength_default,
  toNumber: toNumber_default,
  toPlainObject: toPlainObject_default,
  toSafeInteger: toSafeInteger_default,
  toString: toString_default
};

// node_modules/lodash-es/math.default.js
var math_default_default = {
  add: add_default,
  ceil: ceil_default,
  divide: divide_default,
  floor: floor_default,
  max: max_default,
  maxBy: maxBy_default,
  mean: mean_default,
  meanBy: meanBy_default,
  min: min_default,
  minBy: minBy_default,
  multiply: multiply_default,
  round: round_default,
  subtract: subtract_default,
  sum: sum_default,
  sumBy: sumBy_default
};

// node_modules/lodash-es/number.default.js
var number_default_default = {
  clamp: clamp_default,
  inRange: inRange_default,
  random: random_default
};

// node_modules/lodash-es/object.default.js
var object_default_default = {
  assign: assign_default,
  assignIn: assignIn_default,
  assignInWith: assignInWith_default,
  assignWith: assignWith_default,
  at: at_default,
  create: create_default,
  defaults: defaults_default,
  defaultsDeep: defaultsDeep_default,
  entries: toPairs_default,
  entriesIn: toPairsIn_default,
  extend: assignIn_default,
  extendWith: assignInWith_default,
  findKey: findKey_default,
  findLastKey: findLastKey_default,
  forIn: forIn_default,
  forInRight: forInRight_default,
  forOwn: forOwn_default,
  forOwnRight: forOwnRight_default,
  functions: functions_default,
  functionsIn: functionsIn_default,
  get: get_default,
  has: has_default,
  hasIn: hasIn_default,
  invert: invert_default,
  invertBy: invertBy_default,
  invoke: invoke_default,
  keys: keys_default,
  keysIn: keysIn_default,
  mapKeys: mapKeys_default,
  mapValues: mapValues_default,
  merge: merge_default,
  mergeWith: mergeWith_default,
  omit: omit_default,
  omitBy: omitBy_default,
  pick: pick_default,
  pickBy: pickBy_default,
  result: result_default,
  set: set_default,
  setWith: setWith_default,
  toPairs: toPairs_default,
  toPairsIn: toPairsIn_default,
  transform: transform_default,
  unset: unset_default,
  update: update_default,
  updateWith: updateWith_default,
  values: values_default,
  valuesIn: valuesIn_default
};

// node_modules/lodash-es/seq.default.js
var seq_default_default = {
  at: wrapperAt_default,
  chain: chain_default,
  commit: commit_default,
  lodash: wrapperLodash_default,
  next: next_default,
  plant: plant_default,
  reverse: wrapperReverse_default,
  tap: tap_default,
  thru: thru_default,
  toIterator: toIterator_default,
  toJSON: wrapperValue_default,
  value: wrapperValue_default,
  valueOf: wrapperValue_default,
  wrapperChain: wrapperChain_default
};

// node_modules/lodash-es/string.default.js
var string_default_default = {
  camelCase: camelCase_default,
  capitalize: capitalize_default,
  deburr: deburr_default,
  endsWith: endsWith_default,
  escape: escape_default,
  escapeRegExp: escapeRegExp_default,
  kebabCase: kebabCase_default,
  lowerCase: lowerCase_default,
  lowerFirst: lowerFirst_default,
  pad: pad_default,
  padEnd: padEnd_default,
  padStart: padStart_default,
  parseInt: parseInt_default,
  repeat: repeat_default,
  replace: replace_default,
  snakeCase: snakeCase_default,
  split: split_default,
  startCase: startCase_default,
  startsWith: startsWith_default,
  template: template_default,
  templateSettings: templateSettings_default,
  toLower: toLower_default,
  toUpper: toUpper_default,
  trim: trim_default,
  trimEnd: trimEnd_default,
  trimStart: trimStart_default,
  truncate: truncate_default,
  unescape: unescape_default,
  upperCase: upperCase_default,
  upperFirst: upperFirst_default,
  words: words_default
};

// node_modules/lodash-es/util.default.js
var util_default_default = {
  attempt: attempt_default,
  bindAll: bindAll_default,
  cond: cond_default,
  conforms: conforms_default,
  constant: constant_default,
  defaultTo: defaultTo_default,
  flow: flow_default,
  flowRight: flowRight_default,
  identity: identity_default,
  iteratee: iteratee_default,
  matches: matches_default,
  matchesProperty: matchesProperty_default,
  method: method_default,
  methodOf: methodOf_default,
  mixin: mixin_default,
  noop: noop_default,
  nthArg: nthArg_default,
  over: over_default,
  overEvery: overEvery_default,
  overSome: overSome_default,
  property: property_default,
  propertyOf: propertyOf_default,
  range: range_default,
  rangeRight: rangeRight_default,
  stubArray: stubArray_default,
  stubFalse: stubFalse_default,
  stubObject: stubObject_default,
  stubString: stubString_default,
  stubTrue: stubTrue_default,
  times: times_default,
  toPath: toPath_default,
  uniqueId: uniqueId_default
};

// node_modules/lodash-es/_lazyClone.js
function lazyClone() {
  var result2 = new LazyWrapper_default(this.__wrapped__);
  result2.__actions__ = copyArray_default(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray_default(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray_default(this.__views__);
  return result2;
}
var lazyClone_default = lazyClone;

// node_modules/lodash-es/_lazyReverse.js
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper_default(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var lazyReverse_default = lazyReverse;

// node_modules/lodash-es/_getView.js
var nativeMax16 = Math.max;
var nativeMin13 = Math.min;
function getView(start2, end, transforms2) {
  var index = -1, length = transforms2.length;
  while (++index < length) {
    var data = transforms2[index], size2 = data.size;
    switch (data.type) {
      case "drop":
        start2 += size2;
        break;
      case "dropRight":
        end -= size2;
        break;
      case "take":
        end = nativeMin13(end, start2 + size2);
        break;
      case "takeRight":
        start2 = nativeMax16(start2, end - size2);
        break;
    }
  }
  return { "start": start2, "end": end };
}
var getView_default = getView;

// node_modules/lodash-es/_lazyValue.js
var LAZY_FILTER_FLAG = 1;
var LAZY_MAP_FLAG = 2;
var nativeMin14 = Math.min;
function lazyValue() {
  var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_default(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView_default(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin14(length, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length && takeCount == length) {
    return baseWrapperValue_default(array, this.__actions__);
  }
  var result2 = [];
  outer:
    while (length-- && resIndex < takeCount) {
      index += dir;
      var iterIndex = -1, value = array[index];
      while (++iterIndex < iterLength) {
        var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
        if (type == LAZY_MAP_FLAG) {
          value = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result2[resIndex++] = value;
    }
  return result2;
}
var lazyValue_default = lazyValue;

// node_modules/lodash-es/lodash.default.js
var VERSION = "4.17.21";
var WRAP_BIND_KEY_FLAG7 = 2;
var LAZY_FILTER_FLAG2 = 1;
var LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH7 = 4294967295;
var arrayProto6 = Array.prototype;
var objectProto29 = Object.prototype;
var hasOwnProperty25 = objectProto29.hasOwnProperty;
var symIterator2 = Symbol_default ? Symbol_default.iterator : void 0;
var nativeMax17 = Math.max;
var nativeMin15 = Math.min;
var mixin2 = /* @__PURE__ */ (function(func) {
  return function(object, source, options) {
    if (options == null) {
      var isObj = isObject_default(source), props = isObj && keys_default(source), methodNames = props && props.length && baseFunctions_default(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object;
        object = this;
      }
    }
    return func(object, source, options);
  };
})(mixin_default);
wrapperLodash_default.after = function_default_default.after;
wrapperLodash_default.ary = function_default_default.ary;
wrapperLodash_default.assign = object_default_default.assign;
wrapperLodash_default.assignIn = object_default_default.assignIn;
wrapperLodash_default.assignInWith = object_default_default.assignInWith;
wrapperLodash_default.assignWith = object_default_default.assignWith;
wrapperLodash_default.at = object_default_default.at;
wrapperLodash_default.before = function_default_default.before;
wrapperLodash_default.bind = function_default_default.bind;
wrapperLodash_default.bindAll = util_default_default.bindAll;
wrapperLodash_default.bindKey = function_default_default.bindKey;
wrapperLodash_default.castArray = lang_default_default.castArray;
wrapperLodash_default.chain = seq_default_default.chain;
wrapperLodash_default.chunk = array_default_default.chunk;
wrapperLodash_default.compact = array_default_default.compact;
wrapperLodash_default.concat = array_default_default.concat;
wrapperLodash_default.cond = util_default_default.cond;
wrapperLodash_default.conforms = util_default_default.conforms;
wrapperLodash_default.constant = util_default_default.constant;
wrapperLodash_default.countBy = collection_default_default.countBy;
wrapperLodash_default.create = object_default_default.create;
wrapperLodash_default.curry = function_default_default.curry;
wrapperLodash_default.curryRight = function_default_default.curryRight;
wrapperLodash_default.debounce = function_default_default.debounce;
wrapperLodash_default.defaults = object_default_default.defaults;
wrapperLodash_default.defaultsDeep = object_default_default.defaultsDeep;
wrapperLodash_default.defer = function_default_default.defer;
wrapperLodash_default.delay = function_default_default.delay;
wrapperLodash_default.difference = array_default_default.difference;
wrapperLodash_default.differenceBy = array_default_default.differenceBy;
wrapperLodash_default.differenceWith = array_default_default.differenceWith;
wrapperLodash_default.drop = array_default_default.drop;
wrapperLodash_default.dropRight = array_default_default.dropRight;
wrapperLodash_default.dropRightWhile = array_default_default.dropRightWhile;
wrapperLodash_default.dropWhile = array_default_default.dropWhile;
wrapperLodash_default.fill = array_default_default.fill;
wrapperLodash_default.filter = collection_default_default.filter;
wrapperLodash_default.flatMap = collection_default_default.flatMap;
wrapperLodash_default.flatMapDeep = collection_default_default.flatMapDeep;
wrapperLodash_default.flatMapDepth = collection_default_default.flatMapDepth;
wrapperLodash_default.flatten = array_default_default.flatten;
wrapperLodash_default.flattenDeep = array_default_default.flattenDeep;
wrapperLodash_default.flattenDepth = array_default_default.flattenDepth;
wrapperLodash_default.flip = function_default_default.flip;
wrapperLodash_default.flow = util_default_default.flow;
wrapperLodash_default.flowRight = util_default_default.flowRight;
wrapperLodash_default.fromPairs = array_default_default.fromPairs;
wrapperLodash_default.functions = object_default_default.functions;
wrapperLodash_default.functionsIn = object_default_default.functionsIn;
wrapperLodash_default.groupBy = collection_default_default.groupBy;
wrapperLodash_default.initial = array_default_default.initial;
wrapperLodash_default.intersection = array_default_default.intersection;
wrapperLodash_default.intersectionBy = array_default_default.intersectionBy;
wrapperLodash_default.intersectionWith = array_default_default.intersectionWith;
wrapperLodash_default.invert = object_default_default.invert;
wrapperLodash_default.invertBy = object_default_default.invertBy;
wrapperLodash_default.invokeMap = collection_default_default.invokeMap;
wrapperLodash_default.iteratee = util_default_default.iteratee;
wrapperLodash_default.keyBy = collection_default_default.keyBy;
wrapperLodash_default.keys = keys_default;
wrapperLodash_default.keysIn = object_default_default.keysIn;
wrapperLodash_default.map = collection_default_default.map;
wrapperLodash_default.mapKeys = object_default_default.mapKeys;
wrapperLodash_default.mapValues = object_default_default.mapValues;
wrapperLodash_default.matches = util_default_default.matches;
wrapperLodash_default.matchesProperty = util_default_default.matchesProperty;
wrapperLodash_default.memoize = function_default_default.memoize;
wrapperLodash_default.merge = object_default_default.merge;
wrapperLodash_default.mergeWith = object_default_default.mergeWith;
wrapperLodash_default.method = util_default_default.method;
wrapperLodash_default.methodOf = util_default_default.methodOf;
wrapperLodash_default.mixin = mixin2;
wrapperLodash_default.negate = negate_default;
wrapperLodash_default.nthArg = util_default_default.nthArg;
wrapperLodash_default.omit = object_default_default.omit;
wrapperLodash_default.omitBy = object_default_default.omitBy;
wrapperLodash_default.once = function_default_default.once;
wrapperLodash_default.orderBy = collection_default_default.orderBy;
wrapperLodash_default.over = util_default_default.over;
wrapperLodash_default.overArgs = function_default_default.overArgs;
wrapperLodash_default.overEvery = util_default_default.overEvery;
wrapperLodash_default.overSome = util_default_default.overSome;
wrapperLodash_default.partial = function_default_default.partial;
wrapperLodash_default.partialRight = function_default_default.partialRight;
wrapperLodash_default.partition = collection_default_default.partition;
wrapperLodash_default.pick = object_default_default.pick;
wrapperLodash_default.pickBy = object_default_default.pickBy;
wrapperLodash_default.property = util_default_default.property;
wrapperLodash_default.propertyOf = util_default_default.propertyOf;
wrapperLodash_default.pull = array_default_default.pull;
wrapperLodash_default.pullAll = array_default_default.pullAll;
wrapperLodash_default.pullAllBy = array_default_default.pullAllBy;
wrapperLodash_default.pullAllWith = array_default_default.pullAllWith;
wrapperLodash_default.pullAt = array_default_default.pullAt;
wrapperLodash_default.range = util_default_default.range;
wrapperLodash_default.rangeRight = util_default_default.rangeRight;
wrapperLodash_default.rearg = function_default_default.rearg;
wrapperLodash_default.reject = collection_default_default.reject;
wrapperLodash_default.remove = array_default_default.remove;
wrapperLodash_default.rest = function_default_default.rest;
wrapperLodash_default.reverse = array_default_default.reverse;
wrapperLodash_default.sampleSize = collection_default_default.sampleSize;
wrapperLodash_default.set = object_default_default.set;
wrapperLodash_default.setWith = object_default_default.setWith;
wrapperLodash_default.shuffle = collection_default_default.shuffle;
wrapperLodash_default.slice = array_default_default.slice;
wrapperLodash_default.sortBy = collection_default_default.sortBy;
wrapperLodash_default.sortedUniq = array_default_default.sortedUniq;
wrapperLodash_default.sortedUniqBy = array_default_default.sortedUniqBy;
wrapperLodash_default.split = string_default_default.split;
wrapperLodash_default.spread = function_default_default.spread;
wrapperLodash_default.tail = array_default_default.tail;
wrapperLodash_default.take = array_default_default.take;
wrapperLodash_default.takeRight = array_default_default.takeRight;
wrapperLodash_default.takeRightWhile = array_default_default.takeRightWhile;
wrapperLodash_default.takeWhile = array_default_default.takeWhile;
wrapperLodash_default.tap = seq_default_default.tap;
wrapperLodash_default.throttle = function_default_default.throttle;
wrapperLodash_default.thru = thru_default;
wrapperLodash_default.toArray = lang_default_default.toArray;
wrapperLodash_default.toPairs = object_default_default.toPairs;
wrapperLodash_default.toPairsIn = object_default_default.toPairsIn;
wrapperLodash_default.toPath = util_default_default.toPath;
wrapperLodash_default.toPlainObject = lang_default_default.toPlainObject;
wrapperLodash_default.transform = object_default_default.transform;
wrapperLodash_default.unary = function_default_default.unary;
wrapperLodash_default.union = array_default_default.union;
wrapperLodash_default.unionBy = array_default_default.unionBy;
wrapperLodash_default.unionWith = array_default_default.unionWith;
wrapperLodash_default.uniq = array_default_default.uniq;
wrapperLodash_default.uniqBy = array_default_default.uniqBy;
wrapperLodash_default.uniqWith = array_default_default.uniqWith;
wrapperLodash_default.unset = object_default_default.unset;
wrapperLodash_default.unzip = array_default_default.unzip;
wrapperLodash_default.unzipWith = array_default_default.unzipWith;
wrapperLodash_default.update = object_default_default.update;
wrapperLodash_default.updateWith = object_default_default.updateWith;
wrapperLodash_default.values = object_default_default.values;
wrapperLodash_default.valuesIn = object_default_default.valuesIn;
wrapperLodash_default.without = array_default_default.without;
wrapperLodash_default.words = string_default_default.words;
wrapperLodash_default.wrap = function_default_default.wrap;
wrapperLodash_default.xor = array_default_default.xor;
wrapperLodash_default.xorBy = array_default_default.xorBy;
wrapperLodash_default.xorWith = array_default_default.xorWith;
wrapperLodash_default.zip = array_default_default.zip;
wrapperLodash_default.zipObject = array_default_default.zipObject;
wrapperLodash_default.zipObjectDeep = array_default_default.zipObjectDeep;
wrapperLodash_default.zipWith = array_default_default.zipWith;
wrapperLodash_default.entries = object_default_default.toPairs;
wrapperLodash_default.entriesIn = object_default_default.toPairsIn;
wrapperLodash_default.extend = object_default_default.assignIn;
wrapperLodash_default.extendWith = object_default_default.assignInWith;
mixin2(wrapperLodash_default, wrapperLodash_default);
wrapperLodash_default.add = math_default_default.add;
wrapperLodash_default.attempt = util_default_default.attempt;
wrapperLodash_default.camelCase = string_default_default.camelCase;
wrapperLodash_default.capitalize = string_default_default.capitalize;
wrapperLodash_default.ceil = math_default_default.ceil;
wrapperLodash_default.clamp = number_default_default.clamp;
wrapperLodash_default.clone = lang_default_default.clone;
wrapperLodash_default.cloneDeep = lang_default_default.cloneDeep;
wrapperLodash_default.cloneDeepWith = lang_default_default.cloneDeepWith;
wrapperLodash_default.cloneWith = lang_default_default.cloneWith;
wrapperLodash_default.conformsTo = lang_default_default.conformsTo;
wrapperLodash_default.deburr = string_default_default.deburr;
wrapperLodash_default.defaultTo = util_default_default.defaultTo;
wrapperLodash_default.divide = math_default_default.divide;
wrapperLodash_default.endsWith = string_default_default.endsWith;
wrapperLodash_default.eq = lang_default_default.eq;
wrapperLodash_default.escape = string_default_default.escape;
wrapperLodash_default.escapeRegExp = string_default_default.escapeRegExp;
wrapperLodash_default.every = collection_default_default.every;
wrapperLodash_default.find = collection_default_default.find;
wrapperLodash_default.findIndex = array_default_default.findIndex;
wrapperLodash_default.findKey = object_default_default.findKey;
wrapperLodash_default.findLast = collection_default_default.findLast;
wrapperLodash_default.findLastIndex = array_default_default.findLastIndex;
wrapperLodash_default.findLastKey = object_default_default.findLastKey;
wrapperLodash_default.floor = math_default_default.floor;
wrapperLodash_default.forEach = collection_default_default.forEach;
wrapperLodash_default.forEachRight = collection_default_default.forEachRight;
wrapperLodash_default.forIn = object_default_default.forIn;
wrapperLodash_default.forInRight = object_default_default.forInRight;
wrapperLodash_default.forOwn = object_default_default.forOwn;
wrapperLodash_default.forOwnRight = object_default_default.forOwnRight;
wrapperLodash_default.get = object_default_default.get;
wrapperLodash_default.gt = lang_default_default.gt;
wrapperLodash_default.gte = lang_default_default.gte;
wrapperLodash_default.has = object_default_default.has;
wrapperLodash_default.hasIn = object_default_default.hasIn;
wrapperLodash_default.head = array_default_default.head;
wrapperLodash_default.identity = identity_default;
wrapperLodash_default.includes = collection_default_default.includes;
wrapperLodash_default.indexOf = array_default_default.indexOf;
wrapperLodash_default.inRange = number_default_default.inRange;
wrapperLodash_default.invoke = object_default_default.invoke;
wrapperLodash_default.isArguments = lang_default_default.isArguments;
wrapperLodash_default.isArray = isArray_default;
wrapperLodash_default.isArrayBuffer = lang_default_default.isArrayBuffer;
wrapperLodash_default.isArrayLike = lang_default_default.isArrayLike;
wrapperLodash_default.isArrayLikeObject = lang_default_default.isArrayLikeObject;
wrapperLodash_default.isBoolean = lang_default_default.isBoolean;
wrapperLodash_default.isBuffer = lang_default_default.isBuffer;
wrapperLodash_default.isDate = lang_default_default.isDate;
wrapperLodash_default.isElement = lang_default_default.isElement;
wrapperLodash_default.isEmpty = lang_default_default.isEmpty;
wrapperLodash_default.isEqual = lang_default_default.isEqual;
wrapperLodash_default.isEqualWith = lang_default_default.isEqualWith;
wrapperLodash_default.isError = lang_default_default.isError;
wrapperLodash_default.isFinite = lang_default_default.isFinite;
wrapperLodash_default.isFunction = lang_default_default.isFunction;
wrapperLodash_default.isInteger = lang_default_default.isInteger;
wrapperLodash_default.isLength = lang_default_default.isLength;
wrapperLodash_default.isMap = lang_default_default.isMap;
wrapperLodash_default.isMatch = lang_default_default.isMatch;
wrapperLodash_default.isMatchWith = lang_default_default.isMatchWith;
wrapperLodash_default.isNaN = lang_default_default.isNaN;
wrapperLodash_default.isNative = lang_default_default.isNative;
wrapperLodash_default.isNil = lang_default_default.isNil;
wrapperLodash_default.isNull = lang_default_default.isNull;
wrapperLodash_default.isNumber = lang_default_default.isNumber;
wrapperLodash_default.isObject = isObject_default;
wrapperLodash_default.isObjectLike = lang_default_default.isObjectLike;
wrapperLodash_default.isPlainObject = lang_default_default.isPlainObject;
wrapperLodash_default.isRegExp = lang_default_default.isRegExp;
wrapperLodash_default.isSafeInteger = lang_default_default.isSafeInteger;
wrapperLodash_default.isSet = lang_default_default.isSet;
wrapperLodash_default.isString = lang_default_default.isString;
wrapperLodash_default.isSymbol = lang_default_default.isSymbol;
wrapperLodash_default.isTypedArray = lang_default_default.isTypedArray;
wrapperLodash_default.isUndefined = lang_default_default.isUndefined;
wrapperLodash_default.isWeakMap = lang_default_default.isWeakMap;
wrapperLodash_default.isWeakSet = lang_default_default.isWeakSet;
wrapperLodash_default.join = array_default_default.join;
wrapperLodash_default.kebabCase = string_default_default.kebabCase;
wrapperLodash_default.last = last_default;
wrapperLodash_default.lastIndexOf = array_default_default.lastIndexOf;
wrapperLodash_default.lowerCase = string_default_default.lowerCase;
wrapperLodash_default.lowerFirst = string_default_default.lowerFirst;
wrapperLodash_default.lt = lang_default_default.lt;
wrapperLodash_default.lte = lang_default_default.lte;
wrapperLodash_default.max = math_default_default.max;
wrapperLodash_default.maxBy = math_default_default.maxBy;
wrapperLodash_default.mean = math_default_default.mean;
wrapperLodash_default.meanBy = math_default_default.meanBy;
wrapperLodash_default.min = math_default_default.min;
wrapperLodash_default.minBy = math_default_default.minBy;
wrapperLodash_default.stubArray = util_default_default.stubArray;
wrapperLodash_default.stubFalse = util_default_default.stubFalse;
wrapperLodash_default.stubObject = util_default_default.stubObject;
wrapperLodash_default.stubString = util_default_default.stubString;
wrapperLodash_default.stubTrue = util_default_default.stubTrue;
wrapperLodash_default.multiply = math_default_default.multiply;
wrapperLodash_default.nth = array_default_default.nth;
wrapperLodash_default.noop = util_default_default.noop;
wrapperLodash_default.now = date_default_default.now;
wrapperLodash_default.pad = string_default_default.pad;
wrapperLodash_default.padEnd = string_default_default.padEnd;
wrapperLodash_default.padStart = string_default_default.padStart;
wrapperLodash_default.parseInt = string_default_default.parseInt;
wrapperLodash_default.random = number_default_default.random;
wrapperLodash_default.reduce = collection_default_default.reduce;
wrapperLodash_default.reduceRight = collection_default_default.reduceRight;
wrapperLodash_default.repeat = string_default_default.repeat;
wrapperLodash_default.replace = string_default_default.replace;
wrapperLodash_default.result = object_default_default.result;
wrapperLodash_default.round = math_default_default.round;
wrapperLodash_default.sample = collection_default_default.sample;
wrapperLodash_default.size = collection_default_default.size;
wrapperLodash_default.snakeCase = string_default_default.snakeCase;
wrapperLodash_default.some = collection_default_default.some;
wrapperLodash_default.sortedIndex = array_default_default.sortedIndex;
wrapperLodash_default.sortedIndexBy = array_default_default.sortedIndexBy;
wrapperLodash_default.sortedIndexOf = array_default_default.sortedIndexOf;
wrapperLodash_default.sortedLastIndex = array_default_default.sortedLastIndex;
wrapperLodash_default.sortedLastIndexBy = array_default_default.sortedLastIndexBy;
wrapperLodash_default.sortedLastIndexOf = array_default_default.sortedLastIndexOf;
wrapperLodash_default.startCase = string_default_default.startCase;
wrapperLodash_default.startsWith = string_default_default.startsWith;
wrapperLodash_default.subtract = math_default_default.subtract;
wrapperLodash_default.sum = math_default_default.sum;
wrapperLodash_default.sumBy = math_default_default.sumBy;
wrapperLodash_default.template = string_default_default.template;
wrapperLodash_default.times = util_default_default.times;
wrapperLodash_default.toFinite = lang_default_default.toFinite;
wrapperLodash_default.toInteger = toInteger_default;
wrapperLodash_default.toLength = lang_default_default.toLength;
wrapperLodash_default.toLower = string_default_default.toLower;
wrapperLodash_default.toNumber = lang_default_default.toNumber;
wrapperLodash_default.toSafeInteger = lang_default_default.toSafeInteger;
wrapperLodash_default.toString = lang_default_default.toString;
wrapperLodash_default.toUpper = string_default_default.toUpper;
wrapperLodash_default.trim = string_default_default.trim;
wrapperLodash_default.trimEnd = string_default_default.trimEnd;
wrapperLodash_default.trimStart = string_default_default.trimStart;
wrapperLodash_default.truncate = string_default_default.truncate;
wrapperLodash_default.unescape = string_default_default.unescape;
wrapperLodash_default.uniqueId = util_default_default.uniqueId;
wrapperLodash_default.upperCase = string_default_default.upperCase;
wrapperLodash_default.upperFirst = string_default_default.upperFirst;
wrapperLodash_default.each = collection_default_default.forEach;
wrapperLodash_default.eachRight = collection_default_default.forEachRight;
wrapperLodash_default.first = array_default_default.head;
mixin2(wrapperLodash_default, (function() {
  var source = {};
  baseForOwn_default(wrapperLodash_default, function(func, methodName) {
    if (!hasOwnProperty25.call(wrapperLodash_default.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
})(), { "chain": false });
wrapperLodash_default.VERSION = VERSION;
(wrapperLodash_default.templateSettings = string_default_default.templateSettings).imports._ = wrapperLodash_default;
arrayEach_default(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  wrapperLodash_default[methodName].placeholder = wrapperLodash_default;
});
arrayEach_default(["drop", "take"], function(methodName, index) {
  LazyWrapper_default.prototype[methodName] = function(n) {
    n = n === void 0 ? 1 : nativeMax17(toInteger_default(n), 0);
    var result2 = this.__filtered__ && !index ? new LazyWrapper_default(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin15(n, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin15(n, MAX_ARRAY_LENGTH7),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper_default.prototype[methodName + "Right"] = function(n) {
    return this.reverse()[methodName](n).reverse();
  };
});
arrayEach_default(["filter", "map", "takeWhile"], function(methodName, index) {
  var type = index + 1, isFilter = type == LAZY_FILTER_FLAG2 || type == LAZY_WHILE_FLAG;
  LazyWrapper_default.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee_default(iteratee2, 3),
      "type": type
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach_default(["head", "last"], function(methodName, index) {
  var takeName = "take" + (index ? "Right" : "");
  LazyWrapper_default.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach_default(["initial", "tail"], function(methodName, index) {
  var dropName = "drop" + (index ? "" : "Right");
  LazyWrapper_default.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper_default(this) : this[dropName](1);
  };
});
LazyWrapper_default.prototype.compact = function() {
  return this.filter(identity_default);
};
LazyWrapper_default.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper_default.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper_default.prototype.invokeMap = baseRest_default(function(path, args) {
  if (typeof path == "function") {
    return new LazyWrapper_default(this);
  }
  return this.map(function(value) {
    return baseInvoke_default(value, path, args);
  });
});
LazyWrapper_default.prototype.reject = function(predicate) {
  return this.filter(negate_default(baseIteratee_default(predicate)));
};
LazyWrapper_default.prototype.slice = function(start2, end) {
  start2 = toInteger_default(start2);
  var result2 = this;
  if (result2.__filtered__ && (start2 > 0 || end < 0)) {
    return new LazyWrapper_default(result2);
  }
  if (start2 < 0) {
    result2 = result2.takeRight(-start2);
  } else if (start2) {
    result2 = result2.drop(start2);
  }
  if (end !== void 0) {
    end = toInteger_default(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
  }
  return result2;
};
LazyWrapper_default.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper_default.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH7);
};
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_default[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  wrapperLodash_default.prototype[methodName] = function() {
    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper_default, iteratee2 = args[0], useLazy = isLazy || isArray_default(value);
    var interceptor = function(value2) {
      var result3 = lodashFunc.apply(wrapperLodash_default, arrayPush_default([value2], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value = onlyLazy ? value : new LazyWrapper_default(this);
      var result2 = func.apply(value, args);
      result2.__actions__.push({ "func": thru_default, "args": [interceptor], "thisArg": void 0 });
      return new LodashWrapper_default(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach_default(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func = arrayProto6[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  wrapperLodash_default.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value = this.value();
      return func.apply(isArray_default(value) ? value : [], args);
    }
    return this[chainName](function(value2) {
      return func.apply(isArray_default(value2) ? value2 : [], args);
    });
  };
});
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var lodashFunc = wrapperLodash_default[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + "";
    if (!hasOwnProperty25.call(realNames_default, key)) {
      realNames_default[key] = [];
    }
    realNames_default[key].push({ "name": methodName, "func": lodashFunc });
  }
});
realNames_default[createHybrid_default(void 0, WRAP_BIND_KEY_FLAG7).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper_default.prototype.clone = lazyClone_default;
LazyWrapper_default.prototype.reverse = lazyReverse_default;
LazyWrapper_default.prototype.value = lazyValue_default;
wrapperLodash_default.prototype.at = seq_default_default.at;
wrapperLodash_default.prototype.chain = seq_default_default.wrapperChain;
wrapperLodash_default.prototype.commit = seq_default_default.commit;
wrapperLodash_default.prototype.next = seq_default_default.next;
wrapperLodash_default.prototype.plant = seq_default_default.plant;
wrapperLodash_default.prototype.reverse = seq_default_default.reverse;
wrapperLodash_default.prototype.toJSON = wrapperLodash_default.prototype.valueOf = wrapperLodash_default.prototype.value = seq_default_default.value;
wrapperLodash_default.prototype.first = wrapperLodash_default.prototype.head;
if (symIterator2) {
  wrapperLodash_default.prototype[symIterator2] = seq_default_default.toIterator;
}

// node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject2 = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject2(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap2(port);
  }
};
var throwTransferHandler = {
  canHandle: (value) => isObject2(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent2 = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent2[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent2, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap2(ep, target) {
  const pendingListeners = /* @__PURE__ */ new Map();
  ep.addEventListener("message", function handleMessage(ev) {
    const { data } = ev;
    if (!data || !data.id) {
      return;
    }
    const resolver = pendingListeners.get(data.id);
    if (!resolver) {
      return;
    }
    try {
      resolver(data);
    } finally {
      pendingListeners.delete(data.id);
    }
  });
  return createProxy(ep, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, pendingListeners, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          pendingListeners.clear();
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r = requestResponseMessage(ep, pendingListeners, {
          type: "GET",
          path: path.map((p) => p.toString())
        }).then(fromWireValue);
        return r.then.bind(r);
      }
      return createProxy(ep, pendingListeners, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, pendingListeners, {
        type: "SET",
        path: [...path, prop].map((p) => p.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last2 = path[path.length - 1];
      if (last2 === createEndpoint) {
        return requestResponseMessage(ep, pendingListeners, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last2 === "bind") {
        return createProxy(ep, pendingListeners, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "APPLY",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "CONSTRUCT",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v2) => v2[0]), myFlat(processed.map((v2) => v2[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, pendingListeners, msg, transfers) {
  return new Promise((resolve) => {
    const id = generateUUID();
    pendingListeners.set(id, resolve);
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// node_modules/@allmaps/transform/dist/shared/distortion.js
var supportedDistortionMeasures = [
  "log2sigma",
  "twoOmega",
  "airyKavr",
  "signDetJ",
  "thetaa"
];
function computeDistortionsFromPartialDerivatives(distortionMeasures, partialDerivativeX, partialDerivativeY, referenceScale = 1) {
  if (distortionMeasures.length === 0) {
    return /* @__PURE__ */ new Map();
  }
  if (!partialDerivativeX || !partialDerivativeY) {
    return new Map(distortionMeasures.map((distortionMeasure) => [distortionMeasure, 0]));
  }
  const { E, F, a, b } = computeDistortionIntermediates(partialDerivativeX, partialDerivativeY);
  return new Map(distortionMeasures.map((distortionMeasure) => {
    if (supportedDistortionMeasures.indexOf(distortionMeasure) === -1) {
      throw new Error("Distortion " + distortionMeasure + " not supported");
    }
    switch (supportedDistortionMeasures.indexOf(distortionMeasure)) {
      case 0:
        return [distortionMeasure, log2sigma(a, b, referenceScale)];
      case 1:
        return [distortionMeasure, twoOmega(a, b)];
      case 2:
        return [distortionMeasure, airyKavr(a, b, referenceScale)];
      case 3:
        return [
          distortionMeasure,
          signDetJ(partialDerivativeX, partialDerivativeY)
        ];
      case 4:
        return [distortionMeasure, thetaa(partialDerivativeX, a, b, E, F)];
      default:
        return [distortionMeasure, 0];
    }
  }));
}
function computeDistortionIntermediates(partialDerivativeX, partialDerivativeY) {
  const E = partialDerivativeX[0] ** 2 + partialDerivativeX[1] ** 2;
  const F = partialDerivativeX[0] * partialDerivativeY[0] + partialDerivativeX[1] * partialDerivativeY[1];
  const G = partialDerivativeY[0] ** 2 + partialDerivativeY[1] ** 2;
  const a = Math.sqrt(0.5 * (E + G + Math.sqrt((E - G) ** 2 + 4 * F ** 2)));
  const b = Math.sqrt(0.5 * (E + G - Math.sqrt((E - G) ** 2 + 4 * F ** 2)));
  return { E, F, G, a, b };
}
function log2sigma(a, b, referenceScale = 1) {
  return (Math.log(a * b) - 2 * Math.log(referenceScale)) / Math.log(2);
}
function twoOmega(a, b) {
  return 2 * Math.asin((a - b) / (a + b));
}
function airyKavr(a, b, referenceScale = 1) {
  return 0.5 * (Math.log(a / referenceScale) ** 2 + Math.log(b / referenceScale) ** 2);
}
function signDetJ(partialDerivativeX, partialDerivativeY) {
  return Math.sign(partialDerivativeX[0] * partialDerivativeY[1] - partialDerivativeX[1] * partialDerivativeY[0]);
}
function thetaa(partialDerivativeX, a, b, E, F) {
  const thetaxp = Math.atan(partialDerivativeX[1] / partialDerivativeX[0]);
  const alphap = Math.sign(-F) * Math.asin(Math.sqrt((1 - a ** 2 / E) / (1 - (a / b) ** 2)));
  return thetaxp - alphap;
}

// node_modules/@allmaps/transform/dist/transformation-types/BaseTransformation.js
var BaseTransformation = class {
  sourcePoints;
  destinationPoints;
  destinationTransformedSourcePoints;
  type;
  pointCount;
  pointCountMinimum;
  errors;
  rmse;
  /**
   * Create a transformation
   *
   * @param sourcePoints - The source points
   * @param destinationPoints - The destination points
   * @param type - The transformation type
   * @param pointCountMinimum - The minimum number of points for the transformation type
   */
  constructor(sourcePoints, destinationPoints, type, pointCountMinimum) {
    this.sourcePoints = sourcePoints;
    this.destinationPoints = destinationPoints;
    this.pointCount = this.sourcePoints.length;
    this.type = type;
    this.pointCountMinimum = pointCountMinimum;
    if (this.pointCount < this.pointCountMinimum) {
      throw new Error("Not enough control points. A " + this.type + " transformation requires a minimum of " + this.pointCountMinimum + " points, but " + this.pointCount + " are given.");
    }
  }
  /**
   * Set weights.
   *
   * The weights might be obtained in other ways then through solving
   * (e.g. through solving multiple transformation together when staping).
   * This function can be used to set weights computed elsewhere.
   */
  setWeightsArrays(weightsArrays) {
    this.weightsArrays = weightsArrays;
    this.processWeightsArrays();
  }
  processWeightsArrays() {
    return;
  }
  /**
   * Get the destination-transformed source points.
   *
   * @returns source points, transformed to destination domain
   */
  getDestinationTransformedSourcePoints() {
    if (!this.destinationTransformedSourcePoints) {
      this.destinationTransformedSourcePoints = this.sourcePoints.map((sourcePoint) => this.evaluateFunction(sourcePoint));
    }
    return this.destinationTransformedSourcePoints;
  }
  getMeasures() {
    return {};
  }
  getErrors() {
    if (!this.errors) {
      const destinationTransformedSourcePoints = this.getDestinationTransformedSourcePoints();
      this.errors = this.destinationPoints.map((destinationPoint, index) => distance(destinationPoint, destinationTransformedSourcePoints[index]));
    }
    return this.errors;
  }
  getRmse() {
    if (!this.rmse) {
      const destinationTransformedSourcePoints = this.getDestinationTransformedSourcePoints();
      if (!this.destinationTransformedSourcePoints) {
        this.getDestinationTransformedSourcePoints();
      }
      this.rmse = rms(this.destinationPoints, destinationTransformedSourcePoints);
    }
    return this.rmse;
  }
};

// node_modules/@allmaps/transform/dist/transformation-types/BaseLinearWeightsTransformation.js
var BaseLinearWeightsTransformation = class extends BaseTransformation {
  destinationPointsArrays;
  constructor(sourcePoints, destinationPoints, type, pointCountMinimum) {
    super(sourcePoints, destinationPoints, type, pointCountMinimum);
    this.destinationPointsArrays = this.getDestinationPointsArrays();
  }
};

// node_modules/ml-matrix/matrix.mjs
var matrix = __toESM(require_matrix(), 1);
var SingularValueDecomposition2 = matrix.SingularValueDecomposition;
var matrix_default = matrix.default.Matrix ? matrix.default.Matrix : matrix.Matrix;
var inverse2 = matrix.inverse;
var pseudoInverse2 = matrix.pseudoInverse;

// node_modules/@allmaps/transform/dist/shared/solve-functions.js
function solveJointlyPseudoInverse(coefsArrayMatrices, destinationPointsArrays) {
  const coefsMatrix = new matrix_default([
    ...coefsArrayMatrices[0],
    ...coefsArrayMatrices[1]
  ]);
  const destinationPointsMatrix = matrix_default.columnVector([
    ...destinationPointsArrays[0],
    ...destinationPointsArrays[1]
  ]);
  const pseudoInverseCoefsMatrix = pseudoInverse2(coefsMatrix);
  const weightsMatrix = pseudoInverseCoefsMatrix.mmul(destinationPointsMatrix);
  const weightsArray = weightsMatrix.to1DArray();
  return weightsArray;
}
function solveIndependentlyPseudoInverse(coefsArrayMatrix, destinationPointsArrays) {
  const coefsMatrix = new matrix_default(coefsArrayMatrix);
  const destinationPointsMatrices = [
    matrix_default.columnVector(destinationPointsArrays[0]),
    matrix_default.columnVector(destinationPointsArrays[1])
  ];
  const pseudoInverseCoefsMatrix = pseudoInverse2(coefsMatrix);
  const weightsMatrices = [
    pseudoInverseCoefsMatrix.mmul(destinationPointsMatrices[0]),
    pseudoInverseCoefsMatrix.mmul(destinationPointsMatrices[1])
  ];
  const weightsArrays = weightsMatrices.map((matrix2) => matrix2.to1DArray());
  return weightsArrays;
}
function solveIndependentlyInverse(coefsArrayMatrix, destinationPointsArrays) {
  const coefsMatrix = new matrix_default(coefsArrayMatrix);
  const destinationPointsMatrices = [
    matrix_default.columnVector(destinationPointsArrays[0]),
    matrix_default.columnVector(destinationPointsArrays[1])
  ];
  const inverseCoefsMatrix = inverse2(coefsMatrix);
  const weightsMatrices = [
    inverseCoefsMatrix.mmul(destinationPointsMatrices[0]),
    inverseCoefsMatrix.mmul(destinationPointsMatrices[1])
  ];
  const weightsArrays = weightsMatrices.map((matrix2) => matrix2.to1DArray());
  return weightsArrays;
}
function solveJointlySvd(coefsArrayMatrices, pointCount) {
  const coefsMatrix = [];
  for (let i = 0; i < pointCount; i++) {
    coefsMatrix.push(coefsArrayMatrices[0][i]);
    coefsMatrix.push(coefsArrayMatrices[1][i]);
  }
  const svdCoefsMatrix = new SingularValueDecomposition2(coefsMatrix);
  const weightsMatrix = matrix_default.from1DArray(3, 3, svdCoefsMatrix.rightSingularVectors.getColumn(8)).transpose();
  const weightsArrays = weightsMatrix.to2DArray();
  return weightsArrays;
}

// node_modules/@allmaps/transform/dist/transformation-types/Helmert.js
var Helmert = class extends BaseLinearWeightsTransformation {
  coefsArrayMatrices;
  coefsArrayMatricesSize;
  weightsArray;
  weightsArrays;
  constructor(sourcePoints, destinationPoints) {
    super(sourcePoints, destinationPoints, "helmert", 2);
    this.coefsArrayMatrices = this.getCoefsArrayMatrices();
    this.coefsArrayMatricesSize = this.coefsArrayMatrices.map((coefsArrayMatrix) => arrayMatrixSize(coefsArrayMatrix));
  }
  getDestinationPointsArrays() {
    return [
      this.destinationPoints.map((value) => value[0]),
      this.destinationPoints.map((value) => value[1])
    ];
  }
  getCoefsArrayMatrices() {
    let coefsArrayMatrix0 = newArrayMatrix(this.pointCount, 4, 0);
    let coefsArrayMatrix1 = newArrayMatrix(this.pointCount, 4, 0);
    for (let i = 0; i < this.pointCount; i++) {
      const sourcePointCoefsArrays = this.getSourcePointCoefsArrays(this.sourcePoints[i]);
      coefsArrayMatrix0 = pasteArrayMatrix(coefsArrayMatrix0, i, 0, [
        sourcePointCoefsArrays[0]
      ]);
      coefsArrayMatrix1 = pasteArrayMatrix(coefsArrayMatrix1, i, 0, [
        sourcePointCoefsArrays[1]
      ]);
    }
    return [coefsArrayMatrix0, coefsArrayMatrix1];
  }
  /**
   * Get two 1x4 coefsArrays, populating the 2Nx4 coefsArrayMatrices
   * 1 0 x0 -y0
   * 1 0 x1 -y1
   * ...
   * 0 1 y0 x0
   * 0 1 y1 x1
   * ...
   *
   * @param sourcePoint
   */
  getSourcePointCoefsArrays(sourcePoint) {
    return [
      [1, 0, sourcePoint[0], -sourcePoint[1]],
      [0, 1, sourcePoint[1], sourcePoint[0]]
    ];
  }
  solve() {
    this.weightsArray = solveJointlyPseudoInverse(this.coefsArrayMatrices, this.destinationPointsArrays);
    this.weightsArrays = [this.weightsArray, this.weightsArray];
  }
  getMeasures() {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArray) {
      throw new Error("Helmert weights not computed");
    }
    const measures = {};
    measures.scale = Math.sqrt(this.weightsArray[2] ** 2 + this.weightsArray[3] ** 2);
    measures.rotation = Math.atan2(this.weightsArray[3], this.weightsArray[2]);
    measures.translation = [this.weightsArray[0], this.weightsArray[1]];
    return measures;
  }
  evaluateFunction(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArray) {
      throw new Error("Helmert weights not computed");
    }
    const newDestinationPoint = [
      this.weightsArray[0] + this.weightsArray[2] * newSourcePoint[0] - this.weightsArray[3] * newSourcePoint[1],
      this.weightsArray[1] + this.weightsArray[2] * newSourcePoint[1] + this.weightsArray[3] * newSourcePoint[0]
    ];
    return newDestinationPoint;
  }
  evaluatePartialDerivativeX(_newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArray) {
      throw new Error("Helmert weights not computed");
    }
    const newDestinationPointPartDerX = [
      this.weightsArray[2],
      this.weightsArray[3]
    ];
    return newDestinationPointPartDerX;
  }
  evaluatePartialDerivativeY(_newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArray) {
      throw new Error("Helmert weights not computed");
    }
    const newDestinationPointPartDerY = [
      -this.weightsArray[3],
      this.weightsArray[2]
    ];
    return newDestinationPointPartDerY;
  }
};

// node_modules/@allmaps/transform/dist/transformation-types/Straight.js
var Straight = class extends BaseTransformation {
  weightsArrays;
  constructor(sourcePoints, destinationPoints) {
    super(sourcePoints, destinationPoints, "straight", 2);
  }
  /** Solve the x and y components jointly.
   *
   * This computes the corresponding Helmert transform and get the scale from it.
   */
  solve() {
    const helmertTransformation = new Helmert(this.sourcePoints, this.destinationPoints);
    const scale3 = helmertTransformation.getMeasures().scale;
    const sourcePointsCenter = this.sourcePoints.reduce((center, point2) => [center[0] + point2[0], center[1] + point2[1]]).map((coordinate) => coordinate / this.pointCount);
    const destinationPointsCenter = this.destinationPoints.reduce((center, point2) => [center[0] + point2[0], center[1] + point2[1]]).map((coordinate) => coordinate / this.pointCount);
    const translation = destinationPointsCenter.map((coord, i) => coord - sourcePointsCenter[i] * scale3);
    this.weightsArrays = {
      scale: scale3,
      sourcePointsCenter,
      destinationPointsCenter,
      translation
    };
  }
  // Evaluate the transformation function at a new point
  evaluateFunction(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPoint = [
      this.weightsArrays.translation[0] + this.weightsArrays.scale * newSourcePoint[0],
      this.weightsArrays.translation[1] + this.weightsArrays.scale * newSourcePoint[1]
    ];
    return newDestinationPoint;
  }
  // Evaluate the transformation function's partial derivative to x at a new point
  evaluatePartialDerivativeX(_newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPointPartDerX = [this.weightsArrays.scale, 0];
    return newDestinationPointPartDerX;
  }
  // Evaluate the transformation function's partial derivative to y at a new point
  evaluatePartialDerivativeY(_newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPointPartDerY = [0, this.weightsArrays.scale];
    return newDestinationPointPartDerY;
  }
};

// node_modules/@allmaps/transform/dist/transformation-types/BaseIndependentLinearWeightsTransformation.js
var BaseIndependentLinearWeightsTransformation = class extends BaseLinearWeightsTransformation {
  constructor(sourcePoints, destinationPoints, type, pointCountMinimum) {
    super(sourcePoints, destinationPoints, type, pointCountMinimum);
  }
  getCoefsArrayMatrices() {
    const coefsArrayMatrix = this.getCoefsArrayMatrix();
    return [coefsArrayMatrix, coefsArrayMatrix];
  }
  getSourcePointCoefsArrays(sourcePoint) {
    const sourcePointCoefsArray = this.getSourcePointCoefsArray(sourcePoint);
    return [sourcePointCoefsArray, sourcePointCoefsArray];
  }
};

// node_modules/@allmaps/transform/dist/transformation-types/BasePolynomialTransformation.js
var BasePolynomialTransformation = class extends BaseIndependentLinearWeightsTransformation {
  coefsArrayMatrices;
  coefsArrayMatrix;
  coefsArrayMatricesSize;
  coefsArrayMatrixSize;
  order;
  weightsArrays;
  constructor(sourcePoints, destinationPoints, order) {
    order = order || 1;
    const pointsCountMinimum = (order + 1) * (order + 2) / 2;
    super(sourcePoints, destinationPoints, "polynomial" + order, pointsCountMinimum);
    this.order = order;
    if (this.order < 1 || this.order > 3) {
      throw new Error("Only polynomial transformations of order 1, 2 or 3 are supported");
    }
    this.coefsArrayMatrices = this.getCoefsArrayMatrices();
    this.coefsArrayMatrix = this.coefsArrayMatrices[0];
    this.coefsArrayMatricesSize = this.coefsArrayMatrices.map((coefsArrayMatrix) => arrayMatrixSize(coefsArrayMatrix));
    this.coefsArrayMatrixSize = arrayMatrixSize(this.coefsArrayMatrix);
  }
  getDestinationPointsArrays() {
    return [
      this.destinationPoints.map((value) => value[0]),
      this.destinationPoints.map((value) => value[1])
    ];
  }
  getCoefsArrayMatrix() {
    let coefsArrayArray = newArrayMatrix(this.pointCount, this.pointCountMinimum, 0);
    for (let i = 0; i < this.pointCount; i++) {
      coefsArrayArray = pasteArrayMatrix(coefsArrayArray, i, 0, [
        this.getSourcePointCoefsArray(this.sourcePoints[i])
      ]);
    }
    return coefsArrayArray;
  }
  solve() {
    this.weightsArrays = solveIndependentlyPseudoInverse(this.coefsArrayMatrix, this.destinationPointsArrays);
  }
};

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial1.js
var Polynomial1 = class _Polynomial1 extends BasePolynomialTransformation {
  constructor(sourcePoints, destinationPoints) {
    super(sourcePoints, destinationPoints, 1);
  }
  getSourcePointCoefsArray(sourcePoint) {
    return _Polynomial1.getPolynomial1SourcePointCoefsArray(sourcePoint);
  }
  /**
   * Get 1x3 coefsArray, populating the Nx3 coefsArrayMatrix
   * 1 x0 y0
   * 1 x1 y1
   * 1 x2 y2
   * ...
   *
   * @param sourcePoint
   */
  static getPolynomial1SourcePointCoefsArray(sourcePoint) {
    return [1, sourcePoint[0], sourcePoint[1]];
  }
  getHomogeneousTransform() {
    if (!this.weightsArrays) {
      return void 0;
    }
    return [
      this.weightsArrays[0][1],
      this.weightsArrays[1][1],
      this.weightsArrays[0][2],
      this.weightsArrays[1][2],
      this.weightsArrays[0][0],
      this.weightsArrays[1][0]
    ];
  }
  setWeightsArraysFromHomogeneousTransform(homogeneousTransform) {
    this.weightsArrays = [
      [
        homogeneousTransform[4],
        homogeneousTransform[0],
        homogeneousTransform[2]
      ],
      [
        homogeneousTransform[5],
        homogeneousTransform[1],
        homogeneousTransform[3]
      ]
    ];
  }
  getMeasures() {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const measures = {};
    measures.translation = [this.weightsArrays[0][0], this.weightsArrays[1][0]];
    const a = this.weightsArrays[0][1];
    const b = this.weightsArrays[1][1];
    const c = this.weightsArrays[0][2];
    const d = this.weightsArrays[1][2];
    const delta = a * d - b * c;
    if (a != 0 || b != 0) {
      const r = Math.sqrt(a * a + b * b);
      measures.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
      measures.scales = [r, delta / r];
      measures.shears = [Math.atan((a * c + b * d) / (r * r)), 0];
    } else if (c != 0 || d != 0) {
      const s = Math.sqrt(c * c + d * d);
      measures.rotation = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
      measures.scales = [delta / s, s];
      measures.shears = [0, Math.atan((a * c + b * d) / (s * s))];
    } else {
    }
    return measures;
  }
  evaluateFunction(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPoint = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPoint[i] += this.weightsArrays[i][0] + this.weightsArrays[i][1] * newSourcePoint[0] + this.weightsArrays[i][2] * newSourcePoint[1];
    }
    return newDestinationPoint;
  }
  evaluatePartialDerivativeX(_newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPointPartDerX = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPointPartDerX[i] += this.weightsArrays[i][1];
    }
    return newDestinationPointPartDerX;
  }
  evaluatePartialDerivativeY(_newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPointPartDerY = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPointPartDerY[i] += this.weightsArrays[i][2];
    }
    return newDestinationPointPartDerY;
  }
};

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial2.js
var Polynomial2 = class _Polynomial2 extends BasePolynomialTransformation {
  constructor(sourcePoints, destinationPoints) {
    super(sourcePoints, destinationPoints, 2);
  }
  getSourcePointCoefsArray(sourcePoint) {
    return _Polynomial2.getPolynomial2SourcePointCoefsArray(sourcePoint);
  }
  /**
   * Get 1x3 coefsArray, populating the Nx3 coefsArrayMatrix
   * 1 x0 y0 x0^2 y0^2 x0*y0
   * ...
   *
   * @param sourcePoint
   */
  static getPolynomial2SourcePointCoefsArray(sourcePoint) {
    return [
      1,
      sourcePoint[0],
      sourcePoint[1],
      sourcePoint[0] ** 2,
      sourcePoint[1] ** 2,
      sourcePoint[0] * sourcePoint[1]
    ];
  }
  // Evaluate the transformation function at a new point
  evaluateFunction(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPoint = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPoint[i] += this.weightsArrays[i][0] + this.weightsArrays[i][1] * newSourcePoint[0] + this.weightsArrays[i][2] * newSourcePoint[1] + this.weightsArrays[i][3] * newSourcePoint[0] ** 2 + this.weightsArrays[i][4] * newSourcePoint[1] ** 2 + this.weightsArrays[i][5] * newSourcePoint[0] * newSourcePoint[1];
    }
    return newDestinationPoint;
  }
  // Evaluate the transformation function's partial derivative to x at a new point
  evaluatePartialDerivativeX(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPointPartDerX = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPointPartDerX[i] += this.weightsArrays[i][1] + 2 * this.weightsArrays[i][3] * newSourcePoint[0] + this.weightsArrays[i][5] * newSourcePoint[1];
    }
    return newDestinationPointPartDerX;
  }
  // Evaluate the transformation function's partial derivative to x at a new point
  evaluatePartialDerivativeY(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPointPartDerY = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPointPartDerY[i] += this.weightsArrays[i][2] + 2 * this.weightsArrays[i][4] * newSourcePoint[1] + this.weightsArrays[i][5] * newSourcePoint[0];
    }
    return newDestinationPointPartDerY;
  }
};

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial3.js
var Polynomial3 = class _Polynomial3 extends BasePolynomialTransformation {
  constructor(sourcePoints, destinationPoints) {
    super(sourcePoints, destinationPoints, 3);
  }
  getSourcePointCoefsArray(sourcePoint) {
    return _Polynomial3.getPolynomial3SourcePointCoefsArray(sourcePoint);
  }
  /**
   * Get 1x3 coefsArray, populating the Nx3 coefsArrayMatrix
   * 1 x0 y0 x0^2 y0^2 x0*y0 x0^3 y0^3 x0^2*y0 x0*y0^2
   * ...
   *
   * @param sourcePoint
   */
  static getPolynomial3SourcePointCoefsArray(sourcePoint) {
    return [
      1,
      sourcePoint[0],
      sourcePoint[1],
      sourcePoint[0] ** 2,
      sourcePoint[1] ** 2,
      sourcePoint[0] * sourcePoint[1],
      sourcePoint[0] ** 3,
      sourcePoint[1] ** 3,
      sourcePoint[0] ** 2 * sourcePoint[1],
      sourcePoint[0] * sourcePoint[1] ** 2
    ];
  }
  // Evaluate the transformation function at a new point
  evaluateFunction(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPoint = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPoint[i] += this.weightsArrays[i][0] + this.weightsArrays[i][1] * newSourcePoint[0] + this.weightsArrays[i][2] * newSourcePoint[1] + this.weightsArrays[i][3] * newSourcePoint[0] ** 2 + this.weightsArrays[i][4] * newSourcePoint[1] ** 2 + this.weightsArrays[i][5] * newSourcePoint[0] * newSourcePoint[1] + this.weightsArrays[i][6] * newSourcePoint[0] ** 3 + this.weightsArrays[i][7] * newSourcePoint[1] ** 3 + this.weightsArrays[i][8] * newSourcePoint[0] ** 2 * newSourcePoint[1] + this.weightsArrays[i][9] * newSourcePoint[0] * newSourcePoint[1] ** 2;
    }
    return newDestinationPoint;
  }
  // Evaluate the transformation function's partial derivative to x at a new point
  evaluatePartialDerivativeX(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPointPartDerX = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPointPartDerX[i] += this.weightsArrays[i][1] + 2 * this.weightsArrays[i][3] * newSourcePoint[0] + this.weightsArrays[i][5] * newSourcePoint[1] + 3 * this.weightsArrays[i][6] * newSourcePoint[0] ** 2 + 2 * this.weightsArrays[i][8] * newSourcePoint[0] * newSourcePoint[1] + this.weightsArrays[i][9] * newSourcePoint[1] ** 2;
    }
    return newDestinationPointPartDerX;
  }
  // Evaluate the transformation function's partial derivative to x at a new point
  evaluatePartialDerivativeY(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const newDestinationPointPartDerY = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPointPartDerY[i] += this.weightsArrays[i][2] + 2 * this.weightsArrays[i][4] * newSourcePoint[1] + this.weightsArrays[i][5] * newSourcePoint[0] + 3 * this.weightsArrays[i][7] * newSourcePoint[1] ** 2 + this.weightsArrays[i][8] * newSourcePoint[0] ** 2 + 2 * this.weightsArrays[i][9] * newSourcePoint[0] * newSourcePoint[1];
    }
    return newDestinationPointPartDerY;
  }
};

// node_modules/@allmaps/transform/dist/transformation-types/Projective.js
var Projective = class extends BaseTransformation {
  coefsArrayMatrices;
  weightsArrays;
  constructor(sourcePoints, destinationPoints) {
    super(sourcePoints, destinationPoints, "projective", 4);
    this.coefsArrayMatrices = [
      newArrayMatrix(this.pointCount, 9, 0),
      newArrayMatrix(this.pointCount, 9, 0)
    ];
    for (let i = 0; i < this.pointCount; i++) {
      this.coefsArrayMatrices[0][i][0] = -sourcePoints[i][0];
      this.coefsArrayMatrices[0][i][1] = -sourcePoints[i][1];
      this.coefsArrayMatrices[0][i][2] = -1;
      this.coefsArrayMatrices[0][i][3] = 0;
      this.coefsArrayMatrices[0][i][4] = 0;
      this.coefsArrayMatrices[0][i][5] = 0;
      this.coefsArrayMatrices[0][i][6] = destinationPoints[i][0] * sourcePoints[i][0];
      this.coefsArrayMatrices[0][i][7] = destinationPoints[i][0] * sourcePoints[i][1];
      this.coefsArrayMatrices[0][i][8] = destinationPoints[i][0];
      this.coefsArrayMatrices[1][i][0] = 0;
      this.coefsArrayMatrices[1][i][1] = 0;
      this.coefsArrayMatrices[1][i][2] = 0;
      this.coefsArrayMatrices[1][i][3] = -sourcePoints[i][0];
      this.coefsArrayMatrices[1][i][4] = -sourcePoints[i][1];
      this.coefsArrayMatrices[1][i][5] = -1;
      this.coefsArrayMatrices[1][i][6] = destinationPoints[i][1] * sourcePoints[i][0];
      this.coefsArrayMatrices[1][i][7] = destinationPoints[i][1] * sourcePoints[i][1];
      this.coefsArrayMatrices[1][i][8] = destinationPoints[i][1];
    }
  }
  solve() {
    this.weightsArrays = solveJointlySvd(this.coefsArrayMatrices, this.pointCount);
  }
  evaluateFunction(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const c = this.weightsArrays[0][2] * newSourcePoint[0] + this.weightsArrays[1][2] * newSourcePoint[1] + this.weightsArrays[2][2];
    const num1 = this.weightsArrays[0][0] * newSourcePoint[0] + this.weightsArrays[1][0] * newSourcePoint[1] + this.weightsArrays[2][0];
    const num2 = this.weightsArrays[0][1] * newSourcePoint[0] + this.weightsArrays[1][1] * newSourcePoint[1] + this.weightsArrays[2][1];
    const newDestinationPoint = [num1 / c, num2 / c];
    return newDestinationPoint;
  }
  evaluatePartialDerivativeX(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const c = this.weightsArrays[0][2] * newSourcePoint[0] + this.weightsArrays[1][2] * newSourcePoint[1] + this.weightsArrays[2][2];
    const num1 = this.weightsArrays[0][0] * newSourcePoint[0] + this.weightsArrays[1][0] * newSourcePoint[1] + this.weightsArrays[2][0];
    const num2 = this.weightsArrays[0][1] * newSourcePoint[0] + this.weightsArrays[1][1] * newSourcePoint[1] + this.weightsArrays[2][1];
    const newDestinationPointPartDerX = [
      (c * this.weightsArrays[0][0] - this.weightsArrays[0][2] * num1) / c ** 2,
      (c * this.weightsArrays[0][1] - this.weightsArrays[0][2] * num2) / c ** 2
    ];
    return newDestinationPointPartDerX;
  }
  evaluatePartialDerivativeY(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    const c = this.weightsArrays[0][2] * newSourcePoint[0] + this.weightsArrays[1][2] * newSourcePoint[1] + this.weightsArrays[2][2];
    const num1 = this.weightsArrays[0][0] * newSourcePoint[0] + this.weightsArrays[1][0] * newSourcePoint[1] + this.weightsArrays[2][0];
    const num2 = this.weightsArrays[0][1] * newSourcePoint[0] + this.weightsArrays[1][1] * newSourcePoint[1] + this.weightsArrays[2][1];
    const newDestinationPointPartDerY = [
      (c * this.weightsArrays[1][0] - this.weightsArrays[1][2] * num1) / c ** 2,
      (c * this.weightsArrays[1][1] - this.weightsArrays[1][2] * num2) / c ** 2
    ];
    return newDestinationPointPartDerY;
  }
};

// node_modules/@allmaps/transform/dist/transformation-types/RBF.js
var RBF = class extends BaseIndependentLinearWeightsTransformation {
  kernelFunction;
  normFunction;
  epsilon;
  coefsArrayMatrices;
  coefsArrayMatrix;
  coefsArrayMatricesSize;
  coefsArrayMatrixSize;
  weightsArrays;
  rbfWeightsArrays;
  affineWeightsArrays;
  constructor(sourcePoints, destinationPoints, kernelFunction, normFunction, type, epsilon2) {
    super(sourcePoints, destinationPoints, type, 3);
    this.kernelFunction = kernelFunction;
    this.normFunction = normFunction;
    this.epsilon = epsilon2;
    this.coefsArrayMatrices = this.getCoefsArrayMatrices();
    this.coefsArrayMatrix = this.coefsArrayMatrices[0];
    this.coefsArrayMatricesSize = this.coefsArrayMatrices.map((coefsArrayMatrix) => arrayMatrixSize(coefsArrayMatrix));
    this.coefsArrayMatrixSize = arrayMatrixSize(this.coefsArrayMatrix);
  }
  getDestinationPointsArrays() {
    return [
      [...this.destinationPoints, [0, 0], [0, 0], [0, 0]].map((value) => value[0]),
      [...this.destinationPoints, [0, 0], [0, 0], [0, 0]].map((value) => value[1])
    ];
  }
  getCoefsArrayMatrix() {
    const normsArrayMatrix = newArrayMatrix(this.pointCount, this.pointCount, 0);
    for (let i = 0; i < this.pointCount; i++) {
      for (let j = 0; j < this.pointCount; j++) {
        normsArrayMatrix[i][j] = this.normFunction(this.sourcePoints[i], this.sourcePoints[j]);
      }
    }
    if (this.epsilon === void 0) {
      const normsSum = normsArrayMatrix.map((row) => row.reduce((a, c) => a + c, 0)).reduce((a, c) => a + c, 0);
      this.epsilon = normsSum / (Math.pow(this.pointCount, 2) - this.pointCount);
    }
    const kernelCoefsArrayMatrix = newArrayMatrix(this.pointCount, this.pointCount, 0);
    for (let i = 0; i < this.pointCount; i++) {
      for (let j = 0; j < this.pointCount; j++) {
        kernelCoefsArrayMatrix[i][j] = this.kernelFunction(normsArrayMatrix[i][j], {
          epsilon: this.epsilon
        });
      }
    }
    let affineCoefsArrayMatrix = newArrayMatrix(this.pointCount, 3, 0);
    for (let i = 0; i < this.pointCount; i++) {
      affineCoefsArrayMatrix = pasteArrayMatrix(affineCoefsArrayMatrix, i, 0, [
        Polynomial1.getPolynomial1SourcePointCoefsArray(this.sourcePoints[i])
      ]);
    }
    const zerosArrayMatrix = newArrayMatrix(3, 3, 0);
    const coefsArrayMatrix = newBlockArrayMatrix([
      [kernelCoefsArrayMatrix, affineCoefsArrayMatrix],
      [transposeArrayMatrix(affineCoefsArrayMatrix), zerosArrayMatrix]
    ]);
    return coefsArrayMatrix;
  }
  /**
   * Get 1x(N+3) coefsArray, populating the (N+3)x(N+3) coefsArrayMatrix
   *
   * The coefsArray has a 1xN kernel part and a 1x3 affine part.
   *
   * @param sourcePoint
   */
  getSourcePointCoefsArray(sourcePoint) {
    return [
      ...this.getRbfKernelSourcePointCoefsArray(sourcePoint),
      ...Polynomial1.getPolynomial1SourcePointCoefsArray(sourcePoint)
    ];
  }
  getRbfKernelSourcePointCoefsArray(sourcePoint) {
    const kernelSourcePointCoefsArray = [];
    for (let i = 0; i < this.pointCount; i++) {
      kernelSourcePointCoefsArray.push(this.kernelFunction(this.normFunction(this.sourcePoints[i], sourcePoint), {
        epsilon: this.epsilon
      }));
    }
    return kernelSourcePointCoefsArray;
  }
  setWeightsArrays(weightsArrays, epsilon2) {
    if (epsilon2) {
      this.epsilon = epsilon2;
    }
    super.setWeightsArrays(weightsArrays);
  }
  /**
   * Solve the x and y components independently.
   *
   * This uses the exact inverse to compute (for each component, using the same coefs for both)
   * the exact solution for the system of linear equations
   * which is (in general) invertable to an exact solution.
   *
   * This wil result in a weights array for each component with rbf weights and affine weights.
   */
  solve() {
    this.weightsArrays = solveIndependentlyInverse(this.coefsArrayMatrix, this.destinationPointsArrays);
    this.processWeightsArrays();
  }
  processWeightsArrays() {
    if (!this.weightsArrays) {
      throw new Error("Weights not computed");
    }
    this.rbfWeightsArrays = this.weightsArrays.map((array) => array.slice(0, this.pointCount));
    this.affineWeightsArrays = this.weightsArrays.map((array) => array.slice(this.pointCount));
  }
  evaluateFunction(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.rbfWeightsArrays || !this.affineWeightsArrays) {
      throw new Error("RBF weights not computed");
    }
    const rbfWeights = this.rbfWeightsArrays;
    const affineWeights = this.affineWeightsArrays;
    const newDistances = this.sourcePoints.map((sourcePoint) => this.normFunction(newSourcePoint, sourcePoint));
    const newDestinationPoint = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPoint[i] = newDistances.reduce((sum3, dist2, index) => sum3 + this.kernelFunction(dist2, { epsilon: this.epsilon }) * rbfWeights[i][index], 0);
      newDestinationPoint[i] += affineWeights[i][0] + affineWeights[i][1] * newSourcePoint[0] + affineWeights[i][2] * newSourcePoint[1];
    }
    return newDestinationPoint;
  }
  evaluatePartialDerivativeX(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.rbfWeightsArrays || !this.affineWeightsArrays) {
      throw new Error("RBF weights not computed");
    }
    const rbfWeights = this.rbfWeightsArrays;
    const affineWeights = this.affineWeightsArrays;
    const newDistances = this.sourcePoints.map((sourcePoint) => this.normFunction(newSourcePoint, sourcePoint));
    const newDestinationPointPartDerX = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPointPartDerX[i] = newDistances.reduce((sum3, dist2, index) => sum3 + (dist2 === 0 ? 0 : this.kernelFunction(dist2, {
        derivative: 1,
        epsilon: this.epsilon
      }) * ((newSourcePoint[0] - this.sourcePoints[index][0]) / dist2) * rbfWeights[i][index]), 0);
      newDestinationPointPartDerX[i] += affineWeights[i][1];
    }
    return newDestinationPointPartDerX;
  }
  evaluatePartialDerivativeY(newSourcePoint) {
    if (!this.weightsArrays) {
      this.solve();
    }
    if (!this.rbfWeightsArrays || !this.affineWeightsArrays) {
      throw new Error("RBF weights not computed");
    }
    const rbfWeights = this.rbfWeightsArrays;
    const affineWeights = this.affineWeightsArrays;
    const newDistances = this.sourcePoints.map((sourcePoint) => this.normFunction(newSourcePoint, sourcePoint));
    const newDestinationPointPartDerY = [0, 0];
    for (let i = 0; i < 2; i++) {
      newDestinationPointPartDerY[i] = newDistances.reduce((sum3, dist2, index) => sum3 + (dist2 === 0 ? 0 : this.kernelFunction(dist2, {
        derivative: 1,
        epsilon: this.epsilon
      }) * ((newSourcePoint[1] - this.sourcePoints[index][1]) / dist2) * rbfWeights[i][index]), 0);
      newDestinationPointPartDerY[i] += affineWeights[i][2];
    }
    return newDestinationPointPartDerY;
  }
};

// node_modules/@allmaps/transform/dist/shared/kernel-functions.js
function linearKernel(r, options) {
  if (!options.derivative) {
    return r;
  } else if (options.derivative === 1) {
    return 1;
  } else {
    throw new Error("Derivate of order " + options.derivative + " not implemented");
  }
}
function thinPlateKernel(r, options) {
  if (!options.derivative) {
    if (r === 0) {
      return 0;
    }
    return Math.pow(r, 2) * Math.log(r);
  } else if (options.derivative === 1) {
    if (r === 0) {
      return 0;
    }
    return r + 2 * r * Math.log(r);
  } else {
    throw new Error("Derivate of order " + options.derivative + " not implemented");
  }
}

// node_modules/@allmaps/transform/dist/shared/norm-functions.js
function euclideanNorm(point0, point1) {
  const sub = [point1[0] - point0[0], point1[1] - point0[1]];
  const norm = Math.sqrt(sub[0] ** 2 + sub[1] ** 2);
  return norm;
}

// node_modules/@turf/bearing/dist/esm/index.js
function bearing(start2, end, options = {}) {
  if (options.final === true) {
    return calculateFinalBearing(start2, end);
  }
  const coordinates1 = getCoord(start2);
  const coordinates2 = getCoord(end);
  const lon1 = degreesToRadians(coordinates1[0]);
  const lon2 = degreesToRadians(coordinates2[0]);
  const lat1 = degreesToRadians(coordinates1[1]);
  const lat2 = degreesToRadians(coordinates2[1]);
  const a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return radiansToDegrees(Math.atan2(a, b));
}
function calculateFinalBearing(start2, end) {
  let bear = bearing(end, start2);
  bear = (bear + 180) % 360;
  return bear;
}

// node_modules/@turf/destination/dist/esm/index.js
function destination(origin, distance3, bearing2, options = {}) {
  const coordinates1 = getCoord(origin);
  const longitude1 = degreesToRadians(coordinates1[0]);
  const latitude1 = degreesToRadians(coordinates1[1]);
  const bearingRad = degreesToRadians(bearing2);
  const radians = lengthToRadians(distance3, options.units);
  const latitude2 = Math.asin(
    Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad)
  );
  const longitude2 = longitude1 + Math.atan2(
    Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),
    Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2)
  );
  const lng = radiansToDegrees(longitude2);
  const lat = radiansToDegrees(latitude2);
  return point([lng, lat], options.properties);
}

// node_modules/@turf/distance/dist/esm/index.js
function distance2(from, to, options = {}) {
  var coordinates1 = getCoord(from);
  var coordinates2 = getCoord(to);
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(
    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),
    options.units
  );
}
var turf_distance_default = distance2;

// node_modules/@turf/midpoint/dist/esm/index.js
function midpoint(point1, point2) {
  const dist2 = distance2(point1, point2);
  const heading = bearing(point1, point2);
  const midpoint2 = destination(point1, dist2 / 2, heading);
  return midpoint2;
}
var turf_midpoint_default = midpoint;

// node_modules/@allmaps/transform/dist/shared/refinement-functions.js
var defaultRefinementOptions = {
  maxDepth: 0,
  minOffsetRatio: 0,
  minOffsetDistance: Infinity,
  minLineDistance: Infinity,
  sourceMidPointFunction: midPoint,
  destinationMidPointFunction: midPoint,
  destinationDistanceFunction: distance
};
function refineLineString(lineString, refinementFunction, refinementOptions) {
  lineString = conformLineString(lineString);
  const gcps = lineString.map((point2) => ({
    source: point2,
    destination: refinementFunction(point2)
  }));
  const gcpLines = gcpsToGcpLines(gcps, false);
  const refinedGcpLines = gcpLines.map((gcpLine) => splitGcpLineRecursively(gcpLine, refinementFunction, refinementOptions, 0)).flat(1);
  return gcpLinesToGcps(refinedGcpLines, true);
}
function refineRing(ring, refinementFunction, refinementOptions) {
  ring = conformRing(ring);
  const gcps = ring.map((point2) => ({
    source: point2,
    destination: refinementFunction(point2)
  }));
  const gcpLines = gcpsToGcpLines(gcps, true);
  const refinedGcpLines = gcpLines.map((line) => splitGcpLineRecursively(line, refinementFunction, refinementOptions, 0)).flat(1);
  return gcpLinesToGcps(refinedGcpLines, false);
}
function splitGcpLineRecursively(gcpLine, refinementFunction, refinementOptions, depth) {
  const newMidGcp = newMidGcpIfShouldSplitGcpLine(gcpLine, refinementFunction, refinementOptions, depth);
  if (newMidGcp) {
    return [
      splitGcpLineRecursively([gcpLine[0], newMidGcp], refinementFunction, refinementOptions, depth + 1),
      splitGcpLineRecursively([newMidGcp, gcpLine[1]], refinementFunction, refinementOptions, depth + 1)
    ].flat(1);
  } else {
    return [gcpLine];
  }
}
function newMidGcpIfShouldSplitGcpLine(gcpLine, refinementFunction, refinementOptions, depth) {
  if (depth >= refinementOptions.maxDepth || refinementOptions.maxDepth <= 0) {
    return void 0;
  }
  const { sourceMidPoint, destinationMidPointFromRefinementFunction, destinationMidPointsDistance, destinationLineDistance, destinationRefinedLineDistance } = splitGcpLinePointInfo(gcpLine, refinementFunction, refinementOptions);
  const shouldSplit = shouldSplitGcpLine({
    destinationMidPointsDistance,
    destinationLineDistance,
    destinationRefinedLineDistance
  }, refinementOptions);
  return shouldSplit ? {
    source: sourceMidPoint,
    destination: destinationMidPointFromRefinementFunction
  } : void 0;
}
function splitGcpLinePointInfo(gcpLine, refinementFunction, refinementOptions) {
  const sourceMidPoint = refinementOptions.sourceMidPointFunction(gcpLine[0].source, gcpLine[1].source);
  const destinationMidPoint = refinementOptions.destinationMidPointFunction(gcpLine[0].destination, gcpLine[1].destination);
  const destinationMidPointFromRefinementFunction = refinementFunction(sourceMidPoint);
  const destinationLineDistance = refinementOptions.destinationDistanceFunction(gcpLine[0].destination, gcpLine[1].destination);
  const destinationRefinedLineDistance = refinementOptions.destinationDistanceFunction(refinementFunction(gcpLine[0].source), refinementFunction(gcpLine[1].source));
  const destinationMidPointsDistance = refinementOptions.destinationDistanceFunction(destinationMidPoint, destinationMidPointFromRefinementFunction);
  return {
    sourceMidPoint,
    destinationMidPointFromRefinementFunction,
    destinationMidPointsDistance,
    destinationLineDistance,
    destinationRefinedLineDistance
  };
}
function shouldSplitGcpLine({ destinationMidPointsDistance, destinationLineDistance, destinationRefinedLineDistance }, refinementOptions) {
  return destinationMidPointsDistance / destinationLineDistance > refinementOptions.minOffsetRatio || destinationMidPointsDistance > refinementOptions.minOffsetDistance || destinationRefinedLineDistance > refinementOptions.minLineDistance;
}
function getSourceRefinementResolution(sourceBbox, refinementFunction, refinementOptions) {
  const sourceRectangle = bboxToRectangle(sourceBbox);
  const sourcePointNE = sourceRectangle[2];
  const sourcePointNW = sourceRectangle[3];
  const sourcePointSE = sourceRectangle[1];
  const sourcePointSW = sourceRectangle[0];
  const sourcePointCE = refinementOptions.sourceMidPointFunction(sourcePointNE, sourcePointSE);
  const sourcePointCW = refinementOptions.sourceMidPointFunction(sourcePointNW, sourcePointSW);
  const sourcePointNC = refinementOptions.sourceMidPointFunction(sourcePointNE, sourcePointNW);
  const sourcePointSC = refinementOptions.sourceMidPointFunction(sourcePointSE, sourcePointSW);
  const sourceHorizontalLine = [sourcePointCE, sourcePointCW];
  const sourceVerticalLine = [sourcePointNC, sourcePointSC];
  const sourceRefinedHorizontalLineString = refineLineString(sourceHorizontalLine, refinementFunction, refinementOptions).map((generalGcp) => generalGcp.source);
  const sourceRefinedVerticalLineString = refineLineString(sourceVerticalLine, refinementFunction, refinementOptions).map((generalGcp) => generalGcp.source);
  if (sourceRefinedHorizontalLineString.length === 2 && sourceRefinedVerticalLineString.length === 2) {
    return void 0;
  }
  const sourceMinHorizontalLineSquaredLengths = [];
  for (let i = 0; i < sourceRefinedHorizontalLineString.length - 1; i++) {
    sourceMinHorizontalLineSquaredLengths.push(squaredDistance(sourceRefinedHorizontalLineString[i], sourceRefinedHorizontalLineString[i + 1]));
  }
  const sourceMinHorizontalLineLength = Math.sqrt(Math.min(...sourceMinHorizontalLineSquaredLengths));
  const sourceMinVerticalLineSquaredLengths = [];
  for (let i = 0; i < sourceRefinedVerticalLineString.length - 1; i++) {
    sourceMinVerticalLineSquaredLengths.push(squaredDistance(sourceRefinedVerticalLineString[i], sourceRefinedVerticalLineString[i + 1]));
  }
  const sourceMinVerticalLineLength = Math.sqrt(Math.min(...sourceMinVerticalLineSquaredLengths));
  const sourceMinLineLength = Math.min(sourceMinHorizontalLineLength, sourceMinVerticalLineLength);
  return sourceMinLineLength;
}
function gcpsToGcpLines(gcps, close = false) {
  const lineCount = gcps.length - (close ? 0 : 1);
  const lines = [];
  for (let index = 0; index < lineCount; index++) {
    lines.push([gcps[index], gcps[(index + 1) % gcps.length]]);
  }
  return lines;
}
function gcpLinesToGcps(lines, close = false) {
  const gcps = lines.map((line) => line[0]);
  if (close) {
    gcps.push(lines[lines.length - 1][1]);
  }
  return gcps;
}

// node_modules/@allmaps/transform/dist/shared/transform-functions.js
var defaultGeneralGcpTransformOptions = {
  maxDepth: 0,
  minOffsetRatio: 0,
  minOffsetDistance: Infinity,
  minLineDistance: Infinity,
  sourceIsGeographic: false,
  destinationIsGeographic: false,
  isMultiGeometry: false,
  distortionMeasures: [],
  referenceScale: 1,
  preForward: (point2) => point2,
  postForward: (point2) => point2,
  preBackward: (point2) => point2,
  postBackward: (point2) => point2
};
var defaultGeneralGcpTransformerOptions = {
  differentHandedness: false,
  ...defaultGeneralGcpTransformOptions
};
function gcpTransformOptionsToGeneralGcpTransformOptions(gcpTransformOptions) {
  if (gcpTransformOptions === void 0) {
    return {};
  }
  const generalGcpTransformOptions = gcpTransformOptions;
  if (gcpTransformOptions.geoIsGeographic) {
    generalGcpTransformOptions.destinationIsGeographic = gcpTransformOptions.geoIsGeographic;
  }
  if (gcpTransformOptions.postToGeo) {
    generalGcpTransformOptions.postForward = gcpTransformOptions.postToGeo;
  }
  if (gcpTransformOptions.preToResource) {
    generalGcpTransformOptions.preBackward = gcpTransformOptions.preToResource;
  }
  return generalGcpTransformOptions;
}
function gcpTransformerOptionsToGeneralGcpTransformerOptions(gcpTransformerOptions) {
  if (gcpTransformerOptions === void 0) {
    return {};
  }
  const generalGcpTransformerOptions = gcpTransformOptionsToGeneralGcpTransformOptions(gcpTransformerOptions);
  return generalGcpTransformerOptions;
}
function generalGcpTransformOptionsToGcpTransformOptions(generalGcpTransformOptions) {
  if (generalGcpTransformOptions === void 0) {
    return {};
  }
  const gcpTransformOptions = generalGcpTransformOptions;
  if (generalGcpTransformOptions.destinationIsGeographic) {
    gcpTransformOptions.geoIsGeographic = generalGcpTransformOptions.destinationIsGeographic;
  }
  if (generalGcpTransformOptions.postForward) {
    gcpTransformOptions.postToGeo = generalGcpTransformOptions.postForward;
  }
  if (generalGcpTransformOptions.preBackward) {
    gcpTransformOptions.preToResource = generalGcpTransformOptions.preBackward;
  }
  return gcpTransformOptions;
}
function generalGcpTransformerOptionsToGcpTransformerOptions(generalGcpTransformerOptions) {
  if (generalGcpTransformerOptions == void 0) {
    return {};
  }
  const gcpTransformerOptions = generalGcpTransformerOptions;
  return gcpTransformerOptions;
}
var defaultGcpTransformOptions = generalGcpTransformOptionsToGcpTransformOptions(defaultGeneralGcpTransformOptions);
var defaultGcpTransformerOptions = generalGcpTransformerOptionsToGcpTransformerOptions(defaultGeneralGcpTransformerOptions);
function refinementOptionsFromForwardTransformOptions(generalGcpTransformOptions) {
  const refinementOptions = mergeOptions(defaultRefinementOptions, {
    minOffsetRatio: generalGcpTransformOptions.minOffsetRatio,
    minOffsetDistance: generalGcpTransformOptions.minOffsetDistance,
    minLineDistance: generalGcpTransformOptions.minLineDistance,
    maxDepth: generalGcpTransformOptions.maxDepth
  });
  if (generalGcpTransformOptions.sourceIsGeographic) {
    refinementOptions.sourceMidPointFunction = (point0, point1) => turf_midpoint_default(point0, point1).geometry.coordinates;
  }
  if (generalGcpTransformOptions.destinationIsGeographic) {
    refinementOptions.destinationMidPointFunction = (point0, point1) => turf_midpoint_default(point0, point1).geometry.coordinates;
    refinementOptions.destinationDistanceFunction = turf_distance_default;
  }
  return refinementOptions;
}
function refinementOptionsFromBackwardTransformOptions(generalGcpTransformOptions) {
  const refinementOptions = mergeOptions(defaultRefinementOptions, {
    minOffsetRatio: generalGcpTransformOptions.minOffsetRatio,
    minOffsetDistance: generalGcpTransformOptions.minOffsetDistance,
    minLineDistance: generalGcpTransformOptions.minLineDistance,
    maxDepth: generalGcpTransformOptions.maxDepth
  });
  if (generalGcpTransformOptions.destinationIsGeographic) {
    refinementOptions.sourceMidPointFunction = (point0, point1) => turf_midpoint_default(point0, point1).geometry.coordinates;
  }
  if (generalGcpTransformOptions.sourceIsGeographic) {
    refinementOptions.destinationMidPointFunction = (point0, point1) => turf_midpoint_default(point0, point1).geometry.coordinates;
    refinementOptions.destinationDistanceFunction = turf_distance_default;
  }
  return refinementOptions;
}

// node_modules/@allmaps/transform/dist/shared/conversion-functions.js
function invertGeneralGcp(generalGcp) {
  return { source: generalGcp.destination, destination: generalGcp.source };
}
function generalGcpToPointForForward(generalGcp) {
  return generalGcp.destination;
}
function generalGcpToPointForBackward(generalGcp) {
  return generalGcp.source;
}
function gcpToPointForToGeo(gcp) {
  return gcp.geo;
}
function gcpToPointForToResource(gcp) {
  return gcp.resource;
}
function generalGcpToGcp(generalGcp) {
  return {
    resource: generalGcp.source,
    geo: generalGcp.destination,
    partialDerivativeX: generalGcp.partialDerivativeX,
    partialDerivativeY: generalGcp.partialDerivativeY,
    distortions: generalGcp.distortions,
    distortion: generalGcp.distortion
  };
}
function gcpToGeneralGcp(gcp) {
  return {
    source: gcp.resource,
    destination: gcp.geo,
    partialDerivativeX: gcp.partialDerivativeX,
    partialDerivativeY: gcp.partialDerivativeY,
    distortions: gcp.distortions,
    distortion: gcp.distortion
  };
}

// node_modules/@allmaps/transform/dist/transformers/BaseGcpTransformer.js
var BaseGcpTransformer = class {
  generalGcpsInternal;
  sourcePointsInternal;
  destinationPointsInternal;
  type;
  transformerOptions;
  forwardTransformation;
  backwardTransformation;
  /**
   * Create a BaseGcpTransformer
   *
   * @param generalGcps - An array of General Ground Control Points (GCPs)
   * @param type - The transformation type
   * @param partialGeneralGcpTransformerOptions - General GCP Transformer options
   */
  constructor(generalGcps, type = "polynomial", partialGeneralGcpTransformerOptions) {
    this.transformerOptions = mergeOptions(defaultGeneralGcpTransformerOptions, partialGeneralGcpTransformerOptions);
    if (generalGcps.length === 0) {
      throw new Error("No control points");
    }
    this.generalGcpsInternal = generalGcps;
    this.sourcePointsInternal = this.generalGcpsInternal.map((generalGcp) => {
      const source = this.transformerOptions.differentHandedness ? flipY(generalGcp.source) : generalGcp.source;
      return this.transformerOptions.preForward(source);
    });
    this.destinationPointsInternal = this.generalGcpsInternal.map((generalGcp) => this.transformerOptions.preBackward(generalGcp.destination));
    this.type = type;
  }
  /**
   * Get the forward transformation. Create if it doesn't exist yet.
   */
  getForwardTransformationInternal() {
    if (!this.forwardTransformation) {
      this.forwardTransformation = this.createTransformation(this.sourcePointsInternal, this.destinationPointsInternal);
    }
    return this.forwardTransformation;
  }
  /**
   * Get the backward transformation. Create if it doesn't exist yet.
   */
  getBackwardTransformationInternal() {
    if (!this.backwardTransformation) {
      this.backwardTransformation = this.createTransformation(this.destinationPointsInternal, this.sourcePointsInternal);
    }
    return this.backwardTransformation;
  }
  /**
   * Create the (forward or backward) transformation.
   *
   * Results in forward transformation if source and destination points are entered as such.
   * Results in backward if source points are entered for destination points and vice versa.
   *
   * Results in a transformation of this instance's transformation type.
   *
   * @param sourcePoints - source points
   * @param destinationPoints - destination points
   * @returns Transformation
   */
  createTransformation(sourcePoints, destinationPoints) {
    if (this.type === "straight") {
      return new Straight(sourcePoints, destinationPoints);
    } else if (this.type === "helmert") {
      return new Helmert(sourcePoints, destinationPoints);
    } else if (this.type === "polynomial1" || this.type === "polynomial") {
      return new Polynomial1(sourcePoints, destinationPoints);
    } else if (this.type === "polynomial2") {
      return new Polynomial2(sourcePoints, destinationPoints);
    } else if (this.type === "polynomial3") {
      return new Polynomial3(sourcePoints, destinationPoints);
    } else if (this.type === "projective") {
      return new Projective(sourcePoints, destinationPoints);
    } else if (this.type === "thinPlateSpline") {
      return new RBF(sourcePoints, destinationPoints, thinPlateKernel, euclideanNorm, "thinPlateSpline");
    } else if (this.type === "linear") {
      return new RBF(sourcePoints, destinationPoints, linearKernel, euclideanNorm, "linear");
    } else {
      throw new Error(`Unsupported transformation type: ${this.type}`);
    }
  }
  /**
   * Get the resolution of the forward transformation in source space, within a given bbox.
   *
   * This informs you in how fine the warping is, in source space.
   * It can be useful e.g. to create a triangulation in source space
   * that is fine enough for this warping.
   *
   * It is obtained by transforming forward two linestring,
   * namely the horizontal and vertical midlines of the given bbox.
   * The forward transformation will refine these lines:
   * it will break them in small enough pieces to obtain a near continuous result.
   * Returned in the length of the shortest piece, measured in source coordinates.
   *
   * @param sourceBbox - BBox in source space where the resolution is requested
   * @param partialGeneralGcpTransformOptions - General GCP Transform options to consider during the transformation
   * @returns Resolution of the forward transformation in source space
   */
  getForwardTransformationResolutionInternal(sourceBbox, partialGeneralGcpTransformOptions) {
    const transformOptions = mergeOptions(this.transformerOptions, partialGeneralGcpTransformOptions);
    return getSourceRefinementResolution(sourceBbox, (p) => this.transformForwardInternal(p, transformOptions), refinementOptionsFromForwardTransformOptions(transformOptions));
  }
  /**
   * Get the resolution of the backward transformation in destination space, within a given bbox.
   *
   * This informs you in how fine the warping is, in destination space.
   * It can be useful e.g. to create a triangulation in destination space
   * that is fine enough for this warping.
   *
   * It is obtained by transforming backward two linestring,
   * namely the horizontal and vertical midlines of the given bbox.
   * The backward transformation will refine these lines:
   * it will break them in small enough pieces to obtain a near continuous result.
   * Returned in the length of the shortest piece, measured in destination coordinates.
   *
   * @param destinationBbox - BBox in destination space where the resolution is requested
   * @param partialGeneralGcpTransformOptions - General GCP Transform options to consider during the transformation
   * @returns Resolution of the backward transformation in destination space
   */
  getBackwardTransformationResolutionInternal(destinationBbox, partialGeneralGcpTransformOptions) {
    const transformOptions = mergeOptions(this.transformerOptions, partialGeneralGcpTransformOptions);
    return getSourceRefinementResolution(destinationBbox, (p) => this.transformBackwardInternal(p, transformOptions), refinementOptionsFromBackwardTransformOptions(transformOptions));
  }
  /**
   * Transform a geometry forward
   *
   * @param geometry - Geometry to transform
   * @param partialGeneralGcpTransformOptions - General GCP Transform options
   * @param generalGcpToP - Return type function
   * @returns Forward transform of input geometry
   */
  transformForwardInternal(geometry, partialGeneralGcpTransformOptions, generalGcpToP = generalGcpToPointForForward) {
    const transformOptions = mergeOptions(this.transformerOptions, partialGeneralGcpTransformOptions);
    if (!transformOptions.isMultiGeometry) {
      if (isPoint(geometry)) {
        return this.transformPointForwardInternal(geometry, transformOptions, generalGcpToP);
      } else if (isLineString(geometry)) {
        return this.transformLineStringForwardInternal(geometry, transformOptions, generalGcpToP);
      } else if (isPolygon(geometry)) {
        return this.transformPolygonForwardInternal(geometry, transformOptions, generalGcpToP);
      } else {
        throw new Error("Geometry type not supported");
      }
    } else {
      if (partialGeneralGcpTransformOptions) {
        partialGeneralGcpTransformOptions.isMultiGeometry = false;
      }
      if (isMultiPoint(geometry)) {
        return geometry.map((element) => this.transformForwardInternal(element, partialGeneralGcpTransformOptions, generalGcpToP));
      } else if (isMultiLineString(geometry)) {
        return geometry.map((element) => this.transformForwardInternal(element, partialGeneralGcpTransformOptions, generalGcpToP));
      } else if (isMultiPolygon(geometry)) {
        return geometry.map((element) => this.transformForwardInternal(element, partialGeneralGcpTransformOptions, generalGcpToP));
      } else {
        throw new Error("Geometry type not supported");
      }
    }
  }
  /**
   * Transform a geometry backward
   *
   * @param geometry - Geometry to transform
   * @param partialGeneralGcpTransformOptions - General GCP Transform options
   * @param generalGcpToP - Return type function
   * @returns Backward transform of input geometry
   */
  transformBackwardInternal(geometry, partialGeneralGcpTransformOptions, generalGcpToP = generalGcpToPointForBackward) {
    const transformOptions = mergeOptions(this.transformerOptions, partialGeneralGcpTransformOptions);
    if (!transformOptions.isMultiGeometry) {
      if (isPoint(geometry)) {
        return this.transformPointBackwardInternal(geometry, transformOptions, generalGcpToP);
      } else if (isLineString(geometry)) {
        return this.transformLineStringBackwardInternal(geometry, transformOptions, generalGcpToP);
      } else if (isPolygon(geometry)) {
        return this.transformPolygonBackwardInternal(geometry, transformOptions, generalGcpToP);
      } else {
        throw new Error("Geometry type not supported");
      }
    } else {
      if (partialGeneralGcpTransformOptions) {
        partialGeneralGcpTransformOptions.isMultiGeometry = false;
      }
      if (isMultiPoint(geometry)) {
        return geometry.map((element) => this.transformBackwardInternal(element, partialGeneralGcpTransformOptions, generalGcpToP));
      } else if (isMultiLineString(geometry)) {
        return geometry.map((element) => this.transformBackwardInternal(element, partialGeneralGcpTransformOptions, generalGcpToP));
      } else if (isMultiPolygon(geometry)) {
        return geometry.map((element) => this.transformBackwardInternal(element, partialGeneralGcpTransformOptions, generalGcpToP));
      } else {
        throw new Error("Geometry type not supported");
      }
    }
  }
  // Handle specific geometries
  transformPointForwardInternal(point2, generalGcpTransformOptions, generalGcpToP = generalGcpToPointForForward) {
    const forwardTransformation = this.getForwardTransformationInternal();
    let source = this.transformerOptions.differentHandedness ? flipY(point2) : point2;
    source = generalGcpTransformOptions.preForward(source);
    let destination2 = forwardTransformation.evaluateFunction(source);
    destination2 = generalGcpTransformOptions.postForward(destination2);
    let partialDerivativeX = void 0;
    let partialDerivativeY = void 0;
    let distortions = /* @__PURE__ */ new Map();
    if (generalGcpTransformOptions.distortionMeasures.length > 0) {
      partialDerivativeX = forwardTransformation.evaluatePartialDerivativeX(source);
      partialDerivativeY = forwardTransformation.evaluatePartialDerivativeY(source);
      distortions = computeDistortionsFromPartialDerivatives(generalGcpTransformOptions.distortionMeasures, partialDerivativeX, partialDerivativeY, generalGcpTransformOptions.referenceScale);
    }
    return generalGcpToP({
      source: point2,
      // don't apply differentHandedness here, this is only internally.
      destination: destination2,
      partialDerivativeX,
      partialDerivativeY,
      distortions
    });
  }
  transformPointBackwardInternal(point2, generalGcpTransformOptions, generalGcpToP = generalGcpToPointForBackward) {
    const backwardTransformation = this.getBackwardTransformationInternal();
    const destination2 = generalGcpTransformOptions.preBackward(point2);
    let source = backwardTransformation.evaluateFunction(destination2);
    source = generalGcpTransformOptions.postBackward(source);
    source = this.transformerOptions.differentHandedness ? flipY(source) : source;
    let partialDerivativeX = void 0;
    let partialDerivativeY = void 0;
    let distortions = /* @__PURE__ */ new Map();
    if (generalGcpTransformOptions.distortionMeasures.length > 0) {
      partialDerivativeX = backwardTransformation.evaluatePartialDerivativeX(destination2);
      partialDerivativeX = this.transformerOptions.differentHandedness ? flipY(partialDerivativeX) : partialDerivativeX;
      partialDerivativeY = backwardTransformation.evaluatePartialDerivativeY(destination2);
      partialDerivativeY = this.transformerOptions.differentHandedness ? flipY(partialDerivativeY) : partialDerivativeY;
      distortions = computeDistortionsFromPartialDerivatives(generalGcpTransformOptions.distortionMeasures, partialDerivativeX, partialDerivativeY, generalGcpTransformOptions.referenceScale);
    }
    return generalGcpToP({
      source,
      destination: destination2,
      partialDerivativeX,
      partialDerivativeY,
      distortions
    });
  }
  transformLineStringForwardInternal(lineString, generalGcpTransformOptions, generalGcpToP) {
    return refineLineString(lineString, (p) => this.transformPointForwardInternal(p, generalGcpTransformOptions), refinementOptionsFromForwardTransformOptions(generalGcpTransformOptions)).map((generalGcp) => generalGcpToP(generalGcp));
  }
  transformLineStringBackwardInternal(lineString, generalGcpTransformOptions, generalGcpToP) {
    return refineLineString(lineString, (p) => this.transformPointBackwardInternal(p, generalGcpTransformOptions), refinementOptionsFromBackwardTransformOptions(generalGcpTransformOptions)).map((generalGcp) => generalGcpToP(invertGeneralGcp(generalGcp)));
  }
  transformRingForwardInternal(ring, generalGcpTransformOptions, generalGcpToP) {
    return refineRing(ring, (p) => this.transformPointForwardInternal(p, generalGcpTransformOptions), refinementOptionsFromForwardTransformOptions(generalGcpTransformOptions)).map((generalGcp) => generalGcpToP(generalGcp));
  }
  transformRingBackwardInternal(ring, generalGcpTransformOptions, generalGcpToP) {
    return refineRing(ring, (p) => this.transformPointBackwardInternal(p, generalGcpTransformOptions), refinementOptionsFromBackwardTransformOptions(generalGcpTransformOptions)).map((generalGcp) => generalGcpToP(invertGeneralGcp(generalGcp)));
  }
  transformPolygonForwardInternal(polygon, generalGcpTransformOptions, generalGcpToP) {
    return polygon.map((ring) => {
      return this.transformRingForwardInternal(ring, generalGcpTransformOptions, generalGcpToP);
    });
  }
  transformPolygonBackwardInternal(polygon, generalGcpTransformOptions, generalGcpToP) {
    return polygon.map((ring) => {
      return this.transformRingBackwardInternal(ring, generalGcpTransformOptions, generalGcpToP);
    });
  }
};

// node_modules/@allmaps/transform/dist/transformers/GcpTransformer.js
var GcpTransformer = class _GcpTransformer extends BaseGcpTransformer {
  /**
   * Create a GcpTransformer
   *
   * @param gcps - An array of Ground Control Points (GCPs)
   * @param type - The transformation type
   * @param partialGcpTransformerOptions - GCP Transformer options
   */
  constructor(gcps, type = "polynomial", partialGcpTransformerOptions) {
    const generalGcps = gcps.map(gcpToGeneralGcp);
    partialGcpTransformerOptions = mergePartialOptions({ differentHandedness: true }, partialGcpTransformerOptions);
    super(generalGcps, type, gcpTransformerOptionsToGeneralGcpTransformerOptions(partialGcpTransformerOptions));
  }
  get gcps() {
    return this.generalGcpsInternal.map(generalGcpToGcp);
  }
  /**
   * Get the forward transformation. Create if it doesn't exist yet.
   */
  getToGeoTransformation() {
    return super.getForwardTransformationInternal();
  }
  /**
   * Get the backward transformation. Create if it doesn't exist yet.
   */
  getToResourceTransformation() {
    return super.getBackwardTransformationInternal();
  }
  /**
   * Get the resolution of the toGeo transformation in resource space, within a given bbox.
   *
   * This informs you in how fine the warping is, in resource space.
   * It can be useful e.g. to create a triangulation in resource space
   * that is fine enough for this warping.
   *
   * It is obtained by transforming toGeo two linestring,
   * namely the horizontal and vertical midlines of the given bbox.
   * The toGeo transformation will refine these lines:
   * it will break them in small enough pieces to obtain a near continuous result.
   * Returned in the length of the shortest piece, measured in resource coordinates.
   *
   * @param resourceBbox - BBox in resource space where the resolution is requested
   * @param partialGcpTransformOptions - GCP Transform options to consider during the transformation
   * @returns Resolution of the toGeo transformation in resource space
   */
  getToGeoTransformationResolution(resourceBbox, partialGcpTransformOptions) {
    const partialGeneralGcpTransformOptions = gcpTransformOptionsToGeneralGcpTransformOptions(partialGcpTransformOptions);
    return super.getForwardTransformationResolutionInternal(resourceBbox, partialGeneralGcpTransformOptions);
  }
  /**
   * Get the resolution of the toResource transformation in geo space, within a given bbox.
   *
   * This informs you in how fine the warping is, in geo space.
   * It can be useful e.g. to create a triangulation in geo space
   * that is fine enough for this warping.
   *
   * It is obtained by transforming toResource two linestring,
   * namely the horizontal and vertical midlines of the given bbox.
   * The toResource transformation will refine these lines:
   * it will break them in small enough pieces to obtain a near continuous result.
   * Returned in the length of the shortest piece, measured in geo coordinates.
   *
   * @param geoBbox - BBox in geo space where the resolution is requested
   * @param partialGcpTransformOptions - GCP Transform options to consider during the transformation
   * @returns Resolution of the toResource transformation in geo space
   */
  getToResourceTransformationResolution(geoBbox, partialGcpTransformOptions) {
    const generalGcpTransformOptions = gcpTransformOptionsToGeneralGcpTransformOptions(partialGcpTransformOptions);
    return super.getBackwardTransformationResolutionInternal(geoBbox, generalGcpTransformOptions);
  }
  /**
   * Get the transformer options.
   */
  getTransformerOptions() {
    return this.transformerOptions;
  }
  /**
   * Set the transformer options.
   *
   * Use with caution, especially for options that have effects in the constructor.
   */
  setTransformerOptionsInternal(partialGcpTransformerOptions) {
    this.transformerOptions = mergeOptions(this.transformerOptions, gcpTransformerOptionsToGeneralGcpTransformerOptions(partialGcpTransformerOptions));
  }
  /**
   * Transform a geometry to geo space
   *
   * @param geometry - Geometry to transform
   * @param partialGcpTransformOptions - GCP Transform options
   * @param gcpToP - Return type function
   * @returns Input geometry transformed to geo space
   */
  transformToGeo(geometry, partialGcpTransformOptions, gcpToP = gcpToPointForToGeo) {
    const generalGcpToP = (generalGcp) => gcpToP(generalGcpToGcp(generalGcp));
    const partialGeneralGcpTransformOptions = partialGcpTransformOptions ? gcpTransformOptionsToGeneralGcpTransformOptions(partialGcpTransformOptions) : void 0;
    return super.transformForwardInternal(geometry, partialGeneralGcpTransformOptions, generalGcpToP);
  }
  /**
   * Transform a geometry to resource space
   *
   * @param geometry - Geometry to transform
   * @param partialGcpTransformOptions - GCP Transform options
   * @param gcpToP - Return type function
   * @returns Input geometry transformed to resource space
   */
  transformToResource(geometry, partialGcpTransformOptions, gcpToP = gcpToPointForToResource) {
    const generalGcpToP = (generalGcp) => gcpToP(generalGcpToGcp(generalGcp));
    const partialGeneralGcpTransformOptions = partialGcpTransformOptions ? gcpTransformOptionsToGeneralGcpTransformOptions(partialGcpTransformOptions) : void 0;
    return super.transformBackwardInternal(geometry, partialGeneralGcpTransformOptions, generalGcpToP);
  }
  /**
   * Transform an SVG geometry to geo space as a GeoJSON Geometry
   *
   * This is a shortcut method, available as static method in order not to overpopulate intellisense suggestions
   * Note: since this converts to GeoJSON we assume geo-space is in lon-lat WGS84 and automatically set `destinationIsGeographic` to use geographically computed midpoints.
   * Note: Multi-geometries are not supported
   *
   * @param transformer - A GCP Transformer defining the transformation
   * @param geometry - SVG geometry to transform
   * @param partialGcpTransformOptions - GCP Transform options
   * @returns Input SVG geometry transformed to geo space, as a GeoJSON Geometry
   */
  static transformSvgToGeojson(transformer2, svgGeometry, partialGcpTransformOptions) {
    partialGcpTransformOptions = mergePartialOptions({ geoIsGeographic: true }, partialGcpTransformOptions);
    const transformedGeometry = transformer2.transformToGeo(svgGeometryToGeometry(svgGeometry), partialGcpTransformOptions);
    return geometryToGeojsonGeometry(transformedGeometry);
  }
  /**
   * Transform an SVG string to geo space to a GeoJSON FeatureCollection
   *
   * This is a shortcut method, available as static method in order not to overpopulate intellisense suggestions
   * Note: since this converts to GeoJSON we assume geo-space is in lon-lat WGS84 and automatically set `destinationIsGeographic` to use geographically computed midpoints.
   * Note: Multi-geometries are not supported
   *
   * @param transformer - A GCP Transformer defining the transformation
   * @param svg - An SVG string to transform
   * @param partialGcpTransformOptions - GCP Transform options
   * @returns Input SVG string transformed to geo space, as a GeoJSON FeatureCollection
   */
  static transformSvgStringToGeojsonFeatureCollection(transformer2, svg2, partialGcpTransformOptions) {
    const geojsonGeometries = [];
    for (const svgGeometry of stringToSvgGeometriesGenerator(svg2)) {
      const geojsonGeometry = this.transformSvgToGeojson(transformer2, svgGeometry, partialGcpTransformOptions);
      geojsonGeometries.push(geojsonGeometry);
    }
    return geojsonGeometriesToGeojsonFeatureCollection(geojsonGeometries);
  }
  /**
   * Transform a GeoJSON Geometry to resource space to a SVG geometry
   *
   * This is a shortcut method, available as static method in order not to overpopulate intellisense suggestions
   * Note: since this converts from GeoJSON we assume geo-space is in lon-lat WGS84 and automatically set `destinationIsGeographic` to use geographically computed midpoints.
   * Note: Multi-geometries are not supported
   *
   * @param transformer - A GCP Transformer defining the transformation
   * @param geojsonGeometry - GeoJSON Geometry to transform
   * @param partialGcpTransformOptions - GCP Transform options
   * @returns Input GeoJSON Geometry transform to resource space, as SVG geometry
   */
  static transformGeojsonToSvg(transformer2, geojsonGeometry, partialGcpTransformOptions) {
    partialGcpTransformOptions = mergePartialOptions({ geoIsGeographic: true }, partialGcpTransformOptions);
    const transformedGeometry = transformer2.transformToResource(geojsonGeometryToGeometry(geojsonGeometry), partialGcpTransformOptions);
    return geometryToSvgGeometry(transformedGeometry);
  }
  /**
   * Transform a GeoJSON FeatureCollection to resource space to a SVG string
   *
   * This is a shortcut method, available as static method in order not to overpopulate intellisense suggestions
   * Note: since this converts from GeoJSON we assume geo-space is in lon-lat WGS84 and automatically set `destinationIsGeographic` to use geographically computed midpoints.
   * Note: Multi-geometries are not supported
   *
   * @param transformer - A GCP Transformer defining the transformation
   * @param geojson - GeoJSON FeatureCollection to transform
   * @param partialGcpTransformOptions - GCP Transform options
   * @returns Input GeoJSON FeaturesCollection transformed to resource space, as SVG string
   */
  static transformGeojsonFeatureCollectionToSvgString(transformer2, geojson, partialGcpTransformOptions) {
    const svgGeometries = [];
    for (const geojsonGeometry of geojsonFeatureCollectionToGeojsonGeometries(geojson)) {
      const svgGeometry = this.transformGeojsonToSvg(transformer2, geojsonGeometry, partialGcpTransformOptions);
      svgGeometries.push(svgGeometry);
    }
    return svgGeometriesToSvgString(svgGeometries);
  }
  /**
   * Create a Projected GCP Transformer from a Georeferenced Map
   *
   * @param georeferencedMap - A Georeferenced Map
   * @param options - Options, including GCP Transformer Options, and a transformation type to overrule the type defined in the Georeferenced Map
   * @returns A Projected GCP Transformer
   */
  static fromGeoreferencedMap(georeferencedMap, options) {
    return new _GcpTransformer(georeferencedMap.gcps, options?.transformationType || georeferencedMap.transformation?.type, options);
  }
};

// node_modules/@allmaps/tailwind/dist/colors.js
var black = "#222222";
var white = "#ffffff";
var inherit = "inherit";
var current = "currentColor";
var transparent = "transparent";
var originalColorIndex = 4;
var blueShades = [
  "#dff7fa",
  "#c0eff5",
  "#a1e7f0",
  "#82dfeb",
  "#63d8e6",
  // Original color
  "#4facb8",
  "#3b818a",
  "#27565c",
  "#132b2d"
];
var darkblueShades = [
  "#d7d9ee",
  "#b0b4de",
  "#898ecd",
  "#6269bd",
  "#3b44ad",
  // Original color
  "#2f368a",
  "#232867",
  "#171b45",
  "#0b0d22"
];
var purpleShades = [
  "#f3dcf0",
  "#e7b9e1",
  "#dc97d2",
  "#d074c3",
  "#c552b5",
  // Original color
  "#9d4190",
  "#76316c",
  "#4e2048",
  "#271024"
];
var pinkShades = [
  "#ffddf1",
  "#ffbbe3",
  "#ff99d5",
  "#ff77c7",
  "#ff56ba",
  // Original color
  "#cc4494",
  "#99336f",
  "#66224a",
  "#321125"
];
var orangeShades = [
  "#ffe3d0",
  "#ffc7a1",
  "#ffab72",
  "#ff8f43",
  "#ff7415",
  // Original color
  "#cc5c10",
  "#99450c",
  "#662e08",
  "#321704"
];
var redShades = [
  "#fededf",
  "#febebf",
  "#fe9e9f",
  "#fe7e7f",
  "#fe5e60",
  // Original color
  "#cb4b4c",
  "#983839",
  "#652526",
  "#321213"
];
var greenShades = [
  "#e0f2e8",
  "#c1e6d2",
  "#a2d9bb",
  "#83cda5",
  "#64c18f",
  // Original color
  "#509a72",
  "#3c7355",
  "#284d39",
  "#13261c"
];
var yellowShades = [
  "#fff3d9",
  "#ffe8b3",
  "#ffdd8d",
  "#ffd267",
  "#ffc742",
  // Original color
  "#cc9f34",
  "#997727",
  "#664f1a",
  "#32270d"
];
var grayShades = [
  "#efefef",
  "#e0e0e0",
  "#d0d0d0",
  "#c1c1c1",
  "#b2b2b2",
  "#8e8e8e",
  "#6a6a6a",
  "#474747",
  "#232323"
];
var shades = {
  blue: blueShades,
  darkblue: darkblueShades,
  purple: purpleShades,
  pink: pinkShades,
  orange: orangeShades,
  red: redShades,
  green: greenShades,
  yellow: yellowShades,
  gray: grayShades
};
var blue = blueShades[originalColorIndex];
var darkblue = darkblueShades[originalColorIndex];
var purple = purpleShades[originalColorIndex];
var pink = pinkShades[originalColorIndex];
var orange = orangeShades[originalColorIndex];
var red = redShades[originalColorIndex];
var green = greenShades[originalColorIndex];
var yellow = yellowShades[originalColorIndex];
var gray = grayShades[originalColorIndex];

// node_modules/@allmaps/tailwind/dist/theme-colors.js
function flattenShades(color, shades2) {
  return shades2.reduce((flattened, hex, index) => {
    const shade = (index + 1) * 100;
    const key = `${color}-${shade}`;
    flattened[key] = hex;
    return flattened;
  }, {});
}
var themeColors = {
  blue,
  darkblue,
  purple,
  pink,
  orange,
  red,
  green,
  yellow,
  gray,
  black,
  white,
  inherit,
  current,
  transparent,
  // Add shades
  ...flattenShades("blue", shades.blue),
  ...flattenShades("darkblue", shades.darkblue),
  ...flattenShades("purple", shades.purple),
  ...flattenShades("pink", shades.pink),
  ...flattenShades("orange", shades.orange),
  ...flattenShades("red", shades.red),
  ...flattenShades("green", shades.green),
  ...flattenShades("yellow", shades.yellow),
  ...flattenShades("gray", shades.gray)
};

// node_modules/@allmaps/tailwind/dist/theme.js
var theme = {
  extend: {
    textColor: {
      DEFAULT: themeColors.black
    },
    transitionDuration: {
      0: "0ms"
    }
  },
  colors: themeColors,
  fontFamily: {
    sans: ["Geograph", "sans-serif"],
    // Consider using https://tosche.net/fonts/codelia
    mono: ["DM Mono", "monospace"]
  }
};

// node_modules/@allmaps/render/dist/shared/events.js
var WarpedMapEventType = ((WarpedMapEventType2) => {
  WarpedMapEventType2["GEOREFERENCEANNOTATIONADDED"] = "georeferenceannotationadded";
  WarpedMapEventType2["GEOREFERENCEANNOTATIONREMOVED"] = "georeferenceannotationremoved";
  WarpedMapEventType2["WARPEDMAPADDED"] = "warpedmapadded";
  WarpedMapEventType2["WARPEDMAPREMOVED"] = "warpedmapremoved";
  WarpedMapEventType2["WARPEDMAPENTER"] = "warpedmapenter";
  WarpedMapEventType2["WARPEDMAPLEAVE"] = "warpedmapleave";
  WarpedMapEventType2["IMAGEINFOLOADED"] = "imageinfoloaded";
  WarpedMapEventType2["TILEFETCHED"] = "tilefetched";
  WarpedMapEventType2["TILEFETCHERROR"] = "tilefetcherror";
  WarpedMapEventType2["MAPTILELOADED"] = "maptileloaded";
  WarpedMapEventType2["MAPTILEREMOVED"] = "maptileremoved";
  WarpedMapEventType2["FIRSTMAPTILELOADED"] = "firstmaptileloaded";
  WarpedMapEventType2["ALLREQUESTEDTILESLOADED"] = "allrequestedtilesloaded";
  WarpedMapEventType2["TEXTURESUPDATED"] = "texturesupdated";
  WarpedMapEventType2["PRECHANGE"] = "prechange";
  WarpedMapEventType2["OPTIONSCHANGED"] = "optionschanged";
  WarpedMapEventType2["ZINDICESCHANGED"] = "zindiceschanged";
  WarpedMapEventType2["RESOURCEMASKCHANGED"] = "resourcemaskchanged";
  WarpedMapEventType2["GCPSCHANGED"] = "gcpschanged";
  WarpedMapEventType2["VISIBILITYCHANGED"] = "visibilitychanged";
  WarpedMapEventType2["TRANSFORMATIONCHANGED"] = "transformationchanged";
  WarpedMapEventType2["DISTORTIONCHANGED"] = "distortionchanged";
  WarpedMapEventType2["INTERNALPROJECTIONCHANGED"] = "internalprojectionchanged";
  WarpedMapEventType2["PROJECTIONCHANGED"] = "projectionchanged";
  WarpedMapEventType2["CHANGED"] = "changed";
  WarpedMapEventType2["CLEARED"] = "cleared";
  return WarpedMapEventType2;
})(WarpedMapEventType || {});
var WarpedMapEvent = class extends Event {
  data;
  constructor(type, data) {
    super(type);
    this.data = data;
  }
};

// node_modules/@allmaps/render/dist/shared/tiles.js
function getTileZoomLevelForScale(tileZoomLevels, resourceToCanvasScale, scaleFactorCorrection, log2scaleFactorCorrection) {
  let smallestdiffLogScaleFactor = Number.POSITIVE_INFINITY;
  let bestTileZoomLevel = tileZoomLevels.at(-1);
  for (const tileZoomLevel of tileZoomLevels) {
    const diffLogScaleFactor = Math.abs(
      Math.log2(tileZoomLevel.scaleFactor) - (Math.log2(resourceToCanvasScale + scaleFactorCorrection) + log2scaleFactorCorrection)
    );
    if (diffLogScaleFactor < smallestdiffLogScaleFactor) {
      smallestdiffLogScaleFactor = diffLogScaleFactor;
      bestTileZoomLevel = tileZoomLevel;
    }
  }
  return bestTileZoomLevel;
}
function computeTilesCoveringRingAtTileZoomLevel(resourceRing, tileZoomLevel, imageSize) {
  const scaledResourceRing = scaleResourcePoints(resourceRing, tileZoomLevel);
  const tilesByColumn = ringToTilesByColumn(scaledResourceRing);
  const tiles = tilesByColumnToTiles(tilesByColumn, tileZoomLevel, imageSize);
  return tiles;
}
function scaleResourcePoints(resourcePoints, tileZoomLevel) {
  return resourcePoints.map((point2) => [
    point2[0] / tileZoomLevel.originalWidth,
    point2[1] / tileZoomLevel.originalHeight
  ]);
}
function ringToTilesByColumn(ring) {
  const tilesByColumn = {};
  for (let i = 0; i < ring.length; i++) {
    const line = [ring[i], ring[(i + 1) % ring.length]];
    const pixels = lineToPixels(line);
    pixels.forEach(([x, y]) => {
      if (!tilesByColumn[x]) {
        tilesByColumn[x] = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
      }
      if (y < tilesByColumn[x][0]) {
        tilesByColumn[x][0] = y;
      }
      if (y > tilesByColumn[x][1]) {
        tilesByColumn[x][1] = y;
      }
    });
  }
  return tilesByColumn;
}
function lineToPixels([startPoint, endPoint]) {
  let startPixelX = Math.floor(startPoint[0]);
  let startPixelY = Math.floor(startPoint[1]);
  const endPixelX = Math.floor(endPoint[0]);
  const endPixelY = Math.floor(endPoint[1]);
  const points = [[startPixelX, startPixelY]];
  if (startPixelX === endPixelX && startPixelY === endPixelY) {
    return points;
  }
  const stepX = Math.sign(endPoint[0] - startPoint[0]);
  const stepY = Math.sign(endPoint[1] - startPoint[1]);
  const restX = Math.abs(startPoint[0] - startPixelX - Math.max(0, stepX));
  const restY = Math.abs(startPoint[1] - startPixelY - Math.max(0, stepY));
  const distanceX = Math.abs(startPoint[0] - endPoint[0]);
  const distanceY = Math.abs(startPoint[1] - endPoint[1]);
  let restPerStepX = restX / distanceX;
  let restPerStepY = restY / distanceY;
  const onePerStepX = 1 / distanceX;
  const onePerStepY = 1 / distanceY;
  while (!(startPixelX === endPixelX && startPixelY === endPixelY)) {
    if (distanceY === 0) {
      startPixelX = startPixelX + stepX;
    } else if (distanceX === 0) {
      startPixelY = startPixelY + stepY;
    } else if (restPerStepX < restPerStepY) {
      restPerStepX = restPerStepX + onePerStepX;
      startPixelX = startPixelX + stepX;
    } else {
      restPerStepY = restPerStepY + onePerStepY;
      startPixelY = startPixelY + stepY;
    }
    points.push([startPixelX, startPixelY]);
  }
  return points;
}
function tilesByColumnToTiles(tilesByColumn, tileZoomLevel, imageSize) {
  const tiles = [];
  for (const xKey in tilesByColumn) {
    const x = parseInt(xKey);
    if (x < 0 || x >= tileZoomLevel.columns) {
      break;
    }
    const fromY = Math.max(tilesByColumn[x][0], 0);
    const toY = Math.min(tilesByColumn[x][1], tileZoomLevel.rows - 1);
    for (let y = fromY; y <= toY; y++) {
      tiles.push({
        column: x,
        row: y,
        tileZoomLevel,
        imageSize
      });
    }
  }
  return tiles;
}
function getTilesCoveringTileAtScaleFactor(tile, parsedImage, scaleFactor, validTile) {
  let columnStart = Math.floor(
    tile.column * tile.tileZoomLevel.scaleFactor / scaleFactor
  );
  columnStart = columnStart >= 0 ? columnStart : 0;
  const columnEnd = Math.ceil(
    (tile.column + 1) * tile.tileZoomLevel.scaleFactor / scaleFactor
  );
  let rowStart = Math.floor(
    tile.row * tile.tileZoomLevel.scaleFactor / scaleFactor
  );
  rowStart = rowStart >= 0 ? rowStart : 0;
  const rowEnd = Math.ceil(
    (tile.row + 1) * tile.tileZoomLevel.scaleFactor / scaleFactor
  );
  return getTilesAtScaleFactor(
    scaleFactor,
    parsedImage,
    columnStart,
    columnEnd,
    rowStart,
    rowEnd,
    validTile
  );
}
function getTilesAtScaleFactor(scaleFactor, parsedImage, columnStart, columnEnd, rowStart, rowEnd, validTile = (_tile) => true) {
  const tileZoomLevel = parsedImage.tileZoomLevels.find(
    (tileZoomLevel2) => tileZoomLevel2.scaleFactor === scaleFactor
  );
  const imageSize = [parsedImage.width, parsedImage.height];
  if (!tileZoomLevel) {
    return [];
  }
  columnStart = columnStart ? columnStart : 0;
  columnEnd = columnEnd ? columnEnd : tileZoomLevel.columns;
  rowStart = rowStart ? rowStart : 0;
  rowEnd = rowEnd ? rowEnd : tileZoomLevel.rows;
  const tiles = [];
  for (let column = columnStart; column < columnEnd; column++) {
    for (let row = rowStart; row < rowEnd; row++) {
      const tile = {
        column,
        row,
        tileZoomLevel,
        imageSize
      };
      if (validTile(tile)) {
        tiles.push(tile);
      }
    }
  }
  return tiles;
}
function squaredDistanceTileToPoint(tile, point2) {
  return squaredDistance(tileCenter(tile), point2);
}
function tileCenter(tile) {
  const bbox = computeBboxTile(tile);
  return [(bbox[2] - bbox[0]) / 2 + bbox[0], (bbox[3] - bbox[1]) / 2 + bbox[1]];
}
function tileToTileOriginPoint(tile) {
  return [
    tile.column * tile.tileZoomLevel.originalWidth,
    tile.row * tile.tileZoomLevel.originalHeight
  ];
}
function computeBboxTile(tile) {
  const resourceTileOriginPoint = tileToTileOriginPoint(tile);
  const resourceTileMaxX = Math.min(
    resourceTileOriginPoint[0] + tile.tileZoomLevel.originalWidth,
    tile.imageSize[0]
  );
  const resourceTileMaxY = Math.min(
    resourceTileOriginPoint[1] + tile.tileZoomLevel.originalHeight,
    tile.imageSize[1]
  );
  return [
    resourceTileOriginPoint[0],
    resourceTileOriginPoint[1],
    resourceTileMaxX,
    resourceTileMaxY
  ];
}
function getTileSize(tile) {
  return [tile.tileZoomLevel.width, tile.tileZoomLevel.height];
}
function getTileResolution(tile) {
  return sizeToResolution(getTileSize(tile));
}
function getTilesResolution(tiles) {
  return tiles.map((tile) => getTileResolution(tile)).reduce((a, c) => a + c, 0);
}
function getTileZoomLevelResolution(tileZoomLevel) {
  return tileZoomLevel.rows * tileZoomLevel.width * tileZoomLevel.columns * tileZoomLevel.height;
}
function getTilesAtOtherScaleFactors(tile, parsedImage, scaleFactor, TEXTURES_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF2, TEXTURES_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF2, validTile) {
  const tilesAtOtherScaleFactors = [];
  const tilesAtLowerScaleFactor = recursivelyGetTilesAtLowerScaleFactor(
    tile,
    parsedImage,
    scaleFactor,
    TEXTURES_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF2,
    validTile
  );
  for (const tileAtLowerScaleFactor of tilesAtLowerScaleFactor) {
    if (tileAtLowerScaleFactor) {
      tilesAtOtherScaleFactors.push(tileAtLowerScaleFactor);
    }
  }
  if (tilesAtOtherScaleFactors.length === 0) {
    const tileAtHigherScaleFactor = recursivelyGetTilesAtHigherScaleFactor(
      tile,
      parsedImage,
      scaleFactor,
      TEXTURES_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF2,
      validTile
    );
    if (tileAtHigherScaleFactor) {
      tilesAtOtherScaleFactors.push(tileAtHigherScaleFactor);
    }
  }
  return tilesAtOtherScaleFactors;
}
function recursivelyGetTilesAtHigherScaleFactor(tile, parsedImage, scaleFactor, log2ScaleFactorDiff, validTile) {
  const higherScaleFactor = 2 ** (Math.log2(scaleFactor) + 1);
  if (higherScaleFactor > parsedImage.tileZoomLevels.map((tileZoomLevel) => tileZoomLevel.scaleFactor).reduce((a, c) => a + c, 0) - scaleFactor || log2ScaleFactorDiff === 0) {
    return void 0;
  }
  const tileAtHigherScaleFactor = getTileAtHigherScaleFactor(
    tile,
    parsedImage,
    higherScaleFactor,
    validTile
  );
  if (tileAtHigherScaleFactor !== void 0) {
    return tileAtHigherScaleFactor;
  } else {
    return recursivelyGetTilesAtHigherScaleFactor(
      tile,
      parsedImage,
      higherScaleFactor,
      log2ScaleFactorDiff--,
      validTile
    );
  }
}
function recursivelyGetTilesAtLowerScaleFactor(tile, parsedImage, scaleFactor, log2ScaleFactorDiff, validTile) {
  const lowerScaleFactor = 2 ** (Math.log2(scaleFactor) - 1);
  if (lowerScaleFactor <= 0 || log2ScaleFactorDiff === 0) {
    return [];
  }
  const tilesAtLowerScaleFactor = getTilesAtLowerScaleFactor(
    tile,
    parsedImage,
    lowerScaleFactor,
    validTile
  );
  const allTilesAtLowerScaleFactor = getTilesAtLowerScaleFactor(
    tile,
    parsedImage,
    lowerScaleFactor,
    (_tile) => true
  );
  if (tilesAtLowerScaleFactor.length === allTilesAtLowerScaleFactor.length) {
    return tilesAtLowerScaleFactor;
  } else {
    return [
      ...tilesAtLowerScaleFactor,
      ...recursivelyGetTilesAtLowerScaleFactor(
        tile,
        parsedImage,
        lowerScaleFactor,
        log2ScaleFactorDiff--,
        validTile
      )
    ];
  }
}
function getTileAtHigherScaleFactor(tile, parsedImage, higherScaleFactor, validTile) {
  const tilesCoveringTileAtHigherScaleFactor = getTilesCoveringTileAtScaleFactor(
    tile,
    parsedImage,
    higherScaleFactor,
    validTile
  );
  if (tilesCoveringTileAtHigherScaleFactor.length === 0) {
    return void 0;
  }
  return tilesCoveringTileAtHigherScaleFactor[0];
}
function getTilesAtLowerScaleFactor(tile, parsedImage, lowerScaleFactor, validTile) {
  const tilesCoveringTileAtLowerScaleFactor = getTilesCoveringTileAtScaleFactor(
    tile,
    parsedImage,
    lowerScaleFactor,
    validTile
  );
  return tilesCoveringTileAtLowerScaleFactor;
}
function fetchableTileKey(fetchableTile) {
  return keyFromMapIdTileUrl(fetchableTile.mapId, fetchableTile.tileUrl);
}
function keyFromMapIdTileUrl(mapId, tileUrl2) {
  return `${mapId}:${tileUrl2}`;
}
function tileKey(tile) {
  return keyFromScaleFactorRowColumn(
    tile.tileZoomLevel.scaleFactor,
    tile.row,
    tile.column
  );
}
function keyFromScaleFactorRowColumn(scaleFactor, row, column) {
  return `${scaleFactor}:${row}:${column}`;
}
function shouldPruneTile(tile, mapPruneInfo, mapPruneConstants) {
  if (mapPruneInfo.overviewTileZoomLevelForViewport && tile.tileZoomLevel.scaleFactor == mapPruneInfo.overviewTileZoomLevelForViewport.scaleFactor) {
    return false;
  }
  if (mapPruneInfo.resourceViewportRingBboxForViewport === void 0 || mapPruneInfo.tileZoomLevelForViewport === void 0) {
    return true;
  }
  const log2ScaleFactorDiff = Math.log2(tile.tileZoomLevel.scaleFactor) - Math.log2(mapPruneInfo.tileZoomLevelForViewport.scaleFactor);
  const tileScaleFactorTooHigh = log2ScaleFactorDiff > mapPruneConstants.maxHigherLog2ScaleFactorDiff;
  if (tileScaleFactorTooHigh) {
    return true;
  }
  const tileScaleFactorTooLow = -log2ScaleFactorDiff > mapPruneConstants.maxLowerLog2ScaleFactorDiff;
  if (tileScaleFactorTooLow) {
    return true;
  }
  if (!doBboxesIntersect(
    bufferBboxByRatio(
      computeBboxTile(tile),
      Math.max(0, log2ScaleFactorDiff)
    ),
    mapPruneInfo.resourceViewportRingBboxForViewport
  )) {
    return true;
  }
  return false;
}

// node_modules/@allmaps/render/dist/tilecache/TileCache.js
var PRUNE_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF = 4;
var PRUNE_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF = 2;
var TileCache = class extends EventTarget {
  cachableTileFactory;
  fetchFn;
  tilesByTileUrl = /* @__PURE__ */ new Map();
  mapIdsByTileUrl = /* @__PURE__ */ new Map();
  tileUrlsByMapId = /* @__PURE__ */ new Map();
  tilesFetchingCount = 0;
  fetchableTiles = [];
  constructor(cachableTileFactory, partialTileCacheOptions) {
    super();
    this.setOptions(partialTileCacheOptions);
    this.cachableTileFactory = cachableTileFactory;
  }
  /**
   * Get the tiles in this cache
   *
   * @returns
   */
  getCacheableTiles() {
    return this.tilesByTileUrl.values();
  }
  /**
   * Get a specific tile in this cache
   *
   * @param tileUrl - the URL of the requested tile
   * @returns
   */
  getCacheableTile(tileUrl) {
    return this.tilesByTileUrl.get(tileUrl);
  }
  /**
   * Get the tiles in this cache, corresponding to a specific map
   *
   * @param mapId - ID of the map
   * @returns
   */
  getMapCacheableTiles(mapId) {
    const cacheableTiles = [];
    for (const cacheableTile of this.tilesByTileUrl.values()) {
      if (this.tileUrlsByMapId.get(mapId)?.has(cacheableTile.tileUrl)) {
        cacheableTiles.push(cacheableTile);
      }
    }
    return cacheableTiles;
  }
  /**
   * Get the tiles in this cache that have been fetched
   *
   * @returns
   */
  getCachedTiles() {
    const cachedTiles = [];
    for (const cacheableTile of this.tilesByTileUrl.values()) {
      if (cacheableTile.isCachedTile()) {
        cachedTiles.push(cacheableTile);
      }
    }
    return cachedTiles;
  }
  /**
   * Get a specific cached tile in this cache that has been fetched
   *
   * @param tileUrl - the URL of the requested tile
   * @returns
   */
  getCachedTile(tileUrl) {
    const cacheableTile = this.tilesByTileUrl.get(tileUrl);
    if (cacheableTile && cacheableTile.isCachedTile()) {
      return cacheableTile;
    }
  }
  /**
   * Get the tiles in this cache, corresponding to a specific map, that have been fetched
   *
   * @param mapId - ID of the map
   * @returns
   */
  getMapCachedTiles(mapId) {
    const cachedTiles = [];
    for (const cacheableTile of this.tilesByTileUrl.values()) {
      if (cacheableTile.isCachedTile() && this.tileUrlsByMapId.get(mapId)?.has(cacheableTile.tileUrl)) {
        cachedTiles.push(cacheableTile);
      }
    }
    return cachedTiles;
  }
  /**
   * Get the URLs of tiles in this cache
   *
   * @returns
   */
  getTileUrls() {
    return this.tilesByTileUrl.keys();
  }
  /**
   * Get the URLs of tiles in this cache, corresponding to a specific map
   *
   * @param mapId - ID of the map
   * @returns
   */
  getMapTileUrls(mapId) {
    return this.tileUrlsByMapId.get(mapId) || /* @__PURE__ */ new Set();
  }
  /**
   * Get the Tile Cache options
   *
   * @param partialTileCacheOptions - Options
   */
  setOptions(partialTileCacheOptions) {
    this.fetchFn = partialTileCacheOptions?.fetchFn;
  }
  // TODO: this function needs a new name!
  /**
   * Process the request for new tiles to be added to this cache
   *
   * @param fetchableTiles
   */
  requestFetchableTiles(fetchableTiles) {
    const previousKeys = new Set(
      this.fetchableTiles.map((fetchableTile) => fetchableTile.fetchableTileKey)
    );
    const keys2 = new Set(
      fetchableTiles.map((fetchableTile) => fetchableTile.fetchableTileKey)
    );
    if (equalSet(previousKeys, keys2)) {
      return;
    }
    for (const fetchableTile of fetchableTiles) {
      this.requestFetchableTile(fetchableTile);
    }
    this.fetchableTiles = fetchableTiles;
  }
  /**
   * Returns a promise that resolves when all requested tiles are loaded.
   * This could happen immidiately, in case there are no ongoing requests and the tilesFetchingCount is zero,
   * or in a while, when the count reaches zero and the ALLREQUESTEDTILESLOADED event is fired.
   */
  async allRequestedTilesLoaded() {
    return new Promise((resolve) => {
      if (this.finished) {
        resolve();
      } else {
        const listener = () => {
          this.removeEventListener(
            WarpedMapEventType.ALLREQUESTEDTILESLOADED,
            listener
          );
          resolve();
        };
        this.addEventListener(
          WarpedMapEventType.ALLREQUESTEDTILESLOADED,
          listener
        );
      }
    });
  }
  /**
   * Prune tiles in this cache using the provided prune info
   */
  prune(pruneInfoByMapId) {
    for (const [tileUrl, mapIds] of this.mapIdsByTileUrl.entries()) {
      for (const mapId of mapIds) {
        const pruneInfo = pruneInfoByMapId.get(mapId);
        const tile = this.tilesByTileUrl.get(tileUrl)?.tile;
        if (tile) {
          if (!pruneInfo || shouldPruneTile(tile, pruneInfo, {
            maxHigherLog2ScaleFactorDiff: PRUNE_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF,
            maxLowerLog2ScaleFactorDiff: PRUNE_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF
          })) {
            this.removeCacheableTileForMapId(tileUrl, mapId);
          }
        }
      }
    }
  }
  clear() {
    for (const cacheableTile of this.getCacheableTiles()) {
      cacheableTile.abort();
      this.removeEventListenersFromCacheableTile(cacheableTile);
    }
    this.tilesByTileUrl = /* @__PURE__ */ new Map();
    this.mapIdsByTileUrl = /* @__PURE__ */ new Map();
    this.tileUrlsByMapId = /* @__PURE__ */ new Map();
    this.tilesFetchingCount = 0;
  }
  destroy() {
    this.clear();
  }
  requestFetchableTile(fetchableTile) {
    const mapId = fetchableTile.mapId;
    const tileUrl = fetchableTile.tileUrl;
    if (!this.tilesByTileUrl.has(tileUrl)) {
      const cacheableTile = this.cachableTileFactory(
        fetchableTile,
        this.fetchFn
      );
      this.addEventListenersToCacheableTile(cacheableTile);
      this.addCacheableTile(cacheableTile);
    } else {
      const cachedTile = this.tilesByTileUrl.get(tileUrl);
      if (cachedTile?.isCachedTile()) {
        this.dispatchEvent(
          new WarpedMapEvent(WarpedMapEventType.MAPTILELOADED, {
            mapId,
            tileUrl
          })
        );
      }
    }
    this.addTileUrlForMapId(tileUrl, mapId);
    this.addMapIdForTileUrl(mapId, tileUrl);
  }
  addCacheableTile(cacheableTile) {
    this.tilesByTileUrl.set(cacheableTile.tileUrl, cacheableTile);
    cacheableTile.fetch();
    this.updateTilesFetchingCount(1);
  }
  removeCacheableTileForMapId(tileUrl, mapId) {
    const cacheableTile = this.tilesByTileUrl.get(tileUrl);
    if (!cacheableTile) {
      return;
    }
    const mapIds = this.removeMapIdForTileUrl(mapId, tileUrl);
    this.removeTileUrlForMapId(tileUrl, mapId);
    if (!mapIds.size) {
      if (!cacheableTile.isCachedTile()) {
        cacheableTile.abort();
        this.updateTilesFetchingCount(-1);
      }
      this.tilesByTileUrl.delete(tileUrl);
    }
    this.dispatchEvent(
      new WarpedMapEvent(WarpedMapEventType.MAPTILEREMOVED, {
        mapId,
        tileUrl
      })
    );
  }
  tileFetched(event) {
    if (event instanceof WarpedMapEvent) {
      const tileUrl = event.data;
      this.updateTilesFetchingCount(-1);
      for (const mapId of this.mapIdsByTileUrl.get(tileUrl) || []) {
        this.dispatchEvent(
          new WarpedMapEvent(WarpedMapEventType.MAPTILELOADED, {
            mapId,
            tileUrl
          })
        );
        const tileUrls = this.tileUrlsByMapId.get(mapId);
        const firstTileUrl = tileUrls?.values().next().value;
        if (firstTileUrl === tileUrl) {
          this.dispatchEvent(
            new WarpedMapEvent(WarpedMapEventType.FIRSTMAPTILELOADED, {
              mapId,
              tileUrl
            })
          );
        }
      }
    }
  }
  tileFetchError(event) {
    if (event instanceof WarpedMapEvent) {
      const tileUrl = event.data;
      if (!this.tilesByTileUrl.has(tileUrl)) {
        this.updateTilesFetchingCount(-1);
      }
    }
  }
  addMapIdForTileUrl(mapId, tileUrl) {
    let mapIds = this.mapIdsByTileUrl.get(tileUrl);
    if (!mapIds) {
      mapIds = /* @__PURE__ */ new Set([mapId]);
    } else {
      mapIds.add(mapId);
    }
    this.mapIdsByTileUrl.set(tileUrl, mapIds);
    return mapIds;
  }
  removeMapIdForTileUrl(mapId, tileUrl) {
    const mapIds = this.mapIdsByTileUrl.get(tileUrl);
    if (!mapIds) {
      return /* @__PURE__ */ new Set();
    } else {
      mapIds.delete(mapId);
    }
    if (!mapIds.size) {
      this.mapIdsByTileUrl.delete(tileUrl);
    } else {
      this.mapIdsByTileUrl.set(tileUrl, mapIds);
    }
    return mapIds;
  }
  addTileUrlForMapId(tileUrl, mapId) {
    let tileUrls = this.tileUrlsByMapId.get(mapId);
    if (!tileUrls) {
      tileUrls = /* @__PURE__ */ new Set([tileUrl]);
    } else {
      tileUrls.add(tileUrl);
    }
    this.tileUrlsByMapId.set(mapId, tileUrls);
    return tileUrls;
  }
  removeTileUrlForMapId(tileUrl, mapId) {
    const tileUrls = this.tileUrlsByMapId.get(mapId);
    if (!tileUrls) {
      return /* @__PURE__ */ new Set();
    } else {
      tileUrls.delete(tileUrl);
      if (!tileUrls.size) {
        this.tileUrlsByMapId.delete(mapId);
      } else {
        this.tileUrlsByMapId.set(mapId, tileUrls);
      }
      return tileUrls;
    }
  }
  get finished() {
    return this.tilesFetchingCount === 0;
  }
  updateTilesFetchingCount(delta) {
    this.tilesFetchingCount += delta;
    if (this.tilesFetchingCount === 0) {
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.ALLREQUESTEDTILESLOADED)
      );
    }
  }
  addEventListenersToCacheableTile(cacheableTile) {
    cacheableTile.addEventListener(
      WarpedMapEventType.TILEFETCHED,
      this.tileFetched.bind(this)
    );
    cacheableTile.addEventListener(
      WarpedMapEventType.TILEFETCHERROR,
      this.tileFetchError.bind(this)
    );
  }
  removeEventListenersFromCacheableTile(cacheableTile) {
    cacheableTile.removeEventListener(
      WarpedMapEventType.TILEFETCHED,
      this.tileFetched.bind(this)
    );
    cacheableTile.removeEventListener(
      WarpedMapEventType.TILEFETCHERROR,
      this.tileFetchError.bind(this)
    );
  }
};

// node_modules/@allmaps/id/dist/checksum.js
function serialize(obj) {
  if (Array.isArray(obj)) {
    return `[${obj.map((i) => serialize(i)).join(",")}]`;
  } else if (typeof obj === "number") {
    return `${obj}`;
  } else if (typeof obj === "string") {
    return `"${obj}"`;
  } else if (typeof obj === "object" && obj !== null) {
    return Object.keys(obj).sort().map((key) => `${key}:${serialize(obj[key])}`).join("|");
  }
  return String(obj);
}

// node_modules/@allmaps/id/dist/index.js
var DEFAULT_LENGTH = 16;
async function generateHash(str) {
  const hashBuffer = await crypto.subtle.digest("SHA-1", new TextEncoder().encode(str));
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((byte) => byte.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
async function generateId(str, length = DEFAULT_LENGTH) {
  const hash = await generateHash(String(str));
  return hash.slice(0, length);
}
async function generateChecksum(obj, length = DEFAULT_LENGTH) {
  const checksum = await generateId(serialize(obj), length);
  return checksum;
}

// node_modules/@allmaps/annotation/dist/schemas/shared.js
function ensureArray(val) {
  if (val) {
    return Array.isArray(val) ? val : [val];
  }
}
var SingleValueSchema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]);
var LanguageValueSchema = external_exports.record(external_exports.string(), SingleValueSchema.array());
var PointSchema = external_exports.tuple([external_exports.number(), external_exports.number()]);
var PointGeometrySchema = external_exports.object({
  type: external_exports.literal("Point"),
  coordinates: PointSchema
});
var ResourceMaskSchema = PointSchema.array().min(3);
var ImageServices = [
  "ImageService1",
  "ImageService2",
  "ImageService3"
];
var ResourceTypes = [...ImageServices, ...["Canvas"]];
var ImageServiceSchema = external_exports.enum(ImageServices);
var ResourceTypeSchema = external_exports.enum(ResourceTypes);
var basePartOfItemSchema = external_exports.object({
  id: external_exports.string().url(),
  type: external_exports.string(),
  label: LanguageValueSchema.optional()
});
var PartOfItemSchema = basePartOfItemSchema.extend({
  partOf: external_exports.lazy(() => PartOfItemSchema.array()).optional()
});
var PartOfSchema = external_exports.union([PartOfItemSchema.array(), PartOfItemSchema]).transform(ensureArray);
var ValidTransformationSchema = external_exports.object({
  type: external_exports.enum(["helmert", "polynomial", "thinPlateSpline", "projective"]),
  options: external_exports.object({}).passthrough().optional()
});
function parseInvalidTransformation(val) {
  const valLowerCase = val.toLowerCase();
  if (valLowerCase === "thinplatespline" || valLowerCase === "thin-plate-spline") {
    return {
      type: "thinPlateSpline"
    };
  } else if (valLowerCase === "polynomial1") {
    return {
      type: "polynomial",
      options: { order: 1 }
    };
  } else if (valLowerCase === "polynomial2") {
    return {
      type: "polynomial",
      options: { order: 2 }
    };
  }
}
var TransformationSchema = external_exports.union([
  ValidTransformationSchema,
  // Catchall for unknown transformation types
  external_exports.unknown()
]).transform((val) => {
  const { success, data } = ValidTransformationSchema.safeParse(val);
  if (success) {
    return data;
  } else if (val === "string") {
    return parseInvalidTransformation(val);
  } else if (val && typeof val === "object" && "type" in val && typeof val.type === "string") {
    return parseInvalidTransformation(val.type);
  }
});
var ProjectionSchema = external_exports.object({
  name: external_exports.string().optional(),
  definition: external_exports.union([external_exports.string(), external_exports.unknown()])
});
var ContextSchema = external_exports.union([
  external_exports.string().url().array(),
  external_exports.string().url()
]);

// node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.0.js
var svg = /^<svg\s+width="\d+"\s+height="\d+"\s*>\s*<polygon\s+points="\s*(-?\d+(\.\d+)?,-?\d+(\.\d+)?\s+){2,}-?\d+(\.\d+)?,-?\d+(\.\d+)?\s*"\s*\/>\s*<\/svg>$/;
var SvgSelectorSchema = external_exports.object({
  type: external_exports.literal("SvgSelector"),
  value: external_exports.string().regex(svg)
});
var TargetSchema = external_exports.object({
  source: external_exports.string().url(),
  service: external_exports.array(external_exports.object({
    "@id": external_exports.string().url(),
    type: ResourceTypeSchema
  })).length(1),
  selector: SvgSelectorSchema
});
var FeaturePropertiesSchema = external_exports.object({
  pixelCoords: PointSchema
});
var BodySchema = external_exports.object({
  type: external_exports.literal("FeatureCollection"),
  transformation: TransformationSchema.optional(),
  features: external_exports.array(external_exports.object({
    type: external_exports.literal("Feature"),
    properties: FeaturePropertiesSchema,
    geometry: PointGeometrySchema
  }))
});
var AnnotationSchema = external_exports.object({
  id: external_exports.string().optional(),
  type: external_exports.literal("Annotation"),
  "@context": ContextSchema.optional(),
  motivation: external_exports.string().default("georeferencing").optional(),
  target: TargetSchema,
  body: BodySchema
});
var AnnotationPageSchema = external_exports.object({
  id: external_exports.string().optional(),
  type: external_exports.literal("AnnotationPage"),
  "@context": ContextSchema.optional(),
  items: external_exports.array(AnnotationSchema)
});

// node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.1.js
var polygonRegex = /<polygon\s+points="\s*(-?\d+(\.\d+)?,-?\d+(\.\d+)?\s+){2,}-?\d+(\.\d+)?,-?\d+(\.\d+)?\s*"\s*\/>/;
var svgWidthHeightRegex = new RegExp(`^<svg\\s+width="\\d+"\\s+height="\\d+"\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
var svgHeightWidthRegex = new RegExp(`^<svg\\s+height="\\d+"\\s+width="\\d+"\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
var svgRegex = new RegExp(`^<svg\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
var SvgRegexSchema = external_exports.string().regex(svgRegex);
var SvgWidthHeightRegexSchema = external_exports.string().regex(svgWidthHeightRegex);
var SvgHeightWidthRegexSchema = external_exports.string().regex(svgHeightWidthRegex);
var SvgSelectorSchema2 = external_exports.object({
  type: external_exports.literal("SvgSelector"),
  value: external_exports.union([
    SvgRegexSchema,
    SvgWidthHeightRegexSchema,
    SvgHeightWidthRegexSchema
  ])
});
var Source1Schema = external_exports.object({
  "@id": external_exports.string().url(),
  type: ImageServiceSchema,
  height: external_exports.number().positive(),
  width: external_exports.number().positive(),
  partOf: PartOfSchema.optional()
});
var Source2Schema = external_exports.object({
  id: external_exports.string().url(),
  type: ImageServiceSchema,
  height: external_exports.number().positive().optional(),
  width: external_exports.number().positive().optional(),
  partOf: PartOfSchema.optional()
});
var Canvas3Schema = external_exports.object({
  id: external_exports.string().url(),
  type: external_exports.literal("Canvas"),
  height: external_exports.number().positive().optional(),
  width: external_exports.number().positive().optional(),
  partOf: PartOfSchema.optional()
});
var SourceSchema = external_exports.union([
  Source1Schema,
  Source2Schema,
  Canvas3Schema
]);
var TargetSchema2 = external_exports.object({
  type: external_exports.literal("SpecificResource"),
  source: SourceSchema,
  // selector: z.union([SvgSelectorSchema, ImageApiSelectorSchema])
  selector: SvgSelectorSchema2
});
var FeaturePropertiesSchema2 = external_exports.object({
  resourceCoords: PointSchema
});
var BodySchema2 = external_exports.object({
  type: external_exports.literal("FeatureCollection"),
  transformation: TransformationSchema.optional(),
  resourceCrs: ProjectionSchema.optional(),
  features: external_exports.array(external_exports.object({
    type: external_exports.literal("Feature"),
    properties: FeaturePropertiesSchema2,
    geometry: PointGeometrySchema
  }))
});
var AnnotationSchema2 = external_exports.object({
  id: external_exports.string().optional(),
  type: external_exports.literal("Annotation"),
  "@context": ContextSchema.optional(),
  motivation: external_exports.string().default("georeferencing").optional(),
  created: external_exports.string().datetime().optional(),
  modified: external_exports.string().datetime().optional(),
  target: TargetSchema2,
  body: BodySchema2
});
var AnnotationPageSchema2 = external_exports.object({
  id: external_exports.string().optional(),
  type: external_exports.literal("AnnotationPage"),
  "@context": ContextSchema.optional(),
  items: external_exports.array(AnnotationSchema2)
});

// node_modules/@allmaps/annotation/dist/schemas/annotation.js
var AnnotationAllVersionsSchema = external_exports.union([
  AnnotationSchema,
  AnnotationSchema2
]);
var AnnotationPageAllVersionsSchema = external_exports.union([
  AnnotationPageSchema,
  AnnotationPageSchema2
]);
var FeaturePropertiesAllVersionsSchema = external_exports.union([
  FeaturePropertiesSchema,
  FeaturePropertiesSchema2
]);

// node_modules/@allmaps/annotation/dist/before-parse.js
function isGeoreferencedMapsBeforeParse(mapOrMaps) {
  return Array.isArray(mapOrMaps);
}
function isAnnotationPageBeforeParse(annotation) {
  if (annotation && typeof annotation === "object" && "type" in annotation && annotation.type === "AnnotationPage" && "items" in annotation) {
    return true;
  } else {
    return false;
  }
}
function isGeoreferencedMap2BeforeParse(georeferencedMap) {
  if (georeferencedMap && typeof georeferencedMap === "object" && "type" in georeferencedMap && georeferencedMap.type === "GeoreferencedMap") {
    return true;
  } else {
    return false;
  }
}
function isAnnotation0BeforeParse(annotation) {
  if (annotation && typeof annotation === "object" && "target" in annotation && annotation.target && typeof annotation.target === "object" && "source" in annotation.target && typeof annotation.target.source === "string") {
    return true;
  } else {
    return false;
  }
}

// node_modules/@allmaps/annotation/dist/guards.js
function isGeoreferencedMap2(georeferencedMap) {
  return "type" in georeferencedMap && georeferencedMap.type === "GeoreferencedMap";
}
function isAnnotation1(annotation) {
  return "source" in annotation.target && typeof annotation.target.source === "object";
}

// node_modules/@allmaps/annotation/dist/parser.js
function parseResource(annotation) {
  return {
    id: parseImageId(annotation),
    ...parseImageDimensions(annotation),
    type: parseResourceType(annotation),
    partOf: parsePartOf(annotation)
  };
}
function parseImageId(annotation) {
  if (isAnnotation1(annotation)) {
    const source = annotation.target.source;
    if ("id" in source) {
      return source.id;
    } else {
      return source["@id"];
    }
  } else {
    return annotation.target.service[0]["@id"];
  }
}
function parseResourceType(annotation) {
  if ("service" in annotation.target) {
    return annotation.target.service[0].type;
  } else {
    return annotation.target.source.type;
  }
}
function parsePartOf(annotation) {
  if (isAnnotation1(annotation)) {
    return annotation.target.source.partOf;
  }
}
function parseResourceCoords(properties) {
  if ("pixelCoords" in properties) {
    return properties.pixelCoords;
  } else {
    return properties.resourceCoords;
  }
}
function parseGcps(annotation) {
  return annotation.body.features.map((gcpFeature) => ({
    resource: parseResourceCoords(gcpFeature.properties),
    geo: gcpFeature.geometry.coordinates
  }));
}
function parseDates(annotation) {
  if (isAnnotation1(annotation)) {
    return {
      created: annotation.created,
      modified: annotation.modified
    };
  }
}
function parseImageDimensions(annotation) {
  if (isAnnotation1(annotation)) {
    return {
      width: annotation.target.source.width,
      height: annotation.target.source.height
    };
  }
  const selector = annotation.target.selector;
  const svg2 = selector.value;
  const widthResult = /width="(?<width>\d+)"/.exec(svg2);
  const heightResult = /height="(?<height>\d+)"/.exec(svg2);
  const width = widthResult?.groups?.width;
  const height = heightResult?.groups?.height;
  if (!width || !height) {
    throw new Error("Could not parse image dimensions");
  }
  return {
    width: parseInt(width),
    height: parseInt(height)
  };
}
function parseResourceMask(annotation) {
  const selector = annotation.target.selector;
  const svg2 = selector.value;
  const result2 = /points="(?<points>.+)"/.exec(svg2);
  const groups = result2?.groups;
  if (groups && groups.points) {
    const pointStrings = groups.points.trim().split(/\s+/);
    if (pointStrings[0] === pointStrings[pointStrings.length - 1]) {
      pointStrings.splice(-1);
    }
    if (pointStrings.length >= 3) {
      return pointStrings.map((point2) => {
        const numberStrings = point2.split(",");
        if (numberStrings.length === 2) {
          return [parseFloat(numberStrings[0]), parseFloat(numberStrings[1])];
        } else {
          throw new Error("Could not parse resource mask");
        }
      });
    } else {
      throw new Error("Could not parse resource mask");
    }
  } else {
    throw new Error("Could not parse resource mask");
  }
}
function getGeoreferencedMap(annotation) {
  let resourceCrs;
  if ("resourceCrs" in annotation.body) {
    resourceCrs = annotation.body.resourceCrs;
  }
  return {
    "@context": "https://schemas.allmaps.org/map/2/context.json",
    type: "GeoreferencedMap",
    id: annotation.id,
    ...parseDates(annotation),
    resource: parseResource(annotation),
    gcps: parseGcps(annotation),
    resourceMask: parseResourceMask(annotation),
    transformation: annotation.body.transformation,
    resourceCrs
  };
}
function parseAnnotation(annotation) {
  if (isAnnotationPageBeforeParse(annotation)) {
    let parsedAnnotationPage;
    if ("items" in annotation && Array.isArray(annotation.items) && isAnnotation0BeforeParse(annotation.items[0])) {
      parsedAnnotationPage = AnnotationPageSchema.parse(annotation);
    } else {
      parsedAnnotationPage = AnnotationPageSchema2.parse(annotation);
    }
    return parsedAnnotationPage.items.map((parsedAnnotation) => getGeoreferencedMap(parsedAnnotation));
  } else {
    let parsedAnnotation;
    if (isAnnotation0BeforeParse(annotation)) {
      parsedAnnotation = AnnotationSchema.parse(annotation);
    } else {
      parsedAnnotation = AnnotationSchema2.parse(annotation);
    }
    return [getGeoreferencedMap(parsedAnnotation)];
  }
}

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.1.js
var GCPSchema = external_exports.object({
  image: PointSchema,
  world: PointSchema
});
var ImageSchema = external_exports.object({
  uri: external_exports.string().url(),
  width: external_exports.number(),
  height: external_exports.number(),
  type: ImageServiceSchema
});
var GeoreferencedMapSchema = external_exports.object({
  id: external_exports.string().optional(),
  version: external_exports.number().min(1).max(1).default(1),
  image: ImageSchema,
  gcps: GCPSchema.array(),
  pixelMask: ResourceMaskSchema,
  transformation: TransformationSchema.optional()
});
var GeoreferencedMapsSchema = external_exports.array(GeoreferencedMapSchema);

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.2.js
var GCPSchema2 = external_exports.object({
  resource: PointSchema,
  geo: PointSchema
});
var ResourceSchema = external_exports.object({
  id: external_exports.string().url(),
  height: external_exports.number().positive().optional(),
  width: external_exports.number().positive().optional(),
  type: ResourceTypeSchema,
  partOf: PartOfSchema.optional()
});
var GeoreferencedMapSchema2 = external_exports.object({
  "@context": external_exports.literal("https://schemas.allmaps.org/map/2/context.json").optional(),
  type: external_exports.literal("GeoreferencedMap"),
  id: external_exports.string().optional(),
  created: external_exports.string().datetime().optional(),
  modified: external_exports.string().datetime().optional(),
  resource: ResourceSchema,
  gcps: GCPSchema2.array(),
  resourceMask: ResourceMaskSchema,
  transformation: TransformationSchema.optional(),
  resourceCrs: ProjectionSchema.optional()
});
var GeoreferencedMapsSchema2 = external_exports.array(GeoreferencedMapSchema2);

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map.js
var GeoreferencedMapAllVersionsSchema = external_exports.union([
  GeoreferencedMapSchema,
  GeoreferencedMapSchema2
]);
var GeoreferencedMapsAllVersionsSchema = external_exports.union([
  GeoreferencedMapsSchema,
  GeoreferencedMapsSchema2
]);
var GCPAllVersionsSchema = external_exports.union([
  GCPSchema,
  GCPSchema2
]);

// node_modules/@allmaps/annotation/dist/generator.js
function generateSvgSelector(georeferencedMap) {
  let width;
  let height;
  let resourceMask;
  if (isGeoreferencedMap2(georeferencedMap)) {
    width = georeferencedMap.resource.width;
    height = georeferencedMap.resource.height;
    resourceMask = georeferencedMap.resourceMask;
  } else {
    width = georeferencedMap.image.width;
    height = georeferencedMap.image.height;
    resourceMask = georeferencedMap.pixelMask;
  }
  let svg2 = `<svg>`;
  if (width && height) {
    svg2 = `<svg width="${width}" height="${height}">`;
  }
  return {
    type: "SvgSelector",
    value: `${svg2}<polygon points="${resourceMask.map((point2) => point2.join(",")).join(" ")}" /></svg>`
  };
}
function generateSource(georeferencedMap) {
  let id;
  let type;
  let width;
  let height;
  let partOf;
  if (isGeoreferencedMap2(georeferencedMap)) {
    if (georeferencedMap.resource.type === "Canvas") {
      const source = {
        id: georeferencedMap.resource.id,
        type: georeferencedMap.resource.type,
        height: georeferencedMap.resource.height,
        width: georeferencedMap.resource.width,
        partOf: georeferencedMap.resource.partOf
      };
      return source;
    } else {
      id = georeferencedMap.resource.id;
      type = georeferencedMap.resource.type;
      width = georeferencedMap.resource.width;
      height = georeferencedMap.resource.height;
      partOf = georeferencedMap.resource.partOf;
    }
  } else {
    id = georeferencedMap.image.uri;
    type = georeferencedMap.image.type;
    width = georeferencedMap.image.width;
    height = georeferencedMap.image.height;
  }
  return {
    id,
    type,
    height,
    width,
    partOf
  };
}
function generateDates(georeferencedMap) {
  if (isGeoreferencedMap2(georeferencedMap)) {
    return {
      created: georeferencedMap.created,
      modified: georeferencedMap.modified
    };
  }
}
function generateContext() {
  return [
    "http://iiif.io/api/extension/georef/1/context.json",
    "http://iiif.io/api/presentation/3/context.json"
  ];
}
function generateFeature(gcp) {
  let resourceCoords;
  let geoCoords;
  if ("resource" in gcp) {
    resourceCoords = gcp.resource;
    geoCoords = gcp.geo;
  } else {
    resourceCoords = gcp.image;
    geoCoords = gcp.world;
  }
  return {
    type: "Feature",
    properties: {
      resourceCoords
    },
    geometry: {
      type: "Point",
      coordinates: geoCoords
    }
  };
}
function generateGeoreferenceAnnotation(georeferencedMap) {
  const target = {
    type: "SpecificResource",
    source: generateSource(georeferencedMap),
    selector: generateSvgSelector(georeferencedMap)
  };
  let resourceCrs;
  if ("resourceCrs" in georeferencedMap) {
    resourceCrs = georeferencedMap.resourceCrs;
  }
  const body = {
    type: "FeatureCollection",
    transformation: georeferencedMap.transformation,
    resourceCrs,
    features: georeferencedMap.gcps.map((gcp) => generateFeature(gcp))
  };
  return {
    id: georeferencedMap.id,
    type: "Annotation",
    "@context": generateContext(),
    ...generateDates(georeferencedMap),
    motivation: "georeferencing",
    target,
    body
  };
}
function generateAnnotation(mapOrMaps) {
  if (isGeoreferencedMapsBeforeParse(mapOrMaps)) {
    let parsedGeoreferencedMaps;
    if (isGeoreferencedMap2BeforeParse(mapOrMaps[0])) {
      parsedGeoreferencedMaps = GeoreferencedMapsSchema2.parse(mapOrMaps);
    } else {
      parsedGeoreferencedMaps = GeoreferencedMapsSchema.parse(mapOrMaps);
    }
    const annotations = parsedGeoreferencedMaps.map((parsedGeoreferencedMap) => generateGeoreferenceAnnotation(parsedGeoreferencedMap));
    return {
      type: "AnnotationPage",
      "@context": "http://www.w3.org/ns/anno.jsonld",
      items: annotations
    };
  } else {
    let parsedGeoreferencedMap;
    if (isGeoreferencedMap2BeforeParse(mapOrMaps)) {
      parsedGeoreferencedMap = GeoreferencedMapSchema2.parse(mapOrMaps);
    } else {
      parsedGeoreferencedMap = GeoreferencedMapSchema.parse(mapOrMaps);
    }
    return generateGeoreferenceAnnotation(parsedGeoreferencedMap);
  }
}

// node_modules/@allmaps/annotation/dist/convert.js
function toGeoreferencedMap2(georeferencedMap) {
  if (isGeoreferencedMap2(georeferencedMap)) {
    return georeferencedMap;
  } else {
    const convertedMap = parseAnnotation(generateAnnotation(georeferencedMap));
    return convertedMap[0];
  }
}
function toGeoreferencedMaps2(georeferencedMap) {
  return georeferencedMap.map(toGeoreferencedMap2);
}

// node_modules/@allmaps/annotation/dist/validator.js
function validateGeoreferencedMap(mapOrMaps) {
  if (isGeoreferencedMapsBeforeParse(mapOrMaps)) {
    let parsedGeoreferencedMaps;
    if (isGeoreferencedMap2BeforeParse(mapOrMaps[0])) {
      parsedGeoreferencedMaps = GeoreferencedMapsSchema2.parse(mapOrMaps);
    } else {
      parsedGeoreferencedMaps = GeoreferencedMapsSchema.parse(mapOrMaps);
    }
    return toGeoreferencedMaps2(parsedGeoreferencedMaps);
  } else {
    let parsedGeoreferencedMap;
    if (isGeoreferencedMap2BeforeParse(mapOrMaps)) {
      parsedGeoreferencedMap = GeoreferencedMapSchema2.parse(mapOrMaps);
    } else {
      parsedGeoreferencedMap = GeoreferencedMapSchema.parse(mapOrMaps);
    }
    return toGeoreferencedMap2(parsedGeoreferencedMap);
  }
}

// node_modules/proj4/lib/global.js
function global_default(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var i = 1; i <= 60; ++i) {
    defs2("EPSG:" + (32600 + i), "+proj=utm +zone=" + i + " +datum=WGS84 +units=m");
    defs2("EPSG:" + (32700 + i), "+proj=utm +zone=" + i + " +south +datum=WGS84 +units=m");
  }
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}

// node_modules/proj4/lib/constants/values.js
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4;
var PJD_NODATUM = 5;
var SRS_WGS84_SEMIMAJOR = 6378137;
var SRS_WGS84_SEMIMINOR = 6356752314e-3;
var SRS_WGS84_ESQUARED = 0.0066943799901413165;
var SEC_TO_RAD = 484813681109536e-20;
var HALF_PI = Math.PI / 2;
var SIXTH = 0.16666666666666666;
var RA4 = 0.04722222222222222;
var RA6 = 0.022156084656084655;
var EPSLN = 1e-10;
var D2R = 0.017453292519943295;
var R2D = 57.29577951308232;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2;
var SPI = 3.14159265359;

// node_modules/proj4/lib/constants/PrimeMeridian.js
var primeMeridian = {};
primeMeridian.greenwich = 0;
primeMeridian.lisbon = -9.131906111111;
primeMeridian.paris = 2.337229166667;
primeMeridian.bogota = -74.080916666667;
primeMeridian.madrid = -3.687938888889;
primeMeridian.rome = 12.452333333333;
primeMeridian.bern = 7.439583333333;
primeMeridian.jakarta = 106.807719444444;
primeMeridian.ferro = -17.666666666667;
primeMeridian.brussels = 4.367975;
primeMeridian.stockholm = 18.058277777778;
primeMeridian.athens = 23.7163375;
primeMeridian.oslo = 10.722916666667;
var PrimeMeridian_default = primeMeridian;

// node_modules/proj4/lib/constants/units.js
var units_default = {
  mm: { to_meter: 1e-3 },
  cm: { to_meter: 0.01 },
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 },
  fath: { to_meter: 1.8288 },
  kmi: { to_meter: 1852 },
  "us-ch": { to_meter: 20.1168402336805 },
  "us-mi": { to_meter: 1609.34721869444 },
  km: { to_meter: 1e3 },
  "ind-ft": { to_meter: 0.30479841 },
  "ind-yd": { to_meter: 0.91439523 },
  mi: { to_meter: 1609.344 },
  yd: { to_meter: 0.9144 },
  ch: { to_meter: 20.1168 },
  link: { to_meter: 0.201168 },
  dm: { to_meter: 0.1 },
  in: { to_meter: 0.0254 },
  "ind-ch": { to_meter: 20.11669506 },
  "us-in": { to_meter: 0.025400050800101 },
  "us-yd": { to_meter: 0.914401828803658 }
};

// node_modules/proj4/lib/match.js
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys2 = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i = -1;
  var testkey, processedKey;
  while (++i < keys2.length) {
    testkey = keys2[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}

// node_modules/proj4/lib/projString.js
function projString_default(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v2) {
    return v2.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split2 = a.split("=");
    split2.push(true);
    p[split2[0].toLowerCase()] = split2[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v2) {
      self2.rf = parseFloat(v2);
    },
    lat_0: function(v2) {
      self2.lat0 = v2 * D2R;
    },
    lat_1: function(v2) {
      self2.lat1 = v2 * D2R;
    },
    lat_2: function(v2) {
      self2.lat2 = v2 * D2R;
    },
    lat_ts: function(v2) {
      self2.lat_ts = v2 * D2R;
    },
    lon_0: function(v2) {
      self2.long0 = v2 * D2R;
    },
    lon_1: function(v2) {
      self2.long1 = v2 * D2R;
    },
    lon_2: function(v2) {
      self2.long2 = v2 * D2R;
    },
    alpha: function(v2) {
      self2.alpha = parseFloat(v2) * D2R;
    },
    gamma: function(v2) {
      self2.rectified_grid_angle = parseFloat(v2) * D2R;
    },
    lonc: function(v2) {
      self2.longc = v2 * D2R;
    },
    x_0: function(v2) {
      self2.x0 = parseFloat(v2);
    },
    y_0: function(v2) {
      self2.y0 = parseFloat(v2);
    },
    k_0: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    k: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    a: function(v2) {
      self2.a = parseFloat(v2);
    },
    b: function(v2) {
      self2.b = parseFloat(v2);
    },
    r: function(v2) {
      self2.a = self2.b = parseFloat(v2);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v2) {
      self2.zone = parseInt(v2, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v2) {
      self2.datum_params = v2.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v2) {
      self2.to_meter = parseFloat(v2);
    },
    units: function(v2) {
      self2.units = v2;
      var unit = match(units_default, v2);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v2) {
      self2.from_greenwich = v2 * D2R;
    },
    pm: function(v2) {
      var pm = match(PrimeMeridian_default, v2);
      self2.from_greenwich = (pm ? pm : parseFloat(v2)) * D2R;
    },
    nadgrids: function(v2) {
      if (v2 === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v2;
      }
    },
    axis: function(v2) {
      var legalAxis = "ewnsud";
      if (v2.length === 3 && legalAxis.indexOf(v2.substr(0, 1)) !== -1 && legalAxis.indexOf(v2.substr(1, 1)) !== -1 && legalAxis.indexOf(v2.substr(2, 1)) !== -1) {
        self2.axis = v2;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}

// node_modules/wkt-parser/PROJJSONBuilderBase.js
var PROJJSONBuilderBase = class {
  static getId(node) {
    const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
    if (idNode && idNode.length >= 3) {
      return {
        authority: idNode[1],
        code: parseInt(idNode[2], 10)
      };
    }
    return null;
  }
  static convertUnit(node, type = "unit") {
    if (!node || node.length < 3) {
      return { type, name: "unknown", conversion_factor: null };
    }
    const name = node[1];
    const conversionFactor = parseFloat(node[2]) || null;
    const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
    const id = idNode ? {
      authority: idNode[1],
      code: parseInt(idNode[2], 10)
    } : null;
    return {
      type,
      name,
      conversion_factor: conversionFactor,
      id
    };
  }
  static convertAxis(node) {
    const name = node[1] || "Unknown";
    let direction;
    const abbreviationMatch = name.match(/^\((.)\)$/);
    if (abbreviationMatch) {
      const abbreviation = abbreviationMatch[1].toUpperCase();
      if (abbreviation === "E") direction = "east";
      else if (abbreviation === "N") direction = "north";
      else if (abbreviation === "U") direction = "up";
      else throw new Error(`Unknown axis abbreviation: ${abbreviation}`);
    } else {
      direction = node[2] ? node[2].toLowerCase() : "unknown";
    }
    const orderNode = node.find((child) => Array.isArray(child) && child[0] === "ORDER");
    const order = orderNode ? parseInt(orderNode[1], 10) : null;
    const unitNode = node.find(
      (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
    );
    const unit = this.convertUnit(unitNode);
    return {
      name,
      direction,
      // Use the valid PROJJSON direction value
      unit,
      order
    };
  }
  static extractAxes(node) {
    return node.filter((child) => Array.isArray(child) && child[0] === "AXIS").map((axis) => this.convertAxis(axis)).sort((a, b) => (a.order || 0) - (b.order || 0));
  }
  static convert(node, result2 = {}) {
    switch (node[0]) {
      case "PROJCRS":
        result2.type = "ProjectedCRS";
        result2.name = node[1];
        result2.base_crs = node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS")) : null;
        result2.conversion = node.find((child) => Array.isArray(child) && child[0] === "CONVERSION") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "CONVERSION")) : null;
        const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
        if (csNode) {
          result2.coordinate_system = {
            type: csNode[1],
            axis: this.extractAxes(node)
          };
        }
        const lengthUnitNode = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT");
        if (lengthUnitNode) {
          const unit2 = this.convertUnit(lengthUnitNode);
          result2.coordinate_system.unit = unit2;
        }
        result2.id = this.getId(node);
        break;
      case "BASEGEOGCRS":
      case "GEOGCRS":
        result2.type = "GeographicCRS";
        result2.name = node[1];
        const datumOrEnsembleNode = node.find(
          (child) => Array.isArray(child) && (child[0] === "DATUM" || child[0] === "ENSEMBLE")
        );
        if (datumOrEnsembleNode) {
          const datumOrEnsemble = this.convert(datumOrEnsembleNode);
          if (datumOrEnsembleNode[0] === "ENSEMBLE") {
            result2.datum_ensemble = datumOrEnsemble;
          } else {
            result2.datum = datumOrEnsemble;
          }
          const primem = node.find((child) => Array.isArray(child) && child[0] === "PRIMEM");
          if (primem && primem[1] !== "Greenwich") {
            datumOrEnsemble.prime_meridian = {
              name: primem[1],
              longitude: parseFloat(primem[2])
            };
          }
        }
        result2.coordinate_system = {
          type: "ellipsoidal",
          axis: this.extractAxes(node)
        };
        result2.id = this.getId(node);
        break;
      case "DATUM":
        result2.type = "GeodeticReferenceFrame";
        result2.name = node[1];
        result2.ellipsoid = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID")) : null;
        break;
      case "ENSEMBLE":
        result2.type = "DatumEnsemble";
        result2.name = node[1];
        result2.members = node.filter((child) => Array.isArray(child) && child[0] === "MEMBER").map((member) => ({
          type: "DatumEnsembleMember",
          name: member[1],
          id: this.getId(member)
          // Extract ID as { authority, code }
        }));
        const accuracyNode = node.find((child) => Array.isArray(child) && child[0] === "ENSEMBLEACCURACY");
        if (accuracyNode) {
          result2.accuracy = parseFloat(accuracyNode[1]);
        }
        const ellipsoidNode = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID");
        if (ellipsoidNode) {
          result2.ellipsoid = this.convert(ellipsoidNode);
        }
        result2.id = this.getId(node);
        break;
      case "ELLIPSOID":
        result2.type = "Ellipsoid";
        result2.name = node[1];
        result2.semi_major_axis = parseFloat(node[2]);
        result2.inverse_flattening = parseFloat(node[3]);
        const units = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT"), result2) : null;
        break;
      case "CONVERSION":
        result2.type = "Conversion";
        result2.name = node[1];
        result2.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
        result2.parameters = node.filter((child) => Array.isArray(child) && child[0] === "PARAMETER").map((param) => this.convert(param));
        break;
      case "METHOD":
        result2.type = "Method";
        result2.name = node[1];
        result2.id = this.getId(node);
        break;
      case "PARAMETER":
        result2.type = "Parameter";
        result2.name = node[1];
        result2.value = parseFloat(node[2]);
        result2.unit = this.convertUnit(
          node.find(
            (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
          )
        );
        result2.id = this.getId(node);
        break;
      case "BOUNDCRS":
        result2.type = "BoundCRS";
        const sourceCrsNode = node.find((child) => Array.isArray(child) && child[0] === "SOURCECRS");
        if (sourceCrsNode) {
          const sourceCrsContent = sourceCrsNode.find((child) => Array.isArray(child));
          result2.source_crs = sourceCrsContent ? this.convert(sourceCrsContent) : null;
        }
        const targetCrsNode = node.find((child) => Array.isArray(child) && child[0] === "TARGETCRS");
        if (targetCrsNode) {
          const targetCrsContent = targetCrsNode.find((child) => Array.isArray(child));
          result2.target_crs = targetCrsContent ? this.convert(targetCrsContent) : null;
        }
        const transformationNode = node.find((child) => Array.isArray(child) && child[0] === "ABRIDGEDTRANSFORMATION");
        if (transformationNode) {
          result2.transformation = this.convert(transformationNode);
        } else {
          result2.transformation = null;
        }
        break;
      case "ABRIDGEDTRANSFORMATION":
        result2.type = "Transformation";
        result2.name = node[1];
        result2.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
        result2.parameters = node.filter((child) => Array.isArray(child) && (child[0] === "PARAMETER" || child[0] === "PARAMETERFILE")).map((param) => {
          if (param[0] === "PARAMETER") {
            return this.convert(param);
          } else if (param[0] === "PARAMETERFILE") {
            return {
              name: param[1],
              value: param[2],
              id: {
                "authority": "EPSG",
                "code": 8656
              }
            };
          }
        });
        if (result2.parameters.length === 7) {
          const scaleDifference = result2.parameters[6];
          if (scaleDifference.name === "Scale difference") {
            scaleDifference.value = Math.round((scaleDifference.value - 1) * 1e12) / 1e6;
          }
        }
        result2.id = this.getId(node);
        break;
      case "AXIS":
        if (!result2.coordinate_system) {
          result2.coordinate_system = { type: "unspecified", axis: [] };
        }
        result2.coordinate_system.axis.push(this.convertAxis(node));
        break;
      case "LENGTHUNIT":
        const unit = this.convertUnit(node, "LinearUnit");
        if (result2.coordinate_system && result2.coordinate_system.axis) {
          result2.coordinate_system.axis.forEach((axis) => {
            if (!axis.unit) {
              axis.unit = unit;
            }
          });
        }
        if (unit.conversion_factor && unit.conversion_factor !== 1) {
          if (result2.semi_major_axis) {
            result2.semi_major_axis = {
              value: result2.semi_major_axis,
              unit
            };
          }
        }
        break;
      default:
        result2.keyword = node[0];
        break;
    }
    return result2;
  }
};
var PROJJSONBuilderBase_default = PROJJSONBuilderBase;

// node_modules/wkt-parser/PROJJSONBuilder2015.js
var PROJJSONBuilder2015 = class extends PROJJSONBuilderBase_default {
  static convert(node, result2 = {}) {
    super.convert(node, result2);
    if (result2.coordinate_system && result2.coordinate_system.subtype === "Cartesian") {
      delete result2.coordinate_system;
    }
    if (result2.usage) {
      delete result2.usage;
    }
    return result2;
  }
};
var PROJJSONBuilder2015_default = PROJJSONBuilder2015;

// node_modules/wkt-parser/PROJJSONBuilder2019.js
var PROJJSONBuilder2019 = class extends PROJJSONBuilderBase_default {
  static convert(node, result2 = {}) {
    super.convert(node, result2);
    const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
    if (csNode) {
      result2.coordinate_system = {
        subtype: csNode[1],
        axis: this.extractAxes(node)
      };
    }
    const usageNode = node.find((child) => Array.isArray(child) && child[0] === "USAGE");
    if (usageNode) {
      const scope = usageNode.find((child) => Array.isArray(child) && child[0] === "SCOPE");
      const area = usageNode.find((child) => Array.isArray(child) && child[0] === "AREA");
      const bbox = usageNode.find((child) => Array.isArray(child) && child[0] === "BBOX");
      result2.usage = {};
      if (scope) {
        result2.usage.scope = scope[1];
      }
      if (area) {
        result2.usage.area = area[1];
      }
      if (bbox) {
        result2.usage.bbox = bbox.slice(1);
      }
    }
    return result2;
  }
};
var PROJJSONBuilder2019_default = PROJJSONBuilder2019;

// node_modules/wkt-parser/buildPROJJSON.js
function detectWKT2Version(root2) {
  if (root2.find((child) => Array.isArray(child) && child[0] === "USAGE")) {
    return "2019";
  }
  if (root2.find((child) => Array.isArray(child) && child[0] === "CS")) {
    return "2015";
  }
  if (root2[0] === "BOUNDCRS" || root2[0] === "PROJCRS" || root2[0] === "GEOGCRS") {
    return "2015";
  }
  return "2015";
}
function buildPROJJSON(root2) {
  const version = detectWKT2Version(root2);
  const builder = version === "2019" ? PROJJSONBuilder2019_default : PROJJSONBuilder2015_default;
  return builder.convert(root2);
}

// node_modules/wkt-parser/detectWKTVersion.js
function detectWKTVersion(wkt) {
  const normalizedWKT = wkt.toUpperCase();
  if (normalizedWKT.includes("PROJCRS") || normalizedWKT.includes("GEOGCRS") || normalizedWKT.includes("BOUNDCRS") || normalizedWKT.includes("VERTCRS") || normalizedWKT.includes("LENGTHUNIT") || normalizedWKT.includes("ANGLEUNIT") || normalizedWKT.includes("SCALEUNIT")) {
    return "WKT2";
  }
  if (normalizedWKT.includes("PROJCS") || normalizedWKT.includes("GEOGCS") || normalizedWKT.includes("LOCAL_CS") || normalizedWKT.includes("VERT_CS") || normalizedWKT.includes("UNIT")) {
    return "WKT1";
  }
  return "WKT1";
}

// node_modules/wkt-parser/parser.js
var parser_default = parseString;
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
function Parser(text) {
  if (typeof text !== "string") {
    throw new Error("not a string");
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char);
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
  if (char === ",") {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === "]") {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }
    return;
  }
};
Parser.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === "[") {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = "";
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}

// node_modules/wkt-parser/process.js
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v2, obj) {
  if (!Array.isArray(v2)) {
    obj[v2] = true;
    return;
  }
  var key = v2.shift();
  if (key === "PARAMETER") {
    key = v2.shift();
  }
  if (v2.length === 1) {
    if (Array.isArray(v2[0])) {
      obj[key] = {};
      sExpr(v2[0], obj[key]);
      return;
    }
    obj[key] = v2[0];
    return;
  }
  if (!v2.length) {
    obj[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj[key] = v2;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v2);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key] = {
        name: v2[0].toLowerCase(),
        convert: v2[1]
      };
      if (v2.length === 3) {
        sExpr(v2[2], obj[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key] = {
        name: v2[0],
        a: v2[1],
        rf: v2[2]
      };
      if (v2.length === 4) {
        sExpr(v2[3], obj[key]);
      }
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      v2[0] = ["name", v2[0]];
      mapit(obj, key, v2);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      v2[0] = ["name", v2[0]];
      mapit(obj, key, v2);
      obj[key].type = key;
      return;
    default:
      i = -1;
      while (++i < v2.length) {
        if (!Array.isArray(v2[i])) {
          return sExpr(v2, obj[key]);
        }
      }
      return mapit(obj, key, v2);
  }
}

// node_modules/wkt-parser/util.js
var D2R2 = 0.017453292519943295;
function d2r(input) {
  return input * D2R2;
}
function applyProjectionDefaults(wkt) {
  const normalizedProjName = (wkt.projName || "").toLowerCase().replace(/_/g, " ");
  if (!wkt.long0 && wkt.longc && (normalizedProjName === "albers conic equal area" || normalizedProjName === "lambert azimuthal equal area")) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (normalizedProjName === "stereographic south pole" || normalizedProjName === "polar stereographic (variant b)")) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
    delete wkt.lat1;
  } else if (!wkt.lat_ts && wkt.lat0 && (normalizedProjName === "polar stereographic" || normalizedProjName === "polar stereographic (variant a)")) {
    wkt.lat_ts = wkt.lat0;
    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
    delete wkt.lat1;
  }
}

// node_modules/wkt-parser/transformPROJJSON.js
function processUnit(unit) {
  let result2 = { units: null, to_meter: void 0 };
  if (typeof unit === "string") {
    result2.units = unit.toLowerCase();
    if (result2.units === "metre") {
      result2.units = "meter";
    }
    if (result2.units === "meter") {
      result2.to_meter = 1;
    }
  } else if (unit && unit.name) {
    result2.units = unit.name.toLowerCase();
    if (result2.units === "metre") {
      result2.units = "meter";
    }
    result2.to_meter = unit.conversion_factor;
  }
  return result2;
}
function toValue(valueOrObject) {
  if (typeof valueOrObject === "object") {
    return valueOrObject.value * valueOrObject.unit.conversion_factor;
  }
  return valueOrObject;
}
function calculateEllipsoid(value, result2) {
  if (value.ellipsoid.radius) {
    result2.a = value.ellipsoid.radius;
    result2.rf = 0;
  } else {
    result2.a = toValue(value.ellipsoid.semi_major_axis);
    if (value.ellipsoid.inverse_flattening !== void 0) {
      result2.rf = value.ellipsoid.inverse_flattening;
    } else if (value.ellipsoid.semi_major_axis !== void 0 && value.ellipsoid.semi_minor_axis !== void 0) {
      result2.rf = result2.a / (result2.a - toValue(value.ellipsoid.semi_minor_axis));
    }
  }
}
function transformPROJJSON(projjson, result2 = {}) {
  if (!projjson || typeof projjson !== "object") {
    return projjson;
  }
  if (projjson.type === "BoundCRS") {
    transformPROJJSON(projjson.source_crs, result2);
    if (projjson.transformation) {
      if (projjson.transformation.method && projjson.transformation.method.name === "NTv2") {
        result2.nadgrids = projjson.transformation.parameters[0].value;
      } else {
        result2.datum_params = projjson.transformation.parameters.map((param) => param.value);
      }
    }
    return result2;
  }
  Object.keys(projjson).forEach((key) => {
    const value = projjson[key];
    if (value === null) {
      return;
    }
    switch (key) {
      case "name":
        if (result2.srsCode) {
          break;
        }
        result2.name = value;
        result2.srsCode = value;
        break;
      case "type":
        if (value === "GeographicCRS") {
          result2.projName = "longlat";
        } else if (value === "ProjectedCRS" && projjson.conversion && projjson.conversion.method) {
          result2.projName = projjson.conversion.method.name;
        }
        break;
      case "datum":
      case "datum_ensemble":
        if (value.ellipsoid) {
          result2.ellps = value.ellipsoid.name;
          calculateEllipsoid(value, result2);
        }
        if (value.prime_meridian) {
          result2.from_greenwich = value.prime_meridian.longitude * Math.PI / 180;
        }
        break;
      case "ellipsoid":
        result2.ellps = value.name;
        calculateEllipsoid(value, result2);
        break;
      case "prime_meridian":
        result2.long0 = (value.longitude || 0) * Math.PI / 180;
        break;
      case "coordinate_system":
        if (value.axis) {
          result2.axis = value.axis.map((axis) => {
            const direction = axis.direction;
            if (direction === "east") return "e";
            if (direction === "north") return "n";
            if (direction === "west") return "w";
            if (direction === "south") return "s";
            throw new Error(`Unknown axis direction: ${direction}`);
          }).join("") + "u";
          if (value.unit) {
            const { units, to_meter } = processUnit(value.unit);
            result2.units = units;
            result2.to_meter = to_meter;
          } else if (value.axis[0] && value.axis[0].unit) {
            const { units, to_meter } = processUnit(value.axis[0].unit);
            result2.units = units;
            result2.to_meter = to_meter;
          }
        }
        break;
      case "id":
        if (value.authority && value.code) {
          result2.title = value.authority + ":" + value.code;
        }
        break;
      case "conversion":
        if (value.method && value.method.name) {
          result2.projName = value.method.name;
        }
        if (value.parameters) {
          value.parameters.forEach((param) => {
            const paramName = param.name.toLowerCase().replace(/\s+/g, "_");
            const paramValue = param.value;
            if (param.unit && param.unit.conversion_factor) {
              result2[paramName] = paramValue * param.unit.conversion_factor;
            } else if (param.unit === "degree") {
              result2[paramName] = paramValue * Math.PI / 180;
            } else {
              result2[paramName] = paramValue;
            }
          });
        }
        break;
      case "unit":
        if (value.name) {
          result2.units = value.name.toLowerCase();
          if (result2.units === "metre") {
            result2.units = "meter";
          }
        }
        if (value.conversion_factor) {
          result2.to_meter = value.conversion_factor;
        }
        break;
      case "base_crs":
        transformPROJJSON(value, result2);
        result2.datumCode = value.id ? value.id.authority + "_" + value.id.code : value.name;
        break;
      default:
        break;
    }
  });
  if (result2.latitude_of_false_origin !== void 0) {
    result2.lat0 = result2.latitude_of_false_origin;
  }
  if (result2.longitude_of_false_origin !== void 0) {
    result2.long0 = result2.longitude_of_false_origin;
  }
  if (result2.latitude_of_standard_parallel !== void 0) {
    result2.lat0 = result2.latitude_of_standard_parallel;
    result2.lat1 = result2.latitude_of_standard_parallel;
  }
  if (result2.latitude_of_1st_standard_parallel !== void 0) {
    result2.lat1 = result2.latitude_of_1st_standard_parallel;
  }
  if (result2.latitude_of_2nd_standard_parallel !== void 0) {
    result2.lat2 = result2.latitude_of_2nd_standard_parallel;
  }
  if (result2.latitude_of_projection_centre !== void 0) {
    result2.lat0 = result2.latitude_of_projection_centre;
  }
  if (result2.longitude_of_projection_centre !== void 0) {
    result2.longc = result2.longitude_of_projection_centre;
  }
  if (result2.easting_at_false_origin !== void 0) {
    result2.x0 = result2.easting_at_false_origin;
  }
  if (result2.northing_at_false_origin !== void 0) {
    result2.y0 = result2.northing_at_false_origin;
  }
  if (result2.latitude_of_natural_origin !== void 0) {
    result2.lat0 = result2.latitude_of_natural_origin;
  }
  if (result2.longitude_of_natural_origin !== void 0) {
    result2.long0 = result2.longitude_of_natural_origin;
  }
  if (result2.longitude_of_origin !== void 0) {
    result2.long0 = result2.longitude_of_origin;
  }
  if (result2.false_easting !== void 0) {
    result2.x0 = result2.false_easting;
  }
  if (result2.easting_at_projection_centre) {
    result2.x0 = result2.easting_at_projection_centre;
  }
  if (result2.false_northing !== void 0) {
    result2.y0 = result2.false_northing;
  }
  if (result2.northing_at_projection_centre) {
    result2.y0 = result2.northing_at_projection_centre;
  }
  if (result2.standard_parallel_1 !== void 0) {
    result2.lat1 = result2.standard_parallel_1;
  }
  if (result2.standard_parallel_2 !== void 0) {
    result2.lat2 = result2.standard_parallel_2;
  }
  if (result2.scale_factor_at_natural_origin !== void 0) {
    result2.k0 = result2.scale_factor_at_natural_origin;
  }
  if (result2.scale_factor_at_projection_centre !== void 0) {
    result2.k0 = result2.scale_factor_at_projection_centre;
  }
  if (result2.scale_factor_on_pseudo_standard_parallel !== void 0) {
    result2.k0 = result2.scale_factor_on_pseudo_standard_parallel;
  }
  if (result2.azimuth !== void 0) {
    result2.alpha = result2.azimuth;
  }
  if (result2.azimuth_at_projection_centre !== void 0) {
    result2.alpha = result2.azimuth_at_projection_centre;
  }
  if (result2.angle_from_rectified_to_skew_grid) {
    result2.rectified_grid_angle = result2.angle_from_rectified_to_skew_grid;
  }
  applyProjectionDefaults(result2);
  return result2;
}

// node_modules/wkt-parser/index.js
var knownTypes = [
  "PROJECTEDCRS",
  "PROJCRS",
  "GEOGCS",
  "GEOCCS",
  "PROJCS",
  "LOCAL_CS",
  "GEODCRS",
  "GEODETICCRS",
  "GEODETICDATUM",
  "ENGCRS",
  "ENGINEERINGCRS"
];
function rename(obj, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params2.length === 3) {
      obj[outName] = params2[2](obj[outName]);
    }
  }
}
function cleanWKT(wkt) {
  var keys2 = Object.keys(wkt);
  for (var i = 0, ii = keys2.length; i < ii; ++i) {
    var key = keys2[i];
    if (knownTypes.indexOf(key) !== -1) {
      setPropertiesFromWkt(wkt[key]);
    }
    if (typeof wkt[key] === "object") {
      cleanWKT(wkt[key]);
    }
  }
}
function setPropertiesFromWkt(wkt) {
  if (wkt.AUTHORITY) {
    var authority = Object.keys(wkt.AUTHORITY)[0];
    if (authority && authority in wkt.AUTHORITY) {
      wkt.title = authority + ":" + wkt.AUTHORITY[authority];
    }
  }
  if (wkt.type === "GEOGCS") {
    wkt.projName = "longlat";
  } else if (wkt.type === "LOCAL_CS") {
    wkt.projName = "identity";
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = "";
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === "metre") {
      wkt.units = "meter";
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === "GEOGCS") {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === "GEOGCS") {
    geogcs = wkt;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === "d_") {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === "new_zealand_1949") {
      wkt.datumCode = "nzgd49";
    }
    if (wkt.datumCode === "wgs_1984" || wkt.datumCode === "world_geodetic_system_1984") {
      if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt.sphere = true;
      }
      wkt.datumCode = "wgs84";
    }
    if (wkt.datumCode === "belge_1972") {
      wkt.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = "intl";
      }
      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf("osgb_1936")) {
      wkt.datumCode = "osgb36";
    }
    if (~wkt.datumCode.indexOf("osni_1952")) {
      wkt.datumCode = "osni52";
    }
    if (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt.datumCode = "ire65";
    }
    if (wkt.datumCode === "ch1903+") {
      wkt.datumCode = "ch1903";
    }
    if (~wkt.datumCode.indexOf("israel")) {
      wkt.datumCode = "isr93";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }
  if (wkt.rectified_grid_angle) {
    wkt.rectified_grid_angle = d2r(wkt.rectified_grid_angle);
  }
  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  applyProjectionDefaults(wkt);
}
function wkt_parser_default(wkt) {
  if (typeof wkt === "object") {
    return transformPROJJSON(wkt);
  }
  const version = detectWKTVersion(wkt);
  var lisp = parser_default(wkt);
  if (version === "WKT2") {
    const projjson = buildPROJJSON(lisp);
    return transformPROJJSON(projjson);
  }
  var type = lisp[0];
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj[type];
}

// node_modules/proj4/lib/defs.js
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[
          /** @type {string} */
          name
        ] = projString_default(arguments[1]);
      } else {
        defs[
          /** @type {string} */
          name
        ] = wkt_parser_default(arguments[1]);
      }
    } else {
      defs[
        /** @type {string} */
        name
      ] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v2) {
        if (Array.isArray(v2)) {
          return defs.apply(that, v2);
        } else {
          return defs(v2);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
global_default(defs);
var defs_default = defs;

// node_modules/proj4/lib/parseCode.js
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs_default;
}
function testWKT(code) {
  return code.indexOf("+") !== 0 && code.indexOf("[") !== -1 || typeof code === "object" && !("srsCode" in code);
}
var codes = ["3857", "900913", "3785", "102113"];
function checkMercator(item) {
  var auth = match(item, "authority");
  if (!auth) {
    return;
  }
  var code = match(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, "extension");
  if (!ext) {
    return;
  }
  return match(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs_default[code];
    }
    if (testWKT(code)) {
      var out = wkt_parser_default(code);
      if (checkMercator(out)) {
        return defs_default["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString_default(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projString_default(code);
    }
  } else if (!("projName" in code)) {
    return wkt_parser_default(code);
  } else {
    return code;
  }
}
var parseCode_default = parse;

// node_modules/proj4/lib/extend.js
function extend_default(destination2, source) {
  destination2 = destination2 || {};
  var value, property2;
  if (!source) {
    return destination2;
  }
  for (property2 in source) {
    value = source[property2];
    if (value !== void 0) {
      destination2[property2] = value;
    }
  }
  return destination2;
}

// node_modules/proj4/lib/common/msfnz.js
function msfnz_default(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}

// node_modules/proj4/lib/common/sign.js
function sign_default(x) {
  return x < 0 ? -1 : 1;
}

// node_modules/proj4/lib/common/adjust_lon.js
function adjust_lon_default(x) {
  return Math.abs(x) <= SPI ? x : x - sign_default(x) * TWO_PI;
}

// node_modules/proj4/lib/common/tsfnz.js
function tsfnz_default(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}

// node_modules/proj4/lib/common/phi2z.js
function phi2z_default(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}

// node_modules/proj4/lib/projections/merc.js
function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz_default(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}
function inverse3(p) {
  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon_default(this.long0 + x / (this.a * this.k0));
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "Mercator_Variant_A", "merc"];
var merc_default = {
  init,
  forward,
  inverse: inverse3,
  names
};

// node_modules/proj4/lib/projections/longlat.js
function init2() {
}
function identity2(pt) {
  return pt;
}
var names2 = ["longlat", "identity"];
var longlat_default = {
  init: init2,
  forward: identity2,
  inverse: identity2,
  names: names2
};

// node_modules/proj4/lib/projections.js
var projs = [merc_default, longlat_default];
var names3 = {};
var projStore = [];
function add5(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names3[n.toLowerCase()] = len;
  });
  return this;
}
function getNormalizedProjName(n) {
  return n.replace(/[-\(\)\s]+/g, " ").trim().replace(/ /g, "_");
}
function get5(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names3[n] !== "undefined" && projStore[names3[n]]) {
    return projStore[names3[n]];
  }
  n = getNormalizedProjName(n);
  if (n in names3 && projStore[names3[n]]) {
    return projStore[names3[n]];
  }
}
function start() {
  projs.forEach(add5);
}
var projections_default = {
  start,
  add: add5,
  get: get5
};

// node_modules/proj4/lib/constants/Ellipsoid.js
var ellipsoids = {
  MERIT: {
    a: 6378137,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  },
  SGS85: {
    a: 6378136,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  },
  GRS80: {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  },
  IAU76: {
    a: 6378140,
    rf: 298.257,
    ellipseName: "IAU 1976"
  },
  airy: {
    a: 6377563396e-3,
    b: 635625691e-2,
    ellipseName: "Airy 1830"
  },
  APL4: {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  },
  NWL9D: {
    a: 6378145,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  },
  mod_airy: {
    a: 6377340189e-3,
    b: 6356034446e-3,
    ellipseName: "Modified Airy"
  },
  andrae: {
    a: 637710443e-2,
    rf: 300,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  },
  aust_SA: {
    a: 6378160,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  },
  GRS67: {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: "GRS 67(IUGG 1967)"
  },
  bessel: {
    a: 6377397155e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  },
  bess_nam: {
    a: 6377483865e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  },
  clrk66: {
    a: 63782064e-1,
    b: 63565838e-1,
    ellipseName: "Clarke 1866"
  },
  clrk80: {
    a: 6378249145e-3,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  },
  clrk80ign: {
    a: 63782492e-1,
    b: 6356515,
    rf: 293.4660213,
    ellipseName: "Clarke 1880 (IGN)"
  },
  clrk58: {
    a: 6378293645208759e-9,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  },
  CPM: {
    a: 63757387e-1,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  },
  delmbr: {
    a: 6376428,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  },
  engelis: {
    a: 637813605e-2,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  },
  evrst30: {
    a: 6377276345e-3,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  },
  evrst48: {
    a: 6377304063e-3,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  },
  evrst56: {
    a: 6377301243e-3,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  },
  evrst69: {
    a: 6377295664e-3,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  },
  evrstSS: {
    a: 6377298556e-3,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  },
  fschr60: {
    a: 6378166,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  },
  fschr60m: {
    a: 6378155,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  },
  fschr68: {
    a: 6378150,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  },
  helmert: {
    a: 6378200,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  },
  hough: {
    a: 6378270,
    rf: 297,
    ellipseName: "Hough"
  },
  intl: {
    a: 6378388,
    rf: 297,
    ellipseName: "International 1909 (Hayford)"
  },
  kaula: {
    a: 6378163,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  },
  lerch: {
    a: 6378139,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  },
  mprts: {
    a: 6397300,
    rf: 191,
    ellipseName: "Maupertius 1738"
  },
  new_intl: {
    a: 63781575e-1,
    b: 63567722e-1,
    ellipseName: "New International 1967"
  },
  plessis: {
    a: 6376523,
    rf: 6355863,
    ellipseName: "Plessis 1817 (France)"
  },
  krass: {
    a: 6378245,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  },
  SEasia: {
    a: 6378155,
    b: 63567733205e-4,
    ellipseName: "Southeast Asia"
  },
  walbeck: {
    a: 6376896,
    b: 63558348467e-4,
    ellipseName: "Walbeck"
  },
  WGS60: {
    a: 6378165,
    rf: 298.3,
    ellipseName: "WGS 60"
  },
  WGS66: {
    a: 6378145,
    rf: 298.25,
    ellipseName: "WGS 66"
  },
  WGS7: {
    a: 6378135,
    rf: 298.26,
    ellipseName: "WGS 72"
  },
  WGS84: {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  },
  sphere: {
    a: 6370997,
    b: 6370997,
    ellipseName: "Normal Sphere (r=6370997)"
  }
};
var Ellipsoid_default = ellipsoids;

// node_modules/proj4/lib/deriveConstants.js
var WGS84 = Ellipsoid_default.WGS84;
function eccentricity(a, b, rf, R_A) {
  var a2 = a * a;
  var b2 = b * b;
  var es = (a2 - b2) / a2;
  var e = 0;
  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es);
  }
  var ep2 = (a2 - b2) / b2;
  return {
    es,
    e,
    ep2
  };
}
function sphere(a, b, rf, ellps, sphere2) {
  if (!a) {
    var ellipse = match(Ellipsoid_default, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b) {
    b = (1 - 1 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere2 = true;
    b = a;
  }
  return {
    a,
    b,
    rf,
    sphere: sphere2
  };
}

// node_modules/proj4/lib/constants/Datum.js
var datums = {
  wgs84: {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  },
  ch1903: {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  },
  ggrs87: {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  },
  nad83: {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  },
  nad27: {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  },
  potsdam: {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  },
  carthage: {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  },
  hermannskogel: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  },
  mgi: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Militar-Geographische Institut"
  },
  osni52: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  },
  ire65: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  },
  rassadiran: {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  },
  nzgd49: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  },
  osgb36: {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Ordnance Survey of Great Britain 1936"
  },
  s_jtsk: {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
  },
  beduaram: {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
  },
  gunung_segara: {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
  },
  rnb72: {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  },
  EPSG_5451: {
    towgs84: "6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649"
  },
  IGNF_LURESG: {
    towgs84: "-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43"
  },
  EPSG_4614: {
    towgs84: "-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065"
  },
  EPSG_4615: {
    towgs84: "-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748"
  },
  ESRI_37241: {
    towgs84: "-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031"
  },
  ESRI_37249: {
    towgs84: "-440.296,58.548,296.265,1.128,10.202,4.559,-0.438"
  },
  ESRI_37245: {
    towgs84: "-511.151,-181.269,139.609,1.05,2.703,1.798,3.071"
  },
  EPSG_4178: {
    towgs84: "24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01"
  },
  EPSG_4622: {
    towgs84: "-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984"
  },
  EPSG_4625: {
    towgs84: "126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227"
  },
  EPSG_5252: {
    towgs84: "0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439"
  },
  EPSG_4314: {
    towgs84: "597.1,71.4,412.1,0.894,0.068,-1.563,7.58"
  },
  EPSG_4282: {
    towgs84: "-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166"
  },
  EPSG_4231: {
    towgs84: "-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218"
  },
  EPSG_4274: {
    towgs84: "-230.994,102.591,25.199,0.633,-0.239,0.9,1.95"
  },
  EPSG_4134: {
    towgs84: "-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006"
  },
  EPSG_4254: {
    towgs84: "18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013"
  },
  EPSG_4159: {
    towgs84: "-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175"
  },
  EPSG_4687: {
    towgs84: "0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093"
  },
  EPSG_4227: {
    towgs84: "-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225"
  },
  EPSG_4746: {
    towgs84: "599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46"
  },
  EPSG_4745: {
    towgs84: "612.4,77,440.2,-0.054,0.057,-2.797,2.55"
  },
  EPSG_6311: {
    towgs84: "8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926"
  },
  EPSG_4289: {
    towgs84: "565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244"
  },
  EPSG_4230: {
    towgs84: "-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4"
  },
  EPSG_4154: {
    towgs84: "-123.02,-158.95,-168.47"
  },
  EPSG_4156: {
    towgs84: "570.8,85.7,462.8,4.998,1.587,5.261,3.56"
  },
  EPSG_4299: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4179: {
    towgs84: "33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84"
  },
  EPSG_4313: {
    towgs84: "-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747"
  },
  EPSG_4194: {
    towgs84: "163.511,127.533,-159.789"
  },
  EPSG_4195: {
    towgs84: "105,326,-102.5"
  },
  EPSG_4196: {
    towgs84: "-45,417,-3.5"
  },
  EPSG_4611: {
    towgs84: "-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246"
  },
  EPSG_4633: {
    towgs84: "137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824"
  },
  EPSG_4641: {
    towgs84: "-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993"
  },
  EPSG_4643: {
    towgs84: "-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002"
  },
  EPSG_4300: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4188: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4660: {
    towgs84: "982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805"
  },
  EPSG_4662: {
    towgs84: "97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259"
  },
  EPSG_3906: {
    towgs84: "577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664"
  },
  EPSG_4307: {
    towgs84: "-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547"
  },
  EPSG_6892: {
    towgs84: "-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686"
  },
  EPSG_4690: {
    towgs84: "221.597,152.441,176.523,2.403,1.3893,0.884,11.4648"
  },
  EPSG_4691: {
    towgs84: "218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817"
  },
  EPSG_4629: {
    towgs84: "72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653"
  },
  EPSG_4630: {
    towgs84: "165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111"
  },
  EPSG_4692: {
    towgs84: "217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093"
  },
  EPSG_9333: {
    towgs84: "0,0,0,-8.393,0.749,-10.276,0"
  },
  EPSG_9059: {
    towgs84: "0,0,0"
  },
  EPSG_4312: {
    towgs84: "601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887"
  },
  EPSG_4123: {
    towgs84: "-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496"
  },
  EPSG_4309: {
    towgs84: "-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365"
  },
  ESRI_104106: {
    towgs84: "-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058"
  },
  EPSG_4281: {
    towgs84: "-219.247,-73.802,269.529"
  },
  EPSG_4322: {
    towgs84: "0,0,4.5"
  },
  EPSG_4324: {
    towgs84: "0,0,1.9"
  },
  EPSG_4284: {
    towgs84: "43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549"
  },
  EPSG_4277: {
    towgs84: "446.448,-125.157,542.06,0.15,0.247,0.842,-20.489"
  },
  EPSG_4207: {
    towgs84: "-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46"
  },
  EPSG_4688: {
    towgs84: "347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647"
  },
  EPSG_4689: {
    towgs84: "410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218"
  },
  EPSG_4720: {
    towgs84: "0,0,4.5"
  },
  EPSG_4273: {
    towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
  },
  EPSG_4240: {
    towgs84: "204.64,834.74,293.8"
  },
  EPSG_4817: {
    towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
  },
  ESRI_104131: {
    towgs84: "426.62,142.62,460.09,4.98,4.49,-12.42,-17.1"
  },
  EPSG_4265: {
    towgs84: "-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68"
  },
  EPSG_4263: {
    towgs84: "-111.92,-87.85,114.5,1.875,0.202,0.219,0.032"
  },
  EPSG_4298: {
    towgs84: "-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536"
  },
  EPSG_4270: {
    towgs84: "-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424"
  },
  EPSG_4229: {
    towgs84: "-121.8,98.1,-10.7"
  },
  EPSG_4220: {
    towgs84: "-55.5,-348,-229.2"
  },
  EPSG_4214: {
    towgs84: "12.646,-155.176,-80.863"
  },
  EPSG_4232: {
    towgs84: "-345,3,223"
  },
  EPSG_4238: {
    towgs84: "-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037"
  },
  EPSG_4168: {
    towgs84: "-170,33,326"
  },
  EPSG_4131: {
    towgs84: "199,931,318.9"
  },
  EPSG_4152: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_5228: {
    towgs84: "572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378"
  },
  EPSG_8351: {
    towgs84: "485.021,169.465,483.839,7.786342,4.397554,4.102655,0"
  },
  EPSG_4683: {
    towgs84: "-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06"
  },
  EPSG_4133: {
    towgs84: "0,0,0"
  },
  EPSG_7373: {
    towgs84: "0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693"
  },
  EPSG_9075: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_9072: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_9294: {
    towgs84: "1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388"
  },
  EPSG_4212: {
    towgs84: "-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492"
  },
  EPSG_4191: {
    towgs84: "-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703"
  },
  EPSG_4237: {
    towgs84: "52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191"
  },
  EPSG_4740: {
    towgs84: "-1.08,-0.27,-0.9"
  },
  EPSG_4124: {
    towgs84: "419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496"
  },
  EPSG_5681: {
    towgs84: "584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922"
  },
  EPSG_4141: {
    towgs84: "23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262"
  },
  EPSG_4204: {
    towgs84: "-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194"
  },
  EPSG_4319: {
    towgs84: "226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798"
  },
  EPSG_4200: {
    towgs84: "24.82,-131.21,-82.66"
  },
  EPSG_4130: {
    towgs84: "0,0,0"
  },
  EPSG_4127: {
    towgs84: "-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359"
  },
  EPSG_4149: {
    towgs84: "674.374,15.056,405.346"
  },
  EPSG_4617: {
    towgs84: "-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0"
  },
  EPSG_4663: {
    towgs84: "-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485"
  },
  EPSG_4664: {
    towgs84: "-211.939,137.626,58.3,-0.089,0.251,0.079,0.384"
  },
  EPSG_4665: {
    towgs84: "-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048"
  },
  EPSG_4666: {
    towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
  },
  EPSG_4756: {
    towgs84: "-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188"
  },
  EPSG_4723: {
    towgs84: "-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925"
  },
  EPSG_4726: {
    towgs84: "8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081"
  },
  EPSG_4267: {
    towgs84: "-8.0,160.0,176.0"
  },
  EPSG_5365: {
    towgs84: "-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693"
  },
  EPSG_4218: {
    towgs84: "304.5,306.5,-318.1"
  },
  EPSG_4242: {
    towgs84: "-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95"
  },
  EPSG_4216: {
    towgs84: "-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289"
  },
  ESRI_104105: {
    towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
  },
  ESRI_104129: {
    towgs84: "0,0,0"
  },
  EPSG_4673: {
    towgs84: "174.05,-25.49,112.57"
  },
  EPSG_4202: {
    towgs84: "-124,-60,154"
  },
  EPSG_4203: {
    towgs84: "-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191"
  },
  EPSG_3819: {
    towgs84: "595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408"
  },
  EPSG_8694: {
    towgs84: "-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169"
  },
  EPSG_4145: {
    towgs84: "275.57,676.78,229.6"
  },
  EPSG_4283: {
    towgs84: "61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994"
  },
  EPSG_4317: {
    towgs84: "2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266"
  },
  EPSG_4272: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993"
  },
  EPSG_4248: {
    towgs84: "-307.7,265.3,-363.5"
  },
  EPSG_5561: {
    towgs84: "24,-121,-76"
  },
  EPSG_5233: {
    towgs84: "-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338"
  },
  ESRI_104130: {
    towgs84: "-86,-98,-119"
  },
  ESRI_104102: {
    towgs84: "682,-203,480"
  },
  ESRI_37207: {
    towgs84: "7,-10,-26"
  },
  EPSG_4675: {
    towgs84: "59.935,118.4,-10.871"
  },
  ESRI_104109: {
    towgs84: "-89.121,-348.182,260.871"
  },
  ESRI_104112: {
    towgs84: "-185.583,-230.096,281.361"
  },
  ESRI_104113: {
    towgs84: "25.1,-275.6,222.6"
  },
  IGNF_WGS72G: {
    towgs84: "0,12,6"
  },
  IGNF_NTFG: {
    towgs84: "-168,-60,320"
  },
  IGNF_EFATE57G: {
    towgs84: "-127,-769,472"
  },
  IGNF_PGP50G: {
    towgs84: "324.8,153.6,172.1"
  },
  IGNF_REUN47G: {
    towgs84: "94,-948,-1262"
  },
  IGNF_CSG67G: {
    towgs84: "-186,230,110"
  },
  IGNF_GUAD48G: {
    towgs84: "-467,-16,-300"
  },
  IGNF_TAHI51G: {
    towgs84: "162,117,154"
  },
  IGNF_TAHAAG: {
    towgs84: "65,342,77"
  },
  IGNF_NUKU72G: {
    towgs84: "84,274,65"
  },
  IGNF_PETRELS72G: {
    towgs84: "365,194,166"
  },
  IGNF_WALL78G: {
    towgs84: "253,-133,-127"
  },
  IGNF_MAYO50G: {
    towgs84: "-382,-59,-262"
  },
  IGNF_TANNAG: {
    towgs84: "-139,-967,436"
  },
  IGNF_IGN72G: {
    towgs84: "-13,-348,292"
  },
  IGNF_ATIGG: {
    towgs84: "1118,23,66"
  },
  IGNF_FANGA84G: {
    towgs84: "150.57,158.33,118.32"
  },
  IGNF_RUSAT84G: {
    towgs84: "202.13,174.6,-15.74"
  },
  IGNF_KAUE70G: {
    towgs84: "126.74,300.1,-75.49"
  },
  IGNF_MOP90G: {
    towgs84: "-10.8,-1.8,12.77"
  },
  IGNF_MHPF67G: {
    towgs84: "338.08,212.58,-296.17"
  },
  IGNF_TAHI79G: {
    towgs84: "160.61,116.05,153.69"
  },
  IGNF_ANAA92G: {
    towgs84: "1.5,3.84,4.81"
  },
  IGNF_MARQUI72G: {
    towgs84: "330.91,-13.92,58.56"
  },
  IGNF_APAT86G: {
    towgs84: "143.6,197.82,74.05"
  },
  IGNF_TUBU69G: {
    towgs84: "237.17,171.61,-77.84"
  },
  IGNF_STPM50G: {
    towgs84: "11.363,424.148,373.13"
  },
  EPSG_4150: {
    towgs84: "674.374,15.056,405.346"
  },
  EPSG_4754: {
    towgs84: "-208.4058,-109.8777,-2.5764"
  },
  ESRI_104101: {
    towgs84: "374,150,588"
  },
  EPSG_4693: {
    towgs84: "0,-0.15,0.68"
  },
  EPSG_6207: {
    towgs84: "293.17,726.18,245.36"
  },
  EPSG_4153: {
    towgs84: "-133.63,-157.5,-158.62"
  },
  EPSG_4132: {
    towgs84: "-241.54,-163.64,396.06"
  },
  EPSG_4221: {
    towgs84: "-154.5,150.7,100.4"
  },
  EPSG_4266: {
    towgs84: "-80.7,-132.5,41.1"
  },
  EPSG_4193: {
    towgs84: "-70.9,-151.8,-41.4"
  },
  EPSG_5340: {
    towgs84: "-0.41,0.46,-0.35"
  },
  EPSG_4246: {
    towgs84: "-294.7,-200.1,525.5"
  },
  EPSG_4318: {
    towgs84: "-3.2,-5.7,2.8"
  },
  EPSG_4121: {
    towgs84: "-199.87,74.79,246.62"
  },
  EPSG_4223: {
    towgs84: "-260.1,5.5,432.2"
  },
  EPSG_4158: {
    towgs84: "-0.465,372.095,171.736"
  },
  EPSG_4285: {
    towgs84: "-128.16,-282.42,21.93"
  },
  EPSG_4613: {
    towgs84: "-404.78,685.68,45.47"
  },
  EPSG_4607: {
    towgs84: "195.671,332.517,274.607"
  },
  EPSG_4475: {
    towgs84: "-381.788,-57.501,-256.673"
  },
  EPSG_4208: {
    towgs84: "-157.84,308.54,-146.6"
  },
  EPSG_4743: {
    towgs84: "70.995,-335.916,262.898"
  },
  EPSG_4710: {
    towgs84: "-323.65,551.39,-491.22"
  },
  EPSG_7881: {
    towgs84: "-0.077,0.079,0.086"
  },
  EPSG_4682: {
    towgs84: "283.729,735.942,261.143"
  },
  EPSG_4739: {
    towgs84: "-156,-271,-189"
  },
  EPSG_4679: {
    towgs84: "-80.01,253.26,291.19"
  },
  EPSG_4750: {
    towgs84: "-56.263,16.136,-22.856"
  },
  EPSG_4644: {
    towgs84: "-10.18,-350.43,291.37"
  },
  EPSG_4695: {
    towgs84: "-103.746,-9.614,-255.95"
  },
  EPSG_4292: {
    towgs84: "-355,21,72"
  },
  EPSG_4302: {
    towgs84: "-61.702,284.488,472.052"
  },
  EPSG_4143: {
    towgs84: "-124.76,53,466.79"
  },
  EPSG_4606: {
    towgs84: "-153,153,307"
  },
  EPSG_4699: {
    towgs84: "-770.1,158.4,-498.2"
  },
  EPSG_4247: {
    towgs84: "-273.5,110.6,-357.9"
  },
  EPSG_4160: {
    towgs84: "8.88,184.86,106.69"
  },
  EPSG_4161: {
    towgs84: "-233.43,6.65,173.64"
  },
  EPSG_9251: {
    towgs84: "-9.5,122.9,138.2"
  },
  EPSG_9253: {
    towgs84: "-78.1,101.6,133.3"
  },
  EPSG_4297: {
    towgs84: "-198.383,-240.517,-107.909"
  },
  EPSG_4269: {
    towgs84: "0,0,0"
  },
  EPSG_4301: {
    towgs84: "-147,506,687"
  },
  EPSG_4618: {
    towgs84: "-59,-11,-52"
  },
  EPSG_4612: {
    towgs84: "0,0,0"
  },
  EPSG_4678: {
    towgs84: "44.585,-131.212,-39.544"
  },
  EPSG_4250: {
    towgs84: "-130,29,364"
  },
  EPSG_4144: {
    towgs84: "214,804,268"
  },
  EPSG_4147: {
    towgs84: "-17.51,-108.32,-62.39"
  },
  EPSG_4259: {
    towgs84: "-254.1,-5.36,-100.29"
  },
  EPSG_4164: {
    towgs84: "-76,-138,67"
  },
  EPSG_4211: {
    towgs84: "-378.873,676.002,-46.255"
  },
  EPSG_4182: {
    towgs84: "-422.651,-172.995,84.02"
  },
  EPSG_4224: {
    towgs84: "-143.87,243.37,-33.52"
  },
  EPSG_4225: {
    towgs84: "-205.57,168.77,-4.12"
  },
  EPSG_5527: {
    towgs84: "-67.35,3.88,-38.22"
  },
  EPSG_4752: {
    towgs84: "98,390,-22"
  },
  EPSG_4310: {
    towgs84: "-30,190,89"
  },
  EPSG_9248: {
    towgs84: "-192.26,65.72,132.08"
  },
  EPSG_4680: {
    towgs84: "124.5,-63.5,-281"
  },
  EPSG_4701: {
    towgs84: "-79.9,-158,-168.9"
  },
  EPSG_4706: {
    towgs84: "-146.21,112.63,4.05"
  },
  EPSG_4805: {
    towgs84: "682,-203,480"
  },
  EPSG_4201: {
    towgs84: "-165,-11,206"
  },
  EPSG_4210: {
    towgs84: "-157,-2,-299"
  },
  EPSG_4183: {
    towgs84: "-104,167,-38"
  },
  EPSG_4139: {
    towgs84: "11,72,-101"
  },
  EPSG_4668: {
    towgs84: "-86,-98,-119"
  },
  EPSG_4717: {
    towgs84: "-2,151,181"
  },
  EPSG_4732: {
    towgs84: "102,52,-38"
  },
  EPSG_4280: {
    towgs84: "-377,681,-50"
  },
  EPSG_4209: {
    towgs84: "-138,-105,-289"
  },
  EPSG_4261: {
    towgs84: "31,146,47"
  },
  EPSG_4658: {
    towgs84: "-73,46,-86"
  },
  EPSG_4721: {
    towgs84: "265.025,384.929,-194.046"
  },
  EPSG_4222: {
    towgs84: "-136,-108,-292"
  },
  EPSG_4601: {
    towgs84: "-255,-15,71"
  },
  EPSG_4602: {
    towgs84: "725,685,536"
  },
  EPSG_4603: {
    towgs84: "72,213.7,93"
  },
  EPSG_4605: {
    towgs84: "9,183,236"
  },
  EPSG_4621: {
    towgs84: "137,248,-430"
  },
  EPSG_4657: {
    towgs84: "-28,199,5"
  },
  EPSG_4316: {
    towgs84: "103.25,-100.4,-307.19"
  },
  EPSG_4642: {
    towgs84: "-13,-348,292"
  },
  EPSG_4698: {
    towgs84: "145,-187,103"
  },
  EPSG_4192: {
    towgs84: "-206.1,-174.7,-87.7"
  },
  EPSG_4311: {
    towgs84: "-265,120,-358"
  },
  EPSG_4135: {
    towgs84: "58,-283,-182"
  },
  ESRI_104138: {
    towgs84: "198,-226,-347"
  },
  EPSG_4245: {
    towgs84: "-11,851,5"
  },
  EPSG_4142: {
    towgs84: "-125,53,467"
  },
  EPSG_4213: {
    towgs84: "-106,-87,188"
  },
  EPSG_4253: {
    towgs84: "-133,-77,-51"
  },
  EPSG_4129: {
    towgs84: "-132,-110,-335"
  },
  EPSG_4713: {
    towgs84: "-77,-128,142"
  },
  EPSG_4239: {
    towgs84: "217,823,299"
  },
  EPSG_4146: {
    towgs84: "295,736,257"
  },
  EPSG_4155: {
    towgs84: "-83,37,124"
  },
  EPSG_4165: {
    towgs84: "-173,253,27"
  },
  EPSG_4672: {
    towgs84: "175,-38,113"
  },
  EPSG_4236: {
    towgs84: "-637,-549,-203"
  },
  EPSG_4251: {
    towgs84: "-90,40,88"
  },
  EPSG_4271: {
    towgs84: "-2,374,172"
  },
  EPSG_4175: {
    towgs84: "-88,4,101"
  },
  EPSG_4716: {
    towgs84: "298,-304,-375"
  },
  EPSG_4315: {
    towgs84: "-23,259,-9"
  },
  EPSG_4744: {
    towgs84: "-242.2,-144.9,370.3"
  },
  EPSG_4244: {
    towgs84: "-97,787,86"
  },
  EPSG_4293: {
    towgs84: "616,97,-251"
  },
  EPSG_4714: {
    towgs84: "-127,-769,472"
  },
  EPSG_4736: {
    towgs84: "260,12,-147"
  },
  EPSG_6883: {
    towgs84: "-235,-110,393"
  },
  EPSG_6894: {
    towgs84: "-63,176,185"
  },
  EPSG_4205: {
    towgs84: "-43,-163,45"
  },
  EPSG_4256: {
    towgs84: "41,-220,-134"
  },
  EPSG_4262: {
    towgs84: "639,405,60"
  },
  EPSG_4604: {
    towgs84: "174,359,365"
  },
  EPSG_4169: {
    towgs84: "-115,118,426"
  },
  EPSG_4620: {
    towgs84: "-106,-129,165"
  },
  EPSG_4184: {
    towgs84: "-203,141,53"
  },
  EPSG_4616: {
    towgs84: "-289,-124,60"
  },
  EPSG_9403: {
    towgs84: "-307,-92,127"
  },
  EPSG_4684: {
    towgs84: "-133,-321,50"
  },
  EPSG_4708: {
    towgs84: "-491,-22,435"
  },
  EPSG_4707: {
    towgs84: "114,-116,-333"
  },
  EPSG_4709: {
    towgs84: "145,75,-272"
  },
  EPSG_4712: {
    towgs84: "-205,107,53"
  },
  EPSG_4711: {
    towgs84: "124,-234,-25"
  },
  EPSG_4718: {
    towgs84: "230,-199,-752"
  },
  EPSG_4719: {
    towgs84: "211,147,111"
  },
  EPSG_4724: {
    towgs84: "208,-435,-229"
  },
  EPSG_4725: {
    towgs84: "189,-79,-202"
  },
  EPSG_4735: {
    towgs84: "647,1777,-1124"
  },
  EPSG_4722: {
    towgs84: "-794,119,-298"
  },
  EPSG_4728: {
    towgs84: "-307,-92,127"
  },
  EPSG_4734: {
    towgs84: "-632,438,-609"
  },
  EPSG_4727: {
    towgs84: "912,-58,1227"
  },
  EPSG_4729: {
    towgs84: "185,165,42"
  },
  EPSG_4730: {
    towgs84: "170,42,84"
  },
  EPSG_4733: {
    towgs84: "276,-57,149"
  },
  ESRI_37218: {
    towgs84: "230,-199,-752"
  },
  ESRI_37240: {
    towgs84: "-7,215,225"
  },
  ESRI_37221: {
    towgs84: "252,-209,-751"
  },
  ESRI_4305: {
    towgs84: "-123,-206,219"
  },
  ESRI_104139: {
    towgs84: "-73,-247,227"
  },
  EPSG_4748: {
    towgs84: "51,391,-36"
  },
  EPSG_4219: {
    towgs84: "-384,664,-48"
  },
  EPSG_4255: {
    towgs84: "-333,-222,114"
  },
  EPSG_4257: {
    towgs84: "-587.8,519.75,145.76"
  },
  EPSG_4646: {
    towgs84: "-963,510,-359"
  },
  EPSG_6881: {
    towgs84: "-24,-203,268"
  },
  EPSG_6882: {
    towgs84: "-183,-15,273"
  },
  EPSG_4715: {
    towgs84: "-104,-129,239"
  },
  IGNF_RGF93GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGM04GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGSPM06GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGTAAF07GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGFG95GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGNCG: {
    towgs84: "0,0,0"
  },
  IGNF_RGPFGDD: {
    towgs84: "0,0,0"
  },
  IGNF_ETRS89G: {
    towgs84: "0,0,0"
  },
  IGNF_RGR92GDD: {
    towgs84: "0,0,0"
  },
  EPSG_4173: {
    towgs84: "0,0,0"
  },
  EPSG_4180: {
    towgs84: "0,0,0"
  },
  EPSG_4619: {
    towgs84: "0,0,0"
  },
  EPSG_4667: {
    towgs84: "0,0,0"
  },
  EPSG_4075: {
    towgs84: "0,0,0"
  },
  EPSG_6706: {
    towgs84: "0,0,0"
  },
  EPSG_7798: {
    towgs84: "0,0,0"
  },
  EPSG_4661: {
    towgs84: "0,0,0"
  },
  EPSG_4669: {
    towgs84: "0,0,0"
  },
  EPSG_8685: {
    towgs84: "0,0,0"
  },
  EPSG_4151: {
    towgs84: "0,0,0"
  },
  EPSG_9702: {
    towgs84: "0,0,0"
  },
  EPSG_4758: {
    towgs84: "0,0,0"
  },
  EPSG_4761: {
    towgs84: "0,0,0"
  },
  EPSG_4765: {
    towgs84: "0,0,0"
  },
  EPSG_8997: {
    towgs84: "0,0,0"
  },
  EPSG_4023: {
    towgs84: "0,0,0"
  },
  EPSG_4670: {
    towgs84: "0,0,0"
  },
  EPSG_4694: {
    towgs84: "0,0,0"
  },
  EPSG_4148: {
    towgs84: "0,0,0"
  },
  EPSG_4163: {
    towgs84: "0,0,0"
  },
  EPSG_4167: {
    towgs84: "0,0,0"
  },
  EPSG_4189: {
    towgs84: "0,0,0"
  },
  EPSG_4190: {
    towgs84: "0,0,0"
  },
  EPSG_4176: {
    towgs84: "0,0,0"
  },
  EPSG_4659: {
    towgs84: "0,0,0"
  },
  EPSG_3824: {
    towgs84: "0,0,0"
  },
  EPSG_3889: {
    towgs84: "0,0,0"
  },
  EPSG_4046: {
    towgs84: "0,0,0"
  },
  EPSG_4081: {
    towgs84: "0,0,0"
  },
  EPSG_4558: {
    towgs84: "0,0,0"
  },
  EPSG_4483: {
    towgs84: "0,0,0"
  },
  EPSG_5013: {
    towgs84: "0,0,0"
  },
  EPSG_5264: {
    towgs84: "0,0,0"
  },
  EPSG_5324: {
    towgs84: "0,0,0"
  },
  EPSG_5354: {
    towgs84: "0,0,0"
  },
  EPSG_5371: {
    towgs84: "0,0,0"
  },
  EPSG_5373: {
    towgs84: "0,0,0"
  },
  EPSG_5381: {
    towgs84: "0,0,0"
  },
  EPSG_5393: {
    towgs84: "0,0,0"
  },
  EPSG_5489: {
    towgs84: "0,0,0"
  },
  EPSG_5593: {
    towgs84: "0,0,0"
  },
  EPSG_6135: {
    towgs84: "0,0,0"
  },
  EPSG_6365: {
    towgs84: "0,0,0"
  },
  EPSG_5246: {
    towgs84: "0,0,0"
  },
  EPSG_7886: {
    towgs84: "0,0,0"
  },
  EPSG_8431: {
    towgs84: "0,0,0"
  },
  EPSG_8427: {
    towgs84: "0,0,0"
  },
  EPSG_8699: {
    towgs84: "0,0,0"
  },
  EPSG_8818: {
    towgs84: "0,0,0"
  },
  EPSG_4757: {
    towgs84: "0,0,0"
  },
  EPSG_9140: {
    towgs84: "0,0,0"
  },
  EPSG_8086: {
    towgs84: "0,0,0"
  },
  EPSG_4686: {
    towgs84: "0,0,0"
  },
  EPSG_4737: {
    towgs84: "0,0,0"
  },
  EPSG_4702: {
    towgs84: "0,0,0"
  },
  EPSG_4747: {
    towgs84: "0,0,0"
  },
  EPSG_4749: {
    towgs84: "0,0,0"
  },
  EPSG_4674: {
    towgs84: "0,0,0"
  },
  EPSG_4755: {
    towgs84: "0,0,0"
  },
  EPSG_4759: {
    towgs84: "0,0,0"
  },
  EPSG_4762: {
    towgs84: "0,0,0"
  },
  EPSG_4763: {
    towgs84: "0,0,0"
  },
  EPSG_4764: {
    towgs84: "0,0,0"
  },
  EPSG_4166: {
    towgs84: "0,0,0"
  },
  EPSG_4170: {
    towgs84: "0,0,0"
  },
  EPSG_5546: {
    towgs84: "0,0,0"
  },
  EPSG_7844: {
    towgs84: "0,0,0"
  },
  EPSG_4818: {
    towgs84: "589,76,480"
  }
};
for (key in datums) {
  datum2 = datums[key];
  if (!datum2.datumName) {
    continue;
  }
  datums[datum2.datumName] = datum2;
}
var datum2;
var key;
var Datum_default = datums;

// node_modules/proj4/lib/datum.js
function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a;
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var datum_default = datum;

// node_modules/proj4/lib/nadgrid.js
var loadedNadgrids = {};
function nadgrid(key, data, options) {
  if (data instanceof ArrayBuffer) {
    return readNTV2Grid(key, data, options);
  }
  return { ready: readGeotiffGrid(key, data) };
}
function readNTV2Grid(key, data, options) {
  var includeErrorFields = true;
  if (options !== void 0 && options.includeErrorFields === false) {
    includeErrorFields = false;
  }
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  var subgrids = readSubgrids(view, header, isLittleEndian, includeErrorFields);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key] = nadgrid2;
  return nadgrid2;
}
async function readGeotiffGrid(key, tiff) {
  var subgrids = [];
  var subGridCount = await tiff.getImageCount();
  for (var subgridIndex = subGridCount - 1; subgridIndex >= 0; subgridIndex--) {
    var image = await tiff.getImage(subgridIndex);
    var rasters = await image.readRasters();
    var data = rasters;
    var lim = [image.getWidth(), image.getHeight()];
    var imageBBoxRadians = image.getBoundingBox().map(degreesToRadians2);
    var del = [image.fileDirectory.ModelPixelScale[0], image.fileDirectory.ModelPixelScale[1]].map(degreesToRadians2);
    var maxX = imageBBoxRadians[0] + (lim[0] - 1) * del[0];
    var minY = imageBBoxRadians[3] - (lim[1] - 1) * del[1];
    var latitudeOffsetBand = data[0];
    var longitudeOffsetBand = data[1];
    var nodes = [];
    for (let i = lim[1] - 1; i >= 0; i--) {
      for (let j = lim[0] - 1; j >= 0; j--) {
        var index = i * lim[0] + j;
        nodes.push([-secondsToRadians(longitudeOffsetBand[index]), secondsToRadians(latitudeOffsetBand[index])]);
      }
    }
    subgrids.push({
      del,
      lim,
      ll: [-maxX, minY],
      cvs: nodes
    });
  }
  var tifGrid = {
    header: {
      nSubgrids: subGridCount
    },
    subgrids
  };
  loadedNadgrids[key] = tifGrid;
  return tifGrid;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === "@";
  if (optional) {
    value = value.slice(1);
  }
  if (value === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function degreesToRadians2(degrees) {
  return degrees * Math.PI / 180;
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian, includeErrorFields) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian, includeErrorFields);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
    );
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
    );
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
    var rowSize = 16;
    if (includeErrorFields === false) {
      rowSize = 8;
    }
    gridOffset += 176 + subHeader.gridNodeCount * rowSize;
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r) {
    return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
  });
}
function readGridHeader(view, offset2, isLittleEndian) {
  return {
    name: decodeString(view, offset2 + 8, offset2 + 16).trim(),
    parent: decodeString(view, offset2 + 24, offset2 + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset2 + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset2 + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset2 + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset2 + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset2 + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset2 + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset2 + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset2, gridHeader, isLittleEndian, includeErrorFields) {
  var nodesOffset = offset2 + 176;
  var gridRecordLength = 16;
  if (includeErrorFields === false) {
    gridRecordLength = 8;
  }
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian)
    };
    if (includeErrorFields !== false) {
      record.latitudeAccuracy = view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian);
      record.longitudeAccuracy = view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian);
    }
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}

// node_modules/proj4/lib/Proj.js
function Projection2(srsCode, callback) {
  if (!(this instanceof Projection2)) {
    return new Projection2(srsCode);
  }
  this.forward = null;
  this.inverse = null;
  this.init = null;
  this.name;
  this.names = null;
  this.title;
  callback = callback || function(error) {
    if (error) {
      throw error;
    }
  };
  var json = parseCode_default(srsCode);
  if (typeof json !== "object") {
    callback("Could not parse to valid json: " + srsCode);
    return;
  }
  var ourProj = Projection2.projections.get(json.projName);
  if (!ourProj) {
    callback("Could not get projection name from: " + srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== "none") {
    var datumDef = match(Datum_default, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1;
  json.axis = json.axis || "enu";
  json.ellps = json.ellps || "wgs84";
  json.lat1 = json.lat1 || json.lat0;
  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || datum_default(
    json.datumCode,
    json.datum_params,
    sphere_.a,
    sphere_.b,
    ecc.es,
    ecc.ep2,
    nadgrids
  );
  extend_default(this, json);
  extend_default(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  if ("init" in this && typeof this.init === "function") {
    this.init();
  }
  callback(null, this);
}
Projection2.projections = projections_default;
Projection2.projections.start();
var Proj_default = Projection2;

// node_modules/proj4/lib/datumUtils.js
function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false;
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0;
  var Rn;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p, es, a, b) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X = p.x;
  var Y = p.y;
  var Z2 = p.z ? p.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z2 * Z2);
  if (P / a < genau) {
    Longitude = 0;
    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    Longitude = Math.atan2(Y, X);
  }
  CT = Z2 / RR;
  ST = P / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}

// node_modules/proj4/lib/datum_transform.js
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform_default(source, dest, point2) {
  if (compareDatums(source, dest)) {
    return point2;
  }
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point2;
  }
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point2);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point2;
  }
  point2 = geodeticToGeocentric(point2, source_es, source_a);
  if (checkParams(source.datum_type)) {
    point2 = geocentricToWgs84(point2, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point2 = geocentricFromWgs84(point2, dest.datum_type, dest.datum_params);
  }
  point2 = geocentricToGeodetic(point2, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point2);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point2;
}
function applyGridShift(source, inverse35, point2) {
  if (source.grids === null || source.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point2.x, y: point2.y };
  var output = { x: Number.NaN, y: Number.NaN };
  var attemptedGrids = [];
  outer:
    for (var i = 0; i < source.grids.length; i++) {
      var grid = source.grids[i];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrids = grid.grid.subgrids;
      for (var j = 0, jj = subgrids.length; j < jj; j++) {
        var subgrid = subgrids[j];
        var epsilon2 = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
        var minX = subgrid.ll[0] - epsilon2;
        var minY = subgrid.ll[1] - epsilon2;
        var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon2;
        var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon2;
        if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
          continue;
        }
        output = applySubgridShift(input, inverse35, subgrid);
        if (!isNaN(output.x)) {
          break outer;
        }
      }
    }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point2.x = -output.x;
  point2.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse35, ct) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon_default(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse35) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t, ct);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon_default(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct) {
  var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
  var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
  var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = indx.y * ct.lim[0] + indx.x;
  var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx++;
  var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx += ct.lim[0];
  var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx--;
  var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}

// node_modules/proj4/lib/adjust_axis.js
function adjust_axis_default(crs, denorm, point2) {
  var xin = point2.x, yin = point2.y, zin = point2.z || 0;
  var v2, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point2.z === void 0) {
      continue;
    }
    if (i === 0) {
      v2 = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = "x";
      } else {
        t = "y";
      }
    } else if (i === 1) {
      v2 = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = "y";
      } else {
        t = "x";
      }
    } else {
      v2 = zin;
      t = "z";
    }
    switch (crs.axis[i]) {
      case "e":
        out[t] = v2;
        break;
      case "w":
        out[t] = -v2;
        break;
      case "n":
        out[t] = v2;
        break;
      case "s":
        out[t] = -v2;
        break;
      case "u":
        if (point2[t] !== void 0) {
          out.z = v2;
        }
        break;
      case "d":
        if (point2[t] !== void 0) {
          out.z = -v2;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}

// node_modules/proj4/lib/common/toPoint.js
function toPoint_default(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}

// node_modules/proj4/lib/checkSanity.js
function checkSanity_default(point2) {
  checkCoord(point2.x);
  checkCoord(point2.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}

// node_modules/proj4/lib/transform.js
function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== "WGS84";
}
function transform3(source, dest, point2, enforceAxis) {
  var wgs842;
  if (Array.isArray(point2)) {
    point2 = toPoint_default(point2);
  } else {
    point2 = {
      x: point2.x,
      y: point2.y,
      z: point2.z,
      m: point2.m
    };
  }
  var hasZ = point2.z !== void 0;
  checkSanity_default(point2);
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs842 = new Proj_default("WGS84");
    point2 = transform3(source, wgs842, point2, enforceAxis);
    source = wgs842;
  }
  if (enforceAxis && source.axis !== "enu") {
    point2 = adjust_axis_default(source, false, point2);
  }
  if (source.projName === "longlat") {
    point2 = {
      x: point2.x * D2R,
      y: point2.y * D2R,
      z: point2.z || 0
    };
  } else {
    if (source.to_meter) {
      point2 = {
        x: point2.x * source.to_meter,
        y: point2.y * source.to_meter,
        z: point2.z || 0
      };
    }
    point2 = source.inverse(point2);
    if (!point2) {
      return;
    }
  }
  if (source.from_greenwich) {
    point2.x += source.from_greenwich;
  }
  point2 = datum_transform_default(source.datum, dest.datum, point2);
  if (!point2) {
    return;
  }
  point2 = /** @type {import('./core').InterfaceCoordinates} */
  point2;
  if (dest.from_greenwich) {
    point2 = {
      x: point2.x - dest.from_greenwich,
      y: point2.y,
      z: point2.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point2 = {
      x: point2.x * R2D,
      y: point2.y * R2D,
      z: point2.z || 0
    };
  } else {
    point2 = dest.forward(point2);
    if (dest.to_meter) {
      point2 = {
        x: point2.x / dest.to_meter,
        y: point2.y / dest.to_meter,
        z: point2.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis_default(dest, true, point2);
  }
  if (point2 && !hasZ) {
    delete point2.z;
  }
  return point2;
}

// node_modules/proj4/lib/core.js
var wgs84 = Proj_default("WGS84");
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys2;
  if (Array.isArray(coords)) {
    transformedArray = transform3(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return (
            /** @type {T} */
            [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.slice(3))
          );
        } else {
          return (
            /** @type {T} */
            [transformedArray.x, transformedArray.y, coords[2]].concat(coords.slice(3))
          );
        }
      } else {
        return (
          /** @type {T} */
          [transformedArray.x, transformedArray.y].concat(coords.slice(2))
        );
      }
    } else {
      return (
        /** @type {T} */
        [transformedArray.x, transformedArray.y]
      );
    }
  } else {
    out = transform3(from, to, coords, enforceAxis);
    keys2 = Object.keys(coords);
    if (keys2.length === 2) {
      return (
        /** @type {T} */
        out
      );
    }
    keys2.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return (
      /** @type {T} */
      out
    );
  }
}
function checkProj(item) {
  if (item instanceof Proj_default) {
    return item;
  }
  if (typeof item === "object" && "oProj" in item) {
    return item.oProj;
  }
  return Proj_default(
    /** @type {string | PROJJSONDefinition} */
    item
  );
}
function proj4(fromProjOrToProj, toProjOrCoord, coord) {
  var fromProj;
  var toProj;
  var single = false;
  var obj;
  if (typeof toProjOrCoord === "undefined") {
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  } else if (typeof /** @type {?} */
  toProjOrCoord.x !== "undefined" || Array.isArray(toProjOrCoord)) {
    coord = /** @type {T} */
    /** @type {?} */
    toProjOrCoord;
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  }
  if (!fromProj) {
    fromProj = checkProj(fromProjOrToProj);
  }
  if (!toProj) {
    toProj = checkProj(
      /** @type {string | PROJJSONDefinition | proj } */
      toProjOrCoord
    );
  }
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var core_default = proj4;

// node_modules/mgrs/mgrs.js
var NUM_100K_SETS = 6;
var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
var A = 65;
var I = 73;
var O = 79;
var V = 86;
var Z = 90;
var mgrs_default = {
  forward: forward2,
  inverse: inverse4,
  toPoint
};
function forward2(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse4(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
function toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A5, M2;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A5 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M2 = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N * (A5 + (1 - T + C) * A5 * A5 * A5 / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 / 120) + 5e5;
  var UTMNorthing = k0 * (M2 + N * Math.tan(LatRad) * (A5 * A5 / 2 + (5 - T + 9 * C + 4 * C * C) * A5 * A5 * A5 * A5 / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 * A5 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm) {
  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C13, R1, D2, M2;
  var LongOrigin;
  var mu, phi1Rad;
  var x = UTMEasting - 5e5;
  var y = UTMNorthing;
  if (zoneLetter < "N") {
    y -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M2 = y / k0;
  mu = M2 / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C13 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D2 = x / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D2 * D2 / 2 - (5 + 3 * T1 + 10 * C13 - 4 * C13 * C13 - 9 * eccPrimeSquared) * D2 * D2 * D2 * D2 / 24 + (61 + 90 * T1 + 298 * C13 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C13 * C13) * D2 * D2 * D2 * D2 * D2 * D2 / 720);
  lat = radToDeg(lat);
  var lon = (D2 - (1 + 2 * T1 + C13) * D2 * D2 * D2 / 6 + (5 - 2 * C13 + 28 * T1 - 3 * C13 * C13 + 8 * eccPrimeSquared + 24 * T1 * T1) * D2 * D2 * D2 * D2 * D2 / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result2;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result2 = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result2 = {
      lat,
      lon
    };
  }
  return result2;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode(utm, accuracy) {
  var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }
  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }
  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;
    if (colInt === I) {
      colInt++;
    }
  }
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }
  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;
    if (rowInt === I) {
      rowInt++;
    }
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i === 0 || i + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i, i += 2);
  var set2 = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set2);
  var north100k = getNorthingFromChar(hunK.charAt(1), set2);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e, set2) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set2 - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n, set2) {
  if (n > "V") {
    throw "MGRSPoint given invalid Northing " + n;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set2 - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    if (curRow > V) {
      if (rewindMarker) {
        throw "Bad character: " + n;
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}

// node_modules/proj4/lib/Point.js
function Point2(x, y, z) {
  if (!(this instanceof Point2)) {
    return new Point2(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0;
  } else if (typeof x === "object") {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0;
  } else if (typeof x === "string" && typeof y === "undefined") {
    var coords = x.split(",");
    this.x = parseFloat(coords[0]);
    this.y = parseFloat(coords[1]);
    this.z = parseFloat(coords[2]) || 0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Point2.fromMGRS = function(mgrsStr) {
  return new Point2(toPoint(mgrsStr));
};
Point2.prototype.toMGRS = function(accuracy) {
  return forward2([this.x, this.y], accuracy);
};
var Point_default2 = Point2;

// node_modules/proj4/lib/common/pj_enfn.js
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.013020833333333334;
var C48 = 0.007120768229166667;
var C66 = 0.3645833333333333;
var C68 = 0.005696614583333333;
var C88 = 0.3076171875;
function pj_enfn_default(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
}

// node_modules/proj4/lib/common/pj_mlfn.js
function pj_mlfn_default(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}

// node_modules/proj4/lib/common/pj_inv_mlfn.js
var MAX_ITER = 20;
function pj_inv_mlfn_default(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) {
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    t = (pj_mlfn_default(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  return phi;
}

// node_modules/proj4/lib/projections/tmerc.js
function init3() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.ml0 = pj_mlfn_default(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward3(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b) - 1) < EPSLN) {
      return 93;
    } else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);
      if (b >= 1) {
        if (b - 1 > EPSLN) {
          return 93;
        } else {
          y = 0;
        }
      } else {
        y = Math.acos(y);
      }
      if (lat < 0) {
        y = -y;
      }
      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn_default(lat, sin_phi, cos_phi, this.en);
    x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
    y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse5(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);
    if (y < 0) {
      lat = -lat;
    }
    if (g === 0 && h === 0) {
      lon = 0;
    } else {
      lon = adjust_lon_default(Math.atan2(g, h) + this.long0);
    }
  } else {
    con = this.ml0 + y / this.k0;
    phi = pj_inv_mlfn_default(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
      lon = adjust_lon_default(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
    } else {
      lat = HALF_PI * sign_default(y);
      lon = 0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names4 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
var tmerc_default = {
  init: init3,
  forward: forward3,
  inverse: inverse5,
  names: names4
};

// node_modules/proj4/lib/common/sinh.js
function sinh_default(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
}

// node_modules/proj4/lib/common/hypot.js
function hypot_default(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);
  return a * Math.sqrt(1 + Math.pow(b, 2));
}

// node_modules/proj4/lib/common/log1py.js
function log1py_default(x) {
  var y = 1 + x;
  var z = y - 1;
  return z === 0 ? x : x * Math.log(y) / z;
}

// node_modules/proj4/lib/common/asinhy.js
function asinhy_default(x) {
  var y = Math.abs(x);
  y = log1py_default(y * (1 + y / (hypot_default(1, y) + 1)));
  return x < 0 ? -y : y;
}

// node_modules/proj4/lib/common/gatg.js
function gatg_default(pp, B2) {
  var cos_2B = 2 * Math.cos(2 * B2);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;
  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }
  return B2 + h * Math.sin(2 * B2);
}

// node_modules/proj4/lib/common/clens.js
function clens_default(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;
  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }
  return Math.sin(arg_r) * hr;
}

// node_modules/proj4/lib/common/cosh.js
function cosh_default(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
}

// node_modules/proj4/lib/common/clens_cmplx.js
function clens_cmplx_default(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh_default(arg_i);
  var cosh_arg_i = cosh_default(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;
  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }
  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r * hr - i * hi, r * hi + i * hr];
}

// node_modules/proj4/lib/projections/etmerc.js
function init4() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc_default.init.apply(this);
    this.forward = tmerc_default.forward;
    this.inverse = tmerc_default.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
  this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z2 = gatg_default(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z2 + clens_default(this.gtu, 2 * Z2));
}
function forward4(p) {
  var Ce = adjust_lon_default(p.x - this.long0);
  var Cn = p.y;
  Cn = gatg_default(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot_default(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy_default(Math.tan(Ce));
  var tmp = clens_cmplx_default(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x;
  var y;
  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x = Infinity;
    y = Infinity;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse6(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx_default(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh_default(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot_default(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon_default(Ce + this.long0);
    lat = gatg_default(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names5 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
var etmerc_default = {
  init: init4,
  forward: forward4,
  inverse: inverse6,
  names: names5
};

// node_modules/proj4/lib/common/adjust_zone.js
function adjust_zone_default(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon_default(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}

// node_modules/proj4/lib/projections/utm.js
var dependsOn = "etmerc";
function init5() {
  var zone = adjust_zone_default(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc_default.init.apply(this);
  this.forward = etmerc_default.forward;
  this.inverse = etmerc_default.inverse;
}
var names6 = ["Universal Transverse Mercator System", "utm"];
var utm_default = {
  init: init5,
  names: names6,
  dependsOn
};

// node_modules/proj4/lib/common/srat.js
function srat_default(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}

// node_modules/proj4/lib/projections/gauss.js
var MAX_ITER2 = 20;
function init6() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat_default(this.e * sphi, this.ratexp));
}
function forward5(p) {
  var lon = p.x;
  var lat = p.y;
  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat_default(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
}
function inverse7(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = MAX_ITER2; i > 0; --i) {
    lat = 2 * Math.atan(num * srat_default(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names7 = ["gauss"];
var gauss_default = {
  init: init6,
  forward: forward5,
  inverse: inverse7,
  names: names7
};

// node_modules/proj4/lib/projections/sterea.js
function init7() {
  gauss_default.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward6(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon_default(p.x - this.long0);
  gauss_default.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function inverse8(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rho = hypot_default(p.x, p.y)) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  gauss_default.inverse.apply(this, [p]);
  p.x = adjust_lon_default(p.x + this.long0);
  return p;
}
var names8 = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
var sterea_default = {
  init: init7,
  forward: forward6,
  inverse: inverse8,
  names: names8
};

// node_modules/proj4/lib/projections/stere.js
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init8() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign_default(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && Math.abs(Math.cos(this.lat_ts)) > EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz_default(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz_default(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward7(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A5, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon_default(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    A5 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A5 * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A5 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  } else {
    X = 2 * Math.atan(ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz_default(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A5 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A5 * sinX;
    } else {
      A5 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A5 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A5 * cosX * Math.sin(dlon) + this.x0;
  }
  return p;
}
function inverse9(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce2, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -1 * p.y));
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x, p.y));
      }
    } else {
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z_default(this.e, ts);
      lon = this.con * adjust_lon_default(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
    } else {
      ce2 = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce2) * this.sinX0 + p.y * Math.sin(ce2) * this.cosX0 / rh);
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x * Math.sin(ce2), rh * this.cosX0 * Math.cos(ce2) - p.y * this.sinX0 * Math.sin(ce2)));
      }
      lat = -1 * phi2z_default(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names9 = ["stere", "Stereographic_South_Pole", "Polar_Stereographic_variant_A", "Polar_Stereographic_variant_B", "Polar_Stereographic"];
var stere_default = {
  init: init8,
  forward: forward7,
  inverse: inverse9,
  names: names9,
  ssfn_
};

// node_modules/proj4/lib/projections/somerc.js
function init9() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}
function forward8(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
  var I2 = this.alpha * (p.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I2)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I2));
  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}
function inverse10(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I2 / this.alpha;
  var S = 0;
  var phy = b;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }
  p.x = lambda;
  p.y = phy;
  return p;
}
var names10 = ["somerc"];
var somerc_default = {
  init: init9,
  forward: forward8,
  inverse: inverse10,
  names: names10
};

// node_modules/proj4/lib/projections/omerc.js
var TOL = 1e-7;
function isTypeA(P) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P.projName === "object" ? Object.keys(P.projName)[0] : P.projName;
  return "no_uoff" in P || "no_off" in P || typeAProjections.indexOf(projectionName) !== -1 || typeAProjections.indexOf(getNormalizedProjName(projectionName)) !== -1;
}
function init10() {
  var con, com, cosph0, D2, F, H, L, sinph0, p, J, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D2 = this.B * com / (cosph0 * Math.sqrt(con));
    F = D2 * D2 - 1;
    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);
      if (this.lat0 < 0) {
        F = -F;
      }
    }
    this.E = F += D2;
    this.E *= Math.pow(tsfnz_default(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D2 = F = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D2);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D2 * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz_default(this.e, phi1, Math.sin(phi1)), this.B);
    L = Math.pow(tsfnz_default(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p = (L - H) / (L + H);
    J = this.E * this.E;
    J = (J - L * H) / (J + L * H);
    con = lam1 - lam2;
    if (con < -Math.PI) {
      lam2 -= TWO_PI;
    } else if (con > Math.PI) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon_default(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon_default(lam1 - this.lam0)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D2 * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D2 * D2 - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
}
function forward9(p) {
  var coords = {};
  var S, T, U, V2, W, temp, u4, v2;
  p.x = p.x - this.lam0;
  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
    W = this.E / Math.pow(tsfnz_default(this.e, p.y, Math.sin(p.y)), this.B);
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V2 = Math.sin(this.B * p.x);
    U = (S * this.singam - V2 * this.cosgam) / T;
    if (Math.abs(Math.abs(U) - 1) < EPSLN) {
      throw new Error();
    }
    v2 = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
    temp = Math.cos(this.B * p.x);
    if (Math.abs(temp) < TOL) {
      u4 = this.A * p.x;
    } else {
      u4 = this.ArB * Math.atan2(S * this.cosgam + V2 * this.singam, temp);
    }
  } else {
    v2 = p.y > 0 ? this.v_pole_n : this.v_pole_s;
    u4 = this.ArB * p.y;
  }
  if (this.no_rot) {
    coords.x = u4;
    coords.y = v2;
  } else {
    u4 -= this.u_0;
    coords.x = v2 * this.cosrot + u4 * this.sinrot;
    coords.y = u4 * this.cosrot - v2 * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse11(p) {
  var u4, v2, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p.x = (p.x - this.x0) * (1 / this.a);
  p.y = (p.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v2 = p.y;
    u4 = p.x;
  } else {
    v2 = p.x * this.cosrot - p.y * this.sinrot;
    u4 = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v2);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u4);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z_default(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u4));
  }
  coords.x += this.lam0;
  return coords;
}
var names11 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Variant_B", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
var omerc_default = {
  init: init10,
  forward: forward9,
  inverse: inverse11,
  names: names11
};

// node_modules/proj4/lib/projections/lcc.js
function init11() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz_default(this.e, sin1, cos1);
  var ts1 = tsfnz_default(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz_default(this.e, sin2, cos2);
  var ts2 = tsfnz_default(this.e, this.lat2, sin2);
  var ts0 = Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN ? 0 : tsfnz_default(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward10(p) {
  var lon = p.x;
  var lat = p.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign_default(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz_default(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p;
}
function inverse12(p) {
  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = this.rh - (p.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x, con * y);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon_default(theta / this.ns + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
var names12 = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
var lcc_default = {
  init: init11,
  forward: forward10,
  inverse: inverse12,
  names: names12
};

// node_modules/proj4/lib/projections/krovak.js
function init12() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward11(p) {
  var gfi, u4, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u4 = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u4) + Math.sin(this.ad) * Math.cos(u4) * Math.cos(deltav));
  d = Math.asin(Math.cos(u4) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return p;
}
function inverse13(p) {
  var u4, deltav, s, d, eps, ro, fi1;
  var ok;
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u4 = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u4));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u4;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u4 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p;
}
var names13 = ["Krovak", "krovak"];
var krovak_default = {
  init: init12,
  forward: forward11,
  inverse: inverse13,
  names: names13
};

// node_modules/proj4/lib/common/mlfn.js
function mlfn_default(e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}

// node_modules/proj4/lib/common/e0fn.js
function e0fn_default(x) {
  return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
}

// node_modules/proj4/lib/common/e1fn.js
function e1fn_default(x) {
  return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
}

// node_modules/proj4/lib/common/e2fn.js
function e2fn_default(x) {
  return 0.05859375 * x * x * (1 + 0.75 * x);
}

// node_modules/proj4/lib/common/e3fn.js
function e3fn_default(x) {
  return x * x * x * (35 / 3072);
}

// node_modules/proj4/lib/common/gN.js
function gN_default(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
}

// node_modules/proj4/lib/common/adjust_lat.js
function adjust_lat_default(x) {
  return Math.abs(x) < HALF_PI ? x : x - sign_default(x) * Math.PI;
}

// node_modules/proj4/lib/common/imlfn.js
function imlfn_default(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}

// node_modules/proj4/lib/projections/cass.js
function init13() {
  if (!this.sphere) {
    this.e0 = e0fn_default(this.es);
    this.e1 = e1fn_default(this.es);
    this.e2 = e2fn_default(this.es);
    this.e3 = e3fn_default(this.es);
    this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward12(p) {
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN_default(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
function inverse14(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn_default(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN_default(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p.x = adjust_lon_default(lam + this.long0);
  p.y = adjust_lat_default(phi);
  return p;
}
var names14 = ["Cassini", "Cassini_Soldner", "cass"];
var cass_default = {
  init: init13,
  forward: forward12,
  inverse: inverse14,
  names: names14
};

// node_modules/proj4/lib/common/qsfnz.js
function qsfnz_default(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}

// node_modules/proj4/lib/projections/laea.js
var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;
function init14() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? S_POLE : N_POLE;
  } else if (Math.abs(t) < EPSLN) {
    this.mode = EQUIT;
  } else {
    this.mode = OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz_default(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case N_POLE:
        this.dd = 1;
        break;
      case S_POLE:
        this.dd = 1;
        break;
      case EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz_default(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward13(p) {
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz_default(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * (this.mode === this.S_POLE ? b : -b);
        } else {
          x = y = 0;
        }
        break;
    }
  }
  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}
function inverse15(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab4;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
  } else {
    ab4 = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab4 = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab4;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      } else {
        ab4 = y * sCe / rho;
        q = this.qp * ab4;
        y = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = x * x + y * y;
      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      ab4 = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab4 = -ab4;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab4), this.apa);
  }
  p.x = adjust_lon_default(this.long0 + lam);
  p.y = phi;
  return p;
}
var P00 = 0.3333333333333333;
var P01 = 0.17222222222222222;
var P02 = 0.10257936507936508;
var P10 = 0.06388888888888888;
var P11 = 0.0664021164021164;
var P20 = 0.016415012942191543;
function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}
function authlat(beta, APA) {
  var t = beta + beta;
  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
}
var names15 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
var laea_default = {
  init: init14,
  forward: forward13,
  inverse: inverse15,
  names: names15,
  S_POLE,
  N_POLE,
  EQUIT,
  OBLIQ
};

// node_modules/proj4/lib/common/asinz.js
function asinz_default(x) {
  if (Math.abs(x) > 1) {
    x = x > 1 ? 1 : -1;
  }
  return Math.asin(x);
}

// node_modules/proj4/lib/projections/aea.js
function init15() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz_default(this.e3, this.sin_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward14(p) {
  var lon = p.x;
  var lat = p.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz_default(this.e3, this.sin_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon_default(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse16(p) {
  var rh1, qs, con, theta, lon, lat;
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon_default(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz_default(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names16 = ["Albers_Conic_Equal_Area", "Albers_Equal_Area", "Albers", "aea"];
var aea_default = {
  init: init15,
  forward: forward14,
  inverse: inverse16,
  names: names16,
  phi1z
};

// node_modules/proj4/lib/projections/gnom.js
function init16() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward15(p) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse17(p) {
  var rh;
  var sinc, cosc;
  var c;
  var lon, lat;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = asinz_default(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon_default(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names17 = ["gnom"];
var gnom_default = {
  init: init16,
  forward: forward15,
  inverse: inverse17,
  names: names17
};

// node_modules/proj4/lib/common/iqsfnz.js
function iqsfnz_default(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1e-6) {
    if (q < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}

// node_modules/proj4/lib/projections/cea.js
function init17() {
  if (!this.sphere) {
    this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward16(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  var dlon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz_default(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse18(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz_default(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon_default(this.long0 + p.x / (this.a * this.k0));
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names18 = ["cea"];
var cea_default = {
  init: init17,
  forward: forward16,
  inverse: inverse18,
  names: names18
};

// node_modules/proj4/lib/projections/eqc.js
function init18() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward17(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var dlat = adjust_lat_default(lat - this.lat0);
  p.x = this.x0 + this.a * dlon * this.rc;
  p.y = this.y0 + this.a * dlat;
  return p;
}
function inverse19(p) {
  var x = p.x;
  var y = p.y;
  p.x = adjust_lon_default(this.long0 + (x - this.x0) / (this.a * this.rc));
  p.y = adjust_lat_default(this.lat0 + (y - this.y0) / this.a);
  return p;
}
var names19 = ["Equirectangular", "Equidistant_Cylindrical", "Equidistant_Cylindrical_Spherical", "eqc"];
var eqc_default = {
  init: init18,
  forward: forward17,
  inverse: inverse19,
  names: names19
};

// node_modules/proj4/lib/projections/poly.js
var MAX_ITER3 = 20;
function init19() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward18(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon_default(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    } else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat_default(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    } else {
      var nl = gN_default(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
function inverse20(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon_default(x / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER3; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon_default(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon_default(this.long0 + x / this.a);
    } else {
      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER3; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon_default(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names20 = ["Polyconic", "American_Polyconic", "poly"];
var poly_default = {
  init: init19,
  forward: forward18,
  inverse: inverse20,
  names: names20
};

// node_modules/proj4/lib/projections/nzmg.js
function init20() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward19(p) {
  var n;
  var lon = p.x;
  var lat = p.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }
  p.x = z_im * this.a + this.x0;
  p.y = z_re * this.a + this.y0;
  return p;
}
function inverse21(p) {
  var n;
  var x = p.x;
  var y = p.y;
  var delta_x = x - this.x0;
  var delta_y = y - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p.x = lon;
  p.y = lat;
  return p;
}
var names21 = ["New_Zealand_Map_Grid", "nzmg"];
var nzmg_default = {
  init: init20,
  forward: forward19,
  inverse: inverse21,
  names: names21
};

// node_modules/proj4/lib/projections/mill.js
function init21() {
}
function forward20(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p.x = x;
  p.y = y;
  return p;
}
function inverse22(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon = adjust_lon_default(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
  p.x = lon;
  p.y = lat;
  return p;
}
var names22 = ["Miller_Cylindrical", "mill"];
var mill_default = {
  init: init21,
  forward: forward20,
  inverse: inverse22,
  names: names22
};

// node_modules/proj4/lib/projections/sinu.js
var MAX_ITER4 = 20;
function init22() {
  if (!this.sphere) {
    this.en = pj_enfn_default(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward21(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  lon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER4; i; --i) {
        var V2 = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V2;
        if (Math.abs(V2) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;
  } else {
    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn_default(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse23(p) {
  var lat, temp, lon, s;
  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz_default((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz_default(Math.sin(lat) / this.n);
    }
    lon = adjust_lon_default(lon + this.long0);
    lat = adjust_lat_default(lat);
  } else {
    lat = pj_inv_mlfn_default(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      lon = adjust_lon_default(temp);
    } else if (s - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names23 = ["Sinusoidal", "sinu"];
var sinu_default = {
  init: init22,
  forward: forward21,
  inverse: inverse23,
  names: names23
};

// node_modules/proj4/lib/projections/moll.js
function init23() {
}
function forward22(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse24(p) {
  var theta;
  var arg;
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon_default(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p.x = lon;
  p.y = lat;
  return p;
}
var names24 = ["Mollweide", "moll"];
var moll_default = {
  init: init23,
  forward: forward22,
  inverse: inverse24,
  names: names24
};

// node_modules/proj4/lib/projections/eqdc.js
function init24() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.sin_phi = Math.sin(this.lat1);
  this.cos_phi = Math.cos(this.lat1);
  this.ms1 = msfnz_default(this.e, this.sin_phi, this.cos_phi);
  this.ml1 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sin_phi;
  } else {
    this.sin_phi = Math.sin(this.lat2);
    this.cos_phi = Math.cos(this.lat2);
    this.ms2 = msfnz_default(this.e, this.sin_phi, this.cos_phi);
    this.ml2 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward23(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn_default(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}
function inverse25(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    lat = adjust_lat_default(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn_default(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }
}
var names25 = ["Equidistant_Conic", "eqdc"];
var eqdc_default = {
  init: init24,
  forward: forward23,
  inverse: inverse25,
  names: names25
};

// node_modules/proj4/lib/projections/vandg.js
function init25() {
  this.R = this.a;
}
function forward24(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x, y;
  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz_default(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    y = this.y0 + con;
  } else {
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse26(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon_default(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names26 = ["Van_der_Grinten_I", "VanDerGrinten", "Van_der_Grinten", "vandg"];
var vandg_default = {
  init: init25,
  forward: forward24,
  inverse: inverse26,
  names: names26
};

// node_modules/proj4/lib/common/vincenty.js
function vincentyInverse(lat1, lon1, lat2, lon2, a, f) {
  const L = lon2 - lon1;
  const U1 = Math.atan((1 - f) * Math.tan(lat1));
  const U2 = Math.atan((1 - f) * Math.tan(lat2));
  const sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
  const sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);
  let lambda = L, lambdaP, iterLimit = 100;
  let sinLambda, cosLambda, sinSigma, cosSigma, sigma, sinAlpha, cos2Alpha, cos2SigmaM, C;
  let uSq, A5, B2, deltaSigma, s;
  do {
    sinLambda = Math.sin(lambda);
    cosLambda = Math.cos(lambda);
    sinSigma = Math.sqrt(
      cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)
    );
    if (sinSigma === 0) {
      return { azi1: 0, s12: 0 };
    }
    cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
    sigma = Math.atan2(sinSigma, cosSigma);
    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
    cos2Alpha = 1 - sinAlpha * sinAlpha;
    cos2SigmaM = cos2Alpha !== 0 ? cosSigma - 2 * sinU1 * sinU2 / cos2Alpha : 0;
    C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
    lambdaP = lambda;
    lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return { azi1: NaN, s12: NaN };
  }
  uSq = cos2Alpha * (a * a - a * (1 - f) * (a * (1 - f))) / (a * (1 - f) * (a * (1 - f)));
  A5 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  B2 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  deltaSigma = B2 * sinSigma * (cos2SigmaM + B2 / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B2 / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
  s = a * (1 - f) * A5 * (sigma - deltaSigma);
  const azi1 = Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
  return { azi1, s12: s };
}
function vincentyDirect(lat1, lon1, azi1, s12, a, f) {
  const U1 = Math.atan((1 - f) * Math.tan(lat1));
  const sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
  const sinAlpha1 = Math.sin(azi1), cosAlpha1 = Math.cos(azi1);
  const sigma1 = Math.atan2(sinU1, cosU1 * cosAlpha1);
  const sinAlpha = cosU1 * sinAlpha1;
  const cos2Alpha = 1 - sinAlpha * sinAlpha;
  const uSq = cos2Alpha * (a * a - a * (1 - f) * (a * (1 - f))) / (a * (1 - f) * (a * (1 - f)));
  const A5 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  const B2 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  let sigma = s12 / (a * (1 - f) * A5), sigmaP, iterLimit = 100;
  let cos2SigmaM, sinSigma, cosSigma, deltaSigma;
  do {
    cos2SigmaM = Math.cos(2 * sigma1 + sigma);
    sinSigma = Math.sin(sigma);
    cosSigma = Math.cos(sigma);
    deltaSigma = B2 * sinSigma * (cos2SigmaM + B2 / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B2 / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
    sigmaP = sigma;
    sigma = s12 / (a * (1 - f) * A5) + deltaSigma;
  } while (Math.abs(sigma - sigmaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return { lat2: NaN, lon2: NaN };
  }
  const tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;
  const lat2 = Math.atan2(
    sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1,
    (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp)
  );
  const lambda = Math.atan2(
    sinSigma * sinAlpha1,
    cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1
  );
  const C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
  const L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  const lon2 = lon1 + L;
  return { lat2, lon2 };
}

// node_modules/proj4/lib/projections/aeqd.js
function init26() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
  this.f = this.es / (1 + Math.sqrt(1 - this.es));
}
function forward25(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon_default(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, c, kp, cos_c, vars, azi1;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e2 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    } else {
      if (Math.abs(lon) < EPSLN && Math.abs(lat - this.lat0) < EPSLN) {
        p.x = p.y = 0;
        return p;
      }
      vars = vincentyInverse(this.lat0, this.long0, lat, lon, this.a, this.f);
      azi1 = vars.azi1;
      p.x = vars.s12 * Math.sin(azi1);
      p.y = vars.s12 * Math.cos(azi1);
      return p;
    }
  }
}
function inverse27(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M2, azi1, s12, vars;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z = rh / this.a;
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz_default(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -p.y));
        } else {
          lon = adjust_lon_default(this.long0 - Math.atan2(-p.x, p.y));
        }
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e2 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M2 = Mlp - rh;
      lat = imlfn_default(M2 / this.a, e0, e1, e2, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M2 = rh - Mlp;
      lat = imlfn_default(M2 / this.a, e0, e1, e2, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      azi1 = Math.atan2(p.x, p.y);
      s12 = Math.sqrt(p.x * p.x + p.y * p.y);
      vars = vincentyDirect(this.lat0, this.long0, azi1, s12, this.a, this.f);
      p.x = vars.lon2;
      p.y = vars.lat2;
      return p;
    }
  }
}
var names27 = ["Azimuthal_Equidistant", "aeqd"];
var aeqd_default = {
  init: init26,
  forward: forward25,
  inverse: inverse27,
  names: names27
};

// node_modules/proj4/lib/projections/ortho.js
function init27() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward26(p) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse28(p) {
  var rh;
  var z;
  var sinz, cosz;
  var con;
  var lon, lat;
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = asinz_default(rh / this.a);
  sinz = Math.sin(z);
  cosz = Math.cos(z);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = asinz_default(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -p.y));
    } else {
      lon = adjust_lon_default(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = adjust_lon_default(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}
var names28 = ["ortho"];
var ortho_default = {
  init: init27,
  forward: forward26,
  inverse: inverse28,
  names: names28
};

// node_modules/proj4/lib/projections/qsc.js
var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function init28() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward27(p) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t, mu;
  var area = { value: 0 };
  p.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }
  lon = p.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p.x = xy.x;
  p.y = xy.y;
  return p;
}
function inverse29(p) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = { value: 0 };
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p.x < 0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset2) {
  var slon = lon + offset2;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var names29 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
var qsc_default = {
  init: init28,
  forward: forward27,
  inverse: inverse29,
  names: names29
};

// node_modules/proj4/lib/projections/robin.js
var COEFS_X = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
];
var COEFS_Y = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D / 5;
var RC1 = 1 / C1;
var NODES = 18;
var poly3_val = function(coefs, x) {
  return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};
var poly3_der = function(coefs, x) {
  return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};
function newton_rapshon(f_df, start2, max_err, iters) {
  var x = start2;
  for (; iters; --iters) {
    var upd = f_df(x);
    x -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x;
}
function init29() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward28(ll) {
  var lon = adjust_lon_default(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);
  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse30(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i = Math.floor(ll.y * NODES);
    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i];
    var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
    t = newton_rapshon(function(x) {
      return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
    }, t, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i], t);
    ll.y = (5 * i + t) * D2R;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon_default(ll.x + this.long0);
  return ll;
}
var names30 = ["Robinson", "robin"];
var robin_default = {
  init: init29,
  forward: forward28,
  inverse: inverse30,
  names: names30
};

// node_modules/proj4/lib/projections/geocent.js
function init30() {
  this.name = "geocent";
}
function forward29(p) {
  var point2 = geodeticToGeocentric(p, this.es, this.a);
  return point2;
}
function inverse31(p) {
  var point2 = geocentricToGeodetic(p, this.es, this.a, this.b);
  return point2;
}
var names31 = ["Geocentric", "geocentric", "geocent", "Geocent"];
var geocent_default = {
  init: init30,
  forward: forward29,
  inverse: inverse31,
  names: names31
};

// node_modules/proj4/lib/projections/tpers.js
var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};
var params = {
  h: { def: 1e5, num: true },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: true, degrees: true },
  // default is North
  tilt: { def: 0, num: true, degrees: true },
  // default is Nadir
  long0: { def: 0, num: true },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: true }
  // default is Equator, conversion to rad is automatic
};
function init31() {
  Object.keys(params).forEach((function(p) {
    if (typeof this[p] === "undefined") {
      this[p] = params[p].def;
    } else if (params[p].num && isNaN(this[p])) {
      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
    } else if (params[p].num) {
      this[p] = parseFloat(this[p]);
    }
    if (params[p].degrees) {
      this[p] = this[p] * D2R;
    }
  }).bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward30(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;
  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y = cosphi * coslam;
      break;
    case mode.S_POLE:
      y = -sinphi;
      break;
    case mode.N_POLE:
      y = sinphi;
      break;
  }
  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y *= sinphi;
      break;
    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  }
  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;
  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}
function inverse32(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r = { x: p.x, y: p.y };
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;
  var rh = hypot_default(p.x, p.y);
  if (Math.abs(rh) < EPSLN) {
    r.x = 0;
    r.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;
      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p.y = -p.y;
        break;
      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }
    r.x = Math.atan2(p.x, p.y);
  }
  p.x = r.x + this.long0;
  p.y = r.y;
  return p;
}
var names32 = ["Tilted_Perspective", "tpers"];
var tpers_default = {
  init: init31,
  forward: forward30,
  inverse: inverse32,
  names: names32
};

// node_modules/proj4/lib/projections/geos.js
function init32() {
  this.flip_axis = this.sweep === "x" ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;
  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }
  this.radius_g = 1 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1;
  if (this.es !== 0) {
    var one_es = 1 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = "ellipse";
  } else {
    this.radius_p = 1;
    this.radius_p2 = 1;
    this.radius_p_inv2 = 1;
    this.shape = "sphere";
  }
  if (!this.title) {
    this.title = "Geostationary Satellite View";
  }
}
function forward31(p) {
  var lon = p.x;
  var lat = p.y;
  var tmp, v_x, v_y, v_z;
  lon = lon - this.long0;
  if (this.shape === "ellipse") {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r = this.radius_p / hypot_default(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r * Math.cos(lon) * Math.cos(lat);
    v_y = r * Math.sin(lon) * Math.cos(lat);
    v_z = r * Math.sin(lat);
    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  } else if (this.shape === "sphere") {
    tmp = Math.cos(lat);
    v_x = Math.cos(lon) * tmp;
    v_y = Math.sin(lon) * tmp;
    v_z = Math.sin(lat);
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  }
  p.x = p.x * this.a;
  p.y = p.y * this.a;
  return p;
}
function inverse33(p) {
  var v_x = -1;
  var v_y = 0;
  var v_z = 0;
  var a, b, det, k;
  p.x = p.x / this.a;
  p.y = p.y / this.a;
  if (this.shape === "ellipse") {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * hypot_default(1, v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * hypot_default(1, v_y);
    }
    var v_zp = v_z / this.radius_p;
    a = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
    p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
    }
    a = v_y * v_y + v_z * v_z + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
  }
  p.x = p.x + this.long0;
  return p;
}
var names33 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
var geos_default = {
  init: init32,
  forward: forward31,
  inverse: inverse33,
  names: names33
};

// node_modules/proj4/lib/projections/eqearth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = Math.sqrt(3) / 2;
function init33() {
  this.es = 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function forward32(p) {
  var lam = adjust_lon_default(p.x - this.long0);
  var phi = p.y;
  var paramLat = Math.asin(M * Math.sin(phi)), paramLatSq = paramLat * paramLat, paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p.x = lam * Math.cos(paramLat) / (M * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)));
  p.y = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq));
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function inverse34(p) {
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  var EPS = 1e-9, NITER = 12, paramLat = p.y, paramLatSq, paramLatPow6, fy, fpy, dlat, i;
  for (i = 0; i < NITER; ++i) {
    paramLatSq = paramLat * paramLat;
    paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
    fy = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq)) - p.y;
    fpy = A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq);
    paramLat -= dlat = fy / fpy;
    if (Math.abs(dlat) < EPS) {
      break;
    }
  }
  paramLatSq = paramLat * paramLat;
  paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p.x = M * p.x * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)) / Math.cos(paramLat);
  p.y = Math.asin(Math.sin(paramLat) / M);
  p.x = adjust_lon_default(p.x + this.long0);
  return p;
}
var names34 = ["eqearth", "Equal Earth", "Equal_Earth"];
var eqearth_default = {
  init: init33,
  forward: forward32,
  inverse: inverse34,
  names: names34
};

// node_modules/proj4/lib/projections/bonne.js
var EPS10 = 1e-10;
function init34() {
  var c;
  this.phi1 = this.lat1;
  if (Math.abs(this.phi1) < EPS10) {
    throw new Error();
  }
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.m1 = pj_mlfn_default(
      this.phi1,
      this.am1 = Math.sin(this.phi1),
      c = Math.cos(this.phi1),
      this.en
    );
    this.am1 = c / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1);
    this.inverse = e_inv;
    this.forward = e_fwd;
  } else {
    if (Math.abs(this.phi1) + EPS10 >= HALF_PI) {
      this.cphi1 = 0;
    } else {
      this.cphi1 = 1 / Math.tan(this.phi1);
    }
    this.inverse = s_inv;
    this.forward = s_fwd;
  }
}
function e_fwd(p) {
  var lam = adjust_lon_default(p.x - (this.long0 || 0));
  var phi = p.y;
  var rh, E, c;
  rh = this.am1 + this.m1 - pj_mlfn_default(phi, E = Math.sin(phi), c = Math.cos(phi), this.en);
  E = c * lam / (rh * Math.sqrt(1 - this.es * E * E));
  p.x = rh * Math.sin(E);
  p.y = this.am1 - rh * Math.cos(E);
  p.x = this.a * p.x + (this.x0 || 0);
  p.y = this.a * p.y + (this.y0 || 0);
  return p;
}
function e_inv(p) {
  p.x = (p.x - (this.x0 || 0)) / this.a;
  p.y = (p.y - (this.y0 || 0)) / this.a;
  var s, rh, lam, phi;
  rh = hypot_default(p.x, p.y = this.am1 - p.y);
  phi = pj_inv_mlfn_default(this.am1 + this.m1 - rh, this.es, this.en);
  if ((s = Math.abs(phi)) < HALF_PI) {
    s = Math.sin(phi);
    lam = rh * Math.atan2(p.x, p.y) * Math.sqrt(1 - this.es * s * s) / Math.cos(phi);
  } else if (Math.abs(s - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    throw new Error();
  }
  p.x = adjust_lon_default(lam + (this.long0 || 0));
  p.y = adjust_lat_default(phi);
  return p;
}
function s_fwd(p) {
  var lam = adjust_lon_default(p.x - (this.long0 || 0));
  var phi = p.y;
  var E, rh;
  rh = this.cphi1 + this.phi1 - phi;
  if (Math.abs(rh) > EPS10) {
    p.x = rh * Math.sin(E = lam * Math.cos(phi) / rh);
    p.y = this.cphi1 - rh * Math.cos(E);
  } else {
    p.x = p.y = 0;
  }
  p.x = this.a * p.x + (this.x0 || 0);
  p.y = this.a * p.y + (this.y0 || 0);
  return p;
}
function s_inv(p) {
  p.x = (p.x - (this.x0 || 0)) / this.a;
  p.y = (p.y - (this.y0 || 0)) / this.a;
  var lam, phi;
  var rh = hypot_default(p.x, p.y = this.cphi1 - p.y);
  phi = this.cphi1 + this.phi1 - rh;
  if (Math.abs(phi) > HALF_PI) {
    throw new Error();
  }
  if (Math.abs(Math.abs(phi) - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    lam = rh * Math.atan2(p.x, p.y) / Math.cos(phi);
  }
  p.x = adjust_lon_default(lam + (this.long0 || 0));
  p.y = adjust_lat_default(phi);
  return p;
}
var names35 = ["bonne", "Bonne (Werner lat_1=90)"];
var bonne_default = {
  init: init34,
  names: names35
};

// node_modules/proj4/projs.js
function projs_default(proj43) {
  proj43.Proj.projections.add(tmerc_default);
  proj43.Proj.projections.add(etmerc_default);
  proj43.Proj.projections.add(utm_default);
  proj43.Proj.projections.add(sterea_default);
  proj43.Proj.projections.add(stere_default);
  proj43.Proj.projections.add(somerc_default);
  proj43.Proj.projections.add(omerc_default);
  proj43.Proj.projections.add(lcc_default);
  proj43.Proj.projections.add(krovak_default);
  proj43.Proj.projections.add(cass_default);
  proj43.Proj.projections.add(laea_default);
  proj43.Proj.projections.add(aea_default);
  proj43.Proj.projections.add(gnom_default);
  proj43.Proj.projections.add(cea_default);
  proj43.Proj.projections.add(eqc_default);
  proj43.Proj.projections.add(poly_default);
  proj43.Proj.projections.add(nzmg_default);
  proj43.Proj.projections.add(mill_default);
  proj43.Proj.projections.add(sinu_default);
  proj43.Proj.projections.add(moll_default);
  proj43.Proj.projections.add(eqdc_default);
  proj43.Proj.projections.add(vandg_default);
  proj43.Proj.projections.add(aeqd_default);
  proj43.Proj.projections.add(ortho_default);
  proj43.Proj.projections.add(qsc_default);
  proj43.Proj.projections.add(robin_default);
  proj43.Proj.projections.add(geocent_default);
  proj43.Proj.projections.add(tpers_default);
  proj43.Proj.projections.add(geos_default);
  proj43.Proj.projections.add(eqearth_default);
  proj43.Proj.projections.add(bonne_default);
}

// node_modules/proj4/lib/index.js
var proj42 = Object.assign(core_default, {
  defaultDatum: "WGS84",
  Proj: Proj_default,
  WGS84: new Proj_default("WGS84"),
  Point: Point_default2,
  toPoint: toPoint_default,
  defs: defs_default,
  nadgrid,
  transform: transform3,
  mgrs: mgrs_default,
  version: "__VERSION__"
});
projs_default(proj42);
var lib_default = proj42;

// node_modules/@allmaps/project/dist/shared/project-functions.js
var lonLatEquivalentDefinitions = [
  "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees",
  "+proj=longlat +datum=WGS84 +no_defs +type=crs",
  "EPSG:4326",
  "WGS84"
];
var webMercatorEquivalentDefinitions = [
  "+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs +type=crs",
  "EPSG:3857",
  "EPSG:3785",
  "GOOGLE",
  "EPSG:900913",
  "EPSG:102113"
];
var lonLatProjection = {
  name: "EPSG:4326",
  definition: lonLatEquivalentDefinitions[0]
};
var webMercatorProjection = {
  name: "EPSG:3857",
  definition: webMercatorEquivalentDefinitions[0]
};
var defaultProjectedGcpTransformerOptions = {
  internalProjection: webMercatorProjection,
  projection: webMercatorProjection,
  ...defaultGcpTransformerOptions
};
var defaultProjectedGcpTransformOptions = {
  projection: webMercatorProjection,
  ...defaultGcpTransformerOptions
};
var lonLatProjectionToWebMecatorProjectionConverter = lib_default(lonLatProjection.definition, webMercatorProjection.definition);
var lonLatToWebMercator = lonLatProjectionToWebMecatorProjectionConverter.forward;
var webMercatorToLonLat = lonLatProjectionToWebMecatorProjectionConverter.inverse;
function projectionDefinitionToAntialiasedDefinition(stringProjectionDefinition) {
  if (stringProjectionDefinition === void 0) {
    return void 0;
  }
  const lonLatIndex = lonLatEquivalentDefinitions.indexOf(stringProjectionDefinition);
  const webMercatorIndex = webMercatorEquivalentDefinitions.indexOf(stringProjectionDefinition);
  if (lonLatIndex != -1) {
    return lonLatProjection.definition;
  } else if (webMercatorIndex != -1) {
    return webMercatorProjection.definition;
  } else {
    return stringProjectionDefinition;
  }
}
function isEqualProjection(projection0, projection1) {
  return projectionDefinitionToAntialiasedDefinition(String(projection0?.definition)) == projectionDefinitionToAntialiasedDefinition(String(projection1?.definition));
}

// node_modules/@allmaps/project/dist/projected-transformers/ProjectedGcpTransformer.js
var ProjectedGcpTransformer = class _ProjectedGcpTransformer extends GcpTransformer {
  internalProjection;
  projection;
  internalProjectionToProjection;
  projectionToInternalProjection;
  lonLatToProjection;
  projectionToLatLon;
  /**
   * Create a ProjectedGcpTransformer
   *
   * @param gcps - An array of Ground Control Points (GCPs) in lon-lat 'EPSG:4326'
   * @param type - The transformation type
   * @param partialProjectedGcpTransformerOptions - Projected GCP Transformer options
   */
  constructor(gcps, type = "polynomial", partialProjectedGcpTransformerOptions) {
    const projectedGcpTransformerOptions = mergeOptionsUnlessUndefined(defaultProjectedGcpTransformerOptions, partialProjectedGcpTransformerOptions);
    const internalProjectionToProjectionConverter = lib_default(projectedGcpTransformerOptions.internalProjection.definition, projectedGcpTransformerOptions.projection.definition);
    const postToGeo = internalProjectionToProjectionConverter.forward;
    const preToResource = internalProjectionToProjectionConverter.inverse;
    const lonLatToProjectionConverter = lib_default(lonLatProjection.definition, projectedGcpTransformerOptions.projection.definition);
    const lonLatToProjection = lonLatToProjectionConverter.forward;
    const projectionToLatLon = lonLatToProjectionConverter.inverse;
    const partialGcpTransformerOptions = {
      ...partialProjectedGcpTransformerOptions,
      postToGeo,
      preToResource
    };
    gcps = gcps.map((gcp) => {
      return {
        resource: gcp.resource,
        geo: lonLatToProjection(gcp.geo)
      };
    });
    super(gcps, type, partialGcpTransformerOptions);
    this.internalProjection = projectedGcpTransformerOptions.internalProjection;
    this.projection = projectedGcpTransformerOptions.projection;
    this.internalProjectionToProjection = postToGeo;
    this.projectionToInternalProjection = preToResource;
    this.lonLatToProjection = lonLatToProjection;
    this.projectionToLatLon = projectionToLatLon;
  }
  // Note: this is different from generalGcpsInternal from the BaseTransformer,
  // which also includes a possible handedness flip
  get interalProjectedGcps() {
    return this.gcps.map(({ resource, geo }) => ({
      resource,
      geo: this.projectionToInternalProjection(this.lonLatToProjection(geo))
    }));
  }
  get projectedGcps() {
    return this.gcps.map(({ resource, geo }) => ({
      resource,
      geo: this.lonLatToProjection(geo)
    }));
  }
  /**
   * Set the projection.
   *
   * To transform 'toGeo' or 'toResource' to or from a different projection
   * than set on a transformer's construction (but using the same internal projection)
   * it's possible to specify the requested projection in the transform options.
   *
   * This way we circumvent a possibly expensive recomputation
   * of the toGeo and/or toResource transformations.
   *
   * To do this more systematically, it's possible to set
   * a projected gcp transformer's projection using this method
   *
   * Combine this with a deep clone of the transformer instance
   * to keep the original transformer as well.
   *
   * @returns this
   */
  setProjection(projection) {
    if (projection == this.projection) {
      return this;
    }
    const internalProjectionToProjectionConverter = lib_default(this.internalProjection.definition, projection.definition);
    const postToGeo = internalProjectionToProjectionConverter.forward;
    const preToResource = internalProjectionToProjectionConverter.inverse;
    const lonLatToProjectionConverter = lib_default(lonLatProjection.definition, projection.definition);
    const lonLatToProjection = lonLatToProjectionConverter.forward;
    const projectionToLatLon = lonLatToProjectionConverter.inverse;
    const partialGcpTransformerOptions = {
      postToGeo,
      preToResource
    };
    this.setTransformerOptionsInternal(partialGcpTransformerOptions);
    this.projection = projection;
    this.internalProjectionToProjection = postToGeo;
    this.projectionToInternalProjection = preToResource;
    this.lonLatToProjection = lonLatToProjection;
    this.projectionToLatLon = projectionToLatLon;
    return this;
  }
  /**
   * Transform a geometry to projected geo space
   *
   * @param geometry - Geometry to transform
   * @param partialProjectedGcpTransformOptions - Projected GCP Transform options
   * @param gcpToP - Return type function
   * @returns Input geometry transformed to projected geo space
   */
  transformToGeo(geometry, partialProjectedGcpTransformOptions, gcpToP) {
    const projection = partialProjectedGcpTransformOptions?.projection;
    let partialGcpTransformOptions = partialProjectedGcpTransformOptions;
    if (projection) {
      const internalProjectionToProjectionConverter = lib_default(this.internalProjection.definition, projection.definition);
      const postToGeo = internalProjectionToProjectionConverter.forward;
      const preToResource = internalProjectionToProjectionConverter.inverse;
      partialGcpTransformOptions = mergePartialOptions(partialGcpTransformOptions, {
        postToGeo,
        preToResource
      });
    }
    return super.transformToGeo(geometry, partialGcpTransformOptions, gcpToP);
  }
  /**
   * Transform a geometry to resource space
   *
   * @param geometry - Geometry to transform
   * @param partialProjectedGcpTransformOptions - Projected GCP Transform options
   * @param gcpToP - Return type function
   * @returns Input geometry transformed to resource space
   */
  transformToResource(geometry, partialProjectedGcpTransformOptions, gcpToP) {
    const projection = partialProjectedGcpTransformOptions?.projection;
    let partialGcpTransformOptions = partialProjectedGcpTransformOptions;
    if (projection) {
      const internalProjectionToProjectionConverter = lib_default(this.internalProjection.definition, projection.definition);
      const postToGeo = internalProjectionToProjectionConverter.forward;
      const preToResource = internalProjectionToProjectionConverter.inverse;
      partialGcpTransformOptions = mergePartialOptions(partialGcpTransformOptions, {
        postToGeo,
        preToResource
      });
    }
    return super.transformToResource(geometry, partialGcpTransformOptions, gcpToP);
  }
  /**
   * Create a Projected GCP Transformer from a Georeferenced Map
   *
   * @param georeferencedMap - A Georeferenced Map
   * @param options - Options, including Projected GCP Transformer Options, and a transformation type to overrule the type defined in the Georeferenced Map
   * @returns A Projected GCP Transformer
   */
  static fromGeoreferencedMap(georeferencedMap, options) {
    const georeferencedMapInput = {
      transformationType: georeferencedMap.transformation?.type,
      internalProjection: georeferencedMap.resourceCrs
    };
    options = mergeOptions(georeferencedMapInput, options);
    return new _ProjectedGcpTransformer(georeferencedMap.gcps, options.transformationType, options);
  }
};

// node_modules/robust-predicates/esm/util.js
var epsilon = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon) * epsilon;
function sum2(elen, e, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function sum_three(alen, a, blen, b, clen, c, tmp, out) {
  return sum2(sum2(alen, a, blen, b, tmp), tmp, clen, c, out);
}
function scale2(elen, e, b, h) {
  let Q, sum3, hh, product1, product0;
  let bvirt, c, ahi, alo, bhi, blo;
  c = splitter * b;
  bhi = c - (c - b);
  blo = b - bhi;
  let enow = e[0];
  Q = enow * b;
  c = splitter * enow;
  ahi = c - (c - enow);
  alo = enow - ahi;
  hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);
  let hindex = 0;
  if (hh !== 0) {
    h[hindex++] = hh;
  }
  for (let i = 1; i < elen; i++) {
    enow = e[i];
    product1 = enow * b;
    c = splitter * enow;
    ahi = c - (c - enow);
    alo = enow - ahi;
    product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);
    sum3 = Q + product0;
    bvirt = sum3 - Q;
    hh = Q - (sum3 - bvirt) + (product0 - bvirt);
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    Q = product1 + sum3;
    hh = sum3 - (Q - product1);
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q = e[0];
  for (let i = 1; i < elen; i++) Q += e[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
var B = vec(4);
var C12 = vec(8);
var C2 = vec(12);
var D = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B[3] = u32;
  let det = estimate(4, B);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum2(4, B, 4, u, C12);
  s1 = acx * bcytail;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum2(C1len, C12, 4, u, C2);
  s1 = acxtail * bcytail;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum2(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon) * epsilon;
var o3derrboundB = (3 + 28 * epsilon) * epsilon;
var o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon) * epsilon;
var iccerrboundB = (4 + 48 * epsilon) * epsilon;
var iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);
function finadd(finlen, a, alen) {
  finlen = sum2(finlen, fin3, a, alen, fin22);
  const tmp = fin3;
  fin3 = fin22;
  fin22 = tmp;
  return finlen;
}
function incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {
  let finlen;
  let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;
  let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;
  let abtlen, bctlen, catlen;
  let abttlen, bcttlen, cattlen;
  let n1, n0;
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  s1 = bdx * cdy;
  c = splitter * bdx;
  ahi = c - (c - bdx);
  alo = bdx - ahi;
  c = splitter * cdy;
  bhi = c - (c - cdy);
  blo = cdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cdx * bdy;
  c = splitter * cdx;
  ahi = c - (c - cdx);
  alo = cdx - ahi;
  c = splitter * bdy;
  bhi = c - (c - bdy);
  blo = bdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bc2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bc2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  bc2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  bc2[3] = u32;
  s1 = cdx * ady;
  c = splitter * cdx;
  ahi = c - (c - cdx);
  alo = cdx - ahi;
  c = splitter * ady;
  bhi = c - (c - ady);
  blo = ady - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = adx * cdy;
  c = splitter * adx;
  ahi = c - (c - adx);
  alo = adx - ahi;
  c = splitter * cdy;
  bhi = c - (c - cdy);
  blo = cdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ca2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ca2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  ca2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  ca2[3] = u32;
  s1 = adx * bdy;
  c = splitter * adx;
  ahi = c - (c - adx);
  alo = adx - ahi;
  c = splitter * bdy;
  bhi = c - (c - bdy);
  blo = bdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = bdx * ady;
  c = splitter * bdx;
  ahi = c - (c - bdx);
  alo = bdx - ahi;
  c = splitter * ady;
  bhi = c - (c - ady);
  blo = ady - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ab2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ab2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  ab2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  ab2[3] = u32;
  finlen = sum2(
    sum2(
      sum2(
        scale2(scale2(4, bc2, adx, _82), _82, adx, _162),
        _162,
        scale2(scale2(4, bc2, ady, _82), _82, ady, _16b),
        _16b,
        _32
      ),
      _32,
      sum2(
        scale2(scale2(4, ca2, bdx, _82), _82, bdx, _162),
        _162,
        scale2(scale2(4, ca2, bdy, _82), _82, bdy, _16b),
        _16b,
        _32b
      ),
      _32b,
      _64
    ),
    _64,
    sum2(
      scale2(scale2(4, ab2, cdx, _82), _82, cdx, _162),
      _162,
      scale2(scale2(4, ab2, cdy, _82), _82, cdy, _16b),
      _16b,
      _32
    ),
    _32,
    fin3
  );
  let det = estimate(finlen, fin3);
  let errbound = iccerrboundB * permanent;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - adx;
  adxtail = ax - (adx + bvirt) + (bvirt - dx);
  bvirt = ay - ady;
  adytail = ay - (ady + bvirt) + (bvirt - dy);
  bvirt = bx - bdx;
  bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
  bvirt = by - bdy;
  bdytail = by - (bdy + bvirt) + (bvirt - dy);
  bvirt = cx - cdx;
  cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
  bvirt = cy - cdy;
  cdytail = cy - (cdy + bvirt) + (bvirt - dy);
  if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) {
    return det;
  }
  errbound = iccerrboundC * permanent + resulterrbound * Math.abs(det);
  det += (adx * adx + ady * ady) * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + 2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx) + ((bdx * bdx + bdy * bdy) * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + 2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) + ((cdx * cdx + cdy * cdy) * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + 2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
    s1 = adx * adx;
    c = splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = ady * ady;
    c = splitter * ady;
    ahi = c - (c - ady);
    alo = ady - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    aa[2] = _j - (u32 - bvirt) + (_i - bvirt);
    aa[3] = u32;
  }
  if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
    s1 = bdx * bdx;
    c = splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = bdy * bdy;
    c = splitter * bdy;
    ahi = c - (c - bdy);
    alo = bdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    bb[2] = _j - (u32 - bvirt) + (_i - bvirt);
    bb[3] = u32;
  }
  if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
    s1 = cdx * cdx;
    c = splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = cdy * cdy;
    c = splitter * cdy;
    ahi = c - (c - cdy);
    alo = cdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    cc[2] = _j - (u32 - bvirt) + (_i - bvirt);
    cc[3] = u32;
  }
  if (adxtail !== 0) {
    axtbclen = scale2(4, bc2, adxtail, axtbc);
    finlen = finadd(finlen, sum_three(
      scale2(axtbclen, axtbc, 2 * adx, _162),
      _162,
      scale2(scale2(4, cc, adxtail, _82), _82, bdy, _16b),
      _16b,
      scale2(scale2(4, bb, adxtail, _82), _82, -cdy, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (adytail !== 0) {
    aytbclen = scale2(4, bc2, adytail, aytbc);
    finlen = finadd(finlen, sum_three(
      scale2(aytbclen, aytbc, 2 * ady, _162),
      _162,
      scale2(scale2(4, bb, adytail, _82), _82, cdx, _16b),
      _16b,
      scale2(scale2(4, cc, adytail, _82), _82, -bdx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (bdxtail !== 0) {
    bxtcalen = scale2(4, ca2, bdxtail, bxtca);
    finlen = finadd(finlen, sum_three(
      scale2(bxtcalen, bxtca, 2 * bdx, _162),
      _162,
      scale2(scale2(4, aa, bdxtail, _82), _82, cdy, _16b),
      _16b,
      scale2(scale2(4, cc, bdxtail, _82), _82, -ady, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (bdytail !== 0) {
    bytcalen = scale2(4, ca2, bdytail, bytca);
    finlen = finadd(finlen, sum_three(
      scale2(bytcalen, bytca, 2 * bdy, _162),
      _162,
      scale2(scale2(4, cc, bdytail, _82), _82, adx, _16b),
      _16b,
      scale2(scale2(4, aa, bdytail, _82), _82, -cdx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (cdxtail !== 0) {
    cxtablen = scale2(4, ab2, cdxtail, cxtab);
    finlen = finadd(finlen, sum_three(
      scale2(cxtablen, cxtab, 2 * cdx, _162),
      _162,
      scale2(scale2(4, bb, cdxtail, _82), _82, ady, _16b),
      _16b,
      scale2(scale2(4, aa, cdxtail, _82), _82, -bdy, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (cdytail !== 0) {
    cytablen = scale2(4, ab2, cdytail, cytab);
    finlen = finadd(finlen, sum_three(
      scale2(cytablen, cytab, 2 * cdy, _162),
      _162,
      scale2(scale2(4, aa, cdytail, _82), _82, bdx, _16b),
      _16b,
      scale2(scale2(4, bb, cdytail, _82), _82, -adx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (adxtail !== 0 || adytail !== 0) {
    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
      s1 = bdxtail * cdy;
      c = splitter * bdxtail;
      ahi = c - (c - bdxtail);
      alo = bdxtail - ahi;
      c = splitter * cdy;
      bhi = c - (c - cdy);
      blo = cdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * cdytail;
      c = splitter * bdx;
      ahi = c - (c - bdx);
      alo = bdx - ahi;
      c = splitter * cdytail;
      bhi = c - (c - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u3[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u3[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u3[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u3[3] = u32;
      s1 = cdxtail * -bdy;
      c = splitter * cdxtail;
      ahi = c - (c - cdxtail);
      alo = cdxtail - ahi;
      c = splitter * -bdy;
      bhi = c - (c - -bdy);
      blo = -bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * -bdytail;
      c = splitter * cdx;
      ahi = c - (c - cdx);
      alo = cdx - ahi;
      c = splitter * -bdytail;
      bhi = c - (c - -bdytail);
      blo = -bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v[3] = u32;
      bctlen = sum2(4, u3, 4, v, bct2);
      s1 = bdxtail * cdytail;
      c = splitter * bdxtail;
      ahi = c - (c - bdxtail);
      alo = bdxtail - ahi;
      c = splitter * cdytail;
      bhi = c - (c - cdytail);
      blo = cdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdxtail * bdytail;
      c = splitter * cdxtail;
      ahi = c - (c - cdxtail);
      alo = cdxtail - ahi;
      c = splitter * bdytail;
      bhi = c - (c - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      bctt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      bctt[3] = u32;
      bcttlen = 4;
    } else {
      bct2[0] = 0;
      bctlen = 1;
      bctt[0] = 0;
      bcttlen = 1;
    }
    if (adxtail !== 0) {
      const len = scale2(bctlen, bct2, adxtail, _16c);
      finlen = finadd(finlen, sum2(
        scale2(axtbclen, axtbc, adxtail, _162),
        _162,
        scale2(len, _16c, 2 * adx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(bcttlen, bctt, adxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * adx, _162),
        _162,
        scale2(len2, _82, adxtail, _16b),
        _16b,
        scale2(len, _16c, adxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (bdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, cc, adxtail, _82), _82, bdytail, _162), _162);
      }
      if (cdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, bb, -adxtail, _82), _82, cdytail, _162), _162);
      }
    }
    if (adytail !== 0) {
      const len = scale2(bctlen, bct2, adytail, _16c);
      finlen = finadd(finlen, sum2(
        scale2(aytbclen, aytbc, adytail, _162),
        _162,
        scale2(len, _16c, 2 * ady, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(bcttlen, bctt, adytail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * ady, _162),
        _162,
        scale2(len2, _82, adytail, _16b),
        _16b,
        scale2(len, _16c, adytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  if (bdxtail !== 0 || bdytail !== 0) {
    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
      s1 = cdxtail * ady;
      c = splitter * cdxtail;
      ahi = c - (c - cdxtail);
      alo = cdxtail - ahi;
      c = splitter * ady;
      bhi = c - (c - ady);
      blo = ady - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * adytail;
      c = splitter * cdx;
      ahi = c - (c - cdx);
      alo = cdx - ahi;
      c = splitter * adytail;
      bhi = c - (c - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u3[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u3[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u3[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u3[3] = u32;
      n1 = -cdy;
      n0 = -cdytail;
      s1 = adxtail * n1;
      c = splitter * adxtail;
      ahi = c - (c - adxtail);
      alo = adxtail - ahi;
      c = splitter * n1;
      bhi = c - (c - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * n0;
      c = splitter * adx;
      ahi = c - (c - adx);
      alo = adx - ahi;
      c = splitter * n0;
      bhi = c - (c - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v[3] = u32;
      catlen = sum2(4, u3, 4, v, cat2);
      s1 = cdxtail * adytail;
      c = splitter * cdxtail;
      ahi = c - (c - cdxtail);
      alo = cdxtail - ahi;
      c = splitter * adytail;
      bhi = c - (c - adytail);
      blo = adytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adxtail * cdytail;
      c = splitter * adxtail;
      ahi = c - (c - adxtail);
      alo = adxtail - ahi;
      c = splitter * cdytail;
      bhi = c - (c - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      catt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      catt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      catt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      catt[3] = u32;
      cattlen = 4;
    } else {
      cat2[0] = 0;
      catlen = 1;
      catt[0] = 0;
      cattlen = 1;
    }
    if (bdxtail !== 0) {
      const len = scale2(catlen, cat2, bdxtail, _16c);
      finlen = finadd(finlen, sum2(
        scale2(bxtcalen, bxtca, bdxtail, _162),
        _162,
        scale2(len, _16c, 2 * bdx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(cattlen, catt, bdxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * bdx, _162),
        _162,
        scale2(len2, _82, bdxtail, _16b),
        _16b,
        scale2(len, _16c, bdxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (cdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, aa, bdxtail, _82), _82, cdytail, _162), _162);
      }
      if (adytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, cc, -bdxtail, _82), _82, adytail, _162), _162);
      }
    }
    if (bdytail !== 0) {
      const len = scale2(catlen, cat2, bdytail, _16c);
      finlen = finadd(finlen, sum2(
        scale2(bytcalen, bytca, bdytail, _162),
        _162,
        scale2(len, _16c, 2 * bdy, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(cattlen, catt, bdytail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * bdy, _162),
        _162,
        scale2(len2, _82, bdytail, _16b),
        _16b,
        scale2(len, _16c, bdytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  if (cdxtail !== 0 || cdytail !== 0) {
    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
      s1 = adxtail * bdy;
      c = splitter * adxtail;
      ahi = c - (c - adxtail);
      alo = adxtail - ahi;
      c = splitter * bdy;
      bhi = c - (c - bdy);
      blo = bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * bdytail;
      c = splitter * adx;
      ahi = c - (c - adx);
      alo = adx - ahi;
      c = splitter * bdytail;
      bhi = c - (c - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u3[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u3[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u3[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u3[3] = u32;
      n1 = -ady;
      n0 = -adytail;
      s1 = bdxtail * n1;
      c = splitter * bdxtail;
      ahi = c - (c - bdxtail);
      alo = bdxtail - ahi;
      c = splitter * n1;
      bhi = c - (c - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * n0;
      c = splitter * bdx;
      ahi = c - (c - bdx);
      alo = bdx - ahi;
      c = splitter * n0;
      bhi = c - (c - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v[3] = u32;
      abtlen = sum2(4, u3, 4, v, abt2);
      s1 = adxtail * bdytail;
      c = splitter * adxtail;
      ahi = c - (c - adxtail);
      alo = adxtail - ahi;
      c = splitter * bdytail;
      bhi = c - (c - bdytail);
      blo = bdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdxtail * adytail;
      c = splitter * bdxtail;
      ahi = c - (c - bdxtail);
      alo = bdxtail - ahi;
      c = splitter * adytail;
      bhi = c - (c - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      abtt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      abtt[3] = u32;
      abttlen = 4;
    } else {
      abt2[0] = 0;
      abtlen = 1;
      abtt[0] = 0;
      abttlen = 1;
    }
    if (cdxtail !== 0) {
      const len = scale2(abtlen, abt2, cdxtail, _16c);
      finlen = finadd(finlen, sum2(
        scale2(cxtablen, cxtab, cdxtail, _162),
        _162,
        scale2(len, _16c, 2 * cdx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(abttlen, abtt, cdxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * cdx, _162),
        _162,
        scale2(len2, _82, cdxtail, _16b),
        _16b,
        scale2(len, _16c, cdxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (adytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, bb, cdxtail, _82), _82, adytail, _162), _162);
      }
      if (bdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, aa, -cdxtail, _82), _82, bdytail, _162), _162);
      }
    }
    if (cdytail !== 0) {
      const len = scale2(abtlen, abt2, cdytail, _16c);
      finlen = finadd(finlen, sum2(
        scale2(cytablen, cytab, cdytail, _162),
        _162,
        scale2(len, _16c, 2 * cdy, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(abttlen, abtt, cdytail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * cdy, _162),
        _162,
        scale2(len2, _82, cdytail, _16b),
        _16b,
        scale2(len, _16c, cdytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  return fin3[finlen - 1];
}
function incircle(ax, ay, bx, by, cx, cy, dx, dy) {
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  const bdxcdy = bdx * cdy;
  const cdxbdy = cdx * bdy;
  const alift = adx * adx + ady * ady;
  const cdxady = cdx * ady;
  const adxcdy = adx * cdy;
  const blift = bdx * bdx + bdy * bdy;
  const adxbdy = adx * bdy;
  const bdxady = bdx * ady;
  const clift = cdx * cdx + cdy * cdy;
  const det = alift * (bdxcdy - cdxbdy) + blift * (cdxady - adxcdy) + clift * (adxbdy - bdxady);
  const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift + (Math.abs(cdxady) + Math.abs(adxcdy)) * blift + (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;
  const errbound = iccerrboundA * permanent;
  if (det > errbound || -det > errbound) {
    return det;
  }
  return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);
}

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon) * epsilon;
var isperrboundB = (5 + 72 * epsilon) * epsilon;
var isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// node_modules/point-in-polygon-hao/dist/esm/index.js
function pointInPolygon(p, polygon) {
  var i;
  var ii;
  var k = 0;
  var f;
  var u1;
  var v1;
  var u22;
  var v2;
  var currentP;
  var nextP;
  var x = p[0];
  var y = p[1];
  var numContours = polygon.length;
  for (i = 0; i < numContours; i++) {
    ii = 0;
    var contour = polygon[i];
    var contourLen = contour.length - 1;
    currentP = contour[0];
    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
      throw new Error("First and last coordinates in a ring must be the same");
    }
    u1 = currentP[0] - x;
    v1 = currentP[1] - y;
    for (ii; ii < contourLen; ii++) {
      nextP = contour[ii + 1];
      u22 = nextP[0] - x;
      v2 = nextP[1] - y;
      if (v1 === 0 && v2 === 0) {
        if (u22 <= 0 && u1 >= 0 || u1 <= 0 && u22 >= 0) {
          return 0;
        }
      } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {
        f = orient2d(u1, u22, v1, v2, 0, 0);
        if (f === 0) {
          return 0;
        }
        if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {
          k++;
        }
      }
      currentP = nextP;
      v1 = v2;
      u1 = u22;
    }
  }
  if (k % 2 === 0) {
    return false;
  }
  return true;
}

// node_modules/@allmaps/render/dist/maps/RTree.js
var DEFAULT_FILTER_INSIDE_POLYGON = true;
var RTree = class {
  rbush = new RBush();
  polygonsById = /* @__PURE__ */ new Map();
  bboxesById = /* @__PURE__ */ new Map();
  itemsById = /* @__PURE__ */ new Map();
  addItem(id, polygon) {
    this.removeItem(id);
    const bbox = computeBbox(polygon);
    const item = {
      minX: bbox[0],
      minY: bbox[1],
      maxX: bbox[2],
      maxY: bbox[3],
      id
    };
    this.polygonsById.set(id, polygon);
    this.bboxesById.set(id, bbox);
    this.itemsById.set(id, item);
    this.rbush.insert(item);
  }
  removeItem(id) {
    const item = this.itemsById.get(id);
    if (item) {
      this.rbush.remove(item);
      this.polygonsById.delete(id);
      this.bboxesById.delete(id);
      this.itemsById.delete(id);
    }
  }
  clear() {
    this.polygonsById.clear();
    this.bboxesById.clear();
    this.itemsById.clear();
    this.rbush.clear();
  }
  search(minX, minY, maxX, maxY) {
    return this.rbush.search({
      minX,
      minY,
      maxX,
      maxY
    });
  }
  getBbox(id) {
    return this.bboxesById.get(id);
  }
  getPolygon(id) {
    return this.polygonsById.get(id);
  }
  searchFromBbox(bbox) {
    const [minX, minY, maxX, maxY] = bbox;
    return this.search(minX, minY, maxX, maxY).map((item) => item.id);
  }
  searchFromPoint(point2, filterInsidePolygon = DEFAULT_FILTER_INSIDE_POLYGON) {
    const [minX, minY, maxX, maxY] = [point2[0], point2[1], point2[0], point2[1]];
    const rtreeResults = this.search(minX, minY, maxX, maxY);
    if (filterInsidePolygon) {
      return rtreeResults.filter((item) => {
        const polygon = this.polygonsById.get(item.id);
        if (polygon) {
          return pointInPolygon(point2, polygon);
        } else {
          return false;
        }
      }).map((item) => item.id);
    } else {
      return rtreeResults.map((item) => item.id);
    }
  }
};

// node_modules/@allmaps/render/dist/maps/WarpedMapList.js
var defaultSelectionOptions = {
  onlyVisible: true
};
var defaultWarpedMapListOptions = {
  createRTree: true,
  imageInformations: /* @__PURE__ */ new Map()
};
var WarpedMapList = class extends EventTarget {
  warpedMapFactory;
  /**
   * Maps in this list, indexed by their ID
   */
  warpedMapsById;
  zIndices;
  rtree;
  partialWarpedMapListOptions;
  /**
   * Creates an instance of a WarpedMapList
   *
   * @constructor
   * @param warpedMapFactory - Factory function for creating WarpedMap objects
   * @param partialWarpedMapListOptions - Options
   */
  constructor(warpedMapFactory, partialWarpedMapListOptions) {
    super();
    this.warpedMapsById = /* @__PURE__ */ new Map();
    this.zIndices = /* @__PURE__ */ new Map();
    this.warpedMapFactory = warpedMapFactory;
    this.partialWarpedMapListOptions = mergePartialOptions(
      defaultWarpedMapListOptions,
      partialWarpedMapListOptions
    );
    if (this.partialWarpedMapListOptions.createRTree) {
      this.rtree = new RTree();
    }
  }
  /**
   * Get mapIds for selected maps
   *
   * Also allows to only select maps whose geoBbox overlaps with the specified geoBbox
   *
   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps
   * @returns mapIds
   */
  getMapIds(partialSelectionOptions) {
    return Array.from(this.getWarpedMaps(partialSelectionOptions)).map(
      (warpedMap) => warpedMap.mapId
    );
  }
  /**
   * Get the WarpedMap instances for selected maps
   *
   * Also allows to only select maps whose geoBbox overlaps with the specified geoBbox
   *
   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps
   * @returns WarpedMap instances
   */
  getWarpedMaps(partialSelectionOptions) {
    const selectionOptions = mergeOptions(
      defaultSelectionOptions,
      partialSelectionOptions
    );
    let mapIds;
    if (selectionOptions.mapIds === void 0) {
      if (this.rtree && selectionOptions.geoBbox) {
        mapIds = this.rtree.searchFromBbox(selectionOptions.geoBbox);
      } else {
        mapIds = Array.from(this.warpedMapsById.keys());
      }
    } else {
      mapIds = selectionOptions.mapIds;
    }
    const warpedMaps = [];
    if (mapIds === void 0) {
      return warpedMaps;
    }
    for (const mapId of mapIds) {
      const warpedMap = this.warpedMapsById.get(mapId);
      if (warpedMap && (selectionOptions.onlyVisible ? warpedMap.visible : true)) {
        warpedMaps.push(warpedMap);
      }
    }
    return warpedMaps;
  }
  /**
   * Get the WarpedMap instance for a specific map
   *
   * @param mapId - Map ID of the requested WarpedMap instance
   * @returns WarpedMap instance, or undefined
   */
  getWarpedMap(mapId) {
    return this.warpedMapsById.get(mapId);
  }
  /**
   * Get the z-index for a specific map
   *
   * @param mapId
   * @returns
   */
  getMapZIndex(mapId) {
    return this.zIndices.get(mapId);
  }
  /**
   * Get the center of the bounding box of the maps in this list
   *
   * Use {projection: 'EPSG:4326'} to request the result in lon-lat `EPSG:4326`
   *
   * @param partialSelectionAndProjectionOptions - Selection (e.g. mapIds) and projection options, defaults to all visible maps and current projection
   * @returns The center of the bbox of all selected maps, in the chosen projection, or undefined if there were no maps matching the selection.
   */
  getMapsCenter(partialSelectionAndProjectionOptions) {
    const bbox = this.getMapsBbox(partialSelectionAndProjectionOptions);
    if (bbox) {
      return bboxToCenter(bbox);
    }
  }
  /**
   * Get the bounding box of the maps in this list
   *
   * Use {projection: 'EPSG:4326'} to request the result in lon-lat `EPSG:4326`
   *
   * @param partialSelectionAndProjectionOptions - Selection (e.g. mapIds) and projection options, defaults to all visible maps and current projection
   * @returns The bbox of all selected maps, in the chosen projection, or undefined if there were no maps matching the selection.
   */
  getMapsBbox(partialSelectionAndProjectionOptions) {
    const projectedGeoMaskPoints = this.getProjectedGeoMaskPoints(
      partialSelectionAndProjectionOptions
    );
    return computeBbox(projectedGeoMaskPoints);
  }
  /**
   * Get the convex hull of the maps in this list
   *
   * Use {projection: 'EPSG:4326'} to request the result in lon-lat `EPSG:4326`
   *
   * @param partialSelectionAndProjectionOptions - Selection (e.g. mapIds) and projection options, defaults to all visible maps and current projection
   * @returns The convex hull of all selected maps, in the chosen projection, or undefined if there were no maps matching the selection.
   */
  getMapsConvexHull(partialSelectionAndProjectionOptions) {
    const projectedGeoMaskPoints = this.getProjectedGeoMaskPoints(
      partialSelectionAndProjectionOptions
    );
    return convexHull(projectedGeoMaskPoints);
  }
  /**
   * Set the Warped Map List options
   *
   * @param partialWarpedMapListOptions - Options
   */
  setOptions(partialWarpedMapListOptions) {
    this.partialWarpedMapListOptions = mergeOptions(
      this.partialWarpedMapListOptions,
      partialWarpedMapListOptions
    );
    this.dispatchEvent(
      new WarpedMapEvent(WarpedMapEventType.OPTIONSCHANGED, this.getMapIds())
    );
  }
  /**
   * Sets the object that caches image information
   *
   * @param imageInformations - object that caches image information
   */
  setImageInformations(imageInformations) {
    this.partialWarpedMapListOptions.imageInformations = imageInformations;
  }
  /**
   * Sets the GCPs for a specific map
   *
   * @param gcps - new GCPs
   * @param mapId - ID of the map
   */
  setMapGcps(gcps, mapId) {
    const warpedMap = this.warpedMapsById.get(mapId);
    if (warpedMap) {
      warpedMap.setGcps(gcps);
      this.addToOrUpdateRtree(warpedMap);
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.GCPSCHANGED, mapId)
      );
    }
  }
  /**
   * Sets the resource mask for a specific map
   *
   * @param resourceMask - the new resource mask
   * @param mapId - ID of the map
   */
  setMapResourceMask(resourceMask, mapId) {
    const warpedMap = this.warpedMapsById.get(mapId);
    if (warpedMap) {
      warpedMap.setResourceMask(resourceMask);
      this.addToOrUpdateRtree(warpedMap);
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.RESOURCEMASKCHANGED, mapId)
      );
    }
  }
  /**
   * Sets the transformation type for a specific map
   *
   * @param transformationType - the new transformation type
   * @param mapId - the ID of the map
   */
  setMapTransformationType(transformationType, mapId) {
    this.setMapsTransformationType(transformationType, { mapIds: [mapId] });
  }
  /**
   * Sets the transformation type for selected maps
   *
   * @param transformationType - the new transformation type
   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps
   */
  setMapsTransformationType(transformationType, partialSelectionOptions) {
    const mapIdsChanged = [];
    const warpedMaps = this.getWarpedMaps(partialSelectionOptions);
    for (const warpedMap of warpedMaps) {
      if (warpedMap.transformationType !== transformationType) {
        mapIdsChanged.push(warpedMap.mapId);
      }
    }
    if (mapIdsChanged.length > 0) {
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.PRECHANGE, mapIdsChanged)
      );
      mapIdsChanged.forEach((mapId) => {
        const warpedMap = this.warpedMapsById.get(mapId);
        if (warpedMap) {
          warpedMap.setTransformationType(transformationType);
          this.addToOrUpdateRtree(warpedMap);
        }
      });
      this.dispatchEvent(
        new WarpedMapEvent(
          WarpedMapEventType.TRANSFORMATIONCHANGED,
          mapIdsChanged
        )
      );
    }
  }
  /**
   * Sets the distortionMeasure for a specific map
   *
   * @param distortionMeasure - the distortion measure
   * @param mapId - the ID of the map
   */
  setMapDistortionMeasure(distortionMeasure, mapId) {
    this.setMapsDistortionMeasure(distortionMeasure, { mapIds: [mapId] });
  }
  /**
   * Sets the distortion measure for selected maps
   *
   * @param distortionMeasure - the distortion measure
   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps
   */
  setMapsDistortionMeasure(distortionMeasure, partialSelectionOptions) {
    const mapIdsChanged = [];
    const warpedMaps = this.getWarpedMaps(partialSelectionOptions);
    for (const warpedMap of warpedMaps) {
      if (warpedMap.distortionMeasure !== distortionMeasure) {
        mapIdsChanged.push(warpedMap.mapId);
      }
    }
    if (mapIdsChanged.length > 0) {
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.PRECHANGE, mapIdsChanged)
      );
      mapIdsChanged.forEach((mapId) => {
        const warpedMap = this.warpedMapsById.get(mapId);
        if (warpedMap) {
          warpedMap.setDistortionMeasure(distortionMeasure);
        }
      });
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.DISTORTIONCHANGED, mapIdsChanged)
      );
    }
  }
  /**
   * Sets the internal projection for a specific map
   *
   * @param projection - the internal projection
   * @param mapId - the ID of the map
   */
  setMapInternalProjection(projection, mapId) {
    this.setMapsInternalProjection(projection, { mapIds: [mapId] });
  }
  /**
   * Sets the internal projection for selected maps
   *
   * @param projection - the internal projection
   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps
   */
  setMapsInternalProjection(projection, partialSelectionOptions) {
    const mapIdsChanged = [];
    const warpedMaps = this.getWarpedMaps(partialSelectionOptions);
    for (const warpedMap of warpedMaps) {
      if (!isEqualProjection(warpedMap.internalProjection, projection)) {
        mapIdsChanged.push(warpedMap.mapId);
      }
    }
    if (mapIdsChanged.length > 0) {
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.PRECHANGE, mapIdsChanged)
      );
      mapIdsChanged.forEach((mapId) => {
        const warpedMap = this.warpedMapsById.get(mapId);
        if (warpedMap) {
          warpedMap.setInternalProjection(projection);
          this.addToOrUpdateRtree(warpedMap);
        }
      });
      this.dispatchEvent(
        new WarpedMapEvent(
          WarpedMapEventType.INTERNALPROJECTIONCHANGED,
          mapIdsChanged
        )
      );
    }
  }
  /**
   * Sets the projection for a specific map
   *
   * @param projection - the projection
   * @param mapId - the ID of the map
   */
  setMapProjection(projection, mapId) {
    this.setMapsProjection(projection, { mapIds: [mapId] });
  }
  /**
   * Sets the projection for selected maps
   *
   * @param projection - the projection
   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps
   */
  setMapsProjection(projection, partialSelectionOptions) {
    const mapIdsChanged = [];
    const warpedMaps = this.getWarpedMaps(partialSelectionOptions);
    for (const warpedMap of warpedMaps) {
      if (!isEqualProjection(warpedMap.projection, projection)) {
        mapIdsChanged.push(warpedMap.mapId);
      }
    }
    if (mapIdsChanged.length > 0) {
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.PRECHANGE, mapIdsChanged)
      );
      mapIdsChanged.forEach((mapId) => {
        const warpedMap = this.warpedMapsById.get(mapId);
        if (warpedMap) {
          warpedMap.setProjection(projection);
          this.addToOrUpdateRtree(warpedMap);
        }
      });
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.PROJECTIONCHANGED, mapIdsChanged)
      );
    }
  }
  /**
   * Removes a warped map by its ID
   *
   * @param mapId - the ID of the map
   *
   * @param mapIds - Map IDs
   */
  removeGeoreferencedMapById(mapId) {
    const warpedMap = this.warpedMapsById.get(mapId);
    if (warpedMap) {
      this.removeGeoreferencedMap(warpedMap);
      this.removeFromRtree(warpedMap);
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.WARPEDMAPREMOVED, mapId)
      );
    }
  }
  /**
   * Changes the z-index of the specified maps to bring them to front
   *
   * @param mapIds - Map IDs
   */
  bringMapsToFront(mapIds) {
    let newZIndex = this.warpedMapsById.size;
    for (const mapId of mapIds) {
      if (this.zIndices.has(mapId)) {
        this.zIndices.set(mapId, newZIndex);
        newZIndex++;
      }
    }
    this.removeZIndexHoles();
    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED));
  }
  /**
   * Changes the z-index of the specified maps to send them to back
   *
   * @param mapIds - Map IDs
   */
  sendMapsToBack(mapIds) {
    let newZIndex = -Array.from(mapIds).length;
    for (const mapId of mapIds) {
      if (this.zIndices.has(mapId)) {
        this.zIndices.set(mapId, newZIndex);
        newZIndex++;
      }
    }
    this.removeZIndexHoles();
    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED));
  }
  /**
   * Changes the z-index of the specified maps to bring them forward
   *
   * @param mapIds - Map IDs
   */
  bringMapsForward(mapIds) {
    for (const [mapId, zIndex] of this.zIndices.entries()) {
      this.zIndices.set(mapId, zIndex * 2);
    }
    for (const mapId of mapIds) {
      const zIndex = this.zIndices.get(mapId);
      if (zIndex !== void 0) {
        this.zIndices.set(mapId, zIndex + 3);
      }
    }
    this.removeZIndexHoles();
    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED));
  }
  /**
   * Changes the zIndex of the specified maps to send them backward
   *
   * @param mapIds - Map IDs
   */
  sendMapsBackward(mapIds) {
    for (const [mapId, zIndex] of this.zIndices.entries()) {
      this.zIndices.set(mapId, zIndex * 2);
    }
    for (const mapId of mapIds) {
      const zIndex = this.zIndices.get(mapId);
      if (zIndex !== void 0) {
        this.zIndices.set(mapId, zIndex - 3);
      }
    }
    this.removeZIndexHoles();
    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED));
  }
  /**
   * Changes the visibility of the specified maps to `true`
   *
   * @param mapIds - Map IDs
   */
  showMaps(mapIds) {
    for (const mapId of mapIds) {
      const warpedMap = this.warpedMapsById.get(mapId);
      if (warpedMap) {
        warpedMap.visible = true;
      }
    }
    this.dispatchEvent(
      new WarpedMapEvent(WarpedMapEventType.VISIBILITYCHANGED, mapIds)
    );
  }
  /**
   * Changes the visibility of the specified maps to `false`
   *
   * @param mapIds - Map IDs
   */
  hideMaps(mapIds) {
    for (const mapId of mapIds) {
      const warpedMap = this.warpedMapsById.get(mapId);
      if (warpedMap) {
        warpedMap.visible = false;
      }
    }
    this.dispatchEvent(
      new WarpedMapEvent(WarpedMapEventType.VISIBILITYCHANGED, mapIds)
    );
  }
  /**
   * Adds a georeferenced map to this list
   *
   * @param georeferencedMap
   * @returns
   */
  async addGeoreferencedMap(georeferencedMap) {
    const validatedGeoreferencedMapOrMaps = validateGeoreferencedMap(georeferencedMap);
    const validatedGeoreferencedMap = Array.isArray(
      validatedGeoreferencedMapOrMaps
    ) ? validatedGeoreferencedMapOrMaps[0] : validatedGeoreferencedMapOrMaps;
    return this.addGeoreferencedMapInternal(validatedGeoreferencedMap);
  }
  /**
   * Removes a georeferenced map from this list
   *
   * @param georeferencedMap
   * @returns
   */
  async removeGeoreferencedMap(georeferencedMap) {
    const validatedGeoreferencedMapOrMaps = validateGeoreferencedMap(georeferencedMap);
    const validatedGeoreferencedMap = Array.isArray(
      validatedGeoreferencedMapOrMaps
    ) ? validatedGeoreferencedMapOrMaps[0] : validatedGeoreferencedMapOrMaps;
    return this.removeGeoreferencedMapInternal(validatedGeoreferencedMap);
  }
  /**
   * Parses an annotation and adds its georeferenced map to this list
   *
   * @param annotation
   * @returns
   */
  async addGeoreferenceAnnotation(annotation) {
    const results = [];
    const maps = parseAnnotation(annotation);
    const settledResults = await Promise.allSettled(
      maps.map((map2) => this.addGeoreferencedMapInternal(map2))
    );
    for (const settledResult of settledResults) {
      if (settledResult.status === "fulfilled") {
        results.push(settledResult.value);
      } else {
        results.push(settledResult.reason);
      }
    }
    this.dispatchEvent(
      new WarpedMapEvent(WarpedMapEventType.GEOREFERENCEANNOTATIONADDED)
    );
    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED));
    return results;
  }
  /**
   * Parses an annotation and removes its georeferenced map from this list
   *
   * @param annotation
   * @returns
   */
  async removeGeoreferenceAnnotation(annotation) {
    const results = [];
    const maps = parseAnnotation(annotation);
    for (const map2 of maps) {
      const mapIdOrError = await this.removeGeoreferencedMapInternal(map2);
      results.push(mapIdOrError);
    }
    this.dispatchEvent(
      new WarpedMapEvent(WarpedMapEventType.GEOREFERENCEANNOTATIONREMOVED)
    );
    return results;
  }
  clear() {
    this.warpedMapsById = /* @__PURE__ */ new Map();
    this.zIndices = /* @__PURE__ */ new Map();
    this.rtree?.clear();
    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.CLEARED));
  }
  destroy() {
    for (const warpedMap of this.getWarpedMaps()) {
      this.removeEventListenersFromWarpedMap(warpedMap);
      warpedMap.destroy();
    }
    this.clear();
  }
  async addGeoreferencedMapInternal(georeferencedMap) {
    const mapId = await this.getOrComputeMapId(georeferencedMap);
    const warpedMap = this.warpedMapFactory(
      mapId,
      georeferencedMap,
      this.partialWarpedMapListOptions
    );
    this.warpedMapsById.set(mapId, warpedMap);
    this.zIndices.set(mapId, this.warpedMapsById.size - 1);
    this.addToOrUpdateRtree(warpedMap);
    this.addEventListenersToWarpedMap(warpedMap);
    this.dispatchEvent(
      new WarpedMapEvent(WarpedMapEventType.WARPEDMAPADDED, mapId)
    );
    return mapId;
  }
  async removeGeoreferencedMapInternal(georeferencedMap) {
    const mapId = await this.getOrComputeMapId(georeferencedMap);
    const warpedMap = this.warpedMapsById.get(mapId);
    if (warpedMap) {
      this.warpedMapsById.delete(mapId);
      this.zIndices.delete(mapId);
      this.removeFromRtree(warpedMap);
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.WARPEDMAPREMOVED, mapId)
      );
      this.removeZIndexHoles();
      this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED));
      warpedMap.destroy();
    } else {
      throw new Error(`No map found with ID ${mapId}`);
    }
    return mapId;
  }
  async getOrComputeMapId(georeferencedMap) {
    const mapId = georeferencedMap.id || await generateChecksum(georeferencedMap);
    return mapId;
  }
  getProjectedGeoMaskPoints(partialSelectionAndProjectionOptions) {
    const warpedMaps = this.getWarpedMaps(partialSelectionAndProjectionOptions);
    const projection = partialSelectionAndProjectionOptions?.projection;
    if (projection) {
      const geoMaskPoints = [];
      for (const warpedMap of warpedMaps) {
        geoMaskPoints.push(...warpedMap.geoMask);
      }
      const projectedGeoMaskPoints = geoMaskPoints.map(
        (point2) => lib_default(projection.definition, point2)
      );
      return projectedGeoMaskPoints;
    } else {
      const projectedGeoMaskPoints = [];
      for (const warpedMap of warpedMaps) {
        projectedGeoMaskPoints.push(...warpedMap.projectedGeoMask);
      }
      return projectedGeoMaskPoints;
    }
  }
  addToOrUpdateRtree(warpedMap) {
    if (this.rtree) {
      this.rtree.removeItem(warpedMap.mapId);
      this.rtree.addItem(warpedMap.mapId, [warpedMap.geoMask]);
    }
  }
  removeFromRtree(warpedMap) {
    if (this.rtree) {
      this.rtree.removeItem(warpedMap.mapId);
    }
  }
  removeZIndexHoles() {
    const sortedZIndices = [...this.zIndices.entries()].sort(
      (entryA, entryB) => entryA[1] - entryB[1]
    );
    let zIndex = 0;
    for (const entry of sortedZIndices) {
      const mapId = entry[0];
      this.zIndices.set(mapId, zIndex);
      zIndex++;
    }
  }
  // This function and the listeners below transform an IMAGEINFOLOADED event by a WarpedMap
  // to an IMAGEINFOLOADED of the WarpedMapList, which is listened to in the Renderer
  imageInfoLoaded() {
    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.IMAGEINFOLOADED));
  }
  addEventListenersToWarpedMap(warpedMap) {
    warpedMap.addEventListener(
      WarpedMapEventType.IMAGEINFOLOADED,
      this.imageInfoLoaded.bind(this)
    );
  }
  removeEventListenersFromWarpedMap(warpedMap) {
    warpedMap.removeEventListener(
      WarpedMapEventType.IMAGEINFOLOADED,
      this.imageInfoLoaded.bind(this)
    );
  }
};

// node_modules/@allmaps/render/dist/tilecache/FetchableTile.js
var FetchableTile = class {
  mapId;
  tile;
  imageRequest;
  tileUrl;
  tileKey;
  fetchableTileKey;
  /**
   * Creates an instance of FetchableTile.
   *
   * @constructor
   * @param tile - the tile
   * @param warpedMap - A WarpedMap with fetched image information
   */
  constructor(tile, warpedMap) {
    this.mapId = warpedMap.mapId;
    this.tile = tile;
    const imageRequest = warpedMap.parsedImage.getTileImageRequest(
      tile.tileZoomLevel,
      tile.column,
      tile.row
    );
    this.imageRequest = imageRequest;
    this.tileUrl = warpedMap.parsedImage.getImageUrl(imageRequest);
    this.tileKey = tileKey(tile);
    this.fetchableTileKey = fetchableTileKey(this);
  }
};

// node_modules/@allmaps/render/dist/renderers/BaseRenderer.js
var defaultBaseRendererOptions = {};
var REQUEST_VIEWPORT_BUFFER_RATIO = 0;
var OVERVIEW_REQUEST_VIEWPORT_BUFFER_RATIO = 2;
var PRUNE_VIEWPORT_BUFFER_RATIO = 4;
var OVERVIEW_PRUNE_VIEWPORT_BUFFER_RATIO = 10;
var SCALE_FACTOR_CORRECTION = 0;
var LOG2_SCALE_FACTOR_CORRECTION = 0.4;
var MAX_MAP_OVERVIEW_RESOLUTION = 1024 * 1024;
var MAX_TOTAL_RESOLUTION_RATIO = 10;
var MAX_GCPS_EXACT_TPS_TO_RESOURCE = 100;
var BaseRenderer = class extends EventTarget {
  partialBaseRendererOptions;
  warpedMapList;
  tileCache;
  mapsInPreviousViewport = /* @__PURE__ */ new Set();
  mapsInViewport = /* @__PURE__ */ new Set();
  mapsWithRequestedTilesForViewport = /* @__PURE__ */ new Set();
  viewport;
  constructor(cachableTileFactory, warpedMapFactory, partialBaseRendererOptions) {
    super();
    this.partialBaseRendererOptions = mergeOptions(
      defaultBaseRendererOptions,
      partialBaseRendererOptions
    );
    this.tileCache = new TileCache(
      cachableTileFactory,
      partialBaseRendererOptions
    );
    this.warpedMapList = new WarpedMapList(
      warpedMapFactory,
      partialBaseRendererOptions
    );
  }
  /**
   * Parses an annotation and adds its georeferenced map to this renderer's warped map list
   *
   * @param annotation
   * @returns
   */
  async addGeoreferenceAnnotation(annotation) {
    return this.warpedMapList.addGeoreferenceAnnotation(annotation);
  }
  /**
   * Adds a georeferenced map to this renderer's warped map list
   *
   * @param georeferencedMap
   * @returns
   */
  async addGeoreferencedMap(georeferencedMap) {
    return this.warpedMapList.addGeoreferencedMap(georeferencedMap);
  }
  /**
   * Set the Base Renderer options
   *
   * @param partialBaseRendererOptions - Options
   */
  setOptions(partialBaseRendererOptions) {
    this.partialBaseRendererOptions = mergeOptions(
      this.partialBaseRendererOptions,
      partialBaseRendererOptions
    );
    this.tileCache.setOptions(partialBaseRendererOptions);
    this.warpedMapList.setOptions(partialBaseRendererOptions);
  }
  loadMissingImageInfosInViewport() {
    if (!this.viewport) {
      return [];
    }
    return Array.from(
      this.warpedMapList.getWarpedMaps({
        geoBbox: this.viewport.geoRectangleBbox
      })
    ).filter(
      (warpedMap) => !warpedMap.hasImageInfo() && !warpedMap.loadingImageInfo
    ).map((warpedMap) => warpedMap.loadImageInfo());
  }
  someImageInfosInViewport() {
    if (!this.viewport) {
      return false;
    }
    return Array.from(
      this.findMapsInViewport(
        this.shouldAnticipateInteraction() ? OVERVIEW_PRUNE_VIEWPORT_BUFFER_RATIO : 0
      )
    ).map((mapId) => this.warpedMapList.getWarpedMap(mapId)).map((warpedMap) => warpedMap.hasImageInfo()).some(Boolean);
  }
  shouldRequestFetchableTiles() {
    return true;
  }
  // Should we anticipate user interaction (panning or zooming)
  // and hence buffer the viewport or get overview tiles
  shouldAnticipateInteraction() {
    return false;
  }
  assureProjection() {
    if (!this.viewport) {
      return;
    }
    this.warpedMapList.partialWarpedMapListOptions.projection = this.viewport.projection;
    this.warpedMapList.setMapsProjection(this.viewport.projection, {
      onlyVisible: false
    });
  }
  requestFetchableTiles() {
    if (!this.shouldRequestFetchableTiles()) {
      return;
    }
    const fetchableTilesForViewport = [];
    const overviewFetchableTilesForViewport = [];
    const mapsInViewportForRequest = this.findMapsInViewport(
      this.shouldAnticipateInteraction() ? REQUEST_VIEWPORT_BUFFER_RATIO : 0
    );
    const mapsInViewportForOverviewRequest = this.findMapsInViewport(
      this.shouldAnticipateInteraction() ? OVERVIEW_REQUEST_VIEWPORT_BUFFER_RATIO : 0
    );
    const mapsInViewportForPrune = this.findMapsInViewport(
      this.shouldAnticipateInteraction() ? PRUNE_VIEWPORT_BUFFER_RATIO : 0
    );
    const mapsInViewportForOverviewPrune = this.findMapsInViewport(
      this.shouldAnticipateInteraction() ? OVERVIEW_PRUNE_VIEWPORT_BUFFER_RATIO : 0
    );
    for (const warpedMap of this.warpedMapList.getWarpedMaps()) {
      warpedMap.resetForViewport();
    }
    for (const mapId of mapsInViewportForPrune) {
      fetchableTilesForViewport.push(
        ...this.getMapFetchableTilesForViewport(mapId, mapsInViewportForRequest)
      );
    }
    if (this.shouldAnticipateInteraction()) {
      for (const mapId of mapsInViewportForOverviewPrune) {
        overviewFetchableTilesForViewport.push(
          ...this.getMapOverviewFetchableTilesForViewport(
            mapId,
            [
              ...fetchableTilesForViewport,
              ...overviewFetchableTilesForViewport
            ],
            mapsInViewportForOverviewRequest
          )
        );
      }
    }
    this.tileCache.requestFetchableTiles([
      ...fetchableTilesForViewport,
      ...overviewFetchableTilesForViewport
    ]);
    this.updateMapsForViewport([
      ...fetchableTilesForViewport,
      ...overviewFetchableTilesForViewport
    ]);
    this.pruneTileCache(mapsInViewportForOverviewPrune);
  }
  findMapsInViewport(viewportBufferRatio = 0) {
    if (!this.viewport) {
      return /* @__PURE__ */ new Set();
    }
    const viewport = this.viewport;
    const projectedGeoBufferedRectangle = this.viewport.getProjectedGeoBufferedRectangle(viewportBufferRatio);
    const geoBufferedRectangleBbox = computeBbox(
      projectedGeoBufferedRectangle.map(
        (point2) => lib_default(
          viewport.projection.definition,
          lonLatProjection.definition,
          point2
        )
      )
    );
    return new Set(
      Array.from(
        this.warpedMapList.getWarpedMaps({ geoBbox: geoBufferedRectangleBbox })
      ).sort((warpedMapA, warpedMapB) => {
        if (warpedMapA && warpedMapB) {
          return squaredDistance(
            bboxToCenter(warpedMapA.projectedGeoMaskBbox),
            viewport.projectedGeoCenter
          ) - squaredDistance(
            bboxToCenter(warpedMapB.projectedGeoMaskBbox),
            viewport.projectedGeoCenter
          );
        } else {
          return 0;
        }
      }).map((warpedMap) => warpedMap.mapId)
    );
  }
  getMapFetchableTilesForViewport(mapId, mapsInViewportForRequest) {
    if (!this.viewport) {
      return [];
    }
    const viewport = this.viewport;
    const warpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (!warpedMap) {
      return [];
    }
    if (!warpedMap.visible) {
      return [];
    }
    if (!warpedMap.hasImageInfo()) {
      return [];
    }
    const tileZoomLevel = getTileZoomLevelForScale(
      warpedMap.parsedImage.tileZoomLevels,
      warpedMap.getResourceToCanvasScale(viewport),
      SCALE_FACTOR_CORRECTION,
      LOG2_SCALE_FACTOR_CORRECTION
    );
    warpedMap.setTileZoomLevelForViewport(tileZoomLevel);
    const transformerOptions = {
      maxDepth: 0,
      // maxDepth: 2,
      // minOffsetRatio: 0.00001,
      sourceIsGeographic: false,
      destinationIsGeographic: true
    };
    const projectedGeoBufferedViewportRectangle = viewport.getProjectedGeoBufferedRectangle(
      this.shouldAnticipateInteraction() ? REQUEST_VIEWPORT_BUFFER_RATIO : 0
    );
    const projectedTransformer = warpedMap.transformationType === "thinPlateSpline" && warpedMap.gcps.length > MAX_GCPS_EXACT_TPS_TO_RESOURCE ? warpedMap.getProjectedTransformer("polynomial") : warpedMap.projectedTransformer;
    const resourceBufferedViewportRing = projectedTransformer.transformToResource(
      [projectedGeoBufferedViewportRectangle],
      transformerOptions
    )[0];
    warpedMap.setProjectedGeoBufferedViewportRectangleForViewport(
      projectedGeoBufferedViewportRectangle
    );
    warpedMap.setResourceBufferedViewportRingForViewport(
      resourceBufferedViewportRing
    );
    if (!warpedMap.resourceBufferedViewportRingBboxForViewport || !warpedMap.resourceBufferedViewportRingBboxForViewport) {
      throw new Error(
        "No resourceBufferedViewportRingBboxForViewport or resourceBufferedViewportRingBboxForViewport"
      );
    }
    const resourceBufferedViewportRingBboxAndResourceMaskBboxIntersection = intersectBboxes(
      warpedMap.resourceBufferedViewportRingBboxForViewport,
      warpedMap.resourceMaskBbox
    );
    warpedMap.setResourceBufferedViewportRingBboxAndResourceMaskBboxIntersectionForViewport(
      resourceBufferedViewportRingBboxAndResourceMaskBboxIntersection
    );
    if (!mapsInViewportForRequest.has(mapId)) {
      return [];
    }
    if (!resourceBufferedViewportRingBboxAndResourceMaskBboxIntersection) {
      return [];
    }
    const tiles = computeTilesCoveringRingAtTileZoomLevel(
      bboxToRectangle(
        resourceBufferedViewportRingBboxAndResourceMaskBboxIntersection
      ),
      tileZoomLevel,
      [warpedMap.parsedImage.width, warpedMap.parsedImage.height]
    );
    const resourceBufferedViewportRingCenter = bboxToCenter(
      warpedMap.resourceBufferedViewportRingBboxForViewport
    );
    tiles.sort(
      (tileA, tileB) => squaredDistanceTileToPoint(tileA, resourceBufferedViewportRingCenter) - squaredDistanceTileToPoint(tileB, resourceBufferedViewportRingCenter)
    );
    const fetchableTiles = tiles.map(
      (tile) => new FetchableTile(tile, warpedMap)
    );
    warpedMap.setFetchableTilesForViewport(fetchableTiles);
    return fetchableTiles;
  }
  getMapOverviewFetchableTilesForViewport(mapId, totalFetchableTilesForViewport, mapsInViewportForOverviewRequest) {
    if (!this.viewport) {
      return [];
    }
    const warpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (!warpedMap) {
      return [];
    }
    if (!warpedMap.visible) {
      return [];
    }
    if (!warpedMap.hasImageInfo()) {
      return [];
    }
    const totalFetchableTilesResolution = getTilesResolution(
      totalFetchableTilesForViewport.map((fetchableTile) => fetchableTile.tile)
    );
    const maxTotalFetchableTilesResolution = this.viewport.canvasResolution * MAX_TOTAL_RESOLUTION_RATIO;
    if (totalFetchableTilesResolution > maxTotalFetchableTilesResolution) {
      return [];
    }
    const overviewTileZoomLevel = warpedMap.parsedImage.tileZoomLevels.filter(
      (tileZoomLevel) => getTileZoomLevelResolution(tileZoomLevel) <= MAX_MAP_OVERVIEW_RESOLUTION
      // Neglect zoomlevels that contain too many pixels
    ).sort(
      (tileZoomLevel0, tileZoomLevel1) => tileZoomLevel0.scaleFactor - tileZoomLevel1.scaleFactor
      // Enforcing default ascending order, e.g. from 1 to 16
    ).at(-1);
    warpedMap.setOverviewTileZoomLevelForViewport(overviewTileZoomLevel);
    if (!mapsInViewportForOverviewRequest.has(mapId)) {
      return [];
    }
    if (!overviewTileZoomLevel || warpedMap.tileZoomLevelForViewport && overviewTileZoomLevel.scaleFactor <= warpedMap.tileZoomLevelForViewport.scaleFactor) {
      return [];
    }
    const overviewTiles = getTilesAtScaleFactor(
      overviewTileZoomLevel.scaleFactor,
      warpedMap.parsedImage
    );
    const overviewFetchableTiles = overviewTiles.map(
      (tile) => new FetchableTile(tile, warpedMap)
    );
    warpedMap.setOverviewFetchableTilesForViewport(overviewFetchableTiles);
    return overviewFetchableTiles;
  }
  updateMapsForViewport(tiles) {
    this.mapsWithRequestedTilesForViewport = new Set(
      tiles.map((tile) => tile.mapId).filter((v2, i, a) => {
        return a.indexOf(v2) === i;
      }).sort((mapIdA, mapIdB) => {
        const zIndexA = this.warpedMapList.getMapZIndex(mapIdA);
        const zIndexB = this.warpedMapList.getMapZIndex(mapIdB);
        if (zIndexA !== void 0 && zIndexB !== void 0) {
          return zIndexA - zIndexB;
        }
        return 0;
      })
    );
    this.mapsInPreviousViewport = this.mapsInViewport;
    this.mapsInViewport = this.findMapsInViewport();
    const mapsInPreviousViewportAsArray = Array.from(
      this.mapsInPreviousViewport
    );
    const mapsInViewportAsArray = Array.from(this.mapsInViewport);
    const mapsEnteringViewport = mapsInViewportAsArray.filter(
      (mapId) => !mapsInPreviousViewportAsArray.includes(mapId)
    );
    const mapsLeavingViewport = mapsInPreviousViewportAsArray.filter(
      (mapId) => !mapsInViewportAsArray.includes(mapId)
    );
    for (const mapId of mapsEnteringViewport) {
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.WARPEDMAPENTER, mapId)
      );
    }
    for (const mapId of mapsLeavingViewport) {
      this.clearMap(mapId);
      this.dispatchEvent(
        new WarpedMapEvent(WarpedMapEventType.WARPEDMAPLEAVE, mapId)
      );
    }
    return {
      mapsEnteringViewport,
      mapsLeavingViewport
    };
  }
  pruneTileCache(mapsInViewportForOverviewPrune) {
    const pruneInfoByMapId = /* @__PURE__ */ new Map();
    for (const warpedMap of this.warpedMapList.getWarpedMaps({
      mapIds: mapsInViewportForOverviewPrune
    })) {
      pruneInfoByMapId.set(warpedMap.mapId, {
        tileZoomLevelForViewport: warpedMap.tileZoomLevelForViewport,
        overviewTileZoomLevelForViewport: warpedMap.overviewTileZoomLevelForViewport,
        resourceViewportRingBboxForViewport: warpedMap.resourceBufferedViewportRingBboxForViewport
      });
    }
    this.tileCache.prune(pruneInfoByMapId);
  }
  destroy() {
    this.tileCache.destroy();
    this.warpedMapList.destroy();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  clearMap(mapId) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  mapTileLoaded(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  mapTileRemoved(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  imageInfoLoaded(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  warpedMapAdded(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  warpedMapRemoved(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  preChange(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  optionsChanged(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  gcpsChanged(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  resourceMaskChanged(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  transformationChanged(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  distortionChanged(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  internalProjectionChanged(event) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  projectionChanged(event) {
  }
  addEventListeners() {
    this.tileCache.addEventListener(
      WarpedMapEventType.MAPTILELOADED,
      this.mapTileLoaded.bind(this)
    );
    this.tileCache.addEventListener(
      WarpedMapEventType.MAPTILEREMOVED,
      this.mapTileRemoved.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.IMAGEINFOLOADED,
      this.imageInfoLoaded.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.WARPEDMAPADDED,
      this.warpedMapAdded.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.WARPEDMAPREMOVED,
      this.warpedMapRemoved.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.PRECHANGE,
      this.preChange.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.OPTIONSCHANGED,
      this.optionsChanged.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.GCPSCHANGED,
      this.gcpsChanged.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.RESOURCEMASKCHANGED,
      this.gcpsChanged.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.TRANSFORMATIONCHANGED,
      this.transformationChanged.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.DISTORTIONCHANGED,
      this.distortionChanged.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.INTERNALPROJECTIONCHANGED,
      this.internalProjectionChanged.bind(this)
    );
    this.warpedMapList.addEventListener(
      WarpedMapEventType.PROJECTIONCHANGED,
      this.projectionChanged.bind(this)
    );
  }
  removeEventListeners() {
    this.tileCache.removeEventListener(
      WarpedMapEventType.MAPTILELOADED,
      this.mapTileLoaded.bind(this)
    );
    this.tileCache.removeEventListener(
      WarpedMapEventType.MAPTILEREMOVED,
      this.mapTileRemoved.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.IMAGEINFOLOADED,
      this.imageInfoLoaded.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.WARPEDMAPADDED,
      this.warpedMapAdded.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.WARPEDMAPREMOVED,
      this.warpedMapRemoved.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.PRECHANGE,
      this.preChange.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.OPTIONSCHANGED,
      this.optionsChanged.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.GCPSCHANGED,
      this.gcpsChanged.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.RESOURCEMASKCHANGED,
      this.gcpsChanged.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.TRANSFORMATIONCHANGED,
      this.transformationChanged.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.DISTORTIONCHANGED,
      this.distortionChanged.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.INTERNALPROJECTIONCHANGED,
      this.internalProjectionChanged.bind(this)
    );
    this.warpedMapList.removeEventListener(
      WarpedMapEventType.PROJECTIONCHANGED,
      this.projectionChanged.bind(this)
    );
  }
};

// node_modules/@allmaps/triangulate/dist/shared.js
function interpolateLine(line, dist2) {
  const lineDistance = distance(line);
  const steps = Math.ceil(lineDistance / dist2) - 1;
  const angle = lineAngle(line);
  let currentPoint = line[0];
  const result2 = [currentPoint];
  for (let step = 1; step <= steps; step++) {
    currentPoint = stepDistanceAngle(currentPoint, dist2, angle);
    result2.push(currentPoint);
  }
  return result2;
}
function interpolateRing(ring, dist2) {
  ring = closeRing(ring);
  let result2 = [];
  for (let i = 0; i < ring.length - 1; i++) {
    result2 = result2.concat(interpolateLine([ring[i], ring[i + 1]], dist2));
  }
  return result2;
}
function interpolatePolygon(polygon, dist2) {
  return polygon.map((ring) => interpolateRing(ring, dist2));
}
function getGridPointsInBbox(bbox, gridSize) {
  const grid = [];
  for (let x = bbox[0] + gridSize, i = 0; x <= bbox[2]; i++, x += gridSize) {
    for (let y = bbox[1] + gridSize, j = 0; y <= bbox[3]; j++, y += gridSize) {
      grid.push([x, y]);
    }
  }
  return grid;
}
function pointInPolygon2(point2, polygon) {
  try {
    return pointInPolygon(point2, closePolygon(polygon)) === true;
  } catch (error) {
    console.error("Error determining if point is inside polygon:", error);
    return false;
  }
}

// node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points, getX = defaultGetX, getY = defaultGetY) {
    const n = points.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < n; i++) {
      const x = coords[2 * i];
      const y = coords[2 * i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    let i0, i1, i2;
    for (let i = 0, minDist = Infinity; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    for (let i = 0, minDist = Infinity; i < n; i++) {
      if (i === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1) continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id = this._ids[i];
        const d = this._dists[id];
        if (d > d0) {
          hull[j++] = id;
          d0 = d;
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i = i1;
      const x = i1x;
      const y = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x;
      i2y = y;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k = 0, xp, yp; k < this._ids.length; k++) {
      const i = this._ids[k];
      const x = coords[2 * i];
      const y = coords[2 * i + 1];
      if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
      xp = x;
      yp = y;
      if (i === i0 || i === i1 || i === i2) continue;
      let start2 = 0;
      for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
        start2 = hullHash[(key + j) % this._hashSize];
        if (start2 !== -1 && start2 !== hullNext[start2]) break;
      }
      start2 = hullPrev[start2];
      let e = start2, q;
      while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
        e = q;
        if (e === start2) {
          e = -1;
          break;
        }
      }
      if (e === -1) continue;
      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q = hullNext[n2], orient2d(x, y, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e === start2) {
        while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
          this._legalize(t + 2);
          hullTri[q] = t;
          hullNext[e] = e;
          hullSize--;
          e = q;
        }
      }
      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x, y)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x, y) {
    return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b = halfedges[a];
      const a0 = a - a % 3;
      ar = a0 + (a + 2) % 3;
      if (b === -1) {
        if (i === 0) break;
        a = EDGE_STACK[--i];
        continue;
      }
      const b0 = b - b % 3;
      const al = a0 + (a + 1) % 3;
      const bl = b0 + (b + 2) % 3;
      const p0 = triangles[ar];
      const pr = triangles[a];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p0],
        coords[2 * p0 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a] = p1;
        triangles[b] = p0;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a, hbl);
        this._link(b, halfedges[ar]);
        this._link(ar, bl);
        const br = b0 + (b + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br;
        }
      } else {
        if (i === 0) break;
        a = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a, b) {
    this._halfedges[a] = b;
    if (b !== -1) this._halfedges[b] = a;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a, b, c) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a);
    this._link(t + 1, b);
    this._link(t + 2, c);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x = (ey * bl - dy * cl) * d;
  const y = (dx * cl - ex * bl) * d;
  return x * x + y * y;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x = ax + (ey * bl - dy * cl) * d;
  const y = ay + (dx * cl - ex * bl) * d;
  return { x, y };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp = ids[i];
      const tempDist = dists[temp];
      let j = i - 1;
      while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
      ids[j + 1] = temp;
    }
  } else {
    const median = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap(ids, median, i);
    if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);
    const temp = ids[i];
    const tempDist = dists[temp];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i) break;
      swap(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp;
    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/@kninnug/constrainautor/lib/Constrainautor.mjs
var BitSet = class {
  constructor(W, bs) {
    this.W = W;
    this.bs = bs;
  }
  /**
   * Add a number to the set.
   *
   * @param idx The number to add. Must be 0 <= idx < len.
   * @return this.
   */
  add(idx) {
    const W = this.W, byte = idx / W | 0, bit = idx % W;
    this.bs[byte] |= 1 << bit;
    return this;
  }
  /**
   * Delete a number from the set.
   *
   * @param idx The number to delete. Must be 0 <= idx < len.
   * @return this.
   */
  delete(idx) {
    const W = this.W, byte = idx / W | 0, bit = idx % W;
    this.bs[byte] &= ~(1 << bit);
    return this;
  }
  /**
   * Add or delete a number in the set, depending on the second argument.
   *
   * @param idx The number to add or delete. Must be 0 <= idx < len.
   * @param val If true, add the number, otherwise delete.
   * @return val.
   */
  set(idx, val) {
    const W = this.W, byte = idx / W | 0, bit = idx % W, m = 1 << bit;
    this.bs[byte] ^= (-val ^ this.bs[byte]) & m;
    return val;
  }
  /**
   * Whether the number is in the set.
   *
   * @param idx The number to test. Must be 0 <= idx < len.
   * @return True if the number is in the set.
   */
  has(idx) {
    const W = this.W, byte = idx / W | 0, bit = idx % W;
    return !!(this.bs[byte] & 1 << bit);
  }
  /**
   * Iterate over the numbers that are in the set. The callback is invoked
   * with each number that is set. It is allowed to change the BitSet during
   * iteration. If it deletes a number that has not been iterated over, that
   * number will not show up in a later call. If it adds a number during
   * iteration, that number may or may not show up in a later call.
   *
   * @param fn The function to call for each number.
   * @return this.
   */
  forEach(fn) {
    const W = this.W, bs = this.bs, len = bs.length;
    for (let byte = 0; byte < len; byte++) {
      let bit = 0;
      while (bs[byte] && bit < W) {
        if (bs[byte] & 1 << bit) {
          fn(byte * W + bit);
        }
        bit++;
      }
    }
    return this;
  }
};
var BitSet8 = class extends BitSet {
  /**
   * Create a bit set.
   *
   * @param len The length of the bit set, limiting the maximum value that
   *        can be stored in it to len - 1.
   */
  constructor(len) {
    const W = 8, bs = new Uint8Array(Math.ceil(len / W)).fill(0);
    super(W, bs);
  }
};
function nextEdge(e) {
  return e % 3 === 2 ? e - 2 : e + 1;
}
function prevEdge(e) {
  return e % 3 === 0 ? e + 2 : e - 1;
}
var Constrainautor = class {
  /**
   * Make a Constrainautor.
   *
   * @param del The triangulation output from Delaunator.
   * @param edges If provided, constrain these edges as by constrainAll.
   */
  constructor(del, edges) {
    if (!del || typeof del !== "object" || !del.triangles || !del.halfedges || !del.coords) {
      throw new Error("Expected an object with Delaunator output");
    }
    if (del.triangles.length % 3 || del.halfedges.length !== del.triangles.length || del.coords.length % 2) {
      throw new Error("Delaunator output appears inconsistent");
    }
    if (del.triangles.length < 3) {
      throw new Error("No edges in triangulation");
    }
    this.del = del;
    const U32NIL = 2 ** 32 - 1, numPoints = del.coords.length >> 1, numEdges = del.triangles.length;
    this.vertMap = new Uint32Array(numPoints).fill(U32NIL);
    this.flips = new BitSet8(numEdges);
    this.consd = new BitSet8(numEdges);
    for (let e = 0; e < numEdges; e++) {
      const v2 = del.triangles[e];
      if (this.vertMap[v2] === U32NIL) {
        this.updateVert(e);
      }
    }
    if (edges) {
      this.constrainAll(edges);
    }
  }
  /**
   * Constrain the triangulation such that there is an edge between p1 and p2.
   *
   * @param segP1 The index of one segment end-point in the coords array.
   * @param segP2 The index of the other segment end-point in the coords array.
   * @return The id of the edge that points from p1 to p2. If the
   *         constrained edge lies on the hull and points in the opposite
   *         direction (p2 to p1), the negative of its id is returned.
   */
  constrainOne(segP1, segP2) {
    const { triangles, halfedges } = this.del, vm = this.vertMap, consd = this.consd, start2 = vm[segP1];
    let edg = start2;
    do {
      const p4 = triangles[edg], nxt = nextEdge(edg);
      if (p4 === segP2) {
        return this.protect(edg);
      }
      const opp = prevEdge(edg), p3 = triangles[opp];
      if (p3 === segP2) {
        this.protect(nxt);
        return nxt;
      }
      if (this.intersectSegments(segP1, segP2, p3, p4)) {
        edg = opp;
        break;
      }
      const adj = halfedges[nxt];
      edg = adj;
    } while (edg !== -1 && edg !== start2);
    let conEdge = edg;
    let rescan = -1;
    while (edg !== -1) {
      const adj = halfedges[edg], bot = prevEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj);
      if (adj === -1) {
        throw new Error("Constraining edge exited the hull");
      }
      if (consd.has(edg)) {
        throw new Error("Edge intersects already constrained edge");
      }
      if (this.isCollinear(segP1, segP2, triangles[edg]) || this.isCollinear(segP1, segP2, triangles[adj])) {
        throw new Error("Constraining edge intersects point");
      }
      const convex = this.intersectSegments(triangles[edg], triangles[adj], triangles[bot], triangles[top]);
      if (!convex) {
        if (rescan === -1) {
          rescan = edg;
        }
        if (triangles[top] === segP2) {
          if (edg === rescan) {
            throw new Error("Infinite loop: non-convex quadrilateral");
          }
          edg = rescan;
          rescan = -1;
          continue;
        }
        if (this.intersectSegments(segP1, segP2, triangles[top], triangles[adj])) {
          edg = top;
        } else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {
          edg = rgt;
        } else if (rescan === edg) {
          throw new Error("Infinite loop: no further intersect after non-convex");
        }
        continue;
      }
      this.flipDiagonal(edg);
      if (this.intersectSegments(segP1, segP2, triangles[bot], triangles[top])) {
        if (rescan === -1) {
          rescan = bot;
        }
        if (rescan === bot) {
          throw new Error("Infinite loop: flipped diagonal still intersects");
        }
      }
      if (triangles[top] === segP2) {
        conEdge = top;
        edg = rescan;
        rescan = -1;
      } else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {
        edg = rgt;
      }
    }
    const flips = this.flips;
    this.protect(conEdge);
    do {
      var flipped = 0;
      flips.forEach((edg2) => {
        flips.delete(edg2);
        const adj = halfedges[edg2];
        if (adj === -1) {
          return;
        }
        flips.delete(adj);
        if (!this.isDelaunay(edg2)) {
          this.flipDiagonal(edg2);
          flipped++;
        }
      });
    } while (flipped > 0);
    return this.findEdge(segP1, segP2);
  }
  /**
   * Fix the Delaunay condition. It is no longer necessary to call this
   * method after constraining (many) edges, since constrainOne will do it
   * after each.
   *
   * @param deep If true, keep checking & flipping edges until all
   *        edges are Delaunay, otherwise only check the edges once.
   * @return The triangulation object.
   */
  delaunify(deep = false) {
    const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd, len = halfedges.length;
    do {
      var flipped = 0;
      for (let edg = 0; edg < len; edg++) {
        if (consd.has(edg)) {
          continue;
        }
        flips.delete(edg);
        const adj = halfedges[edg];
        if (adj === -1) {
          continue;
        }
        flips.delete(adj);
        if (!this.isDelaunay(edg)) {
          this.flipDiagonal(edg);
          flipped++;
        }
      }
    } while (deep && flipped > 0);
    return this;
  }
  /**
   * Call constrainOne on each edge, and delaunify afterwards.
   *
   * @param edges The edges to constrain: each element is an array with
   *        [p1, p2] which are indices into the points array originally
   *        supplied to Delaunator.
   * @return The triangulation object.
   */
  constrainAll(edges) {
    const len = edges.length;
    for (let i = 0; i < len; i++) {
      const e = edges[i];
      this.constrainOne(e[0], e[1]);
    }
    return this;
  }
  /**
   * Whether an edge is a constrained edge.
   *
   * @param edg The edge id.
   * @return True if the edge is constrained.
   */
  isConstrained(edg) {
    return this.consd.has(edg);
  }
  /**
   * Find the edge that points from p1 -> p2. If there is only an edge from
   * p2 -> p1 (i.e. it is on the hull), returns the negative id of it.
   *
   * @param p1 The index of the first point into the points array.
   * @param p2 The index of the second point into the points array.
   * @return The id of the edge that points from p1 -> p2, or the negative
   *         id of the edge that goes from p2 -> p1, or Infinity if there is
   *         no edge between p1 and p2.
   */
  findEdge(p1, p2) {
    const start1 = this.vertMap[p2], { triangles, halfedges } = this.del;
    let edg = start1, prv = -1;
    do {
      if (triangles[edg] === p1) {
        return edg;
      }
      prv = nextEdge(edg);
      edg = halfedges[prv];
    } while (edg !== -1 && edg !== start1);
    if (triangles[nextEdge(prv)] === p1) {
      return -prv;
    }
    return Infinity;
  }
  /**
   * Mark an edge as constrained, i.e. should not be touched by `delaunify`.
   *
   * @private
   * @param edg The edge id.
   * @return If edg has an adjacent, returns that, otherwise -edg.
   */
  protect(edg) {
    const adj = this.del.halfedges[edg], flips = this.flips, consd = this.consd;
    flips.delete(edg);
    consd.add(edg);
    if (adj !== -1) {
      flips.delete(adj);
      consd.add(adj);
      return adj;
    }
    return -edg;
  }
  /**
   * Mark an edge as flipped, unless it is already marked as constrained.
   *
   * @private
   * @param edg The edge id.
   * @return True if edg was not constrained.
   */
  markFlip(edg) {
    const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd;
    if (consd.has(edg)) {
      return false;
    }
    const adj = halfedges[edg];
    if (adj !== -1) {
      flips.add(edg);
      flips.add(adj);
    }
    return true;
  }
  /**
   * Flip the edge shared by two triangles.
   *
   * @private
   * @param edg The edge shared by the two triangles, must have an
   *        adjacent half-edge.
   * @return The new diagonal.
   */
  flipDiagonal(edg) {
    const { triangles, halfedges } = this.del, flips = this.flips, consd = this.consd, adj = halfedges[edg], bot = prevEdge(edg), lft = nextEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj), adjBot = halfedges[bot], adjTop = halfedges[top];
    if (consd.has(edg)) {
      throw new Error("Trying to flip a constrained edge");
    }
    triangles[edg] = triangles[top];
    halfedges[edg] = adjTop;
    if (!flips.set(edg, flips.has(top))) {
      consd.set(edg, consd.has(top));
    }
    if (adjTop !== -1) {
      halfedges[adjTop] = edg;
    }
    halfedges[bot] = top;
    triangles[adj] = triangles[bot];
    halfedges[adj] = adjBot;
    if (!flips.set(adj, flips.has(bot))) {
      consd.set(adj, consd.has(bot));
    }
    if (adjBot !== -1) {
      halfedges[adjBot] = adj;
    }
    halfedges[top] = bot;
    this.markFlip(edg);
    this.markFlip(lft);
    this.markFlip(adj);
    this.markFlip(rgt);
    flips.add(bot);
    consd.delete(bot);
    flips.add(top);
    consd.delete(top);
    this.updateVert(edg);
    this.updateVert(lft);
    this.updateVert(adj);
    this.updateVert(rgt);
    return bot;
  }
  /**
   * Whether the two triangles sharing edg conform to the Delaunay condition.
   * As a shortcut, if the given edge has no adjacent (is on the hull), it is
   * certainly Delaunay.
   *
   * @private
   * @param edg The edge shared by the triangles to test.
   * @return True if they are Delaunay.
   */
  isDelaunay(edg) {
    const { triangles, halfedges } = this.del, adj = halfedges[edg];
    if (adj === -1) {
      return true;
    }
    const p1 = triangles[prevEdge(edg)], p2 = triangles[edg], p3 = triangles[nextEdge(edg)], px = triangles[prevEdge(adj)];
    return !this.inCircle(p1, p2, p3, px);
  }
  /**
   * Update the vertex -> incoming edge map.
   *
   * @private
   * @param start The id of an *outgoing* edge.
   * @return The id of the right-most incoming edge.
   */
  updateVert(start2) {
    const { triangles, halfedges } = this.del, vm = this.vertMap, v2 = triangles[start2];
    let inc = prevEdge(start2), adj = halfedges[inc];
    while (adj !== -1 && adj !== start2) {
      inc = prevEdge(adj);
      adj = halfedges[inc];
    }
    vm[v2] = inc;
    return inc;
  }
  /**
   * Whether the segment between [p1, p2] intersects with [p3, p4]. When the
   * segments share an end-point (e.g. p1 == p3 etc.), they are not considered
   * intersecting.
   *
   * @private
   * @param p1 The index of point 1 into this.del.coords.
   * @param p2 The index of point 2 into this.del.coords.
   * @param p3 The index of point 3 into this.del.coords.
   * @param p4 The index of point 4 into this.del.coords.
   * @return True if the segments intersect.
   */
  intersectSegments(p1, p2, p3, p4) {
    const pts = this.del.coords;
    if (p1 === p3 || p1 === p4 || p2 === p3 || p2 === p4) {
      return false;
    }
    return intersectSegments(pts[p1 * 2], pts[p1 * 2 + 1], pts[p2 * 2], pts[p2 * 2 + 1], pts[p3 * 2], pts[p3 * 2 + 1], pts[p4 * 2], pts[p4 * 2 + 1]);
  }
  /**
   * Whether point px is in the circumcircle of the triangle formed by p1, p2,
   * and p3 (which are in counter-clockwise order).
   *
   * @param p1 The index of point 1 into this.del.coords.
   * @param p2 The index of point 2 into this.del.coords.
   * @param p3 The index of point 3 into this.del.coords.
   * @param px The index of point x into this.del.coords.
   * @return True if (px, py) is in the circumcircle.
   */
  inCircle(p1, p2, p3, px) {
    const pts = this.del.coords;
    return incircle(pts[p1 * 2], pts[p1 * 2 + 1], pts[p2 * 2], pts[p2 * 2 + 1], pts[p3 * 2], pts[p3 * 2 + 1], pts[px * 2], pts[px * 2 + 1]) < 0;
  }
  /**
   * Whether point p1, p2, and p are collinear.
   *
   * @private
   * @param p1 The index of segment point 1 into this.del.coords.
   * @param p2 The index of segment point 2 into this.del.coords.
   * @param p The index of the point p into this.del.coords.
   * @return True if the points are collinear.
   */
  isCollinear(p1, p2, p) {
    const pts = this.del.coords;
    return orient2d(pts[p1 * 2], pts[p1 * 2 + 1], pts[p2 * 2], pts[p2 * 2 + 1], pts[p * 2], pts[p * 2 + 1]) === 0;
  }
};
Constrainautor.intersectSegments = intersectSegments;
function intersectSegments(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
  const x0 = orient2d(p1x, p1y, p3x, p3y, p4x, p4y), y0 = orient2d(p2x, p2y, p3x, p3y, p4x, p4y);
  if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0) {
    return false;
  }
  const x1 = orient2d(p3x, p3y, p1x, p1y, p2x, p2y), y1 = orient2d(p4x, p4y, p1x, p1y, p2x, p2y);
  if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0) {
    return false;
  }
  if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return !(Math.max(p3x, p4x) < Math.min(p1x, p2x) || Math.max(p1x, p2x) < Math.min(p3x, p4x) || Math.max(p3y, p4y) < Math.min(p1y, p2y) || Math.max(p1y, p2y) < Math.min(p3y, p4y));
  }
  return true;
}

// node_modules/@allmaps/triangulate/dist/index.js
var MINIMUM_TRIANGLE_ANGLE = 1e-4;
var defaultTriangulationOptions = {
  steinerPoints: [],
  minimumTriangleAngle: MINIMUM_TRIANGLE_ANGLE
};
function triangulateToUnique(polygon, distance3, triangulationOptions) {
  const mergedTriangulationOptions = mergeOptions(defaultTriangulationOptions, triangulationOptions);
  const steinerPoints = mergedTriangulationOptions.steinerPoints;
  const minimumTriangleAngle = mergedTriangulationOptions.minimumTriangleAngle;
  polygon = conformPolygon(polygon);
  let interpolatedPolygon = [];
  let interpolatedPolygonPoints = [];
  let gridPoints = [];
  let gridPointsInPolygon = [];
  if (distance3) {
    interpolatedPolygon = interpolatePolygon(polygon, distance3);
    interpolatedPolygonPoints = interpolatedPolygon.flat();
    gridPoints = getGridPointsInBbox(computeBbox(polygon), distance3);
    gridPointsInPolygon = gridPoints.filter((point2) => pointInPolygon2(point2, polygon));
  } else {
    interpolatedPolygon = polygon;
    interpolatedPolygonPoints = polygon.flat();
  }
  const steinerPointsInPolygon = steinerPoints.filter((point2) => pointInPolygon2(point2, polygon));
  const uniquePoints = [
    ...interpolatedPolygonPoints,
    ...gridPointsInPolygon,
    ...steinerPointsInPolygon
  ];
  const delautator = new Delaunator(uniquePoints.flat());
  let ringOffset = 0;
  const uniquePointIndexInterpolatedPolygon = interpolatedPolygon.map((ring) => {
    const uniqueIndexRing = ring.map((_point, index) => ringOffset + index);
    ringOffset += ring.length;
    return uniqueIndexRing;
  });
  const uniquePointIndexEdges = uniquePointIndexInterpolatedPolygon.map((ring) => ring.map((uniqueIndex) => [uniqueIndex, (uniqueIndex + 1) % ring.length])).flat();
  const constrainautor = new Constrainautor(delautator);
  constrainautor.delaunify(true);
  constrainautor.constrainAll(uniquePointIndexEdges);
  let uniquePointIndexTriangles = [];
  let triangles = [];
  const shouldClassifyTriangles = [];
  for (let i = 0; i < constrainautor.del.triangles.length; i += 3) {
    uniquePointIndexTriangles.push([
      constrainautor.del.triangles[i],
      constrainautor.del.triangles[i + 1],
      constrainautor.del.triangles[i + 2]
    ]);
    triangles.push([
      uniquePoints[constrainautor.del.triangles[i]],
      uniquePoints[constrainautor.del.triangles[i + 1]],
      uniquePoints[constrainautor.del.triangles[i + 2]]
    ]);
    shouldClassifyTriangles.push(constrainautor.del.triangles[i] < interpolatedPolygonPoints.length || constrainautor.del.triangles[i + 1] < interpolatedPolygonPoints.length || constrainautor.del.triangles[i + 2] < interpolatedPolygonPoints.length);
  }
  const shouldKeep = triangles.map((triangle, index) => {
    if (shouldClassifyTriangles[index]) {
      return pointInPolygon2(midPoint(...triangle), polygon) && triangleAngles(triangle).every((angle) => angle >= minimumTriangleAngle);
    } else {
      return true;
    }
  });
  uniquePointIndexTriangles = uniquePointIndexTriangles.filter((_triangle, index) => shouldKeep[index]);
  triangles = triangles.filter((_triangle, index) => shouldKeep[index]);
  const edges = [];
  for (let i = 0; i < uniquePointIndexEdges.length; i += 1) {
    edges.push([
      uniquePoints[uniquePointIndexEdges[i][0]],
      uniquePoints[uniquePointIndexEdges[i][1]]
    ]);
  }
  return {
    interpolatedPolygon,
    interpolatedPolygonPoints,
    gridPoints,
    gridPointsInPolygon,
    uniquePoints,
    triangles,
    uniquePointIndexTriangles,
    uniquePointIndexInterpolatedPolygon,
    uniquePointIndexEdges
  };
}

// node_modules/@allmaps/render/dist/shared/homogeneous-transform.js
function applyHomogeneousTransform(homogeneousTransform, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  return [
    homogeneousTransform[0] * x + homogeneousTransform[2] * y + homogeneousTransform[4],
    homogeneousTransform[1] * x + homogeneousTransform[3] * y + homogeneousTransform[5]
  ];
}
function createHomogeneousTransform() {
  return [1, 0, 0, 1, 0, 0];
}
function multiplyHomogeneousTransform(homogeneousTransform1, homogeneousTransform2) {
  const a1 = homogeneousTransform1[0];
  const b1 = homogeneousTransform1[1];
  const c1 = homogeneousTransform1[2];
  const d1 = homogeneousTransform1[3];
  const e1 = homogeneousTransform1[4];
  const f1 = homogeneousTransform1[5];
  const a2 = homogeneousTransform2[0];
  const b2 = homogeneousTransform2[1];
  const c2 = homogeneousTransform2[2];
  const d2 = homogeneousTransform2[3];
  const e2 = homogeneousTransform2[4];
  const f2 = homogeneousTransform2[5];
  return [
    a1 * a2 + c1 * b2,
    b1 * a2 + d1 * b2,
    a1 * c2 + c1 * d2,
    b1 * c2 + d1 * d2,
    a1 * e2 + c1 * f2 + e1,
    b1 * e2 + d1 * f2 + f1
  ];
}
function composeHomogeneousTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  return [
    sx * cos,
    sy * sin,
    -sx * sin,
    sy * cos,
    dx2 * sx * cos - dy2 * sx * sin + dx1,
    dx2 * sy * sin + dy2 * sy * cos + dy1
  ];
}
function invertHomogeneousTransform(source) {
  const determinant2 = getDeterminant(source);
  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];
  return [
    d / determinant2,
    -b / determinant2,
    -c / determinant2,
    a / determinant2,
    (c * f - d * e) / determinant2,
    -(a * f - b * e) / determinant2
  ];
}
function getDeterminant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
function homogeneousTransformToMatrix4(homogeneousTransform) {
  const matrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  matrix4[0] = homogeneousTransform[0];
  matrix4[1] = homogeneousTransform[1];
  matrix4[4] = homogeneousTransform[2];
  matrix4[5] = homogeneousTransform[3];
  matrix4[12] = homogeneousTransform[4];
  matrix4[13] = homogeneousTransform[5];
  return matrix4;
}

// node_modules/@allmaps/render/dist/maps/WarpedMap.js
var DEFAULT_PROJECTED_GCP_TRANSFORMER_OPTIONS = {
  minOffsetRatio: 0.01,
  minOffsetDistance: 4,
  maxDepth: 5,
  differentHandedness: true
};
var DEFAULT_WARPED_MAP_OPTIONS = {
  visible: true,
  applyMask: true,
  transformationType: "polynomial",
  internalProjection: webMercatorProjection,
  projection: webMercatorProjection
};
var WarpedMap = class extends EventTarget {
  mapId;
  georeferencedMap;
  imageInformations;
  parsedImage;
  loadingImageInfo;
  fetchFn;
  abortController;
  visible;
  applyMask;
  mixed = false;
  gcps;
  projectedGcps;
  resourcePoints;
  geoPoints;
  projectedGeoPoints;
  projectedGeoPreviousTransformedResourcePoints;
  projectedGeoTransformedResourcePoints;
  resourceMask;
  resourceMaskBbox;
  resourceMaskRectangle;
  resourceFullMask;
  resourceFullMaskBbox;
  resourceFullMaskRectangle;
  previousTransformationType;
  transformationType;
  previousInternalProjection;
  internalProjection;
  projection;
  projectedPreviousTransformer;
  projectedTransformer;
  projectedTransformerCache;
  geoMask;
  geoMaskBbox;
  geoMaskRectangle;
  geoFullMask;
  geoFullMaskBbox;
  geoFullMaskRectangle;
  projectedGeoMask;
  projectedGeoMaskBbox;
  projectedGeoMaskRectangle;
  projectedGeoFullMask;
  projectedGeoFullMaskBbox;
  projectedGeoFullMaskRectangle;
  resourceToProjectedGeoScale;
  previousDistortionMeasure;
  distortionMeasure;
  tileZoomLevelForViewport;
  overviewTileZoomLevelForViewport;
  projectedGeoBufferedViewportRectangleForViewport;
  projectedGeoBufferedViewportRectangleBboxForViewport;
  resourceBufferedViewportRingForViewport;
  resourceBufferedViewportRingBboxForViewport;
  resourceBufferedViewportRingBboxAndResourceMaskBboxIntersectionForViewport;
  fetchableTilesForViewport = [];
  overviewFetchableTilesForViewport = [];
  /**
   * Creates an instance of WarpedMap.
   *
   * @param mapId - ID of the map
   * @param georeferencedMap - Georeferenced map used to construct the WarpedMap
   * @param partialWarpedMapOptions - options
   */
  constructor(mapId, georeferencedMap, partialWarpedMapOptions) {
    super();
    const georeferencedMapInput = {
      transformationType: georeferencedMap.transformation?.type,
      internalProjection: georeferencedMap.resourceCrs
    };
    const mapAndConstructorOptions = mergeOptions(
      georeferencedMapInput,
      partialWarpedMapOptions
    );
    const warpedMapOptions = mergeOptionsUnlessUndefined(
      DEFAULT_WARPED_MAP_OPTIONS,
      mapAndConstructorOptions
    );
    this.projectedTransformerCache = /* @__PURE__ */ new Map();
    this.mapId = mapId;
    this.georeferencedMap = georeferencedMap;
    this.imageInformations = warpedMapOptions.imageInformations;
    this.loadingImageInfo = false;
    this.visible = warpedMapOptions.visible;
    this.applyMask = warpedMapOptions.applyMask;
    this.fetchFn = warpedMapOptions.fetchFn;
    this.gcps = this.georeferencedMap.gcps;
    this.resourceMask = this.applyMask ? this.georeferencedMap.resourceMask : this.getResourceFullMask();
    this.updateResourceMaskProperties();
    this.updateResourceFullMaskProperties();
    this.transformationType = warpedMapOptions.transformationType;
    this.previousTransformationType = this.transformationType;
    this.internalProjection = warpedMapOptions.internalProjection;
    this.previousInternalProjection = this.internalProjection;
    this.projection = warpedMapOptions.projection;
    this.updateProjectedTransformerProperties();
  }
  /**
   * Get resourceMask in viewport coordinates
   *
   * @param viewport - the current viewport
   * @returns
   */
  getViewportMask(viewport) {
    return this.projectedGeoMask.map((point2) => {
      return applyHomogeneousTransform(
        viewport.projectedGeoToViewportHomogeneousTransform,
        point2
      );
    });
  }
  /**
   * Get Bbox of resourceMask in viewport coordinates
   *
   * @param viewport - the current viewport
   * @returns
   */
  getViewportMaskBbox(viewport) {
    return computeBbox(this.getViewportMask(viewport));
  }
  /**
   * Get resourceMaskRectangle in viewport coordinates
   *
   * @param viewport - the current viewport
   * @returns
   */
  getViewportMaskRectangle(viewport) {
    return this.projectedGeoMaskRectangle.map((point2) => {
      return applyHomogeneousTransform(
        viewport.projectedGeoToViewportHomogeneousTransform,
        point2
      );
    });
  }
  /**
   * Get resourceFullMask in viewport coordinates
   *
   * @param viewport - the current viewport
   * @returns
   */
  getViewportFullMask(viewport) {
    return this.projectedGeoFullMask.map((point2) => {
      return applyHomogeneousTransform(
        viewport.projectedGeoToViewportHomogeneousTransform,
        point2
      );
    });
  }
  /**
   * Get bbox of rresourceFullMask in viewport coordinates
   *
   * @param viewport - the current viewport
   * @returns
   */
  getViewportFullMaskBbox(viewport) {
    return computeBbox(this.getViewportFullMask(viewport));
  }
  /**
   * Get resourceFullMaskRectangle in viewport coordinates
   *
   * @param viewport - the current viewport
   * @returns
   */
  getViewportFullMaskRectangle(viewport) {
    return this.projectedGeoFullMaskRectangle.map((point2) => {
      return applyHomogeneousTransform(
        viewport.projectedGeoToViewportHomogeneousTransform,
        point2
      );
    });
  }
  /**
   * Get scale of the warped map, in resource pixels per viewport pixels.
   *
   * @param viewport - the current viewport
   * @returns
   */
  getResourceToViewportScale(viewport) {
    return rectanglesToScale(
      this.resourceMaskRectangle,
      this.getViewportMaskRectangle(viewport)
    );
  }
  /**
   * Get scale of the warped map, in resource pixels per canvas pixels.
   *
   * @param viewport - the current viewport
   * @returns
   */
  getResourceToCanvasScale(viewport) {
    return this.getResourceToViewportScale(viewport) / viewport.devicePixelRatio;
  }
  /**
   * Get the reference scaling from the forward transformation of the projected Helmert transformer
   *
   * @returns
   */
  getReferenceScale() {
    const projectedHelmertTransformer = this.getProjectedTransformer("helmert");
    const toProjectedGeoHelmertTransformation = projectedHelmertTransformer.getToGeoTransformation();
    const helmertMeasures = toProjectedGeoHelmertTransformation.getMeasures();
    return helmertMeasures.scale;
  }
  /**
   * Get a projected transformer of the given transformation type.
   *
   * Uses cashed projected transformers by transformation type,
   * and only computes a new projected transformer if none found.
   *
   * Returns a projected transformer in the current projection,
   * even if the cached transformer was computed in a different projection.
   *
   * Default settings apply for the options.
   *
   * @params transformationType - the transformation type
   * @params partialProjectedGcpTransformerOptions - options
   * @params useCache - whether to use the cached projected transformers previously computed
   * @returns A projected transformer
   */
  getProjectedTransformer(transformationType, partialProjectedGcpTransformerOptions) {
    partialProjectedGcpTransformerOptions = mergePartialOptions(
      {
        projection: this.projection,
        internalProjection: this.internalProjection
      },
      partialProjectedGcpTransformerOptions
    );
    partialProjectedGcpTransformerOptions = mergePartialOptions(
      DEFAULT_PROJECTED_GCP_TRANSFORMER_OPTIONS,
      partialProjectedGcpTransformerOptions
    );
    const projectedTransformer = getPropertyFromCacheOrComputation(
      this.projectedTransformerCache,
      transformationType,
      () => new ProjectedGcpTransformer(
        this.gcps,
        transformationType,
        partialProjectedGcpTransformerOptions
      )
    );
    return projectedTransformer.setProjection(this.projection);
  }
  /**
   * Update the ground control points loaded from a georeferenced map to new ground control points.
   *
   * @param gcps
   */
  setGcps(gcps) {
    this.gcps = gcps;
    this.clearProjectedTransformerCaches();
    this.updateProjectedTransformerProperties();
    this.updateGcpsProperties();
  }
  /**
   * Update the resource mask loaded from a georeferenced map to a new mask.
   *
   * @param resourceMask
   */
  setResourceMask(resourceMask) {
    this.applyMask = true;
    this.resourceMask = resourceMask;
    this.updateResourceMaskProperties();
    this.updateResourceFullMaskProperties();
    this.updateGeoMaskProperties();
    this.updateProjectedGeoMaskProperties();
  }
  /**
   * Set the transformationType
   *
   * @param transformationType
   */
  setTransformationType(transformationType) {
    this.transformationType = transformationType;
    this.updateProjectedTransformerProperties();
  }
  /**
   * Set the distortionMeasure
   *
   * @param distortionMeasure - the disortion measure
   */
  setDistortionMeasure(distortionMeasure) {
    this.distortionMeasure = distortionMeasure;
  }
  /**
   * Set the internal projection
   *
   * @param projection - the internal projection
   */
  setInternalProjection(projection) {
    this.internalProjection = projection || DEFAULT_PROJECTED_GCP_TRANSFORMER_OPTIONS.internalProjection || webMercatorProjection;
    this.clearProjectedTransformerCaches();
    this.updateProjectedTransformerProperties();
  }
  /**
   * Set the projection
   *
   * @param projection - the projection
   */
  setProjection(projection) {
    this.projection = projection || DEFAULT_PROJECTED_GCP_TRANSFORMER_OPTIONS.projection || webMercatorProjection;
    this.updateProjectedTransformerProperties();
  }
  /**
   * Set the tile zoom level for the current viewport
   *
   * @param tileZoomLevel - tile zoom level for the current viewport
   */
  setTileZoomLevelForViewport(tileZoomLevel) {
    this.tileZoomLevelForViewport = tileZoomLevel;
  }
  /**
   * Set the overview tile zoom level for the current viewport
   *
   * @param tileZoomLevel - tile zoom level for the current viewport
   */
  setOverviewTileZoomLevelForViewport(tileZoomLevel) {
    this.overviewTileZoomLevelForViewport = tileZoomLevel;
  }
  /**
   * Set projectedGeoBufferedViewportRectangle for the current viewport
   *
   * @param projectedGeoBufferedViewportRectangle
   */
  setProjectedGeoBufferedViewportRectangleForViewport(projectedGeoBufferedViewportRectangle) {
    this.projectedGeoBufferedViewportRectangleForViewport = projectedGeoBufferedViewportRectangle;
    this.projectedGeoBufferedViewportRectangleBboxForViewport = projectedGeoBufferedViewportRectangle ? computeBbox(projectedGeoBufferedViewportRectangle) : void 0;
  }
  /**
   * Set resourceBufferedViewportRing for the current viewport
   *
   * @param resourceBufferedViewportRing
   */
  setResourceBufferedViewportRingForViewport(resourceBufferedViewportRing) {
    this.resourceBufferedViewportRingForViewport = resourceBufferedViewportRing;
    this.resourceBufferedViewportRingBboxForViewport = resourceBufferedViewportRing ? computeBbox(resourceBufferedViewportRing) : void 0;
  }
  /**
   * Set resourceBufferedViewportRingBboxAndResourceMaskBboxIntersection for the current viewport
   *
   * @param resourceBufferedViewportRingBboxAndResourceMaskBboxIntersection
   */
  setResourceBufferedViewportRingBboxAndResourceMaskBboxIntersectionForViewport(resourceBufferedViewportRingBboxAndResourceMaskBboxIntersection) {
    this.resourceBufferedViewportRingBboxAndResourceMaskBboxIntersectionForViewport = resourceBufferedViewportRingBboxAndResourceMaskBboxIntersection;
  }
  /**
   * Set tiles for the current viewport
   *
   * @param fetchableTiles
   */
  setFetchableTilesForViewport(fetchableTiles) {
    this.fetchableTilesForViewport = fetchableTiles;
  }
  /**
   * Set overview tiles for the current viewport
   *
   * @param overviewFetchableTiles
   */
  setOverviewFetchableTilesForViewport(overviewFetchableTiles) {
    this.overviewFetchableTilesForViewport = overviewFetchableTiles;
  }
  /**
   * Reset the properties for the current values
   */
  resetForViewport() {
    this.setTileZoomLevelForViewport();
    this.setOverviewTileZoomLevelForViewport();
    this.setProjectedGeoBufferedViewportRectangleForViewport();
    this.setResourceBufferedViewportRingForViewport();
    this.setFetchableTilesForViewport([]);
    this.setOverviewFetchableTilesForViewport([]);
  }
  /**
   * Reset previous transform properties to new ones (when completing a transformer transitions).
   */
  resetPrevious() {
    this.mixed = false;
    this.previousTransformationType = this.transformationType;
    this.previousDistortionMeasure = this.distortionMeasure;
    this.previousInternalProjection = this.internalProjection;
    this.projectedPreviousTransformer = cloneDeep_default(this.projectedTransformer);
    this.projectedGeoPreviousTransformedResourcePoints = this.projectedGeoTransformedResourcePoints;
  }
  /**
   * Mix previous transform properties with new ones (when changing an ongoing transformer transition).
   *
   * @param t - animation progress
   */
  mixPreviousAndNew(t) {
    this.mixed = true;
    this.previousTransformationType = this.transformationType;
    this.previousDistortionMeasure = this.distortionMeasure;
    this.previousInternalProjection = this.internalProjection;
    this.projectedPreviousTransformer = cloneDeep_default(this.projectedTransformer);
    this.projectedGeoPreviousTransformedResourcePoints = this.projectedGeoTransformedResourcePoints.map((point2, index) => {
      return mixPoints(
        point2,
        this.projectedGeoPreviousTransformedResourcePoints[index],
        t
      );
    });
  }
  /**
   * Check if this instance has image info
   *
   * @returns
   */
  hasImageInfo() {
    return this.parsedImage !== void 0;
  }
  /**
   * Fetch and parse the image info, and generate the image ID
   *
   * @returns
   */
  async loadImageInfo() {
    try {
      this.loadingImageInfo = true;
      const imageUri = this.georeferencedMap.resource.id;
      let imageInfo;
      if (this.imageInformations?.get(imageUri)) {
        imageInfo = this.imageInformations.get(imageUri);
      } else {
        this.abortController = new AbortController();
        const signal = this.abortController.signal;
        imageInfo = await fetchImageInfo(imageUri, { signal }, this.fetchFn);
        this.abortController = void 0;
        this.imageInformations?.set(imageUri, imageInfo);
      }
      this.parsedImage = Image2.parse(imageInfo);
      this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.IMAGEINFOLOADED));
    } catch (err) {
      this.loadingImageInfo = false;
      throw err;
    } finally {
      this.loadingImageInfo = false;
    }
  }
  updateResourceMaskProperties() {
    this.resourceMaskBbox = computeBbox(this.resourceMask);
    this.resourceMaskRectangle = bboxToRectangle(this.resourceMaskBbox);
  }
  getResourceFullMask() {
    const resourceWidth = this.georeferencedMap.resource.width;
    const resourceHeight = this.georeferencedMap.resource.height;
    if (resourceWidth && resourceHeight) {
      return sizeToRectangle([resourceWidth, resourceHeight]);
    } else {
      return bboxToRectangle(this.resourceMaskBbox);
    }
  }
  updateResourceFullMaskProperties() {
    this.resourceFullMask = this.getResourceFullMask();
    this.resourceFullMaskBbox = computeBbox(this.resourceFullMask);
    this.resourceFullMaskRectangle = bboxToRectangle(this.resourceFullMaskBbox);
  }
  updateGeoMaskProperties() {
    this.updateGeoMask();
    this.updateFullGeoMask();
  }
  updateProjectedGeoMaskProperties() {
    this.updateProjectedGeoMask();
    this.updateProjectedFullGeoMask();
    this.updateResourceToProjectedGeoScale();
  }
  updateProjectedTransformerProperties() {
    this.updateProjectedTransformer();
    this.updateGeoMaskProperties();
    this.updateProjectedGeoMaskProperties();
    this.updateGcpsProperties();
  }
  updateProjectedTransformer() {
    this.projectedTransformer = this.getProjectedTransformer(
      this.transformationType
    );
    if (!this.projectedPreviousTransformer) {
      this.projectedPreviousTransformer = this.projectedTransformer;
    }
  }
  updateGeoMask() {
    this.geoMask = this.projectedTransformer.transformToGeo(
      [this.resourceMask],
      { projection: lonLatProjection }
    )[0];
    this.geoMaskBbox = computeBbox(this.geoMask);
    this.geoMaskRectangle = this.projectedTransformer.transformToGeo(
      [this.resourceMaskRectangle],
      { maxDepth: 0, projection: lonLatProjection }
    )[0];
  }
  updateFullGeoMask() {
    this.geoFullMask = this.projectedTransformer.transformToGeo(
      [this.resourceFullMask],
      { projection: lonLatProjection }
    )[0];
    this.geoFullMaskBbox = computeBbox(this.geoFullMask);
    this.geoFullMaskRectangle = this.projectedTransformer.transformToGeo(
      [this.resourceFullMaskRectangle],
      { maxDepth: 0, projection: lonLatProjection }
    )[0];
  }
  updateProjectedGeoMask() {
    this.projectedGeoMask = this.projectedTransformer.transformToGeo([
      this.resourceMask
    ])[0];
    this.projectedGeoMaskBbox = computeBbox(this.projectedGeoMask);
    this.projectedGeoMaskRectangle = this.projectedTransformer.transformToGeo(
      [this.resourceMaskRectangle],
      { maxDepth: 0 }
    )[0];
  }
  updateProjectedFullGeoMask() {
    this.projectedGeoFullMask = this.projectedTransformer.transformToGeo([
      this.resourceFullMask
    ])[0];
    this.projectedGeoFullMaskBbox = computeBbox(this.projectedGeoFullMask);
    this.projectedGeoFullMaskRectangle = this.projectedTransformer.transformToGeo(
      [this.resourceFullMaskRectangle],
      { maxDepth: 0 }
    )[0];
  }
  updateResourceToProjectedGeoScale() {
    this.resourceToProjectedGeoScale = rectanglesToScale(
      this.resourceMaskRectangle,
      this.projectedGeoMaskRectangle
    );
  }
  updateGcpsProperties() {
    this.projectedGcps = this.gcps.map(({ resource, geo }) => ({
      resource,
      geo: this.projectedTransformer.lonLatToProjection(geo)
    }));
    this.resourcePoints = this.gcps.map((gcp) => gcp.resource);
    this.geoPoints = this.gcps.map((gcp) => gcp.geo);
    this.projectedGeoPoints = this.projectedGcps.map(
      (projectedGcp) => projectedGcp.geo
    );
    this.projectedGeoTransformedResourcePoints = this.gcps.map(
      (projectedGcp) => this.projectedTransformer.transformToGeo(projectedGcp.resource)
    );
    if (!this.projectedGeoPreviousTransformedResourcePoints) {
      this.projectedGeoPreviousTransformedResourcePoints = this.projectedGeoTransformedResourcePoints;
    }
  }
  clearProjectedTransformerCaches() {
    this.projectedTransformerCache = /* @__PURE__ */ new Map();
  }
  destroy() {
    if (this.abortController) {
      this.abortController.abort();
    }
  }
};

// node_modules/@allmaps/render/dist/maps/TriangulatedWarpedMap.js
var DEFAULT_DISTORTION_MEASURES = [
  "log2sigma",
  "twoOmega"
];
function createDefaultTriangulatedWarpedMapOptions() {
  return {};
}
var TriangulatedWarpedMap = class extends WarpedMap {
  previousResourceResolution;
  resourceResolution;
  triangulateErrorCount = 0;
  projectedGcpPreviousTriangulation;
  projectedGcpTriangulation;
  resourceTriangulationCache;
  projectedGcpTriangulationCache;
  resourceTrianglePoints = [];
  projectedGeoPreviousTrianglePoints = [];
  projectedGeoTrianglePoints = [];
  previousTrianglePointsDistortion = [];
  trianglePointsDistortion = [];
  projectedGeoPreviousTriangulationMask = [];
  projectedGeoTriangulationMask = [];
  /**
   * Creates an instance of a TriangulatedWarpedMap.
   *
   * @param mapId - ID of the map
   * @param georeferencedMap - Georeferenced map used to construct the WarpedMap
   * @param options - Options
   */
  constructor(mapId, georeferencedMap, options) {
    options = {
      ...createDefaultTriangulatedWarpedMapOptions(),
      ...options
    };
    super(mapId, georeferencedMap, options);
    this.resourceTriangulationCache = /* @__PURE__ */ new Map();
    this.projectedGcpTriangulationCache = /* @__PURE__ */ new Map();
    this.updateTriangulation();
  }
  /**
   * Update the ground control points loaded from a georeferenced map to new ground control points.
   *
   * @param gcps - the new ground control points
   */
  setGcps(gcps) {
    super.setGcps(gcps);
    this.clearResourceTriangulationCaches();
    this.updateTriangulation();
  }
  /**
   * Update the resource mask loaded from a georeferenced map to a new mask.
   *
   * @param resourceMask - the new mask
   */
  setResourceMask(resourceMask) {
    super.setResourceMask(resourceMask);
    this.clearResourceTriangulationCaches();
    this.updateTriangulation();
  }
  /**
   * Set the distortionMeasure
   *
   * @param distortionMeasure - the disortion measure
   */
  setDistortionMeasure(distortionMeasure) {
    super.setDistortionMeasure(distortionMeasure);
    this.updateTrianglePointsDistortion();
  }
  /**
   * Set the internal projection
   *
   * @param projection - the internal projection
   */
  setInternalProjection(projection) {
    super.setInternalProjection(projection);
    this.updateTriangulation();
  }
  /**
   * Set the projection
   *
   * @param projection - the projection
   */
  setProjection(projection) {
    super.setProjection(projection);
    this.clearProjectedTriangulationCaches();
    this.updateTriangulation();
  }
  /**
   * Reset previous transform properties to new ones (when completing a transformer transitions).
   */
  resetPrevious() {
    super.resetPrevious();
    this.previousResourceResolution = this.resourceResolution;
    this.projectedGcpPreviousTriangulation = this.projectedGcpTriangulation;
    this.projectedGeoPreviousTrianglePoints = this.projectedGeoTrianglePoints;
    this.previousTrianglePointsDistortion = this.trianglePointsDistortion;
    this.projectedGeoPreviousTriangulationMask = this.projectedGeoTriangulationMask;
  }
  /**
   * Mix previous transform properties with new ones (when changing an ongoing transformer transition).
   *
   * @param t - animation progress
   */
  mixPreviousAndNew(t) {
    super.mixPreviousAndNew(t);
    if (this.projectedGcpPreviousTriangulation && this.projectedGcpTriangulation) {
      const projectedGcpPreviousTriangulation = this.projectedGcpPreviousTriangulation;
      const projectedGcpTriangulation = this.projectedGcpTriangulation;
      this.previousResourceResolution = this.resourceResolution;
      this.projectedGcpPreviousTriangulation = {
        resourceResolution: projectedGcpPreviousTriangulation.resourceResolution,
        gcpUniquePoints: projectedGcpPreviousTriangulation.gcpUniquePoints.map(
          (projectedGcp, index) => {
            return {
              resource: projectedGcp.resource,
              geo: mixPoints(
                projectedGcpTriangulation.gcpUniquePoints[index].geo,
                projectedGcp.geo,
                t
              ),
              // Note: Not mixing the distortions Map, only the active distortion
              distortions: projectedGcpTriangulation.gcpUniquePoints[index].distortions,
              distortion: mixNumbers(
                projectedGcpTriangulation.gcpUniquePoints[index].distortion || 0,
                projectedGcp.distortion || 0,
                t
              )
            };
          }
        ),
        uniquePointIndices: projectedGcpPreviousTriangulation.uniquePointIndices,
        uniquePointIndexInterpolatedPolygon: projectedGcpPreviousTriangulation.uniquePointIndexInterpolatedPolygon
      };
      this.projectedGeoPreviousTrianglePoints = projectedGcpPreviousTriangulation.uniquePointIndices.map(
        (i) => projectedGcpPreviousTriangulation.gcpUniquePoints[i].geo
      );
      this.previousTrianglePointsDistortion = projectedGcpPreviousTriangulation.uniquePointIndices.map(
        (i) => projectedGcpPreviousTriangulation.gcpUniquePoints[i].distortion
      );
    }
    this.projectedGeoPreviousTriangulationMask = this.projectedGeoTriangulationMask.map((point2, index) => {
      return mixPoints(
        point2,
        this.projectedGeoPreviousTriangulationMask[index],
        t
      );
    });
  }
  /**
   * Update the (previous and new) triangulation of the resourceMask. Use cache if available.
   */
  updateTriangulation() {
    if (!this.resourceTriangulationCache || !this.projectedGcpTriangulationCache) {
      return;
    }
    const resourceResolution = this.projectedTransformer.getToGeoTransformationResolution(
      this.resourceMaskBbox
    );
    let refinePrevious = false;
    if (resourceResolution && this.previousResourceResolution) {
      refinePrevious = this.previousResourceResolution < resourceResolution;
      this.resourceResolution = Math.min(
        resourceResolution,
        this.previousResourceResolution
      );
    }
    if (resourceResolution && !this.previousResourceResolution) {
      refinePrevious = true;
      this.resourceResolution = resourceResolution;
    }
    if (!resourceResolution && this.previousResourceResolution) {
      this.resourceResolution = this.previousResourceResolution;
    } else if (!resourceResolution && !this.previousResourceResolution) {
      this.resourceResolution = void 0;
    }
    this.projectedGcpTriangulation = getPropertyFromTripleCacheOrComputation(
      this.projectedGcpTriangulationCache,
      this.resourceResolution,
      this.transformationType,
      this.internalProjection,
      () => {
        const {
          uniquePoints,
          uniquePointIndexTriangles,
          uniquePointIndexInterpolatedPolygon
        } = getPropertyFromCacheOrComputation(
          this.resourceTriangulationCache,
          this.resourceResolution,
          () => triangulateToUnique([this.resourceMask], this.resourceResolution, {
            steinerPoints: this.gcps.map((gcp) => gcp.resource)
          })
        );
        const resourceResolution2 = this.resourceResolution;
        const resourceUniquePoints = uniquePoints;
        const gcpUniquePoints = resourceUniquePoints.map(
          (resourcePoint) => this.projectedTransformer.transformToGeo(
            resourcePoint,
            {
              distortionMeasures: DEFAULT_DISTORTION_MEASURES,
              referenceScale: this.getReferenceScale()
            },
            (gcpPartialDistortion) => gcpPartialDistortion
          )
        );
        const uniquePointIndices = uniquePointIndexTriangles.flat();
        return {
          resourceResolution: resourceResolution2,
          gcpUniquePoints,
          uniquePointIndices,
          uniquePointIndexInterpolatedPolygon
        };
      }
    );
    if (!this.projectedGcpPreviousTriangulation) {
      this.projectedGcpPreviousTriangulation = this.projectedGcpTriangulation;
    }
    if (refinePrevious) {
      this.previousResourceResolution = this.resourceResolution;
      this.projectedGcpPreviousTriangulation = getPropertyFromTripleCacheOrComputation(
        this.projectedGcpTriangulationCache,
        this.previousResourceResolution,
        this.previousTransformationType,
        this.previousInternalProjection,
        () => {
          if (!this.projectedGcpTriangulation) {
            throw new Error("No projectedGcpTriangulation");
          }
          const projectedGcpTriangulation = this.projectedGcpTriangulation;
          return {
            resourceResolution: this.projectedGcpTriangulation.resourceResolution,
            gcpUniquePoints: this.projectedGcpTriangulation.gcpUniquePoints.map(
              (projectedGcp) => this.projectedPreviousTransformer.transformToGeo(
                projectedGcp.resource,
                {
                  distortionMeasures: DEFAULT_DISTORTION_MEASURES,
                  referenceScale: this.getReferenceScale()
                },
                (gcpPartialDistortion) => gcpPartialDistortion
              )
            ),
            uniquePointIndices: this.projectedGcpTriangulation.uniquePointIndices,
            uniquePointIndexInterpolatedPolygon: projectedGcpTriangulation.uniquePointIndexInterpolatedPolygon
          };
        },
        () => !this.mixed,
        () => !this.mixed
      );
    }
    this.updateTrianglePoints();
  }
  /**
   * Derive the (previous and new) resource and projectedGeo points from their corresponding triangulations.
   *
   * Also derive the (previous and new) triangulation-refined resource and projectedGeo mask
   */
  updateTrianglePoints() {
    if (!this.projectedGcpPreviousTriangulation || !this.projectedGcpTriangulation) {
      return;
    }
    const projectedGcpPreviousTriangulation = this.projectedGcpPreviousTriangulation;
    const projectedGcpTriangulation = this.projectedGcpTriangulation;
    this.resourceTrianglePoints = this.projectedGcpTriangulation.uniquePointIndices.map(
      (i) => projectedGcpTriangulation.gcpUniquePoints[i].resource
    );
    this.projectedGeoPreviousTrianglePoints = this.projectedGcpPreviousTriangulation.uniquePointIndices.map(
      (i) => projectedGcpPreviousTriangulation.gcpUniquePoints[i].geo
    );
    this.projectedGeoTrianglePoints = this.projectedGcpTriangulation.uniquePointIndices.map(
      (i) => projectedGcpTriangulation.gcpUniquePoints[i].geo
    );
    this.projectedGeoPreviousTriangulationMask = this.projectedGcpPreviousTriangulation.uniquePointIndexInterpolatedPolygon.map(
      (typedRing) => typedRing.map(
        (i) => projectedGcpPreviousTriangulation.gcpUniquePoints[i].geo
      )
    ).flat();
    this.projectedGeoTriangulationMask = this.projectedGcpTriangulation.uniquePointIndexInterpolatedPolygon.map(
      (typedRing) => typedRing.map((i) => projectedGcpTriangulation.gcpUniquePoints[i].geo)
    ).flat();
    this.updateTrianglePointsDistortion();
  }
  /**
   * Derive the (previous and new) distortions from their corresponding triangulations.
   */
  updateTrianglePointsDistortion() {
    if (!this.projectedGcpPreviousTriangulation || !this.projectedGcpTriangulation) {
      return;
    }
    const projectedGcpPreviousTriangulation = this.projectedGcpPreviousTriangulation;
    const projectedGcpTriangulation = this.projectedGcpTriangulation;
    this.previousTrianglePointsDistortion = projectedGcpPreviousTriangulation.uniquePointIndices.map((i) => {
      const distortions = projectedGcpPreviousTriangulation.gcpUniquePoints[i].distortions;
      if (!this.previousDistortionMeasure || !distortions) {
        return 0;
      } else {
        return distortions.get(this.previousDistortionMeasure);
      }
    });
    this.trianglePointsDistortion = projectedGcpTriangulation.uniquePointIndices.map((i) => {
      const distortions = projectedGcpTriangulation.gcpUniquePoints[i].distortions;
      if (!this.distortionMeasure || !distortions) {
        return 0;
      } else {
        return distortions.get(this.distortionMeasure);
      }
    });
  }
  updateProjectedTransformerProperties() {
    super.updateProjectedTransformerProperties();
    this.updateTriangulation();
  }
  clearProjectedTransformerCaches() {
    super.clearProjectedTransformerCaches();
    this.clearResourceTriangulationCaches();
  }
  clearResourceTriangulationCaches() {
    this.resourceTriangulationCache = /* @__PURE__ */ new Map();
    this.clearProjectedTriangulationCaches();
  }
  clearProjectedTriangulationCaches() {
    this.projectedGcpTriangulationCache = /* @__PURE__ */ new Map();
  }
};

// node_modules/@allmaps/render/dist/shared/webgl2.js
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  if (shader) {
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
      return shader;
    } else {
      const message = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      throw new Error("Failed to compile shader: " + message);
    }
  } else {
    throw new Error("Failed to create shader");
  }
}
function createProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  if (program) {
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    const success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
      return program;
    } else {
      const message = gl.getProgramInfoLog(program);
      gl.deleteProgram(program);
      throw new Error("Failed to link program: " + message);
    }
  } else {
    throw new Error("Failed to create program");
  }
}
function createBuffer(gl, program, data, size2, name) {
  const buffer = gl.createBuffer();
  if (!buffer) {
    throw new Error("Failed to create buffer");
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  const type = gl.FLOAT;
  const normalize = false;
  const stride = 0;
  const offset2 = 0;
  const positionAttributeLocation = gl.getAttribLocation(program, name);
  gl.vertexAttribPointer(
    positionAttributeLocation,
    size2,
    type,
    normalize,
    stride,
    offset2
  );
  gl.enableVertexAttribArray(positionAttributeLocation);
  return buffer;
}

// node_modules/@allmaps/render/dist/maps/WebGL2WarpedMap.js
var THROTTLE_UPDATE_TEXTURES_WAIT_MS = 200;
var THROTTLE_UPDATE_TEXTURES_OPTIONS = {
  leading: true,
  trailing: true
};
var defaultRenderLineLayerOptions = {
  viewportSize: 6,
  color: black,
  viewportBorderSize: 0,
  borderColor: white
};
var defaultRenderPointLayerOptions = {
  viewportSize: 16,
  color: black,
  viewportBorderSize: 1,
  borderColor: white
};
var defaultWebgl2WarpedMapOptions = {
  renderGcps: false,
  renderGcpsColor: blue,
  renderTransformedGcps: false,
  renderTransformedGcpsColor: pink,
  renderVectors: false,
  renderMask: false,
  renderMaskSize: 8,
  renderMaskColor: pink,
  renderFullMask: false,
  renderFullMaskSize: 8,
  renderFullMaskColor: green
};
var DEFAULT_OPACITY = 1;
var DEFAULT_SATURATION = 1;
var TEXTURES_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF = 5;
var TEXTURES_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF = 1;
function createWebGL2WarpedMapFactory(gl, mapProgram, linesProgram, pointsProgram) {
  return (mapId, georeferencedMap, options) => new WebGL2WarpedMap(
    mapId,
    georeferencedMap,
    gl,
    mapProgram,
    linesProgram,
    pointsProgram,
    options
  );
}
var WebGL2WarpedMap = class extends TriangulatedWarpedMap {
  webgl2WarpedMapOptions;
  gl;
  mapProgram;
  linesProgram;
  pointsProgram;
  mapVao = null;
  linesVao = null;
  pointsVao = null;
  lineLayers = [];
  pointLayers = [];
  // Consider to store cachedTilesByTileKey as a quadtree for faster lookups
  cachedTilesByTileKey;
  cachedTilesByTileUrl;
  cachedTilesForTexture = [];
  previousCachedTilesForTexture = [];
  opacity = DEFAULT_OPACITY;
  saturation = DEFAULT_SATURATION;
  renderOptions = {};
  cachedTilesTextureArray = null;
  cachedTilesResourceOriginPointsAndDimensionsTexture = null;
  cachedTilesScaleFactorsTexture = null;
  // About renderHomogeneousTransform and InvertedRenderHomogeneousTransform:
  // renderHomogeneousTransform is the product of:
  // - the viewport's projectedGeoToClipTransform (projected geo coordinates -> clip coordinates)
  // - the saved invertedRenderHomogeneousTransform (projected clip coordinates -> geo coordinates)
  // since updateVertexBuffers ('where to draw triangles') run with possibly a different Viewport then renderInternal ('drawing the triangles'), a difference caused by throttling, there needs to be an adjustment.
  // this adjustment is minimal: indeed, since invertedRenderHomogeneousTransform is set as the inverse of the viewport's projectedGeoToClipTransform in updateVertexBuffers()
  // this renderHomogeneousTransform is almost the identity transform [1, 0, 0, 1, 0, 0].
  invertedRenderHomogeneousTransform;
  throttledUpdateTextures;
  /**
   * Creates an instance of WebGL2WarpedMap.
   *
   * @constructor
   * @param mapId - ID of the map
   * @param georeferencedMap - Georeferenced map used to construct the WarpedMap
   * @param gl - WebGL rendering context
   * @param mapProgram - WebGL program for map
   * @param options - WarpedMapOptions
   */
  constructor(mapId, georeferencedMap, gl, mapProgram, linesProgram, pointsProgram, options) {
    super(mapId, georeferencedMap, options);
    this.cachedTilesByTileKey = /* @__PURE__ */ new Map();
    this.cachedTilesByTileUrl = /* @__PURE__ */ new Map();
    this.webgl2WarpedMapOptions = mergeOptions(
      defaultWebgl2WarpedMapOptions,
      options
    );
    this.gl = gl;
    this.initializeWebGL(mapProgram, linesProgram, pointsProgram);
    this.invertedRenderHomogeneousTransform = createHomogeneousTransform();
    this.throttledUpdateTextures = throttle_default(
      this.updateTextures.bind(this),
      THROTTLE_UPDATE_TEXTURES_WAIT_MS,
      THROTTLE_UPDATE_TEXTURES_OPTIONS
    );
  }
  initializeWebGL(mapProgram, linesProgram, pointsProgram) {
    this.mapProgram = mapProgram;
    this.linesProgram = linesProgram;
    this.pointsProgram = pointsProgram;
    this.mapVao = this.gl.createVertexArray();
    this.linesVao = this.gl.createVertexArray();
    this.pointsVao = this.gl.createVertexArray();
    this.cachedTilesTextureArray = this.gl.createTexture();
    this.cachedTilesScaleFactorsTexture = this.gl.createTexture();
    this.cachedTilesResourceOriginPointsAndDimensionsTexture = this.gl.createTexture();
  }
  /**
   * Update the vertex buffers of this warped map
   *
   * @param projectedGeoToClipHomogeneousTransform - Transform from projected geo coordinates to webgl2 coordinates in the [-1, 1] range. Equivalent to OpenLayers' projectionTransform.
   */
  updateVertexBuffers(projectedGeoToClipHomogeneousTransform, partialWebgl2RendererOptions) {
    this.invertedRenderHomogeneousTransform = invertHomogeneousTransform(
      projectedGeoToClipHomogeneousTransform
    );
    if (partialWebgl2RendererOptions.renderMaps) {
      this.updateVertexBuffersMap(projectedGeoToClipHomogeneousTransform);
    }
    if (partialWebgl2RendererOptions.renderLines) {
      this.updateVertexBuffersLines(projectedGeoToClipHomogeneousTransform);
    }
    if (partialWebgl2RendererOptions.renderPoints) {
      this.updateVertexBuffersPoints(projectedGeoToClipHomogeneousTransform);
    }
  }
  /**
   * Clear textures for this map
   */
  clearTextures() {
    this.throttledUpdateTextures();
  }
  /**
   * Add cached tile to the textures of this map and update textures
   *
   * @param cachedTile
   */
  addCachedTileAndUpdateTextures(cachedTile) {
    this.cachedTilesByTileKey.set(cachedTile.tileKey, cachedTile);
    this.cachedTilesByTileUrl.set(cachedTile.tileUrl, cachedTile);
    this.throttledUpdateTextures();
  }
  /**
   * Remove cached tile from the textures of this map and update textures
   *
   * @param tileUrl
   */
  removeCachedTileAndUpdateTextures(tileUrl) {
    const cachedTile = this.cachedTilesByTileUrl.get(tileUrl);
    if (cachedTile) {
      this.cachedTilesByTileKey.delete(cachedTile.tileKey);
    }
    this.cachedTilesByTileUrl.delete(tileUrl);
    this.throttledUpdateTextures();
  }
  cancelThrottledFunctions() {
    this.throttledUpdateTextures.cancel();
  }
  destroy() {
    this.gl.deleteVertexArray(this.mapVao);
    this.gl.deleteVertexArray(this.linesVao);
    this.gl.deleteVertexArray(this.pointsVao);
    this.gl.deleteTexture(this.cachedTilesTextureArray);
    this.gl.deleteTexture(this.cachedTilesScaleFactorsTexture);
    this.gl.deleteTexture(
      this.cachedTilesResourceOriginPointsAndDimensionsTexture
    );
    this.cancelThrottledFunctions();
    super.destroy();
  }
  setLineLayers() {
    this.lineLayers = [];
    if (this.webgl2WarpedMapOptions.renderVectors) {
      this.lineLayers.push({
        projectedGeoLines: pointsAndPointsToLines(
          this.projectedGeoPoints,
          this.projectedGeoTransformedResourcePoints
        ),
        projectedGeoPreviousLines: pointsAndPointsToLines(
          this.projectedGeoPoints,
          this.projectedGeoPreviousTransformedResourcePoints
        ),
        viewportSize: this.webgl2WarpedMapOptions.renderVectorsSize,
        color: this.webgl2WarpedMapOptions.renderVectorsColor,
        viewportBorderSize: this.webgl2WarpedMapOptions.renderVectorsBorderSize,
        borderColor: this.webgl2WarpedMapOptions.renderVectorsBorderColor
      });
    }
    if (this.webgl2WarpedMapOptions.renderMask) {
      this.lineLayers.push({
        projectedGeoLines: lineStringToLines(
          this.projectedGeoTriangulationMask
        ),
        projectedGeoPreviousLines: lineStringToLines(
          this.projectedGeoPreviousTriangulationMask
        ),
        viewportSize: this.webgl2WarpedMapOptions.renderMaskSize,
        color: this.webgl2WarpedMapOptions.renderMaskColor,
        viewportBorderSize: this.webgl2WarpedMapOptions.renderMaskBorderSize,
        borderColor: this.webgl2WarpedMapOptions.renderMaskBorderColor
      });
    }
    if (this.webgl2WarpedMapOptions.renderFullMask) {
      this.lineLayers.push({
        projectedGeoLines: lineStringToLines(this.projectedGeoFullMask),
        viewportSize: this.webgl2WarpedMapOptions.renderFullMaskSize,
        color: this.webgl2WarpedMapOptions.renderFullMaskColor,
        viewportBorderSize: this.webgl2WarpedMapOptions.renderFullMaskBorderSize,
        borderColor: this.webgl2WarpedMapOptions.renderFullMaskBorderColor
      });
    }
  }
  setPointLayers() {
    this.pointLayers = [];
    if (this.webgl2WarpedMapOptions.renderGcps) {
      this.pointLayers.push({
        projectedGeoPoints: this.projectedGeoPoints,
        viewportSize: this.webgl2WarpedMapOptions.renderGcpsSize,
        color: this.webgl2WarpedMapOptions.renderGcpsColor,
        viewportBorderSize: this.webgl2WarpedMapOptions.renderGcpsBorderSize,
        borderColor: this.webgl2WarpedMapOptions.renderGcpsBorderColor
      });
    }
    if (this.webgl2WarpedMapOptions.renderTransformedGcps) {
      this.pointLayers.push({
        projectedGeoPoints: this.projectedGeoTransformedResourcePoints,
        projectedGeoPreviousPoints: this.projectedGeoPreviousTransformedResourcePoints,
        viewportSize: this.webgl2WarpedMapOptions.renderTransformedGcpsSize,
        color: this.webgl2WarpedMapOptions.renderTransformedGcpsColor,
        viewportBorderSize: this.webgl2WarpedMapOptions.renderTransformedGcpsBorderSize,
        borderColor: this.webgl2WarpedMapOptions.renderTransformedGcpsBorderColor
      });
    }
  }
  updateVertexBuffersMap(projectedGeoToClipHomogeneousTransform) {
    if (!this.mapVao) {
      return;
    }
    const gl = this.gl;
    const program = this.mapProgram;
    gl.bindVertexArray(this.mapVao);
    createBuffer(
      gl,
      program,
      new Float32Array(this.resourceTrianglePoints.flat()),
      2,
      "a_resourceTrianglePoint"
    );
    const clipPreviousTrianglePoints = this.projectedGeoPreviousTrianglePoints.map(
      (point2) => applyHomogeneousTransform(projectedGeoToClipHomogeneousTransform, point2)
    );
    createBuffer(
      gl,
      program,
      new Float32Array(clipPreviousTrianglePoints.flat()),
      2,
      "a_clipPreviousTrianglePoint"
    );
    const clipTrianglePoints = this.projectedGeoTrianglePoints.map(
      (point2) => applyHomogeneousTransform(projectedGeoToClipHomogeneousTransform, point2)
    );
    createBuffer(
      gl,
      program,
      new Float32Array(clipTrianglePoints.flat()),
      2,
      "a_clipTrianglePoint"
    );
    createBuffer(
      gl,
      program,
      new Float32Array(this.previousTrianglePointsDistortion),
      1,
      "a_previousTrianglePointDistortion"
    );
    createBuffer(
      gl,
      program,
      new Float32Array(this.trianglePointsDistortion),
      1,
      "a_trianglePointDistortion"
    );
    const trianglePointsTriangleIndex = new Float32Array(
      this.resourceTrianglePoints.length
    ).map((_v, i) => {
      return i;
    });
    createBuffer(
      gl,
      program,
      trianglePointsTriangleIndex,
      1,
      "a_trianglePointIndex"
    );
  }
  updateVertexBuffersLines(projectedGeoToClipHomogeneousTransform) {
    if (!this.linesVao) {
      return;
    }
    const gl = this.gl;
    const program = this.linesProgram;
    gl.bindVertexArray(this.linesVao);
    this.setLineLayers();
    const clipSixPoints = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(lineLayer.projectedGeoLines),
      []
    ).map((projectedGeoLine) => [
      projectedGeoLine[0],
      projectedGeoLine[0],
      projectedGeoLine[0],
      projectedGeoLine[1],
      projectedGeoLine[1],
      projectedGeoLine[1]
    ]).flat().map(
      (point2) => applyHomogeneousTransform(projectedGeoToClipHomogeneousTransform, point2)
    );
    createBuffer(
      gl,
      program,
      new Float32Array(clipSixPoints.flat()),
      2,
      "a_clipPoint"
    );
    const clipSixOtherPoints = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(lineLayer.projectedGeoLines),
      []
    ).map((projectedGeoLine) => [
      projectedGeoLine[1],
      projectedGeoLine[1],
      projectedGeoLine[1],
      projectedGeoLine[0],
      projectedGeoLine[0],
      projectedGeoLine[0]
    ]).flat().map(
      (point2) => applyHomogeneousTransform(projectedGeoToClipHomogeneousTransform, point2)
    );
    createBuffer(
      gl,
      program,
      new Float32Array(clipSixOtherPoints.flat()),
      2,
      "a_clipOtherPoint"
    );
    const clipSixPreviousPoints = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(
        lineLayer.projectedGeoPreviousLines || lineLayer.projectedGeoLines
      ),
      []
    ).map((projectedGeoLine) => [
      projectedGeoLine[0],
      projectedGeoLine[0],
      projectedGeoLine[0],
      projectedGeoLine[1],
      projectedGeoLine[1],
      projectedGeoLine[1]
    ]).flat().map(
      (point2) => applyHomogeneousTransform(projectedGeoToClipHomogeneousTransform, point2)
    );
    createBuffer(
      gl,
      program,
      new Float32Array(clipSixPreviousPoints.flat()),
      2,
      "a_clipPreviousPoint"
    );
    const clipSixPreviousOtherPoints = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(
        lineLayer.projectedGeoPreviousLines || lineLayer.projectedGeoLines
      ),
      []
    ).map((projectedGeoLine) => [
      projectedGeoLine[1],
      projectedGeoLine[1],
      projectedGeoLine[1],
      projectedGeoLine[0],
      projectedGeoLine[0],
      projectedGeoLine[0]
    ]).flat().map(
      (point2) => applyHomogeneousTransform(projectedGeoToClipHomogeneousTransform, point2)
    );
    createBuffer(
      gl,
      program,
      new Float32Array(clipSixPreviousOtherPoints.flat()),
      2,
      "a_clipPreviousOtherPoint"
    );
    const sixIsOtherPoints = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(
        lineLayer.projectedGeoLines.flatMap((_projectedGeoLine) => [
          0,
          0,
          1,
          0,
          0,
          1
        ])
      ),
      []
    );
    createBuffer(
      gl,
      program,
      new Float32Array(sixIsOtherPoints),
      1,
      "a_isOtherPoint"
    );
    const sixNormalSigns = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(
        lineLayer.projectedGeoLines.flatMap((_projectedGeoLine) => [
          1,
          -1,
          1,
          1,
          -1,
          1
        ])
      ),
      []
    );
    createBuffer(
      gl,
      program,
      new Float32Array(sixNormalSigns),
      1,
      "a_normalSign"
    );
    const viewportSizes = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(
        lineLayer.projectedGeoLines.flatMap(
          (_projectedGeoLine) => Array(6).fill(
            lineLayer.viewportSize ?? defaultRenderLineLayerOptions.viewportSize
          )
        )
      ),
      []
    );
    createBuffer(
      gl,
      program,
      new Float32Array(viewportSizes),
      1,
      "a_viewportSize"
    );
    const colors = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(
        lineLayer.projectedGeoLines.flatMap(
          (_projectedGeoLine) => Array(6).fill(
            hexToFractionalOpaqueRgba(
              lineLayer.color ?? defaultRenderLineLayerOptions.color
            )
          )
        )
      ),
      []
    );
    createBuffer(gl, program, new Float32Array(colors.flat()), 4, "a_color");
    const viewportBorderSizes = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(
        lineLayer.projectedGeoLines.flatMap(
          (_projectedGeoLine) => Array(6).fill(
            lineLayer.viewportBorderSize ?? defaultRenderLineLayerOptions.viewportBorderSize
          )
        )
      ),
      []
    );
    createBuffer(
      gl,
      program,
      new Float32Array(viewportBorderSizes),
      1,
      "a_viewportBorderSize"
    );
    const borderColors = this.lineLayers.reduce(
      (accumulator, lineLayer) => accumulator.concat(
        lineLayer.projectedGeoLines.flatMap(
          (_projectedGeoLine) => Array(6).fill(
            hexToFractionalOpaqueRgba(
              lineLayer.borderColor ?? defaultRenderLineLayerOptions.borderColor
            )
          )
        )
      ),
      []
    );
    createBuffer(
      gl,
      program,
      new Float32Array(borderColors.flat()),
      4,
      "a_borderColor"
    );
  }
  updateVertexBuffersPoints(projectedGeoToClipHomogeneousTransform) {
    if (!this.pointsVao) {
      return;
    }
    const gl = this.gl;
    const program = this.pointsProgram;
    gl.bindVertexArray(this.pointsVao);
    this.setPointLayers();
    const clipPoints = this.pointLayers.reduce(
      (accumulator, pointLayer) => accumulator.concat(pointLayer.projectedGeoPoints),
      []
    ).map(
      (point2) => applyHomogeneousTransform(projectedGeoToClipHomogeneousTransform, point2)
    );
    createBuffer(
      gl,
      program,
      new Float32Array(clipPoints.flat()),
      2,
      "a_clipPoint"
    );
    const clipPreviousPoints = this.pointLayers.reduce(
      (accumulator, pointLayer) => accumulator.concat(
        pointLayer.projectedGeoPreviousPoints || pointLayer.projectedGeoPoints
      ),
      []
    ).map(
      (point2) => applyHomogeneousTransform(projectedGeoToClipHomogeneousTransform, point2)
    );
    createBuffer(
      gl,
      program,
      new Float32Array(clipPreviousPoints.flat()),
      2,
      "a_clipPreviousPoint"
    );
    const viewportSizes = this.pointLayers.reduce(
      (accumulator, pointLayer) => accumulator.concat(
        pointLayer.projectedGeoPoints.map(
          (_projectedGeoPoint) => pointLayer.viewportSize ?? defaultRenderPointLayerOptions.viewportSize
        )
      ),
      []
    );
    createBuffer(
      gl,
      program,
      new Float32Array(viewportSizes),
      1,
      "a_viewportSize"
    );
    const colors = this.pointLayers.reduce(
      (accumulator, pointLayer) => accumulator.concat(
        pointLayer.projectedGeoPoints.map(
          (_projectedGeoPoint) => hexToFractionalOpaqueRgba(
            pointLayer.color ?? defaultRenderPointLayerOptions.color
          )
        )
      ),
      []
    );
    createBuffer(gl, program, new Float32Array(colors.flat()), 4, "a_color");
    const viewportBorderSizes = this.pointLayers.reduce(
      (accumulator, pointLayer) => accumulator.concat(
        pointLayer.projectedGeoPoints.map(
          (_projectedGeoPoint) => pointLayer.viewportBorderSize ?? defaultRenderPointLayerOptions.viewportBorderSize
        )
      ),
      []
    );
    createBuffer(
      gl,
      program,
      new Float32Array(viewportBorderSizes),
      1,
      "a_viewportBorderSize"
    );
    const borderColors = this.pointLayers.reduce(
      (accumulator, pointLayer) => accumulator.concat(
        pointLayer.projectedGeoPoints.map(
          (_projectedGeoPoint) => hexToFractionalOpaqueRgba(
            pointLayer.borderColor ?? defaultRenderPointLayerOptions.borderColor
          )
        )
      ),
      []
    );
    createBuffer(
      gl,
      program,
      new Float32Array(borderColors.flat()),
      4,
      "a_borderColor"
    );
  }
  async updateTextures() {
    const gl = this.gl;
    this.updateCachedTilesForTextures();
    if (this.cachedTilesForTexture.length !== 0 && subSetArray(
      this.previousCachedTilesForTexture.map(
        (textureTile) => textureTile.tileUrl
      ),
      this.cachedTilesForTexture.map((textureTile) => textureTile.tileUrl)
    )) {
      return;
    }
    const requiredTextureWidth = Math.max(
      ...this.parsedImage.tileZoomLevels.map((size2) => size2.width)
    );
    const requiredTextureHeigt = Math.max(
      ...this.parsedImage.tileZoomLevels.map((size2) => size2.height)
    );
    const requiredTextureDepth = this.cachedTilesForTexture.length;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.cachedTilesTextureArray);
    gl.texImage3D(
      gl.TEXTURE_2D_ARRAY,
      0,
      gl.RGBA,
      requiredTextureWidth,
      requiredTextureHeigt,
      requiredTextureDepth,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      null
    );
    for (let i = 0; i < this.cachedTilesForTexture.length; i++) {
      const imageData = this.cachedTilesForTexture[i].data;
      const pbo = gl.createBuffer();
      gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, pbo);
      gl.bufferData(gl.PIXEL_UNPACK_BUFFER, imageData.data, gl.STATIC_DRAW);
      gl.texSubImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        0,
        0,
        i,
        imageData.width,
        imageData.height,
        1,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        0
      );
      gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
    }
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    const cachedTilesResourceOriginPointsAndDimensions = this.cachedTilesForTexture.map((textureTile) => {
      if (textureTile && textureTile.imageRequest && textureTile.imageRequest.region) {
        return [
          textureTile.imageRequest.region.x,
          textureTile.imageRequest.region.y,
          textureTile.imageRequest.region.width,
          textureTile.imageRequest.region.height
        ];
      }
    });
    gl.bindTexture(
      gl.TEXTURE_2D,
      this.cachedTilesResourceOriginPointsAndDimensionsTexture
    );
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.R32I,
      1,
      this.cachedTilesForTexture.length * 4,
      0,
      gl.RED_INTEGER,
      gl.INT,
      new Int32Array(cachedTilesResourceOriginPointsAndDimensions.flat())
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    const cachedTilesScaleFactors = this.cachedTilesForTexture.map(
      (textureTile) => textureTile.tile.tileZoomLevel.scaleFactor
    );
    gl.bindTexture(gl.TEXTURE_2D, this.cachedTilesScaleFactorsTexture);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.R32I,
      1,
      this.cachedTilesForTexture.length,
      0,
      gl.RED_INTEGER,
      gl.INT,
      new Int32Array(cachedTilesScaleFactors)
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.TEXTURESUPDATED));
  }
  updateCachedTilesForTextures() {
    const cachedTiles = [];
    const cachedTilesAtOtherScaleFactors = [];
    const overviewCachedTiles = [];
    for (const fetchableTile of this.fetchableTilesForViewport) {
      const cachedTile = this.cachedTilesByTileUrl.get(fetchableTile.tileUrl);
      if (cachedTile) {
        cachedTiles.push(cachedTile);
      } else {
        for (const cachedTile2 of this.getCachedTilesAtOtherScaleFactors(
          fetchableTile.tile
        )) {
          cachedTilesAtOtherScaleFactors.push(cachedTile2);
        }
      }
    }
    for (const fetchableTile of this.overviewFetchableTilesForViewport) {
      const cachedTile = this.cachedTilesByTileUrl.get(fetchableTile.tileUrl);
      if (cachedTile) {
        const tileZoolLevelTilesCount = this.tileZoomLevelForViewport ? this.tileZoomLevelForViewport.rows * this.tileZoomLevelForViewport.columns : void 0;
        if (cachedTiles.length === 0 || tileZoolLevelTilesCount && cachedTiles.length < tileZoolLevelTilesCount) {
          overviewCachedTiles.push(cachedTile);
        }
      }
    }
    let cachedTilesForTextures = [
      ...cachedTiles,
      ...cachedTilesAtOtherScaleFactors,
      ...overviewCachedTiles
    ];
    const cachedTilesForTexturesByTileUrl = /* @__PURE__ */ new Map();
    cachedTilesForTextures.forEach(
      (cachedTile) => cachedTilesForTexturesByTileUrl.set(cachedTile.tileUrl, cachedTile)
    );
    cachedTilesForTextures = [...cachedTilesForTexturesByTileUrl.values()];
    this.previousCachedTilesForTexture = this.cachedTilesForTexture;
    this.cachedTilesForTexture = cachedTilesForTextures;
    return;
  }
  getCachedTilesAtOtherScaleFactors(tile) {
    if (this.cachedTilesByTileUrl.size === 0) {
      return [];
    }
    if (!this.tileZoomLevelForViewport) {
      return [];
    }
    const cachedTiles = [];
    for (tile of getTilesAtOtherScaleFactors(
      tile,
      this.parsedImage,
      this.tileZoomLevelForViewport.scaleFactor,
      TEXTURES_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF,
      TEXTURES_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF,
      this.tileInCachedTiles.bind(this)
      // Only consider tiles in cache,
    )) {
      const cachedTile = this.tileToCachedTile(tile);
      if (cachedTile) {
        cachedTiles.push(cachedTile);
      } else {
        throw new Error("Tile supposed to be in cache isn't.");
      }
    }
    return cachedTiles;
  }
  // Lookup by tileKey (zoomlevel, row, column) instead of tileUrl
  // Because computing the tileUrl for every tile is expensive
  tileToCachedTile(tile) {
    return this.cachedTilesByTileKey.get(tileKey(tile));
  }
  tileInCachedTiles(tile) {
    return this.cachedTilesByTileKey.has(tileKey(tile));
  }
};

// node_modules/@allmaps/render/dist/tilecache/CacheableTile.js
var CacheableTile = class extends EventTarget {
  tile;
  imageRequest;
  tileUrl;
  tileKey;
  fetchFn;
  abortController;
  data;
  /**
   * Creates an instance of CacheableTile.
   *
   * @constructor
   * @param fetchableTile
   * @param fetchFn - Optional fetch function to use
   */
  constructor(fetchableTile, fetchFn) {
    super();
    this.tile = fetchableTile.tile;
    this.imageRequest = fetchableTile.imageRequest;
    this.tileUrl = fetchableTile.tileUrl;
    this.tileKey = fetchableTile.tileKey;
    this.fetchFn = fetchFn;
    this.abortController = new AbortController();
  }
  /**
   * Whether a tile has fetched its data
   *
   * @returns
   */
  isCachedTile() {
    return this.data !== void 0;
  }
  /**
   * Abort the fetch
   */
  abort() {
    if (!this.abortController.signal.aborted) {
      this.abortController.abort();
    }
  }
};

// node_modules/@allmaps/render/dist/tilecache/CacheableWorkerImageDataTile.js
var CacheableWorkerImageDataTile = class _CacheableWorkerImageDataTile extends CacheableTile {
  #worker;
  constructor(fetchableTile, worker, fetchFn) {
    super(fetchableTile, fetchFn);
    this.#worker = worker;
  }
  /**
   * Fetch the tile and create its ImageData using a WebWorker.
   *
   * @returns
   */
  async fetch() {
    try {
      this.#worker.getImageData(
        this.tileUrl,
        proxy(() => this.abortController.abort()),
        this.fetchFn,
        this.tile.tileZoomLevel.width,
        this.tile.tileZoomLevel.height
      ).then((response) => {
        this.data = response;
        this.dispatchEvent(
          new WarpedMapEvent(WarpedMapEventType.TILEFETCHED, this.tileUrl)
        );
      }).catch((err) => {
        if (err instanceof Error && err.name === "AbortError") {
          console.log("Fetch aborted");
        } else {
          console.error(err);
        }
      });
    } catch (err) {
      if (err instanceof Error && err.name === "AbortError") ;
      else {
        this.dispatchEvent(
          new WarpedMapEvent(WarpedMapEventType.TILEFETCHERROR, this.tileUrl)
        );
      }
    }
    return this.data;
  }
  static createFactory(worker) {
    return (fetchableTile, fetchFn) => new _CacheableWorkerImageDataTile(fetchableTile, worker, fetchFn);
  }
};

// node_modules/@allmaps/render/dist/viewport/Viewport.js
var defaultViewportOptions = {
  rotation: 0,
  devicePixelRatio: 1,
  projection: webMercatorProjection
};
var defaultZoomOptions = {
  zoom: 1
};
var defaultFitOptions = {
  fit: "contain"
};
var Viewport = class _Viewport {
  geoCenter;
  geoRectangle;
  geoSize;
  geoResolution;
  geoRectangleBbox;
  projection;
  projectedGeoCenter;
  projectedGeoRectangle;
  projectedGeoSize;
  projectedGeoResolution;
  projectedGeoRectangleBbox;
  rotation;
  projectedGeoPerViewportScale;
  viewportCenter;
  viewportRectangle;
  viewportSize;
  viewportResolution;
  viewportBbox;
  devicePixelRatio;
  canvasCenter;
  canvasRectangle;
  canvasSize;
  canvasResolution;
  canvasBbox;
  projectedGeoPerCanvasScale;
  projectedGeoToViewportHomogeneousTransform = [
    1,
    0,
    0,
    1,
    0,
    0
  ];
  projectedGeoToCanvasHomogeneousTransform = [
    1,
    0,
    0,
    1,
    0,
    0
  ];
  projectedGeoToClipHomogeneousTransform = [
    1,
    0,
    0,
    1,
    0,
    0
  ];
  viewportToClipHomogeneousTransform = [1, 0, 0, 1, 0, 0];
  /**
   * Creates a new Viewport
   *
   * @constructor
   * @param viewportSize - Size of the viewport in viewport pixels, as [width, height].
   * @param projectedGeoCenter - Center point of the viewport, in projected geospatial coordinates.
   * @param projectedGeoPerViewportScale - Scale of the viewport, in projection coordinates per viewport pixel.
   * @param rotation - Rotation of the viewport with respect to the projected geo coordinate system. Positive values rotate the viewport positively (i.e. counter-clockwise) w.r.t. the map in projected geospatial coordinates. This is equivalent to rotating the map negatively (i.e. clockwise) within the viewport.
   * @param devicePixelRatio - The devicePixelRatio of the viewport.
   * @param projection - The projection the projected coordinates are in .
   */
  constructor(viewportSize, projectedGeoCenter, projectedGeoPerViewportScale, partialViewportOptions) {
    const viewportOptions = mergeOptions(
      defaultViewportOptions,
      partialViewportOptions
    );
    this.projectedGeoCenter = projectedGeoCenter;
    this.projectedGeoPerViewportScale = projectedGeoPerViewportScale;
    this.rotation = viewportOptions.rotation;
    this.viewportSize = [
      Math.round(viewportSize[0]),
      Math.round(viewportSize[1])
    ];
    this.devicePixelRatio = viewportOptions.devicePixelRatio;
    this.projection = viewportOptions.projection;
    this.projectedGeoRectangle = this.computeProjectedGeoRectangle(
      this.viewportSize,
      this.projectedGeoPerViewportScale,
      this.rotation,
      this.projectedGeoCenter
    );
    this.projectedGeoRectangleBbox = computeBbox(this.projectedGeoRectangle);
    this.projectedGeoSize = scaleSize(
      this.viewportSize,
      projectedGeoPerViewportScale
    );
    this.projectedGeoResolution = sizeToResolution(this.projectedGeoSize);
    this.geoRectangle = this.projectedGeoRectangle.map((point2) => {
      return lib_default(
        this.projection.definition,
        lonLatProjection.definition,
        point2
      );
    });
    this.geoRectangleBbox = computeBbox(this.geoRectangle);
    this.geoCenter = bboxToCenter(this.geoRectangleBbox);
    this.geoSize = bboxToSize(this.geoRectangleBbox);
    this.geoResolution = sizeToResolution(this.geoSize);
    this.viewportResolution = sizeToResolution(this.viewportSize);
    this.viewportCenter = sizeToCenter(this.viewportSize);
    this.viewportBbox = sizeToBbox(this.viewportSize);
    this.viewportRectangle = bboxToRectangle(this.viewportBbox);
    this.canvasCenter = scalePoint(this.viewportCenter, this.devicePixelRatio);
    this.canvasSize = scaleSize(this.viewportSize, this.devicePixelRatio);
    this.canvasResolution = sizeToResolution(this.canvasSize);
    this.canvasBbox = sizeToBbox(this.canvasSize);
    this.canvasRectangle = bboxToRectangle(this.canvasBbox);
    this.projectedGeoPerCanvasScale = this.projectedGeoPerViewportScale / this.devicePixelRatio;
    this.projectedGeoToViewportHomogeneousTransform = this.composeProjectedGeoToViewportHomogeneousTransform();
    this.projectedGeoToCanvasHomogeneousTransform = this.composeProjectedGeoToCanvasHomogeneousTransform();
    this.projectedGeoToClipHomogeneousTransform = this.composeProjectedGeoToClipHomogeneousTransform();
    this.viewportToClipHomogeneousTransform = this.composeViewportToClipHomogeneousTransform();
  }
  /**
   * Static method that creates a Viewport from a size and maps.
   *
   * Optionally specify a projection, to be used both when obtaining the extent of selected warped maps in projected geospatial coordinates, as well as when create a viewport
   *
   * @param viewportSize - Size of the viewport in viewport pixels, as [width, height].
   * @param warpedMapList - A WarpedMapList.
   * @param partialExtendedViewportOptions - Optional viewport options
   * @returns A new Viewport object.
   */
  static fromSizeAndMaps(viewportSize, warpedMapList, partialExtendedViewportOptions) {
    const projectedGeoConvexHull = warpedMapList.getMapsConvexHull(
      partialExtendedViewportOptions
    );
    if (!projectedGeoConvexHull) {
      throw new Error(
        "Maps have no projected convex hull. Possibly because WarpedMapList or Array is empty."
      );
    }
    return this.fromSizeAndProjectedGeoPolygon(
      viewportSize,
      [projectedGeoConvexHull],
      partialExtendedViewportOptions
    );
  }
  /**
   * Static method that creates a Viewport from a size and a polygon in geospatial coordinates, i.e. lon-lat `EPSG:4326`.
   *
   * @static
   * @param viewportSize - Size of the viewport in viewport pixels, as [width, height].
   * @param geoPolygon - A polygon in geospatial coordinates.
   * @param partialExtendedViewportOptions - Optional viewport options
   * @returns A new Viewport object.
   */
  static fromSizeAndGeoPolygon(viewportSize, geoPolygon, partialExtendedViewportOptions) {
    const extendedViewportOptions = mergeOptions(
      {
        ...defaultViewportOptions,
        ...defaultZoomOptions,
        ...defaultFitOptions
      },
      partialExtendedViewportOptions
    );
    const projectedGeoPolygon = geoPolygon.map(
      (ring) => ring.map(
        (point2) => lib_default(extendedViewportOptions.projection.definition, point2)
      )
    );
    return this.fromSizeAndProjectedGeoPolygon(
      viewportSize,
      projectedGeoPolygon,
      partialExtendedViewportOptions
    );
  }
  /**
   * Static method that creates a Viewport from a size and a polygon in projected geospatial coordinates.
   *
   * @static
   * @param viewportSize - Size of the viewport in viewport pixels, as [width, height].
   * @param projectedGeoPolygon - A polygon in projected geospatial coordinates.
   * @param partialExtendedViewportOptions - Optional viewport options
   * @returns A new Viewport object.
   */
  static fromSizeAndProjectedGeoPolygon(viewportSize, projectedGeoPolygon, partialExtendedViewportOptions) {
    const extendedViewportOptions = mergeOptions(
      {
        ...defaultViewportOptions,
        ...defaultZoomOptions,
        ...defaultFitOptions
      },
      partialExtendedViewportOptions
    );
    const projectedGeoRing = projectedGeoPolygon[0];
    const rotatedProjectedGeoRing = rotatePoints(
      projectedGeoRing,
      -extendedViewportOptions.rotation
    );
    const rotatedProjectedGeoBbox = computeBbox(rotatedProjectedGeoRing);
    const rotatedProjectedGeoSize = bboxToSize(rotatedProjectedGeoBbox);
    const rotatedProjectedGeoCenter = bboxToCenter(rotatedProjectedGeoBbox);
    const projectedGeoPerViewportScale = sizesToScale(
      rotatedProjectedGeoSize,
      viewportSize,
      extendedViewportOptions.fit
    );
    const projectedGeoCenter = rotatePoint(
      rotatedProjectedGeoCenter,
      extendedViewportOptions.rotation
    );
    return new _Viewport(
      viewportSize,
      projectedGeoCenter,
      projectedGeoPerViewportScale * extendedViewportOptions.zoom,
      extendedViewportOptions
    );
  }
  /**
   * Static method that creates a Viewport from a scale and maps.
   *
   * Optionally specify a projection, to be used both when obtaining the extent of selected warped maps in projected geospatial coordinates, as well as when create a viewport
   *
   * @param projectedGeoPerViewportScale - Scale of the viewport, in projected geospatial coordinates per viewport pixel.
   * @param warpedMapList - A WarpedMapList.
   * @param partialExtendedViewportOptions - Optional viewport options.
   * @returns A new Viewport object.
   */
  static fromScaleAndMaps(projectedGeoPerViewportScale, warpedMapList, partialExtendedViewportOptions) {
    const projectedGeoConvexHull = warpedMapList.getMapsConvexHull(
      partialExtendedViewportOptions
    );
    if (!projectedGeoConvexHull) {
      throw new Error(
        "Maps have no projected convex hull. Possibly because WarpedMapList or Array is empty."
      );
    }
    return this.fromScaleAndProjectedGeoPolygon(
      projectedGeoPerViewportScale,
      [projectedGeoConvexHull],
      partialExtendedViewportOptions
    );
  }
  /**
   * Static method that creates a Viewport from a scale and a polygon in geospatial coordinates, i.e. lon-lat `EPSG:4326`.
   *
   * Note: the scale is still in *projected* geospatial per viewport pixel!
   *
   * @param projectedGeoPerViewportScale - Scale of the viewport, in projected geospatial coordinates per viewport pixel.
   * @param geoPolygon - A polygon in geospatial coordinates.
   * @param partialViewportOptions - Optional viewport options.
   * @returns A new Viewport object.
   */
  static fromScaleAndGeoPolygon(projectedGeoPerViewportScale, geoPolygon, partialExtendedViewportOptions) {
    const extendedViewportOptions = mergeOptions(
      {
        ...defaultViewportOptions,
        ...defaultZoomOptions,
        ...defaultFitOptions
      },
      partialExtendedViewportOptions
    );
    const projectedGeoPolygon = geoPolygon.map(
      (ring) => ring.map(
        (point2) => lib_default(extendedViewportOptions.projection.definition, point2)
      )
    );
    return this.fromScaleAndProjectedGeoPolygon(
      projectedGeoPerViewportScale,
      projectedGeoPolygon,
      partialExtendedViewportOptions
    );
  }
  /**
   * Static method that creates a Viewport from a scale and a polygon in projected geospatial coordinates.
   *
   * @param projectedGeoPerViewportScale - Scale of the viewport, in projected geospatial coordinates per viewport pixel.
   * @param projectedGeoPolygon - A polygon in projected geospatial coordinates.
   * @param partialViewportOptions - Optional viewport options.
   * @returns A new Viewport object.
   */
  static fromScaleAndProjectedGeoPolygon(projectedGeoPerViewportScale, projectedGeoPolygon, partialExtendedViewportOptions) {
    const extendedViewportOptions = mergeOptions(
      {
        ...defaultViewportOptions,
        ...defaultZoomOptions
      },
      partialExtendedViewportOptions
    );
    const projectedGeoRing = projectedGeoPolygon[0];
    const viewportRing = scalePoints(
      rotatePoints(projectedGeoRing, -extendedViewportOptions.rotation),
      1 / projectedGeoPerViewportScale
    );
    const viewportBbox = computeBbox(viewportRing);
    const viewportSize = bboxToSize(viewportBbox);
    const viewportCenter = bboxToCenter(viewportBbox);
    const projectedGeoCenter = rotatePoint(
      scalePoint(viewportCenter, projectedGeoPerViewportScale),
      extendedViewportOptions.rotation
    );
    return new _Viewport(
      viewportSize,
      projectedGeoCenter,
      projectedGeoPerViewportScale * extendedViewportOptions.zoom,
      extendedViewportOptions
    );
  }
  getProjectedGeoBufferedRectangle(bufferFraction) {
    const viewportBufferedBbox = bufferBboxByRatio(
      this.viewportBbox,
      bufferFraction
    );
    const viewportBufferedRectangle = bboxToRectangle(viewportBufferedBbox);
    return viewportBufferedRectangle.map(
      (point2) => applyHomogeneousTransform(
        invertHomogeneousTransform(
          this.projectedGeoToViewportHomogeneousTransform
        ),
        point2
      )
    );
  }
  composeProjectedGeoToViewportHomogeneousTransform() {
    return composeHomogeneousTransform(
      this.viewportCenter[0],
      this.viewportCenter[1],
      1 / this.projectedGeoPerViewportScale,
      -1 / this.projectedGeoPerViewportScale,
      // '-' for handedness
      -this.rotation,
      -this.projectedGeoCenter[0],
      -this.projectedGeoCenter[1]
    );
  }
  composeProjectedGeoToCanvasHomogeneousTransform() {
    return composeHomogeneousTransform(
      this.canvasCenter[0],
      this.canvasCenter[1],
      1 / this.projectedGeoPerCanvasScale,
      -1 / this.projectedGeoPerCanvasScale,
      // '-' for handedness
      -this.rotation,
      -this.projectedGeoCenter[0],
      -this.projectedGeoCenter[1]
    );
  }
  composeProjectedGeoToClipHomogeneousTransform() {
    return composeHomogeneousTransform(
      0,
      0,
      2 / (this.projectedGeoPerViewportScale * this.viewportSize[0]),
      2 / (this.projectedGeoPerViewportScale * this.viewportSize[1]),
      -this.rotation,
      -this.projectedGeoCenter[0],
      -this.projectedGeoCenter[1]
    );
  }
  composeViewportToClipHomogeneousTransform() {
    return composeHomogeneousTransform(
      0,
      0,
      2 / this.viewportSize[0],
      -2 / this.viewportSize[1],
      // '-' for handedness
      0,
      -this.viewportCenter[0],
      -this.viewportCenter[1]
    );
  }
  /**
   * Returns a rectangle in projected geospatial coordinates
   *
   * The rectangle is the result of a horizontal rectangle in Viewport space of size 'viewportSize',
   * scaled using projectedGeoPerViewportScale, centered,
   * rotated using 'rotation' and translated to 'projectedGeoCenter'.
   *
   * @private
   * @param viewportSize
   * @param projectedGeoPerViewportScale
   * @param rotation
   * @param projectedGeoCenter
   */
  computeProjectedGeoRectangle(viewportSize, projectedGeoPerViewportScale, rotation, projectedGeoCenter) {
    const scaled = scaleSize(viewportSize, projectedGeoPerViewportScale);
    const rectangle = sizeToRectangle(scaled);
    const centered = translatePoints(
      rectangle,
      midPoint(...rectangle),
      "substract"
    );
    const rotated = rotatePoints(centered, rotation);
    const translated = translatePoints(rotated, projectedGeoCenter);
    return translated;
  }
};

// node_modules/@allmaps/render/dist/shaders/map/vertex-shader.glsl.js
var vertex_shader_default = "#version 300 es\n\nprecision highp float;\n\nfloat easing(float t) {\n  return t;\n\n  \n  \n}\n\nuniform mat4 u_renderHomogeneousTransform;\nuniform float u_animationProgress;\n\nin vec2 a_resourceTrianglePoint;\nin vec2 a_clipPreviousTrianglePoint;\nin vec2 a_clipTrianglePoint;\nin float a_previousTrianglePointDistortion;\nin float a_trianglePointDistortion;\nin float a_trianglePointIndex;\n\nout vec2 v_resourceTrianglePoint;\nout float v_trianglePointDistortion;\nout float v_trianglePointIndex;\nout vec4 v_trianglePointBarycentric;\n\nvoid main() {\n  \n  vec2 clipTrianglePoint = mix(a_clipPreviousTrianglePoint, a_clipTrianglePoint, easing(u_animationProgress));\n  float trianglePointDistortion = mix(a_previousTrianglePointDistortion, a_trianglePointDistortion, easing(u_animationProgress));\n\n  \n  \n  \n\n  gl_Position = u_renderHomogeneousTransform * vec4(clipTrianglePoint, 0.0f, 1.0f);\n\n  \n  v_resourceTrianglePoint = a_resourceTrianglePoint;\n  v_trianglePointDistortion = trianglePointDistortion;\n  v_trianglePointIndex = a_trianglePointIndex;\n\n  float trianglePointLocalIndex = mod(a_trianglePointIndex, 3.0f);\n  if(trianglePointLocalIndex == 0.0f)\n    v_trianglePointBarycentric = vec4(1.0f, 0, 0, 1.0f);\n  if(trianglePointLocalIndex == 1.0f)\n    v_trianglePointBarycentric = vec4(0.0f, 1.0f, 0, 1.0f);\n  if(trianglePointLocalIndex == 2.0f)\n    v_trianglePointBarycentric = vec4(0.0f, 0, 1.0f, 1.0f);\n}";

// node_modules/@allmaps/render/dist/shaders/map/fragment-shader.glsl.js
var fragment_shader_default = "#version 300 es\n\nprecision highp float;\nprecision highp isampler2D;\n\nfloat easing(float t) {\n  return t;\n\n  \n  \n}\n\nuniform float u_debug;\n\nuniform bool u_removeColor;\nuniform vec3 u_removeColorOptionsColor;\nuniform float u_removeColorOptionsThreshold;\nuniform float u_removeColorOptionsHardness;\n\nuniform bool u_colorize;\nuniform vec3 u_colorizeOptionsColor;\n\nuniform bool u_grid;\n\nuniform float u_opacity;\nuniform float u_saturation;\n\nuniform bool u_distortion;\nuniform int u_distortionOptionsdistortionMeasure;\n\nuniform int u_scaleFactorForViewport;\n\nuniform lowp sampler2DArray u_cachedTilesTextureArray;\nuniform isampler2D u_cachedTilesResourceOriginPointsAndDimensionsTexture;\nuniform isampler2D u_cachedTilesScaleFactorsTexture;\n\nuniform vec4 u_colorDistortion00;\nuniform vec4 u_colorDistortion01;\nuniform vec4 u_colorDistortion1;\nuniform vec4 u_colorDistortion2;\nuniform vec4 u_colorDistortion3;\nuniform vec4 u_colorGrid;\n\nin vec2 v_resourceTrianglePoint;\nin float v_trianglePointDistortion;\nin float v_trianglePointIndex;\nin vec4 v_trianglePointBarycentric;\n\nout vec4 color;\n\nvoid main() {\n  float resourceTrianglePointX = v_resourceTrianglePoint.x;\n  float resourceTrianglePointY = v_resourceTrianglePoint.y;\n\n  \n  ivec3 cachedTilesTextureSize = textureSize(u_cachedTilesTextureArray, 0);\n  int cachedTilesCount = cachedTilesTextureSize.z;\n\n  \n  int smallestScaleFactor;\n  bool found = false;\n  int foundIndex;\n\n  \n  vec3 cachedTilesTexturePoint = vec3(0.0f, 0.0f, 0.0f);\n\n  \n  color = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n  \n  for(int index = 0; index < cachedTilesCount; index += 1) {\n\n    \n    float cachedTileResourceOriginPointX = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4)), 0));\n    float cachedTileResourceOriginPointY = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4) + 1), 0));\n    float cachedTileDimensionWidth = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4) + 2), 0));\n    float cachedTileDimensionHeight = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4) + 3), 0));\n\n    int cachedTileScaleFactor = texelFetch(u_cachedTilesScaleFactorsTexture, ivec2(0, index), 0).r;\n\n    \n    if(resourceTrianglePointX >= cachedTileResourceOriginPointX &&\n      resourceTrianglePointX < cachedTileResourceOriginPointX + cachedTileDimensionWidth &&\n      resourceTrianglePointY >= cachedTileResourceOriginPointY &&\n      resourceTrianglePointY < cachedTileResourceOriginPointY + cachedTileDimensionHeight) {\n\n      \n      \n      \n      \n      \n      if(!(smallestScaleFactor > 0) || cachedTileScaleFactor <= smallestScaleFactor) {\n        smallestScaleFactor = cachedTileScaleFactor;\n        found = true;\n        foundIndex = index;\n\n        float cachedTilePointX = (resourceTrianglePointX - cachedTileResourceOriginPointX) / float(cachedTileScaleFactor);\n        float cachedTilePointY = (resourceTrianglePointY - cachedTileResourceOriginPointY) / float(cachedTileScaleFactor);\n\n        float cachedTilesTexturePointX = cachedTilePointX / float(cachedTilesTextureSize.x);\n        float cachedTilesTexturePointY = cachedTilePointY / float(cachedTilesTextureSize.y);\n\n        cachedTilesTexturePoint = vec3(cachedTilesTexturePointX, cachedTilesTexturePointY, index);\n      }\n    }\n  }\n\n  if(found == true) {\n    \n    color = texture(u_cachedTilesTextureArray, cachedTilesTexturePoint);\n\n    if(u_removeColorOptionsThreshold > 0.0f) {\n  vec3 backgroundColorDiff = color.rgb - u_removeColorOptionsColor.rgb;\n  float backgroundColorDistance = length(backgroundColorDiff);\n  if(u_removeColor && backgroundColorDistance < u_removeColorOptionsThreshold) {\n    float amount = smoothstep(u_removeColorOptionsThreshold - u_removeColorOptionsThreshold * (1.0f - u_removeColorOptionsHardness), u_removeColorOptionsThreshold, backgroundColorDistance);\n    color = vec4(color.rgb * amount, amount);\n  }\n}\n\nfloat gray = 0.21f * color.r + 0.71f * color.g + 0.07f * color.b;\ncolor = vec4(color.rgb * (u_saturation) + (gray * (1.0f - u_saturation)), color.a);\n\nif(u_colorize) {\n  color = vec4((u_colorizeOptionsColor + color.rgb) * color.a, color.a);\n}\n\ncolor = vec4(color.rgb * u_opacity, color.a * u_opacity);\n    if(u_distortion) {\n  \n  \n\n  float trianglePointDistortion = v_trianglePointDistortion;\n\n  \n  \n  trianglePointDistortion = floor(trianglePointDistortion * 10.0f) / 10.0f;\n\n  \n  float trianglePointDistortionMix = clamp(trianglePointDistortion, -1.0f, 1.0f);\n\n  switch(u_distortionOptionsdistortionMeasure) {\n    case 0:\n      if(trianglePointDistortion > 0.0f) {\n        color = mix(color, u_colorDistortion00, trianglePointDistortionMix);\n      } else {\n        color = mix(color, u_colorDistortion01, abs(trianglePointDistortionMix));\n      }\n      break;\n    case 1:\n      color = mix(color, u_colorDistortion1, trianglePointDistortionMix);\n      break;\n    case 2:\n      color = mix(color, u_colorDistortion2, trianglePointDistortionMix);\n      break;\n    case 3:\n      color = trianglePointDistortion == -1.0f ? u_colorDistortion3 : color;\n      break;\n    default:\n      color = color;\n  }\n}\n\nif(u_grid) {\n  float gridSize = 20.0f * float(u_scaleFactorForViewport);\n  float gridWidth = 2.0f * float(u_scaleFactorForViewport);\n  if(mod(float(resourceTrianglePointX) + gridWidth / 2.0f, gridSize) < gridWidth || mod(float(resourceTrianglePointY) + gridWidth / 2.0f, gridSize) < gridWidth) {\n    color = u_colorGrid;\n  }\n}\n    if(bool(u_debug)) {\n  float viewportWidth = 4.0;\n\n  \n\n  \n  \n  \n\n  float barycentricTriangleDist = min(min(v_trianglePointBarycentric.x, v_trianglePointBarycentric.y), v_trianglePointBarycentric.z);\n  \n  \n  float barycentricTriangleDistPixelSize = length(vec2(dFdx(barycentricTriangleDist), dFdy(barycentricTriangleDist)));\n  \n  float TriangleDistThreshold = viewportWidth * barycentricTriangleDistPixelSize / 2.0;\n\n  if(barycentricTriangleDist < TriangleDistThreshold) {\n    color = vec4(0.0, 0.0, 0.0, 1.0);\n  }\n\n  \n\n  float resourceDist = min(cachedTilesTexturePoint.x, cachedTilesTexturePoint.y);\n  \n  \n  float resourceDistPixelSize = length(vec2(dFdx(resourceDist), dFdy(resourceDist)));\n  float resourceDistThreshold = viewportWidth * resourceDistPixelSize;\n\n  if(resourceDist < resourceDistThreshold) {\n    color = vec4(0.0, 0.0, 1.0, 1.0);\n  }\n}\n  }\n}";

// node_modules/@allmaps/render/dist/shaders/lines/vertex-shader.glsl.js
var vertex_shader_default2 = "#version 300 es\n\nprecision highp float;\n\nfloat easing(float t) {\n  return t;\n\n  \n  \n}\n\nuniform mat4 u_renderHomogeneousTransform;\nuniform mat4 u_viewportToClipHomogeneousTransform;\nuniform mat4 u_clipToViewportHomogeneousTransform;\nuniform float u_animationProgress;\n\nin vec2 a_clipPoint;\nin vec2 a_clipOtherPoint;\nin vec2 a_clipPreviousPoint;\nin vec2 a_clipPreviousOtherPoint;\nin float a_isOtherPoint;\nin float a_normalSign;\nin float a_viewportSize;\nin vec4 a_color;\nin float a_viewportBorderSize;\nin vec4 a_borderColor;\n\nout float v_viewportLineLength;\nout vec2 v_linePoint;\nout float v_viewportSize;\nout vec4 v_color;\nout float v_viewportBorderSize;\nout vec4 v_borderColor;\nout float v_viewportFeatherSize;\nout float v_viewportTotalSize;\n\nvoid main() {\n  vec2 clipPoint = mix(a_clipPreviousPoint, a_clipPoint, easing(u_animationProgress));\n  vec2 clipOtherPoint = mix(a_clipPreviousOtherPoint, a_clipOtherPoint, easing(u_animationProgress));\n\n  vec2 viewportPoint = (u_clipToViewportHomogeneousTransform * u_renderHomogeneousTransform * vec4(clipPoint, 0.0f, 1.0f)).xy;\n  vec2 viewportOtherPoint = (u_clipToViewportHomogeneousTransform * u_renderHomogeneousTransform * vec4(clipOtherPoint, 0.0f, 1.0f)).xy;\n\n  vec2 viewportLine = vec2(viewportOtherPoint.x-viewportPoint.x, viewportOtherPoint.y-viewportPoint.y);\n  vec2 viewportNormalizedLine = normalize(viewportLine);\n  vec2 viewportNormalizedLineNormal = vec2(viewportNormalizedLine.y, -viewportNormalizedLine.x);\n  v_viewportLineLength = length(viewportLine);\n\n  v_viewportFeatherSize = 1.0;\n\n  \n  \n  \n  float viewportSize = a_viewportSize / 2.0;\n  float viewportBorderSize = a_viewportBorderSize / 2.0;\n  v_viewportFeatherSize = v_viewportFeatherSize / 2.0;\n\n  v_viewportTotalSize = viewportSize + viewportBorderSize + v_viewportFeatherSize;\n  float lineX = -1.0 * v_viewportTotalSize / 2.0 + a_isOtherPoint * (v_viewportLineLength + 2.0 * (v_viewportTotalSize / 2.0));\n  float lineY = a_normalSign * v_viewportTotalSize / 2.0;\n  v_linePoint = vec2(lineX, lineY);\n  \n  \n  \n  \n  \n  \n\n  v_viewportSize = viewportSize;\n  v_color = a_color;\n  v_viewportBorderSize = viewportBorderSize;\n  v_borderColor = a_borderColor;\n\n  gl_Position =  u_viewportToClipHomogeneousTransform * vec4(viewportPoint + lineX * viewportNormalizedLine + lineY * viewportNormalizedLineNormal, 0, 1);\n}";

// node_modules/@allmaps/render/dist/shaders/lines/fragment-shader.glsl.js
var fragment_shader_default2 = "#version 300 es\n\nprecision highp float;\nprecision highp isampler2D;\n\nin float v_viewportLineLength;\nin vec2 v_linePoint;\nin float v_viewportSize;\nin vec4 v_color;\nin float v_viewportBorderSize;\nin vec4 v_borderColor;\nin float v_viewportFeatherSize;\nin float v_viewportTotalSize;\n\nout vec4 color;\n\nvoid main() {\n  float distance;\n  if (v_linePoint.x < 0.0) {\n    distance = length(v_linePoint - vec2(0.0,0.0)) / (v_viewportTotalSize / 2.0);\n  } else if (v_linePoint.x > v_viewportLineLength) {\n    distance = length(v_linePoint - vec2(v_viewportLineLength,0.0)) / (v_viewportTotalSize / 2.0);\n  } else {\n    distance = abs(v_linePoint.y) / (v_viewportTotalSize / 2.0);\n  }\n  if (distance > 1.0) {\n    discard;\n  }\n  float viewportDistance = distance * v_viewportTotalSize / 2.0;\n\n  \n  color = vec4(0, 0, 0, 0);\n  if (v_viewportSize >= v_viewportFeatherSize) {\n    color = v_color;\n  }\n\n  \n  \n  \n  float borderSmoothStep;\n  if(v_viewportBorderSize >= v_viewportFeatherSize) {\n    borderSmoothStep = smoothstep(\n      v_viewportSize / 2.0 - v_viewportBorderSize / 2.0 - v_viewportFeatherSize / 2.0,\n      v_viewportSize / 2.0 - v_viewportBorderSize / 2.0 + v_viewportFeatherSize / 2.0,\n      viewportDistance\n    );\n    color = ((1.0 - borderSmoothStep) * color) + (borderSmoothStep * v_borderColor);\n  }\n\n  \n  \n  \n  borderSmoothStep = smoothstep(\n      v_viewportSize / 2.0 + v_viewportBorderSize / 2.0 - v_viewportFeatherSize / 2.0,\n      v_viewportSize / 2.0 + v_viewportBorderSize / 2.0 + v_viewportFeatherSize / 2.0,\n      viewportDistance\n  );\n  color = ((1.0 - borderSmoothStep) * color) + (borderSmoothStep * vec4(0, 0, 0, 0));\n}";

// node_modules/@allmaps/render/dist/shaders/points/vertex-shader.glsl.js
var vertex_shader_default3 = "#version 300 es\n\nprecision highp float;\n\nfloat easing(float t) {\n  return t;\n\n  \n  \n}\n\nuniform mat4 u_renderHomogeneousTransform;\nuniform float u_animationProgress;\n\nin float a_viewportSize;\nin vec4 a_color;\nin float a_viewportBorderSize;\nin vec4 a_borderColor;\n\nin vec2 a_clipPoint;\nin vec2 a_clipPreviousPoint;\n\nout float v_viewportSize;\nout vec4 v_color;\nout float v_viewportBorderSize;\nout vec4 v_borderColor;\nout float v_viewportFeatherSize;\nout float v_viewportTotalSize;\n\nvoid main() {\n  vec2 clipPoint = mix(a_clipPreviousPoint, a_clipPoint, easing(u_animationProgress));\n\n  gl_Position = u_renderHomogeneousTransform * vec4(clipPoint, 0.0f, 1.0f);\n\n  v_viewportFeatherSize = 1.0;\n\n  v_viewportTotalSize = a_viewportSize + a_viewportBorderSize + v_viewportFeatherSize;\n  gl_PointSize = v_viewportTotalSize;\n  \n  \n  \n  \n  \n  \n  \n\n  v_viewportSize = a_viewportSize;\n  v_color = a_color;\n  v_viewportBorderSize = a_viewportBorderSize;\n  v_borderColor = a_borderColor;\n}";

// node_modules/@allmaps/render/dist/shaders/points/fragment-shader.glsl.js
var fragment_shader_default3 = "#version 300 es\n\nprecision highp float;\nprecision highp isampler2D;\n\nin float v_viewportSize;\nin vec4 v_color;\nin float v_viewportBorderSize;\nin vec4 v_borderColor;\nin float v_viewportFeatherSize;\nin float v_viewportTotalSize;\n\nout vec4 color;\n\nvoid main() {\n  \n  float distance = length(2.0 * gl_PointCoord - 1.0);\n  if (distance > 1.0) {\n    discard;\n  }\n  float viewportDistance = distance * v_viewportTotalSize / 2.0;\n\n  \n  color = vec4(0, 0, 0, 0);\n  if (v_viewportSize >= v_viewportFeatherSize) {\n    color = v_color;\n  }\n\n  \n  \n  \n  float borderSmoothStep;\n  if(v_viewportBorderSize >= v_viewportFeatherSize) {\n    borderSmoothStep = smoothstep(\n      v_viewportSize / 2.0 - v_viewportBorderSize / 2.0 - v_viewportFeatherSize / 2.0,\n      v_viewportSize / 2.0 - v_viewportBorderSize / 2.0 + v_viewportFeatherSize / 2.0,\n      viewportDistance\n    );\n    color = ((1.0 - borderSmoothStep) * color) + (borderSmoothStep * v_borderColor);\n  }\n\n  \n  \n  \n  borderSmoothStep = smoothstep(\n      v_viewportSize / 2.0 + v_viewportBorderSize / 2.0 - v_viewportFeatherSize / 2.0,\n      v_viewportSize / 2.0 + v_viewportBorderSize / 2.0 + v_viewportFeatherSize / 2.0,\n      viewportDistance\n  );\n  color = ((1.0 - borderSmoothStep) * color) + (borderSmoothStep * vec4(0, 0, 0, 0));\n}";

// node_modules/@allmaps/render/dist/workers/fetch-and-get-image-data.js
var encodedJs = "LyoqCiAqIEBsaWNlbnNlCiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAKICovCmNvbnN0IHByb3h5TWFya2VyID0gU3ltYm9sKCJDb21saW5rLnByb3h5Iik7CmNvbnN0IGNyZWF0ZUVuZHBvaW50ID0gU3ltYm9sKCJDb21saW5rLmVuZHBvaW50Iik7CmNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbCgiQ29tbGluay5yZWxlYXNlUHJveHkiKTsKY29uc3QgZmluYWxpemVyID0gU3ltYm9sKCJDb21saW5rLmZpbmFsaXplciIpOwpjb25zdCB0aHJvd01hcmtlciA9IFN5bWJvbCgiQ29tbGluay50aHJvd24iKTsKY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAib2JqZWN0IiAmJiB2YWwgIT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gImZ1bmN0aW9uIjsKY29uc3QgcHJveHlUcmFuc2ZlckhhbmRsZXIgPSB7CiAgY2FuSGFuZGxlOiAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIHZhbFtwcm94eU1hcmtlcl0sCiAgc2VyaWFsaXplKG9iaikgewogICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpOwogICAgZXhwb3NlKG9iaiwgcG9ydDEpOwogICAgcmV0dXJuIFtwb3J0MiwgW3BvcnQyXV07CiAgfSwKICBkZXNlcmlhbGl6ZShwb3J0KSB7CiAgICBwb3J0LnN0YXJ0KCk7CiAgICByZXR1cm4gd3JhcChwb3J0KTsKICB9Cn07CmNvbnN0IHRocm93VHJhbnNmZXJIYW5kbGVyID0gewogIGNhbkhhbmRsZTogKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgdGhyb3dNYXJrZXIgaW4gdmFsdWUsCiAgc2VyaWFsaXplKHsgdmFsdWUgfSkgewogICAgbGV0IHNlcmlhbGl6ZWQ7CiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikgewogICAgICBzZXJpYWxpemVkID0gewogICAgICAgIGlzRXJyb3I6IHRydWUsCiAgICAgICAgdmFsdWU6IHsKICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsCiAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lLAogICAgICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrCiAgICAgICAgfQogICAgICB9OwogICAgfSBlbHNlIHsKICAgICAgc2VyaWFsaXplZCA9IHsgaXNFcnJvcjogZmFsc2UsIHZhbHVlIH07CiAgICB9CiAgICByZXR1cm4gW3NlcmlhbGl6ZWQsIFtdXTsKICB9LAogIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHsKICAgIGlmIChzZXJpYWxpemVkLmlzRXJyb3IpIHsKICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3Ioc2VyaWFsaXplZC52YWx1ZS5tZXNzYWdlKSwgc2VyaWFsaXplZC52YWx1ZSk7CiAgICB9CiAgICB0aHJvdyBzZXJpYWxpemVkLnZhbHVlOwogIH0KfTsKY29uc3QgdHJhbnNmZXJIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFsKICBbInByb3h5IiwgcHJveHlUcmFuc2ZlckhhbmRsZXJdLAogIFsidGhyb3ciLCB0aHJvd1RyYW5zZmVySGFuZGxlcl0KXSk7CmZ1bmN0aW9uIGlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgb3JpZ2luKSB7CiAgZm9yIChjb25zdCBhbGxvd2VkT3JpZ2luIG9mIGFsbG93ZWRPcmlnaW5zKSB7CiAgICBpZiAob3JpZ2luID09PSBhbGxvd2VkT3JpZ2luIHx8IGFsbG93ZWRPcmlnaW4gPT09ICIqIikgewogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIGlmIChhbGxvd2VkT3JpZ2luIGluc3RhbmNlb2YgUmVnRXhwICYmIGFsbG93ZWRPcmlnaW4udGVzdChvcmlnaW4pKSB7CiAgICAgIHJldHVybiB0cnVlOwogICAgfQogIH0KICByZXR1cm4gZmFsc2U7Cn0KZnVuY3Rpb24gZXhwb3NlKG9iaiwgZXAgPSBnbG9iYWxUaGlzLCBhbGxvd2VkT3JpZ2lucyA9IFsiKiJdKSB7CiAgZXAuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGZ1bmN0aW9uIGNhbGxiYWNrKGV2KSB7CiAgICBpZiAoIWV2IHx8ICFldi5kYXRhKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICghaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBldi5vcmlnaW4pKSB7CiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBvcmlnaW4gJyR7ZXYub3JpZ2lufScgZm9yIGNvbWxpbmsgcHJveHlgKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgeyBpZCwgdHlwZSwgcGF0aCB9ID0gT2JqZWN0LmFzc2lnbih7IHBhdGg6IFtdIH0sIGV2LmRhdGEpOwogICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7CiAgICBsZXQgcmV0dXJuVmFsdWU7CiAgICB0cnkgewogICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iajIsIHByb3ApID0+IG9iajJbcHJvcF0sIG9iaik7CiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcGF0aC5yZWR1Y2UoKG9iajIsIHByb3ApID0+IG9iajJbcHJvcF0sIG9iaik7CiAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgIGNhc2UgIkdFVCI6CiAgICAgICAgICB7CiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJTRVQiOgogICAgICAgICAgewogICAgICAgICAgICBwYXJlbnRbcGF0aC5zbGljZSgtMSlbMF1dID0gZnJvbVdpcmVWYWx1ZShldi5kYXRhLnZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiQVBQTFkiOgogICAgICAgICAgewogICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlLmFwcGx5KHBhcmVudCwgYXJndW1lbnRMaXN0KTsKICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgIkNPTlNUUlVDVCI6CiAgICAgICAgICB7CiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7CiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcHJveHkodmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiRU5EUE9JTlQiOgogICAgICAgICAgewogICAgICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7CiAgICAgICAgICAgIGV4cG9zZShvYmosIHBvcnQyKTsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cmFuc2Zlcihwb3J0MSwgW3BvcnQxXSk7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJSRUxFQVNFIjoKICAgICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICB9IGNhdGNoICh2YWx1ZSkgewogICAgICByZXR1cm5WYWx1ZSA9IHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTsKICAgIH0KICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkuY2F0Y2goKHZhbHVlKSA9PiB7CiAgICAgIHJldHVybiB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07CiAgICB9KS50aGVuKChyZXR1cm5WYWx1ZTIpID0+IHsKICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyZXR1cm5WYWx1ZTIpOwogICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpOwogICAgICBpZiAodHlwZSA9PT0gIlJFTEVBU0UiKSB7CiAgICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGNhbGxiYWNrKTsKICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTsKICAgICAgICBpZiAoZmluYWxpemVyIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpbmFsaXplcl0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIG9ialtmaW5hbGl6ZXJdKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsKICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZSh7CiAgICAgICAgdmFsdWU6IG5ldyBUeXBlRXJyb3IoIlVuc2VyaWFsaXphYmxlIHJldHVybiB2YWx1ZSIpLAogICAgICAgIFt0aHJvd01hcmtlcl06IDAKICAgICAgfSk7CiAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7CiAgICB9KTsKICB9KTsKICBpZiAoZXAuc3RhcnQpIHsKICAgIGVwLnN0YXJ0KCk7CiAgfQp9CmZ1bmN0aW9uIGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpIHsKICByZXR1cm4gZW5kcG9pbnQuY29uc3RydWN0b3IubmFtZSA9PT0gIk1lc3NhZ2VQb3J0IjsKfQpmdW5jdGlvbiBjbG9zZUVuZFBvaW50KGVuZHBvaW50KSB7CiAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKQogICAgZW5kcG9pbnQuY2xvc2UoKTsKfQpmdW5jdGlvbiB3cmFwKGVwLCB0YXJnZXQpIHsKICBjb25zdCBwZW5kaW5nTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBlcC5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldikgewogICAgY29uc3QgeyBkYXRhIH0gPSBldjsKICAgIGlmICghZGF0YSB8fCAhZGF0YS5pZCkgewogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCByZXNvbHZlciA9IHBlbmRpbmdMaXN0ZW5lcnMuZ2V0KGRhdGEuaWQpOwogICAgaWYgKCFyZXNvbHZlcikgewogICAgICByZXR1cm47CiAgICB9CiAgICB0cnkgewogICAgICByZXNvbHZlcihkYXRhKTsKICAgIH0gZmluYWxseSB7CiAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuZGVsZXRlKGRhdGEuaWQpOwogICAgfQogIH0pOwogIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgW10sIHRhcmdldCk7Cn0KZnVuY3Rpb24gdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNSZWxlYXNlZCkgewogIGlmIChpc1JlbGVhc2VkKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZSIpOwogIH0KfQpmdW5jdGlvbiByZWxlYXNlRW5kcG9pbnQoZXApIHsKICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgewogICAgdHlwZTogIlJFTEVBU0UiCiAgfSkudGhlbigoKSA9PiB7CiAgICBjbG9zZUVuZFBvaW50KGVwKTsKICB9KTsKfQpjb25zdCBwcm94eUNvdW50ZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTsKY29uc3QgcHJveHlGaW5hbGl6ZXJzID0gIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiBpbiBnbG9iYWxUaGlzICYmIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoZXApID0+IHsKICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSAtIDE7CiAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpOwogIGlmIChuZXdDb3VudCA9PT0gMCkgewogICAgcmVsZWFzZUVuZHBvaW50KGVwKTsKICB9Cn0pOwpmdW5jdGlvbiByZWdpc3RlclByb3h5KHByb3h5MiwgZXApIHsKICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSArIDE7CiAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpOwogIGlmIChwcm94eUZpbmFsaXplcnMpIHsKICAgIHByb3h5RmluYWxpemVycy5yZWdpc3Rlcihwcm94eTIsIGVwLCBwcm94eTIpOwogIH0KfQpmdW5jdGlvbiB1bnJlZ2lzdGVyUHJveHkocHJveHkyKSB7CiAgaWYgKHByb3h5RmluYWxpemVycykgewogICAgcHJveHlGaW5hbGl6ZXJzLnVucmVnaXN0ZXIocHJveHkyKTsKICB9Cn0KZnVuY3Rpb24gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHBhdGggPSBbXSwgdGFyZ2V0ID0gZnVuY3Rpb24oKSB7Cn0pIHsKICBsZXQgaXNQcm94eVJlbGVhc2VkID0gZmFsc2U7CiAgY29uc3QgcHJveHkyID0gbmV3IFByb3h5KHRhcmdldCwgewogICAgZ2V0KF90YXJnZXQsIHByb3ApIHsKICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTsKICAgICAgaWYgKHByb3AgPT09IHJlbGVhc2VQcm94eSkgewogICAgICAgIHJldHVybiAoKSA9PiB7CiAgICAgICAgICB1bnJlZ2lzdGVyUHJveHkocHJveHkyKTsKICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7CiAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmNsZWFyKCk7CiAgICAgICAgICBpc1Byb3h5UmVsZWFzZWQgPSB0cnVlOwogICAgICAgIH07CiAgICAgIH0KICAgICAgaWYgKHByb3AgPT09ICJ0aGVuIikgewogICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gcHJveHkyIH07CiAgICAgICAgfQogICAgICAgIGNvbnN0IHIgPSByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgICB0eXBlOiAiR0VUIiwKICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpCiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgICAgICByZXR1cm4gci50aGVuLmJpbmQocik7CiAgICAgIH0KICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBbLi4ucGF0aCwgcHJvcF0pOwogICAgfSwKICAgIHNldChfdGFyZ2V0LCBwcm9wLCByYXdWYWx1ZSkgewogICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpOwogICAgICBjb25zdCBbdmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmF3VmFsdWUpOwogICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgewogICAgICAgIHR5cGU6ICJTRVQiLAogICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksCiAgICAgICAgdmFsdWUKICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgIH0sCiAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgcmF3QXJndW1lbnRMaXN0KSB7CiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7CiAgICAgIGNvbnN0IGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07CiAgICAgIGlmIChsYXN0ID09PSBjcmVhdGVFbmRwb2ludCkgewogICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgICB0eXBlOiAiRU5EUE9JTlQiCiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgICAgfQogICAgICBpZiAobGFzdCA9PT0gImJpbmQiKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBwYXRoLnNsaWNlKDAsIC0xKSk7CiAgICAgIH0KICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7CiAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgdHlwZTogIkFQUExZIiwKICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSwKICAgICAgICBhcmd1bWVudExpc3QKICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgIH0sCiAgICBjb25zdHJ1Y3QoX3RhcmdldCwgcmF3QXJndW1lbnRMaXN0KSB7CiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7CiAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpOwogICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgewogICAgICAgIHR5cGU6ICJDT05TVFJVQ1QiLAogICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLAogICAgICAgIGFyZ3VtZW50TGlzdAogICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpOwogICAgfQogIH0pOwogIHJlZ2lzdGVyUHJveHkocHJveHkyLCBlcCk7CiAgcmV0dXJuIHByb3h5MjsKfQpmdW5jdGlvbiBteUZsYXQoYXJyKSB7CiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7Cn0KZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3QpIHsKICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTsKICByZXR1cm4gW3Byb2Nlc3NlZC5tYXAoKHYpID0+IHZbMF0pLCBteUZsYXQocHJvY2Vzc2VkLm1hcCgodikgPT4gdlsxXSkpXTsKfQpjb25zdCB0cmFuc2ZlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7CmZ1bmN0aW9uIHRyYW5zZmVyKG9iaiwgdHJhbnNmZXJzKSB7CiAgdHJhbnNmZXJDYWNoZS5zZXQob2JqLCB0cmFuc2ZlcnMpOwogIHJldHVybiBvYmo7Cn0KZnVuY3Rpb24gcHJveHkob2JqKSB7CiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCB7IFtwcm94eU1hcmtlcl06IHRydWUgfSk7Cn0KZnVuY3Rpb24gdG9XaXJlVmFsdWUodmFsdWUpIHsKICBmb3IgKGNvbnN0IFtuYW1lLCBoYW5kbGVyXSBvZiB0cmFuc2ZlckhhbmRsZXJzKSB7CiAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodmFsdWUpKSB7CiAgICAgIGNvbnN0IFtzZXJpYWxpemVkVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gaGFuZGxlci5zZXJpYWxpemUodmFsdWUpOwogICAgICByZXR1cm4gWwogICAgICAgIHsKICAgICAgICAgIHR5cGU6ICJIQU5ETEVSIiwKICAgICAgICAgIG5hbWUsCiAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFZhbHVlCiAgICAgICAgfSwKICAgICAgICB0cmFuc2ZlcmFibGVzCiAgICAgIF07CiAgICB9CiAgfQogIHJldHVybiBbCiAgICB7CiAgICAgIHR5cGU6ICJSQVciLAogICAgICB2YWx1ZQogICAgfSwKICAgIHRyYW5zZmVyQ2FjaGUuZ2V0KHZhbHVlKSB8fCBbXQogIF07Cn0KZnVuY3Rpb24gZnJvbVdpcmVWYWx1ZSh2YWx1ZSkgewogIHN3aXRjaCAodmFsdWUudHlwZSkgewogICAgY2FzZSAiSEFORExFUiI6CiAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7CiAgICBjYXNlICJSQVciOgogICAgICByZXR1cm4gdmFsdWUudmFsdWU7CiAgfQp9CmZ1bmN0aW9uIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIG1zZywgdHJhbnNmZXJzKSB7CiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpOwogICAgcGVuZGluZ0xpc3RlbmVycy5zZXQoaWQsIHJlc29sdmUpOwogICAgaWYgKGVwLnN0YXJ0KSB7CiAgICAgIGVwLnN0YXJ0KCk7CiAgICB9CiAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKHsgaWQgfSwgbXNnKSwgdHJhbnNmZXJzKTsKICB9KTsKfQpmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7CiAgcmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKDApLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikudG9TdHJpbmcoMTYpKS5qb2luKCItIik7Cn0KYXN5bmMgZnVuY3Rpb24gZmV0Y2hVcmwoaW5wdXQsIGluaXQsIGZldGNoRm4pIHsKICBsZXQgcmVzcG9uc2U7CiAgaWYgKHR5cGVvZiBmZXRjaEZuID09PSAiZnVuY3Rpb24iKSB7CiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoRm4oaW5wdXQsIGluaXQpOwogIH0gZWxzZSB7CiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKGlucHV0LCBpbml0KTsKICB9CiAgaWYgKCFyZXNwb25zZS5vaykgewogICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTsKICAgIGlmIChqc29uICYmIGpzb24uZXJyb3IpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKGpzb24uZXJyb3IpOwogICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNUZXh0KSB7CiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTsKICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgZm91bmQ6ICR7aW5wdXR9ICg0MDQpYCk7CiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAwKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiSW50ZXJuYWwgc2VydmVyIGVycm9yICg1MDApIik7CiAgICB9IGVsc2UgewogICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaDogJHtpbnB1dH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSlgKTsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3BvbnNlOwp9CmNvbnN0IGZldGNoQW5kR2V0SW1hZ2VEYXRhV29ya2VyID0gewogIGFzeW5jIGdldEltYWdlRGF0YSh0aWxlVXJsLCBvbkFib3J0LCBmZXRjaEZuLCB3aWR0aCwgaGVpZ2h0KSB7CiAgICBjb25zdCB3b3JrZXJBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7CiAgICBvbkFib3J0KCk7CiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoVXJsKAogICAgICB0aWxlVXJsLAogICAgICB7CiAgICAgICAgc2lnbmFsOiB3b3JrZXJBYm9ydENvbnRyb2xsZXIuc2lnbmFsCiAgICAgIH0sCiAgICAgIGZldGNoRm4KICAgICk7CiAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpOwogICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7CiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICBpZiAoIWNvbnRleHQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJDb3VsZCBub3QgY3JlYXRlIE9mZnNjcmVlbkNhbnZhcyBjb250ZXh0Iik7CiAgICB9CiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZUJpdG1hcCwgMCwgMCk7CiAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgIHJldHVybiB0cmFuc2ZlcihpbWFnZURhdGEsIFtpbWFnZURhdGEuZGF0YS5idWZmZXJdKTsKICB9Cn07CmV4cG9zZShmZXRjaEFuZEdldEltYWdlRGF0YVdvcmtlcik7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLWFuZC1nZXQtaW1hZ2UtZGF0YS1CQzRZc0lHNy5qcy5tYXAK";
var decodeBase64 = (base64) => Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
var blob = typeof self !== "undefined" && self.Blob && new Blob(["URL.revokeObjectURL(import.meta.url);", decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(options) {
  let objURL;
  try {
    objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      type: "module",
      name: options?.name
    });
    worker.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e) {
    return new Worker(
      "data:text/javascript;base64," + encodedJs,
      {
        type: "module",
        name: options?.name
      }
    );
  }
}

// node_modules/@allmaps/render/dist/renderers/WebGL2Renderer.js
var THROTTLE_PREPARE_RENDER_WAIT_MS = 200;
var THROTTLE_PREPARE_RENDER_OPTIONS = {
  leading: true,
  trailing: true
};
var THROTTLE_CHANGED_WAIT_MS = 50;
var THROTTLE_CHANGED_OPTIONS = {
  leading: true,
  trailing: true
};
var defaultWebgl2RendererOptions = {
  debugMaps: false,
  renderMaps: true,
  renderLines: true,
  renderPoints: true
};
var DEFAULT_OPACITY2 = 1;
var DEFAULT_SATURATION2 = 1;
var DEFAULT_REMOVE_COLOR_THRESHOLD = 0;
var DEFAULT_REMOVE_COLOR_HARDNESS = 0.7;
var SIGNIFICANT_VIEWPORT_EPSILON = 100 * Number.EPSILON;
var SIGNIFICANT_VIEWPORT_DISTANCE = 5;
var ANIMATION_DURATION = 750;
var WebGL2Renderer = class extends BaseRenderer {
  #worker;
  gl;
  partialWebgl2RendererOptions;
  mapProgram;
  linesProgram;
  pointsProgram;
  previousSignificantViewport;
  opacity = DEFAULT_OPACITY2;
  saturation = DEFAULT_SATURATION2;
  renderOptions = {};
  lastAnimationFrameRequestId;
  animating = false;
  transformaterTransitionStart;
  animationProgress = 0;
  disableRender = false;
  throttledPrepareRenderInternal;
  throttledChanged;
  /**
   * Creates an instance of WebGL2Renderer.
   *
   * @constructor
   * @param gl - WebGL 2 rendering context
   * @param options - options
   */
  constructor(gl, options) {
    const mapVertexShader = createShader(
      gl,
      gl.VERTEX_SHADER,
      vertex_shader_default
    );
    const mapFragmentShader = createShader(
      gl,
      gl.FRAGMENT_SHADER,
      fragment_shader_default
    );
    const linesVertexShader = createShader(
      gl,
      gl.VERTEX_SHADER,
      vertex_shader_default2
    );
    const linesFragmentShader = createShader(
      gl,
      gl.FRAGMENT_SHADER,
      fragment_shader_default2
    );
    const pointsVertexShader = createShader(
      gl,
      gl.VERTEX_SHADER,
      vertex_shader_default3
    );
    const pointsFragmentShader = createShader(
      gl,
      gl.FRAGMENT_SHADER,
      fragment_shader_default3
    );
    const mapProgram = createProgram(gl, mapVertexShader, mapFragmentShader);
    const linesProgram = createProgram(
      gl,
      linesVertexShader,
      linesFragmentShader
    );
    const pointsProgram = createProgram(
      gl,
      pointsVertexShader,
      pointsFragmentShader
    );
    const worker = new WorkerWrapper();
    const wrappedWorker = wrap2(worker);
    super(
      CacheableWorkerImageDataTile.createFactory(wrappedWorker),
      createWebGL2WarpedMapFactory(gl, mapProgram, linesProgram, pointsProgram),
      options
    );
    this.#worker = worker;
    this.gl = gl;
    this.partialWebgl2RendererOptions = mergeOptions(
      defaultWebgl2RendererOptions,
      options
    );
    this.mapProgram = mapProgram;
    this.linesProgram = linesProgram;
    this.pointsProgram = pointsProgram;
    gl.deleteShader(mapVertexShader);
    gl.deleteShader(mapFragmentShader);
    gl.deleteShader(mapVertexShader);
    gl.deleteShader(mapFragmentShader);
    gl.deleteShader(mapVertexShader);
    gl.deleteShader(mapFragmentShader);
    gl.disable(gl.DEPTH_TEST);
    this.addEventListeners();
    this.throttledPrepareRenderInternal = throttle_default(
      this.prepareRenderInternal.bind(this),
      THROTTLE_PREPARE_RENDER_WAIT_MS,
      THROTTLE_PREPARE_RENDER_OPTIONS
    );
    this.throttledChanged = throttle_default(
      this.changed.bind(this),
      THROTTLE_CHANGED_WAIT_MS,
      THROTTLE_CHANGED_OPTIONS
    );
  }
  initializeWebGL(gl) {
    const mapVertexShader = createShader(
      gl,
      gl.VERTEX_SHADER,
      vertex_shader_default
    );
    const mapFragmentShader = createShader(
      gl,
      gl.FRAGMENT_SHADER,
      fragment_shader_default
    );
    const linesVertexShader = createShader(
      gl,
      gl.VERTEX_SHADER,
      vertex_shader_default2
    );
    const linesFragmentShader = createShader(
      gl,
      gl.FRAGMENT_SHADER,
      fragment_shader_default2
    );
    const pointsVertexShader = createShader(
      gl,
      gl.VERTEX_SHADER,
      vertex_shader_default3
    );
    const pointsFragmentShader = createShader(
      gl,
      gl.FRAGMENT_SHADER,
      fragment_shader_default3
    );
    const mapProgram = createProgram(gl, mapVertexShader, mapFragmentShader);
    const linesProgram = createProgram(
      gl,
      linesVertexShader,
      linesFragmentShader
    );
    const pointsProgram = createProgram(
      gl,
      pointsVertexShader,
      pointsFragmentShader
    );
    this.gl = gl;
    this.mapProgram = mapProgram;
    this.linesProgram = linesProgram;
    this.pointsProgram = pointsProgram;
    gl.disable(gl.DEPTH_TEST);
    for (const webgl2WarpedMap of this.warpedMapList.getWarpedMaps()) {
      webgl2WarpedMap.initializeWebGL(mapProgram, linesProgram, pointsProgram);
    }
  }
  /**
   * Get the opacity of the renderer
   *
   * @returns
   */
  getOpacity() {
    return this.opacity;
  }
  /**
   * Set the opacity of the renderer
   *
   * @param opacity - opacity to set
   */
  setOpacity(opacity) {
    this.opacity = opacity;
  }
  /**
   * Reset the opacity of the renderer
   */
  resetOpacity() {
    this.opacity = DEFAULT_OPACITY2;
  }
  /**
   * Get the opacity of a map
   *
   * @param mapId - ID of the map
   * @returns
   */
  getMapOpacity(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      return webgl2WarpedMap.opacity;
    }
  }
  /**
   * Set the opacity of a map
   *
   * @param mapId - ID of the map
   * @param opacity - opacity to set
   */
  setMapOpacity(mapId, opacity) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.opacity = Math.min(Math.max(opacity, 0), 1);
    }
  }
  /**
   * Rreset the opacity of a map
   *
   * @param mapId - ID of the map
   */
  resetMapOpacity(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.opacity = DEFAULT_OPACITY2;
    }
  }
  /**
   * Get the remove color options of the renderer
   *
   * @returns
   */
  getRemoveColorOptions() {
    return this.renderOptions.removeColorOptions;
  }
  /**
   * Set the remove color options of the renderer
   *
   * @param removeColorOptions
   */
  setRemoveColorOptions(removeColorOptions) {
    this.renderOptions.removeColorOptions = removeColorOptions;
  }
  /**
   * Reset the remove color options of the renderer
   */
  resetRemoveColorOptions() {
    this.renderOptions.removeColorOptions = void 0;
  }
  /**
   * Get the remove color options of a map
   *
   * @param mapId - ID of the map
   * @returns
   */
  getMapRemoveColorOptions(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      return webgl2WarpedMap.renderOptions.removeColorOptions;
    }
  }
  /**
   * Set the WebGL2 Renderer options
   *
   * @param partialWebgl2RendererOptions - Options
   */
  setOptions(partialWebgl2RendererOptions) {
    this.partialWebgl2RendererOptions = mergeOptions(
      this.partialWebgl2RendererOptions,
      partialWebgl2RendererOptions
    );
    super.setOptions(partialWebgl2RendererOptions);
  }
  /**
   * Set the remove color options of a map
   *
   * @param mapId - ID of the map
   * @param removeColorOptions - the 'remove color options' to set
   */
  setMapRemoveColorOptions(mapId, removeColorOptions) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.renderOptions.removeColorOptions = removeColorOptions;
    }
  }
  /**
   * Reset the remove color options of a map
   *
   * @param mapId - ID of the map
   */
  resetMapRemoveColorOptions(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.renderOptions.removeColorOptions = void 0;
    }
  }
  /**
   * Get the colorize options of the renderer
   *
   * @returns
   */
  getColorizeOptions() {
    return this.renderOptions.colorizeOptions;
  }
  /**
   * Set the colorize options of the renderer
   *
   * @param colorizeOptions - the colorize options to set
   */
  setColorizeOptions(colorizeOptions) {
    this.renderOptions.colorizeOptions = colorizeOptions;
  }
  /**
   * Reset the colorize options of the renderer
   */
  resetColorizeOptions() {
    this.renderOptions.colorizeOptions = void 0;
  }
  /**
   * Get the colorize options of a map
   *
   * @param mapId - ID of the map
   * @returns Colorize options
   */
  getMapColorizeOptions(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      return webgl2WarpedMap.renderOptions.colorizeOptions;
    }
  }
  /**
   * Set the colorize options of a map
   *
   * @param mapId - ID of the map
   * @param colorizeOptions - the colorize options to set
   */
  setMapColorizeOptions(mapId, colorizeOptions) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.renderOptions.colorizeOptions = colorizeOptions;
    }
  }
  /**
   * Reset the colorize options of a map
   *
   * @param mapId - ID of the map
   */
  resetMapColorizeOptions(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.renderOptions.colorizeOptions = void 0;
    }
  }
  /**
   * Get the grid options of the renderer
   *
   * @returns
   */
  getGridOptions() {
    return this.renderOptions.gridOptions;
  }
  /**
   * Set the grid options of the renderer
   *
   * @param gridOptions - the grid options to set
   */
  setGridOptions(gridOptions) {
    this.renderOptions.gridOptions = gridOptions;
  }
  /**
   * Reset the grid options of the renderer
   */
  resetGridOptions() {
    this.renderOptions.gridOptions = void 0;
  }
  /**
   * Get the grid options of a map
   *
   * @param mapId - ID of the map
   * @returns
   */
  getMapGridOptions(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      return webgl2WarpedMap.renderOptions.gridOptions;
    }
  }
  /**
   * Set the grid options of a map
   *
   * @param mapId - ID of the map
   * @param gridOptions - the grid options to set
   */
  setMapGridOptions(mapId, gridOptions) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.renderOptions.gridOptions = gridOptions;
    }
  }
  /**
   * Reset the grid options of a map
   *
   * @param mapId - ID of the map
   */
  resetMapGridOptions(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.renderOptions.gridOptions = void 0;
    }
  }
  /**
   * Get the saturation of the renderer
   *
   * @returns
   */
  getSaturation() {
    return this.saturation;
  }
  /**
   * Set the saturation of the renderer
   *
   * 0 - grayscale, 1 - original colors
   *
   * @param saturation - the satuation to set
   */
  setSaturation(saturation) {
    this.saturation = saturation;
  }
  /**
   * Reset the satuation of the renderer
   */
  resetSaturation() {
    this.saturation = DEFAULT_SATURATION2;
  }
  /**
   * Get the saturation of a map
   *
   * @param mapId - ID of the map
   * @returns
   */
  getMapSaturation(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      return webgl2WarpedMap.saturation;
    }
  }
  /**
   * Set the saturation of a map
   *
   * 0 - grayscale, 1 - original colors
   *
   * @param mapId - ID of the map
   * @param saturation - the saturation to set
   */
  setMapSaturation(mapId, saturation) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.saturation = saturation;
    }
  }
  /**
   * Reset the saturation of a map
   *
   * @param mapId - ID of the map
   */
  resetMapSaturation(mapId) {
    const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webgl2WarpedMap) {
      webgl2WarpedMap.saturation = DEFAULT_SATURATION2;
    }
  }
  /**
   * Render the map for a given viewport.
   *
   * If no viewport is specified the current viewport is rerendered.
   * If no current viewport is known, a viewport is deduced based on the WarpedMapList and canvas width and hight.
   *
   * @param viewport - the current viewport
   */
  render(viewport) {
    if (this.disableRender) {
      return;
    }
    this.viewport = viewport || this.viewport || Viewport.fromSizeAndMaps(
      [this.gl.canvas.width, this.gl.canvas.width],
      this.warpedMapList
    );
    this.loadMissingImageInfosInViewport();
    if (this.someImageInfosInViewport()) {
      this.throttledPrepareRenderInternal();
    }
    this.renderInternal();
  }
  clear() {
    this.warpedMapList.clear();
    this.mapsInViewport = /* @__PURE__ */ new Set();
    this.mapsWithRequestedTilesForViewport = /* @__PURE__ */ new Set();
    this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT);
    this.tileCache.clear();
  }
  cancelThrottledFunctions() {
    this.throttledPrepareRenderInternal.cancel();
    this.throttledChanged.cancel();
  }
  destroy() {
    this.cancelThrottledFunctions();
    for (const webgl2WarpedMap of this.warpedMapList.getWarpedMaps()) {
      this.removeEventListenersFromWebGL2WarpedMap(webgl2WarpedMap);
    }
    this.removeEventListeners();
    super.destroy();
    this.gl.deleteProgram(this.mapProgram);
    this.gl.deleteProgram(this.linesProgram);
    this.gl.deleteProgram(this.pointsProgram);
    this.#worker.terminate();
  }
  updateMapsForViewport(tiles) {
    const { mapsEnteringViewport, mapsLeavingViewport } = super.updateMapsForViewport(tiles);
    this.updateVertexBuffers(mapsEnteringViewport);
    return { mapsEnteringViewport, mapsLeavingViewport };
  }
  resetPrevious(mapIds) {
    const webgl2WarpedMaps = this.warpedMapList.getWarpedMaps({ mapIds });
    for (const webgl2WarpedMap of webgl2WarpedMaps) {
      webgl2WarpedMap.resetPrevious();
    }
  }
  updateVertexBuffers(mapIds) {
    if (!this.viewport) {
      return;
    }
    const webgl2WarpedMaps = this.warpedMapList.getWarpedMaps({ mapIds });
    for (const webgl2WarpedMap of webgl2WarpedMaps) {
      webgl2WarpedMap.updateVertexBuffers(
        this.viewport.projectedGeoToClipHomogeneousTransform,
        this.partialWebgl2RendererOptions
      );
    }
  }
  prepareRenderInternal() {
    this.assureProjection();
    this.requestFetchableTiles();
  }
  shouldRequestFetchableTiles() {
    if (!this.viewport) {
      return false;
    }
    if (this.animating) {
      return false;
    }
    if (!this.previousSignificantViewport) {
      this.previousSignificantViewport = this.viewport;
      return true;
    } else {
      const rectangleSquaredDistances = [];
      for (let i = 0; i < 4; i++) {
        rectangleSquaredDistances.push(
          squaredDistance(
            this.previousSignificantViewport.projectedGeoRectangle[i],
            this.viewport.projectedGeoRectangle[i]
          ) / Math.pow(this.viewport.projectedGeoPerViewportScale, 2)
        );
      }
      const maxSquaredDistance = Math.max(...rectangleSquaredDistances);
      if (maxSquaredDistance < SIGNIFICANT_VIEWPORT_EPSILON) {
        return true;
      }
      if (maxSquaredDistance > Math.pow(SIGNIFICANT_VIEWPORT_DISTANCE, 2)) {
        this.previousSignificantViewport = this.viewport;
        return true;
      } else {
        return false;
      }
    }
  }
  shouldAnticipateInteraction() {
    return true;
  }
  renderInternal() {
    if (!this.viewport) {
      return;
    }
    const gl = this.gl;
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    if (this.partialWebgl2RendererOptions.renderMaps) {
      this.renderMapsInternal();
    }
    if (this.partialWebgl2RendererOptions.renderLines) {
      this.renderLinesInternal();
    }
    if (this.partialWebgl2RendererOptions.renderPoints) {
      this.renderPointsInternal();
    }
  }
  renderMapsInternal() {
    if (!this.viewport) {
      return;
    }
    this.setMapProgramUniforms();
    for (const mapId of this.mapsWithRequestedTilesForViewport) {
      const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
      if (!webgl2WarpedMap) {
        continue;
      }
      this.setMapProgramRenderOptionsUniforms(
        this.renderOptions,
        webgl2WarpedMap.renderOptions
      );
      this.setMapProgramMapUniforms(webgl2WarpedMap);
      const count = webgl2WarpedMap.resourceTrianglePoints.length;
      const primitiveType = this.gl.TRIANGLES;
      const offset2 = 0;
      this.gl.bindVertexArray(webgl2WarpedMap.mapVao);
      this.gl.drawArrays(primitiveType, offset2, count);
    }
  }
  renderLinesInternal() {
    this.setLinesProgramUniforms();
    for (const mapId of this.mapsInViewport) {
      const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
      if (!webgl2WarpedMap) {
        continue;
      }
      this.setLinesProgramMapUniforms(webgl2WarpedMap);
      const count = webgl2WarpedMap.lineLayers.reduce(
        (accumulator, lineLayer) => accumulator + lineLayer.projectedGeoLines.length,
        0
      ) * 6;
      const primitiveType = this.gl.TRIANGLES;
      const offset2 = 0;
      this.gl.bindVertexArray(webgl2WarpedMap.linesVao);
      this.gl.drawArrays(primitiveType, offset2, count);
    }
  }
  renderPointsInternal() {
    this.setPointsProgramUniforms();
    for (const mapId of this.mapsInViewport) {
      const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
      if (!webgl2WarpedMap) {
        continue;
      }
      this.setPointsProgramMapUniforms(webgl2WarpedMap);
      const count = webgl2WarpedMap.pointLayers.reduce(
        (accumulator, pointLayer) => accumulator + pointLayer.projectedGeoPoints.length,
        0
      );
      const primitiveType = this.gl.POINTS;
      const offset2 = 0;
      this.gl.bindVertexArray(webgl2WarpedMap.pointsVao);
      this.gl.drawArrays(primitiveType, offset2, count);
    }
  }
  setMapProgramUniforms() {
    const program = this.mapProgram;
    const gl = this.gl;
    gl.useProgram(program);
    const debugLocation = gl.getUniformLocation(program, "u_debug");
    gl.uniform1f(
      debugLocation,
      this.partialWebgl2RendererOptions.debugMaps ? 1 : 0
    );
    const animationProgressLocation = gl.getUniformLocation(
      program,
      "u_animationProgress"
    );
    gl.uniform1f(animationProgressLocation, this.animationProgress);
    const colorDistortion00 = gl.getUniformLocation(
      program,
      "u_colorDistortion00"
    );
    gl.uniform4f(colorDistortion00, ...hexToFractionalRgb(red), 1);
    const colorDistortion01 = gl.getUniformLocation(
      program,
      "u_colorDistortion01"
    );
    gl.uniform4f(colorDistortion01, ...hexToFractionalRgb(darkblue), 1);
    const colorDistortion1 = gl.getUniformLocation(
      program,
      "u_colorDistortion1"
    );
    gl.uniform4f(colorDistortion1, ...hexToFractionalRgb(green), 1);
    const colorDistortion2 = gl.getUniformLocation(
      program,
      "u_colorDistortion2"
    );
    gl.uniform4f(colorDistortion2, ...hexToFractionalRgb(yellow), 1);
    const colorDistortion3 = gl.getUniformLocation(
      program,
      "u_colorDistortion3"
    );
    gl.uniform4f(colorDistortion3, ...hexToFractionalRgb(red), 1);
    const colorGrid = gl.getUniformLocation(program, "u_colorGrid");
    gl.uniform4f(colorGrid, ...hexToFractionalRgb(black), 1);
  }
  setMapProgramRenderOptionsUniforms(layerRenderOptions, mapRenderOptions) {
    const gl = this.gl;
    const program = this.mapProgram;
    gl.useProgram(program);
    const renderOptions = {
      removeColorOptions: {
        color: mapRenderOptions.removeColorOptions?.color || layerRenderOptions.removeColorOptions?.color,
        hardness: maxOfNumberOrUndefined(
          mapRenderOptions.removeColorOptions?.hardness,
          layerRenderOptions.removeColorOptions?.hardness
        ),
        threshold: maxOfNumberOrUndefined(
          mapRenderOptions.removeColorOptions?.threshold,
          layerRenderOptions.removeColorOptions?.threshold
        )
      },
      colorizeOptions: {
        ...layerRenderOptions.colorizeOptions,
        ...mapRenderOptions.colorizeOptions
      },
      gridOptions: {
        ...layerRenderOptions.gridOptions,
        ...mapRenderOptions.gridOptions
      }
    };
    const removeColorOptionsColor = renderOptions.removeColorOptions?.color;
    const removeColorLocation = gl.getUniformLocation(program, "u_removeColor");
    gl.uniform1f(removeColorLocation, removeColorOptionsColor ? 1 : 0);
    if (removeColorOptionsColor) {
      const removeColorOptionsColorLocation = gl.getUniformLocation(
        program,
        "u_removeColorOptionsColor"
      );
      gl.uniform3fv(removeColorOptionsColorLocation, removeColorOptionsColor);
      const removeColorOptionsThresholdLocation = gl.getUniformLocation(
        program,
        "u_removeColorOptionsThreshold"
      );
      gl.uniform1f(
        removeColorOptionsThresholdLocation,
        renderOptions.removeColorOptions?.threshold || DEFAULT_REMOVE_COLOR_THRESHOLD
      );
      const removeColorOptionsHardnessLocation = gl.getUniformLocation(
        program,
        "u_removeColorOptionsHardness"
      );
      gl.uniform1f(
        removeColorOptionsHardnessLocation,
        renderOptions.removeColorOptions?.hardness || DEFAULT_REMOVE_COLOR_HARDNESS
      );
    }
    const colorizeOptionsColor = renderOptions.colorizeOptions?.color;
    const colorizeLocation = gl.getUniformLocation(program, "u_colorize");
    gl.uniform1f(colorizeLocation, colorizeOptionsColor ? 1 : 0);
    if (colorizeOptionsColor) {
      const colorizeOptionsColorLocation = gl.getUniformLocation(
        program,
        "u_colorizeOptionsColor"
      );
      gl.uniform3fv(colorizeOptionsColorLocation, colorizeOptionsColor);
    }
    const gridOptionsGrid = renderOptions.gridOptions?.enabled;
    const gridLocation = gl.getUniformLocation(program, "u_grid");
    gl.uniform1f(gridLocation, gridOptionsGrid ? 1 : 0);
  }
  setMapProgramMapUniforms(webgl2WarpedMap) {
    if (!this.viewport) {
      return;
    }
    const gl = this.gl;
    const program = this.mapProgram;
    gl.useProgram(program);
    const renderHomogeneousTransform = multiplyHomogeneousTransform(
      this.viewport.projectedGeoToClipHomogeneousTransform,
      webgl2WarpedMap.invertedRenderHomogeneousTransform
    );
    const renderHomogeneousTransformLocation = gl.getUniformLocation(
      program,
      "u_renderHomogeneousTransform"
    );
    gl.uniformMatrix4fv(
      renderHomogeneousTransformLocation,
      false,
      homogeneousTransformToMatrix4(renderHomogeneousTransform)
    );
    const opacityLocation = gl.getUniformLocation(program, "u_opacity");
    gl.uniform1f(opacityLocation, this.opacity * webgl2WarpedMap.opacity);
    const saturationLocation = gl.getUniformLocation(program, "u_saturation");
    gl.uniform1f(
      saturationLocation,
      this.saturation * webgl2WarpedMap.saturation
    );
    const distortionLocation = gl.getUniformLocation(program, "u_distortion");
    gl.uniform1f(distortionLocation, webgl2WarpedMap.distortionMeasure ? 1 : 0);
    const distortionOptionsDistortionMeasureLocation = gl.getUniformLocation(
      program,
      "u_distortionOptionsdistortionMeasure"
    );
    gl.uniform1i(
      distortionOptionsDistortionMeasureLocation,
      webgl2WarpedMap.distortionMeasure ? supportedDistortionMeasures.indexOf(webgl2WarpedMap.distortionMeasure) : 0
    );
    const scaleFactorForViewportLocation = gl.getUniformLocation(
      program,
      "u_scaleFactorForViewport"
    );
    const scaleFactorForViewport = webgl2WarpedMap.tileZoomLevelForViewport ? webgl2WarpedMap.tileZoomLevelForViewport.scaleFactor : 1;
    gl.uniform1i(scaleFactorForViewportLocation, scaleFactorForViewport);
    const cachedTilesTextureArrayLocation = gl.getUniformLocation(
      program,
      "u_cachedTilesTextureArray"
    );
    gl.uniform1i(cachedTilesTextureArrayLocation, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, webgl2WarpedMap.cachedTilesTextureArray);
    const cachedTilesResourceOriginPointsAndDimensionsLocation = gl.getUniformLocation(
      program,
      "u_cachedTilesResourceOriginPointsAndDimensionsTexture"
    );
    gl.uniform1i(cachedTilesResourceOriginPointsAndDimensionsLocation, 1);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(
      gl.TEXTURE_2D,
      webgl2WarpedMap.cachedTilesResourceOriginPointsAndDimensionsTexture
    );
    const cachedTileScaleFactorsTextureLocation = gl.getUniformLocation(
      program,
      "u_cachedTilesScaleFactorsTexture"
    );
    gl.uniform1i(cachedTileScaleFactorsTextureLocation, 2);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(
      gl.TEXTURE_2D,
      webgl2WarpedMap.cachedTilesScaleFactorsTexture
    );
  }
  setLinesProgramUniforms() {
    if (!this.viewport) {
      return;
    }
    const gl = this.gl;
    const program = this.linesProgram;
    gl.useProgram(program);
    const viewportToClipHomogeneousTransformLocation = gl.getUniformLocation(
      program,
      "u_viewportToClipHomogeneousTransform"
    );
    gl.uniformMatrix4fv(
      viewportToClipHomogeneousTransformLocation,
      false,
      homogeneousTransformToMatrix4(
        this.viewport.viewportToClipHomogeneousTransform
      )
    );
    const clipToViewportHomogeneousTransformLocation = gl.getUniformLocation(
      program,
      "u_clipToViewportHomogeneousTransform"
    );
    gl.uniformMatrix4fv(
      clipToViewportHomogeneousTransformLocation,
      false,
      homogeneousTransformToMatrix4(
        invertHomogeneousTransform(
          this.viewport.viewportToClipHomogeneousTransform
        )
      )
    );
    const animationProgressLocation = gl.getUniformLocation(
      program,
      "u_animationProgress"
    );
    gl.uniform1f(animationProgressLocation, this.animationProgress);
  }
  setLinesProgramMapUniforms(webgl2WarpedMap) {
    if (!this.viewport) {
      return;
    }
    const gl = this.gl;
    const program = this.linesProgram;
    gl.useProgram(program);
    const renderHomogeneousTransform = multiplyHomogeneousTransform(
      this.viewport.projectedGeoToClipHomogeneousTransform,
      webgl2WarpedMap.invertedRenderHomogeneousTransform
    );
    const renderHomogeneousTransformLocation = gl.getUniformLocation(
      program,
      "u_renderHomogeneousTransform"
    );
    gl.uniformMatrix4fv(
      renderHomogeneousTransformLocation,
      false,
      homogeneousTransformToMatrix4(renderHomogeneousTransform)
    );
  }
  setPointsProgramUniforms() {
    if (!this.viewport) {
      return;
    }
    const gl = this.gl;
    const program = this.pointsProgram;
    gl.useProgram(program);
    const animationProgressLocation = gl.getUniformLocation(
      program,
      "u_animationProgress"
    );
    gl.uniform1f(animationProgressLocation, this.animationProgress);
  }
  setPointsProgramMapUniforms(webgl2WarpedMap) {
    if (!this.viewport) {
      return;
    }
    const gl = this.gl;
    const program = this.pointsProgram;
    gl.useProgram(program);
    const renderHomogeneousTransform = multiplyHomogeneousTransform(
      this.viewport.projectedGeoToClipHomogeneousTransform,
      webgl2WarpedMap.invertedRenderHomogeneousTransform
    );
    const renderHomogeneousTransformLocation = gl.getUniformLocation(
      program,
      "u_renderHomogeneousTransform"
    );
    gl.uniformMatrix4fv(
      renderHomogeneousTransformLocation,
      false,
      homogeneousTransformToMatrix4(renderHomogeneousTransform)
    );
  }
  startTransformerTransition(mapIds) {
    this.updateVertexBuffers(mapIds);
    if (this.lastAnimationFrameRequestId !== void 0) {
      cancelAnimationFrame(this.lastAnimationFrameRequestId);
    }
    this.animating = true;
    this.transformaterTransitionStart = void 0;
    this.lastAnimationFrameRequestId = requestAnimationFrame(
      ((now2) => this.transformerTransitionFrame(now2, mapIds)).bind(this)
    );
  }
  transformerTransitionFrame(now2, mapIds) {
    if (!this.transformaterTransitionStart) {
      this.transformaterTransitionStart = now2;
    }
    if (now2 - this.transformaterTransitionStart < ANIMATION_DURATION) {
      this.animationProgress = (now2 - this.transformaterTransitionStart) / ANIMATION_DURATION;
      this.changed();
      this.renderInternal();
      this.lastAnimationFrameRequestId = requestAnimationFrame(
        ((now22) => this.transformerTransitionFrame(now22, mapIds)).bind(
          this
        )
      );
    } else {
      this.finishTransformerTransition(mapIds);
    }
  }
  finishTransformerTransition(mapIds) {
    this.resetPrevious(mapIds);
    this.updateVertexBuffers(mapIds);
    this.animating = false;
    this.animationProgress = 0;
    this.transformaterTransitionStart = void 0;
    this.changed();
  }
  changed() {
    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.CHANGED));
  }
  imageInfoLoaded(event) {
    if (event instanceof WarpedMapEvent) {
      this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.IMAGEINFOLOADED));
    }
  }
  clearMap(mapId) {
    const webGL2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
    if (webGL2WarpedMap) {
      webGL2WarpedMap.clearTextures();
    }
  }
  mapTileLoaded(event) {
    if (event instanceof WarpedMapEvent) {
      const { mapId, tileUrl } = event.data;
      const tile = this.tileCache.getCacheableTile(tileUrl);
      if (!tile) {
        return;
      }
      if (!tile.isCachedTile()) {
        return;
      }
      const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
      if (!webgl2WarpedMap) {
        return;
      }
      webgl2WarpedMap.addCachedTileAndUpdateTextures(tile);
    }
  }
  mapTileRemoved(event) {
    if (event instanceof WarpedMapEvent) {
      const { mapId, tileUrl } = event.data;
      const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
      if (!webgl2WarpedMap) {
        return;
      }
      webgl2WarpedMap.removeCachedTileAndUpdateTextures(tileUrl);
    }
  }
  warpedMapAdded(event) {
    if (event instanceof WarpedMapEvent) {
      const mapId = event.data;
      const webgl2WarpedMap = this.warpedMapList.getWarpedMap(mapId);
      if (webgl2WarpedMap) {
        this.addEventListenersToWebGL2WarpedMap(webgl2WarpedMap);
      }
    }
  }
  preChange(event) {
    if (event instanceof WarpedMapEvent) {
      const mapIds = event.data;
      for (const webgl2WarpedMap of this.warpedMapList.getWarpedMaps({
        mapIds
      })) {
        if (this.animating) {
          webgl2WarpedMap.mixPreviousAndNew(1 - this.animationProgress);
        }
      }
    }
  }
  optionsChanged(event) {
    if (event instanceof WarpedMapEvent) {
      const mapIds = event.data;
      this.finishTransformerTransition(mapIds);
    }
    this.changed();
  }
  gcpsChanged(event) {
    if (event instanceof WarpedMapEvent) {
      const mapIds = event.data;
      this.finishTransformerTransition(mapIds);
    }
    this.changed();
  }
  resourceMaskChanged(event) {
    if (event instanceof WarpedMapEvent) {
      const mapIds = event.data;
      this.finishTransformerTransition(mapIds);
    }
    this.changed();
  }
  transformationChanged(event) {
    if (event instanceof WarpedMapEvent) {
      const mapIds = event.data;
      this.startTransformerTransition(mapIds);
    }
  }
  distortionChanged(event) {
    if (event instanceof WarpedMapEvent) {
      const mapIds = event.data;
      this.startTransformerTransition(mapIds);
    }
  }
  internalProjectionChanged(event) {
    if (event instanceof WarpedMapEvent) {
      const mapIds = event.data;
      this.startTransformerTransition(mapIds);
    }
  }
  projectionChanged(event) {
    if (event instanceof WarpedMapEvent) {
      const mapIds = event.data;
      this.finishTransformerTransition(mapIds);
    }
    this.changed();
  }
  addEventListenersToWebGL2WarpedMap(webgl2WarpedMap) {
    webgl2WarpedMap.addEventListener(
      WarpedMapEventType.TEXTURESUPDATED,
      this.throttledChanged.bind(this)
    );
  }
  removeEventListenersFromWebGL2WarpedMap(webgl2WarpedMap) {
    webgl2WarpedMap.removeEventListener(
      WarpedMapEventType.TEXTURESUPDATED,
      this.throttledChanged.bind(this)
    );
  }
  contextLost() {
    this.disableRender = true;
    this.cancelThrottledFunctions();
    for (const webgl2WarpedMap of this.warpedMapList.getWarpedMaps()) {
      webgl2WarpedMap.cancelThrottledFunctions();
    }
    this.tileCache.clear();
  }
  contextRestored() {
    this.initializeWebGL(this.gl);
    this.disableRender = false;
  }
};

// node_modules/@allmaps/openlayers/dist/OLWarpedMapEvent.js
var OLWarpedMapEvent = class extends Event_default {
  data;
  constructor(type, data) {
    super(type);
    this.data = data;
  }
};

// node_modules/@allmaps/openlayers/dist/WarpedMapLayer.js
var WarpedMapLayer = class extends Layer_default {
  container;
  canvas;
  gl;
  canvasSize = [0, 0];
  renderer;
  resizeObserver;
  /**
   * Creates a WarpedMapLayer instance
   * @param options - the WebGL2 renderer options
   */
  constructor(options) {
    super({});
    const container = document.createElement("div");
    this.container = container;
    container.style.position = "absolute";
    container.style.width = "100%";
    container.style.height = "100%";
    container.classList.add("ol-layer");
    container.classList.add("allmaps-warped-map-layer");
    const canvas = document.createElement("canvas");
    canvas.style.position = "absolute";
    canvas.style.left = "0";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    container.appendChild(canvas);
    const gl = canvas.getContext("webgl2", {
      premultipliedAlpha: true
    });
    if (!gl) {
      throw new Error("WebGL 2 not available");
    }
    this.resizeObserver = new ResizeObserver(this.resized.bind(this));
    this.resizeObserver.observe(canvas, { box: "content-box" });
    this.canvas = canvas;
    this.gl = gl;
    this.renderer = new WebGL2Renderer(this.gl, options);
    this.addEventListeners();
  }
  /**
   * Adds a [Georeference Annotation](https://iiif.io/api/extension/georef/).
   * @param annotation - Georeference Annotation
   * @returns - the map IDs of the maps that were added, or an error per map
   */
  async addGeoreferenceAnnotation(annotation) {
    const results = await this.renderer.warpedMapList.addGeoreferenceAnnotation(annotation);
    this.changed();
    return results;
  }
  /**
   * Removes a [Georeference Annotation](https://iiif.io/api/extension/georef/).
   * @param annotation - Georeference Annotation
   * @returns - the map IDs of the maps that were removed, or an error per map
   */
  async removeGeoreferenceAnnotation(annotation) {
    const results = await this.renderer.warpedMapList.removeGeoreferenceAnnotation(annotation);
    this.changed();
    return results;
  }
  /**
   * Adds a [Georeference Annotation](https://iiif.io/api/extension/georef/) by URL.
   * @param annotationUrl - Georeference Annotation
   * @returns - the map IDs of the maps that were added, or an error per map
   */
  async addGeoreferenceAnnotationByUrl(annotationUrl) {
    const annotation = await fetch(annotationUrl).then(
      (response) => response.json()
    );
    const results = this.addGeoreferenceAnnotation(annotation);
    return results;
  }
  /**
   * Removes a [Georeference Annotation](https://iiif.io/api/extension/georef/) by URL.
   * @param annotationUrl - Georeference Annotation
   * @returns - the map IDs of the maps that were removed, or an error per map
   */
  async removeGeoreferenceAnnotationByUrl(annotationUrl) {
    const annotation = await fetch(annotationUrl).then(
      (response) => response.json()
    );
    const results = this.removeGeoreferenceAnnotation(annotation);
    return results;
  }
  /**
   * Adds a Georeferenced map.
   * @param georeferencedMap - Georeferenced map
   * @returns - the map ID of the map that was added, or an error
   */
  async addGeoreferencedMap(georeferencedMap) {
    const result2 = this.renderer.warpedMapList.addGeoreferencedMap(georeferencedMap);
    this.changed();
    return result2;
  }
  /**
   * Removes a Georeferenced map.
   * @param georeferencedMap - Georeferenced map
   * @returns - the map ID of the map that was remvoed, or an error
   */
  async removeGeoreferencedMap(georeferencedMap) {
    const result2 = this.renderer.warpedMapList.removeGeoreferencedMap(georeferencedMap);
    this.changed();
    return result2;
  }
  /**
   * Returns the WarpedMapList object that contains a list of the warped maps of all loaded maps
   * @returns the warped map list
   */
  getWarpedMapList() {
    return this.renderer.warpedMapList;
  }
  /**
   * Returns a single map's warped map
   * @param mapId - ID of the map
   * @returns the warped map
   */
  getWarpedMap(mapId) {
    return this.renderer.warpedMapList.getWarpedMap(mapId);
  }
  /**
   * Make a single map visible
   * @param mapId - ID of the map
   */
  showMap(mapId) {
    this.renderer.warpedMapList.showMaps([mapId]);
    this.changed();
  }
  /**
   * Make multiple maps visible
   * @param mapIds - IDs of the maps
   */
  showMaps(mapIds) {
    this.renderer.warpedMapList.showMaps(mapIds);
    this.changed();
  }
  /**
   * Make a single map invisible
   * @param mapId - ID of the map
   */
  hideMap(mapId) {
    this.renderer.warpedMapList.hideMaps([mapId]);
    this.changed();
  }
  /**
   * Make multiple maps invisible
   * @param mapIds - IDs of the maps
   */
  hideMaps(mapIds) {
    this.renderer.warpedMapList.hideMaps(mapIds);
    this.changed();
  }
  /**
   * Returns the visibility of a single map
   * @returns - whether the map is visible
   */
  isMapVisible(mapId) {
    const warpedMap = this.renderer.warpedMapList.getWarpedMap(mapId);
    return warpedMap?.visible;
  }
  /**
   * Sets the resource mask of a single map
   * @param mapId - ID of the map
   * @param resourceMask - new resource mask
   */
  setMapResourceMask(mapId, resourceMask) {
    this.renderer.warpedMapList.setMapResourceMask(resourceMask, mapId);
    this.changed();
  }
  /**
   * Sets the GCOs of a single map
   * @param mapId - ID of the map
   * @param gcos - new GCPs
   */
  setMapGcps(mapId, gcps) {
    this.renderer.warpedMapList.setMapGcps(gcps, mapId);
    this.changed();
  }
  /**
   * Sets the transformation type of multiple maps
   * @param mapIds - IDs of the maps
   * @param transformation - new transformation type
   */
  setMapsTransformationType(mapIds, transformation) {
    this.renderer.warpedMapList.setMapsTransformationType(transformation, {
      mapIds
    });
    this.changed();
  }
  /**
   * Sets the transformation type of a single map
   * @param mapId - ID of the map
   * @param transformation - new transformation type
   */
  setMapTransformationType(mapId, transformation) {
    this.renderer.warpedMapList.setMapTransformationType(transformation, mapId);
    this.changed();
  }
  /**
   * Sets the distortion measure of multiple maps
   * @param mapIds - IDs of the maps
   * @param distortionMeasure - new distortion measure
   */
  setMapsDistortionMeasure(mapIds, distortionMeasure) {
    this.renderer.warpedMapList.setMapsDistortionMeasure(distortionMeasure, {
      mapIds
    });
    this.changed();
  }
  removeGeoreferencedMapById(mapId) {
    this.renderer.warpedMapList.removeGeoreferencedMapById(mapId);
    this.changed();
  }
  /**
   * Return the bounding box of all visible maps in the layer (inside or outside of the Viewport), in longitude/latitude coordinates.
   * @returns - Bounding box of all warped maps
   */
  getLonLatExtent() {
    return this.renderer.warpedMapList.getMapsBbox({
      projection: { definition: "EPSG:4326" }
    });
  }
  /**
   * Return the bounding box of all visible maps in the layer (inside or outside of the Viewport), in projected coordinates.
   * @returns - bounding box of all warped maps
   */
  getExtent() {
    return this.renderer.warpedMapList.getMapsBbox();
  }
  /**
   * Bring maps to front
   * @param mapIds - IDs of the maps
   */
  bringMapsToFront(mapIds) {
    this.renderer.warpedMapList.bringMapsToFront(mapIds);
    this.changed();
  }
  /**
   * Send maps to back
   * @param mapIds - IDs of the maps
   */
  sendMapsToBack(mapIds) {
    this.renderer.warpedMapList.sendMapsToBack(mapIds);
    this.changed();
  }
  /**
   * Bring maps forward
   * @param mapIds - IDs of the maps
   */
  bringMapsForward(mapIds) {
    this.renderer.warpedMapList.bringMapsForward(mapIds);
    this.changed();
  }
  /**
   * Send maps backward
   * @param mapIds - IDs of the maps
   */
  sendMapsBackward(mapIds) {
    this.renderer.warpedMapList.sendMapsBackward(mapIds);
    this.changed();
  }
  /**
   * Returns the z-index of a single map
   * @param mapId - ID of the warped map
   * @returns - z-index of the warped map
   */
  getMapZIndex(mapId) {
    return this.renderer.warpedMapList.getMapZIndex(mapId);
  }
  /**
   * Sets the object that caches image information
   * @param imageInformations - Object that caches image information
   */
  setImageInformations(imageInformations) {
    this.renderer.warpedMapList.setImageInformations(imageInformations);
  }
  /**
   * Gets the HTML container element of the layer
   * @returns HTML element
   */
  getContainer() {
    return this.container;
  }
  /**
   * Gets the HTML canvas element of the layer
   * @returns HTML Canvas element
   */
  getCanvas() {
    return this.canvas;
  }
  /**
   * Sets the options
   *
   * @param options - Options
   */
  setOptions(options) {
    this.renderer.setOptions(options);
  }
  // No setOpacity() and getOpacity() here since default for OL Layer class
  /**
   * Gets the opacity of a single map
   * @param mapId - ID of the map
   * @returns Opacity of the map
   */
  getMapOpacity(mapId) {
    return this.renderer.getMapOpacity(mapId);
  }
  /**
   * Sets the opacity of a single map
   * @param mapId - ID of the map
   * @param opacity - opacity between 0 and 1, where 0 is fully transparent and 1 is fully opaque
   */
  setMapOpacity(mapId, opacity) {
    this.renderer.setMapOpacity(mapId, opacity);
    this.changed();
  }
  /**
   * Resets the opacity of a single map to fully opaque
   * @param mapId - ID of the map
   */
  resetMapOpacity(mapId) {
    this.renderer.resetMapOpacity(mapId);
    this.changed();
  }
  /**
   * Sets the saturation of a single map
   * @param saturation - saturation between 0 and 1, where 0 is grayscale and 1 are the original colors
   */
  setSaturation(saturation) {
    this.renderer.setSaturation(saturation);
    this.changed();
  }
  /**
   * Resets the saturation of a single map to the original colors
   */
  resetSaturation() {
    this.renderer.resetSaturation();
    this.changed();
  }
  /**
   * Sets the saturation of a single map
   * @param mapId - ID of the map
   * @param saturation - saturation between 0 and 1, where 0 is grayscale and 1 are the original colors
   */
  setMapSaturation(mapId, saturation) {
    this.renderer.setMapSaturation(mapId, saturation);
    this.changed();
  }
  /**
   * Resets the saturation of a single map to the original colors
   * @param mapId - ID of the map
   */
  resetMapSaturation(mapId) {
    this.renderer.resetMapSaturation(mapId);
    this.changed();
  }
  /**
   * Removes a color from all maps
   * @param transformOptions - remove color options
   * @param transformOptions.hexColor - hex color to remove
   * @param transformOptions.threshold - threshold between 0 and 1
   * @param transformOptions.hardness - hardness between 0 and 1
   */
  setRemoveColor(options) {
    const color = options.hexColor ? hexToFractionalRgb(options.hexColor) : void 0;
    this.renderer.setRemoveColorOptions({
      color,
      threshold: options.threshold,
      hardness: options.hardness
    });
    this.changed();
  }
  /**
   * Resets the color removal for all maps
   */
  resetRemoveColor() {
    this.renderer.resetRemoveColorOptions();
    this.changed();
  }
  /**
   * Removes a color from a single map
   * @param mapId - ID of the map
   * @param transformOptions - remove color options
   * @param transformOptions.hexColor] - hex color to remove
   * @param transformOptions.threshold] - threshold between 0 and 1
   * @param transformOptions.hardness] - hardness between 0 and 1
   */
  setMapRemoveColor(mapId, options) {
    const color = options.hexColor ? hexToFractionalRgb(options.hexColor) : void 0;
    this.renderer.setMapRemoveColorOptions(mapId, {
      color,
      threshold: options.threshold,
      hardness: options.hardness
    });
    this.changed();
  }
  /**
   * Resets the color for a single map
   * @param mapId - ID of the map
   */
  resetMapRemoveColor(mapId) {
    this.renderer.resetMapRemoveColorOptions(mapId);
  }
  /**
   * Sets the colorization for all maps
   * @param hexColor - desired hex color
   */
  setColorize(hexColor) {
    const color = hexToFractionalRgb(hexColor);
    if (color) {
      this.renderer.setColorizeOptions({ color });
      this.changed();
    }
  }
  /**
   * Resets the colorization for all maps
   */
  resetColorize() {
    this.renderer.resetColorizeOptions();
    this.changed();
  }
  /**
   * Sets the colorization for a single mapID of the map
   * @param mapId - ID of the map
   * @param hexColor - desired hex color
   */
  setMapColorize(mapId, hexColor) {
    const color = hexToFractionalRgb(hexColor);
    if (color) {
      this.renderer.setMapColorizeOptions(mapId, { color });
      this.changed();
    }
  }
  /**
   * Resets the colorization of a single map
   * @param mapId - ID of the map
   */
  resetMapColorize(mapId) {
    this.renderer.resetMapColorizeOptions(mapId);
    this.changed();
  }
  /**
   * Sets the grid for all maps
   * @param enabled - whether to show the grid
   */
  setGrid(enabled) {
    this.renderer.setGridOptions({ enabled });
    this.changed();
  }
  /**
   * Resets the grid for all maps
   */
  resetGrid() {
    this.renderer.resetGridOptions();
    this.changed();
  }
  /**
   * Sets the grid for a single mapID of the map
   * @param mapId - ID of the map
   * @param enabled - whether to show the grid
   */
  setMapGrid(mapId, enabled) {
    this.renderer.setMapGridOptions(mapId, { enabled });
    this.changed();
  }
  /**
   * Resets the grid of a single map
   * @param mapId - ID of the map
   */
  resetMapGrid(mapId) {
    this.renderer.resetMapGridOptions(mapId);
    this.changed();
  }
  /**
   * Disposes all WebGL resources and cached tiles
   */
  dispose() {
    this.renderer.destroy();
    const extension = this.gl.getExtension("WEBGL_lose_context");
    if (extension) {
      extension.loseContext();
    }
    const canvas = this.gl.canvas;
    canvas.width = 1;
    canvas.height = 1;
    this.resizeObserver.disconnect();
    this.removeEventListeners();
    super.disposeInternal();
  }
  /**
   * Clears: removes all maps
   */
  clear() {
    this.renderer.warpedMapList.clear();
    this.changed();
  }
  /**
   * Render the layer.
   * @param frameState - OpenLayers frame state
   * @returns The rendered element
   */
  render(frameState) {
    if (this.canvas) {
      this.resizeCanvas(this.canvas, this.canvasSize);
    }
    this.renderer.setOpacity(Math.min(Math.max(this.getOpacity(), 0), 1));
    const viewport = new Viewport(
      frameState.size,
      frameState.viewState.center,
      frameState.viewState.resolution,
      {
        rotation: frameState.viewState.rotation,
        devicePixelRatio: window.devicePixelRatio,
        projection: { definition: frameState.viewState.projection.getCode() }
        // TODO: add a way for viewport and renderer to understand other codes then the two default ones
      }
    );
    this.renderer.render(viewport);
    return this.container;
  }
  resized(entries) {
    for (const entry of entries) {
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      const dpr = window.devicePixelRatio;
      const displayWidth = Math.round(width * dpr);
      const displayHeight = Math.round(height * dpr);
      this.canvasSize = [displayWidth, displayHeight];
    }
    this.changed();
  }
  resizeCanvas(canvas, [width, height]) {
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      canvas.width = width;
      canvas.height = height;
    }
    return needResize;
  }
  contextLost(event) {
    event.preventDefault();
    this.renderer.contextLost();
  }
  contextRestored(event) {
    event.preventDefault();
    this.renderer.contextRestored();
  }
  addEventListeners() {
    this.canvas.addEventListener(
      "webglcontextlost",
      this.contextLost.bind(this)
    );
    this.canvas.addEventListener(
      "webglcontextrestored",
      this.contextRestored.bind(this)
    );
    this.renderer.addEventListener(
      WarpedMapEventType.CHANGED,
      this.changed.bind(this)
    );
    this.renderer.addEventListener(
      WarpedMapEventType.IMAGEINFOLOADED,
      this.changed.bind(this)
    );
    this.renderer.addEventListener(
      WarpedMapEventType.WARPEDMAPENTER,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.addEventListener(
      WarpedMapEventType.WARPEDMAPLEAVE,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.tileCache.addEventListener(
      WarpedMapEventType.FIRSTMAPTILELOADED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.tileCache.addEventListener(
      WarpedMapEventType.ALLREQUESTEDTILESLOADED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.warpedMapList.addEventListener(
      WarpedMapEventType.GEOREFERENCEANNOTATIONADDED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.warpedMapList.addEventListener(
      WarpedMapEventType.WARPEDMAPADDED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.warpedMapList.addEventListener(
      WarpedMapEventType.WARPEDMAPREMOVED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.warpedMapList.addEventListener(
      WarpedMapEventType.VISIBILITYCHANGED,
      this.changed.bind(this)
    );
    this.renderer.warpedMapList.addEventListener(
      WarpedMapEventType.CLEARED,
      this.changed.bind(this)
    );
  }
  removeEventListeners() {
    this.canvas.removeEventListener(
      "webglcontextlost",
      this.contextLost.bind(this)
    );
    this.canvas.removeEventListener(
      "webglcontextrestored",
      this.contextRestored.bind(this)
    );
    this.renderer.removeEventListener(
      WarpedMapEventType.CHANGED,
      this.changed.bind(this)
    );
    this.renderer.removeEventListener(
      WarpedMapEventType.IMAGEINFOLOADED,
      this.changed.bind(this)
    );
    this.renderer.removeEventListener(
      WarpedMapEventType.WARPEDMAPENTER,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.removeEventListener(
      WarpedMapEventType.WARPEDMAPLEAVE,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.tileCache.removeEventListener(
      WarpedMapEventType.FIRSTMAPTILELOADED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.tileCache.removeEventListener(
      WarpedMapEventType.ALLREQUESTEDTILESLOADED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.warpedMapList.removeEventListener(
      WarpedMapEventType.GEOREFERENCEANNOTATIONADDED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.warpedMapList.removeEventListener(
      WarpedMapEventType.WARPEDMAPADDED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.warpedMapList.removeEventListener(
      WarpedMapEventType.WARPEDMAPREMOVED,
      this.passWarpedMapEvent.bind(this)
    );
    this.renderer.warpedMapList.removeEventListener(
      WarpedMapEventType.VISIBILITYCHANGED,
      this.changed.bind(this)
    );
    this.renderer.warpedMapList.removeEventListener(
      WarpedMapEventType.CLEARED,
      this.changed.bind(this)
    );
  }
  passWarpedMapEvent(event) {
    if (event instanceof WarpedMapEvent) {
      const olEvent = new OLWarpedMapEvent(event.type, event.data);
      this.dispatchEvent(olEvent);
    }
  }
};
export {
  OLWarpedMapEvent,
  WarpedMapEvent,
  WarpedMapEventType,
  WarpedMapLayer
};
/*! Bundled license information:

lodash-es/lodash.default.js:
lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@allmaps_openlayers.js.map
