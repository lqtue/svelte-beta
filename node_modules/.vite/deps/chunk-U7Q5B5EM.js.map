{
  "version": 3,
  "sources": ["../../@allmaps/stdlib/dist/fetch.js", "../../@allmaps/stdlib/dist/api.js", "../../@allmaps/stdlib/dist/background-color.js", "../../monotone-chain-convex-hull/src/index.ts", "../../@turf/clone/index.ts", "../../@turf/helpers/index.ts", "../../@turf/invariant/index.ts", "../../@turf/boolean-clockwise/index.ts", "../../@turf/meta/index.js", "../../@turf/rewind/index.ts", "../../@allmaps/stdlib/dist/geometry.js", "../../@allmaps/stdlib/dist/geojson.js", "../../@allmaps/stdlib/dist/bbox.js", "../../@allmaps/stdlib/dist/cache.js", "../../hex-rgb/index.js", "../../rgb-hex/index.js", "../../@allmaps/stdlib/dist/color.js", "../../@allmaps/stdlib/dist/main.js", "../../@allmaps/stdlib/dist/masks.js", "../../@allmaps/stdlib/dist/matrix.js", "../../@allmaps/stdlib/dist/options.js", "../../svg-parser/node_modules/locate-character/dist/locate-character.es.js", "../../svg-parser/src/index.js", "../../@allmaps/stdlib/dist/svg.js", "../../@allmaps/stdlib/dist/self-intersect.js"],
  "sourcesContent": ["export async function fetchUrl(input, init, fetchFn) {\n    let response;\n    if (typeof fetchFn === 'function') {\n        response = await fetchFn(input, init);\n    }\n    else {\n        response = await fetch(input, init);\n    }\n    if (!response.ok) {\n        const json = await response.json();\n        if (json && json.error) {\n            throw new Error(json.error);\n        }\n        else if (response.statusText) {\n            throw new Error(response.statusText);\n        }\n        else if (response.status === 404) {\n            throw new Error(`Not found: ${input} (404)`);\n        }\n        else if (response.status === 500) {\n            throw new Error('Internal server error (500)');\n        }\n        else {\n            throw new Error(`Failed to fetch: ${input} (${response.status})`);\n        }\n    }\n    return response;\n}\nexport async function fetchJson(input, init, fetchFn) {\n    const response = await fetchUrl(input, init, fetchFn);\n    return await response.json();\n}\nexport async function fetchImageInfo(imageUri, init, fetchFn) {\n    return await fetchJson(`${imageUri}/info.json`, init, fetchFn);\n}\nexport async function fetchImageBitmap(input, init, fetchFn) {\n    const response = await fetchUrl(input, init, fetchFn);\n    const blob = await response.blob();\n    return await createImageBitmap(blob);\n}\n", "import { fetchJson } from './fetch.js';\nfunction fetchAnnotationsByIiifUrl(url) {\n    // TODO: move base URLs to env/config file\n    return fetchJson(`https://annotations.allmaps.org/?url=${url}`);\n}\nasync function fetchAnnotationsForImage(parsedImage) {\n    try {\n        const annotations = await fetchAnnotationsByIiifUrl(`${parsedImage.uri}/info.json`);\n        return [annotations];\n    }\n    catch (err) {\n        return [];\n    }\n}\nasync function fetchAnnotationsForManifest(parsedManifest) {\n    try {\n        const annotations = await fetchAnnotationsByIiifUrl(parsedManifest.uri);\n        return [annotations];\n    }\n    catch (err) {\n        const annotations = [];\n        for (const canvas of parsedManifest.canvases) {\n            const imageAnnotations = await fetchAnnotationsForImage(canvas.image);\n            annotations.push(...imageAnnotations);\n        }\n        return annotations;\n    }\n}\nasync function fetchAnnotationsForCollection(parsedCollection) {\n    try {\n        const annotations = await fetchAnnotationsByIiifUrl(parsedCollection.uri);\n        return [annotations];\n    }\n    catch (err) {\n        const annotations = [];\n        if ('items' in parsedCollection) {\n            for (const item of parsedCollection.items) {\n                if (item.type === 'collection') {\n                    const itemAnnotations = await fetchAnnotationsForCollection(item);\n                    annotations.push(...itemAnnotations);\n                }\n                else if (item.type === 'manifest' && 'canvases' in item) {\n                    const itemAnnotations = await fetchAnnotationsForManifest(item);\n                    annotations.push(...itemAnnotations);\n                }\n            }\n        }\n        return annotations;\n    }\n}\nexport function fetchAnnotationsFromApi(parsedIiif) {\n    if (parsedIiif.type === 'image') {\n        return fetchAnnotationsForImage(parsedIiif);\n    }\n    else if (parsedIiif.type === 'manifest') {\n        return fetchAnnotationsForManifest(parsedIiif);\n    }\n    else if (parsedIiif.type === 'collection') {\n        return fetchAnnotationsForCollection(parsedIiif);\n    }\n    else {\n        throw new Error('Unsupported IIIF resource');\n    }\n}\n", "const DEFAULT_BIN_SIZE = 5;\nconst DEFAULT_RESOLUTION = 2;\nexport function getImageData(imageBitmap, mask) {\n    const canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n    const context = canvas.getContext('2d');\n    if (!context) {\n        throw new Error('Could not create OffscreenCanvas context');\n    }\n    if (mask) {\n        context.fillStyle = 'rgba(0, 0, 0, 0)';\n        context.fillRect(0, 0, imageBitmap.width, imageBitmap.height);\n        context.beginPath();\n        context.moveTo(mask[0][0], mask[0][1]);\n        mask.slice(1).forEach((point) => context.lineTo(point[0], point[1]));\n        context.closePath();\n        context.clip();\n    }\n    context.drawImage(imageBitmap, 0, 0);\n    return context.getImageData(0, 0, imageBitmap.width, imageBitmap.height);\n}\nexport function getColorsArray(imageData, resolution = DEFAULT_RESOLUTION) {\n    const colors = [];\n    for (let x = 0; x < imageData.width; x += resolution) {\n        for (let y = 0; y < imageData.height; y += resolution) {\n            const startIndex = (x + y * imageData.width) * 4;\n            const opacity = imageData.data[startIndex + 3];\n            if (opacity > 0) {\n                const color = [\n                    imageData.data[startIndex],\n                    imageData.data[startIndex + 1],\n                    imageData.data[startIndex + 2]\n                ];\n                colors.push(color);\n            }\n        }\n    }\n    return colors;\n}\nexport function getColorHistogram(colors, binSize = DEFAULT_BIN_SIZE) {\n    const histogram = {};\n    for (const color of colors) {\n        const bin = createColorBin(color, binSize);\n        if (!histogram[bin]) {\n            histogram[bin] = {\n                count: 0,\n                color\n            };\n        }\n        histogram[bin].count += 1;\n    }\n    return histogram;\n}\nexport function getMaxOccurringColor(histogram) {\n    let max = Number.NEGATIVE_INFINITY;\n    let maxOccurringColor;\n    for (const { count, color } of Object.values(histogram)) {\n        if (count > max) {\n            max = count;\n            maxOccurringColor = color;\n        }\n    }\n    if (!maxOccurringColor) {\n        throw new Error('Histogram is empty');\n    }\n    return {\n        count: max,\n        color: maxOccurringColor\n    };\n}\nfunction createColorBin(color, binSize) {\n    return color.map((c) => Math.round(c / binSize)).toString();\n}\n", "interface MCCHOptions {\n  sorted?: boolean;\n}\ntype Point = [number, number];\n/**\n * Computes the convex hull of a binary image using Andrew's Monotone Chain Algorithm\n * http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull\n *\n * @param points - An array of points.\n * @param options - MCCH Algorithm options.\n * @return Coordinates of the convex hull in clockwise order\n */\nexport default function monotoneChainConvexHull(\n  points: Point[],\n  options: MCCHOptions = {},\n): Point[] {\n  const { sorted } = options;\n  if (!sorted) {\n    points = points.slice().sort(byXThenY);\n  }\n\n  const n = points.length;\n  const result = new Array(n * 2);\n  let k = 0;\n\n  for (let i = 0; i < n; i++) {\n    const point = points[i];\n    while (k >= 2 && cw(result[k - 2], result[k - 1], point) <= 0) {\n      k--;\n    }\n    result[k++] = point;\n  }\n\n  const t = k + 1;\n  for (let i = n - 2; i >= 0; i--) {\n    const point = points[i];\n    while (k >= t && cw(result[k - 2], result[k - 1], point) <= 0) {\n      k--;\n    }\n    result[k++] = point;\n  }\n\n  return result.slice(0, k - 1);\n}\n\nfunction cw(p1: Point, p2: Point, p3: Point) {\n  return (p2[1] - p1[1]) * (p3[0] - p1[0]) - (p2[0] - p1[0]) * (p3[1] - p1[1]);\n}\n\nfunction byXThenY(point1: Point, point2: Point) {\n  if (point1[0] === point2[0]) {\n    return point1[1] - point2[1];\n  }\n  return point1[0] - point2[0];\n}\n", "import { Feature, GeoJsonProperties } from \"geojson\";\nimport { AllGeoJSON } from \"@turf/helpers\";\n\n/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @function\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone<T extends AllGeoJSON>(geojson: T): T {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n\n  switch (geojson.type) {\n    case \"Feature\":\n      return cloneFeature(geojson);\n    case \"FeatureCollection\":\n      return cloneFeatureCollection(geojson);\n    case \"Point\":\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiPoint\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n    case \"GeometryCollection\":\n      return cloneGeometry(geojson);\n    default:\n      throw new Error(\"unknown GeoJSON type\");\n  }\n}\n\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson: any) {\n  const cloned: any = { type: \"Feature\" };\n  // Preserve Foreign Members\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"properties\":\n      case \"geometry\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  // Add properties & geometry last\n  cloned.properties = cloneProperties(geojson.properties);\n  if (geojson.geometry == null) {\n    cloned.geometry = null;\n  } else {\n    cloned.geometry = cloneGeometry(geojson.geometry);\n  }\n  return cloned;\n}\n\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties: GeoJsonProperties) {\n  const cloned: { [key: string]: any } = {};\n  if (!properties) {\n    return cloned;\n  }\n  Object.keys(properties).forEach((key) => {\n    const value = properties[key];\n    if (typeof value === \"object\") {\n      if (value === null) {\n        // handle null\n        cloned[key] = null;\n      } else if (Array.isArray(value)) {\n        // handle Array\n        cloned[key] = value.map((item) => {\n          return item;\n        });\n      } else {\n        // handle generic Object\n        cloned[key] = cloneProperties(value);\n      }\n    } else {\n      cloned[key] = value;\n    }\n  });\n  return cloned;\n}\n\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson: any) {\n  const cloned: any = { type: \"FeatureCollection\" };\n\n  // Preserve Foreign Members\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"features\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  // Add features\n  cloned.features = geojson.features.map((feature: Feature<any>) => {\n    return cloneFeature(feature);\n  });\n  return cloned;\n}\n\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry: any) {\n  const geom: any = { type: geometry.type };\n  if (geometry.bbox) {\n    geom.bbox = geometry.bbox;\n  }\n\n  if (geometry.type === \"GeometryCollection\") {\n    geom.geometries = geometry.geometries.map((g: any) => {\n      return cloneGeometry(g);\n    });\n    return geom;\n  }\n  geom.coordinates = deepSlice(geometry.coordinates);\n  return geom;\n}\n\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice<C = any[]>(coords: C): C {\n  const cloned: any = coords;\n  if (typeof cloned[0] !== \"object\") {\n    return cloned.slice();\n  }\n  return cloned.map((coord: any) => {\n    return deepSlice(coord);\n  });\n}\n\nexport { clone, cloneProperties };\nexport default clone;\n", "import {\n  BBox,\n  Feature,\n  FeatureCollection,\n  Geometry,\n  GeometryCollection,\n  GeometryObject,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n  Position,\n  GeoJsonProperties,\n} from \"geojson\";\n\nimport { Id } from \"./lib/geojson.js\";\nexport * from \"./lib/geojson.js\";\n\n/**\n * @module helpers\n */\n\n// TurfJS Combined Types\nexport type Coord = Feature<Point> | Point | Position;\n\n/**\n * Linear measurement units.\n *\n * ⚠️ Warning. Be aware of the implications of using radian or degree units to\n * measure distance. The distance represented by a degree of longitude *varies*\n * depending on latitude.\n *\n * See https://www.thoughtco.com/degree-of-latitude-and-longitude-distance-4070616\n * for an illustration of this behaviour.\n *\n * @typedef\n */\nexport type Units =\n  | \"meters\"\n  | \"metres\"\n  | \"millimeters\"\n  | \"millimetres\"\n  | \"centimeters\"\n  | \"centimetres\"\n  | \"kilometers\"\n  | \"kilometres\"\n  | \"miles\"\n  | \"nauticalmiles\"\n  | \"inches\"\n  | \"yards\"\n  | \"feet\"\n  | \"radians\"\n  | \"degrees\";\n\n/**\n * Area measurement units.\n *\n * @typedef\n */\nexport type AreaUnits =\n  | Exclude<Units, \"radians\" | \"degrees\">\n  | \"acres\"\n  | \"hectares\";\n\n/**\n * Grid types.\n *\n * @typedef\n */\nexport type Grid = \"point\" | \"square\" | \"hex\" | \"triangle\";\n\n/**\n * Shorthand corner identifiers.\n *\n * @typedef\n */\nexport type Corners = \"sw\" | \"se\" | \"nw\" | \"ne\" | \"center\" | \"centroid\";\n\n/**\n * Geometries made up of lines i.e. lines and polygons.\n *\n * @typedef\n */\nexport type Lines = LineString | MultiLineString | Polygon | MultiPolygon;\n\n/**\n * Convenience type for all possible GeoJSON.\n *\n * @typedef\n */\nexport type AllGeoJSON =\n  | Feature\n  | FeatureCollection\n  | Geometry\n  | GeometryCollection;\n\n/**\n * The Earth radius in kilometers. Used by Turf modules that model the Earth as a sphere. The {@link https://en.wikipedia.org/wiki/Earth_radius#Arithmetic_mean_radius mean radius} was selected because it is {@link https://rosettacode.org/wiki/Haversine_formula#:~:text=This%20value%20is%20recommended recommended } by the Haversine formula (used by turf/distance) to reduce error.\n *\n * @constant\n */\nexport const earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors based on earthRadius.\n *\n * Keys are the name of the unit, values are the number of that unit in a single radian\n *\n * @constant\n */\nexport const factors: Record<Units, number> = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936,\n};\n\n/**\n\n * Area of measurement factors based on 1 square meter.\n *\n * @constant\n */\nexport const areaFactors: Record<AreaUnits, number> = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  nauticalmiles: 2.9155334959812285e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046,\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @function\n * @param {GeometryObject} geometry input geometry\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryObject, GeoJsonProperties>} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geom: G | null,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<G, P> {\n  const feat: any = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @function\n * @param {(\"Point\" | \"LineString\" | \"Polygon\" | \"MultiPoint\" | \"MultiLineString\" | \"MultiPolygon\")} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(\n  type:\n    | \"Point\"\n    | \"LineString\"\n    | \"Polygon\"\n    | \"MultiPoint\"\n    | \"MultiLineString\"\n    | \"MultiPolygon\",\n  coordinates: any[],\n  _options: Record<string, never> = {}\n) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @function\n * @param {Position} coordinates longitude, latitude position (each in decimal degrees)\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point, GeoJsonProperties>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Point, P> {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n\n  const geom: Point = {\n    type: \"Point\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @function\n * @param {Position[]} coordinates an array of Points\n * @param {GeoJsonProperties} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {Id} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Point, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @function\n * @param {Position[][]} coordinates an array of LinearRings\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon, GeoJsonProperties>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Polygon, P> {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom: Polygon = {\n    type: \"Polygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @function\n * @param {Position[][][]} coordinates an array of Polygon coordinates\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon, GeoJsonProperties>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Polygon, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @function\n * @param {Position[]} coordinates an array of Positions\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString, GeoJsonProperties>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<LineString, P> {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom: LineString = {\n    type: \"LineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @function\n * @param {Position[][]} coordinates an array of LinearRings\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {Id} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString, GeoJsonProperties>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<LineString, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @function\n * @param {Array<Feature<GeometryObject, GeoJsonProperties>>} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection<GeometryObject, GeoJsonProperties>} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  features: Array<Feature<G, P>>,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<G, P> {\n  const fc: any = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\n\n/**\n * Creates a {@link Feature}<{@link MultiLineString}> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Position[][]} coordinates an array of LineStrings\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString, GeoJsonProperties>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiLineString, P> {\n  const geom: MultiLineString = {\n    type: \"MultiLineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature}<{@link MultiPoint}> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Position[]} coordinates an array of Positions\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint, GeoJsonProperties>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPoint, P> {\n  const geom: MultiPoint = {\n    type: \"MultiPoint\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature}<{@link MultiPolygon}> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Position[][][]} coordinates an array of Polygons\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon, GeoJsonProperties>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPolygon, P> {\n  const geom: MultiPolygon = {\n    type: \"MultiPolygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a Feature<GeometryCollection> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Array<Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon>} geometries an array of GeoJSON Geometries\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection, GeoJsonProperties>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geometries: Array<\n    Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon\n  >,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<GeometryCollection, P> {\n  const geom: GeometryCollection = {\n    type: \"GeometryCollection\",\n    geometries,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @function\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num: number, precision = 0): number {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @function\n * @param {number} radians in radians across the sphere\n * @param {Units} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(\n  radians: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @function\n * @param {number} distance in real units\n * @param {Units} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(\n  distance: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @function\n * @param {number} distance in real units\n * @param {Units} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance: number, units?: Units): number {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @function\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing: number): number {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\n\n/**\n * Converts any azimuth angle from the north line direction (positive clockwise)\n * and returns an angle between -180 and +180 degrees (positive clockwise), 0 being the north line\n *\n * @function\n * @param {number} angle between 0 and 360 degrees\n * @returns {number} bearing between -180 and +180 degrees\n */\nexport function azimuthToBearing(angle: number): number {\n  // Ignore full revolutions (multiples of 360)\n  angle = angle % 360;\n\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n\n  return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @function\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians: number): number {\n  // % (2 * Math.PI) radians in case someone passes value > 2π\n  const normalisedRadians = radians % (2 * Math.PI);\n  return (normalisedRadians * 180) / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @function\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees: number): number {\n  // % 360 degrees in case someone passes value > 360\n  const normalisedDegrees = degrees % 360;\n  return (normalisedDegrees * Math.PI) / 180;\n}\n\n/**\n * Converts a length from one unit to another.\n *\n * @function\n * @param {number} length Length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] Input length unit\n * @param {Units} [finalUnit=\"kilometers\"] Returned length unit\n * @returns {number} The converted length\n */\nexport function convertLength(\n  length: number,\n  originalUnit: Units = \"kilometers\",\n  finalUnit: Units = \"kilometers\"\n): number {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n\n/**\n * Converts an area from one unit to another.\n *\n * @function\n * @param {number} area Area to be converted\n * @param {AreaUnits} [originalUnit=\"meters\"] Input area unit\n * @param {AreaUnits} [finalUnit=\"kilometers\"] Returned area unit\n * @returns {number} The converted length\n */\nexport function convertArea(\n  area: number,\n  originalUnit: AreaUnits = \"meters\",\n  finalUnit: AreaUnits = \"kilometers\"\n): number {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n\n  return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @function\n * @param {any} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num: any): boolean {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @function\n * @param {any} input variable to validate\n * @returns {boolean} true/false, including false for Arrays and Functions\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input: any): boolean {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {any} bbox BBox to validate\n * @returns {void}\n * @throws {Error} if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox: any): void {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {any} id Id to validate\n * @returns {void}\n * @throws {Error} if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id: any): void {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\n", "import {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  LineString,\n  MultiPoint,\n  MultiLineString,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from \"geojson\";\nimport { isNumber } from \"@turf/helpers\";\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @function\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord: Feature<Point> | Point | number[]): number[] {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n\n  if (!Array.isArray(coord)) {\n    if (\n      coord.type === \"Feature\" &&\n      coord.geometry !== null &&\n      coord.geometry.type === \"Point\"\n    ) {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (\n    Array.isArray(coord) &&\n    coord.length >= 2 &&\n    !Array.isArray(coord[0]) &&\n    !Array.isArray(coord[1])\n  ) {\n    return [...coord];\n  }\n\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @function\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords<\n  G extends\n    | Point\n    | LineString\n    | Polygon\n    | MultiPoint\n    | MultiLineString\n    | MultiPolygon,\n>(coords: any[] | Feature<G> | G): any[] {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n\n  // Feature\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    // Geometry\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @function\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates: any[]): boolean {\n  if (\n    coordinates.length > 1 &&\n    isNumber(coordinates[0]) &&\n    isNumber(coordinates[1])\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @function\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value: any, type: string, name: string): void {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" +\n        name +\n        \": must be a \" +\n        type +\n        \", given \" +\n        value.type\n    );\n  }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @function\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature: Feature<any>, type: string, name: string): void {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" +\n        name +\n        \": must be a \" +\n        type +\n        \", given \" +\n        feature.geometry.type\n    );\n  }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @function\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(\n  featureCollection: FeatureCollection<any>,\n  type: string,\n  name: string\n) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" +\n          name +\n          \": must be a \" +\n          type +\n          \", given \" +\n          feature.geometry.type\n      );\n    }\n  }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom<G extends Geometry>(geojson: Feature<G> | G): G {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(\n  geojson: Feature<any> | FeatureCollection<any> | Geometry,\n  _name?: string\n): string {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\n\nexport {\n  getCoord,\n  getCoords,\n  containsNumber,\n  geojsonType,\n  featureOf,\n  collectionOf,\n  getGeom,\n  getType,\n};\n// No default export!\n", "import { Feature, LineString, Position } from \"geojson\";\nimport { getCoords } from \"@turf/invariant\";\n\n/**\n * Takes a ring and return true or false whether or not the ring is clockwise or counter-clockwise.\n *\n * @function\n * @param {Feature<LineString>|LineString|Array<Array<number>>} line to be evaluated\n * @returns {boolean} true/false\n * @example\n * var clockwiseRing = turf.lineString([[0,0],[1,1],[1,0],[0,0]]);\n * var counterClockwiseRing = turf.lineString([[0,0],[1,0],[1,1],[0,0]]);\n *\n * turf.booleanClockwise(clockwiseRing)\n * //=true\n * turf.booleanClockwise(counterClockwiseRing)\n * //=false\n */\nfunction booleanClockwise(\n  line: Feature<LineString> | LineString | Position[]\n): boolean {\n  const ring = getCoords(line);\n  let sum = 0;\n  let i = 1;\n  let prev;\n  let cur;\n\n  while (i < ring.length) {\n    prev = cur || ring[0];\n    cur = ring[i];\n    sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);\n    i++;\n  }\n  return sum > 0;\n}\n\nexport { booleanClockwise };\nexport default booleanClockwise;\n", "import { feature, point, lineString, isObject } from \"@turf/helpers\";\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {number[]} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @function\n * @param {AllGeoJSON} geojson any GeoJSON object\n * @param {coordEachCallback} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n        ? geojson.geometry\n        : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {number[]} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @function\n * @param {AllGeoJSON} geojson any GeoJSON object\n * @param {coordReduceCallback} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {GeoJsonProperties} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @function\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {propEachCallback} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {GeoJsonProperties} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @function\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {propReduceCallback} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @function\n * @param {FeatureCollection|Feature|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {featureEachCallback} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @function\n * @param {FeatureCollection|Feature|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {featureReduceCallback} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @function\n * @param {AllGeoJSON} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {GeometryObject} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {GeoJsonProperties} featureProperties The current Feature Properties being processed.\n * @param {BBox} featureBBox The current Feature BBox being processed.\n * @param {Id} featureId The current Feature Id being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @function\n * @param {FeatureCollection|Feature|Geometry|GeometryObject|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {geomEachCallback} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n        ? geojson.geometry\n        : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n        ? geojson.properties\n        : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n        ? geojson.bbox\n        : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n        ? geojson.id\n        : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {GeometryObject} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {GeoJsonProperties} featureProperties The current Feature Properties being processed.\n * @param {BBox} featureBBox The current Feature BBox being processed.\n * @param {Id} featureId The current Feature Id being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @function\n * @param {FeatureCollection|Feature|GeometryObject|GeometryCollection|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {geomReduceCallback} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @function\n * @param {FeatureCollection|Feature|GeometryObject|GeometryCollection|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {flattenEachCallback} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @function\n * @param {FeatureCollection|Feature|GeometryObject|GeometryCollection|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {flattenReduceCallback} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {AllGeoJSON} geojson any GeoJSON\n * @param {segmentEachCallback} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {segmentReduceCallback} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n * @returns {void}\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @function\n * @param {FeatureCollection<Lines>|Feature<Lines>|Lines|Feature<GeometryCollection>|GeometryCollection} geojson object\n * @param {lineEachCallback} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @returns {void}\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n * @returns {Reducer}\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @function\n * @param {FeatureCollection<Lines>|Feature<Lines>|Lines|Feature<GeometryCollection>|GeometryCollection} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport {\n  coordReduce,\n  coordEach,\n  propEach,\n  propReduce,\n  featureReduce,\n  featureEach,\n  coordAll,\n  geomReduce,\n  geomEach,\n  flattenReduce,\n  flattenEach,\n  segmentReduce,\n  segmentEach,\n  lineReduce,\n  lineEach,\n  findSegment,\n  findPoint,\n};\n", "import type {\n  Feature,\n  Position,\n  GeometryCollection,\n  Geometry,\n  LineString,\n  MultiLineString,\n  MultiPolygon,\n  Polygon,\n  FeatureCollection,\n} from \"geojson\";\nimport { clone } from \"@turf/clone\";\nimport { booleanClockwise } from \"@turf/boolean-clockwise\";\nimport { geomEach, featureEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\nimport type { AllGeoJSON } from \"@turf/helpers\";\n\n/**\n * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).\n *\n * @function\n * @param {GeoJSON} geojson input GeoJSON Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.reverse=false] enable reverse winding\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} rewind Polygon\n * @example\n * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);\n *\n * var rewind = turf.rewind(polygon);\n *\n * //addToMap\n * var addToMap = [rewind];\n */\nfunction rewind<T extends AllGeoJSON>(\n  geojson: T,\n  options: {\n    reverse?: boolean;\n    mutate?: boolean;\n  } = {}\n): Geometry | Feature | FeatureCollection {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const mutate = options.mutate ?? false;\n  const reverse = options.reverse ?? false;\n\n  // validation\n  if (!geojson) throw new Error(\"<geojson> is required\");\n  if (typeof reverse !== \"boolean\")\n    throw new Error(\"<reverse> must be a boolean\");\n  if (typeof mutate !== \"boolean\")\n    throw new Error(\"<mutate> must be a boolean\");\n\n  // Prevent input mutation if requested and necessary.\n  if (!mutate && geojson.type !== \"Point\" && geojson.type !== \"MultiPoint\") {\n    geojson = clone(geojson);\n  }\n\n  // Support Feature Collection or Geometry Collection\n  const results: Feature[] = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        const rewoundFeature = rewindFeature(feature, reverse) as Feature;\n        featureEach(rewoundFeature, function (result) {\n          results.push(result);\n        });\n      });\n      return featureCollection(results);\n  }\n  // Support Feature or Geometry Objects\n  return rewindFeature(geojson, reverse);\n}\n\n/**\n * Rewind\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {Geometry|Feature<any>} rewind Geometry or Feature\n */\nfunction rewindFeature(\n  geojson: Geometry | GeometryCollection | Feature,\n  reverse: boolean\n) {\n  const type =\n    geojson.type === \"Feature\" ? geojson.geometry.type : geojson.type;\n\n  // Support all GeoJSON Geometry Objects\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"LineString\":\n      rewindLineString(getCoords(geojson as LineString), reverse);\n      return geojson;\n    case \"Polygon\":\n      rewindPolygon(getCoords(geojson as Polygon), reverse);\n      return geojson;\n    case \"MultiLineString\":\n      getCoords(geojson as MultiLineString).forEach(function (lineCoords) {\n        rewindLineString(lineCoords, reverse);\n      });\n      return geojson;\n    case \"MultiPolygon\":\n      getCoords(geojson as MultiPolygon).forEach(function (lineCoords) {\n        rewindPolygon(lineCoords, reverse);\n      });\n      return geojson;\n    case \"Point\":\n    case \"MultiPoint\":\n      // noop\n      return geojson;\n  }\n}\n\n/**\n * Rewind LineString - outer ring clockwise\n *\n * @private\n * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindLineString(coords: Position[], reverse: boolean) {\n  if (booleanClockwise(coords) === reverse) coords.reverse();\n}\n\n/**\n * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.\n *\n * @private\n * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindPolygon(coords: Position[][], reverse: boolean) {\n  // outer ring\n  if (booleanClockwise(coords[0]) !== reverse) {\n    coords[0].reverse();\n  }\n  // inner rings\n  for (let i = 1; i < coords.length; i++) {\n    if (booleanClockwise(coords[i]) === reverse) {\n      coords[i].reverse();\n    }\n  }\n}\n\nexport { rewind };\nexport default rewind;\n", "import { rewind } from '@turf/rewind';\n// Assert\nexport function isPoint(input) {\n    return (Array.isArray(input) &&\n        input.length >= 2 &&\n        typeof input[0] === 'number' &&\n        typeof input[1] === 'number');\n}\nexport function isLineString(input) {\n    return Array.isArray(input) && input.every(isPoint);\n}\nexport function isRing(input) {\n    return Array.isArray(input) && input.every(isPoint);\n}\nexport function isPolygon(input) {\n    return Array.isArray(input) && input.every(isRing);\n}\nexport function isMultiPoint(input) {\n    return Array.isArray(input) && input.every(isPoint);\n}\nexport function isMultiLineString(input) {\n    return Array.isArray(input) && input.every(isLineString);\n}\nexport function isMultiPolygon(input) {\n    return Array.isArray(input) && input.every(isPolygon);\n}\nexport function isGeometry(input) {\n    return (isPoint(input) ||\n        isLineString(input) ||\n        isPolygon(input) ||\n        isMultiPoint(input) ||\n        isMultiLineString(input) ||\n        isMultiPolygon(input));\n}\n// Close\nexport function closeRing(ring) {\n    return [...ring, ring[0]];\n}\nexport function uncloseRing(ring) {\n    ring.splice(-1);\n    return ring;\n}\nexport function closePolygon(polygon) {\n    return polygon.map((ring) => closeRing(ring));\n}\nexport function unclosePolygon(polygon) {\n    return polygon.map((ring) => uncloseRing(ring));\n}\nexport function closeMultiPolygon(multiPolygon) {\n    return multiPolygon.map((polygon) => closePolygon(polygon));\n}\nexport function uncloseMultiPolygon(multiPolygon) {\n    return multiPolygon.map((polygon) => unclosePolygon(polygon));\n}\n// Conform\nexport function conformLineString(lineString) {\n    // Filter out repeated points\n    lineString = lineString.filter(function (point, i, originalLineString) {\n        return i === 0 || !isEqualPoint(point, originalLineString[i - 1]);\n    });\n    if (lineString.length < 2) {\n        throw new Error('LineString should contain at least 2 points');\n    }\n    return lineString;\n}\nexport function conformRing(ring) {\n    // Filter out repeated points\n    ring = ring.filter(function (point, i, originalRing) {\n        return i === 0 || !isEqualPoint(point, originalRing[i - 1]);\n    });\n    // Remove last point if input is closed ring\n    if (isClosed(ring)) {\n        uncloseRing(ring);\n    }\n    if (ring.length < 3) {\n        throw new Error('Ring should contain at least 3 points');\n    }\n    return ring;\n}\nexport function conformPolygon(polygon) {\n    return polygon.map((ring) => {\n        return conformRing(ring);\n    });\n}\nexport function conformMultiLineString(multiLineString) {\n    return multiLineString.map((lineString) => conformLineString(lineString));\n}\nexport function conformMultiPolygon(multiPolygon) {\n    return multiPolygon.map((polygon) => conformPolygon(polygon));\n}\n// Convert to GeoJSON\nexport function pointToGeojsonPoint(point) {\n    return {\n        type: 'Point',\n        coordinates: point\n    };\n}\nexport function lineStringToGeojsonLineString(lineString) {\n    return {\n        type: 'LineString',\n        coordinates: lineString\n    };\n}\nexport function ringToGeojsonPolygon(ring, close = true) {\n    const geometry = {\n        type: 'Polygon',\n        coordinates: close ? [closeRing(ring)] : [ring]\n    };\n    return rewind(geometry);\n}\nexport function polygonToGeojsonPolygon(polygon, close = true) {\n    const geometry = {\n        type: 'Polygon',\n        coordinates: close ? closePolygon(polygon) : polygon\n    };\n    return rewind(geometry);\n}\nexport function multiPointToGeojsonMultiPoint(multiPoint) {\n    return {\n        type: 'MultiPoint',\n        coordinates: multiPoint\n    };\n}\nexport function multiLineStringToGeojsonMultiLineString(multiLineString) {\n    return {\n        type: 'MultiLineString',\n        coordinates: multiLineString\n    };\n}\nexport function multiPolygonToGeojsonMultiPolygon(multiPolygon, close = true) {\n    const geometry = {\n        type: 'MultiPolygon',\n        coordinates: close ? closeMultiPolygon(multiPolygon) : multiPolygon\n    };\n    return rewind(geometry);\n}\n/**\n * Converts a Geometry to a GeoJSON Geometry\n * @param geometry - Geometry\n * @returns GeoJSON Geometry\n */\nexport function geometryToGeojsonGeometry(geometry, options) {\n    if (!options || !options.isMultiGeometry) {\n        if (isPoint(geometry)) {\n            return pointToGeojsonPoint(geometry);\n        }\n        else if (isLineString(geometry)) {\n            return lineStringToGeojsonLineString(geometry);\n        }\n        else if (isPolygon(geometry)) {\n            return polygonToGeojsonPolygon(geometry);\n        }\n        else {\n            throw new Error('Geometry type not supported');\n        }\n    }\n    else {\n        if (isMultiPoint(geometry)) {\n            return multiPointToGeojsonMultiPoint(geometry);\n        }\n        else if (isMultiLineString(geometry)) {\n            return multiLineStringToGeojsonMultiLineString(geometry);\n        }\n        else if (isMultiPolygon(geometry)) {\n            return multiPolygonToGeojsonMultiPolygon(geometry);\n        }\n        else {\n            throw new Error('Geometry type not supported');\n        }\n    }\n}\n// Convert to SVG\nexport function pointToSvgCircle(point) {\n    return {\n        type: 'circle',\n        coordinates: point\n    };\n}\nexport function lineStringToSvgPolyLine(lineString) {\n    return {\n        type: 'polyline',\n        coordinates: lineString\n    };\n}\nexport function polygonToSvgPolygon(polygon) {\n    return {\n        type: 'polygon',\n        coordinates: polygon[0]\n    };\n}\n/**\n * Converts a Geometry to a SVG Geometry\n * @param geometry - Geometry\n * @returns SVG Geometry\n * }}\n */\nexport function geometryToSvgGeometry(geometry) {\n    if (isPoint(geometry)) {\n        return pointToSvgCircle(geometry);\n    }\n    else if (isLineString(geometry)) {\n        return lineStringToSvgPolyLine(geometry);\n    }\n    else if (isPolygon(geometry)) {\n        return polygonToSvgPolygon(geometry);\n    }\n    else {\n        throw new Error(`Unsupported GeoJSON Geometry`);\n    }\n}\n// Check\nexport function isClosed(input) {\n    return (Array.isArray(input) &&\n        input.length >= 2 &&\n        isEqualPoint(input[0], input[input.length - 1]));\n}\nexport function isEqualPoint(point0, point1) {\n    if (point0 === point1)\n        return true;\n    if (point0 === null || point1 === null)\n        return false;\n    return point0[0] === point1[0] && point0[1] === point1[1];\n}\nexport function isEqualPointArray(pointArray0, pointArray1) {\n    if (pointArray0 === pointArray1)\n        return true;\n    if (!pointArray0 || !pointArray1)\n        return false;\n    if (pointArray0.length !== pointArray1.length)\n        return false;\n    for (let i = 0; i < pointArray0.length; ++i) {\n        if (isEqualPoint(pointArray0[i], pointArray1[i]))\n            return false;\n    }\n    return true;\n}\nexport function isEqualPointArrayArray(pointArrayArray0, pointArrayArray1) {\n    if (pointArrayArray0 === pointArrayArray1)\n        return true;\n    if (!pointArrayArray0 || !pointArrayArray1)\n        return false;\n    if (pointArrayArray0.length !== pointArrayArray1.length)\n        return false;\n    for (let i = 0; i < pointArrayArray0.length; ++i) {\n        if (isEqualPointArray(pointArrayArray0[i], pointArrayArray1[i]))\n            return false;\n    }\n    return true;\n}\n// Split, combine, shift, flip\nexport function pointsAndPointsToLines(points0, points1) {\n    if (points0.length !== points1.length)\n        throw new Error('Point arrays should be of same length');\n    return points0.map((point0, index) => [point0, points1[index]]);\n}\nexport function lineStringToLines(lineString) {\n    return lineString.reduce((accumulator, point, index) => [\n        ...accumulator,\n        [point, lineString[(index + 1) % lineString.length]]\n    ], []);\n}\nexport function pointToPixel(point, translate = [0, 0]) {\n    return point.map((coordinate, index) => {\n        return Math.floor(coordinate + translate[index]);\n    });\n}\nexport function pixelToIntArrayIndex(pixel, size, channels, flipY = false) {\n    const column = pixel[0];\n    const row = flipY ? size[1] - 1 - pixel[1] : pixel[1];\n    return (row * size[0] + column) * channels;\n}\nexport function flipX(point) {\n    return [-point[0], point[1]];\n}\nexport function flipY(point) {\n    return [point[0], -point[1]];\n}\n// Mix\nexport function mixNumbers(number0, number1, t) {\n    return number0 * (1 - t) + number1 * t;\n}\nexport function mixPoints(point0, point1, t) {\n    return [\n        mixNumbers(point0[0], point1[0], t),\n        mixNumbers(point0[1], point1[1], t)\n    ];\n}\n// Compute\nexport function midPoint(...points) {\n    const result = [0, 0];\n    for (let i = 0; i < points.length; i++) {\n        result[0] += points[i][0];\n        result[1] += points[i][1];\n    }\n    result[0] = result[0] / points.length;\n    result[1] = result[1] / points.length;\n    return result;\n}\n// Return angle of line (in radians, signed)\nexport function lineAngle(line) {\n    return Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]);\n}\n// Return the next point starting from a point going a certian distance in a certain direction\nexport function stepDistanceAngle(point, dist, angle) {\n    return [point[0] + Math.cos(angle) * dist, point[1] + Math.sin(angle) * dist];\n}\nexport function distance(from, to) {\n    if (isLineString(from) && from.length === 2) {\n        return distance(from[0], from[1]);\n    }\n    else if (isPoint(from) && to === undefined) {\n        return distance(from, [0, 0]);\n    }\n    else if (isPoint(from) && isPoint(to)) {\n        return Math.sqrt(squaredDistance(from, to));\n    }\n    else {\n        throw new Error('Input type not supported');\n    }\n}\nexport function squaredDistance(from, to) {\n    if (isLineString(from) && from.length === 2) {\n        return squaredDistance(from[0], from[1]);\n    }\n    else if (isPoint(from) && to === undefined) {\n        return squaredDistance(from, [0, 0]);\n    }\n    else if (isPoint(from) && isPoint(to)) {\n        return (to[0] - from[0]) ** 2 + (to[1] - from[1]) ** 2;\n    }\n    else {\n        throw new Error('Input type not supported');\n    }\n}\nexport function rms(from, to) {\n    if (from.length !== to.length) {\n        throw new Error('Arrays need to be of same length');\n    }\n    const squaredDistances = from.map((fromPoint, index) => squaredDistance(fromPoint, to[index]));\n    const meanSquaredDistances = squaredDistances.reduce((sum, squaredDistace) => sum + squaredDistace, 0) /\n        squaredDistances.length;\n    const rootMeanSquaredDistances = Math.sqrt(meanSquaredDistances);\n    return rootMeanSquaredDistances;\n}\nexport function triangleArea(triangle) {\n    return (0.5 *\n        Math.abs(triangle[0][0] * (triangle[1][1] - triangle[2][1]) +\n            triangle[1][0] * (triangle[2][1] - triangle[0][1]) +\n            triangle[2][0] * (triangle[0][1] - triangle[1][1])));\n}\nexport function invertPoint(point) {\n    return [-point[0], -point[1]];\n}\nexport function invertPoints(points) {\n    return points.map((point) => invertPoint(point));\n}\nexport function scalePoint(point, scale) {\n    if (scale === 1) {\n        return point;\n    }\n    return [point[0] * scale, point[1] * scale];\n}\nexport function scalePoints(points, scale) {\n    if (scale === 1) {\n        return points;\n    }\n    return points.map((point) => scalePoint(point, scale));\n}\nexport function translatePoint(point, translationPoint, addOrSubstract = 'add') {\n    if (addOrSubstract === 'add') {\n        return [point[0] + translationPoint[0], point[1] + translationPoint[1]];\n    }\n    else {\n        return [point[0] - translationPoint[0], point[1] - translationPoint[1]];\n    }\n}\nexport function translatePoints(points, point, addOrSubstract = 'add') {\n    if (isEqualPoint(point, [0, 0])) {\n        return points;\n    }\n    return points.map((p) => translatePoint(p, point, addOrSubstract));\n}\nexport function rotatePoint(point, angle = 0, anchor = undefined, cosAngle, sinAngle) {\n    if (angle === 0 || angle === undefined) {\n        return point;\n    }\n    if (anchor) {\n        return translatePoint(rotatePoint(translatePoint(point, anchor, 'substract'), angle, undefined, cosAngle, sinAngle), anchor);\n    }\n    else {\n        cosAngle = cosAngle || Math.cos(angle);\n        sinAngle = sinAngle || Math.sin(angle);\n        return [\n            point[0] * cosAngle - point[1] * sinAngle,\n            point[0] * sinAngle + point[1] * cosAngle\n        ];\n    }\n}\nexport function rotatePoints(points, angle = 0, anchor = undefined, cosAngle, sinAngle) {\n    if (angle === 0 || angle === undefined) {\n        return points;\n    }\n    cosAngle = cosAngle || Math.cos(angle);\n    sinAngle = sinAngle || Math.sin(angle);\n    return points.map((point) => rotatePoint(point, angle, anchor, cosAngle, sinAngle));\n}\nexport function triangleAngles(triangle) {\n    return [\n        threePointsToAngle(triangle[0], triangle[1], triangle[2]),\n        threePointsToAngle(triangle[1], triangle[2], triangle[0]),\n        threePointsToAngle(triangle[2], triangle[0], triangle[1])\n    ];\n}\n/**\n * Return angle alpha made at point A by points B and C\n */\nexport function threePointsToAngle(pointA, pointB, pointC) {\n    const AB = distance(pointA, pointB);\n    const BC = distance(pointB, pointC);\n    const AC = distance(pointA, pointC);\n    return Math.acos((AB ** 2 + AC ** 2 - BC ** 2) / (2 * AB * AC));\n}\n", "import { conformLineString, conformRing, conformPolygon, conformMultiLineString, conformMultiPolygon, geometryToSvgGeometry } from './geometry.js';\n// Assert\nfunction isGeojsonPointCoordinates(input) {\n    return (Array.isArray(input) &&\n        input.length >= 2 &&\n        input.every((item) => typeof item === 'number'));\n}\nexport function isGeojsonLineStringCoordinates(input) {\n    return Array.isArray(input) && input.every(isGeojsonPointCoordinates);\n}\nexport function isGeojsonRingCoordinates(input) {\n    return Array.isArray(input) && input.every(isGeojsonPointCoordinates);\n}\nexport function isGeojsonPolygonCoordinates(input) {\n    return Array.isArray(input) && input.every(isGeojsonRingCoordinates);\n}\nexport function isGeojsonMultiPointCoordinates(input) {\n    return Array.isArray(input) && input.every(isGeojsonPointCoordinates);\n}\nexport function isGeojsonMultiLineStringCoordinates(input) {\n    return Array.isArray(input) && input.every(isGeojsonLineStringCoordinates);\n}\nexport function isGeojsonMultiPolygonCoordinates(input) {\n    return Array.isArray(input) && input.every(isGeojsonPolygonCoordinates);\n}\nexport function isGeojsonPoint(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        'type' in input &&\n        input.type === 'Point' &&\n        'coordinates' in input &&\n        isGeojsonPointCoordinates(input.coordinates));\n}\nexport function isGeojsonLineString(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        'type' in input &&\n        input.type === 'LineString' &&\n        'coordinates' in input &&\n        isGeojsonLineStringCoordinates(input.coordinates));\n}\nexport function isGeojsonPolygon(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        'type' in input &&\n        input.type === 'Polygon' &&\n        'coordinates' in input &&\n        Array.isArray(input.coordinates) &&\n        isGeojsonPolygonCoordinates(input.coordinates));\n}\nexport function isGeojsonMultiPoint(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        'type' in input &&\n        input.type === 'MultiPoint' &&\n        'coordinates' in input &&\n        isGeojsonMultiPointCoordinates(input.coordinates));\n}\nexport function isGeojsonMultiLineString(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        'type' in input &&\n        input.type === 'MultiLineString' &&\n        'coordinates' in input &&\n        isGeojsonMultiLineStringCoordinates(input.coordinates));\n}\nexport function isGeojsonMultiPolygon(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        'type' in input &&\n        input.type === 'MultiPolygon' &&\n        'coordinates' in input &&\n        Array.isArray(input.coordinates) &&\n        isGeojsonMultiPolygonCoordinates(input.coordinates));\n}\nexport function isGeojsonGeometry(obj) {\n    const isObject = typeof obj === 'object' && obj !== null;\n    const hasStringType = isObject && 'type' in obj && typeof obj.type === 'string';\n    const isValidType = hasStringType &&\n        (obj.type === 'Point' ||\n            obj.type === 'LineString' ||\n            obj.type === 'Polygon' ||\n            obj.type === 'MultiPoint' ||\n            obj.type === 'MultiLineString' ||\n            obj.type === 'MultiPolygon');\n    const hasCoordinatesArray = isObject && 'coordinates' in obj && Array.isArray(obj.coordinates);\n    return isValidType && hasCoordinatesArray;\n}\nexport function isGeojsonMultiGeometry(obj) {\n    const isObject = typeof obj === 'object' && obj !== null;\n    const hasStringType = isObject && 'type' in obj && typeof obj.type === 'string';\n    const isValidType = hasStringType &&\n        (obj.type === 'MultiPoint' ||\n            obj.type === 'MultiLineString' ||\n            obj.type === 'MultiPolygon');\n    const hasCoordinatesArray = isObject && 'coordinates' in obj && Array.isArray(obj.coordinates);\n    return isValidType && hasCoordinatesArray;\n}\n// Convert to Geometry\n// Note: GeoJSON points can have more then two coordiantes\nfunction geojsonPointCoordinatesToPoint(geojsonPointCoordinates) {\n    return geojsonPointCoordinates.slice(0, 2);\n}\nexport function geojsonPointToPoint(geojsonPoint) {\n    return geojsonPointCoordinatesToPoint(geojsonPoint.coordinates);\n}\nexport function geojsonLineStringToLineString(geojsonLineString) {\n    return conformLineString(geojsonLineString.coordinates.map(geojsonPointCoordinatesToPoint));\n}\nexport function geojsonPolygonToRing(geojsonPolygon, close = false) {\n    const outerRing = conformRing(geojsonPolygon.coordinates[0].map(geojsonPointCoordinatesToPoint));\n    return close ? [...outerRing, outerRing[0]] : outerRing;\n}\nexport function geojsonPolygonToPolygon(geojsonPolygon, close = false) {\n    const polygon = conformPolygon(geojsonPolygon.coordinates.map((ring) => ring.map(geojsonPointCoordinatesToPoint)));\n    return close ? polygon.map((ring) => [...ring, ring[0]]) : polygon;\n}\nexport function geojsonMultiPointToMultiPoint(geojsonMultiPoint) {\n    return geojsonMultiPoint.coordinates.map(geojsonPointCoordinatesToPoint);\n}\nexport function geojsonMultiLineStringToMultiLineString(geojsonMultiLineString) {\n    return conformMultiLineString(geojsonMultiLineString.coordinates.map((l) => l.map(geojsonPointCoordinatesToPoint)));\n}\nexport function geojsonMultiPolygonToMultiPolygon(geojsonMultiPolygon, close = false) {\n    const multipolygon = conformMultiPolygon(geojsonMultiPolygon.coordinates.map((p) => p.map((l) => l.map(geojsonPointCoordinatesToPoint))));\n    return close\n        ? multipolygon.map((polygon) => polygon.map((ring) => [...ring, ring[0]]))\n        : multipolygon;\n}\n/**\n * Converts a GeoJSON Geometry to a Geometry\n * @param geojsonGeometry - GeoJSON Geometry\n * @returns Geometry\n */\nexport function geojsonGeometryToGeometry(geojsonGeometry) {\n    if (isGeojsonPoint(geojsonGeometry)) {\n        return geojsonPointToPoint(geojsonGeometry);\n    }\n    else if (isGeojsonLineString(geojsonGeometry)) {\n        return geojsonLineStringToLineString(geojsonGeometry);\n    }\n    else if (isGeojsonPolygon(geojsonGeometry)) {\n        return geojsonPolygonToPolygon(geojsonGeometry);\n    }\n    else if (isGeojsonMultiPoint(geojsonGeometry)) {\n        return geojsonMultiPointToMultiPoint(geojsonGeometry);\n    }\n    else if (isGeojsonMultiLineString(geojsonGeometry)) {\n        return geojsonMultiLineStringToMultiLineString(geojsonGeometry);\n    }\n    else if (isGeojsonMultiPolygon(geojsonGeometry)) {\n        return geojsonMultiPolygonToMultiPolygon(geojsonGeometry);\n    }\n    else {\n        throw new Error('Geometry type not supported');\n    }\n}\n// Convert to SVG\nexport function geojsonGeometryToSvgGeometry(geojsonGeometry) {\n    return geometryToSvgGeometry(geojsonGeometryToGeometry(geojsonGeometry));\n}\n// Wrap Geometry in Feature\nexport function geojsonGeometryToGeojsonFeature(geojsonGeometry, properties) {\n    return {\n        type: 'Feature',\n        properties: properties ? properties : {},\n        geometry: geojsonGeometry\n    };\n}\nexport function geojsonFeaturesToGeojsonFeatureCollection(geojsonFeatures) {\n    if (!Array.isArray(geojsonFeatures)) {\n        geojsonFeatures = [geojsonFeatures];\n    }\n    return {\n        type: 'FeatureCollection',\n        features: geojsonFeatures\n    };\n}\nexport function geojsonGeometriesToGeojsonFeatureCollection(geojsonGeometries, properties) {\n    return {\n        type: 'FeatureCollection',\n        features: geojsonGeometries.map((geometry, i) => properties\n            ? geojsonGeometryToGeojsonFeature(geometry, properties[i])\n            : geojsonGeometryToGeojsonFeature(geometry))\n    };\n}\nexport function geojsonFeatureToGeojsonGeometry(geojsonFeature) {\n    return geojsonFeature.geometry;\n}\nexport function geojsonFeatureCollectionToGeojsonGeometries(geojsonFeatureCollection) {\n    return geojsonFeatureCollection.features.map(geojsonFeatureToGeojsonGeometry);\n}\n// Expand\nexport function expandGeojsonMultiPointToGeojsonPoints(geojsonMultiPoint) {\n    return geojsonMultiPoint.coordinates.map((point) => {\n        return {\n            type: 'Point',\n            coordinates: point\n        };\n    });\n}\nexport function expandGeojsonMultiLineStringToGeojsonLineStrings(geojsonMultiLineString) {\n    return geojsonMultiLineString.coordinates.map((lineString) => {\n        return {\n            type: 'LineString',\n            coordinates: lineString\n        };\n    });\n}\nexport function expandGeojsonMultiPolygonToGeojsonPolygons(geojsonMultiPolygon) {\n    return geojsonMultiPolygon.coordinates.map((polygon) => {\n        return {\n            type: 'Polygon',\n            coordinates: polygon\n        };\n    });\n}\nexport function expandGeojsonMultiGeometryToGeojsonGeometries(geojsonMultiGeometry) {\n    if (isGeojsonMultiPoint(geojsonMultiGeometry)) {\n        return expandGeojsonMultiPointToGeojsonPoints(geojsonMultiGeometry);\n    }\n    else if (isGeojsonMultiLineString(geojsonMultiGeometry)) {\n        return expandGeojsonMultiLineStringToGeojsonLineStrings(geojsonMultiGeometry);\n    }\n    else if (isGeojsonMultiPolygon(geojsonMultiGeometry)) {\n        return expandGeojsonMultiPolygonToGeojsonPolygons(geojsonMultiGeometry);\n    }\n    else {\n        throw new Error('Geometry type not supported');\n    }\n}\n// Contract\nexport function contractGeojsonPointsToGeojsonMultiPoint(geojsonPoints) {\n    return {\n        type: 'MultiPoint',\n        coordinates: geojsonPoints.map((geojsonPoint) => geojsonPoint.coordinates)\n    };\n}\nexport function contractGeojsonLineStringsToGeojsonMultiLineString(geojsonLineStrings) {\n    return {\n        type: 'MultiLineString',\n        coordinates: geojsonLineStrings.map((geojsonLineString) => geojsonLineString.coordinates)\n    };\n}\nexport function contractGeojsonPolygonsToGeojsonMultiPolygon(geojsonPolygons) {\n    return {\n        type: 'MultiPolygon',\n        coordinates: geojsonPolygons.map((geojsonPolygon) => geojsonPolygon.coordinates)\n    };\n}\nexport function contractGeojsonGeometriesToGeojsonMultiGeometry(geojsonGeometries) {\n    if (geojsonGeometries.every(isGeojsonPoint)) {\n        return contractGeojsonPointsToGeojsonMultiPoint(geojsonGeometries);\n    }\n    else if (geojsonGeometries.every(isGeojsonLineString)) {\n        return contractGeojsonLineStringsToGeojsonMultiLineString(geojsonGeometries);\n    }\n    else if (geojsonGeometries.every(isGeojsonPolygon)) {\n        return contractGeojsonPolygonsToGeojsonMultiPolygon(geojsonGeometries);\n    }\n    else {\n        throw new Error('Geometry type not supported');\n    }\n}\nexport function mergeGeojsonFeaturesCollections(geojsonFeatureCollections) {\n    return {\n        type: 'FeatureCollection',\n        features: geojsonFeatureCollections\n            .map((geojsonFeatureCollection) => geojsonFeatureCollection.features)\n            .flat(1)\n    };\n}\n", "import monotoneChainConvexHull from 'monotone-chain-convex-hull';\nimport { isGeojsonGeometry, geojsonGeometryToGeometry } from './geojson.js';\nimport { isPoint, isPolygon, isMultiPolygon, distance } from './geometry.js';\n// Compute\nexport function computeMinMax(values) {\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    for (const value of values) {\n        if (min === undefined) {\n            if (value >= value)\n                min = max = value;\n        }\n        else {\n            if (min > value)\n                min = value;\n            if (max < value)\n                max = value;\n        }\n    }\n    return [min, max];\n}\n// Note: bbox order is minX, minY, maxX, maxY\nexport function computeBbox(points) {\n    if (isPoint(points)) {\n        points = [points];\n    }\n    if (isPolygon(points)) {\n        points = points.flat();\n    }\n    if (isMultiPolygon(points)) {\n        points = points.flat();\n    }\n    if (isGeojsonGeometry(points)) {\n        return computeBbox(geojsonGeometryToGeometry(points));\n    }\n    // TODO: do this without making two new arrays\n    const xs = [];\n    const ys = [];\n    for (const point of points) {\n        xs.push(point[0]);\n        ys.push(point[1]);\n    }\n    const [minX, maxX] = computeMinMax(xs);\n    const [minY, maxY] = computeMinMax(ys);\n    return [minX, minY, maxX, maxY];\n}\nexport function combineBboxes(...bboxes) {\n    if (bboxes.length === 0) {\n        return undefined;\n    }\n    return [\n        Math.min(...bboxes.map((bbox) => bbox[0])),\n        Math.min(...bboxes.map((bbox) => bbox[1])),\n        Math.max(...bboxes.map((bbox) => bbox[2])),\n        Math.max(...bboxes.map((bbox) => bbox[3]))\n    ];\n}\nexport function doBboxesIntersect(bbox0, bbox1) {\n    const isOverlappingInX = bbox0[2] >= bbox1[0] && bbox1[2] >= bbox0[0];\n    const isOverlappingInY = bbox0[3] >= bbox1[1] && bbox1[3] >= bbox0[1];\n    return isOverlappingInX && isOverlappingInY;\n}\nexport function intersectBboxes(bbox0, bbox1) {\n    const minX = Math.max(bbox0[0], bbox1[0]);\n    const maxX = Math.min(bbox0[2], bbox1[2]);\n    const minY = Math.max(bbox0[1], bbox1[1]);\n    const maxY = Math.min(bbox0[3], bbox1[3]);\n    if (minX < maxX && minY < maxY) {\n        return [minX, minY, maxX, maxY];\n    }\n    else {\n        return undefined;\n    }\n}\nexport function pointInBbox(point, bbox) {\n    return doBboxesIntersect([point[0], point[1], point[0], point[1]], bbox);\n}\nexport function bufferBbox(bbox, dist0, dist1) {\n    if (dist1 === undefined) {\n        dist1 = dist0;\n    }\n    return [bbox[0] - dist0, bbox[1] - dist1, bbox[2] + dist0, bbox[3] + dist1];\n}\n// Ratio 2 adds half the current width (or height) both left and right of the current (width or height)\n// so the total width (or height) goes * 2 and the total surface goes * 4\nexport function bufferBboxByRatio(bbox, ratio) {\n    if (ratio === 0) {\n        return bbox;\n    }\n    const size = bboxToSize(bbox);\n    return bufferBbox(bbox, ...size.map((widthOrHeigth) => (widthOrHeigth * ratio) / 2));\n}\n// Transform\n// Returns a rectangle with four points, starting from lower left and going anti-clockwise.\nexport function bboxToRectangle(bbox) {\n    return [\n        [bbox[0], bbox[1]],\n        [bbox[2], bbox[1]],\n        [bbox[2], bbox[3]],\n        [bbox[0], bbox[3]]\n    ];\n}\nexport function bboxToPolygon(bbox) {\n    return [bboxToRectangle(bbox)];\n}\nexport function bboxToLine(bbox) {\n    return [\n        [bbox[0], bbox[1]],\n        [bbox[2], bbox[3]]\n    ];\n}\nexport function bboxToDiameter(bbox) {\n    return distance(bboxToLine(bbox));\n}\nexport function geometryToDiameter(geometry) {\n    return distance(bboxToLine(computeBbox(geometry)));\n}\nexport function bboxToCenter(bbox) {\n    return [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];\n}\nexport function bboxToSize(bbox) {\n    return [bbox[2] - bbox[0], bbox[3] - bbox[1]];\n}\nexport function bboxToResolution(bbox) {\n    return sizeToResolution(bboxToSize(bbox));\n}\n// Approximate results for quadrilaterals, exact for rectangles (e.g. coming from bboxes).\n// A more precise result would require a minimal-covering-rectangle algorithm\n// Or computing and comparing rectangle surfaces\nexport function rectangleToSize(rectangle) {\n    return [\n        0.5 *\n            (distance(rectangle[0], rectangle[1]) +\n                distance(rectangle[2], rectangle[3])),\n        0.5 *\n            (distance(rectangle[1], rectangle[2]) +\n                distance(rectangle[3], rectangle[0]))\n    ];\n}\n// Convex hull\nexport function convexHull(points) {\n    if (points.length === 0) {\n        return undefined;\n    }\n    return monotoneChainConvexHull(points);\n}\n// Sizes and Scales\n/**\n * Compute a size from two scales\n *\n * For unspecified 'fit', the scale is computed based on the surface area derived from the sizes.\n *\n * For specified 'fit':\n *\n * Example for square rectangles '*' and '+':\n *\n * 'contain' where '*' contains '.'\n * (in the first image size0 is relatively wider)\n *\n *                ****\n *                *  *\n *   **....**     ....\n *   * .  . *     .  .\n *   **....**     ....\n *                *  *\n *                ****\n *\n *\n * 'cover' where '*' is covered by '.'\n * (in the first image size0 is relatively wider)\n *\n *                ....\n *                .  .\n *   ..****..     ****\n *   . *  * .     *  *\n *   ..****..     ****\n *                .  .\n *                ....\n *\n * @export\n * @param size0 - first size\n * @param size1 - second size\n * @param fit - fit\n */\nexport function sizesToScale(size0, size1, fit) {\n    if (!fit) {\n        return Math.sqrt((size0[0] * size0[1]) / (size1[0] * size1[1]));\n    }\n    else if (fit === 'contain') {\n        return size0[0] / size0[1] >= size1[0] / size1[1] // size0 is relatively wider\n            ? size0[0] / size1[0]\n            : size0[1] / size1[1];\n    }\n    else {\n        // fit = 'cover'\n        return size0[0] / size0[1] >= size1[0] / size1[1] // size0 is relatively wider\n            ? size0[1] / size1[1]\n            : size0[0] / size1[0];\n    }\n}\nexport function scaleSize(size, scale) {\n    return [size[0] * scale, size[1] * scale];\n}\nexport function sizeToResolution(size) {\n    return size[0] * size[1];\n}\nexport function sizeToCenter(size) {\n    return [size[0] / 2, size[1] / 2];\n}\nexport function sizeToBbox(size) {\n    return [0, 0, ...size];\n}\nexport function sizeToRectangle(size) {\n    return bboxToRectangle(sizeToBbox(size));\n}\nexport function bboxesToScale(bbox0, bbox1) {\n    return sizesToScale(bboxToSize(bbox0), bboxToSize(bbox1));\n}\nexport function rectanglesToScale(rectangle0, rectangle1) {\n    return sizesToScale(rectangleToSize(rectangle0), rectangleToSize(rectangle1));\n}\n", "export function getPropertyFromCacheOrComputation(cache, key, computation, checkUse = () => true, checkStore = () => true) {\n    if (cache.has(key) && checkUse(cache.get(key))) {\n        return cache.get(key);\n    }\n    else {\n        const result = computation();\n        if (checkStore(result)) {\n            cache.set(key, result);\n        }\n        return result;\n    }\n}\nexport function getPropertyFromDoubleCacheOrComputation(cache, key0, key1, computation, checkUse = () => true, checkStore = () => true) {\n    if (cache.get(key0)?.has(key1) && checkUse(cache.get(key0)?.get(key1))) {\n        return cache.get(key0)?.get(key1);\n    }\n    else {\n        const result = computation();\n        if (checkStore(result)) {\n            if (!cache.get(key0)) {\n                cache.set(key0, new Map());\n            }\n            cache.get(key0)?.set(key1, result);\n        }\n        return result;\n    }\n}\nexport function getPropertyFromTripleCacheOrComputation(cache, key0, key1, key2, computation, checkUse = () => true, checkStore = () => true) {\n    if (cache.get(key0)?.get(key1)?.has(key2) &&\n        checkUse(cache.get(key0)?.get(key1)?.get(key2))) {\n        return cache.get(key0)?.get(key1)?.get(key2);\n    }\n    else {\n        const result = computation();\n        if (checkStore(result)) {\n            if (!cache.get(key0)) {\n                cache.set(key0, new Map());\n            }\n            if (!cache.get(key0)?.get(key1)) {\n                cache.get(key0)?.set(key1, new Map());\n            }\n            cache.get(key0)?.get(key1)?.set(key2, result);\n        }\n        return result;\n    }\n}\n", "const hexCharacters = 'a-f\\\\d';\nconst match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;\nconst match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;\nconst nonHexChars = new RegExp(`[^#${hexCharacters}]`, 'gi');\nconst validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, 'i');\n\nexport default function hexRgb(hex, options = {}) {\n\tif (typeof hex !== 'string' || nonHexChars.test(hex) || !validHexSize.test(hex)) {\n\t\tthrow new TypeError('Expected a valid hex string');\n\t}\n\n\thex = hex.replace(/^#/, '');\n\tlet alphaFromHex = 1;\n\n\tif (hex.length === 8) {\n\t\talphaFromHex = Number.parseInt(hex.slice(6, 8), 16) / 255;\n\t\thex = hex.slice(0, 6);\n\t}\n\n\tif (hex.length === 4) {\n\t\talphaFromHex = Number.parseInt(hex.slice(3, 4).repeat(2), 16) / 255;\n\t\thex = hex.slice(0, 3);\n\t}\n\n\tif (hex.length === 3) {\n\t\thex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n\t}\n\n\tconst number = Number.parseInt(hex, 16);\n\tconst red = number >> 16;\n\tconst green = (number >> 8) & 255;\n\tconst blue = number & 255;\n\tconst alpha = typeof options.alpha === 'number' ? options.alpha : alphaFromHex;\n\n\tif (options.format === 'array') {\n\t\treturn [red, green, blue, alpha];\n\t}\n\n\tif (options.format === 'css') {\n\t\tconst alphaString = alpha === 1 ? '' : ` / ${Number((alpha * 100).toFixed(2))}%`;\n\t\treturn `rgb(${red} ${green} ${blue}${alphaString})`;\n\t}\n\n\treturn {red, green, blue, alpha};\n}\n", "// TODO: Remove this ignore comment.\n// eslint-disable-next-line no-mixed-operators\nconst toHex = (red, green, blue, alpha) => ((blue | green << 8 | red << 16) | 1 << 24).toString(16).slice(1) + alpha;\n\nexport default function rgbHex(red, green, blue, alpha) {\n\tlet isPercent = (red + (alpha || '')).toString().includes('%');\n\n\tif (typeof red === 'string' && !green) { // Single string parameter.\n\t\tconst parsed = parseCssRgbString(red);\n\t\tif (!parsed) {\n\t\t\tthrow new TypeError('Invalid or unsupported color format.');\n\t\t}\n\n\t\tisPercent = false;\n\t\t[red, green, blue, alpha] = parsed;\n\t} else if (alpha !== undefined) {\n\t\talpha = Number.parseFloat(alpha);\n\t}\n\n\tif (typeof red !== 'number' ||\n\t\ttypeof green !== 'number' ||\n\t\ttypeof blue !== 'number' ||\n\t\tred > 255 ||\n\t\tgreen > 255 ||\n\t\tblue > 255\n\t) {\n\t\tthrow new TypeError('Expected three numbers below 256');\n\t}\n\n\tif (typeof alpha === 'number') {\n\t\tif (!isPercent && alpha >= 0 && alpha <= 1) {\n\t\t\talpha = Math.round(255 * alpha);\n\t\t} else if (isPercent && alpha >= 0 && alpha <= 100) {\n\t\t\talpha = Math.round(255 * alpha / 100);\n\t\t} else {\n\t\t\tthrow new TypeError(`Expected alpha value (${alpha}) as a fraction or percentage`);\n\t\t}\n\n\t\talpha = (alpha | 1 << 8).toString(16).slice(1); // eslint-disable-line no-mixed-operators\n\t} else {\n\t\talpha = '';\n\t}\n\n\treturn toHex(red, green, blue, alpha);\n}\n\nconst parseCssRgbString = input => {\n\tconst parts = input.replace(/rgba?\\(([^)]+)\\)/, '$1').split(/[,\\s/]+/).filter(Boolean);\n\tif (parts.length < 3) {\n\t\treturn;\n\t}\n\n\tconst parseValue = (value, max) => {\n\t\tvalue = value.trim();\n\n\t\tif (value.endsWith('%')) {\n\t\t\treturn Math.min(Number.parseFloat(value) * max / 100, max);\n\t\t}\n\n\t\treturn Math.min(Number.parseFloat(value), max);\n\t};\n\n\tconst red = parseValue(parts[0], 255);\n\tconst green = parseValue(parts[1], 255);\n\tconst blue = parseValue(parts[2], 255);\n\tlet alpha;\n\n\tif (parts.length === 4) {\n\t\talpha = parseValue(parts[3], 1);\n\t}\n\n\treturn [red, green, blue, alpha];\n};\n", "import hexRgb from 'hex-rgb';\nimport rgbHex from 'rgb-hex';\n/**\n * Convert RBG to HEX\n * @param rgb - RGB color array, e.g. [0, 51, 255]\n * @returns HEX string, e.g. '#0033ff'\n */\nexport function rgbToHex(color) {\n    return '#' + rgbHex(...color);\n}\n/**\n * Convert RBGA to HEX\n * @param rgb - RGBA color array, e.g. [0, 51, 255, 255]\n * @returns HEX string, e.g. '#0033ffff'\n */\nexport function rgbaToHex(color) {\n    return '#' + rgbHex(...color);\n}\n/**\n * Convert HEX to RGB\n * @param hex - HEX string, e.g. '#0033ff'\n * @returns RGB, e.g. [0, 51, 255]\n */\nexport function hexToRgb(hex) {\n    return hexRgb(hex, { format: 'array' }).slice(0, 3);\n}\n/**\n * Convert HEX to RGB\n * @param hex - HEX string, e.g. '#0033ffff'\n * @returns RGB, e.g. [0, 51, 255, 255]\n */\nexport function hexToRgba(hex) {\n    const color = hexRgb(hex, { format: 'array' });\n    if (color.length < 4) {\n        color[3] = 255;\n    }\n    return color;\n}\n/**\n * Convert HEX to RGB, and sets the transparency to 255\n * @param hex - HEX string, e.g. '#0033ffcc'\n * @returns RGB, e.g. [0, 51, 255, 255]\n */\nexport function hexToOpaqueRgba(hex) {\n    const color = hexRgb(hex, { format: 'array' });\n    color[3] = 255;\n    return color;\n}\n/**\n * Convert hex to fractional RGB\n * @param hex - hex string, e.g. '#0033ff'\n * @returns Fractional RGB, e.g. [0, 0.2, 1]\n */\nexport function hexToFractionalRgb(hex) {\n    return hexToRgb(hex).map((c) => c / 255);\n}\n/**\n * Convert hex to fractional RGBA\n * @param hex - hex string, e.g. '#0033ffff'\n * @returns Fractional RGB, e.g. [0, 0.2, 1, 1]\n */\nexport function hexToFractionalRgba(hex) {\n    return hexToRgba(hex).map((c) => c / 255);\n}\n/**\n * Convert hex to fractional RGBA, and sets the transparency to 1\n * @param hex - hex string, e.g. '#0033ffcc'\n * @returns Fractional RGB, e.g. [0, 0.2, 1, 1]\n */\nexport function hexToFractionalOpaqueRgba(hex) {\n    return hexToOpaqueRgba(hex).map((c) => c / 255);\n}\n", "export function degreesToRadians(degrees) {\n    return degrees * (Math.PI / 180);\n}\n// Define vanilla groupBy function, since official one is only baseline 2024\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/groupBy\n// Vanilla code from https://stackoverflow.com/a/62765924/2386673\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function groupBy(arr, key) {\n    return arr.reduce((groups, item) => {\n        ;\n        (groups[key(item)] ||= []).push(item);\n        return groups;\n    }, {});\n}\n// Note: this checks equality of the object\n// which is only a good idea for primitive types (string, number), not JSON objects\nexport function isEqualArray(array0, array1, isEqualObject = (t0, t1) => t0 == t1) {\n    if (array0.length !== array1.length) {\n        return false;\n    }\n    for (let i = 0; i < array0.length; i++) {\n        if (!isEqualObject(array0[i], array1[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n// Returns objects in array0 that are not in array1\nexport function arrayDifference(array0, array1, isEqualObject = (t0, t1) => t0 == t1) {\n    const result = [];\n    for (let i = 0; i < array0.length; i++) {\n        let found = false;\n        for (let j = 0; j < array1.length; j++) {\n            if (isEqualObject(array0[i], array1[j])) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            result.push(array0[i]);\n        }\n    }\n    return result;\n}\nexport function arrayUnique(array, isEqualObject = (t0, t1) => t0 == t1) {\n    const result = [];\n    for (let i = 0; i < array.length; i++) {\n        let found = false;\n        for (let j = 0; j < i; j++) {\n            if (isEqualObject(array[i], array[j])) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            result.push(array[i]);\n        }\n    }\n    return result;\n}\nexport function arrayRepeated(array, isEqualObject = (t0, t1) => t0 == t1) {\n    const result = [];\n    for (let i = 0; i < array.length; i++) {\n        let found = false;\n        for (let j = 0; j < i; j++) {\n            if (isEqualObject(array[i], array[j])) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            result.push(array[i]);\n        }\n    }\n    return result;\n}\n// TODO: replace with Set subset once available\n// Note: this checks equality of the object\n// which is only a good idea for primitive types (string, number), not JSON objects\nexport function subSetArray(arr1, arr2) {\n    for (let i = 0; i < arr2.length; i++) {\n        if (arr1.indexOf(arr2[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n// TODO: Replace with Set equality once available\n// Note: this checks equality of the object\n// which is only a good idea for primitive types (string, number), not JSON objects\nexport function equalSet(set1, set2) {\n    if (!set1 || !set2) {\n        return false;\n    }\n    if (set1.size !== set2.size) {\n        return false;\n    }\n    return [...set1].every((x) => set2.has(x));\n}\nexport function maxOfNumberOrUndefined(number1, number2) {\n    if (number1 !== undefined && number2 !== undefined) {\n        return Math.max(number1, number2);\n    }\n    else if (number1 !== undefined) {\n        return number1;\n    }\n    else if (number2 !== undefined) {\n        return number2;\n    }\n}\nexport function isValidHttpUrl(string) {\n    let url;\n    try {\n        url = new URL(string);\n    }\n    catch (_) {\n        return false;\n    }\n    return url.protocol === 'http:' || url.protocol === 'https:';\n}\n", "// TODO: the fullResourceMask is available directly in WarpedMap class!\n// This also means this function can be removed from stdlib.\nexport function getFullResourceMask(imageWidth, imageHeight) {\n    return [\n        [0, 0],\n        [imageWidth, 0],\n        [imageWidth, imageHeight],\n        [0, imageHeight]\n    ];\n}\n", "import { isEqualArray } from './main.js';\n/**\n * Create and fill a ArrayMatrix: an Arrays of Arrays, that can later be loaded as a ml-matrix Matrix\n */\nexport function newArrayMatrix(rows, cols, value = 0) {\n    if (rows <= 0 || cols <= 0) {\n        throw new Error('Empty ArrayMatrix not supported');\n    }\n    return Array.from(Array(rows), (_) => Array(cols).fill(value));\n}\nexport function arrayMatrixSize(arrayMatrix) {\n    if (arrayMatrix.length === 0) {\n        throw new Error('ArrayMatrix may not be empty, but rows are empty');\n    }\n    const rowLengths = arrayMatrix.map((row) => row.length);\n    if (rowLengths.some((rowLength) => rowLength === 0)) {\n        throw new Error('ArrayMatrix may not be empty, but at least one row is empty');\n    }\n    if (!rowLengths.every((rowLength) => rowLength === rowLengths[0])) {\n        throw new Error('Rows of unequal length');\n    }\n    const rows = arrayMatrix.length;\n    const cols = rowLengths[0];\n    return [rows, cols];\n}\nexport function shallowCopyArrayMatrix(arrayMatrix) {\n    return arrayMatrix.map((row) => [...row]);\n}\n// Slice specific rows and columns of an arrayMatrix.\n// Just like slice, this returns a copy!\nexport function sliceArrayMatrix(arrayMatrix, rowsStart, colsStart, rowsEnd, colsEnd) {\n    return arrayMatrix\n        .slice(rowsStart, rowsEnd)\n        .map((row) => row.slice(colsStart, colsEnd));\n}\n// Get a submatrix at specified rows and columns.\n// This is more flexible the the range, like in sliceArrayMatrix.\nexport function subArrayMatrix(arrayMatrix, rows, cols) {\n    const size = [rows.length, cols.length];\n    const result = newArrayMatrix(...size);\n    for (let i = 0; i < size[0]; i++) {\n        for (let j = 0; j < size[1]; j++) {\n            result[i][j] = arrayMatrix[rows[i]][cols[j]];\n        }\n    }\n    return result;\n}\n// Pointwise multiplication. For Matrix multiplication, see ml-matrix\nexport function multiplyArrayMatrix(arrayMatrix, factor) {\n    const size = arrayMatrixSize(arrayMatrix);\n    const result = newArrayMatrix(...size);\n    for (let i = 0; i < size[0]; i++) {\n        for (let j = 0; j < size[1]; j++) {\n            result[i][j] = factor * arrayMatrix[i][j];\n        }\n    }\n    return result;\n}\n// Pastes a arrayMatrix inside an arrayMatrix at a specific location.\n// Returns a copy with the pasted subArray.\nexport function pasteArrayMatrix(arrayMatrix, rowsStart, colsStart, subArrayMatrix) {\n    const subSize = arrayMatrixSize(subArrayMatrix);\n    const result = shallowCopyArrayMatrix(arrayMatrix);\n    for (let i = 0; i < subSize[0]; i++) {\n        for (let j = 0; j < subSize[1]; j++) {\n            result[rowsStart + i][colsStart + j] = subArrayMatrix[i][j];\n        }\n    }\n    return result;\n}\nexport function transposeArrayMatrix(arrayMatrix) {\n    return arrayMatrix[0].map((_, colIndex) => arrayMatrix.map((row) => row[colIndex]));\n}\nexport function newBlockArrayMatrix(blocks, emptyValue = 0) {\n    const size = arrayMatrixSize(blocks);\n    const sizesArrayMatrix = blocks.map((row) => row.map((block) => arrayMatrixSize(block)));\n    const rowsArrayMatrix = sizesArrayMatrix.map((row) => row.map((dims) => dims[0]));\n    const transposedRowsArrayMatrix = transposeArrayMatrix(rowsArrayMatrix);\n    const rowsArray = transposedRowsArrayMatrix[0];\n    if (!transposedRowsArrayMatrix.every((array) => isEqualArray(array, transposedRowsArrayMatrix[0]))) {\n        throw new Error('The blocks, by block column, must have the same sequence of rows.');\n    }\n    const rowsTrailingCumulativeArray = [];\n    let sum = 0;\n    rowsArray.forEach((e) => {\n        rowsTrailingCumulativeArray.push(sum);\n        sum = sum + e;\n    });\n    const rowsCumulative = sum;\n    const colsArrayMatrix = sizesArrayMatrix.map((row) => row.map((dims) => dims[1]));\n    const colsArray = colsArrayMatrix[0];\n    if (!colsArrayMatrix.every((array) => isEqualArray(array, colsArray))) {\n        throw new Error('The blocks, by block row, must have the same sequence of columns.');\n    }\n    const colsTrailingCumulativeArray = [];\n    sum = 0;\n    colsArrayMatrix[0].forEach((e) => {\n        colsTrailingCumulativeArray.push(sum);\n        sum = sum + e;\n    });\n    const colsCumulative = sum;\n    let result = newArrayMatrix(rowsCumulative, colsCumulative, emptyValue);\n    for (let i = 0; i < size[0]; i++) {\n        for (let j = 0; j < size[1]; j++) {\n            result = pasteArrayMatrix(result, rowsTrailingCumulativeArray[i], rowsTrailingCumulativeArray[j], blocks[i][j]);\n        }\n    }\n    return result;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function mergeOptions(options0, options1) {\n    // In general options1 extends options0\n    // Using this over mergePartialOption() assures that the output type will be at least Option0\n    // This function serves two purposes:\n    // 1) Speedup: spreading is a little expensive, so it checks if necessary first\n    // (e.g. it was previously executed for every point in transform,\n    // where this was a 50% speed increase when transforming a lot of points\n    // 2) It allows option1 to be undefined, which simplifies handing over a simple spread\n    if (!options1) {\n        return options0;\n    }\n    return {\n        ...options0,\n        ...options1\n    };\n}\nexport function mergeOptionsUnlessUndefined(options0, options1) {\n    if (!options1) {\n        return options0;\n    }\n    // Only overwrite properties that are not undefined\n    for (const key in options1) {\n        const value = options1[key];\n        if (value !== undefined) {\n            ;\n            options0[key] = value;\n        }\n    }\n    return options0;\n}\n// // Saving this here, may be useful later\n// export function mergeOptionsDeep<\n//   Option0 extends Record<string, any>,\n//   Option1 extends Record<string, any>\n// >(option0: Option0, option1: Option1): Option0 & Option1 {\n//   // Create a new object to avoid mutating either input\n//   const output = { ...option0 } as Record<string, any>\n//   if (isObject(option0) && isObject(option1)) {\n//     Object.keys(option1).forEach((key) => {\n//       const sourceValue = option1[key as keyof Option1]\n//       if (isObject(sourceValue)) {\n//         // If both target and source have the same key and both are objects, recursively merge\n//         if (key in option0 && isObject(option0[key as keyof Option0])) {\n//           output[key] = mergeOptionsDeep(\n//             option0[key as keyof Option0] as Record<string, any>,\n//             sourceValue as Record<string, any>\n//           )\n//         } else {\n//           // Otherwise just clone the source object\n//           output[key] = { ...sourceValue }\n//         }\n//       } else {\n//         // For non-object values, simply copy from source\n//         output[key] = sourceValue\n//       }\n//     })\n//   }\n//   return output as Option0 & Option1\n// }\nexport function mergePartialOptions(...partialOptionsArray) {\n    const definedPartialOptionsArray = partialOptionsArray.filter((partialOptions) => partialOptions !== undefined && partialOptions !== null);\n    if (definedPartialOptionsArray.length === 0) {\n        return {};\n    }\n    else if (definedPartialOptionsArray.length === 1) {\n        return definedPartialOptionsArray[0];\n    }\n    else {\n        // This spreads out eacht of the partialOptions\n        return Object.assign({}, ...definedPartialOptionsArray);\n    }\n}\n", "function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };", "import { locate } from 'locate-character';\n\nconst validNameCharacters = /[a-zA-Z0-9:_-]/;\nconst whitespace = /[\\s\\t\\r\\n]/;\nconst quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n\tlet result = '';\n\twhile (i--) result += str;\n\treturn result;\n}\n\nexport function parse(source) {\n\tlet header = '';\n\tlet stack = [];\n\n\tlet state = metadata;\n\tlet currentElement = null;\n\tlet root = null;\n\n\tfunction error(message) {\n\t\tconst { line, column } = locate(source, i);\n\t\tconst before = source.slice(0, i);\n\t\tconst beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n\t\tconst after = source.slice(i);\n\t\tconst afterLine = /.*(\\n|$)/.exec(after)[0];\n\n\t\tconst snippet = `${beforeLine}${afterLine}\\n${repeat(' ', beforeLine.length)}^`;\n\n\t\tthrow new Error(\n\t\t\t`${message} (${line}:${column}). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n${snippet}`\n\t\t);\n\t}\n\n\tfunction metadata() {\n\t\twhile ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n\t\t\theader += source[i++];\n\t\t}\n\n\t\treturn neutral();\n\t}\n\n\tfunction neutral() {\n\t\tlet text = '';\n\t\twhile (i < source.length && source[i] !== '<') text += source[i++];\n\n\t\tif (/\\S/.test(text)) {\n\t\t\tcurrentElement.children.push({ type: 'text', value: text });\n\t\t}\n\n\t\tif (source[i] === '<') {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag() {\n\t\tconst char = source[i];\n\n\t\tif (char === '?') return neutral; // <?xml...\n\n\t\tif (char === '!') {\n\t\t\tif (source.slice(i + 1, i + 3) === '--') return comment;\n\t\t\tif (source.slice(i + 1, i + 8) === '[CDATA[') return cdata;\n\t\t\tif (/doctype/i.test(source.slice(i + 1, i + 8))) return neutral;\n\t\t}\n\n\t\tif (char === '/') return closingTag;\n\n\t\tconst tagName = getName();\n\n\t\tconst element = {\n\t\t\ttype: 'element',\n\t\t\ttagName,\n\t\t\tproperties: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (currentElement) {\n\t\t\tcurrentElement.children.push(element);\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tlet attribute;\n\t\twhile (i < source.length && (attribute = getAttribute())) {\n\t\t\telement.properties[attribute.name] = attribute.value;\n\t\t}\n\n\t\tlet selfClosing = false;\n\n\t\tif (source[i] === '/') {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tif (!selfClosing) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push(element);\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment() {\n\t\tconst index = source.indexOf('-->', i);\n\t\tif (!~index) error('expected -->');\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction cdata() {\n\t\tconst index = source.indexOf(']]>', i);\n\t\tif (!~index) error('expected ]]>');\n\n\t\tcurrentElement.children.push(source.slice(i + 7, index));\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag() {\n\t\tconst tagName = getName();\n\n\t\tif (!tagName) error('Expected tag name');\n\n\t\tif (tagName !== currentElement.tagName) {\n\t\t\terror(`Expected closing tag </${tagName}> to match opening tag <${currentElement.tagName}>`);\n\t\t}\n\n\t\tallowSpaces();\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[stack.length - 1];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName() {\n\t\tlet name = '';\n\t\twhile (i < source.length && validNameCharacters.test(source[i])) name += source[i++];\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute() {\n\t\tif (!whitespace.test(source[i])) return null;\n\t\tallowSpaces();\n\n\t\tconst name = getName();\n\t\tif (!name) return null;\n\n\t\tlet value = true;\n\n\t\tallowSpaces();\n\t\tif (source[i] === '=') {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif (!isNaN(value) && value.trim() !== '') value = +value; // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name, value };\n\t}\n\n\tfunction getAttributeValue() {\n\t\treturn quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue() {\n\t\tlet value = '';\n\t\tdo {\n\t\t\tconst char = source[i];\n\t\t\tif (char === ' ' || char === '>' || char === '/') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while (i < source.length);\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue() {\n\t\tconst quotemark = source[i++];\n\n\t\tlet value = '';\n\t\tlet escaped = false;\n\n\t\twhile (i < source.length) {\n\t\t\tconst char = source[i++];\n\t\t\tif (char === quotemark && !escaped) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (char === '\\\\' && !escaped) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? `\\\\${char}` : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces() {\n\t\twhile (i < source.length && whitespace.test(source[i])) i += 1;\n\t}\n\n\tlet i = metadata.length;\n\twhile (i < source.length) {\n\t\tif (!state) error('Unexpected character');\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif (state !== neutral) {\n\t\terror('Unexpected end of input');\n\t}\n\n\tif (root.tagName === 'svg') root.metadata = header;\n\treturn {\n\t\ttype: 'root',\n\t\tchildren: [root]\n\t};\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { parse } from 'svg-parser';\n// Assert\nexport function isSvgCircle(input) {\n    return input.type === 'circle';\n}\nexport function isSvgLine(input) {\n    return input.type === 'line';\n}\nexport function isSvgPolyLine(input) {\n    return input.type === 'polyline';\n}\nexport function isSvgRect(input) {\n    return input.type === 'rect';\n}\nexport function isSvgPolygon(input) {\n    return input.type === 'polygon';\n}\n// Read from string\nexport function* stringToSvgGeometriesGenerator(svg) {\n    function* helper(node) {\n        if ('children' in node) {\n            for (const childNode of node.children) {\n                if (typeof childNode !== 'string') {\n                    yield* helper(childNode);\n                }\n            }\n        }\n        yield node;\n    }\n    const parsedSvg = parse(svg);\n    for (const node of helper(parsedSvg)) {\n        if ('tagName' in node) {\n            if (node.tagName !== 'svg' && node.tagName !== 'g') {\n                const geometry = getNodeSvgGeometry(node);\n                if (geometry) {\n                    yield geometry;\n                }\n            }\n        }\n    }\n}\nfunction getNodeSvgGeometry(node) {\n    const tag = node?.tagName?.toLowerCase();\n    if (tag === 'circle') {\n        return {\n            type: 'circle',\n            coordinates: [\n                getNodeNumberProperty(node, 'cx'),\n                getNodeNumberProperty(node, 'cy')\n            ]\n        };\n    }\n    else if (tag === 'line') {\n        return {\n            type: 'line',\n            coordinates: [\n                [getNodeNumberProperty(node, 'x1'), getNodeNumberProperty(node, 'y1')],\n                [getNodeNumberProperty(node, 'x2'), getNodeNumberProperty(node, 'y2')]\n            ]\n        };\n    }\n    else if (tag === 'polyline') {\n        return {\n            type: 'polyline',\n            coordinates: getNodePoints(node)\n        };\n    }\n    else if (tag === 'polygon') {\n        return {\n            type: 'polygon',\n            coordinates: getNodePoints(node)\n        };\n    }\n    else if (tag === 'rect') {\n        return {\n            type: 'rect',\n            coordinates: [\n                [getNodeNumberProperty(node, 'x'), getNodeNumberProperty(node, 'y')],\n                [\n                    getNodeNumberProperty(node, 'x') +\n                        getNodeNumberProperty(node, 'width'),\n                    getNodeNumberProperty(node, 'y')\n                ],\n                [\n                    getNodeNumberProperty(node, 'x') +\n                        getNodeNumberProperty(node, 'width'),\n                    getNodeNumberProperty(node, 'y') +\n                        getNodeNumberProperty(node, 'height')\n                ],\n                [\n                    getNodeNumberProperty(node, 'x'),\n                    getNodeNumberProperty(node, 'y') +\n                        getNodeNumberProperty(node, 'height')\n                ],\n                [getNodeNumberProperty(node, 'x'), getNodeNumberProperty(node, 'y')]\n            ]\n        };\n    }\n    else {\n        throw new Error(`Unsupported SVG element: ${tag}`);\n    }\n}\nfunction getNodeNumberProperty(node, prop) {\n    const value = node?.properties?.[prop];\n    return Number(value) || 0;\n}\nfunction getNodePoints(node) {\n    const points = node?.properties?.points;\n    if (points) {\n        return String(points)\n            .trim()\n            .split(/\\s+/)\n            .map((coordStr) => {\n            const coord = coordStr.split(',').map((numberStr) => Number(numberStr));\n            return [coord[0], coord[1]];\n        });\n    }\n    return [];\n}\nfunction pointsToString(coordinates) {\n    return coordinates.map((coordinate) => coordinate.join(',')).join(' ');\n}\n// Convert to String\nexport function svgGeometriesToSvgString(geometries) {\n    return `<svg xmlns=\"http://www.w3.org/2000/svg\">\n  ${geometries.map(svgGeometryToString).join('\\n')}\n</svg>`;\n}\nexport function svgGeometryToString(geometry) {\n    if (geometry.type === 'circle') {\n        return elementToString('circle', {\n            ...geometry.attributes,\n            cx: geometry.coordinates[0],\n            cy: geometry.coordinates[1]\n        });\n    }\n    else if (geometry.type === 'line') {\n        return elementToString('line', {\n            ...geometry.attributes,\n            x1: geometry.coordinates[0][0],\n            y1: geometry.coordinates[0][1],\n            x2: geometry.coordinates[1][0],\n            y2: geometry.coordinates[1][1]\n        });\n    }\n    else if (geometry.type === 'polyline') {\n        return elementToString('polyline', {\n            ...geometry.attributes,\n            points: pointsToString(geometry.coordinates)\n        });\n    }\n    else if (geometry.type === 'polygon') {\n        return elementToString('polygon', {\n            ...geometry.attributes,\n            points: pointsToString(geometry.coordinates)\n        });\n    }\n    else if (geometry.type === 'rect') {\n        return elementToString('rect', {\n            ...geometry.attributes,\n            x: geometry.coordinates[0][0],\n            y: geometry.coordinates[0][1],\n            width: geometry.coordinates[1][0] - geometry.coordinates[0][0],\n            height: geometry.coordinates[2][1] - geometry.coordinates[0][1]\n        });\n    }\n    else {\n        throw new Error('Unknown SVG element');\n    }\n}\nfunction elementToString(tag, attributes) {\n    const attributeStrings = Object.entries(attributes).map(([key, value]) => `${key}=\"${value}\"`);\n    return `<${tag} ${attributeStrings.join(' ')} />`;\n}\nexport function mapToResourceMaskSvgPolygon(map) {\n    return {\n        type: 'polygon',\n        attributes: {\n            'data-image-id': encodeURIComponent(map.resource.id)\n        },\n        coordinates: map.resourceMask\n    };\n}\n/**\n * Convert a SVG Geometry to Geometry\n *\n * Note: Multi-geometries are not supported\n *\n * @param svgGeometry - SVG Geometry\n * @returns Geometry\n */\nexport function svgGeometryToGeometry(svgGeometry) {\n    if (isSvgCircle(svgGeometry)) {\n        return svgGeometry.coordinates;\n    }\n    else if (isSvgLine(svgGeometry)) {\n        return svgGeometry.coordinates;\n    }\n    else if (isSvgPolyLine(svgGeometry)) {\n        return svgGeometry.coordinates;\n    }\n    else if (isSvgRect(svgGeometry)) {\n        return [svgGeometry.coordinates];\n    }\n    else if (isSvgPolygon(svgGeometry)) {\n        return [svgGeometry.coordinates];\n    }\n    else {\n        throw new Error(`Unsupported SVG geometry`);\n    }\n}\n", "import { conformPolygon, isEqualPoint } from './geometry.js';\nimport { arrayDifference, arrayUnique } from './main.js';\nconst EPSILON = 0;\n// Find self-intersections in ring\n// From https://github.com/mclaeysb/geojson-polygon-self-intersections\nexport function polygonSelfIntersectionPoints(polygon, options) {\n    const intersectionPoints = [];\n    polygon = conformPolygon(polygon);\n    polygon = polygon.map((ring) => [...ring, ring[0]]);\n    for (let ringIndex0 = 0; ringIndex0 < polygon.length; ringIndex0++) {\n        for (let lineIndex0 = 0; lineIndex0 < polygon[ringIndex0].length - 1; lineIndex0++) {\n            for (let ringIndex1 = ringIndex0; ringIndex1 < polygon.length; ringIndex1++) {\n                for (let lineIndex1 = lineIndex0 + 1; lineIndex1 < polygon[ringIndex1].length - 1; lineIndex1++) {\n                    const line0 = [\n                        polygon[ringIndex0][lineIndex0],\n                        polygon[ringIndex0][lineIndex0 + 1]\n                    ];\n                    const line1 = [\n                        polygon[ringIndex1][lineIndex1],\n                        polygon[ringIndex1][lineIndex1 + 1]\n                    ];\n                    const intersectionPoint = linesIntersectionPoint(line0, line1, options);\n                    if (intersectionPoint) {\n                        intersectionPoints.push(intersectionPoint);\n                    }\n                }\n            }\n        }\n    }\n    const selfIntersectionPoints = arrayDifference(intersectionPoints, polygon.flat(), isEqualPoint);\n    return arrayUnique(selfIntersectionPoints, isEqualPoint);\n}\nexport function linesIntersectionPoint(line0, line1, options) {\n    options = {\n        reportVertexOnVertex: false,\n        reportVertexOnEdge: false,\n        ...options\n    };\n    const intersectionPoint = prolongedLinesIntersectionPoint(line0, line1);\n    if (intersectionPoint === undefined)\n        return undefined; // discard parallels and coincidence\n    let frac0, frac1;\n    if (line0[1][0] != line0[0][0]) {\n        frac0 = (intersectionPoint[0] - line0[0][0]) / (line0[1][0] - line0[0][0]);\n    }\n    else {\n        frac0 = (intersectionPoint[1] - line0[0][1]) / (line0[1][1] - line0[0][1]);\n    }\n    if (line1[1][0] != line1[0][0]) {\n        frac1 = (intersectionPoint[0] - line1[0][0]) / (line1[1][0] - line1[0][0]);\n    }\n    else {\n        frac1 = (intersectionPoint[1] - line1[0][1]) / (line1[1][1] - line1[0][1]);\n    }\n    // There are roughly three cases we need to deal with.\n    // 1. If at least one of the fracs lies outside [0,1], there is no intersection.\n    if (isOutside(frac0, options.epsilon) || isOutside(frac1, options.epsilon)) {\n        return undefined;\n    }\n    // 2. If both are either exactly 0 or exactly 1, this is not an intersection but just\n    // two edge segments sharing a common vertex.\n    if (options.reportVertexOnVertex &&\n        isBoundaryCase(frac0, options.epsilon) &&\n        isBoundaryCase(frac1, options.epsilon)) {\n        return intersectionPoint;\n    }\n    // 3. If only one of the fractions is exactly 0 or 1, this is\n    // a vertex-on-edge situation.\n    if (options.reportVertexOnEdge &&\n        (isBoundaryCase(frac0, options.epsilon) ||\n            isBoundaryCase(frac1, options.epsilon))) {\n        return intersectionPoint;\n    }\n    return intersectionPoint;\n}\n// Function to compute where two prolonged lines intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\nexport function prolongedLinesIntersectionPoint(line0, line1) {\n    const denom = (line0[0][0] - line0[1][0]) * (line1[0][1] - line1[1][1]) -\n        (line0[0][1] - line0[1][1]) * (line1[0][0] - line1[1][0]);\n    if (denom === 0)\n        return undefined;\n    const x = ((line0[0][0] * line0[1][1] - line0[0][1] * line0[1][0]) *\n        (line1[0][0] - line1[1][0]) -\n        (line0[0][0] - line0[1][0]) *\n            (line1[0][0] * line1[1][1] - line1[0][1] * line1[1][0])) /\n        denom;\n    const y = ((line0[0][0] * line0[1][1] - line0[0][1] * line0[1][0]) *\n        (line1[0][1] - line1[1][1]) -\n        (line0[0][1] - line0[1][1]) *\n            (line1[0][0] * line1[1][1] - line1[0][1] * line1[1][0])) /\n        denom;\n    return [x, y];\n}\n// true if fraction is (almost) 0.0 or 1.0\nfunction isBoundaryCase(fraction, epsilon) {\n    epsilon = epsilon || EPSILON;\n    const e2 = epsilon * epsilon;\n    return e2 >= (fraction - 1) * (fraction - 1) || e2 >= fraction * fraction;\n}\n// true if fraction is outside [0.0, 1.0] more then epsilon\nfunction isOutside(fraction, epsilon) {\n    epsilon = epsilon || EPSILON;\n    return fraction < 0 - epsilon || fraction > 1 + epsilon;\n}\n"],
  "mappings": "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",
  "names": ["point", "point", "feature", "distance", "feature", "lineString", "point", "flipY", "isObject", "point", "lineString", "point", "degreesToRadians", "subArrayMatrix", "i", "locate", "const", "let", "quotemark"]
}
