import { z } from 'zod';
import { CollectionSchema } from '../schemas/iiif.js';
import { EmbeddedCollection2Schema } from '../schemas/presentation.2.js';
import { EmbeddedCollection3Schema } from '../schemas/presentation.3.js';
import { EmbeddedManifest, Manifest } from './manifest.js';
import type { Image, EmbeddedImage } from './image.js';
import type { Canvas } from './canvas.js';
import type { LanguageString, MajorVersion, FetchNextOptions, FetchNextResults, Metadata, NavDate, NavPlace, Thumbnail, SeeAlso, Summary, RequiredStatement, Annotations, Homepage, Rendering } from '../lib/types.js';
type CollectionType = z.infer<typeof CollectionSchema>;
type EmbeddedCollectionType = z.infer<typeof EmbeddedCollection2Schema> | z.infer<typeof EmbeddedCollection3Schema>;
declare const CollectionTypeString = "collection";
export declare class EmbeddedCollection {
    uri: string;
    type: typeof CollectionTypeString;
    majorVersion: MajorVersion;
    label?: LanguageString;
    embedded: boolean;
    constructor(parsedCollection: CollectionType | EmbeddedCollectionType);
    /**
     * Parses a IIIF Collection and returns a [Collection](#collection) containing the parsed version
     * @param iiifCollection - Source data of IIIF Collection
     * @param majorVersion - IIIF API version of Collection. If not provided, it will be determined automatically
     * @returns Parsed IIIF Collection
     * @static
     */
    static parse(iiifCollection: unknown, majorVersion?: MajorVersion | null): Collection;
}
/**
 * Parsed IIIF Collection
 *
 * @property uri - URI of Collection
 * @property label - Label of Collection
 * @property items - Items in Collection
 * @property majorVersion - IIIF API version of Collection
 * @property type - Resource type, equals 'collection'
 */
export declare class Collection extends EmbeddedCollection {
    items: (Collection | EmbeddedCollection | Manifest | EmbeddedManifest)[];
    embedded: boolean;
    description?: LanguageString;
    metadata?: Metadata;
    navDate?: NavDate;
    navPlace?: NavPlace;
    homepage?: Homepage;
    thumbnail?: Thumbnail;
    rendering?: Rendering;
    seeAlso?: SeeAlso;
    summary?: Summary;
    requiredStatement?: RequiredStatement;
    annotations?: Annotations;
    constructor(parsedCollection: CollectionType);
    /**
     * Parses a IIIF Collection and returns a [Collection](#collection) containing the parsed version
     * @param iiifCollection - Source data of IIIF Collection
     * @param majorVersion - IIIF API version of Collection. If not provided, it will be determined automatically
     * @returns Parsed IIIF Collection
     */
    static parse(iiifCollection: unknown, majorVersion?: MajorVersion | null): Collection;
    get canvases(): Canvas[];
    get images(): (Image | EmbeddedImage)[];
    fetchAll(options?: Partial<FetchNextOptions>): Promise<FetchNextResults<Collection | Manifest | Image>[]>;
    fetchNext(options?: Partial<FetchNextOptions>, depth?: number): AsyncGenerator<FetchNextResults<Collection | Manifest | Image>, void, void>;
}
export {};
