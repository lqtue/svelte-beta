import { z } from 'zod';
import { CanvasSchema, ImageSchema } from '../schemas/iiif.js';
import { ImageResource2Schema } from '../schemas/presentation.2.js';
import { AnnotationBody3Schema } from '../schemas/presentation.3.js';
import type { SizeObject, ImageRequest, TileZoomLevel } from '@allmaps/types';
import type { Fit, MajorVersion } from '../lib/types.js';
type CanvasType = z.infer<typeof CanvasSchema>;
type ImageType = z.infer<typeof ImageSchema>;
type EmbeddedImageType = z.infer<typeof AnnotationBody3Schema> | z.infer<typeof ImageResource2Schema>;
declare const ImageTypeString: "image";
/**
 * Parsed IIIF Image, embedded in a Canvas
 *
 * @property embedded - Whether the Image is embedded in a Canvas
 * @property type - Resource type, equals 'image'
 * @property uri - URI of Image
 * @property majorVersion - IIIF API version of Image
 * @property supportsAnyRegionAndSize - Whether the associated Image Service supports any region and size
 * @property maxWidth - Maximum width of the associated Image Service
 * @property maxHeight - Maximum height of the associated Image Service
 * @property maxArea - Maximum area of the associated Image Service
 * @property width - Width of Image
 * @property height - Height of Image
 */
export declare class EmbeddedImage {
    readonly embedded: boolean;
    uri: string;
    type: typeof ImageTypeString;
    maxWidth: number | undefined;
    maxHeight: number | undefined;
    maxArea: number | undefined;
    supportsAnyRegionAndSize: boolean;
    width: number;
    height: number;
    majorVersion: MajorVersion;
    constructor(parsedImage: ImageType);
    constructor(parsedEmbeddedImage: EmbeddedImageType, parsedCanvas: CanvasType);
    /**
     * Generates a IIIF Image API URL for the requested region and size
     * @param imageRequest - Image request object containing the desired region and size of the requested image
     * @returns Image API URL that can be used to fetch the requested image
     */
    getImageUrl(imageRequest: ImageRequest): string;
    getImageRequest(size: SizeObject, mode?: Fit): ImageRequest | ImageRequest[][];
}
/**
 * Parsed IIIF Image
 * @property tileZoomLevels - Array of parsed tile zoom levels
 * @property sizes - Array of parsed sizes
 */
export declare class Image extends EmbeddedImage {
    tileZoomLevels: TileZoomLevel[];
    sizes?: SizeObject[];
    readonly embedded = false;
    constructor(parsedImage: ImageType);
    /**
     * Parses a IIIF image and returns a [Image](#image) containing the parsed version
     * @param iiifImage - Source data of IIIF Image
     * @param majorVersion - IIIF API version of Image. If not provided, it will be determined automatically
     * @returns Parsed IIIF Image
     * @static
     */
    static parse(iiifImage: unknown, majorVersion?: MajorVersion | null): Image;
    /**
     * Returns a Image request object for a tile with the requested zoom level, column, and row
     * @param zoomLevel - Desired zoom level of the requested tile
     * @param column - Column of the requested tile
     * @param row - Row of the requested tile
     * @returns Image request object that can be used to fetch the requested tile
     */
    getTileImageRequest(zoomLevel: TileZoomLevel, column: number, row: number): ImageRequest;
    /**
     * Returns a Image request object for the requested region and size
     * @param size - Size of the requested thumbnail
     * @param mode - Desired fit mode of the requested thumbnail
     * @returns Image request object that can be used to fetch the requested thumbnail
     */
    getImageRequest(size: SizeObject, mode?: Fit): ImageRequest | ImageRequest[][];
}
export {};
