/**
 * Solve the x and y components jointly using PseudoInverse.
 *
 * This uses the 'Pseudo Inverse' to compute a 'best fit' (least squares) approximate solution
 * for the system of linear equations, which is (in general) over-defined and hence lacks an exact solution.
 * See https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse
 *
 * This will result weightsArray shared by both components: [t_x, t_y, m, n]
 */
export declare function solveJointlyPseudoInverse(coefsArrayMatrices: [number[][], number[][]], destinationPointsArrays: [number[], number[]]): number[];
/**
 * Solve the x and y components independently using PseudoInverse.
 *
 * This uses the 'Pseudo Inverse' to compute (for each component, using the same coefs for both)
 * a 'best fit' (least squares) approximate solution for the system of linear equations
 * which is (in general) over-defined and hence lacks an exact solution.
 *
 * See https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse
 *
 * This wil result in a weights array for each component:
 * For order = 1: this.weight = [[a0_x, ax_x, ay_x], [a0_y, ax_y, ay_y]]
 * For order = 2: ... (similar, following the same order as in coefsArrayMatrix)
 * For order = 3: ... (similar, following the same order as in coefsArrayMatrix)
 */
export declare function solveIndependentlyPseudoInverse(coefsArrayMatrix: number[][], destinationPointsArrays: [number[], number[]]): [number[], number[]];
/**
 * Solve the x and y components independently using exact inverse.
 *
 * This uses the exact inverse to compute (for each component, using the same coefs for both)
 * the exact solution for the system of linear equations
 * which is (in general) invertable to an exact solution.
 *
 * This wil result in a weights array for each component with rbf weights and affine weights.
 */
export declare function solveIndependentlyInverse(coefsArrayMatrix: number[][], destinationPointsArrays: [number[], number[]]): [number[], number[]];
/**
 * Solve the x and y components jointly using singular value decomposition.
 *
 * This uses a singular value decomposition to compute the last (i.e. 9th) 'right singular vector',
 * i.e. the one with the smallest singular value, wich holds the weights for the solution.
 * Note that for a set of gcps that exactly follow a projective transformations,
 * the singular value is null and this vector spans the null-space.
 *
 * This wil result in a weights array for each component with rbf weights and affine weights.
 */
export declare function solveJointlySvd(coefsArrayMatrices: [number[][], number[][]], pointCount: number): number[][];
