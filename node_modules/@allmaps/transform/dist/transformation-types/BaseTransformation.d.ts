import type { Point } from '@allmaps/types';
import type { TransformationTypeMeasures, TransformationType } from '../shared/types.js';
/**
 * Base class for transformation.
 */
export declare abstract class BaseTransformation {
    sourcePoints: Point[];
    destinationPoints: Point[];
    destinationTransformedSourcePoints?: Point[];
    abstract weightsArrays?: object;
    type: TransformationType;
    pointCount: number;
    pointCountMinimum: number;
    private errors?;
    private rmse?;
    /**
     * Create a transformation
     *
     * @param sourcePoints - The source points
     * @param destinationPoints - The destination points
     * @param type - The transformation type
     * @param pointCountMinimum - The minimum number of points for the transformation type
     */
    constructor(sourcePoints: Point[], destinationPoints: Point[], type: TransformationType, pointCountMinimum: number);
    /**
     * Note: since (writing to and) reading from matrices is expensive,
     * we convert to and convert from ml-matrix Matrix types in this function,
     * in order not to use them in the evaluate functions.
     */
    abstract solve(): void;
    /**
     * Set weights.
     *
     * The weights might be obtained in other ways then through solving
     * (e.g. through solving multiple transformation together when staping).
     * This function can be used to set weights computed elsewhere.
     */
    setWeightsArrays(weightsArrays: object): void;
    processWeightsArrays(): void;
    /**
     * Evaluate the transformation function at a new point
     *
     * @param newSourcePoint - a source point
     * @returns the source point, transformed to destination space
     */
    abstract evaluateFunction(newSourcePoint: Point): Point;
    /**
     * Evaluate the transformation function's partial derivative to x at a new point
     *
     * @param newSourcePoint - a source point
     * @returns the x and y component of the partial derivative to x at the source point
     */
    abstract evaluatePartialDerivativeX(newSourcePoint: Point): Point;
    /**
     * Evaluate the transformation function's partial derivative to y at a new point
     *
     * @param newSourcePoint - a source point
     * @returns the x and y component of the partial derivative to y at the source point
     */
    abstract evaluatePartialDerivativeY(newSourcePoint: Point): Point;
    /**
     * Get the destination-transformed source points.
     *
     * @returns source points, transformed to destination domain
     */
    getDestinationTransformedSourcePoints(): Point[];
    getMeasures(): TransformationTypeMeasures;
    getErrors(): number[];
    getRmse(): number;
}
