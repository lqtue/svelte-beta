import { BaseIndependentLinearWeightsTransformation } from './BaseIndependentLinearWeightsTransformation.js';
import type { KernelFunction, NormFunction, TransformationType } from '../shared/types.js';
import type { Point, Size } from '@allmaps/types';
/**
 * 2D Radial Basis Functions transformation
 *
 * See notebook https://observablehq.com/d/0b57d3b587542794 for code source and explanation
 */
export declare class RBF extends BaseIndependentLinearWeightsTransformation {
    kernelFunction: KernelFunction;
    normFunction: NormFunction;
    epsilon?: number;
    coefsArrayMatrices: [number[][], number[][]];
    coefsArrayMatrix: number[][];
    coefsArrayMatricesSize: [Size, Size];
    coefsArrayMatrixSize: Size;
    weightsArrays?: [number[], number[]];
    rbfWeightsArrays?: [number[], number[]];
    affineWeightsArrays?: [number[], number[]];
    constructor(sourcePoints: Point[], destinationPoints: Point[], kernelFunction: KernelFunction, normFunction: NormFunction, type: TransformationType, epsilon?: number);
    getDestinationPointsArrays(): [number[], number[]];
    getCoefsArrayMatrix(): number[][];
    /**
     * Get 1x(N+3) coefsArray, populating the (N+3)x(N+3) coefsArrayMatrix
     *
     * The coefsArray has a 1xN kernel part and a 1x3 affine part.
     *
     * @param sourcePoint
     */
    getSourcePointCoefsArray(sourcePoint: Point): number[];
    getRbfKernelSourcePointCoefsArray(sourcePoint: Point): number[];
    setWeightsArrays(weightsArrays: object, epsilon?: number): void;
    /**
     * Solve the x and y components independently.
     *
     * This uses the exact inverse to compute (for each component, using the same coefs for both)
     * the exact solution for the system of linear equations
     * which is (in general) invertable to an exact solution.
     *
     * This wil result in a weights array for each component with rbf weights and affine weights.
     */
    solve(): void;
    processWeightsArrays(): void;
    evaluateFunction(newSourcePoint: Point): Point;
    evaluatePartialDerivativeX(newSourcePoint: Point): Point;
    evaluatePartialDerivativeY(newSourcePoint: Point): Point;
}
