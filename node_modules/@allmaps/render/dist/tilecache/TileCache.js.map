{"version":3,"file":"TileCache.js","sources":["../../src/tilecache/TileCache.ts"],"sourcesContent":["import { equalSet } from '@allmaps/stdlib'\n\nimport { CacheableTile, CachedTile } from './CacheableTile.js'\nimport { WarpedMapEvent, WarpedMapEventType } from '../shared/events.js'\n\nimport { shouldPruneTile } from '../shared/tiles.js'\nimport { FetchableTile } from './FetchableTile.js'\n\nimport type { FetchFn } from '@allmaps/types'\n\nimport type {\n  CachableTileFactory,\n  TileCacheOptions,\n  MapPruneInfo\n} from '../shared/types.js'\n\nconst PRUNE_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF = 4\nconst PRUNE_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF = 2\n\n/**\n * Class that fetches and caches IIIF tiles.\n */\nexport class TileCache<D> extends EventTarget {\n  cachableTileFactory: CachableTileFactory<D>\n  fetchFn?: FetchFn\n\n  protected tilesByTileUrl: Map<string, CacheableTile<D>> = new Map()\n  protected mapIdsByTileUrl: Map<string, Set<string>> = new Map()\n  protected tileUrlsByMapId: Map<string, Set<string>> = new Map()\n\n  protected tilesFetchingCount = 0\n\n  protected fetchableTiles: FetchableTile[] = []\n\n  constructor(\n    cachableTileFactory: CachableTileFactory<D>,\n    partialTileCacheOptions?: Partial<TileCacheOptions>\n  ) {\n    super()\n\n    this.setOptions(partialTileCacheOptions)\n\n    this.cachableTileFactory = cachableTileFactory\n  }\n\n  /**\n   * Get the tiles in this cache\n   *\n   * @returns\n   */\n  getCacheableTiles(): IterableIterator<CacheableTile<D>> {\n    return this.tilesByTileUrl.values()\n  }\n\n  /**\n   * Get a specific tile in this cache\n   *\n   * @param tileUrl - the URL of the requested tile\n   * @returns\n   */\n  getCacheableTile(tileUrl: string): CacheableTile<D> | undefined {\n    return this.tilesByTileUrl.get(tileUrl)\n  }\n\n  /**\n   * Get the tiles in this cache, corresponding to a specific map\n   *\n   * @param mapId - ID of the map\n   * @returns\n   */\n  getMapCacheableTiles(mapId: string): CacheableTile<D>[] {\n    const cacheableTiles: CacheableTile<D>[] = []\n\n    for (const cacheableTile of this.tilesByTileUrl.values()) {\n      if (this.tileUrlsByMapId.get(mapId)?.has(cacheableTile.tileUrl)) {\n        cacheableTiles.push(cacheableTile)\n      }\n    }\n\n    return cacheableTiles\n  }\n\n  /**\n   * Get the tiles in this cache that have been fetched\n   *\n   * @returns\n   */\n  getCachedTiles(): CachedTile<D>[] {\n    const cachedTiles: CachedTile<D>[] = []\n\n    for (const cacheableTile of this.tilesByTileUrl.values()) {\n      if (cacheableTile.isCachedTile()) {\n        cachedTiles.push(cacheableTile)\n      }\n    }\n\n    return cachedTiles\n  }\n\n  /**\n   * Get a specific cached tile in this cache that has been fetched\n   *\n   * @param tileUrl - the URL of the requested tile\n   * @returns\n   */\n  getCachedTile(tileUrl: string): CachedTile<D> | undefined {\n    const cacheableTile = this.tilesByTileUrl.get(tileUrl)\n    if (cacheableTile && cacheableTile.isCachedTile()) {\n      return cacheableTile as CachedTile<D>\n    }\n  }\n\n  /**\n   * Get the tiles in this cache, corresponding to a specific map, that have been fetched\n   *\n   * @param mapId - ID of the map\n   * @returns\n   */\n  getMapCachedTiles(mapId: string): CachedTile<D>[] {\n    const cachedTiles: CachedTile<D>[] = []\n\n    for (const cacheableTile of this.tilesByTileUrl.values()) {\n      if (\n        cacheableTile.isCachedTile() &&\n        this.tileUrlsByMapId.get(mapId)?.has(cacheableTile.tileUrl)\n      ) {\n        cachedTiles.push(cacheableTile)\n      }\n    }\n\n    return cachedTiles\n  }\n\n  /**\n   * Get the URLs of tiles in this cache\n   *\n   * @returns\n   */\n  getTileUrls(): IterableIterator<string> {\n    return this.tilesByTileUrl.keys()\n  }\n\n  /**\n   * Get the URLs of tiles in this cache, corresponding to a specific map\n   *\n   * @param mapId - ID of the map\n   * @returns\n   */\n  getMapTileUrls(mapId: string) {\n    return this.tileUrlsByMapId.get(mapId) || new Set()\n  }\n\n  /**\n   * Get the Tile Cache options\n   *\n   * @param partialTileCacheOptions - Options\n   */\n  setOptions(partialTileCacheOptions?: Partial<TileCacheOptions>) {\n    this.fetchFn = partialTileCacheOptions?.fetchFn\n  }\n\n  // TODO: this function needs a new name!\n  /**\n   * Process the request for new tiles to be added to this cache\n   *\n   * @param fetchableTiles\n   */\n  requestFetchableTiles(fetchableTiles: FetchableTile[]) {\n    const previousKeys = new Set(\n      this.fetchableTiles.map((fetchableTile) => fetchableTile.fetchableTileKey)\n    )\n    const keys = new Set(\n      fetchableTiles.map((fetchableTile) => fetchableTile.fetchableTileKey)\n    )\n\n    // If the keys are the same as the previous ones, don't do anything\n    // TODO: replace with Set equality once supported\n    if (equalSet(previousKeys, keys)) {\n      return\n    }\n\n    // Loop over all tiles, and add them (also do this if the cache already contains them,\n    // so as to trigger the loading events which will trigger a rerender etc.)\n    for (const fetchableTile of fetchableTiles) {\n      this.requestFetchableTile(fetchableTile)\n    }\n\n    this.fetchableTiles = fetchableTiles\n  }\n\n  /**\n   * Returns a promise that resolves when all requested tiles are loaded.\n   * This could happen immidiately, in case there are no ongoing requests and the tilesFetchingCount is zero,\n   * or in a while, when the count reaches zero and the ALLREQUESTEDTILESLOADED event is fired.\n   */\n  async allRequestedTilesLoaded(): Promise<void> {\n    return new Promise((resolve) => {\n      if (this.finished) {\n        resolve()\n      } else {\n        const listener = () => {\n          this.removeEventListener(\n            WarpedMapEventType.ALLREQUESTEDTILESLOADED,\n            listener\n          )\n          resolve()\n        }\n        this.addEventListener(\n          WarpedMapEventType.ALLREQUESTEDTILESLOADED,\n          listener\n        )\n      }\n    })\n  }\n\n  /**\n   * Prune tiles in this cache using the provided prune info\n   */\n  prune(pruneInfoByMapId: Map<string, MapPruneInfo>) {\n    for (const [tileUrl, mapIds] of this.mapIdsByTileUrl.entries()) {\n      for (const mapId of mapIds) {\n        const pruneInfo = pruneInfoByMapId.get(mapId)\n        const tile = this.tilesByTileUrl.get(tileUrl)?.tile\n\n        if (tile) {\n          // Prune for each mapId that doesn't have pruneInfo\n          // Or for which it should be pruned\n          if (\n            !pruneInfo ||\n            shouldPruneTile(tile, pruneInfo, {\n              maxHigherLog2ScaleFactorDiff:\n                PRUNE_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF,\n              maxLowerLog2ScaleFactorDiff:\n                PRUNE_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF\n            })\n          ) {\n            this.removeCacheableTileForMapId(tileUrl, mapId)\n          }\n        }\n      }\n    }\n  }\n\n  clear() {\n    for (const cacheableTile of this.getCacheableTiles()) {\n      cacheableTile.abort()\n      this.removeEventListenersFromCacheableTile(cacheableTile)\n    }\n\n    this.tilesByTileUrl = new Map()\n    this.mapIdsByTileUrl = new Map()\n    this.tileUrlsByMapId = new Map()\n    this.tilesFetchingCount = 0\n  }\n\n  destroy() {\n    this.clear()\n  }\n\n  private requestFetchableTile(fetchableTile: FetchableTile) {\n    const mapId = fetchableTile.mapId\n    const tileUrl = fetchableTile.tileUrl\n\n    if (!this.tilesByTileUrl.has(tileUrl)) {\n      const cacheableTile = this.cachableTileFactory(\n        fetchableTile,\n        this.fetchFn\n      )\n      this.addEventListenersToCacheableTile(cacheableTile)\n\n      this.addCacheableTile(cacheableTile)\n    } else {\n      const cachedTile = this.tilesByTileUrl.get(tileUrl)\n      if (cachedTile?.isCachedTile()) {\n        this.dispatchEvent(\n          new WarpedMapEvent(WarpedMapEventType.MAPTILELOADED, {\n            mapId,\n            tileUrl\n          })\n        )\n      }\n    }\n\n    this.addTileUrlForMapId(tileUrl, mapId)\n    this.addMapIdForTileUrl(mapId, tileUrl)\n  }\n\n  private addCacheableTile(cacheableTile: CacheableTile<D>) {\n    this.tilesByTileUrl.set(cacheableTile.tileUrl, cacheableTile)\n\n    // This is an async function that we are not awaiting to continue\n    // The results are handled inside the tile using events\n    cacheableTile.fetch()\n    this.updateTilesFetchingCount(1)\n  }\n\n  private removeCacheableTileForMapId(tileUrl: string, mapId: string) {\n    const cacheableTile = this.tilesByTileUrl.get(tileUrl)\n\n    if (!cacheableTile) {\n      return\n    }\n\n    const mapIds = this.removeMapIdForTileUrl(mapId, tileUrl)\n    this.removeTileUrlForMapId(tileUrl, mapId)\n\n    // If there are no other maps for this tile and it's still fetching,\n    // abort the fetch and delete the tile from the cache.\n    if (!mapIds.size) {\n      if (!cacheableTile.isCachedTile()) {\n        // Cancel fetch if tile is still being fetched\n        cacheableTile.abort()\n        this.updateTilesFetchingCount(-1)\n      }\n\n      this.tilesByTileUrl.delete(tileUrl)\n    }\n\n    this.dispatchEvent(\n      new WarpedMapEvent(WarpedMapEventType.MAPTILEREMOVED, {\n        mapId,\n        tileUrl\n      })\n    )\n  }\n\n  private tileFetched(event: Event) {\n    if (event instanceof WarpedMapEvent) {\n      const tileUrl = event.data as string\n\n      this.updateTilesFetchingCount(-1)\n\n      for (const mapId of this.mapIdsByTileUrl.get(tileUrl) || []) {\n        this.dispatchEvent(\n          new WarpedMapEvent(WarpedMapEventType.MAPTILELOADED, {\n            mapId,\n            tileUrl\n          })\n        )\n\n        const tileUrls = this.tileUrlsByMapId.get(mapId)\n        const firstTileUrl = tileUrls?.values().next().value\n\n        if (firstTileUrl === tileUrl) {\n          this.dispatchEvent(\n            new WarpedMapEvent(WarpedMapEventType.FIRSTMAPTILELOADED, {\n              mapId,\n              tileUrl\n            })\n          )\n        }\n      }\n    }\n  }\n\n  private tileFetchError(event: Event) {\n    if (event instanceof WarpedMapEvent) {\n      const tileUrl = event.data as string\n\n      if (!this.tilesByTileUrl.has(tileUrl)) {\n        this.updateTilesFetchingCount(-1)\n      }\n    }\n  }\n\n  private addMapIdForTileUrl(mapId: string, tileUrl: string) {\n    let mapIds = this.mapIdsByTileUrl.get(tileUrl)\n\n    if (!mapIds) {\n      mapIds = new Set([mapId])\n    } else {\n      mapIds.add(mapId)\n    }\n\n    this.mapIdsByTileUrl.set(tileUrl, mapIds)\n\n    return mapIds\n  }\n\n  private removeMapIdForTileUrl(mapId: string, tileUrl: string) {\n    const mapIds = this.mapIdsByTileUrl.get(tileUrl)\n\n    if (!mapIds) {\n      return new Set()\n    } else {\n      mapIds.delete(mapId)\n    }\n\n    if (!mapIds.size) {\n      this.mapIdsByTileUrl.delete(tileUrl)\n    } else {\n      this.mapIdsByTileUrl.set(tileUrl, mapIds)\n    }\n\n    return mapIds\n  }\n\n  private addTileUrlForMapId(tileUrl: string, mapId: string) {\n    let tileUrls = this.tileUrlsByMapId.get(mapId)\n\n    if (!tileUrls) {\n      tileUrls = new Set([tileUrl])\n    } else {\n      tileUrls.add(tileUrl)\n    }\n\n    this.tileUrlsByMapId.set(mapId, tileUrls)\n\n    return tileUrls\n  }\n\n  private removeTileUrlForMapId(tileUrl: string, mapId: string) {\n    const tileUrls = this.tileUrlsByMapId.get(mapId)\n\n    if (!tileUrls) {\n      return new Set()\n    } else {\n      tileUrls.delete(tileUrl)\n\n      if (!tileUrls.size) {\n        this.tileUrlsByMapId.delete(mapId)\n      } else {\n        this.tileUrlsByMapId.set(mapId, tileUrls)\n      }\n\n      return tileUrls\n    }\n  }\n\n  get finished() {\n    return this.tilesFetchingCount === 0\n  }\n\n  private updateTilesFetchingCount(delta: number) {\n    this.tilesFetchingCount += delta\n\n    if (this.tilesFetchingCount === 0) {\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.ALLREQUESTEDTILESLOADED)\n      )\n    }\n  }\n\n  private addEventListenersToCacheableTile(cacheableTile: CacheableTile<D>) {\n    cacheableTile.addEventListener(\n      WarpedMapEventType.TILEFETCHED,\n      this.tileFetched.bind(this)\n    )\n    cacheableTile.addEventListener(\n      WarpedMapEventType.TILEFETCHERROR,\n      this.tileFetchError.bind(this)\n    )\n  }\n\n  private removeEventListenersFromCacheableTile(\n    cacheableTile: CacheableTile<D>\n  ) {\n    cacheableTile.removeEventListener(\n      WarpedMapEventType.TILEFETCHED,\n      this.tileFetched.bind(this)\n    )\n    cacheableTile.removeEventListener(\n      WarpedMapEventType.TILEFETCHERROR,\n      this.tileFetchError.bind(this)\n    )\n  }\n}\n"],"names":[],"mappings":"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"}