{"version":3,"file":"CacheableWorkerImageDataTile.js","sources":["../../src/tilecache/CacheableWorkerImageDataTile.ts"],"sourcesContent":["import { proxy as comlinkProxy, type Remote as ComlinkRemote } from 'comlink'\n\nimport { FetchableTile } from './FetchableTile.js'\nimport { CacheableTile } from './CacheableTile.js'\nimport { WarpedMapEvent, WarpedMapEventType } from '../shared/events.js'\n\nimport type { FetchAndGetImageDataWorkerType } from '../workers/fetch-and-get-image-data.js'\n\nimport type { FetchFn } from '@allmaps/types'\n\n/**\n * Class for tiles that can be cached, and whose data can be processed to its imageData using a WebWorker.\n */\nexport class CacheableWorkerImageDataTile extends CacheableTile<ImageData> {\n  #worker: ComlinkRemote<FetchAndGetImageDataWorkerType>\n\n  constructor(\n    fetchableTile: FetchableTile,\n    worker: ComlinkRemote<FetchAndGetImageDataWorkerType>,\n    fetchFn?: FetchFn\n  ) {\n    super(fetchableTile, fetchFn)\n    this.#worker = worker\n  }\n\n  /**\n   * Fetch the tile and create its ImageData using a WebWorker.\n   *\n   * @returns\n   */\n  async fetch() {\n    try {\n      this.#worker\n        .getImageData(\n          this.tileUrl,\n          comlinkProxy(() => this.abortController.abort()),\n          this.fetchFn,\n          this.tile.tileZoomLevel.width,\n          this.tile.tileZoomLevel.height\n        )\n        .then((response) => {\n          this.data = response\n          this.dispatchEvent(\n            new WarpedMapEvent(WarpedMapEventType.TILEFETCHED, this.tileUrl)\n          )\n        })\n        .catch((err) => {\n          if (err instanceof Error && err.name === 'AbortError') {\n            console.log('Fetch aborted') // Handle the abort error\n          } else {\n            console.error(err) // Handle other errors\n          }\n        })\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        // fetchImage was aborted because viewport was moved and tile\n        // is no longer needed. This error can be ignored, nothing to do.\n      } else {\n        this.dispatchEvent(\n          new WarpedMapEvent(WarpedMapEventType.TILEFETCHERROR, this.tileUrl)\n        )\n      }\n    }\n\n    return this.data\n  }\n\n  static createFactory(worker: ComlinkRemote<FetchAndGetImageDataWorkerType>) {\n    return (fetchableTile: FetchableTile, fetchFn?: FetchFn) =>\n      new CacheableWorkerImageDataTile(fetchableTile, worker, fetchFn)\n  }\n}\n\n/**\n * Class for tiles that is cached, and whose data has been processed to an ImageData object using a WebWorker.\n */\nexport class CachedWorkerImageDataTile extends CacheableWorkerImageDataTile {\n  declare data: ImageData\n}\n"],"names":["comlinkProxy"],"mappings":";;;AAaO,MAAM,qCAAqC,cAAyB;AAAA,EACzE;AAAA,EAEA,YACE,eACA,QACA,SACA;AACA,UAAM,eAAe,OAAO;AAC5B,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAQ;AACZ,QAAI;AACF,WAAK,QACF;AAAA,QACC,KAAK;AAAA,QACLA,MAAa,MAAM,KAAK,gBAAgB,OAAO;AAAA,QAC/C,KAAK;AAAA,QACL,KAAK,KAAK,cAAc;AAAA,QACxB,KAAK,KAAK,cAAc;AAAA,MAAA,EAEzB,KAAK,CAAC,aAAa;AAClB,aAAK,OAAO;AACZ,aAAK;AAAA,UACH,IAAI,eAAe,mBAAmB,aAAa,KAAK,OAAO;AAAA,QAAA;AAAA,MAEnE,CAAC,EACA,MAAM,CAAC,QAAQ;AACd,YAAI,eAAe,SAAS,IAAI,SAAS,cAAc;AACrD,kBAAQ,IAAI,eAAe;AAAA,QAC7B,OAAO;AACL,kBAAQ,MAAM,GAAG;AAAA,QACnB;AAAA,MACF,CAAC;AAAA,IACL,SAAS,KAAK;AACZ,UAAI,eAAe,SAAS,IAAI,SAAS,aAAc;AAAA,WAGhD;AACL,aAAK;AAAA,UACH,IAAI,eAAe,mBAAmB,gBAAgB,KAAK,OAAO;AAAA,QAAA;AAAA,MAEtE;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,OAAO,cAAc,QAAuD;AAC1E,WAAO,CAAC,eAA8B,YACpC,IAAI,6BAA6B,eAAe,QAAQ,OAAO;AAAA,EACnE;AACF;"}