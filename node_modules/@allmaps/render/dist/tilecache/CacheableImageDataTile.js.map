{"version":3,"file":"CacheableImageDataTile.js","sources":["../../src/tilecache/CacheableImageDataTile.ts"],"sourcesContent":["import { fetchUrl } from '@allmaps/stdlib'\n\nimport { FetchableTile } from './FetchableTile.js'\nimport { CacheableTile } from './CacheableTile.js'\nimport { WarpedMapEvent, WarpedMapEventType } from '../shared/events.js'\n\nimport type { FetchFn } from '@allmaps/types'\n\n/**\n * Class for tiles that can be cached, and whose data can be processed to an ImageData object.\n */\nexport class CacheableImageDataTile extends CacheableTile<ImageData> {\n  /**\n   * Fetch the tile and create its ImageData object.\n   *\n   * @returns\n   */\n  async fetch() {\n    try {\n      const response = await fetchUrl(\n        this.tileUrl,\n        {\n          signal: this.abortController.signal\n        },\n        this.fetchFn\n      )\n\n      const width = this.tile.tileZoomLevel.width\n      const height = this.tile.tileZoomLevel.height\n\n      const blob = await response.blob()\n      const bitmap = await createImageBitmap(blob)\n      const canvas = new OffscreenCanvas(width, height)\n      const context = canvas.getContext('2d')\n\n      if (!context) {\n        throw new Error('Could not create OffscreenCanvas context')\n      }\n\n      context.drawImage(bitmap, 0, 0)\n      this.data = context.getImageData(0, 0, width, height)\n\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.TILEFETCHED, this.tileUrl)\n      )\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        // fetchImage was aborted because viewport was moved and tile\n        // is no longer needed. This error can be ignored, nothing to do.\n      } else {\n        this.dispatchEvent(\n          new WarpedMapEvent(WarpedMapEventType.TILEFETCHERROR, this.tileUrl)\n        )\n      }\n    }\n\n    return this.data\n  }\n\n  static createFactory() {\n    return (fetchableTile: FetchableTile, fetchFn?: FetchFn) =>\n      new CacheableImageDataTile(fetchableTile, fetchFn)\n  }\n}\n\n/**\n * Class for tiles that is cached, and whose data has been processed to an ImageData object.\n */\nexport class CachedImageDataTile extends CacheableImageDataTile {\n  declare data: ImageData\n}\n"],"names":[],"mappings":";;;AAWO,MAAM,+BAA+B,cAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMnE,MAAM,QAAQ;AACZ,QAAI;AACF,YAAM,WAAW,MAAM;AAAA,QACrB,KAAK;AAAA,QACL;AAAA,UACE,QAAQ,KAAK,gBAAgB;AAAA,QAAA;AAAA,QAE/B,KAAK;AAAA,MAAA;AAGP,YAAM,QAAQ,KAAK,KAAK,cAAc;AACtC,YAAM,SAAS,KAAK,KAAK,cAAc;AAEvC,YAAM,OAAO,MAAM,SAAS,KAAA;AAC5B,YAAM,SAAS,MAAM,kBAAkB,IAAI;AAC3C,YAAM,SAAS,IAAI,gBAAgB,OAAO,MAAM;AAChD,YAAM,UAAU,OAAO,WAAW,IAAI;AAEtC,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC5D;AAEA,cAAQ,UAAU,QAAQ,GAAG,CAAC;AAC9B,WAAK,OAAO,QAAQ,aAAa,GAAG,GAAG,OAAO,MAAM;AAEpD,WAAK;AAAA,QACH,IAAI,eAAe,mBAAmB,aAAa,KAAK,OAAO;AAAA,MAAA;AAAA,IAEnE,SAAS,KAAK;AACZ,UAAI,eAAe,SAAS,IAAI,SAAS,aAAc;AAAA,WAGhD;AACL,aAAK;AAAA,UACH,IAAI,eAAe,mBAAmB,gBAAgB,KAAK,OAAO;AAAA,QAAA;AAAA,MAEtE;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,OAAO,gBAAgB;AACrB,WAAO,CAAC,eAA8B,YACpC,IAAI,uBAAuB,eAAe,OAAO;AAAA,EACrD;AACF;"}