{"version":3,"file":"fragment-shader.glsl.js","sources":["../../../src/shaders/map/fragment-shader.glsl"],"sourcesContent":["#version 300 es\n\nprecision highp float;\nprecision highp isampler2D;\n\n#include ../helpers.frag;\n\nuniform float u_debug;\n\nuniform bool u_removeColor;\nuniform vec3 u_removeColorOptionsColor;\nuniform float u_removeColorOptionsThreshold;\nuniform float u_removeColorOptionsHardness;\n\nuniform bool u_colorize;\nuniform vec3 u_colorizeOptionsColor;\n\nuniform bool u_grid;\n\nuniform float u_opacity;\nuniform float u_saturation;\n\nuniform bool u_distortion;\nuniform int u_distortionOptionsdistortionMeasure;\n\nuniform int u_scaleFactorForViewport;\n\nuniform lowp sampler2DArray u_cachedTilesTextureArray;\nuniform isampler2D u_cachedTilesResourceOriginPointsAndDimensionsTexture;\nuniform isampler2D u_cachedTilesScaleFactorsTexture;\n\nuniform vec4 u_colorDistortion00;\nuniform vec4 u_colorDistortion01;\nuniform vec4 u_colorDistortion1;\nuniform vec4 u_colorDistortion2;\nuniform vec4 u_colorDistortion3;\nuniform vec4 u_colorGrid;\n\nin vec2 v_resourceTrianglePoint;\nin float v_trianglePointDistortion;\nin float v_trianglePointIndex;\nin vec4 v_trianglePointBarycentric;\n\nout vec4 color;\n\nvoid main() {\n  float resourceTrianglePointX = v_resourceTrianglePoint.x;\n  float resourceTrianglePointY = v_resourceTrianglePoint.y;\n\n  // Reading information on cached tiles from textures\n  ivec3 cachedTilesTextureSize = textureSize(u_cachedTilesTextureArray, 0);\n  int cachedTilesCount = cachedTilesTextureSize.z;\n\n  // Setting references for the for loop\n  int smallestScaleFactor;\n  bool found = false;\n  int foundIndex;\n\n  // Prepare storage for the resulting cached tiles texture point that corresponds to the triangle point\n  vec3 cachedTilesTexturePoint = vec3(0.0f, 0.0f, 0.0f);\n\n  // Set the initial values\n  color = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n  // Loop through all cached tiles\n  for(int index = 0; index < cachedTilesCount; index += 1) {\n\n    // Read the information of the tile\n    float cachedTileResourceOriginPointX = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4)), 0));\n    float cachedTileResourceOriginPointY = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4) + 1), 0));\n    float cachedTileDimensionWidth = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4) + 2), 0));\n    float cachedTileDimensionHeight = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4) + 3), 0));\n\n    int cachedTileScaleFactor = texelFetch(u_cachedTilesScaleFactorsTexture, ivec2(0, index), 0).r;\n\n    // If the triangle point is inside the tile, consider to use the tile:\n    if(resourceTrianglePointX >= cachedTileResourceOriginPointX &&\n      resourceTrianglePointX < cachedTileResourceOriginPointX + cachedTileDimensionWidth &&\n      resourceTrianglePointY >= cachedTileResourceOriginPointY &&\n      resourceTrianglePointY < cachedTileResourceOriginPointY + cachedTileDimensionHeight) {\n\n      // If the smallest scale factor currently known is not set yet,\n      // or if the scale factor of this tile is smaller (more detailed) then the scale factor currently known\n      // update the smallest scale factor\n      // and compute the cached tiles texture point that corresponds to the triangle point\n      // Note: we can safely take the most detailed tile, since the depth is limited when we gather texture tiles\n      if(!(smallestScaleFactor > 0) || cachedTileScaleFactor <= smallestScaleFactor) {\n        smallestScaleFactor = cachedTileScaleFactor;\n        found = true;\n        foundIndex = index;\n\n        float cachedTilePointX = (resourceTrianglePointX - cachedTileResourceOriginPointX) / float(cachedTileScaleFactor);\n        float cachedTilePointY = (resourceTrianglePointY - cachedTileResourceOriginPointY) / float(cachedTileScaleFactor);\n\n        float cachedTilesTexturePointX = cachedTilePointX / float(cachedTilesTextureSize.x);\n        float cachedTilesTexturePointY = cachedTilePointY / float(cachedTilesTextureSize.y);\n\n        cachedTilesTexturePoint = vec3(cachedTilesTexturePointX, cachedTilesTexturePointY, index);\n      }\n    }\n  }\n\n  if(found == true) {\n    // Read color of the point at its chached tiles texture point coordinates in the cached tiles texture array\n    color = texture(u_cachedTilesTextureArray, cachedTilesTexturePoint);\n\n    #include post.frag;\n    #include distortion.frag;\n    #include debug.frag;\n  }\n}\n"],"names":[],"mappings":"AAAA,IAAA,0BAAA;"}