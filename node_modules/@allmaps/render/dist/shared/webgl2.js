function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  if (shader) {
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
      return shader;
    } else {
      const message = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      throw new Error("Failed to compile shader: " + message);
    }
  } else {
    throw new Error("Failed to create shader");
  }
}
function createProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  if (program) {
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    const success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
      return program;
    } else {
      const message = gl.getProgramInfoLog(program);
      gl.deleteProgram(program);
      throw new Error("Failed to link program: " + message);
    }
  } else {
    throw new Error("Failed to create program");
  }
}
function createBuffer(gl, program, data, size, name) {
  const buffer = gl.createBuffer();
  if (!buffer) {
    throw new Error("Failed to create buffer");
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  const type = gl.FLOAT;
  const normalize = false;
  const stride = 0;
  const offset = 0;
  const positionAttributeLocation = gl.getAttribLocation(program, name);
  gl.vertexAttribPointer(
    positionAttributeLocation,
    size,
    type,
    normalize,
    stride,
    offset
  );
  gl.enableVertexAttribArray(positionAttributeLocation);
  return buffer;
}
export {
  createBuffer,
  createProgram,
  createShader
};
//# sourceMappingURL=webgl2.js.map
