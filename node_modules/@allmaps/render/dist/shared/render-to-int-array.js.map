{"version":3,"file":"render-to-int-array.js","sources":["../../src/shared/render-to-int-array.ts"],"sourcesContent":["import inside from 'point-in-polygon-hao'\n\nimport {\n  doBboxesIntersect,\n  pixelToIntArrayIndex,\n  pointToPixel,\n  closeRing\n} from '@allmaps/stdlib'\n\nimport { GetImageDataValue, GetImageDataSize } from './types.js'\nimport {\n  resourcePointInTile,\n  tileToTileOriginPoint,\n  clipTilePointToTile\n} from './tiles.js'\nimport {\n  applyHomogeneousTransform,\n  invertHomogeneousTransform\n} from './homogeneous-transform.js'\n\nimport type { WarpedMapList } from '../maps/WarpedMapList.js'\nimport type { Viewport } from '../viewport/Viewport.js'\nimport type { TileCache } from '../tilecache/TileCache.js'\nimport type { CachedTile } from '../tilecache/CacheableTile.js'\n\nimport type { WarpedMap } from '../maps/WarpedMap.js'\nimport type { Point } from '@allmaps/types'\n\nconst CHANNELS = 4\n\n/**\n * Render to IntArray\n *\n * @param warpedMapList - WarpedMapList who's WarpedMaps will be rendered\n * @param tileCache - TileCache who's tiles will be used\n * @param viewport - Viewport to render to. This can be the entire image, or a single XYZ tile\n * @param getImageDataValue - Function to access the data of the image, at a specific index\n * @param getImageDataSize - Function to access the size of the image\n * @param intArray - IntArray to render to\n * @returns\n */\nexport async function renderToIntArray<W extends WarpedMap, D>(\n  warpedMapList: WarpedMapList<W>,\n  tileCache: TileCache<D>,\n  viewport: Viewport,\n  getImageDataValue: GetImageDataValue<D>,\n  getImageDataSize: GetImageDataSize<D>,\n  intArray: Uint8ClampedArray\n): Promise<void> {\n  for (const warpedMap of warpedMapList.getWarpedMaps()) {\n    if (\n      !doBboxesIntersect(\n        viewport.projectedGeoRectangleBbox,\n        warpedMap.projectedGeoMaskBbox\n      )\n    ) {\n      continue\n    }\n\n    const cachedTiles = tileCache.getMapCachedTiles(warpedMap.mapId)\n    const canvasToProjectedGeoHomogeneousTransform = invertHomogeneousTransform(\n      viewport.projectedGeoToCanvasHomogeneousTransform\n    )\n\n    // Step through all viewport pixels and set their color\n    // Note: naming variables 'Pixel' instead of 'Point' when we are sure they are integer coordinate values\n    for (\n      let canvasPixelX = 0;\n      canvasPixelX < viewport.canvasSize[0];\n      canvasPixelX++\n    ) {\n      for (\n        let canvasPixelY = 0;\n        canvasPixelY < viewport.canvasSize[1];\n        canvasPixelY++\n      ) {\n        const canvasPixel = [canvasPixelX, canvasPixelY] as Point\n\n        // Get resourcePoint corresponding to this canvasPixel\n        const projectedGeoPoint = applyHomogeneousTransform(\n          canvasToProjectedGeoHomogeneousTransform,\n          canvasPixel\n        )\n        const resourcePoint =\n          warpedMap.projectedTransformer.transformToResource(projectedGeoPoint)\n\n        // Apply mask: Check if resourcePoint is inside resource mask\n        if (\n          inside(resourcePoint, [closeRing(warpedMap.resourceMask)]) === false\n        ) {\n          continue\n        }\n\n        // Find the tile on which resourcePoint is located\n        // Note: we are currently waiting for all tiles to be cashed\n        // If not, consider to use the tile with minimum scaleFactorDiff, as in fragmentShader\n        let cachedTile: CachedTile<D> | undefined\n        let foundCachedTile = false\n        for (cachedTile of cachedTiles) {\n          if (resourcePointInTile(resourcePoint, cachedTile.tile)) {\n            foundCachedTile = true\n            break\n          }\n        }\n\n        // If tile is found, set color of this resourcePoint, i.e. canvasPixel\n        if (foundCachedTile && cachedTile) {\n          const tile = cachedTile.tile\n          const tileSize = getImageDataSize(cachedTile.data)\n\n          // Determine sub-pixel coordinates of the resourcePoint on the (scaled) tile: 'tilePoint'\n          //\n          // Schematic drawing of tilePoint inside a pixel of the (scaled) resource tile\n          // tilePoint: +\n          // Surrounding pixels of the (scaled) resource tile: *\n          //\n          //        Y\n          //        ^\n          // [0, 1] *---------* [1, 1]\n          //        |         |\n          //        |         |\n          //        |   +     |\n          // [0, 0] *---------* [1, 0] > X\n          //\n          const resourceTileOriginPoint = tileToTileOriginPoint(tile)\n          const tilePoint = resourcePoint.map(\n            (coordinate, index) =>\n              (coordinate - resourceTileOriginPoint[index]) /\n              tile.tileZoomLevel.scaleFactor\n          ) as Point\n\n          // Determine the tilePoint's four surrounding pixels: bottom-left, bottom-right, top-left, top-right\n          const tilePointPixels = [\n            pointToPixel(tilePoint, [0, 0]),\n            pointToPixel(tilePoint, [1, 0]),\n            pointToPixel(tilePoint, [0, 1]),\n            pointToPixel(tilePoint, [1, 1])\n          ]\n\n          // Determine the index where to write this pixel's information in the IntArray\n          const canvasPixelIntArrayIndex = pixelToIntArrayIndex(\n            canvasPixel,\n            viewport.canvasSize,\n            CHANNELS\n          )\n\n          // Apply bilinear resampling:\n          // for each color, set the color value in the intArray in the following way:\n          // for the current tile point (derived earlier from resourcePoint and hence from canvasPoint)\n          // go over all tile pixels surrounding it\n          // multiply their color value and pixel weight, and add all of these together\n          for (let color = 0; color < CHANNELS; color++) {\n            intArray[canvasPixelIntArrayIndex + color] = tilePointPixels\n              .map(\n                (tilePointPixel) =>\n                  getImageDataValue(\n                    cachedTile.data,\n                    pixelToIntArrayIndex(\n                      clipTilePointToTile(tilePointPixel, tile),\n                      tileSize,\n                      CHANNELS\n                    ) + color\n                  ) * bilinearPixelWeight(tilePointPixel, tilePoint)\n              )\n              .reduce((a, c) => a + c, 0)\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction bilinearPixelWeight(pixel: Point, point: Point): number {\n  return (\n    (1 - Math.abs(point[0] - pixel[0])) * (1 - Math.abs(point[1] - pixel[1]))\n  )\n}\n"],"names":[],"mappings":";;;;AA4BA,MAAM,WAAW;AAajB,eAAsB,iBACpB,eACA,WACA,UACA,mBACA,kBACA,UACe;AACf,aAAW,aAAa,cAAc,iBAAiB;AACrD,QACE,CAAC;AAAA,MACC,SAAS;AAAA,MACT,UAAU;AAAA,IAAA,GAEZ;AACA;AAAA,IACF;AAEA,UAAM,cAAc,UAAU,kBAAkB,UAAU,KAAK;AAC/D,UAAM,2CAA2C;AAAA,MAC/C,SAAS;AAAA,IAAA;AAKX,aACM,eAAe,GACnB,eAAe,SAAS,WAAW,CAAC,GACpC,gBACA;AACA,eACM,eAAe,GACnB,eAAe,SAAS,WAAW,CAAC,GACpC,gBACA;AACA,cAAM,cAAc,CAAC,cAAc,YAAY;AAG/C,cAAM,oBAAoB;AAAA,UACxB;AAAA,UACA;AAAA,QAAA;AAEF,cAAM,gBACJ,UAAU,qBAAqB,oBAAoB,iBAAiB;AAGtE,YACE,OAAO,eAAe,CAAC,UAAU,UAAU,YAAY,CAAC,CAAC,MAAM,OAC/D;AACA;AAAA,QACF;AAKA,YAAI;AACJ,YAAI,kBAAkB;AACtB,aAAK,cAAc,aAAa;AAC9B,cAAI,oBAAoB,eAAe,WAAW,IAAI,GAAG;AACvD,8BAAkB;AAClB;AAAA,UACF;AAAA,QACF;AAGA,YAAI,mBAAmB,YAAY;AACjC,gBAAM,OAAO,WAAW;AACxB,gBAAM,WAAW,iBAAiB,WAAW,IAAI;AAgBjD,gBAAM,0BAA0B,sBAAsB,IAAI;AAC1D,gBAAM,YAAY,cAAc;AAAA,YAC9B,CAAC,YAAY,WACV,aAAa,wBAAwB,KAAK,KAC3C,KAAK,cAAc;AAAA,UAAA;AAIvB,gBAAM,kBAAkB;AAAA,YACtB,aAAa,WAAW,CAAC,GAAG,CAAC,CAAC;AAAA,YAC9B,aAAa,WAAW,CAAC,GAAG,CAAC,CAAC;AAAA,YAC9B,aAAa,WAAW,CAAC,GAAG,CAAC,CAAC;AAAA,YAC9B,aAAa,WAAW,CAAC,GAAG,CAAC,CAAC;AAAA,UAAA;AAIhC,gBAAM,2BAA2B;AAAA,YAC/B;AAAA,YACA,SAAS;AAAA,YACT;AAAA,UAAA;AAQF,mBAAS,QAAQ,GAAG,QAAQ,UAAU,SAAS;AAC7C,qBAAS,2BAA2B,KAAK,IAAI,gBAC1C;AAAA,cACC,CAAC,mBACC;AAAA,gBACE,WAAW;AAAA,gBACX;AAAA,kBACE,oBAAoB,gBAAgB,IAAI;AAAA,kBACxC;AAAA,kBACA;AAAA,gBAAA,IACE;AAAA,cAAA,IACF,oBAAoB,gBAAgB,SAAS;AAAA,YAAA,EAEpD,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AAAA,UAC9B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,oBAAoB,OAAc,OAAsB;AAC/D,UACG,IAAI,KAAK,IAAI,MAAM,CAAC,IAAI,MAAM,CAAC,CAAC,MAAM,IAAI,KAAK,IAAI,MAAM,CAAC,IAAI,MAAM,CAAC,CAAC;AAE3E;"}