{"version":3,"file":"tiles.js","sources":["../../src/shared/tiles.ts"],"sourcesContent":["import {\n  distance,\n  doBboxesIntersect,\n  bufferBboxByRatio,\n  squaredDistance,\n  sizeToResolution\n} from '@allmaps/stdlib'\nimport { MapPruneConstants, MapPruneInfo } from './types'\nimport { FetchableTile } from '../tilecache/FetchableTile'\n\nimport type { Image } from '@allmaps/iiif-parser'\nimport type {\n  Point,\n  Line,\n  Ring,\n  Bbox,\n  Tile,\n  Size,\n  TileZoomLevel,\n  TileByColumn\n} from '@allmaps/types'\n\n// Preparing to make tiles\n\n/**\n * Returns the best TileZoomLevel for a given resource-to-canvas scale.\n *\n * @export\n * @param image - A parsed IIIF Image\n * @param resourceToCanvasScale - The resource to canvas scale, relating resource pixels to canvas pixels.\n * @returns\n */\nexport function getTileZoomLevelForScale(\n  tileZoomLevels: TileZoomLevel[],\n  resourceToCanvasScale: number,\n  scaleFactorCorrection: number,\n  log2scaleFactorCorrection: number\n): TileZoomLevel {\n  // Returning the TileZoomLevel with the scaleFactor closest to the map scale.\n  // We use logarithms here because for scaleFactors 1 is as 'far' of 2 as 8 is of 16.\n  // Math reminder: log(A)-log(B)=log(A/B)\n  //\n  // Example:\n  // Available scaleFactors in tileZoomLevels:\n  // 1---------2---------4---------8---------16\n  // Math.log2() of those scaleFactors\n  // 0---------1---------2---------3---------4\n  //\n  // Scale of the map '|' = 3, corrected scale '*' = 3.5\n  // 1---------2----|-*--4---------8---------16\n  // Math.log2(3) = 1.58, Math.log2(3.5) = 1.80\n  // 0---------1-----|-*-2---------3---------4\n  //\n  // The algorithm loops through all available scaleFactors and find out\n  // which one (in Math.log2()) is closest to the (corrected) scale.\n  //\n  // The scale can be corrected before and after taking the Math.log2()\n  // Here we will correct before.\n  // Math.log2(3 + scaleFactorCorrection) = Math.log2(3 + 0.5) = 1.80\n  //\n  // scaleFactor = 1\n  // Math.log2(1) = 0\n  // diff = abs(0 - 1.80) = abs(-1.80) = 1.80\n  //\n  // scaleFactor = 2\n  // Math.log2(2) = 1\n  // diff = abs(1 - 1.80) = abs(-0.80) = 0.80\n  //\n  // scaleFactor = 4\n  // Math.log2(4) = 3\n  // diff = abs(3 - 1.80) = abs(0.20) = 0.20\n  //\n  // => Pick scaleFactor 4, which has minimum diff.\n  // Notice how 3 lies in the middle of 2 and 4, but on the log scale log2(3) lies closer to log2(4) than log2(2)\n  // Notice how the scaleFactorCorrection corrects the scale for which the closest scaleFactor is searched.\n  // Notice when this happens before taking a Math.log2(), it has more effect on smaller scales then on bigger.\n\n  let smallestdiffLogScaleFactor = Number.POSITIVE_INFINITY\n  let bestTileZoomLevel = tileZoomLevels.at(-1) as TileZoomLevel\n\n  for (const tileZoomLevel of tileZoomLevels) {\n    const diffLogScaleFactor = Math.abs(\n      Math.log2(tileZoomLevel.scaleFactor) -\n        (Math.log2(resourceToCanvasScale + scaleFactorCorrection) +\n          log2scaleFactorCorrection)\n    )\n    if (diffLogScaleFactor < smallestdiffLogScaleFactor) {\n      smallestdiffLogScaleFactor = diffLogScaleFactor\n      bestTileZoomLevel = tileZoomLevel\n    }\n  }\n\n  return bestTileZoomLevel\n}\n\n// Making tiles\n\nexport function computeTilesCoveringRingAtTileZoomLevel(\n  resourceRing: Ring,\n  tileZoomLevel: TileZoomLevel,\n  imageSize: Size\n): Tile[] {\n  const scaledResourceRing = scaleResourcePoints(resourceRing, tileZoomLevel)\n  const tilesByColumn = ringToTilesByColumn(scaledResourceRing)\n  const tiles = tilesByColumnToTiles(tilesByColumn, tileZoomLevel, imageSize)\n\n  return tiles\n}\n\nfunction scaleResourcePoints(\n  resourcePoints: Point[],\n  tileZoomLevel: TileZoomLevel\n): Point[] {\n  // This scales the incoming resource points to a grid, where there scaled coordinates on the grid pixels (between integer numbers) correspond to the original coordinates on the tiles provided at this zoom level\n  return resourcePoints.map((point) => [\n    point[0] / tileZoomLevel.originalWidth,\n    point[1] / tileZoomLevel.originalHeight\n  ])\n}\n\nfunction ringToTilesByColumn(ring: Ring) {\n  const tilesByColumn: TileByColumn = {}\n  for (let i = 0; i < ring.length; i++) {\n    const line: Line = [ring[i], ring[(i + 1) % ring.length]]\n    const pixels = lineToPixels(line)\n\n    pixels.forEach(([x, y]) => {\n      if (!tilesByColumn[x]) {\n        tilesByColumn[x] = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]\n      }\n\n      if (y < tilesByColumn[x][0]) {\n        tilesByColumn[x][0] = y\n      }\n\n      if (y > tilesByColumn[x][1]) {\n        tilesByColumn[x][1] = y\n      }\n    })\n  }\n\n  return tilesByColumn\n}\n\nfunction lineToPixels([startPoint, endPoint]: Line): Point[] {\n  // From:\n  //  https://github.com/vHawk/tiles-intersect\n  // See also:\n  //  https://www.redblobgames.com/grids/line-drawing.html\n\n  // Start and end pixel coordinates\n  let startPixelX = Math.floor(startPoint[0])\n  let startPixelY = Math.floor(startPoint[1])\n  const endPixelX = Math.floor(endPoint[0])\n  const endPixelY = Math.floor(endPoint[1])\n\n  const points: Point[] = [[startPixelX, startPixelY]]\n\n  if (startPixelX === endPixelX && startPixelY === endPixelY) {\n    return points\n  }\n\n  // The pixel step: 1, 0 or -1\n  const stepX = Math.sign(endPoint[0] - startPoint[0])\n  const stepY = Math.sign(endPoint[1] - startPoint[1])\n\n  // The rest in the first pixel before reaching the next one\n  const restX = Math.abs(startPoint[0] - startPixelX - Math.max(0, stepX))\n  const restY = Math.abs(startPoint[1] - startPixelY - Math.max(0, stepY))\n\n  // The distance\n  const distanceX = Math.abs(startPoint[0] - endPoint[0])\n  const distanceY = Math.abs(startPoint[1] - endPoint[1])\n\n  // The relative rest\n  let restPerStepX = restX / distanceX\n  let restPerStepY = restY / distanceY\n\n  // The delta\n  const onePerStepX = 1 / distanceX\n  const onePerStepY = 1 / distanceY\n\n  while (!(startPixelX === endPixelX && startPixelY === endPixelY)) {\n    if (distanceY === 0) {\n      startPixelX = startPixelX + stepX\n    } else if (distanceX === 0) {\n      startPixelY = startPixelY + stepY\n    } else if (restPerStepX < restPerStepY) {\n      restPerStepX = restPerStepX + onePerStepX\n      startPixelX = startPixelX + stepX\n    } else {\n      restPerStepY = restPerStepY + onePerStepY\n      startPixelY = startPixelY + stepY\n    }\n\n    points.push([startPixelX, startPixelY])\n  }\n\n  return points\n}\n\nfunction tilesByColumnToTiles(\n  tilesByColumn: TileByColumn,\n  tileZoomLevel: TileZoomLevel,\n  imageSize: Size\n): Tile[] {\n  const tiles: Tile[] = []\n  for (const xKey in tilesByColumn) {\n    const x = parseInt(xKey)\n\n    if (x < 0 || x >= tileZoomLevel.columns) {\n      break\n    }\n\n    const fromY = Math.max(tilesByColumn[x][0], 0)\n    const toY = Math.min(tilesByColumn[x][1], tileZoomLevel.rows - 1)\n\n    for (let y = fromY; y <= toY; y++) {\n      tiles.push({\n        column: x,\n        row: y,\n        tileZoomLevel: tileZoomLevel,\n        imageSize\n      })\n    }\n  }\n\n  return tiles\n}\n\n// Looking up tiles\n\nexport function getTilesCoveringTileAtScaleFactor(\n  tile: Tile,\n  parsedImage: Image,\n  scaleFactor: number,\n  validTile?: (tile: Tile) => boolean\n) {\n  let columnStart = Math.floor(\n    (tile.column * tile.tileZoomLevel.scaleFactor) / scaleFactor\n  )\n  columnStart = columnStart >= 0 ? columnStart : 0\n  const columnEnd = Math.ceil(\n    ((tile.column + 1) * tile.tileZoomLevel.scaleFactor) / scaleFactor\n  )\n  let rowStart = Math.floor(\n    (tile.row * tile.tileZoomLevel.scaleFactor) / scaleFactor\n  )\n  rowStart = rowStart >= 0 ? rowStart : 0\n  const rowEnd = Math.ceil(\n    ((tile.row + 1) * tile.tileZoomLevel.scaleFactor) / scaleFactor\n  )\n  return getTilesAtScaleFactor(\n    scaleFactor,\n    parsedImage,\n    columnStart,\n    columnEnd,\n    rowStart,\n    rowEnd,\n    validTile\n  )\n}\n\nexport function getTilesAtScaleFactor(\n  scaleFactor: number,\n  parsedImage: Image,\n  columnStart?: number,\n  columnEnd?: number,\n  rowStart?: number,\n  rowEnd?: number,\n  validTile: (tile: Tile) => boolean = (_tile: Tile) => true\n) {\n  const tileZoomLevel = parsedImage.tileZoomLevels.find(\n    (tileZoomLevel) => tileZoomLevel.scaleFactor === scaleFactor\n  )\n  const imageSize = [parsedImage.width, parsedImage.height] as Size\n\n  if (!tileZoomLevel) {\n    return []\n  }\n\n  columnStart = columnStart ? columnStart : 0\n  columnEnd = columnEnd ? columnEnd : tileZoomLevel.columns\n  rowStart = rowStart ? rowStart : 0\n  rowEnd = rowEnd ? rowEnd : tileZoomLevel.rows\n\n  const tiles: Tile[] = []\n  for (let column = columnStart; column < columnEnd; column++) {\n    for (let row = rowStart; row < rowEnd; row++) {\n      const tile = {\n        column,\n        row,\n        tileZoomLevel,\n        imageSize\n      }\n      if (validTile(tile)) {\n        tiles.push(tile)\n      }\n    }\n  }\n\n  return tiles\n}\n\n// Identity\n\nexport function equalTileByRowColumnScaleFactor(\n  tile0: Tile,\n  tile1: Tile\n): boolean {\n  return (\n    tile0.column === tile1.column &&\n    tile0.row === tile1.row &&\n    tile0.tileZoomLevel.scaleFactor === tile1.tileZoomLevel.scaleFactor\n  )\n}\n\n// Geometric computations\n\nexport function distanceTileToPoint(tile: Tile, point: Point): number {\n  return distance(tileCenter(tile), point)\n}\n\nexport function squaredDistanceTileToPoint(tile: Tile, point: Point): number {\n  return squaredDistance(tileCenter(tile), point)\n}\n\nexport function tileCenter(tile: Tile): Point {\n  const bbox = computeBboxTile(tile)\n\n  return [(bbox[2] - bbox[0]) / 2 + bbox[0], (bbox[3] - bbox[1]) / 2 + bbox[1]]\n}\n\n/**\n * Returns the resource coordinates of the tile's origin point\n *\n * @export\n * @param tile\n * @returns\n */\nexport function tileToTileOriginPoint(tile: Tile): Point {\n  return [\n    tile.column * tile.tileZoomLevel.originalWidth,\n    tile.row * tile.tileZoomLevel.originalHeight\n  ]\n}\n\nexport function clipTilePointToTile(tilePoint: Point, tile: Tile): Point {\n  const tileSize = [tile.tileZoomLevel.width, tile.tileZoomLevel.height]\n  return tilePoint.map((coordinate, index) => {\n    coordinate = Math.max(coordinate, 0)\n    coordinate = Math.min(coordinate, tileSize[index] - 1)\n    return coordinate\n  }) as Point\n}\n\n/**\n * From the input point in resource coordinates, returns the same point in tile coordinates\n * I.e. relative to the tile's origin point and scaled using the scale factor\n *\n * @param resourcePoint\n * @param tile\n * @param clip\n * @returns\n */\nexport function resourcePointToTilePoint(\n  resourcePoint: Point,\n  tile: Tile,\n  clip = true\n): Point | undefined {\n  const resourceTileOriginPoint = tileToTileOriginPoint(tile)\n  const tilePoint = [\n    (resourcePoint[0] - resourceTileOriginPoint[0]) /\n      tile.tileZoomLevel.scaleFactor,\n    (resourcePoint[1] - resourceTileOriginPoint[1]) /\n      tile.tileZoomLevel.scaleFactor\n  ] as Point\n\n  if (\n    !clip ||\n    resourcePointInTile(resourcePoint, tile)\n    // && pointInImage(resourcePoint, tile)\n  ) {\n    return tilePoint\n  }\n}\n\nexport function resourcePointInTile(resourcePoint: Point, tile: Tile): boolean {\n  const resourceTileOrigin = tileToTileOriginPoint(tile)\n\n  return (\n    resourcePoint[0] >= resourceTileOrigin[0] &&\n    resourcePoint[0] <=\n      resourceTileOrigin[0] + tile.tileZoomLevel.originalWidth &&\n    resourcePoint[1] >= resourceTileOrigin[1] &&\n    resourcePoint[1] <=\n      resourceTileOrigin[1] + tile.tileZoomLevel.originalHeight\n  )\n}\n\nexport function resourcePointInImage(\n  resourcePoint: Point,\n  tile: Tile\n): boolean {\n  return (\n    resourcePoint[0] > 0 &&\n    resourcePoint[0] <= tile.imageSize[0] &&\n    resourcePoint[1] > 0 &&\n    resourcePoint[1] <= tile.imageSize[1]\n  )\n}\n\nexport function computeBboxTile(tile: Tile): Bbox {\n  const resourceTileOriginPoint = tileToTileOriginPoint(tile)\n\n  const resourceTileMaxX = Math.min(\n    resourceTileOriginPoint[0] + tile.tileZoomLevel.originalWidth,\n    tile.imageSize[0]\n  )\n  const resourceTileMaxY = Math.min(\n    resourceTileOriginPoint[1] + tile.tileZoomLevel.originalHeight,\n    tile.imageSize[1]\n  )\n\n  return [\n    resourceTileOriginPoint[0],\n    resourceTileOriginPoint[1],\n    resourceTileMaxX,\n    resourceTileMaxY\n  ]\n}\n\n// Resolution\n\nexport function getTileSize(tile: Tile): Size {\n  return [tile.tileZoomLevel.width, tile.tileZoomLevel.height]\n}\n\nexport function getTileOriginalSize(tile: Tile): Size {\n  return [tile.tileZoomLevel.originalWidth, tile.tileZoomLevel.originalHeight]\n}\n\nexport function getTileResolution(tile: Tile): number {\n  return sizeToResolution(getTileSize(tile))\n}\n\nexport function getTileOriginalResolution(tile: Tile): number {\n  return sizeToResolution(getTileOriginalSize(tile))\n}\n\nexport function getTilesResolution(tiles: Tile[]): number {\n  return tiles.map((tile) => getTileResolution(tile)).reduce((a, c) => a + c, 0)\n}\n\nexport function getTilesOriginalResolution(tiles: Tile[]): number {\n  return tiles\n    .map((tile) => getTileOriginalResolution(tile))\n    .reduce((a, c) => a + c, 0)\n}\n\nexport function getTileZoomLevelResolution(\n  tileZoomLevel: TileZoomLevel\n): number {\n  return (\n    tileZoomLevel.rows *\n    tileZoomLevel.width *\n    tileZoomLevel.columns *\n    tileZoomLevel.height\n  )\n}\n\nexport function getTileZoomLevelOriginalResolution(\n  tileZoomLevel: TileZoomLevel\n): number {\n  return (\n    tileZoomLevel.rows *\n    tileZoomLevel.originalWidth *\n    tileZoomLevel.columns *\n    tileZoomLevel.originalHeight\n  )\n}\n\n// Search at other scalefactors\n\nexport function getTilesAtOtherScaleFactors(\n  tile: Tile,\n  parsedImage: Image,\n  scaleFactor: number,\n  TEXTURES_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF: number,\n  TEXTURES_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF: number,\n  validTile?: (tile: Tile) => boolean\n): Tile[] {\n  const tilesAtOtherScaleFactors = []\n\n  const tilesAtLowerScaleFactor = recursivelyGetTilesAtLowerScaleFactor(\n    tile,\n    parsedImage,\n    scaleFactor,\n    TEXTURES_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF,\n    validTile\n  )\n  for (const tileAtLowerScaleFactor of tilesAtLowerScaleFactor) {\n    if (tileAtLowerScaleFactor) {\n      tilesAtOtherScaleFactors.push(tileAtLowerScaleFactor)\n    }\n  }\n  if (tilesAtOtherScaleFactors.length === 0) {\n    const tileAtHigherScaleFactor = recursivelyGetTilesAtHigherScaleFactor(\n      tile,\n      parsedImage,\n      scaleFactor,\n      TEXTURES_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF,\n      validTile\n    )\n    if (tileAtHigherScaleFactor) {\n      tilesAtOtherScaleFactors.push(tileAtHigherScaleFactor)\n    }\n  }\n\n  return tilesAtOtherScaleFactors\n}\n\nexport function recursivelyGetTilesAtHigherScaleFactor(\n  tile: Tile,\n  parsedImage: Image,\n  scaleFactor: number,\n  log2ScaleFactorDiff: number,\n  validTile?: (tile: Tile) => boolean\n): Tile | undefined {\n  const higherScaleFactor = 2 ** (Math.log2(scaleFactor) + 1)\n  if (\n    higherScaleFactor >\n      parsedImage.tileZoomLevels\n        .map((tileZoomLevel) => tileZoomLevel.scaleFactor)\n        .reduce((a, c) => a + c, 0) -\n        scaleFactor ||\n    log2ScaleFactorDiff === 0\n  ) {\n    return undefined\n  }\n  const tileAtHigherScaleFactor = getTileAtHigherScaleFactor(\n    tile,\n    parsedImage,\n    higherScaleFactor,\n    validTile\n  )\n  if (tileAtHigherScaleFactor !== undefined) {\n    return tileAtHigherScaleFactor\n  } else {\n    return recursivelyGetTilesAtHigherScaleFactor(\n      tile,\n      parsedImage,\n      higherScaleFactor,\n      log2ScaleFactorDiff--,\n      validTile\n    )\n  }\n}\n\nexport function recursivelyGetTilesAtLowerScaleFactor(\n  tile: Tile,\n  parsedImage: Image,\n  scaleFactor: number,\n  log2ScaleFactorDiff: number,\n  validTile?: (tile: Tile) => boolean\n): (Tile | undefined)[] {\n  const lowerScaleFactor = 2 ** (Math.log2(scaleFactor) - 1)\n  if (lowerScaleFactor <= 0 || log2ScaleFactorDiff === 0) {\n    return []\n  }\n  const tilesAtLowerScaleFactor = getTilesAtLowerScaleFactor(\n    tile,\n    parsedImage,\n    lowerScaleFactor,\n    validTile\n  )\n  const allTilesAtLowerScaleFactor = getTilesAtLowerScaleFactor(\n    tile,\n    parsedImage,\n    lowerScaleFactor,\n    (_tile) => true\n  )\n  if (tilesAtLowerScaleFactor.length === allTilesAtLowerScaleFactor.length) {\n    return tilesAtLowerScaleFactor\n  } else {\n    return [\n      ...tilesAtLowerScaleFactor,\n      ...recursivelyGetTilesAtLowerScaleFactor(\n        tile,\n        parsedImage,\n        lowerScaleFactor,\n        log2ScaleFactorDiff--,\n        validTile\n      )\n    ]\n  }\n}\n\nexport function getTileAtHigherScaleFactor(\n  tile: Tile,\n  parsedImage: Image,\n  higherScaleFactor: number,\n  validTile?: (tile: Tile) => boolean\n): Tile | undefined {\n  const tilesCoveringTileAtHigherScaleFactor =\n    getTilesCoveringTileAtScaleFactor(\n      tile,\n      parsedImage,\n      higherScaleFactor,\n      validTile\n    )\n\n  if (tilesCoveringTileAtHigherScaleFactor.length === 0) {\n    return undefined\n  }\n\n  return tilesCoveringTileAtHigherScaleFactor[0]\n}\n\nexport function getTilesAtLowerScaleFactor(\n  tile: Tile,\n  parsedImage: Image,\n  lowerScaleFactor: number,\n  validTile?: (tile: Tile) => boolean\n): (Tile | undefined)[] {\n  const tilesCoveringTileAtLowerScaleFactor = getTilesCoveringTileAtScaleFactor(\n    tile,\n    parsedImage,\n    lowerScaleFactor,\n    validTile\n  )\n\n  return tilesCoveringTileAtLowerScaleFactor\n}\n\n// Keys for search\n\n// TODO: consider a way to make this more elegant:\n// - many-to-many data structure\n// - a new compact class with just these two properties and an equality function between elements\n// - new JS tuple - https://github.com/tc39/proposal-record-tuple\n\nexport function fetchableTileKey(fetchableTile: FetchableTile): string {\n  return keyFromMapIdTileUrl(fetchableTile.mapId, fetchableTile.tileUrl)\n}\n\nexport function keyFromMapIdTileUrl(mapId: string, tileUrl: string): string {\n  return `${mapId}:${tileUrl}`\n}\n\nexport function tileKey(tile: Tile): string {\n  return keyFromScaleFactorRowColumn(\n    tile.tileZoomLevel.scaleFactor,\n    tile.row,\n    tile.column\n  )\n}\n\nexport function keyFromScaleFactorRowColumn(\n  scaleFactor: number,\n  row: number,\n  column: number\n): string {\n  return `${scaleFactor}:${row}:${column}`\n}\n\nexport function tileUrl(tile: Tile, parsedImage: Image): string {\n  const imageRequest = parsedImage.getTileImageRequest(\n    tile.tileZoomLevel,\n    tile.column,\n    tile.row\n  )\n  return parsedImage.getImageUrl(imageRequest)\n}\n\n// TileCache\n\nexport function shouldPruneTile(\n  tile: Tile,\n  mapPruneInfo: MapPruneInfo,\n  mapPruneConstants: MapPruneConstants\n) {\n  // Don't prune if overview\n  // Note that resourceViewportRingBboxForViewport and tileZoomLevelForViewport are only undefined\n  // if overview tile, so we add them here to prevent TypeScript errors furter on\n  if (\n    mapPruneInfo.overviewTileZoomLevelForViewport &&\n    tile.tileZoomLevel.scaleFactor ==\n      mapPruneInfo.overviewTileZoomLevelForViewport.scaleFactor\n  ) {\n    return false\n  }\n\n  // Prune if the tileZoomLevelForViewport or resourceViewportRingBboxForViewport are undefined\n  // (this only happens if the map is too small to render)\n  if (\n    mapPruneInfo.resourceViewportRingBboxForViewport === undefined ||\n    mapPruneInfo.tileZoomLevelForViewport === undefined\n  ) {\n    return true\n  }\n\n  // Should prune if scale factor too much off\n  //\n  // Example:\n  // Available scaleFactors in tileZoomLevels:\n  // 1 (full original resolution), 2, 4, 8, 16 (zoomed out)\n  //\n  // Tile scale factor: 16, so log2 tile scale factor: 4\n  // Scale factor for viewport: 8, so log2 scale factor for viewport: 3\n  // Difference: 4 - 3 = 1, check if not more then max\n  // This is positive if tile scale factor is higher then scale factor for viewport, so tiles are lower original resolution\n  //\n  // Since there are less lower original resolution tiles,\n  // MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF can be higher then MAX_LOWER_LOG2_SCALE_FACTOR_DIFF\n  //\n  const log2ScaleFactorDiff =\n    Math.log2(tile.tileZoomLevel.scaleFactor) -\n    Math.log2(mapPruneInfo.tileZoomLevelForViewport.scaleFactor)\n  // Check if scale factor not too high, i.e. tile resolution too low\n  const tileScaleFactorTooHigh =\n    log2ScaleFactorDiff > mapPruneConstants.maxHigherLog2ScaleFactorDiff\n  if (tileScaleFactorTooHigh) {\n    return true\n  }\n  // Check if scale factor not too low, i.e. tile resolution too high\n  const tileScaleFactorTooLow =\n    -log2ScaleFactorDiff > mapPruneConstants.maxLowerLog2ScaleFactorDiff\n  if (tileScaleFactorTooLow) {\n    return true\n  }\n\n  // Prune if too far away\n  // Note that we correct the tile bbox by buffering the scale factor difference (if positive)\n  // This allows us to keep all tiles that would be needed if we zoom out again\n  // Even if they currently don't overlap with the viewport ring bbox\n  if (\n    !doBboxesIntersect(\n      bufferBboxByRatio(\n        computeBboxTile(tile),\n        Math.max(0, log2ScaleFactorDiff)\n      ),\n      mapPruneInfo.resourceViewportRingBboxForViewport\n    )\n  ) {\n    return true\n  }\n\n  // By default, don't prune\n  return false\n}\n"],"names":["tileZoomLevel","tileUrl"],"mappings":"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"}