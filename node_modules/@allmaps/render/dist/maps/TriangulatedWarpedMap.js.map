{"version":3,"file":"TriangulatedWarpedMap.js","sources":["../../src/maps/TriangulatedWarpedMap.ts"],"sourcesContent":["import { GeoreferencedMap } from '@allmaps/annotation'\nimport { triangulateToUnique } from '@allmaps/triangulate'\nimport {\n  mixNumbers,\n  mixPoints,\n  getPropertyFromCacheOrComputation,\n  getPropertyFromTripleCacheOrComputation\n} from '@allmaps/stdlib'\n\nimport { WarpedMap } from './WarpedMap.js'\n\nimport type { WarpedMapOptions } from '../shared/types.js'\n\nimport type {\n  GcpAndDistortions,\n  DistortionMeasure,\n  TransformationType\n} from '@allmaps/transform'\nimport type { Gcp, Point, Ring, TypedPolygon } from '@allmaps/types'\nimport type { TriangulationToUnique } from '@allmaps/triangulate'\nimport type { Projection } from '@allmaps/project'\n\nconst DEFAULT_RESOURCE_RESOLUTION = undefined // TODO: allow to set via options\nconst DEFAULT_DISTORTION_MEASURES: DistortionMeasure[] = [\n  'log2sigma',\n  'twoOmega'\n]\n// TODO: allow to set via options\n\nfunction createDefaultTriangulatedWarpedMapOptions(): Partial<WarpedMapOptions> {\n  return {}\n}\n\nexport function createTriangulatedWarpedMapFactory() {\n  return (\n    mapId: string,\n    georeferencedMap: GeoreferencedMap,\n    options?: Partial<WarpedMapOptions>\n  ) => new TriangulatedWarpedMap(mapId, georeferencedMap, options)\n}\n\ntype GcpTriangulation = {\n  resourceResolution: number | undefined\n  gcpUniquePoints: GcpAndDistortions[]\n  uniquePointIndices: number[]\n  uniquePointIndexInterpolatedPolygon: TypedPolygon<number>\n}\n\n/**\n * Class for triangulated WarpedMaps.\n *\n * @param resourcePreviousResolution - Resolution (or 'distance') used during the previous triangulation of the resource mask\n * @param resourceResolution - Resolution (or 'distance') used during the triangulation of the resource mask, computed as the finest resource segment resulting from a resource-to-geo transformation of the horizontal and vertical midline of the resource bbox using the current transformation type\n * @param triangulateErrorCount - Number of time the triangulation has resulted in an error\n * @param projectedGcpPreviousTriangulation - Previous triangulation of the resource mask\n * @param projectedGcpTriangulation - Triangulation of the resource mask of a specific resource resolution, with unique points in resource and projected geospatial coordinates with distortions, and indices pointing to the triangles points and indices pointing to the triangulation-refined resource mask\n * @param resourceTrianglePoints - Triangle points of the triangles the triangulated resourceMask\n * @param projectedGeoPreviousTrianglePoints - The projectedGeoTrianglePoints of the previous transformation type, used during transformation transitions\n * @param projectedGeoTrianglePoints - The resourceTrianglePoints in projected geospatial coordinates\n * @param previousTrianglePointsDistortion - The trianglePointsDistortion of the previous transformation type, used during transformation transitions\n * @param trianglePointsDistortion - Distortion amount of the distortionMeasure at the projectedGeoTrianglePoints\n * @param projectedGeoPreviousTriangulationMask - The resource mask refined by the previous triangulation, in projected geospatial coordinates\n * @param projectedGeoTriangulationMask - The resource mask refined by the triangulation, in projected geospatial coordinates\n */\nexport class TriangulatedWarpedMap extends WarpedMap {\n  previousResourceResolution: number | undefined\n  resourceResolution: number | undefined\n\n  triangulateErrorCount = 0\n\n  projectedGcpPreviousTriangulation?: GcpTriangulation\n  projectedGcpTriangulation?: GcpTriangulation\n  protected resourceTriangulationCache: Map<number, TriangulationToUnique>\n  protected projectedGcpTriangulationCache: Map<\n    number,\n    Map<TransformationType, Map<Projection, GcpTriangulation>>\n  >\n\n  resourceTrianglePoints: Point[] = []\n\n  projectedGeoPreviousTrianglePoints: Point[] = []\n  projectedGeoTrianglePoints: Point[] = []\n\n  previousTrianglePointsDistortion: number[] = []\n  trianglePointsDistortion: number[] = []\n\n  projectedGeoPreviousTriangulationMask: Ring = []\n  projectedGeoTriangulationMask: Ring = []\n\n  /**\n   * Creates an instance of a TriangulatedWarpedMap.\n   *\n   * @param mapId - ID of the map\n   * @param georeferencedMap - Georeferenced map used to construct the WarpedMap\n   * @param options - Options\n   */\n  constructor(\n    mapId: string,\n    georeferencedMap: GeoreferencedMap,\n    options?: Partial<WarpedMapOptions>\n  ) {\n    options = {\n      ...createDefaultTriangulatedWarpedMapOptions(),\n      ...options\n    }\n\n    super(mapId, georeferencedMap, options)\n\n    this.resourceTriangulationCache = new Map()\n    this.projectedGcpTriangulationCache = new Map()\n\n    this.updateTriangulation()\n  }\n\n  /**\n   * Update the ground control points loaded from a georeferenced map to new ground control points.\n   *\n   * @param gcps - the new ground control points\n   */\n  setGcps(gcps: Gcp[]): void {\n    super.setGcps(gcps)\n    this.clearResourceTriangulationCaches()\n    this.updateTriangulation()\n  }\n\n  /**\n   * Update the resource mask loaded from a georeferenced map to a new mask.\n   *\n   * @param resourceMask - the new mask\n   */\n  setResourceMask(resourceMask: Ring): void {\n    super.setResourceMask(resourceMask)\n    this.clearResourceTriangulationCaches()\n    this.updateTriangulation()\n  }\n\n  /**\n   * Set the distortionMeasure\n   *\n   * @param distortionMeasure - the disortion measure\n   */\n  setDistortionMeasure(distortionMeasure?: DistortionMeasure): void {\n    super.setDistortionMeasure(distortionMeasure)\n    this.updateTrianglePointsDistortion()\n  }\n\n  /**\n   * Set the internal projection\n   *\n   * @param projection - the internal projection\n   */\n  setInternalProjection(projection: Projection): void {\n    super.setInternalProjection(projection)\n    this.updateTriangulation()\n  }\n\n  /**\n   * Set the projection\n   *\n   * @param projection - the projection\n   */\n  setProjection(projection: Projection): void {\n    super.setProjection(projection)\n    this.clearProjectedTriangulationCaches()\n    this.updateTriangulation()\n  }\n\n  /**\n   * Reset previous transform properties to new ones (when completing a transformer transitions).\n   */\n  resetPrevious() {\n    super.resetPrevious()\n    this.previousResourceResolution = this.resourceResolution\n    this.projectedGcpPreviousTriangulation = this.projectedGcpTriangulation\n    this.projectedGeoPreviousTrianglePoints = this.projectedGeoTrianglePoints\n    this.previousTrianglePointsDistortion = this.trianglePointsDistortion\n\n    this.projectedGeoPreviousTriangulationMask =\n      this.projectedGeoTriangulationMask\n  }\n\n  /**\n   * Mix previous transform properties with new ones (when changing an ongoing transformer transition).\n   *\n   * @param t - animation progress\n   */\n  mixPreviousAndNew(t: number) {\n    super.mixPreviousAndNew(t)\n\n    if (\n      this.projectedGcpPreviousTriangulation &&\n      this.projectedGcpTriangulation\n    ) {\n      const projectedGcpPreviousTriangulation =\n        this.projectedGcpPreviousTriangulation\n      const projectedGcpTriangulation = this.projectedGcpTriangulation\n\n      this.previousResourceResolution = this.resourceResolution\n      this.projectedGcpPreviousTriangulation = {\n        resourceResolution:\n          projectedGcpPreviousTriangulation.resourceResolution,\n        gcpUniquePoints: projectedGcpPreviousTriangulation.gcpUniquePoints.map(\n          (projectedGcp, index) => {\n            return {\n              resource: projectedGcp.resource,\n              geo: mixPoints(\n                projectedGcpTriangulation.gcpUniquePoints[index].geo,\n                projectedGcp.geo,\n                t\n              ),\n              // Note: Not mixing the distortions Map, only the active distortion\n              distortions:\n                projectedGcpTriangulation.gcpUniquePoints[index].distortions,\n              distortion: mixNumbers(\n                projectedGcpTriangulation.gcpUniquePoints[index].distortion ||\n                  0,\n                projectedGcp.distortion || 0,\n                t\n              )\n            }\n          }\n        ),\n        uniquePointIndices:\n          projectedGcpPreviousTriangulation.uniquePointIndices,\n        uniquePointIndexInterpolatedPolygon:\n          projectedGcpPreviousTriangulation.uniquePointIndexInterpolatedPolygon\n      }\n\n      this.projectedGeoPreviousTrianglePoints =\n        projectedGcpPreviousTriangulation.uniquePointIndices.map(\n          (i) => projectedGcpPreviousTriangulation.gcpUniquePoints[i].geo\n        )\n      this.previousTrianglePointsDistortion =\n        projectedGcpPreviousTriangulation.uniquePointIndices.map(\n          (i) =>\n            projectedGcpPreviousTriangulation.gcpUniquePoints[i]\n              .distortion as number\n        )\n    }\n\n    this.projectedGeoPreviousTriangulationMask =\n      this.projectedGeoTriangulationMask.map((point, index) => {\n        return mixPoints(\n          point,\n          this.projectedGeoPreviousTriangulationMask[index],\n          t\n        )\n      })\n  }\n\n  /**\n   * Update the (previous and new) triangulation of the resourceMask. Use cache if available.\n   */\n  private updateTriangulation() {\n    // The following ensures this function is only run after initialisation\n    // This class' constructor calls this function twice\n    // Once via super() and updateTransformerProperties()\n    // but then the cache is not ready yet, so we make it return\n    // And once at the end\n    if (\n      !this.resourceTriangulationCache ||\n      !this.projectedGcpTriangulationCache\n    ) {\n      return\n    }\n\n    // Get resolution from transform\n    const resourceResolution =\n      DEFAULT_RESOURCE_RESOLUTION ||\n      this.projectedTransformer.getToGeoTransformationResolution(\n        this.resourceMaskBbox\n      )\n\n    // Adapt resolution from previous\n    let refinePrevious = false\n    if (resourceResolution && this.previousResourceResolution) {\n      refinePrevious = this.previousResourceResolution < resourceResolution\n      this.resourceResolution = Math.min(\n        resourceResolution,\n        this.previousResourceResolution\n      )\n    }\n    if (resourceResolution && !this.previousResourceResolution) {\n      refinePrevious = true\n      this.resourceResolution = resourceResolution\n    }\n    if (!resourceResolution && this.previousResourceResolution) {\n      this.resourceResolution = this.previousResourceResolution\n    } else if (!resourceResolution && !this.previousResourceResolution) {\n      this.resourceResolution = undefined\n    }\n\n    // Compute triangulation\n    this.projectedGcpTriangulation = getPropertyFromTripleCacheOrComputation(\n      this.projectedGcpTriangulationCache,\n      this.resourceResolution,\n      this.transformationType,\n      this.internalProjection,\n      () => {\n        const {\n          uniquePoints,\n          uniquePointIndexTriangles,\n          uniquePointIndexInterpolatedPolygon\n        } = getPropertyFromCacheOrComputation(\n          this.resourceTriangulationCache,\n          this.resourceResolution,\n          () =>\n            triangulateToUnique([this.resourceMask], this.resourceResolution, {\n              steinerPoints: this.gcps.map((gcp) => gcp.resource)\n            })\n        )\n\n        // Extend Triangulation to ProjectedGcpTriangulation\n        // By including projectedGeo and distortions\n        const resourceResolution = this.resourceResolution\n        const resourceUniquePoints = uniquePoints as Point[]\n        const gcpUniquePoints = resourceUniquePoints.map((resourcePoint) =>\n          this.projectedTransformer.transformToGeo(\n            resourcePoint,\n            {\n              distortionMeasures: DEFAULT_DISTORTION_MEASURES,\n              referenceScale: this.getReferenceScale()\n            },\n            (gcpPartialDistortion) => gcpPartialDistortion\n          )\n        )\n        const uniquePointIndices = uniquePointIndexTriangles.flat() as number[]\n\n        return {\n          resourceResolution,\n          gcpUniquePoints,\n          uniquePointIndices,\n          uniquePointIndexInterpolatedPolygon\n        }\n      }\n    )\n\n    if (!this.projectedGcpPreviousTriangulation) {\n      this.projectedGcpPreviousTriangulation = this.projectedGcpTriangulation\n    }\n\n    // If new triangulation has higher resolution then previous, refine previous from new\n    if (refinePrevious) {\n      this.previousResourceResolution = this.resourceResolution\n      this.projectedGcpPreviousTriangulation =\n        getPropertyFromTripleCacheOrComputation(\n          this.projectedGcpTriangulationCache,\n          this.previousResourceResolution,\n          this.previousTransformationType,\n          this.previousInternalProjection,\n          () => {\n            if (!this.projectedGcpTriangulation) {\n              // TODO: rewrite this function, make more readble?\n              throw new Error('No projectedGcpTriangulation')\n            }\n            const projectedGcpTriangulation = this.projectedGcpTriangulation\n\n            return {\n              resourceResolution:\n                this.projectedGcpTriangulation.resourceResolution,\n              gcpUniquePoints:\n                this.projectedGcpTriangulation.gcpUniquePoints.map(\n                  (projectedGcp) =>\n                    this.projectedPreviousTransformer.transformToGeo(\n                      projectedGcp.resource,\n                      {\n                        distortionMeasures: DEFAULT_DISTORTION_MEASURES,\n                        referenceScale: this.getReferenceScale()\n                      },\n                      (gcpPartialDistortion) => gcpPartialDistortion\n                    )\n                ),\n              uniquePointIndices:\n                this.projectedGcpTriangulation.uniquePointIndices,\n              uniquePointIndexInterpolatedPolygon:\n                projectedGcpTriangulation.uniquePointIndexInterpolatedPolygon\n            }\n          },\n          () => !this.mixed,\n          () => !this.mixed\n        )\n    }\n\n    this.updateTrianglePoints()\n  }\n\n  /**\n   * Derive the (previous and new) resource and projectedGeo points from their corresponding triangulations.\n   *\n   * Also derive the (previous and new) triangulation-refined resource and projectedGeo mask\n   */\n  private updateTrianglePoints() {\n    if (\n      !this.projectedGcpPreviousTriangulation ||\n      !this.projectedGcpTriangulation\n    ) {\n      return\n    }\n    const projectedGcpPreviousTriangulation =\n      this.projectedGcpPreviousTriangulation\n    const projectedGcpTriangulation = this.projectedGcpTriangulation\n\n    this.resourceTrianglePoints =\n      this.projectedGcpTriangulation.uniquePointIndices.map(\n        (i) => projectedGcpTriangulation.gcpUniquePoints[i].resource\n      )\n    this.projectedGeoPreviousTrianglePoints =\n      this.projectedGcpPreviousTriangulation.uniquePointIndices.map(\n        (i) => projectedGcpPreviousTriangulation.gcpUniquePoints[i].geo\n      )\n    this.projectedGeoTrianglePoints =\n      this.projectedGcpTriangulation.uniquePointIndices.map(\n        (i) => projectedGcpTriangulation.gcpUniquePoints[i].geo\n      )\n\n    this.projectedGeoPreviousTriangulationMask =\n      this.projectedGcpPreviousTriangulation.uniquePointIndexInterpolatedPolygon\n        .map((typedRing) =>\n          typedRing.map(\n            (i) => projectedGcpPreviousTriangulation.gcpUniquePoints[i].geo\n          )\n        )\n        .flat()\n    this.projectedGeoTriangulationMask =\n      this.projectedGcpTriangulation.uniquePointIndexInterpolatedPolygon\n        .map((typedRing) =>\n          typedRing.map((i) => projectedGcpTriangulation.gcpUniquePoints[i].geo)\n        )\n        .flat()\n\n    this.updateTrianglePointsDistortion()\n  }\n\n  /**\n   * Derive the (previous and new) distortions from their corresponding triangulations.\n   */\n  private updateTrianglePointsDistortion() {\n    if (\n      !this.projectedGcpPreviousTriangulation ||\n      !this.projectedGcpTriangulation\n    ) {\n      return\n    }\n    const projectedGcpPreviousTriangulation =\n      this.projectedGcpPreviousTriangulation\n    const projectedGcpTriangulation = this.projectedGcpTriangulation\n\n    this.previousTrianglePointsDistortion =\n      projectedGcpPreviousTriangulation.uniquePointIndices.map((i) => {\n        const distortions =\n          projectedGcpPreviousTriangulation.gcpUniquePoints[i].distortions\n        if (!this.previousDistortionMeasure || !distortions) {\n          return 0\n        } else {\n          return distortions.get(this.previousDistortionMeasure) as number\n        }\n      })\n    this.trianglePointsDistortion =\n      projectedGcpTriangulation.uniquePointIndices.map((i) => {\n        const distortions =\n          projectedGcpTriangulation.gcpUniquePoints[i].distortions\n        if (!this.distortionMeasure || !distortions) {\n          return 0\n        } else {\n          return distortions.get(this.distortionMeasure) as number\n        }\n      })\n  }\n\n  protected updateProjectedTransformerProperties(): void {\n    super.updateProjectedTransformerProperties()\n    this.updateTriangulation()\n  }\n\n  protected clearProjectedTransformerCaches() {\n    super.clearProjectedTransformerCaches()\n    this.clearResourceTriangulationCaches()\n  }\n\n  protected clearResourceTriangulationCaches() {\n    this.resourceTriangulationCache = new Map()\n    this.clearProjectedTriangulationCaches()\n  }\n\n  protected clearProjectedTriangulationCaches() {\n    this.projectedGcpTriangulationCache = new Map()\n  }\n}\n"],"names":["resourceResolution"],"mappings":"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"}