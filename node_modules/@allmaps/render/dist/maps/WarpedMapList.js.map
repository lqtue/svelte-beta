{"version":3,"file":"WarpedMapList.js","sources":["../../src/maps/WarpedMapList.ts"],"sourcesContent":["import { generateChecksum } from '@allmaps/id'\nimport {\n  parseAnnotation,\n  validateGeoreferencedMap,\n  type GeoreferencedMap\n} from '@allmaps/annotation'\nimport { isEqualProjection, proj4 } from '@allmaps/project'\n\nimport { RTree } from './RTree.js'\nimport { WarpedMap } from './WarpedMap.js'\n\nimport {\n  bboxToCenter,\n  computeBbox,\n  convexHull,\n  mergeOptions,\n  mergePartialOptions\n} from '@allmaps/stdlib'\nimport { WarpedMapEvent, WarpedMapEventType } from '../shared/events.js'\n\nimport type {\n  ProjectionOptions,\n  SelectionOptions,\n  WarpedMapFactory,\n  WarpedMapListOptions\n} from '../shared/types.js'\n\nimport type { DistortionMeasure, TransformationType } from '@allmaps/transform'\nimport type { Projection } from '@allmaps/project'\nimport type { Ring, Bbox, Gcp, Point, ImageInformations } from '@allmaps/types'\n\nconst defaultSelectionOptions: SelectionOptions = {\n  onlyVisible: true\n}\n\nconst defaultWarpedMapListOptions: Partial<WarpedMapListOptions> = {\n  createRTree: true,\n  imageInformations: new Map()\n}\n\n/**\n * An ordered list of WarpedMaps. This class contains an optional RTree\n * for quickly looking up maps using their Bbox\n * @template W - The type of WarpedMap objects in this list\n */\nexport class WarpedMapList<W extends WarpedMap> extends EventTarget {\n  warpedMapFactory: WarpedMapFactory<W>\n\n  /**\n   * Maps in this list, indexed by their ID\n   */\n  warpedMapsById: Map<string, W>\n  zIndices: Map<string, number>\n\n  rtree?: RTree\n\n  partialWarpedMapListOptions: Partial<WarpedMapListOptions>\n\n  /**\n   * Creates an instance of a WarpedMapList\n   *\n   * @constructor\n   * @param warpedMapFactory - Factory function for creating WarpedMap objects\n   * @param partialWarpedMapListOptions - Options\n   */\n  constructor(\n    warpedMapFactory: WarpedMapFactory<W>,\n    partialWarpedMapListOptions?: Partial<WarpedMapListOptions>\n  ) {\n    super()\n\n    this.warpedMapsById = new Map()\n    this.zIndices = new Map()\n\n    this.warpedMapFactory = warpedMapFactory\n\n    this.partialWarpedMapListOptions = mergePartialOptions(\n      defaultWarpedMapListOptions,\n      partialWarpedMapListOptions\n    )\n\n    if (this.partialWarpedMapListOptions.createRTree) {\n      this.rtree = new RTree()\n    }\n  }\n\n  /**\n   * Get mapIds for selected maps\n   *\n   * Also allows to only select maps whose geoBbox overlaps with the specified geoBbox\n   *\n   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps\n   * @returns mapIds\n   */\n  getMapIds(\n    partialSelectionOptions?: Partial<SelectionOptions>\n  ): Iterable<string> {\n    // Enable the same selection options when getting mapIds\n    return Array.from(this.getWarpedMaps(partialSelectionOptions)).map(\n      (warpedMap) => warpedMap.mapId\n    )\n  }\n\n  /**\n   * Get the WarpedMap instances for selected maps\n   *\n   * Also allows to only select maps whose geoBbox overlaps with the specified geoBbox\n   *\n   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps\n   * @returns WarpedMap instances\n   */\n  getWarpedMaps(\n    partialSelectionOptions?: Partial<SelectionOptions>\n  ): Iterable<W> {\n    const selectionOptions = mergeOptions(\n      defaultSelectionOptions,\n      partialSelectionOptions\n    )\n\n    let mapIds\n    if (selectionOptions.mapIds === undefined) {\n      if (this.rtree && selectionOptions.geoBbox) {\n        mapIds = this.rtree.searchFromBbox(selectionOptions.geoBbox)\n      } else {\n        mapIds = Array.from(this.warpedMapsById.keys())\n      }\n    } else {\n      mapIds = selectionOptions.mapIds\n    }\n\n    const warpedMaps: W[] = []\n\n    if (mapIds === undefined) {\n      return warpedMaps\n    }\n\n    for (const mapId of mapIds) {\n      const warpedMap = this.warpedMapsById.get(mapId)\n      if (\n        warpedMap &&\n        (selectionOptions.onlyVisible ? warpedMap.visible : true)\n      ) {\n        warpedMaps.push(warpedMap)\n      }\n    }\n    return warpedMaps\n  }\n\n  /**\n   * Get the WarpedMap instance for a specific map\n   *\n   * @param mapId - Map ID of the requested WarpedMap instance\n   * @returns WarpedMap instance, or undefined\n   */\n  getWarpedMap(mapId: string): W | undefined {\n    return this.warpedMapsById.get(mapId)\n  }\n\n  /**\n   * Get the z-index for a specific map\n   *\n   * @param mapId\n   * @returns\n   */\n  getMapZIndex(mapId: string): number | undefined {\n    return this.zIndices.get(mapId)\n  }\n\n  /**\n   * Get the center of the bounding box of the maps in this list\n   *\n   * Use {projection: 'EPSG:4326'} to request the result in lon-lat `EPSG:4326`\n   *\n   * @param partialSelectionAndProjectionOptions - Selection (e.g. mapIds) and projection options, defaults to all visible maps and current projection\n   * @returns The center of the bbox of all selected maps, in the chosen projection, or undefined if there were no maps matching the selection.\n   */\n  getMapsCenter(\n    partialSelectionAndProjectionOptions?: Partial<\n      SelectionOptions & ProjectionOptions\n    >\n  ): Point | undefined {\n    const bbox = this.getMapsBbox(partialSelectionAndProjectionOptions)\n    if (bbox) {\n      return bboxToCenter(bbox)\n    }\n  }\n\n  /**\n   * Get the bounding box of the maps in this list\n   *\n   * Use {projection: 'EPSG:4326'} to request the result in lon-lat `EPSG:4326`\n   *\n   * @param partialSelectionAndProjectionOptions - Selection (e.g. mapIds) and projection options, defaults to all visible maps and current projection\n   * @returns The bbox of all selected maps, in the chosen projection, or undefined if there were no maps matching the selection.\n   */\n  getMapsBbox(\n    partialSelectionAndProjectionOptions?: Partial<\n      SelectionOptions & ProjectionOptions\n    >\n  ): Bbox | undefined {\n    // Note: we can't use the geoMaskBboxes since creating a bbox\n    // gives a different result in a different projection\n\n    const projectedGeoMaskPoints = this.getProjectedGeoMaskPoints(\n      partialSelectionAndProjectionOptions\n    )\n    return computeBbox(projectedGeoMaskPoints)\n  }\n\n  /**\n   * Get the convex hull of the maps in this list\n   *\n   * Use {projection: 'EPSG:4326'} to request the result in lon-lat `EPSG:4326`\n   *\n   * @param partialSelectionAndProjectionOptions - Selection (e.g. mapIds) and projection options, defaults to all visible maps and current projection\n   * @returns The convex hull of all selected maps, in the chosen projection, or undefined if there were no maps matching the selection.\n   */\n  getMapsConvexHull(\n    partialSelectionAndProjectionOptions?: Partial<\n      SelectionOptions & ProjectionOptions\n    >\n  ): Ring | undefined {\n    const projectedGeoMaskPoints = this.getProjectedGeoMaskPoints(\n      partialSelectionAndProjectionOptions\n    )\n    return convexHull(projectedGeoMaskPoints)\n  }\n\n  /**\n   * Set the Warped Map List options\n   *\n   * @param partialWarpedMapListOptions - Options\n   */\n  setOptions(\n    partialWarpedMapListOptions?: Partial<WarpedMapListOptions>\n  ): void {\n    this.partialWarpedMapListOptions = mergeOptions(\n      this.partialWarpedMapListOptions,\n      partialWarpedMapListOptions\n    )\n    this.dispatchEvent(\n      new WarpedMapEvent(WarpedMapEventType.OPTIONSCHANGED, this.getMapIds())\n    )\n  }\n\n  /**\n   * Sets the object that caches image information\n   *\n   * @param imageInformations - object that caches image information\n   */\n  setImageInformations(imageInformations: ImageInformations): void {\n    this.partialWarpedMapListOptions.imageInformations = imageInformations\n  }\n\n  /**\n   * Sets the GCPs for a specific map\n   *\n   * @param gcps - new GCPs\n   * @param mapId - ID of the map\n   */\n  setMapGcps(gcps: Gcp[], mapId: string): void {\n    const warpedMap = this.warpedMapsById.get(mapId)\n    if (warpedMap) {\n      warpedMap.setGcps(gcps)\n      this.addToOrUpdateRtree(warpedMap)\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.GCPSCHANGED, mapId)\n      )\n    }\n  }\n\n  /**\n   * Sets the resource mask for a specific map\n   *\n   * @param resourceMask - the new resource mask\n   * @param mapId - ID of the map\n   */\n  setMapResourceMask(resourceMask: Ring, mapId: string): void {\n    const warpedMap = this.warpedMapsById.get(mapId)\n    if (warpedMap) {\n      warpedMap.setResourceMask(resourceMask)\n      this.addToOrUpdateRtree(warpedMap)\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.RESOURCEMASKCHANGED, mapId)\n      )\n    }\n  }\n\n  /**\n   * Sets the transformation type for a specific map\n   *\n   * @param transformationType - the new transformation type\n   * @param mapId - the ID of the map\n   */\n  setMapTransformationType(\n    transformationType: TransformationType,\n    mapId: string\n  ): void {\n    this.setMapsTransformationType(transformationType, { mapIds: [mapId] })\n  }\n\n  /**\n   * Sets the transformation type for selected maps\n   *\n   * @param transformationType - the new transformation type\n   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps\n   */\n  setMapsTransformationType(\n    transformationType: TransformationType,\n    partialSelectionOptions?: Partial<SelectionOptions>\n  ): void {\n    const mapIdsChanged = []\n    const warpedMaps = this.getWarpedMaps(partialSelectionOptions)\n    for (const warpedMap of warpedMaps) {\n      if (warpedMap.transformationType !== transformationType) {\n        mapIdsChanged.push(warpedMap.mapId)\n      }\n    }\n\n    if (mapIdsChanged.length > 0) {\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.PRECHANGE, mapIdsChanged)\n      )\n      mapIdsChanged.forEach((mapId) => {\n        const warpedMap = this.warpedMapsById.get(mapId)\n        if (warpedMap) {\n          warpedMap.setTransformationType(transformationType)\n          this.addToOrUpdateRtree(warpedMap)\n        }\n      })\n      this.dispatchEvent(\n        new WarpedMapEvent(\n          WarpedMapEventType.TRANSFORMATIONCHANGED,\n          mapIdsChanged\n        )\n      )\n    }\n  }\n\n  /**\n   * Sets the distortionMeasure for a specific map\n   *\n   * @param distortionMeasure - the distortion measure\n   * @param mapId - the ID of the map\n   */\n  setMapDistortionMeasure(\n    distortionMeasure: DistortionMeasure | undefined,\n    mapId: string\n  ): void {\n    this.setMapsDistortionMeasure(distortionMeasure, { mapIds: [mapId] })\n  }\n\n  /**\n   * Sets the distortion measure for selected maps\n   *\n   * @param distortionMeasure - the distortion measure\n   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps\n   */\n  setMapsDistortionMeasure(\n    distortionMeasure?: DistortionMeasure,\n    partialSelectionOptions?: Partial<SelectionOptions>\n  ): void {\n    const mapIdsChanged = []\n    const warpedMaps = this.getWarpedMaps(partialSelectionOptions)\n    for (const warpedMap of warpedMaps) {\n      if (warpedMap.distortionMeasure !== distortionMeasure) {\n        mapIdsChanged.push(warpedMap.mapId)\n      }\n    }\n    if (mapIdsChanged.length > 0) {\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.PRECHANGE, mapIdsChanged)\n      )\n      mapIdsChanged.forEach((mapId) => {\n        const warpedMap = this.warpedMapsById.get(mapId)\n        if (warpedMap) {\n          warpedMap.setDistortionMeasure(distortionMeasure)\n        }\n      })\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.DISTORTIONCHANGED, mapIdsChanged)\n      )\n    }\n  }\n\n  /**\n   * Sets the internal projection for a specific map\n   *\n   * @param projection - the internal projection\n   * @param mapId - the ID of the map\n   */\n  setMapInternalProjection(projection: Projection, mapId: string): void {\n    this.setMapsInternalProjection(projection, { mapIds: [mapId] })\n  }\n\n  /**\n   * Sets the internal projection for selected maps\n   *\n   * @param projection - the internal projection\n   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps\n   */\n  setMapsInternalProjection(\n    projection: Projection | undefined,\n    partialSelectionOptions?: Partial<SelectionOptions>\n  ): void {\n    const mapIdsChanged = []\n    const warpedMaps = this.getWarpedMaps(partialSelectionOptions)\n    for (const warpedMap of warpedMaps) {\n      if (!isEqualProjection(warpedMap.internalProjection, projection)) {\n        mapIdsChanged.push(warpedMap.mapId)\n      }\n    }\n    if (mapIdsChanged.length > 0) {\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.PRECHANGE, mapIdsChanged)\n      )\n      mapIdsChanged.forEach((mapId) => {\n        const warpedMap = this.warpedMapsById.get(mapId)\n        if (warpedMap) {\n          warpedMap.setInternalProjection(projection)\n          this.addToOrUpdateRtree(warpedMap)\n        }\n      })\n      this.dispatchEvent(\n        new WarpedMapEvent(\n          WarpedMapEventType.INTERNALPROJECTIONCHANGED,\n          mapIdsChanged\n        )\n      )\n    }\n  }\n\n  /**\n   * Sets the projection for a specific map\n   *\n   * @param projection - the projection\n   * @param mapId - the ID of the map\n   */\n  setMapProjection(projection: Projection, mapId: string): void {\n    this.setMapsProjection(projection, { mapIds: [mapId] })\n  }\n\n  /**\n   * Sets the projection for selected maps\n   *\n   * @param projection - the projection\n   * @param partialSelectionOptions - Selection options (e.g. mapIds), defaults to all visible maps\n   */\n  setMapsProjection(\n    projection: Projection | undefined,\n    partialSelectionOptions?: Partial<SelectionOptions>\n  ): void {\n    const mapIdsChanged = []\n    const warpedMaps = this.getWarpedMaps(partialSelectionOptions)\n    for (const warpedMap of warpedMaps) {\n      if (!isEqualProjection(warpedMap.projection, projection)) {\n        mapIdsChanged.push(warpedMap.mapId)\n      }\n    }\n    if (mapIdsChanged.length > 0) {\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.PRECHANGE, mapIdsChanged)\n      )\n      mapIdsChanged.forEach((mapId) => {\n        const warpedMap = this.warpedMapsById.get(mapId)\n        if (warpedMap) {\n          warpedMap.setProjection(projection)\n          this.addToOrUpdateRtree(warpedMap)\n        }\n      })\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.PROJECTIONCHANGED, mapIdsChanged)\n      )\n    }\n  }\n\n  /**\n   * Removes a warped map by its ID\n   *\n   * @param mapId - the ID of the map\n   *\n   * @param mapIds - Map IDs\n   */\n  removeGeoreferencedMapById(mapId: string) {\n    const warpedMap = this.warpedMapsById.get(mapId)\n    if (warpedMap) {\n      this.removeGeoreferencedMap(warpedMap)\n      this.removeFromRtree(warpedMap)\n\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.WARPEDMAPREMOVED, mapId)\n      )\n    }\n  }\n\n  /**\n   * Changes the z-index of the specified maps to bring them to front\n   *\n   * @param mapIds - Map IDs\n   */\n  bringMapsToFront(mapIds: Iterable<string>): void {\n    let newZIndex = this.warpedMapsById.size\n    for (const mapId of mapIds) {\n      if (this.zIndices.has(mapId)) {\n        this.zIndices.set(mapId, newZIndex)\n        newZIndex++\n      }\n    }\n    this.removeZIndexHoles()\n    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED))\n  }\n\n  /**\n   * Changes the z-index of the specified maps to send them to back\n   *\n   * @param mapIds - Map IDs\n   */\n  sendMapsToBack(mapIds: Iterable<string>): void {\n    let newZIndex = -Array.from(mapIds).length\n    for (const mapId of mapIds) {\n      if (this.zIndices.has(mapId)) {\n        this.zIndices.set(mapId, newZIndex)\n        newZIndex++\n      }\n    }\n    this.removeZIndexHoles()\n    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED))\n  }\n\n  /**\n   * Changes the z-index of the specified maps to bring them forward\n   *\n   * @param mapIds - Map IDs\n   */\n  bringMapsForward(mapIds: Iterable<string>): void {\n    for (const [mapId, zIndex] of this.zIndices.entries()) {\n      this.zIndices.set(mapId, zIndex * 2)\n    }\n    for (const mapId of mapIds) {\n      const zIndex = this.zIndices.get(mapId)\n      if (zIndex !== undefined) {\n        this.zIndices.set(mapId, zIndex + 3)\n      }\n    }\n    this.removeZIndexHoles()\n    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED))\n  }\n\n  /**\n   * Changes the zIndex of the specified maps to send them backward\n   *\n   * @param mapIds - Map IDs\n   */\n  sendMapsBackward(mapIds: Iterable<string>): void {\n    for (const [mapId, zIndex] of this.zIndices.entries()) {\n      this.zIndices.set(mapId, zIndex * 2)\n    }\n    for (const mapId of mapIds) {\n      const zIndex = this.zIndices.get(mapId)\n      if (zIndex !== undefined) {\n        this.zIndices.set(mapId, zIndex - 3)\n      }\n    }\n    this.removeZIndexHoles()\n    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED))\n  }\n\n  /**\n   * Changes the visibility of the specified maps to `true`\n   *\n   * @param mapIds - Map IDs\n   */\n  showMaps(mapIds: Iterable<string>): void {\n    for (const mapId of mapIds) {\n      const warpedMap = this.warpedMapsById.get(mapId)\n      if (warpedMap) {\n        warpedMap.visible = true\n      }\n    }\n    this.dispatchEvent(\n      new WarpedMapEvent(WarpedMapEventType.VISIBILITYCHANGED, mapIds)\n    )\n  }\n\n  /**\n   * Changes the visibility of the specified maps to `false`\n   *\n   * @param mapIds - Map IDs\n   */\n  hideMaps(mapIds: Iterable<string>): void {\n    for (const mapId of mapIds) {\n      const warpedMap = this.warpedMapsById.get(mapId)\n      if (warpedMap) {\n        warpedMap.visible = false\n      }\n    }\n    this.dispatchEvent(\n      new WarpedMapEvent(WarpedMapEventType.VISIBILITYCHANGED, mapIds)\n    )\n  }\n\n  /**\n   * Adds a georeferenced map to this list\n   *\n   * @param georeferencedMap\n   * @returns\n   */\n  async addGeoreferencedMap(\n    georeferencedMap: unknown\n  ): Promise<string | Error> {\n    const validatedGeoreferencedMapOrMaps =\n      validateGeoreferencedMap(georeferencedMap)\n    const validatedGeoreferencedMap = Array.isArray(\n      validatedGeoreferencedMapOrMaps\n    )\n      ? validatedGeoreferencedMapOrMaps[0]\n      : validatedGeoreferencedMapOrMaps\n    return this.addGeoreferencedMapInternal(validatedGeoreferencedMap)\n  }\n\n  /**\n   * Removes a georeferenced map from this list\n   *\n   * @param georeferencedMap\n   * @returns\n   */\n  async removeGeoreferencedMap(\n    georeferencedMap: unknown\n  ): Promise<string | Error> {\n    const validatedGeoreferencedMapOrMaps =\n      validateGeoreferencedMap(georeferencedMap)\n    const validatedGeoreferencedMap = Array.isArray(\n      validatedGeoreferencedMapOrMaps\n    )\n      ? validatedGeoreferencedMapOrMaps[0]\n      : validatedGeoreferencedMapOrMaps\n    return this.removeGeoreferencedMapInternal(validatedGeoreferencedMap)\n  }\n\n  /**\n   * Parses an annotation and adds its georeferenced map to this list\n   *\n   * @param annotation\n   * @returns\n   */\n  async addGeoreferenceAnnotation(annotation: unknown) {\n    const results: (string | Error)[] = []\n    const maps = parseAnnotation(annotation)\n    const settledResults = await Promise.allSettled(\n      maps.map((map) => this.addGeoreferencedMapInternal(map))\n    )\n    // TODO: make sure reason contains Error\n    for (const settledResult of settledResults) {\n      if (settledResult.status === 'fulfilled') {\n        results.push(settledResult.value)\n      } else {\n        results.push(settledResult.reason)\n      }\n    }\n    this.dispatchEvent(\n      new WarpedMapEvent(WarpedMapEventType.GEOREFERENCEANNOTATIONADDED)\n    )\n    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED))\n    return results\n  }\n\n  /**\n   * Parses an annotation and removes its georeferenced map from this list\n   *\n   * @param annotation\n   * @returns\n   */\n  async removeGeoreferenceAnnotation(\n    annotation: unknown\n  ): Promise<(string | Error)[]> {\n    const results: (string | Error)[] = []\n    const maps = parseAnnotation(annotation)\n    for (const map of maps) {\n      const mapIdOrError = await this.removeGeoreferencedMapInternal(map)\n      results.push(mapIdOrError)\n    }\n    this.dispatchEvent(\n      new WarpedMapEvent(WarpedMapEventType.GEOREFERENCEANNOTATIONREMOVED)\n    )\n    return results\n  }\n\n  clear(): void {\n    this.warpedMapsById = new Map()\n    this.zIndices = new Map()\n    this.rtree?.clear()\n    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.CLEARED))\n  }\n\n  destroy() {\n    for (const warpedMap of this.getWarpedMaps()) {\n      this.removeEventListenersFromWarpedMap(warpedMap)\n      warpedMap.destroy()\n    }\n\n    this.clear()\n  }\n\n  private async addGeoreferencedMapInternal(\n    georeferencedMap: GeoreferencedMap\n  ): Promise<string> {\n    const mapId = await this.getOrComputeMapId(georeferencedMap)\n\n    const warpedMap = this.warpedMapFactory(\n      mapId,\n      georeferencedMap,\n      this.partialWarpedMapListOptions\n    )\n\n    this.warpedMapsById.set(mapId, warpedMap)\n    this.zIndices.set(mapId, this.warpedMapsById.size - 1)\n    this.addToOrUpdateRtree(warpedMap)\n    this.addEventListenersToWarpedMap(warpedMap)\n    this.dispatchEvent(\n      new WarpedMapEvent(WarpedMapEventType.WARPEDMAPADDED, mapId)\n    )\n    return mapId\n  }\n\n  private async removeGeoreferencedMapInternal(\n    georeferencedMap: GeoreferencedMap\n  ): Promise<string> {\n    const mapId = await this.getOrComputeMapId(georeferencedMap)\n    const warpedMap = this.warpedMapsById.get(mapId)\n    if (warpedMap) {\n      this.warpedMapsById.delete(mapId)\n      this.zIndices.delete(mapId)\n      this.removeFromRtree(warpedMap)\n      this.dispatchEvent(\n        new WarpedMapEvent(WarpedMapEventType.WARPEDMAPREMOVED, mapId)\n      )\n      this.removeZIndexHoles()\n      this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.ZINDICESCHANGED))\n\n      warpedMap.destroy()\n    } else {\n      throw new Error(`No map found with ID ${mapId}`)\n    }\n    return mapId\n  }\n\n  private async getOrComputeMapId(\n    georeferencedMap: GeoreferencedMap\n  ): Promise<string> {\n    const mapId =\n      georeferencedMap.id || (await generateChecksum(georeferencedMap))\n    return mapId\n  }\n\n  private getProjectedGeoMaskPoints(\n    partialSelectionAndProjectionOptions?: Partial<\n      SelectionOptions & ProjectionOptions\n    >\n  ): Point[] {\n    const warpedMaps = this.getWarpedMaps(partialSelectionAndProjectionOptions)\n\n    // Project geoMask using projection, if specified in options\n    // otherwise use available projectedGeoMask\n    const projection = partialSelectionAndProjectionOptions?.projection\n    if (projection) {\n      const geoMaskPoints: Point[] = []\n      for (const warpedMap of warpedMaps) {\n        geoMaskPoints.push(...warpedMap.geoMask)\n      }\n\n      const projectedGeoMaskPoints = geoMaskPoints.map((point) =>\n        proj4(projection.definition, point)\n      )\n      return projectedGeoMaskPoints\n    } else {\n      const projectedGeoMaskPoints: Point[] = []\n      for (const warpedMap of warpedMaps) {\n        projectedGeoMaskPoints.push(...warpedMap.projectedGeoMask)\n      }\n\n      return projectedGeoMaskPoints\n    }\n  }\n\n  private addToOrUpdateRtree(warpedMap: W): void {\n    if (this.rtree) {\n      this.rtree.removeItem(warpedMap.mapId)\n      this.rtree.addItem(warpedMap.mapId, [warpedMap.geoMask])\n    }\n  }\n\n  private removeFromRtree(warpedMap: W): void {\n    if (this.rtree) {\n      this.rtree.removeItem(warpedMap.mapId)\n    }\n  }\n\n  private removeZIndexHoles(): void {\n    const sortedZIndices = [...this.zIndices.entries()].sort(\n      (entryA, entryB) => entryA[1] - entryB[1]\n    )\n    let zIndex = 0\n    for (const entry of sortedZIndices) {\n      const mapId = entry[0]\n      this.zIndices.set(mapId, zIndex)\n      zIndex++\n    }\n  }\n\n  // This function and the listeners below transform an IMAGEINFOLOADED event by a WarpedMap\n  // to an IMAGEINFOLOADED of the WarpedMapList, which is listened to in the Renderer\n  private imageInfoLoaded() {\n    this.dispatchEvent(new WarpedMapEvent(WarpedMapEventType.IMAGEINFOLOADED))\n  }\n\n  private addEventListenersToWarpedMap(warpedMap: W) {\n    warpedMap.addEventListener(\n      WarpedMapEventType.IMAGEINFOLOADED,\n      this.imageInfoLoaded.bind(this)\n    )\n  }\n\n  private removeEventListenersFromWarpedMap(warpedMap: W) {\n    warpedMap.removeEventListener(\n      WarpedMapEventType.IMAGEINFOLOADED,\n      this.imageInfoLoaded.bind(this)\n    )\n  }\n}\n"],"names":[],"mappings":"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"}