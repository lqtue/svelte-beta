var fragment_shader_default = "#version 300 es\n\nprecision highp float;\nprecision highp isampler2D;\n\nfloat easing(float t) {\n  return t;\n\n  \n  \n}\n\nuniform float u_debug;\n\nuniform bool u_removeColor;\nuniform vec3 u_removeColorOptionsColor;\nuniform float u_removeColorOptionsThreshold;\nuniform float u_removeColorOptionsHardness;\n\nuniform bool u_colorize;\nuniform vec3 u_colorizeOptionsColor;\n\nuniform bool u_grid;\n\nuniform float u_opacity;\nuniform float u_saturation;\n\nuniform bool u_distortion;\nuniform int u_distortionOptionsdistortionMeasure;\n\nuniform int u_scaleFactorForViewport;\n\nuniform lowp sampler2DArray u_cachedTilesTextureArray;\nuniform isampler2D u_cachedTilesResourceOriginPointsAndDimensionsTexture;\nuniform isampler2D u_cachedTilesScaleFactorsTexture;\n\nuniform vec4 u_colorDistortion00;\nuniform vec4 u_colorDistortion01;\nuniform vec4 u_colorDistortion1;\nuniform vec4 u_colorDistortion2;\nuniform vec4 u_colorDistortion3;\nuniform vec4 u_colorGrid;\n\nin vec2 v_resourceTrianglePoint;\nin float v_trianglePointDistortion;\nin float v_trianglePointIndex;\nin vec4 v_trianglePointBarycentric;\n\nout vec4 color;\n\nvoid main() {\n  float resourceTrianglePointX = v_resourceTrianglePoint.x;\n  float resourceTrianglePointY = v_resourceTrianglePoint.y;\n\n  \n  ivec3 cachedTilesTextureSize = textureSize(u_cachedTilesTextureArray, 0);\n  int cachedTilesCount = cachedTilesTextureSize.z;\n\n  \n  int smallestScaleFactor;\n  bool found = false;\n  int foundIndex;\n\n  \n  vec3 cachedTilesTexturePoint = vec3(0.0f, 0.0f, 0.0f);\n\n  \n  color = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n  \n  for(int index = 0; index < cachedTilesCount; index += 1) {\n\n    \n    float cachedTileResourceOriginPointX = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4)), 0));\n    float cachedTileResourceOriginPointY = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4) + 1), 0));\n    float cachedTileDimensionWidth = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4) + 2), 0));\n    float cachedTileDimensionHeight = float(texelFetch(u_cachedTilesResourceOriginPointsAndDimensionsTexture, ivec2(0, (index * 4) + 3), 0));\n\n    int cachedTileScaleFactor = texelFetch(u_cachedTilesScaleFactorsTexture, ivec2(0, index), 0).r;\n\n    \n    if(resourceTrianglePointX >= cachedTileResourceOriginPointX &&\n      resourceTrianglePointX < cachedTileResourceOriginPointX + cachedTileDimensionWidth &&\n      resourceTrianglePointY >= cachedTileResourceOriginPointY &&\n      resourceTrianglePointY < cachedTileResourceOriginPointY + cachedTileDimensionHeight) {\n\n      \n      \n      \n      \n      \n      if(!(smallestScaleFactor > 0) || cachedTileScaleFactor <= smallestScaleFactor) {\n        smallestScaleFactor = cachedTileScaleFactor;\n        found = true;\n        foundIndex = index;\n\n        float cachedTilePointX = (resourceTrianglePointX - cachedTileResourceOriginPointX) / float(cachedTileScaleFactor);\n        float cachedTilePointY = (resourceTrianglePointY - cachedTileResourceOriginPointY) / float(cachedTileScaleFactor);\n\n        float cachedTilesTexturePointX = cachedTilePointX / float(cachedTilesTextureSize.x);\n        float cachedTilesTexturePointY = cachedTilePointY / float(cachedTilesTextureSize.y);\n\n        cachedTilesTexturePoint = vec3(cachedTilesTexturePointX, cachedTilesTexturePointY, index);\n      }\n    }\n  }\n\n  if(found == true) {\n    \n    color = texture(u_cachedTilesTextureArray, cachedTilesTexturePoint);\n\n    if(u_removeColorOptionsThreshold > 0.0f) {\n  vec3 backgroundColorDiff = color.rgb - u_removeColorOptionsColor.rgb;\n  float backgroundColorDistance = length(backgroundColorDiff);\n  if(u_removeColor && backgroundColorDistance < u_removeColorOptionsThreshold) {\n    float amount = smoothstep(u_removeColorOptionsThreshold - u_removeColorOptionsThreshold * (1.0f - u_removeColorOptionsHardness), u_removeColorOptionsThreshold, backgroundColorDistance);\n    color = vec4(color.rgb * amount, amount);\n  }\n}\n\nfloat gray = 0.21f * color.r + 0.71f * color.g + 0.07f * color.b;\ncolor = vec4(color.rgb * (u_saturation) + (gray * (1.0f - u_saturation)), color.a);\n\nif(u_colorize) {\n  color = vec4((u_colorizeOptionsColor + color.rgb) * color.a, color.a);\n}\n\ncolor = vec4(color.rgb * u_opacity, color.a * u_opacity);\n    if(u_distortion) {\n  \n  \n\n  float trianglePointDistortion = v_trianglePointDistortion;\n\n  \n  \n  trianglePointDistortion = floor(trianglePointDistortion * 10.0f) / 10.0f;\n\n  \n  float trianglePointDistortionMix = clamp(trianglePointDistortion, -1.0f, 1.0f);\n\n  switch(u_distortionOptionsdistortionMeasure) {\n    case 0:\n      if(trianglePointDistortion > 0.0f) {\n        color = mix(color, u_colorDistortion00, trianglePointDistortionMix);\n      } else {\n        color = mix(color, u_colorDistortion01, abs(trianglePointDistortionMix));\n      }\n      break;\n    case 1:\n      color = mix(color, u_colorDistortion1, trianglePointDistortionMix);\n      break;\n    case 2:\n      color = mix(color, u_colorDistortion2, trianglePointDistortionMix);\n      break;\n    case 3:\n      color = trianglePointDistortion == -1.0f ? u_colorDistortion3 : color;\n      break;\n    default:\n      color = color;\n  }\n}\n\nif(u_grid) {\n  float gridSize = 20.0f * float(u_scaleFactorForViewport);\n  float gridWidth = 2.0f * float(u_scaleFactorForViewport);\n  if(mod(float(resourceTrianglePointX) + gridWidth / 2.0f, gridSize) < gridWidth || mod(float(resourceTrianglePointY) + gridWidth / 2.0f, gridSize) < gridWidth) {\n    color = u_colorGrid;\n  }\n}\n    if(bool(u_debug)) {\n  float viewportWidth = 4.0;\n\n  \n\n  \n  \n  \n\n  float barycentricTriangleDist = min(min(v_trianglePointBarycentric.x, v_trianglePointBarycentric.y), v_trianglePointBarycentric.z);\n  \n  \n  float barycentricTriangleDistPixelSize = length(vec2(dFdx(barycentricTriangleDist), dFdy(barycentricTriangleDist)));\n  \n  float TriangleDistThreshold = viewportWidth * barycentricTriangleDistPixelSize / 2.0;\n\n  if(barycentricTriangleDist < TriangleDistThreshold) {\n    color = vec4(0.0, 0.0, 0.0, 1.0);\n  }\n\n  \n\n  float resourceDist = min(cachedTilesTexturePoint.x, cachedTilesTexturePoint.y);\n  \n  \n  float resourceDistPixelSize = length(vec2(dFdx(resourceDist), dFdy(resourceDist)));\n  float resourceDistThreshold = viewportWidth * resourceDistPixelSize;\n\n  if(resourceDist < resourceDistThreshold) {\n    color = vec4(0.0, 0.0, 1.0, 1.0);\n  }\n}\n  }\n}";
export {
  fragment_shader_default as default
};
//# sourceMappingURL=fragment-shader.glsl.js.map
