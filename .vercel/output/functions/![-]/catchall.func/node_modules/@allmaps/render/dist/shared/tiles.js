import { squaredDistance, doBboxesIntersect, bufferBboxByRatio, sizeToResolution } from "@allmaps/stdlib";
function getTileZoomLevelForScale(tileZoomLevels, resourceToCanvasScale, scaleFactorCorrection, log2scaleFactorCorrection) {
  let smallestdiffLogScaleFactor = Number.POSITIVE_INFINITY;
  let bestTileZoomLevel = tileZoomLevels.at(-1);
  for (const tileZoomLevel of tileZoomLevels) {
    const diffLogScaleFactor = Math.abs(
      Math.log2(tileZoomLevel.scaleFactor) - (Math.log2(resourceToCanvasScale + scaleFactorCorrection) + log2scaleFactorCorrection)
    );
    if (diffLogScaleFactor < smallestdiffLogScaleFactor) {
      smallestdiffLogScaleFactor = diffLogScaleFactor;
      bestTileZoomLevel = tileZoomLevel;
    }
  }
  return bestTileZoomLevel;
}
function computeTilesCoveringRingAtTileZoomLevel(resourceRing, tileZoomLevel, imageSize) {
  const scaledResourceRing = scaleResourcePoints(resourceRing, tileZoomLevel);
  const tilesByColumn = ringToTilesByColumn(scaledResourceRing);
  const tiles = tilesByColumnToTiles(tilesByColumn, tileZoomLevel, imageSize);
  return tiles;
}
function scaleResourcePoints(resourcePoints, tileZoomLevel) {
  return resourcePoints.map((point) => [
    point[0] / tileZoomLevel.originalWidth,
    point[1] / tileZoomLevel.originalHeight
  ]);
}
function ringToTilesByColumn(ring) {
  const tilesByColumn = {};
  for (let i = 0; i < ring.length; i++) {
    const line = [ring[i], ring[(i + 1) % ring.length]];
    const pixels = lineToPixels(line);
    pixels.forEach(([x, y]) => {
      if (!tilesByColumn[x]) {
        tilesByColumn[x] = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
      }
      if (y < tilesByColumn[x][0]) {
        tilesByColumn[x][0] = y;
      }
      if (y > tilesByColumn[x][1]) {
        tilesByColumn[x][1] = y;
      }
    });
  }
  return tilesByColumn;
}
function lineToPixels([startPoint, endPoint]) {
  let startPixelX = Math.floor(startPoint[0]);
  let startPixelY = Math.floor(startPoint[1]);
  const endPixelX = Math.floor(endPoint[0]);
  const endPixelY = Math.floor(endPoint[1]);
  const points = [[startPixelX, startPixelY]];
  if (startPixelX === endPixelX && startPixelY === endPixelY) {
    return points;
  }
  const stepX = Math.sign(endPoint[0] - startPoint[0]);
  const stepY = Math.sign(endPoint[1] - startPoint[1]);
  const restX = Math.abs(startPoint[0] - startPixelX - Math.max(0, stepX));
  const restY = Math.abs(startPoint[1] - startPixelY - Math.max(0, stepY));
  const distanceX = Math.abs(startPoint[0] - endPoint[0]);
  const distanceY = Math.abs(startPoint[1] - endPoint[1]);
  let restPerStepX = restX / distanceX;
  let restPerStepY = restY / distanceY;
  const onePerStepX = 1 / distanceX;
  const onePerStepY = 1 / distanceY;
  while (!(startPixelX === endPixelX && startPixelY === endPixelY)) {
    if (distanceY === 0) {
      startPixelX = startPixelX + stepX;
    } else if (distanceX === 0) {
      startPixelY = startPixelY + stepY;
    } else if (restPerStepX < restPerStepY) {
      restPerStepX = restPerStepX + onePerStepX;
      startPixelX = startPixelX + stepX;
    } else {
      restPerStepY = restPerStepY + onePerStepY;
      startPixelY = startPixelY + stepY;
    }
    points.push([startPixelX, startPixelY]);
  }
  return points;
}
function tilesByColumnToTiles(tilesByColumn, tileZoomLevel, imageSize) {
  const tiles = [];
  for (const xKey in tilesByColumn) {
    const x = parseInt(xKey);
    if (x < 0 || x >= tileZoomLevel.columns) {
      break;
    }
    const fromY = Math.max(tilesByColumn[x][0], 0);
    const toY = Math.min(tilesByColumn[x][1], tileZoomLevel.rows - 1);
    for (let y = fromY; y <= toY; y++) {
      tiles.push({
        column: x,
        row: y,
        tileZoomLevel,
        imageSize
      });
    }
  }
  return tiles;
}
function getTilesCoveringTileAtScaleFactor(tile, parsedImage, scaleFactor, validTile) {
  let columnStart = Math.floor(
    tile.column * tile.tileZoomLevel.scaleFactor / scaleFactor
  );
  columnStart = columnStart >= 0 ? columnStart : 0;
  const columnEnd = Math.ceil(
    (tile.column + 1) * tile.tileZoomLevel.scaleFactor / scaleFactor
  );
  let rowStart = Math.floor(
    tile.row * tile.tileZoomLevel.scaleFactor / scaleFactor
  );
  rowStart = rowStart >= 0 ? rowStart : 0;
  const rowEnd = Math.ceil(
    (tile.row + 1) * tile.tileZoomLevel.scaleFactor / scaleFactor
  );
  return getTilesAtScaleFactor(
    scaleFactor,
    parsedImage,
    columnStart,
    columnEnd,
    rowStart,
    rowEnd,
    validTile
  );
}
function getTilesAtScaleFactor(scaleFactor, parsedImage, columnStart, columnEnd, rowStart, rowEnd, validTile = (_tile) => true) {
  const tileZoomLevel = parsedImage.tileZoomLevels.find(
    (tileZoomLevel2) => tileZoomLevel2.scaleFactor === scaleFactor
  );
  const imageSize = [parsedImage.width, parsedImage.height];
  if (!tileZoomLevel) {
    return [];
  }
  columnStart = columnStart ? columnStart : 0;
  columnEnd = columnEnd ? columnEnd : tileZoomLevel.columns;
  rowStart = rowStart ? rowStart : 0;
  rowEnd = rowEnd ? rowEnd : tileZoomLevel.rows;
  const tiles = [];
  for (let column = columnStart; column < columnEnd; column++) {
    for (let row = rowStart; row < rowEnd; row++) {
      const tile = {
        column,
        row,
        tileZoomLevel,
        imageSize
      };
      if (validTile(tile)) {
        tiles.push(tile);
      }
    }
  }
  return tiles;
}
function squaredDistanceTileToPoint(tile, point) {
  return squaredDistance(tileCenter(tile), point);
}
function tileCenter(tile) {
  const bbox = computeBboxTile(tile);
  return [(bbox[2] - bbox[0]) / 2 + bbox[0], (bbox[3] - bbox[1]) / 2 + bbox[1]];
}
function tileToTileOriginPoint(tile) {
  return [
    tile.column * tile.tileZoomLevel.originalWidth,
    tile.row * tile.tileZoomLevel.originalHeight
  ];
}
function clipTilePointToTile(tilePoint, tile) {
  const tileSize = [tile.tileZoomLevel.width, tile.tileZoomLevel.height];
  return tilePoint.map((coordinate, index) => {
    coordinate = Math.max(coordinate, 0);
    coordinate = Math.min(coordinate, tileSize[index] - 1);
    return coordinate;
  });
}
function resourcePointInTile(resourcePoint, tile) {
  const resourceTileOrigin = tileToTileOriginPoint(tile);
  return resourcePoint[0] >= resourceTileOrigin[0] && resourcePoint[0] <= resourceTileOrigin[0] + tile.tileZoomLevel.originalWidth && resourcePoint[1] >= resourceTileOrigin[1] && resourcePoint[1] <= resourceTileOrigin[1] + tile.tileZoomLevel.originalHeight;
}
function computeBboxTile(tile) {
  const resourceTileOriginPoint = tileToTileOriginPoint(tile);
  const resourceTileMaxX = Math.min(
    resourceTileOriginPoint[0] + tile.tileZoomLevel.originalWidth,
    tile.imageSize[0]
  );
  const resourceTileMaxY = Math.min(
    resourceTileOriginPoint[1] + tile.tileZoomLevel.originalHeight,
    tile.imageSize[1]
  );
  return [
    resourceTileOriginPoint[0],
    resourceTileOriginPoint[1],
    resourceTileMaxX,
    resourceTileMaxY
  ];
}
function getTileSize(tile) {
  return [tile.tileZoomLevel.width, tile.tileZoomLevel.height];
}
function getTileResolution(tile) {
  return sizeToResolution(getTileSize(tile));
}
function getTilesResolution(tiles) {
  return tiles.map((tile) => getTileResolution(tile)).reduce((a, c) => a + c, 0);
}
function getTileZoomLevelResolution(tileZoomLevel) {
  return tileZoomLevel.rows * tileZoomLevel.width * tileZoomLevel.columns * tileZoomLevel.height;
}
function getTilesAtOtherScaleFactors(tile, parsedImage, scaleFactor, TEXTURES_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF, TEXTURES_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF, validTile) {
  const tilesAtOtherScaleFactors = [];
  const tilesAtLowerScaleFactor = recursivelyGetTilesAtLowerScaleFactor(
    tile,
    parsedImage,
    scaleFactor,
    TEXTURES_MAX_LOWER_LOG2_SCALE_FACTOR_DIFF,
    validTile
  );
  for (const tileAtLowerScaleFactor of tilesAtLowerScaleFactor) {
    if (tileAtLowerScaleFactor) {
      tilesAtOtherScaleFactors.push(tileAtLowerScaleFactor);
    }
  }
  if (tilesAtOtherScaleFactors.length === 0) {
    const tileAtHigherScaleFactor = recursivelyGetTilesAtHigherScaleFactor(
      tile,
      parsedImage,
      scaleFactor,
      TEXTURES_MAX_HIGHER_LOG2_SCALE_FACTOR_DIFF,
      validTile
    );
    if (tileAtHigherScaleFactor) {
      tilesAtOtherScaleFactors.push(tileAtHigherScaleFactor);
    }
  }
  return tilesAtOtherScaleFactors;
}
function recursivelyGetTilesAtHigherScaleFactor(tile, parsedImage, scaleFactor, log2ScaleFactorDiff, validTile) {
  const higherScaleFactor = 2 ** (Math.log2(scaleFactor) + 1);
  if (higherScaleFactor > parsedImage.tileZoomLevels.map((tileZoomLevel) => tileZoomLevel.scaleFactor).reduce((a, c) => a + c, 0) - scaleFactor || log2ScaleFactorDiff === 0) {
    return void 0;
  }
  const tileAtHigherScaleFactor = getTileAtHigherScaleFactor(
    tile,
    parsedImage,
    higherScaleFactor,
    validTile
  );
  if (tileAtHigherScaleFactor !== void 0) {
    return tileAtHigherScaleFactor;
  } else {
    return recursivelyGetTilesAtHigherScaleFactor(
      tile,
      parsedImage,
      higherScaleFactor,
      log2ScaleFactorDiff--,
      validTile
    );
  }
}
function recursivelyGetTilesAtLowerScaleFactor(tile, parsedImage, scaleFactor, log2ScaleFactorDiff, validTile) {
  const lowerScaleFactor = 2 ** (Math.log2(scaleFactor) - 1);
  if (lowerScaleFactor <= 0 || log2ScaleFactorDiff === 0) {
    return [];
  }
  const tilesAtLowerScaleFactor = getTilesAtLowerScaleFactor(
    tile,
    parsedImage,
    lowerScaleFactor,
    validTile
  );
  const allTilesAtLowerScaleFactor = getTilesAtLowerScaleFactor(
    tile,
    parsedImage,
    lowerScaleFactor,
    (_tile) => true
  );
  if (tilesAtLowerScaleFactor.length === allTilesAtLowerScaleFactor.length) {
    return tilesAtLowerScaleFactor;
  } else {
    return [
      ...tilesAtLowerScaleFactor,
      ...recursivelyGetTilesAtLowerScaleFactor(
        tile,
        parsedImage,
        lowerScaleFactor,
        log2ScaleFactorDiff--,
        validTile
      )
    ];
  }
}
function getTileAtHigherScaleFactor(tile, parsedImage, higherScaleFactor, validTile) {
  const tilesCoveringTileAtHigherScaleFactor = getTilesCoveringTileAtScaleFactor(
    tile,
    parsedImage,
    higherScaleFactor,
    validTile
  );
  if (tilesCoveringTileAtHigherScaleFactor.length === 0) {
    return void 0;
  }
  return tilesCoveringTileAtHigherScaleFactor[0];
}
function getTilesAtLowerScaleFactor(tile, parsedImage, lowerScaleFactor, validTile) {
  const tilesCoveringTileAtLowerScaleFactor = getTilesCoveringTileAtScaleFactor(
    tile,
    parsedImage,
    lowerScaleFactor,
    validTile
  );
  return tilesCoveringTileAtLowerScaleFactor;
}
function fetchableTileKey(fetchableTile) {
  return keyFromMapIdTileUrl(fetchableTile.mapId, fetchableTile.tileUrl);
}
function keyFromMapIdTileUrl(mapId, tileUrl2) {
  return `${mapId}:${tileUrl2}`;
}
function tileKey(tile) {
  return keyFromScaleFactorRowColumn(
    tile.tileZoomLevel.scaleFactor,
    tile.row,
    tile.column
  );
}
function keyFromScaleFactorRowColumn(scaleFactor, row, column) {
  return `${scaleFactor}:${row}:${column}`;
}
function shouldPruneTile(tile, mapPruneInfo, mapPruneConstants) {
  if (mapPruneInfo.overviewTileZoomLevelForViewport && tile.tileZoomLevel.scaleFactor == mapPruneInfo.overviewTileZoomLevelForViewport.scaleFactor) {
    return false;
  }
  if (mapPruneInfo.resourceViewportRingBboxForViewport === void 0 || mapPruneInfo.tileZoomLevelForViewport === void 0) {
    return true;
  }
  const log2ScaleFactorDiff = Math.log2(tile.tileZoomLevel.scaleFactor) - Math.log2(mapPruneInfo.tileZoomLevelForViewport.scaleFactor);
  const tileScaleFactorTooHigh = log2ScaleFactorDiff > mapPruneConstants.maxHigherLog2ScaleFactorDiff;
  if (tileScaleFactorTooHigh) {
    return true;
  }
  const tileScaleFactorTooLow = -log2ScaleFactorDiff > mapPruneConstants.maxLowerLog2ScaleFactorDiff;
  if (tileScaleFactorTooLow) {
    return true;
  }
  if (!doBboxesIntersect(
    bufferBboxByRatio(
      computeBboxTile(tile),
      Math.max(0, log2ScaleFactorDiff)
    ),
    mapPruneInfo.resourceViewportRingBboxForViewport
  )) {
    return true;
  }
  return false;
}
export {
  clipTilePointToTile,
  computeBboxTile,
  computeTilesCoveringRingAtTileZoomLevel,
  fetchableTileKey,
  getTileAtHigherScaleFactor,
  getTileResolution,
  getTileSize,
  getTileZoomLevelForScale,
  getTileZoomLevelResolution,
  getTilesAtLowerScaleFactor,
  getTilesAtOtherScaleFactors,
  getTilesAtScaleFactor,
  getTilesCoveringTileAtScaleFactor,
  getTilesResolution,
  keyFromMapIdTileUrl,
  keyFromScaleFactorRowColumn,
  recursivelyGetTilesAtHigherScaleFactor,
  recursivelyGetTilesAtLowerScaleFactor,
  resourcePointInTile,
  shouldPruneTile,
  squaredDistanceTileToPoint,
  tileCenter,
  tileKey,
  tileToTileOriginPoint
};
//# sourceMappingURL=tiles.js.map
