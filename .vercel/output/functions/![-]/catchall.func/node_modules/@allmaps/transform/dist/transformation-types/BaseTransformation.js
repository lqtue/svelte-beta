import { distance, rms } from '@allmaps/stdlib';
/**
 * Base class for transformation.
 */
export class BaseTransformation {
    sourcePoints;
    destinationPoints;
    destinationTransformedSourcePoints;
    type;
    pointCount;
    pointCountMinimum;
    errors;
    rmse;
    /**
     * Create a transformation
     *
     * @param sourcePoints - The source points
     * @param destinationPoints - The destination points
     * @param type - The transformation type
     * @param pointCountMinimum - The minimum number of points for the transformation type
     */
    constructor(sourcePoints, destinationPoints, type, pointCountMinimum) {
        this.sourcePoints = sourcePoints;
        this.destinationPoints = destinationPoints;
        this.pointCount = this.sourcePoints.length;
        this.type = type;
        this.pointCountMinimum = pointCountMinimum;
        if (this.pointCount < this.pointCountMinimum) {
            throw new Error('Not enough control points. A ' +
                this.type +
                ' transformation requires a minimum of ' +
                this.pointCountMinimum +
                ' points, but ' +
                this.pointCount +
                ' are given.');
        }
    }
    /**
     * Set weights.
     *
     * The weights might be obtained in other ways then through solving
     * (e.g. through solving multiple transformation together when staping).
     * This function can be used to set weights computed elsewhere.
     */
    setWeightsArrays(weightsArrays) {
        this.weightsArrays = weightsArrays;
        this.processWeightsArrays();
    }
    processWeightsArrays() {
        return;
    }
    /**
     * Get the destination-transformed source points.
     *
     * @returns source points, transformed to destination domain
     */
    getDestinationTransformedSourcePoints() {
        if (!this.destinationTransformedSourcePoints) {
            this.destinationTransformedSourcePoints = this.sourcePoints.map((sourcePoint) => this.evaluateFunction(sourcePoint));
        }
        return this.destinationTransformedSourcePoints;
    }
    getMeasures() {
        return {};
    }
    getErrors() {
        if (!this.errors) {
            const destinationTransformedSourcePoints = this.getDestinationTransformedSourcePoints();
            this.errors = this.destinationPoints.map((destinationPoint, index) => distance(destinationPoint, destinationTransformedSourcePoints[index]));
        }
        return this.errors;
    }
    getRmse() {
        if (!this.rmse) {
            const destinationTransformedSourcePoints = this.getDestinationTransformedSourcePoints();
            if (!this.destinationTransformedSourcePoints) {
                this.getDestinationTransformedSourcePoints();
            }
            this.rmse = rms(this.destinationPoints, destinationTransformedSourcePoints);
        }
        return this.rmse;
    }
}
