var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// .svelte-kit/output/server/chunks/false.js
var s;
var init_false = __esm({
  ".svelte-kit/output/server/chunks/false.js"() {
    s = false;
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/remote-functions.js
var init_remote_functions = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/remote-functions.js"() {
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/index.js
var HttpError, Redirect, SvelteKitError, ActionFailure;
var init_internal = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/index.js"() {
    init_remote_functions();
    HttpError = class {
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body) {
        this.status = status;
        if (typeof body === "string") {
          this.body = { message: body };
        } else if (body) {
          this.body = body;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location) {
        this.status = status;
        this.location = location;
      }
    };
    SvelteKitError = class extends Error {
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text2, message) {
        super(message);
        this.status = status;
        this.text = text2;
      }
    };
    ActionFailure = class {
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
  }
});

// node_modules/@sveltejs/kit/src/runtime/server/constants.js
var IN_WEBCONTAINER;
var init_constants = __esm({
  "node_modules/@sveltejs/kit/src/runtime/server/constants.js"() {
    IN_WEBCONTAINER = !!globalThis.process?.versions?.webcontainer;
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/event.js
function with_request_store(store, fn3) {
  try {
    sync_store = store;
    return als ? als.run(store, fn3) : fn3();
  } finally {
    if (!IN_WEBCONTAINER) {
      sync_store = null;
    }
  }
}
var sync_store, als;
var init_event = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/event.js"() {
    init_constants();
    sync_store = null;
    import("node:async_hooks").then((hooks) => als = new hooks.AsyncLocalStorage()).catch(() => {
    });
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/server.js
function merge_tracing(event_like, current2) {
  return {
    ...event_like,
    tracing: {
      ...event_like.tracing,
      current: current2
    }
  };
}
var init_server = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/server.js"() {
    init_event();
  }
});

// .svelte-kit/output/server/chunks/exports.js
function b(e3, r4) {
  if (r4[0] === "/" && r4[1] === "/") return r4;
  let n3 = new URL(e3, p);
  return n3 = new URL(r4, n3), n3.protocol === p.protocol ? n3.pathname + n3.search + n3.hash : n3.href;
}
function $(e3, r4) {
  return e3 === "/" || r4 === "ignore" ? e3 : r4 === "never" ? e3.endsWith("/") ? e3.slice(0, -1) : e3 : r4 === "always" && !e3.endsWith("/") ? e3 + "/" : e3;
}
function P(e3) {
  return e3.split("%25").map(decodeURI).join("%25");
}
function x(e3) {
  for (const r4 in e3) e3[r4] = decodeURIComponent(e3[r4]);
  return e3;
}
function y(e3, r4, n3, o5 = false) {
  const t3 = new URL(e3);
  Object.defineProperty(t3, "searchParams", { value: new Proxy(t3.searchParams, { get(s6, a4) {
    if (a4 === "get" || a4 === "getAll" || a4 === "has") return (d2) => (n3(d2), s6[a4](d2));
    r4();
    const i4 = Reflect.get(s6, a4);
    return typeof i4 == "function" ? i4.bind(s6) : i4;
  } }), enumerable: true, configurable: true });
  const u6 = ["href", "pathname", "search", "toString", "toJSON"];
  o5 && u6.push("hash");
  for (const s6 of u6) Object.defineProperty(t3, s6, { get() {
    return r4(), e3[s6];
  }, enumerable: true, configurable: true });
  return t3[Symbol.for("nodejs.util.inspect.custom")] = (s6, a4, i4) => i4(e3, a4), t3.searchParams[Symbol.for("nodejs.util.inspect.custom")] = (s6, a4, i4) => i4(e3.searchParams, a4), o5 || w(t3), t3;
}
function w(e3) {
  h(e3), Object.defineProperty(e3, "hash", { get() {
    throw new Error("Cannot access event.url.hash. Consider using `page.url.hash` inside a component instead");
  } });
}
function j(e3) {
  h(e3);
  for (const r4 of ["search", "searchParams"]) Object.defineProperty(e3, r4, { get() {
    throw new Error(`Cannot access url.${r4} on a page with prerendering enabled`);
  } });
}
function h(e3) {
  e3[Symbol.for("nodejs.util.inspect.custom")] = (r4, n3, o5) => o5(new URL(e3), n3);
}
function c2(e3) {
  function r4(n3, o5) {
    if (n3) for (const t3 in n3) {
      if (t3[0] === "_" || e3.has(t3)) continue;
      const u6 = [...e3.values()], s6 = m(t3, o5?.slice(o5.lastIndexOf("."))) ?? `valid exports are ${u6.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${t3}'${o5 ? ` in ${o5}` : ""} (${s6})`);
    }
  }
  return r4;
}
function m(e3, r4 = ".js") {
  const n3 = [];
  if (l.has(e3) && n3.push(`+layout${r4}`), _.has(e3) && n3.push(`+page${r4}`), f.has(e3) && n3.push(`+layout.server${r4}`), v.has(e3) && n3.push(`+page.server${r4}`), g.has(e3) && n3.push(`+server${r4}`), n3.length > 0) return `'${e3}' is a valid export in ${n3.slice(0, -1).join(", ")}${n3.length > 1 ? " or " : ""}${n3.at(-1)}`;
}
var p, l, _, f, v, g, E, O, R, U, C;
var init_exports = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    p = new URL("sveltekit-internal://");
    l = /* @__PURE__ */ new Set(["load", "prerender", "csr", "ssr", "trailingSlash", "config"]);
    _ = /* @__PURE__ */ new Set([...l, "entries"]);
    f = /* @__PURE__ */ new Set([...l]);
    v = /* @__PURE__ */ new Set([...f, "actions", "entries"]);
    g = /* @__PURE__ */ new Set(["GET", "POST", "PATCH", "PUT", "DELETE", "OPTIONS", "HEAD", "fallback", "prerender", "trailingSlash", "config", "entries"]);
    E = c2(l);
    O = c2(_);
    R = c2(f);
    U = c2(v);
    C = c2(g);
  }
});

// .svelte-kit/output/server/chunks/utils.js
function s2(r4, n3) {
  const t3 = r4.split(/[/\\]/), e3 = n3.split(/[/\\]/);
  for (t3.pop(); t3[0] === e3[0]; ) t3.shift(), e3.shift();
  let o5 = t3.length;
  for (; o5--; ) t3[o5] = "..";
  return t3.concat(e3).join("/");
}
function f2(r4) {
  if (globalThis.Buffer) return globalThis.Buffer.from(r4).toString("base64");
  let n3 = "";
  for (let t3 = 0; t3 < r4.length; t3++) n3 += String.fromCharCode(r4[t3]);
  return btoa(n3);
}
function l2(r4) {
  if (globalThis.Buffer) {
    const e3 = globalThis.Buffer.from(r4, "base64");
    return new Uint8Array(e3);
  }
  const n3 = atob(r4), t3 = new Uint8Array(n3.length);
  for (let e3 = 0; e3 < n3.length; e3++) t3[e3] = n3.charCodeAt(e3);
  return t3;
}
var a2, i2;
var init_utils = __esm({
  ".svelte-kit/output/server/chunks/utils.js"() {
    a2 = new TextEncoder();
    i2 = new TextDecoder();
  }
});

// node_modules/clsx/dist/clsx.mjs
function r2(e3) {
  var t3, f5, n3 = "";
  if ("string" == typeof e3 || "number" == typeof e3) n3 += e3;
  else if ("object" == typeof e3) if (Array.isArray(e3)) {
    var o5 = e3.length;
    for (t3 = 0; t3 < o5; t3++) e3[t3] && (f5 = r2(e3[t3])) && (n3 && (n3 += " "), n3 += f5);
  } else for (f5 in e3) e3[f5] && (n3 && (n3 += " "), n3 += f5);
  return n3;
}
function clsx() {
  for (var e3, t3, f5 = 0, n3 = "", o5 = arguments.length; f5 < o5; f5++) (e3 = arguments[f5]) && (t3 = r2(e3)) && (n3 && (n3 += " "), n3 += t3);
  return n3;
}
var init_clsx = __esm({
  "node_modules/clsx/dist/clsx.mjs"() {
  }
});

// .svelte-kit/output/server/chunks/context.js
function we(t3) {
  for (var e3 = 0; e3 < t3.length; e3++) t3[e3]();
}
function Ee() {
  var t3, e3, n3 = new Promise((r4, s6) => {
    t3 = r4, e3 = s6;
  });
  return { promise: n3, resolve: t3, reject: e3 };
}
function nn(t3, e3, n3 = false) {
  return t3 === void 0 ? n3 ? e3() : e3 : t3;
}
function ye(t3) {
  return t3 === this.v;
}
function be(t3, e3) {
  return t3 != t3 ? e3 == e3 : t3 !== e3 || t3 !== null && typeof t3 == "object" || typeof t3 == "function";
}
function ge(t3) {
  return !be(t3, this.v);
}
function Re(t3) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function ke() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function ln() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function Se() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function Ae() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Ne() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function un() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
function At(t3) {
  H = t3;
}
function dn(t3, e3 = false, n3) {
  H = { p: H, i: false, c: null, e: null, s: t3, x: null, l: null };
}
function wn(t3) {
  var e3 = H, n3 = e3.e;
  if (n3 !== null) {
    e3.e = null;
    for (var r4 of n3) Le(r4);
  }
  return e3.i = true, H = e3.p, {};
}
function jt() {
  return true;
}
function Ut() {
  var t3 = j2;
  j2 = [], we(t3);
}
function Ce(t3) {
  if (j2.length === 0 && !Q) {
    var e3 = j2;
    queueMicrotask(() => {
      e3 === j2 && Ut();
    });
  }
  j2.push(t3);
}
function De() {
  for (; j2.length > 0; ) Ut();
}
function Fe(t3) {
  var e3 = p2;
  if (e3 === null) return c3.f |= at, t3;
  if ((e3.f & qt) === 0) {
    if ((e3.f & gt) === 0) throw t3;
    e3.b.error(t3);
  } else Bt(t3, e3);
}
function Bt(t3, e3) {
  for (; e3 !== null; ) {
    if ((e3.f & gt) !== 0) try {
      e3.b.error(t3);
      return;
    } catch (n3) {
      t3 = n3;
    }
    e3 = e3.parent;
  }
  throw t3;
}
function En(t3) {
  var e3 = Q;
  Q = true;
  try {
    for (var n3; ; ) {
      if (De(), A.length === 0 && (y2?.flush(), A.length === 0)) return _t = null, n3;
      Ht();
    }
  } finally {
    Q = e3;
  }
}
function Ht() {
  var t3 = $2;
  yt = true;
  try {
    var e3 = 0;
    for (Dt(true); A.length > 0; ) {
      var n3 = z.ensure();
      if (e3++ > 1e3) {
        var r4, s6;
        Ie();
      }
      n3.process(A), q.clear();
    }
  } finally {
    yt = false, Dt(t3), _t = null;
  }
}
function Ie() {
  try {
    ke();
  } catch (t3) {
    Bt(t3, _t);
  }
}
function Ot(t3) {
  var e3 = t3.length;
  if (e3 !== 0) {
    for (var n3 = 0; n3 < e3; ) {
      var r4 = t3[n3++];
      if ((r4.f & (U2 | M)) === 0 && st(r4) && (N = /* @__PURE__ */ new Set(), et(r4), r4.deps === null && r4.first === null && r4.nodes_start === null && (r4.teardown === null && r4.ac === null ? re(r4) : r4.fn = null), N?.size > 0)) {
        q.clear();
        for (const s6 of N) {
          if ((s6.f & (U2 | M)) !== 0) continue;
          const l5 = [s6];
          let f5 = s6.parent;
          for (; f5 !== null; ) N.has(f5) && (N.delete(f5), l5.push(f5)), f5 = f5.parent;
          for (let i4 = l5.length - 1; i4 >= 0; i4--) {
            const u6 = l5[i4];
            (u6.f & (U2 | M)) === 0 && et(u6);
          }
        }
        N.clear();
      }
    }
    N = null;
  }
}
function Gt(t3, e3, n3, r4) {
  if (!n3.has(t3) && (n3.add(t3), t3.reactions !== null)) for (const s6 of t3.reactions) {
    const l5 = s6.f;
    (l5 & m2) !== 0 ? Gt(s6, e3, n3, r4) : (l5 & (Yt | D)) !== 0 && (l5 & R2) === 0 && Kt(s6, e3, r4) && (g2(s6, R2), W(s6));
  }
}
function Kt(t3, e3, n3) {
  const r4 = n3.get(t3);
  if (r4 !== void 0) return r4;
  if (t3.deps !== null) for (const s6 of t3.deps) {
    if (e3.includes(s6)) return true;
    if ((s6.f & m2) !== 0 && Kt(s6, e3, n3)) return n3.set(s6, true), true;
  }
  return n3.set(t3, false), false;
}
function W(t3) {
  for (var e3 = _t = t3; e3.parent !== null; ) {
    e3 = e3.parent;
    var n3 = e3.f;
    if (yt && e3 === p2 && (n3 & D) !== 0) return;
    if ((n3 & (V | K)) !== 0) {
      if ((n3 & b2) === 0) return;
      e3.f ^= b2;
    }
  }
  A.push(e3);
}
function Vt(t3) {
  var e3 = t3.effects;
  if (e3 !== null) {
    t3.effects = null;
    for (var n3 = 0; n3 < e3.length; n3 += 1) G(e3[n3]);
  }
}
function Pe(t3) {
  for (var e3 = t3.parent; e3 !== null; ) {
    if ((e3.f & m2) === 0) return e3;
    e3 = e3.parent;
  }
  return null;
}
function xt(t3) {
  var e3, n3 = p2;
  ot(Pe(t3));
  try {
    t3.f &= ~it, Vt(t3), e3 = ie(t3);
  } finally {
    ot(n3);
  }
  return e3;
}
function $t(t3) {
  var e3 = xt(t3);
  if (t3.equals(e3) || (t3.v = e3, t3.wv = le()), !rt) if (k !== null) k.set(t3, t3.v);
  else {
    var n3 = (P2 || (t3.f & O2) !== 0) && t3.deps !== null ? F : b2;
    g2(t3, n3);
  }
}
function Wt(t3, e3) {
  var n3 = { f: 0, v: t3, reactions: null, equals: ye, rv: 0, wv: 0 };
  return n3;
}
function I(t3, e3) {
  const n3 = Wt(t3);
  return Ge(n3), n3;
}
function yn(t3, e3 = false, n3 = true) {
  const r4 = Wt(t3);
  return e3 || (r4.equals = ge), r4;
}
function L(t3, e3, n3 = false) {
  c3 !== null && (!S || (c3.f & St) !== 0) && jt() && (c3.f & (m2 | D | Yt | St)) !== 0 && !C2?.includes(t3) && Ne();
  let r4 = n3 ? Z(e3) : e3;
  return Me(t3, r4);
}
function Me(t3, e3) {
  if (!t3.equals(e3)) {
    var n3 = t3.v;
    rt ? q.set(t3, e3) : q.set(t3, n3), t3.v = e3;
    var r4 = z.ensure();
    r4.capture(t3, n3), (t3.f & m2) !== 0 && ((t3.f & R2) !== 0 && xt(t3), g2(t3, (t3.f & O2) === 0 ? b2 : F)), t3.wv = le(), Xt(t3, R2), p2 !== null && (p2.f & b2) !== 0 && (p2.f & (K | V)) === 0 && (T === null ? Ke([t3]) : T.push(t3)), !r4.is_fork && bt.size > 0 && !zt && qe();
  }
  return e3;
}
function qe() {
  zt = false;
  const t3 = Array.from(bt);
  for (const e3 of t3) (e3.f & b2) !== 0 && g2(e3, F), st(e3) && et(e3);
  bt.clear();
}
function dt(t3) {
  L(t3, t3.v + 1);
}
function Xt(t3, e3) {
  var n3 = t3.reactions;
  if (n3 !== null) for (var r4 = n3.length, s6 = 0; s6 < r4; s6++) {
    var l5 = n3[s6], f5 = l5.f, i4 = (f5 & R2) === 0;
    i4 && g2(l5, e3), (f5 & m2) !== 0 ? (f5 & it) === 0 && (l5.f |= it, Xt(l5, F)) : i4 && ((f5 & D) !== 0 && N !== null && N.add(l5), W(l5));
  }
}
function Z(t3) {
  if (typeof t3 != "object" || t3 === null || pt in t3) return t3;
  const e3 = pe(t3);
  if (e3 !== ve && e3 !== he) return t3;
  var n3 = /* @__PURE__ */ new Map(), r4 = ce(t3), s6 = I(0), l5 = B, f5 = (i4) => {
    if (B === l5) return i4();
    var u6 = c3, a4 = B;
    X(null), It(l5);
    var o5 = i4();
    return X(u6), It(a4), o5;
  };
  return r4 && n3.set("length", I(t3.length)), new Proxy(t3, { defineProperty(i4, u6, a4) {
    (!("value" in a4) || a4.configurable === false || a4.enumerable === false || a4.writable === false) && Se();
    var o5 = n3.get(u6);
    return o5 === void 0 ? o5 = f5(() => {
      var _3 = I(a4.value);
      return n3.set(u6, _3), _3;
    }) : L(o5, a4.value, true), true;
  }, deleteProperty(i4, u6) {
    var a4 = n3.get(u6);
    if (a4 === void 0) {
      if (u6 in i4) {
        const o5 = f5(() => I(E2));
        n3.set(u6, o5), dt(s6);
      }
    } else L(a4, E2), dt(s6);
    return true;
  }, get(i4, u6, a4) {
    if (u6 === pt) return t3;
    var o5 = n3.get(u6), _3 = u6 in i4;
    if (o5 === void 0 && (!_3 || J(i4, u6)?.writable) && (o5 = f5(() => {
      var v4 = Z(_3 ? i4[u6] : E2), h3 = I(v4);
      return h3;
    }), n3.set(u6, o5)), o5 !== void 0) {
      var d2 = lt(o5);
      return d2 === E2 ? void 0 : d2;
    }
    return Reflect.get(i4, u6, a4);
  }, getOwnPropertyDescriptor(i4, u6) {
    var a4 = Reflect.getOwnPropertyDescriptor(i4, u6);
    if (a4 && "value" in a4) {
      var o5 = n3.get(u6);
      o5 && (a4.value = lt(o5));
    } else if (a4 === void 0) {
      var _3 = n3.get(u6), d2 = _3?.v;
      if (_3 !== void 0 && d2 !== E2) return { enumerable: true, configurable: true, value: d2, writable: true };
    }
    return a4;
  }, has(i4, u6) {
    if (u6 === pt) return true;
    var a4 = n3.get(u6), o5 = a4 !== void 0 && a4.v !== E2 || Reflect.has(i4, u6);
    if (a4 !== void 0 || p2 !== null && (!o5 || J(i4, u6)?.writable)) {
      a4 === void 0 && (a4 = f5(() => {
        var d2 = o5 ? Z(i4[u6]) : E2, v4 = I(d2);
        return v4;
      }), n3.set(u6, a4));
      var _3 = lt(a4);
      if (_3 === E2) return false;
    }
    return o5;
  }, set(i4, u6, a4, o5) {
    var _3 = n3.get(u6), d2 = u6 in i4;
    if (r4 && u6 === "length") for (var v4 = a4; v4 < _3.v; v4 += 1) {
      var h3 = n3.get(v4 + "");
      h3 !== void 0 ? L(h3, E2) : v4 in i4 && (h3 = f5(() => I(E2)), n3.set(v4 + "", h3));
    }
    if (_3 === void 0) (!d2 || J(i4, u6)?.writable) && (_3 = f5(() => I(void 0)), L(_3, Z(a4)), n3.set(u6, _3));
    else {
      d2 = _3.v !== E2;
      var vt3 = f5(() => Z(a4));
      L(_3, vt3);
    }
    var Tt3 = Reflect.getOwnPropertyDescriptor(i4, u6);
    if (Tt3?.set && Tt3.set.call(o5, a4), !d2) {
      if (r4 && typeof u6 == "string") {
        var Rt4 = n3.get("length"), ht4 = Number(u6);
        Number.isInteger(ht4) && ht4 >= Rt4.v && L(Rt4, ht4 + 1);
      }
      dt(s6);
    }
    return true;
  }, ownKeys(i4) {
    lt(s6);
    var u6 = Reflect.ownKeys(i4).filter((_3) => {
      var d2 = n3.get(_3);
      return d2 === void 0 || d2.v !== E2;
    });
    for (var [a4, o5] of n3) o5.v !== E2 && !(a4 in i4) && u6.push(a4);
    return u6;
  }, setPrototypeOf() {
    Ae();
  } });
}
function bn() {
  if (Ct === void 0) {
    Ct = window;
    var t3 = Element.prototype, e3 = Node.prototype, n3 = Text.prototype;
    Zt = J(e3, "firstChild").get, Jt = J(e3, "nextSibling").get, kt(t3) && (t3.__click = void 0, t3.__className = void 0, t3.__attributes = null, t3.__style = void 0, t3.__e = void 0), kt(n3) && (n3.__t = void 0);
  }
}
function gn(t3 = "") {
  return document.createTextNode(t3);
}
function mn(t3) {
  return Zt.call(t3);
}
function Qt(t3) {
  return Jt.call(t3);
}
function xn(t3) {
  t3.textContent = "";
}
function te(t3) {
  var e3 = c3, n3 = p2;
  X(null), ot(null);
  try {
    return t3();
  } finally {
    X(e3), ot(n3);
  }
}
function Ye(t3, e3) {
  var n3 = e3.last;
  n3 === null ? e3.last = e3.first = t3 : (n3.next = t3, t3.prev = n3, e3.last = t3);
}
function nt(t3, e3, n3, r4 = true) {
  var s6 = p2;
  s6 !== null && (s6.f & M) !== 0 && (t3 |= M);
  var l5 = { ctx: H, deps: null, nodes_start: null, nodes_end: null, f: t3 | R2, first: null, fn: e3, last: null, next: null, parent: s6, b: s6 && s6.b, prev: null, teardown: null, transitions: null, wv: 0, ac: null };
  if (n3) try {
    et(l5), l5.f |= qt;
  } catch (u6) {
    throw G(l5), u6;
  }
  else e3 !== null && W(l5);
  if (r4) {
    var f5 = l5;
    if (n3 && f5.deps === null && f5.teardown === null && f5.nodes_start === null && f5.first === f5.last && (f5.f & mt) === 0 && (f5 = f5.first, (t3 & D) !== 0 && (t3 & wt) !== 0 && f5 !== null && (f5.f |= wt)), f5 !== null && (f5.parent = s6, s6 !== null && Ye(f5, s6), c3 !== null && (c3.f & m2) !== 0 && (t3 & V) === 0)) {
      var i4 = c3;
      (i4.effects ??= []).push(f5);
    }
  }
  return l5;
}
function Tn() {
  return c3 !== null && !S;
}
function Le(t3) {
  return nt(Mt | Te, t3, false);
}
function Rn(t3) {
  z.ensure();
  const e3 = nt(V | mt, t3, true);
  return (n3 = {}) => new Promise((r4) => {
    n3.outro ? Be(e3, () => {
      G(e3), r4(void 0);
    }) : (G(e3), r4(void 0));
  });
}
function kn(t3, e3 = 0) {
  return nt(me | e3, t3, true);
}
function Sn(t3, e3 = 0) {
  var n3 = nt(D | e3, t3, true);
  return n3;
}
function An(t3, e3 = true) {
  return nt(K | mt, t3, true, e3);
}
function ee(t3) {
  var e3 = t3.teardown;
  if (e3 !== null) {
    const n3 = rt, r4 = c3;
    Ft(true), X(null);
    try {
      e3.call(null);
    } finally {
      Ft(n3), X(r4);
    }
  }
}
function ne(t3, e3 = false) {
  var n3 = t3.first;
  for (t3.first = t3.last = null; n3 !== null; ) {
    const s6 = n3.ac;
    s6 !== null && te(() => {
      s6.abort(Lt);
    });
    var r4 = n3.next;
    (n3.f & V) !== 0 ? n3.parent = null : G(n3, e3), n3 = r4;
  }
}
function je(t3) {
  for (var e3 = t3.first; e3 !== null; ) {
    var n3 = e3.next;
    (e3.f & K) === 0 && G(e3), e3 = n3;
  }
}
function G(t3, e3 = true) {
  var n3 = false;
  (e3 || (t3.f & xe) !== 0) && t3.nodes_start !== null && t3.nodes_end !== null && (Ue(t3.nodes_start, t3.nodes_end), n3 = true), ne(t3, e3 && !n3), ct(t3, 0), g2(t3, U2);
  var r4 = t3.transitions;
  if (r4 !== null) for (const l5 of r4) l5.stop();
  ee(t3);
  var s6 = t3.parent;
  s6 !== null && s6.first !== null && re(t3), t3.next = t3.prev = t3.teardown = t3.ctx = t3.deps = t3.fn = t3.nodes_start = t3.nodes_end = t3.ac = null;
}
function Ue(t3, e3) {
  for (; t3 !== null; ) {
    var n3 = t3 === e3 ? null : Qt(t3);
    t3.remove(), t3 = n3;
  }
}
function re(t3) {
  var e3 = t3.parent, n3 = t3.prev, r4 = t3.next;
  n3 !== null && (n3.next = r4), r4 !== null && (r4.prev = n3), e3 !== null && (e3.first === t3 && (e3.first = r4), e3.last === t3 && (e3.last = n3));
}
function Be(t3, e3, n3 = true) {
  var r4 = [];
  se(t3, r4, true), He(r4, () => {
    n3 && G(t3), e3 && e3();
  });
}
function He(t3, e3) {
  var n3 = t3.length;
  if (n3 > 0) {
    var r4 = () => --n3 || e3();
    for (var s6 of t3) s6.out(r4);
  } else e3();
}
function se(t3, e3, n3) {
  if ((t3.f & M) === 0) {
    if (t3.f ^= M, t3.transitions !== null) for (const f5 of t3.transitions) (f5.is_global || n3) && e3.push(f5);
    for (var r4 = t3.first; r4 !== null; ) {
      var s6 = r4.next, l5 = (r4.f & wt) !== 0 || (r4.f & K) !== 0 && (t3.f & D) !== 0;
      se(r4, e3, l5 ? n3 : false), r4 = s6;
    }
  }
}
function Nn(t3, e3) {
  for (var n3 = t3.nodes_start, r4 = t3.nodes_end; n3 !== null; ) {
    var s6 = n3 === r4 ? null : Qt(n3);
    e3.append(n3), n3 = s6;
  }
}
function Dt(t3) {
  $2 = t3;
}
function Ft(t3) {
  rt = t3;
}
function X(t3) {
  c3 = t3;
}
function ot(t3) {
  p2 = t3;
}
function Ge(t3) {
  c3 !== null && (C2 === null ? C2 = [t3] : C2.push(t3));
}
function Ke(t3) {
  T = t3;
}
function It(t3) {
  B = t3;
}
function le() {
  return ++fe;
}
function st(t3) {
  var e3 = t3.f;
  if ((e3 & R2) !== 0) return true;
  if ((e3 & F) !== 0) {
    var n3 = t3.deps, r4 = (e3 & O2) !== 0;
    if (e3 & m2 && (t3.f &= ~it), n3 !== null) {
      var s6, l5, f5 = (e3 & ut) !== 0, i4 = r4 && p2 !== null && !P2, u6 = n3.length;
      if ((f5 || i4) && (p2 === null || (p2.f & U2) === 0)) {
        var a4 = t3, o5 = a4.parent;
        for (s6 = 0; s6 < u6; s6++) l5 = n3[s6], (f5 || !l5?.reactions?.includes(a4)) && (l5.reactions ??= []).push(a4);
        f5 && (a4.f ^= ut), i4 && o5 !== null && (o5.f & O2) === 0 && (a4.f ^= O2);
      }
      for (s6 = 0; s6 < u6; s6++) if (l5 = n3[s6], st(l5) && $t(l5), l5.wv > t3.wv) return true;
    }
    (!r4 || p2 !== null && !P2) && g2(t3, b2);
  }
  return false;
}
function ue(t3, e3, n3 = true) {
  var r4 = t3.reactions;
  if (r4 !== null && !C2?.includes(t3)) for (var s6 = 0; s6 < r4.length; s6++) {
    var l5 = r4[s6];
    (l5.f & m2) !== 0 ? ue(l5, e3, false) : e3 === l5 && (n3 ? g2(l5, R2) : (l5.f & b2) !== 0 && g2(l5, F), W(l5));
  }
}
function ie(t3) {
  var e3 = w2, n3 = x2, r4 = T, s6 = c3, l5 = P2, f5 = C2, i4 = H, u6 = S, a4 = B, o5 = t3.f;
  w2 = null, x2 = 0, T = null, P2 = (o5 & O2) !== 0 && (S || !$2 || c3 === null), c3 = (o5 & (K | V)) === 0 ? t3 : null, C2 = null, At(t3.ctx), S = false, B = ++tt, t3.ac !== null && (te(() => {
    t3.ac.abort(Lt);
  }), t3.ac = null);
  try {
    t3.f |= Et;
    var _3 = t3.fn, d2 = _3(), v4 = t3.deps;
    if (w2 !== null) {
      var h3;
      if (ct(t3, x2), v4 !== null && x2 > 0) for (v4.length = x2 + w2.length, h3 = 0; h3 < w2.length; h3++) v4[x2 + h3] = w2[h3];
      else t3.deps = v4 = w2;
      if (!P2 || (o5 & m2) !== 0 && t3.reactions !== null) for (h3 = x2; h3 < v4.length; h3++) (v4[h3].reactions ??= []).push(t3);
    } else v4 !== null && x2 < v4.length && (ct(t3, x2), v4.length = x2);
    if (jt() && T !== null && !S && v4 !== null && (t3.f & (m2 | F | R2)) === 0) for (h3 = 0; h3 < T.length; h3++) ue(T[h3], t3);
    return s6 !== null && s6 !== t3 && (tt++, T !== null && (r4 === null ? r4 = T : r4.push(...T))), (t3.f & at) !== 0 && (t3.f ^= at), d2;
  } catch (vt3) {
    return Fe(vt3);
  } finally {
    t3.f ^= Et, w2 = e3, x2 = n3, T = r4, c3 = s6, P2 = l5, C2 = f5, At(i4), S = u6, B = a4;
  }
}
function Ve(t3, e3) {
  let n3 = e3.reactions;
  if (n3 !== null) {
    var r4 = _e.call(n3, t3);
    if (r4 !== -1) {
      var s6 = n3.length - 1;
      s6 === 0 ? n3 = e3.reactions = null : (n3[r4] = n3[s6], n3.pop());
    }
  }
  n3 === null && (e3.f & m2) !== 0 && (w2 === null || !w2.includes(e3)) && (g2(e3, F), (e3.f & (O2 | ut)) === 0 && (e3.f ^= ut), Vt(e3), ct(e3, 0));
}
function ct(t3, e3) {
  var n3 = t3.deps;
  if (n3 !== null) for (var r4 = e3; r4 < n3.length; r4++) Ve(t3, n3[r4]);
}
function et(t3) {
  var e3 = t3.f;
  if ((e3 & U2) === 0) {
    g2(t3, b2);
    var n3 = p2, r4 = $2;
    p2 = t3, $2 = true;
    try {
      (e3 & D) !== 0 ? je(t3) : ne(t3), ee(t3);
      var s6 = ie(t3);
      t3.teardown = typeof s6 == "function" ? s6 : null, t3.wv = fe;
      var l5;
      s && Oe && (t3.f & R2) !== 0 && t3.deps;
    } finally {
      $2 = r4, p2 = n3;
    }
  }
}
function lt(t3) {
  var e3 = t3.f, n3 = (e3 & m2) !== 0;
  if (c3 !== null && !S) {
    var r4 = p2 !== null && (p2.f & U2) !== 0;
    if (!r4 && !C2?.includes(t3)) {
      var s6 = c3.deps;
      if ((c3.f & Et) !== 0) t3.rv < tt && (t3.rv = tt, w2 === null && s6 !== null && s6[x2] === t3 ? x2++ : w2 === null ? w2 = [t3] : (!P2 || !w2.includes(t3)) && w2.push(t3));
      else {
        (c3.deps ??= []).push(t3);
        var l5 = t3.reactions;
        l5 === null ? t3.reactions = [c3] : l5.includes(c3) || l5.push(c3);
      }
    }
  } else if (n3 && t3.deps === null && t3.effects === null) {
    var f5 = t3, i4 = f5.parent;
    i4 !== null && (i4.f & O2) === 0 && (f5.f ^= O2);
  }
  if (rt) {
    if (q.has(t3)) return q.get(t3);
    if (n3) {
      f5 = t3;
      var u6 = f5.v;
      return ((f5.f & b2) === 0 && f5.reactions !== null || ae(f5)) && (u6 = xt(f5)), q.set(f5, u6), u6;
    }
  } else if (n3) {
    if (f5 = t3, k?.has(f5)) return k.get(f5);
    st(f5) && $t(f5);
  }
  if (k?.has(t3)) return k.get(t3);
  if ((t3.f & at) !== 0) throw t3.v;
  return t3.v;
}
function ae(t3) {
  if (t3.v === E2) return true;
  if (t3.deps === null) return false;
  for (const e3 of t3.deps) if (q.has(e3) || (e3.f & m2) !== 0 && ae(e3)) return true;
  return false;
}
function $e(t3) {
  var e3 = S;
  try {
    return S = true, t3();
  } finally {
    S = e3;
  }
}
function g2(t3, e3) {
  t3.f = t3.f & ze | e3;
}
function On(t3, e3) {
  const n3 = String(t3 ?? ""), r4 = e3 ? We : Xe;
  r4.lastIndex = 0;
  let s6 = "", l5 = 0;
  for (; r4.test(n3); ) {
    const f5 = r4.lastIndex - 1, i4 = n3[f5];
    s6 += n3.substring(l5, f5) + (i4 === "&" ? "&amp;" : i4 === '"' ? "&quot;" : "&lt;"), l5 = f5 + 1;
  }
  return s6 + n3.substring(l5);
}
function Cn(t3, e3, n3) {
  if (t3 == null) return e3(void 0), n3 && n3(void 0), de;
  const r4 = $e(() => t3.subscribe(e3, n3));
  return r4.unsubscribe ? () => r4.unsubscribe() : r4;
}
function Dn(t3) {
  Y = t3;
}
function Fn(t3) {
  return oe().get(t3);
}
function In(t3, e3) {
  return oe().set(t3, e3), e3;
}
function oe(t3) {
  return Y === null && Re(), Y.c ??= new Map(Ze(Y) || void 0);
}
function Pn(t3) {
  Y = { p: Y, c: null, r: null };
}
function Mn() {
  Y = Y.p;
}
function Ze(t3) {
  let e3 = t3.p;
  for (; e3 !== null; ) {
    const n3 = e3.c;
    if (n3 !== null) return n3;
    e3 = e3.p;
  }
  return null;
}
var ce, _e, tn, en, J, ve, he, pe, kt, de, m2, Mt, me, D, K, V, gt, b2, R2, F, M, U2, qt, wt, St, xe, mt, Te, O2, ut, it, Et, Yt, at, pt, rn, Lt, fn, an, on, cn, _n, vn, hn, pn, E2, Oe, H, j2, ft, y2, k, Nt, A, _t, yt, Q, z, N, bt, q, zt, Ct, Zt, Jt, $2, rt, c3, S, p2, C2, w2, x2, T, fe, tt, B, P2, ze, We, Xe, Y;
var init_context = __esm({
  ".svelte-kit/output/server/chunks/context.js"() {
    init_false();
    init_clsx();
    ce = Array.isArray;
    _e = Array.prototype.indexOf;
    tn = Array.from;
    en = Object.defineProperty;
    J = Object.getOwnPropertyDescriptor;
    ve = Object.prototype;
    he = Array.prototype;
    pe = Object.getPrototypeOf;
    kt = Object.isExtensible;
    de = () => {
    };
    m2 = 2;
    Mt = 4;
    me = 8;
    D = 16;
    K = 32;
    V = 64;
    gt = 128;
    b2 = 1024;
    R2 = 2048;
    F = 4096;
    M = 8192;
    U2 = 16384;
    qt = 32768;
    wt = 65536;
    St = 1 << 17;
    xe = 1 << 18;
    mt = 1 << 19;
    Te = 1 << 20;
    O2 = 256;
    ut = 512;
    it = 32768;
    Et = 1 << 21;
    Yt = 1 << 22;
    at = 1 << 23;
    pt = Symbol("$state");
    rn = Symbol("legacy props");
    Lt = new class extends Error {
      name = "StaleReactionError";
      message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
    }();
    fn = 8;
    an = "[";
    on = "[!";
    cn = "]";
    _n = {};
    vn = 1;
    hn = 2;
    pn = 4;
    E2 = Symbol();
    Oe = false;
    H = null;
    j2 = [];
    ft = /* @__PURE__ */ new Set();
    y2 = null;
    k = null;
    Nt = /* @__PURE__ */ new Set();
    A = [];
    _t = null;
    yt = false;
    Q = false;
    z = class _z {
      committed = false;
      current = /* @__PURE__ */ new Map();
      previous = /* @__PURE__ */ new Map();
      #r = /* @__PURE__ */ new Set();
      #s = /* @__PURE__ */ new Set();
      #e = 0;
      #n = 0;
      #u = null;
      #f = [];
      #l = [];
      skipped_effects = /* @__PURE__ */ new Set();
      is_fork = false;
      process(e3) {
        A = [], this.apply();
        var n3 = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] };
        for (const r4 of e3) this.#i(r4, n3);
        this.is_fork || this.#a(), this.#n > 0 || this.is_fork ? (this.#t(n3.effects), this.#t(n3.render_effects), this.#t(n3.block_effects)) : (y2 = null, Ot(n3.render_effects), Ot(n3.effects)), k = null;
      }
      #i(e3, n3) {
        e3.f ^= b2;
        for (var r4 = e3.first; r4 !== null; ) {
          var s6 = r4.f, l5 = (s6 & (K | V)) !== 0, f5 = l5 && (s6 & b2) !== 0, i4 = f5 || (s6 & M) !== 0 || this.skipped_effects.has(r4);
          if ((r4.f & gt) !== 0 && r4.b?.is_pending() && (n3 = { parent: n3, effect: r4, effects: [], render_effects: [], block_effects: [] }), !i4 && r4.fn !== null) {
            l5 ? r4.f ^= b2 : (s6 & Mt) !== 0 ? n3.effects.push(r4) : st(r4) && ((r4.f & D) !== 0 && n3.block_effects.push(r4), et(r4));
            var u6 = r4.first;
            if (u6 !== null) {
              r4 = u6;
              continue;
            }
          }
          var a4 = r4.parent;
          for (r4 = r4.next; r4 === null && a4 !== null; ) a4 === n3.effect && (this.#t(n3.effects), this.#t(n3.render_effects), this.#t(n3.block_effects), n3 = n3.parent), r4 = a4.next, a4 = a4.parent;
        }
      }
      #t(e3) {
        for (const n3 of e3) ((n3.f & R2) !== 0 ? this.#f : this.#l).push(n3), g2(n3, b2);
      }
      capture(e3, n3) {
        this.previous.has(e3) || this.previous.set(e3, n3), this.current.set(e3, e3.v), k?.set(e3, e3.v);
      }
      activate() {
        y2 = this;
      }
      deactivate() {
        y2 = null, k = null;
      }
      flush() {
        if (this.activate(), A.length > 0) {
          if (Ht(), y2 !== null && y2 !== this) return;
        } else this.#e === 0 && this.process([]);
        this.deactivate();
        for (const e3 of Nt) if (Nt.delete(e3), e3(), y2 !== null) break;
      }
      discard() {
        for (const e3 of this.#s) e3(this);
        this.#s.clear();
      }
      #a() {
        if (this.#n === 0) {
          for (const e3 of this.#r) e3();
          this.#r.clear();
        }
        this.#e === 0 && this.#o();
      }
      #o() {
        if (ft.size > 1) {
          this.previous.clear();
          var e3 = k, n3 = true, r4 = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] };
          for (const s6 of ft) {
            if (s6 === this) {
              n3 = false;
              continue;
            }
            const l5 = [];
            for (const [i4, u6] of this.current) {
              if (s6.current.has(i4)) if (n3 && u6 !== s6.current.get(i4)) s6.current.set(i4, u6);
              else continue;
              l5.push(i4);
            }
            if (l5.length === 0) continue;
            const f5 = [...s6.current.keys()].filter((i4) => !this.current.has(i4));
            if (f5.length > 0) {
              const i4 = /* @__PURE__ */ new Set(), u6 = /* @__PURE__ */ new Map();
              for (const a4 of l5) Gt(a4, f5, i4, u6);
              if (A.length > 0) {
                y2 = s6, s6.apply();
                for (const a4 of A) s6.#i(a4, r4);
                A = [], s6.deactivate();
              }
            }
          }
          y2 = null, k = e3;
        }
        this.committed = true, ft.delete(this), this.#u?.resolve();
      }
      increment(e3) {
        this.#e += 1, e3 && (this.#n += 1);
      }
      decrement(e3) {
        this.#e -= 1, e3 && (this.#n -= 1), this.revive();
      }
      revive() {
        for (const e3 of this.#f) g2(e3, R2), W(e3);
        for (const e3 of this.#l) g2(e3, F), W(e3);
        this.#f = [], this.#l = [], this.flush();
      }
      oncommit(e3) {
        this.#r.add(e3);
      }
      ondiscard(e3) {
        this.#s.add(e3);
      }
      settled() {
        return (this.#u ??= Ee()).promise;
      }
      static ensure() {
        if (y2 === null) {
          const e3 = y2 = new _z();
          ft.add(y2), Q || _z.enqueue(() => {
            y2 === e3 && e3.flush();
          });
        }
        return y2;
      }
      static enqueue(e3) {
        Ce(e3);
      }
      apply() {
      }
    };
    N = null;
    bt = /* @__PURE__ */ new Set();
    q = /* @__PURE__ */ new Map();
    zt = false;
    $2 = false;
    rt = false;
    c3 = null;
    S = false;
    p2 = null;
    C2 = null;
    w2 = null;
    x2 = 0;
    T = null;
    fe = 1;
    tt = 0;
    B = tt;
    P2 = false;
    ze = -7169;
    We = /[&"<]/g;
    Xe = /[&<]/g;
    Y = null;
  }
});

// .svelte-kit/output/server/chunks/index.js
function x3(s6, u6) {
  return { subscribe: z2(s6, u6).subscribe };
}
function z2(s6, u6 = de) {
  let n3 = null;
  const r4 = /* @__PURE__ */ new Set();
  function i4(t3) {
    if (be(s6, t3) && (s6 = t3, n3)) {
      const o5 = !a3.length;
      for (const e3 of r4) e3[1](), a3.push(e3, s6);
      if (o5) {
        for (let e3 = 0; e3 < a3.length; e3 += 2) a3[e3][0](a3[e3 + 1]);
        a3.length = 0;
      }
    }
  }
  function l5(t3) {
    i4(t3(s6));
  }
  function b5(t3, o5 = de) {
    const e3 = [t3, o5];
    return r4.add(e3), r4.size === 1 && (n3 = u6(i4, l5) || de), t3(s6), () => {
      r4.delete(e3), r4.size === 0 && n3 && (n3(), n3 = null);
    };
  }
  return { set: i4, update: l5, subscribe: b5 };
}
function B2(s6, u6, n3) {
  const r4 = !Array.isArray(s6), i4 = r4 ? [s6] : s6;
  if (!i4.every(Boolean)) throw new Error("derived() expects stores as input, got a falsy value");
  const l5 = u6.length < 2;
  return x3(n3, (b5, t3) => {
    let o5 = false;
    const e3 = [];
    let p4 = 0, d2 = de;
    const y4 = () => {
      if (p4) return;
      d2();
      const c6 = u6(r4 ? e3[0] : e3, b5, t3);
      l5 ? b5(c6) : d2 = typeof c6 == "function" ? c6 : de;
    }, _3 = i4.map((c6, g3) => Cn(c6, (h3) => {
      e3[g3] = h3, p4 &= ~(1 << g3), o5 && y4();
    }, () => {
      p4 |= 1 << g3;
    }));
    return o5 = true, y4(), function() {
      we(_3), d2(), o5 = false;
    };
  });
}
var a3;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    init_context();
    a3 = [];
  }
});

// .svelte-kit/output/server/chunks/index2.js
function U3(i4) {
  return H2.includes(i4) || i4.toLowerCase() === "!doctype";
}
function Y2(i4) {
  return X2.includes(i4);
}
function nt2(i4) {
  return K2.includes(i4);
}
function G2(i4) {
  return q2.includes(i4);
}
function W2(i4, t3, s6 = false) {
  if (i4 === "hidden" && t3 !== "until-found" && (s6 = true), t3 == null || !t3 && s6) return "";
  const n3 = i4 in T2 && T2[i4].get(t3) || t3, e3 = s6 ? "" : `="${On(n3, true)}"`;
  return ` ${i4}${e3}`;
}
function Z2(i4) {
  return typeof i4 == "object" ? clsx(i4) : i4 ?? "";
}
function M2(i4, t3, s6) {
  var n3 = i4 == null ? "" : "" + i4;
  if (t3 && (n3 = n3 ? n3 + " " + t3 : t3), s6) {
    for (var e3 in s6) if (s6[e3]) n3 = n3 ? n3 + " " + e3 : e3;
    else if (n3.length) for (var o5 = e3.length, c6 = 0; (c6 = n3.indexOf(e3, c6)) >= 0; ) {
      var u6 = c6 + o5;
      (c6 === 0 || S2.includes(n3[c6 - 1])) && (u6 === n3.length || S2.includes(n3[u6])) ? n3 = (c6 === 0 ? "" : n3.substring(0, c6)) + n3.substring(u6 + 1) : c6 = u6;
    }
  }
  return n3 === "" ? null : n3;
}
function $3(i4, t3 = false) {
  var s6 = t3 ? " !important;" : ";", n3 = "";
  for (var e3 in i4) {
    var o5 = i4[e3];
    o5 != null && o5 !== "" && (n3 += " " + e3 + ": " + o5 + s6);
  }
  return n3;
}
function E3(i4) {
  return i4[0] !== "-" || i4[1] !== "-" ? i4.toLowerCase() : i4;
}
function C3(i4, t3) {
  if (t3) {
    var s6 = "", n3, e3;
    if (Array.isArray(t3) ? (n3 = t3[0], e3 = t3[1]) : n3 = t3, i4) {
      i4 = String(i4).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var o5 = false, c6 = 0, u6 = false, f5 = [];
      n3 && f5.push(...Object.keys(n3).map(E3)), e3 && f5.push(...Object.keys(e3).map(E3));
      var a4 = 0, r4 = -1;
      const m5 = i4.length;
      for (var F3 = 0; F3 < m5; F3++) {
        var h3 = i4[F3];
        if (u6 ? h3 === "/" && i4[F3 - 1] === "*" && (u6 = false) : o5 ? o5 === h3 && (o5 = false) : h3 === "/" && i4[F3 + 1] === "*" ? u6 = true : h3 === '"' || h3 === "'" ? o5 = h3 : h3 === "(" ? c6++ : h3 === ")" && c6--, !u6 && o5 === false && c6 === 0) {
          if (h3 === ":" && r4 === -1) r4 = F3;
          else if (h3 === ";" || F3 === m5 - 1) {
            if (r4 !== -1) {
              var D5 = E3(i4.substring(a4, r4).trim());
              if (!f5.includes(D5)) {
                h3 !== ";" && F3++;
                var I4 = i4.substring(a4, F3).trim();
                s6 += " " + I4 + ";";
              }
            }
            a4 = F3 + 1, r4 = -1;
          }
        }
      }
    }
    return n3 && (s6 += $3(n3)), e3 && (s6 += $3(e3, true)), s6 = s6.trim(), s6 === "" ? null : s6;
  }
  return i4 == null ? null : String(i4);
}
function N2() {
  O3?.abort(Lt), O3 = null;
}
function Q2() {
  const i4 = new Error(`await_invalid
Encountered asynchronous work while rendering synchronously.
https://svelte.dev/e/await_invalid`);
  throw i4.name = "Svelte error", i4;
}
function et2(i4, t3, s6 = de, n3 = de) {
  i4.push("<!---->"), t3 && (i4.push(`<${t3}`), s6(), i4.push(">"), U3(t3) || (n3(), G2(t3) || i4.push(J2), i4.push(`</${t3}>`))), i4.push("<!---->");
}
function ot2(i4, t3 = {}) {
  return l3.render(i4, t3);
}
function ct2(i4, t3) {
  i4.head((s6) => {
    s6.push(y3), s6.child(t3), s6.push(b3);
  });
}
function L2(i4, t3, s6, n3, e3 = 0) {
  n3 && (i4.style = C3(i4.style, n3)), i4.class && (i4.class = Z2(i4.class)), (t3 || s6) && (i4.class = M2(i4.class, t3, s6));
  let o5 = "", c6;
  const u6 = (e3 & vn) === 0, f5 = (e3 & hn) === 0, a4 = (e3 & pn) !== 0;
  for (c6 in i4) if (typeof i4[c6] != "function" && !(c6[0] === "$" && c6[1] === "$") && !tt2.test(c6)) {
    var r4 = i4[c6];
    f5 && (c6 = c6.toLowerCase()), !(a4 && (c6 === "defaultvalue" || c6 === "defaultchecked") && (c6 = c6 === "defaultvalue" ? "value" : "checked", i4[c6])) && (o5 += W2(c6, r4, u6 && Y2(c6)));
  }
  return o5;
}
function ut2(i4) {
  return typeof i4 == "string" ? i4 : i4 == null ? "" : i4 + "";
}
function lt2(i4, t3, s6) {
  var n3 = M2(i4, t3, s6);
  return n3 ? ` class="${On(n3, true)}"` : "";
}
function ft2(i4, t3) {
  var s6 = C3(i4, t3);
  return s6 ? ` style="${On(s6, true)}"` : "";
}
function rt2(i4, t3, s6) {
  if (t3 in i4 && i4[t3][0] === s6) return i4[t3][2];
  i4[t3]?.[1](), i4[t3] = [s6, null, void 0];
  const n3 = Cn(s6, (e3) => i4[t3][2] = e3);
  return i4[t3][1] = n3, i4[t3][2];
}
function at2(i4) {
  for (const t3 in i4) i4[t3][1]();
}
function ht(i4, t3, s6, n3, e3) {
  var o5 = t3.$$slots?.[s6];
  o5 === true && (o5 = t3.children), o5 !== void 0 && o5(i4, n3);
}
function Ft2(i4, t3) {
  const s6 = {};
  let n3;
  for (n3 in i4) t3.includes(n3) || (s6[n3] = i4[n3]);
  return s6;
}
function dt2(i4) {
  const { children: t3, $$slots: s6, ...n3 } = i4;
  return n3;
}
function pt2(i4, t3) {
  for (const s6 in t3) {
    const n3 = i4[s6], e3 = t3[s6];
    n3 === void 0 && e3 !== void 0 && Object.getOwnPropertyDescriptor(i4, s6)?.set && (i4[s6] = e3);
  }
}
function Et2(i4) {
  return i4 ? i4.length !== void 0 ? i4 : Array.from(i4) : [];
}
var H2, X2, K2, q2, T2, S2, y3, b3, J2, O3, l3, R3, tt2;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    init_context();
    init_clsx();
    H2 = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
    X2 = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "indeterminate", "inert", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected", "webkitdirectory", "defer", "disablepictureinpicture", "disableremoteplayback"];
    K2 = ["touchstart", "touchmove"];
    q2 = ["textarea", "script", "style", "title"];
    T2 = { translate: /* @__PURE__ */ new Map([[true, "yes"], [false, "no"]]) };
    S2 = [...` 	
\r\f\xA0\v\uFEFF`];
    y3 = `<!--${an}-->`;
    b3 = `<!--${cn}-->`;
    J2 = "<!---->";
    O3 = null;
    l3 = class _l {
      #t = [];
      #o = void 0;
      #c = false;
      type;
      #s;
      promise = void 0;
      global;
      local;
      constructor(t3, s6) {
        this.#s = s6, this.global = t3, this.local = s6 ? { ...s6.local } : { select_value: void 0 }, this.type = s6 ? s6.type : "body";
      }
      head(t3) {
        const s6 = new _l(this.global, this);
        s6.type = "head", this.#t.push(s6), s6.child(t3);
      }
      async(t3) {
        this.#t.push(y3), this.child(t3), this.#t.push(b3);
      }
      child(t3) {
        const s6 = new _l(this.global, this);
        this.#t.push(s6);
        const n3 = Y;
        Dn({ ...Y, p: n3, c: null, r: s6 });
        const e3 = t3(s6);
        return Dn(n3), e3 instanceof Promise && (s6.global.mode === "sync" && Q2(), e3.catch(() => {
        }), s6.promise = e3), s6;
      }
      component(t3, s6) {
        Pn();
        const n3 = this.child(t3);
        n3.#c = true, Mn();
      }
      select(t3, s6, n3, e3, o5, c6) {
        const { value: u6, ...f5 } = t3;
        this.push(`<select${L2(f5, n3, e3, o5, c6)}>`), this.child((a4) => {
          a4.local.select_value = u6, s6(a4);
        }), this.push("</select>");
      }
      option(t3, s6, n3, e3, o5, c6) {
        this.#t.push(`<option${L2(t3, n3, e3, o5, c6)}`);
        const u6 = (f5, a4, { head: r4, body: F3 }) => {
          "value" in t3 && (a4 = t3.value), a4 === this.local.select_value && f5.#t.push(" selected"), f5.#t.push(`>${F3}</option>`), r4 && f5.head((h3) => h3.push(r4));
        };
        typeof s6 == "function" ? this.child((f5) => {
          const a4 = new _l(this.global, this);
          if (s6(a4), this.global.mode === "async") return a4.#e().then((r4) => {
            u6(f5, r4.body.replaceAll("<!---->", ""), r4);
          });
          {
            const r4 = a4.#n();
            u6(f5, r4.body.replaceAll("<!---->", ""), r4);
          }
        }) : u6(this, s6, { body: s6 });
      }
      title(t3) {
        const s6 = this.get_path(), n3 = (e3) => {
          this.global.set_title(e3, s6);
        };
        this.child((e3) => {
          const o5 = new _l(e3.global, e3);
          if (t3(o5), e3.global.mode === "async") return o5.#e().then((c6) => {
            n3(c6.head);
          });
          {
            const c6 = o5.#n();
            n3(c6.head);
          }
        });
      }
      push(t3) {
        typeof t3 == "function" ? this.child(async (s6) => s6.push(await t3())) : this.#t.push(t3);
      }
      on_destroy(t3) {
        (this.#o ??= []).push(t3);
      }
      get_path() {
        return this.#s ? [...this.#s.get_path(), this.#s.#t.indexOf(this)] : [];
      }
      copy() {
        const t3 = new _l(this.global, this.#s);
        return t3.#t = this.#t.map((s6) => s6 instanceof _l ? s6.copy() : s6), t3.promise = this.promise, t3;
      }
      subsume(t3) {
        if (this.global.mode !== t3.global.mode) throw new Error("invariant: A renderer cannot switch modes. If you're seeing this, there's a compiler bug. File an issue!");
        this.local = t3.local, this.#t = t3.#t.map((s6) => (s6 instanceof _l && s6.subsume(s6), s6)), this.promise = t3.promise, this.type = t3.type;
      }
      get length() {
        return this.#t.length;
      }
      static render(t3, s6 = {}) {
        let n3;
        const e3 = {};
        return Object.defineProperties(e3, { html: { get: () => (n3 ??= _l.#i(t3, s6)).body }, head: { get: () => (n3 ??= _l.#i(t3, s6)).head }, body: { get: () => (n3 ??= _l.#i(t3, s6)).body }, then: { value: (o5, c6) => {
          {
            const u6 = n3 ??= _l.#i(t3, s6), f5 = o5({ head: u6.head, body: u6.body, html: u6.body });
            return Promise.resolve(f5);
          }
        } } }), e3;
      }
      *#a() {
        for (const t3 of this.#u()) yield* t3.#l();
      }
      *#u() {
        for (const t3 of this.#t) typeof t3 != "string" && (yield* t3.#u());
        this.#c && (yield this);
      }
      *#l() {
        if (this.#o) for (const t3 of this.#o) yield t3;
        for (const t3 of this.#t) t3 instanceof _l && !t3.#c && (yield* t3.#l());
      }
      static #i(t3, s6) {
        var n3 = Y;
        try {
          const e3 = _l.#f("sync", t3, s6), o5 = e3.#n();
          return _l.#r(o5, e3);
        } finally {
          N2(), Dn(n3);
        }
      }
      static async #h(t3, s6) {
        var n3 = Y;
        try {
          const e3 = _l.#f("async", t3, s6), o5 = await e3.#e();
          return _l.#r(o5, e3);
        } finally {
          N2(), Dn(n3);
        }
      }
      #n(t3 = { head: "", body: "" }) {
        for (const s6 of this.#t) typeof s6 == "string" ? t3[this.type] += s6 : s6 instanceof _l && s6.#n(t3);
        return t3;
      }
      async #e(t3 = { head: "", body: "" }) {
        await this.promise;
        for (const s6 of this.#t) typeof s6 == "string" ? t3[this.type] += s6 : s6 instanceof _l && await s6.#e(t3);
        return t3;
      }
      static #f(t3, s6, n3) {
        const e3 = new _l(new R3(t3, n3.idPrefix ? n3.idPrefix + "-" : ""));
        return e3.push(y3), n3.context && (Pn(), Y.c = n3.context, Y.r = e3), s6(e3, n3.props ?? {}), n3.context && Mn(), e3.push(b3), e3;
      }
      static #r(t3, s6) {
        for (const o5 of s6.#a()) o5();
        let n3 = t3.head + s6.global.get_title(), e3 = t3.body;
        for (const { hash: o5, code: c6 } of s6.global.css) n3 += `<style id="${o5}">${c6}</style>`;
        return { head: n3, body: e3 };
      }
    };
    R3 = class {
      mode;
      uid;
      css = /* @__PURE__ */ new Set();
      #t = { path: [], value: "" };
      constructor(t3, s6 = "") {
        this.mode = t3;
        let n3 = 1;
        this.uid = () => `${s6}s${n3++}`;
      }
      get_title() {
        return this.#t.value;
      }
      set_title(t3, s6) {
        const n3 = this.#t.path;
        let e3 = 0, o5 = Math.min(s6.length, n3.length);
        for (; e3 < o5 && s6[e3] === n3[e3]; ) e3 += 1;
        s6[e3] !== void 0 && (n3[e3] === void 0 || s6[e3] > n3[e3]) && (this.#t.path = s6, this.#t.value = t3);
      }
    };
    tt2 = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse4;
    exports.serialize = serialize2;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse4(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode2;
      var index6 = 0;
      while (index6 < str.length) {
        var eqIdx = str.indexOf("=", index6);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index6);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index6 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index6, eqIdx).trim();
        if (void 0 === obj[key]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index6 = endIdx + 1;
      }
      return obj;
    }
    function serialize2(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode2;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.partitioned) {
        str += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode2(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode2(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode3) {
      try {
        return decode3(str);
      } catch (e3) {
        return str;
      }
    }
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString3(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e3) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e3
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else if (key === "partitioned") {
          cookie.partitioned = true;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse4(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString3(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString3(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start2;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start2 = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start2, lastComma));
              start2 = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start2, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse4;
    module.exports.parse = parse4;
    module.exports.parseString = parseString3;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// .svelte-kit/output/server/entries/pages/_layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => h2
});
function h2(a4, l5) {
  let { children: t3 } = l5;
  ct2(a4, (e3) => {
    e3.push(`<link rel="icon"${W2("href", c4)}/>`);
  }), t3?.(a4), a4.push("<!---->");
}
var c4;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_index2();
    c4 = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='107'%20height='128'%20viewBox='0%200%20107%20128'%3e%3ctitle%3esvelte-logo%3c/title%3e%3cpath%20d='M94.157%2022.819c-10.4-14.885-30.94-19.297-45.792-9.835L22.282%2029.608A29.92%2029.92%200%200%200%208.764%2049.65a31.5%2031.5%200%200%200%203.108%2020.231%2030%2030%200%200%200-4.477%2011.183%2031.9%2031.9%200%200%200%205.448%2024.116c10.402%2014.887%2030.942%2019.297%2045.791%209.835l26.083-16.624A29.92%2029.92%200%200%200%2098.235%2078.35a31.53%2031.53%200%200%200-3.105-20.232%2030%2030%200%200%200%204.474-11.182%2031.88%2031.88%200%200%200-5.447-24.116'%20style='fill:%23ff3e00'/%3e%3cpath%20d='M45.817%20106.582a20.72%2020.72%200%200%201-22.237-8.243%2019.17%2019.17%200%200%201-3.277-14.503%2018%2018%200%200%201%20.624-2.435l.49-1.498%201.337.981a33.6%2033.6%200%200%200%2010.203%205.098l.97.294-.09.968a5.85%205.85%200%200%200%201.052%203.878%206.24%206.24%200%200%200%206.695%202.485%205.8%205.8%200%200%200%201.603-.704L69.27%2076.28a5.43%205.43%200%200%200%202.45-3.631%205.8%205.8%200%200%200-.987-4.371%206.24%206.24%200%200%200-6.698-2.487%205.7%205.7%200%200%200-1.6.704l-9.953%206.345a19%2019%200%200%201-5.296%202.326%2020.72%2020.72%200%200%201-22.237-8.243%2019.17%2019.17%200%200%201-3.277-14.502%2017.99%2017.99%200%200%201%208.13-12.052l26.081-16.623a19%2019%200%200%201%205.3-2.329%2020.72%2020.72%200%200%201%2022.237%208.243%2019.17%2019.17%200%200%201%203.277%2014.503%2018%2018%200%200%201-.624%202.435l-.49%201.498-1.337-.98a33.6%2033.6%200%200%200-10.203-5.1l-.97-.294.09-.968a5.86%205.86%200%200%200-1.052-3.878%206.24%206.24%200%200%200-6.696-2.485%205.8%205.8%200%200%200-1.602.704L37.73%2051.72a5.42%205.42%200%200%200-2.449%203.63%205.79%205.79%200%200%200%20.986%204.372%206.24%206.24%200%200%200%206.698%202.486%205.8%205.8%200%200%200%201.602-.704l9.952-6.342a19%2019%200%200%201%205.295-2.328%2020.72%2020.72%200%200%201%2022.237%208.242%2019.17%2019.17%200%200%201%203.277%2014.503%2018%2018%200%200%201-8.13%2012.053l-26.081%2016.622a19%2019%200%200%201-5.3%202.328'%20style='fill:%23fff'/%3e%3c/svg%3e";
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  stylesheets: () => stylesheets
});
var index, component_cache, component, imports, stylesheets, fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    index = 0;
    component = async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default;
    imports = ["_app/immutable/nodes/0.BhTolFQs.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/obLiwMeQ.js", "_app/immutable/chunks/d6K977q5.js"];
    stylesheets = ["_app/immutable/assets/0.Buy76JVg.css"];
    fonts = [];
  }
});

// .svelte-kit/output/server/chunks/state.svelte.js
var o2;
var init_state_svelte = __esm({
  ".svelte-kit/output/server/chunks/state.svelte.js"() {
    init_clsx();
    init_context();
    init_server();
    o2 = de.toString().includes("$$") || /function \w+\(\) \{\}/.test(de.toString());
    o2 && new URL("https://example.com");
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => b4
});
function n() {
  const { set: t3, subscribe: e3 } = z2(false);
  return { subscribe: e3, check: async () => false };
}
function o3() {
  return Fn("__request__");
}
function b4(t3, e3) {
  t3.component((p4) => {
    p4.push(`<h1>${On(s3.status)}</h1> <p>${On(s3.error?.message)}</p>`);
  });
}
var u2, i3, s3;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_context();
    init_clsx();
    init_state_svelte();
    init_internal();
    init_exports();
    init_utils();
    init_chunks();
    init_server();
    u2 = { updated: n() };
    u2.updated.check;
    i3 = { get error() {
      return o3().page.error;
    }, get status() {
      return o3().page.status;
    } };
    s3 = i3;
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2, component_cache2, component2, imports2, stylesheets2, fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default;
    imports2 = ["_app/immutable/nodes/1.DVa4rnnb.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/CUqaGiYm.js", "_app/immutable/chunks/obLiwMeQ.js", "_app/immutable/chunks/6ds4e1Hj.js", "_app/immutable/chunks/DPtGKd3c.js", "_app/immutable/chunks/ilhcaF4n.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});

// node_modules/ol/TileState.js
var TileState_default;
var init_TileState = __esm({
  "node_modules/ol/TileState.js"() {
    TileState_default = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      /**
       * Indicates that tile loading failed
       * @type {number}
       */
      ERROR: 3,
      EMPTY: 4
    };
  }
});

// node_modules/ol/easing.js
function easeIn(t3) {
  return Math.pow(t3, 3);
}
function easeOut(t3) {
  return 1 - easeIn(1 - t3);
}
function inAndOut(t3) {
  return 3 * t3 * t3 - 2 * t3 * t3 * t3;
}
var init_easing = __esm({
  "node_modules/ol/easing.js"() {
  }
});

// node_modules/ol/events/EventType.js
var EventType_default;
var init_EventType = __esm({
  "node_modules/ol/events/EventType.js"() {
    EventType_default = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: "change",
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: "error",
      BLUR: "blur",
      CLEAR: "clear",
      CONTEXTMENU: "contextmenu",
      CLICK: "click",
      DBLCLICK: "dblclick",
      DRAGENTER: "dragenter",
      DRAGOVER: "dragover",
      DROP: "drop",
      FOCUS: "focus",
      KEYDOWN: "keydown",
      KEYPRESS: "keypress",
      LOAD: "load",
      RESIZE: "resize",
      TOUCHMOVE: "touchmove",
      WHEEL: "wheel"
    };
  }
});

// node_modules/ol/Disposable.js
var Disposable, Disposable_default;
var init_Disposable = __esm({
  "node_modules/ol/Disposable.js"() {
    Disposable = class {
      constructor() {
        this.disposed = false;
      }
      /**
       * Clean up.
       */
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.disposeInternal();
        }
      }
      /**
       * Extension point for disposable objects.
       * @protected
       */
      disposeInternal() {
      }
    };
    Disposable_default = Disposable;
  }
});

// node_modules/ol/array.js
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function ascending(a4, b5) {
  return a4 > b5 ? 1 : a4 < b5 ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n3 = arr.length;
  if (target <= arr[n3 - 1]) {
    return n3 - 1;
  }
  if (typeof direction === "function") {
    for (let i4 = 1; i4 < n3; ++i4) {
      const candidate = arr[i4];
      if (candidate === target) {
        return i4;
      }
      if (candidate < target) {
        if (direction(target, arr[i4 - 1], candidate) > 0) {
          return i4 - 1;
        }
        return i4;
      }
    }
    return n3 - 1;
  }
  if (direction > 0) {
    for (let i4 = 1; i4 < n3; ++i4) {
      if (arr[i4] < target) {
        return i4 - 1;
      }
    }
    return n3 - 1;
  }
  if (direction < 0) {
    for (let i4 = 1; i4 < n3; ++i4) {
      if (arr[i4] <= target) {
        return i4;
      }
    }
    return n3 - 1;
  }
  for (let i4 = 1; i4 < n3; ++i4) {
    if (arr[i4] == target) {
      return i4;
    }
    if (arr[i4] < target) {
      if (arr[i4 - 1] - target < target - arr[i4]) {
        return i4 - 1;
      }
      return i4;
    }
  }
  return n3 - 1;
}
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i4 = 0; i4 < length; i4++) {
    arr[arr.length] = extension[i4];
  }
}
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i4 = 0; i4 < len1; i4++) {
    if (arr1[i4] !== arr2[i4]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index6) {
    if (index6 === 0) {
      return true;
    }
    const res = compare(arr[index6 - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}
var init_array = __esm({
  "node_modules/ol/array.js"() {
  }
});

// node_modules/ol/functions.js
function VOID() {
}
function memoizeOne(fn3) {
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!lastArgs || this !== lastThis || !equals(nextArgs, lastArgs)) {
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn3.apply(this, arguments);
    }
    return lastResult;
  };
}
var init_functions = __esm({
  "node_modules/ol/functions.js"() {
    init_array();
  }
});

// node_modules/ol/obj.js
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}
var init_obj = __esm({
  "node_modules/ol/obj.js"() {
  }
});

// node_modules/ol/events/Event.js
var BaseEvent, Event_default;
var init_Event = __esm({
  "node_modules/ol/events/Event.js"() {
    BaseEvent = class {
      /**
       * @param {string} type Type.
       */
      constructor(type) {
        this.propagationStopped;
        this.defaultPrevented;
        this.type = type;
        this.target = null;
      }
      /**
       * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
       * will be fired.
       * @api
       */
      preventDefault() {
        this.defaultPrevented = true;
      }
      /**
       * Stop event propagation.
       * @api
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
    Event_default = BaseEvent;
  }
});

// node_modules/ol/events/Target.js
var Target, Target_default;
var init_Target = __esm({
  "node_modules/ol/events/Target.js"() {
    init_Disposable();
    init_functions();
    init_obj();
    init_Event();
    Target = class extends Disposable_default {
      /**
       * @param {*} [target] Default event target for dispatched events.
       */
      constructor(target) {
        super();
        this.eventTarget_ = target;
        this.pendingRemovals_ = null;
        this.dispatching_ = null;
        this.listeners_ = null;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      addEventListener(type, listener) {
        if (!type || !listener) {
          return;
        }
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) {
          listenersForType.push(listener);
        }
      }
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      dispatchEvent(event) {
        const isString = typeof event === "string";
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
          return;
        }
        const evt = isString ? new Event_default(event) : (
          /** @type {Event} */
          event
        );
        if (!evt.target) {
          evt.target = this.eventTarget_ || this;
        }
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
          dispatching[type] = 0;
          pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for (let i4 = 0, ii = listeners.length; i4 < ii; ++i4) {
          if ("handleEvent" in listeners[i4]) {
            propagate = /** @type {import("../events.js").ListenerObject} */
            listeners[i4].handleEvent(evt);
          } else {
            propagate = /** @type {import("../events.js").ListenerFunction} */
            listeners[i4].call(this, evt);
          }
          if (propagate === false || evt.propagationStopped) {
            propagate = false;
            break;
          }
        }
        if (--dispatching[type] === 0) {
          let pr2 = pendingRemovals[type];
          delete pendingRemovals[type];
          while (pr2--) {
            this.removeEventListener(type, VOID);
          }
          delete dispatching[type];
        }
        return propagate;
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        this.listeners_ && clear(this.listeners_);
      }
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      getListeners(type) {
        return this.listeners_ && this.listeners_[type] || void 0;
      }
      /**
       * @param {string} [type] Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      hasListener(type) {
        if (!this.listeners_) {
          return false;
        }
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      removeEventListener(type, listener) {
        if (!this.listeners_) {
          return;
        }
        const listeners = this.listeners_[type];
        if (!listeners) {
          return;
        }
        const index6 = listeners.indexOf(listener);
        if (index6 !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            listeners[index6] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index6, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    };
    Target_default = Target;
  }
});

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var uidCounter_;
var init_util = __esm({
  "node_modules/ol/util.js"() {
    uidCounter_ = 0;
  }
});

// node_modules/ol/Tile.js
var Tile, Tile_default;
var init_Tile = __esm({
  "node_modules/ol/Tile.js"() {
    init_TileState();
    init_easing();
    init_EventType();
    init_Target();
    init_util();
    Tile = class extends Target_default {
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("./TileState.js").default} state State.
       * @param {Options} [options] Tile options.
       */
      constructor(tileCoord, state, options) {
        super();
        options = options ? options : {};
        this.tileCoord = tileCoord;
        this.state = state;
        this.key = "";
        this.transition_ = options.transition === void 0 ? 250 : options.transition;
        this.transitionStarts_ = {};
        this.interpolate = !!options.interpolate;
      }
      /**
       * @protected
       */
      changed() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * Called by the tile cache when the tile is removed from the cache due to expiry
       */
      release() {
        this.setState(TileState_default.EMPTY);
      }
      /**
       * @return {string} Key.
       */
      getKey() {
        return this.key + "/" + this.tileCoord;
      }
      /**
       * Get the tile coordinate for this tile.
       * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
       * @api
       */
      getTileCoord() {
        return this.tileCoord;
      }
      /**
       * @return {import("./TileState.js").default} State.
       */
      getState() {
        return this.state;
      }
      /**
       * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
       * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
       * when the tile cannot be loaded. Otherwise the tile cannot be removed from
       * the tile queue and will block other requests.
       * @param {import("./TileState.js").default} state State.
       * @api
       */
      setState(state) {
        if (this.state === TileState_default.EMPTY) {
          return;
        }
        if (this.state !== TileState_default.ERROR && this.state > state) {
          throw new Error("Tile load sequence violation");
        }
        this.state = state;
        this.changed();
      }
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @abstract
       * @api
       */
      load() {
        abstract();
      }
      /**
       * Get the alpha value for rendering.
       * @param {string} id An id for the renderer.
       * @param {number} time The render frame time.
       * @return {number} A number between 0 and 1.
       */
      getAlpha(id, time) {
        if (!this.transition_) {
          return 1;
        }
        let start2 = this.transitionStarts_[id];
        if (!start2) {
          start2 = time;
          this.transitionStarts_[id] = start2;
        } else if (start2 === -1) {
          return 1;
        }
        const delta = time - start2 + 1e3 / 60;
        if (delta >= this.transition_) {
          return 1;
        }
        return easeIn(delta / this.transition_);
      }
      /**
       * Determine if a tile is in an alpha transition.  A tile is considered in
       * transition if tile.getAlpha() has not yet been called or has been called
       * and returned 1.
       * @param {string} id An id for the renderer.
       * @return {boolean} The tile is in transition.
       */
      inTransition(id) {
        if (!this.transition_) {
          return false;
        }
        return this.transitionStarts_[id] !== -1;
      }
      /**
       * Mark a transition as complete.
       * @param {string} id An id for the renderer.
       */
      endTransition(id) {
        if (this.transition_) {
          this.transitionStarts_[id] = -1;
        }
      }
      /**
       * @override
       */
      disposeInternal() {
        this.release();
        super.disposeInternal();
      }
    };
    Tile_default = Tile;
  }
});

// node_modules/ol/has.js
var ua, SAFARI, SAFARI_BUG_237906, WEBKIT, MAC, WORKER_OFFSCREEN_CANVAS, IMAGE_DECODE, PASSIVE_EVENT_LISTENERS;
var init_has = __esm({
  "node_modules/ol/has.js"() {
    ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
    SAFARI = ua.includes("safari") && !ua.includes("chrom");
    SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
    WEBKIT = ua.includes("webkit") && !ua.includes("edge");
    MAC = ua.includes("macintosh");
    WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
    IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
    PASSIVE_EVENT_LISTENERS = function() {
      let passive = false;
      try {
        const options = Object.defineProperty({}, "passive", {
          get: function() {
            passive = true;
          }
        });
        window.addEventListener("_", null, options);
        window.removeEventListener("_", null, options);
      } catch {
      }
      return passive;
    }();
  }
});

// node_modules/ol/dom.js
function createCanvasContext2D(width, height, canvasPool2, settings) {
  let canvas;
  if (canvasPool2 && canvasPool2.length) {
    canvas = /** @type {HTMLCanvasElement} */
    canvasPool2.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", settings)
  );
}
function getSharedCanvasContext2D() {
  if (!sharedCanvasContext) {
    sharedCanvasContext = createCanvasContext2D(1, 1);
  }
  return sharedCanvasContext;
}
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
var sharedCanvasContext;
var init_dom = __esm({
  "node_modules/ol/dom.js"() {
    init_has();
  }
});

// node_modules/ol/DataTile.js
function asImageLike(data) {
  return data instanceof Image || data instanceof HTMLCanvasElement || data instanceof HTMLVideoElement || data instanceof ImageBitmap ? data : null;
}
var disposedError, defaultSize, DataTile, DataTile_default;
var init_DataTile = __esm({
  "node_modules/ol/DataTile.js"() {
    init_Tile();
    init_TileState();
    disposedError = new Error("disposed");
    defaultSize = [256, 256];
    DataTile = class extends Tile_default {
      /**
       * @param {Options} options Tile options.
       */
      constructor(options) {
        const state = TileState_default.IDLE;
        super(options.tileCoord, state, {
          transition: options.transition,
          interpolate: options.interpolate
        });
        this.loader_ = options.loader;
        this.data_ = null;
        this.error_ = null;
        this.size_ = options.size || null;
        this.controller_ = options.controller || null;
      }
      /**
       * Get the tile size.
       * @return {import('./size.js').Size} Tile size.
       */
      getSize() {
        if (this.size_) {
          return this.size_;
        }
        const imageData = asImageLike(this.data_);
        if (imageData) {
          return [imageData.width, imageData.height];
        }
        return defaultSize;
      }
      /**
       * Get the data for the tile.
       * @return {Data} Tile data.
       * @api
       */
      getData() {
        return this.data_;
      }
      /**
       * Get any loading error.
       * @return {Error} Loading error.
       * @api
       */
      getError() {
        return this.error_;
      }
      /**
       * Load the tile data.
       * @api
       * @override
       */
      load() {
        if (this.state !== TileState_default.IDLE && this.state !== TileState_default.ERROR) {
          return;
        }
        this.state = TileState_default.LOADING;
        this.changed();
        const self2 = this;
        this.loader_().then(function(data) {
          self2.data_ = data;
          self2.state = TileState_default.LOADED;
          self2.changed();
        }).catch(function(error2) {
          self2.error_ = error2;
          self2.state = TileState_default.ERROR;
          self2.changed();
        });
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        if (this.controller_) {
          this.controller_.abort(disposedError);
          this.controller_ = null;
        }
        super.disposeInternal();
      }
    };
    DataTile_default = DataTile;
  }
});

// node_modules/ol/ImageState.js
var ImageState_default;
var init_ImageState = __esm({
  "node_modules/ol/ImageState.js"() {
    ImageState_default = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4
    };
  }
});

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (once) {
    const originalListener = listener;
    listener = function(event) {
      target.removeEventListener(type, listener);
      return originalListener.call(thisArg ?? this, event);
    };
  } else if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}
var init_events = __esm({
  "node_modules/ol/events.js"() {
    init_obj();
  }
});

// node_modules/ol/Image.js
function listenImage(image, loadHandler, errorHandler) {
  const img = (
    /** @type {HTMLImageElement} */
    image
  );
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType_default.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error2) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType_default.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error("Image load error"));
    }
    function unlisten() {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    }
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (src) {
      image.src = src;
    }
  });
}
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE ? new Promise(
    (resolve, reject) => image.decode().then(() => resolve(image)).catch(
      (e3) => image.complete && image.width ? resolve(image) : reject(e3)
    )
  ) : load(image);
}
var init_Image = __esm({
  "node_modules/ol/Image.js"() {
    init_EventType();
    init_events();
    init_has();
  }
});

// node_modules/ol/ImageTile.js
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var ImageTile, ImageTile_default;
var init_ImageTile = __esm({
  "node_modules/ol/ImageTile.js"() {
    init_Image();
    init_Tile();
    init_TileState();
    init_dom();
    ImageTile = class extends Tile_default {
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("./TileState.js").default} state State.
       * @param {string} src Image source URI.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
       * @param {import("./Tile.js").Options} [options] Tile options.
       */
      constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
        super(tileCoord, state, options);
        this.crossOrigin_ = crossOrigin;
        this.src_ = src;
        this.key = src;
        this.image_ = new Image();
        if (crossOrigin !== null) {
          this.image_.crossOrigin = crossOrigin;
        }
        this.unlisten_ = null;
        this.tileLoadFunction_ = tileLoadFunction;
      }
      /**
       * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @api
       */
      getImage() {
        return this.image_;
      }
      /**
       * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
       * @param {HTMLCanvasElement|HTMLImageElement} element Element.
       */
      setImage(element) {
        this.image_ = element;
        this.state = TileState_default.LOADED;
        this.unlistenImage_();
        this.changed();
      }
      /**
       * Tracks loading or read errors.
       *
       * @private
       */
      handleImageError_() {
        this.state = TileState_default.ERROR;
        this.unlistenImage_();
        this.image_ = getBlankImage();
        this.changed();
      }
      /**
       * Tracks successful image load.
       *
       * @private
       */
      handleImageLoad_() {
        const image = (
          /** @type {HTMLImageElement} */
          this.image_
        );
        if (image.naturalWidth && image.naturalHeight) {
          this.state = TileState_default.LOADED;
        } else {
          this.state = TileState_default.EMPTY;
        }
        this.unlistenImage_();
        this.changed();
      }
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       *
       * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
       * that checks for error status codes and reloads only when the status code is
       * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
       * made already:
       *
       * ```js
       * const retryCodes = [408, 429, 500, 502, 503, 504];
       * const retries = {};
       * source.setTileLoadFunction((tile, src) => {
       *   const image = tile.getImage();
       *   fetch(src)
       *     .then((response) => {
       *       if (retryCodes.includes(response.status)) {
       *         retries[src] = (retries[src] || 0) + 1;
       *         if (retries[src] <= 3) {
       *           setTimeout(() => tile.load(), retries[src] * 1000);
       *         }
       *         return Promise.reject();
       *       }
       *       return response.blob();
       *     })
       *     .then((blob) => {
       *       const imageUrl = URL.createObjectURL(blob);
       *       image.src = imageUrl;
       *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
       *     })
       *     .catch(() => tile.setState(3)); // error
       * });
       * ```
       * @api
       * @override
       */
      load() {
        if (this.state == TileState_default.ERROR) {
          this.state = TileState_default.IDLE;
          this.image_ = new Image();
          if (this.crossOrigin_ !== null) {
            this.image_.crossOrigin = this.crossOrigin_;
          }
        }
        if (this.state == TileState_default.IDLE) {
          this.state = TileState_default.LOADING;
          this.changed();
          this.tileLoadFunction_(this, this.src_);
          this.unlisten_ = listenImage(
            this.image_,
            this.handleImageLoad_.bind(this),
            this.handleImageError_.bind(this)
          );
        }
      }
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      unlistenImage_() {
        if (this.unlisten_) {
          this.unlisten_();
          this.unlisten_ = null;
        }
      }
      /**
       * @override
       */
      disposeInternal() {
        this.unlistenImage_();
        this.image_ = null;
        super.disposeInternal();
      }
    };
    ImageTile_default = ImageTile;
  }
});

// node_modules/ol/TileRange.js
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
var TileRange, TileRange_default;
var init_TileRange = __esm({
  "node_modules/ol/TileRange.js"() {
    TileRange = class {
      /**
       * @param {number} minX Minimum X.
       * @param {number} maxX Maximum X.
       * @param {number} minY Minimum Y.
       * @param {number} maxY Maximum Y.
       */
      constructor(minX, maxX, minY, maxY) {
        this.minX = minX;
        this.maxX = maxX;
        this.minY = minY;
        this.maxY = maxY;
      }
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {boolean} Contains tile coordinate.
       */
      contains(tileCoord) {
        return this.containsXY(tileCoord[1], tileCoord[2]);
      }
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Contains.
       */
      containsTileRange(tileRange) {
        return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
      }
      /**
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @return {boolean} Contains coordinate.
       */
      containsXY(x5, y4) {
        return this.minX <= x5 && x5 <= this.maxX && this.minY <= y4 && y4 <= this.maxY;
      }
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Equals.
       */
      equals(tileRange) {
        return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
      }
      /**
       * @param {TileRange} tileRange Tile range.
       */
      extend(tileRange) {
        if (tileRange.minX < this.minX) {
          this.minX = tileRange.minX;
        }
        if (tileRange.maxX > this.maxX) {
          this.maxX = tileRange.maxX;
        }
        if (tileRange.minY < this.minY) {
          this.minY = tileRange.minY;
        }
        if (tileRange.maxY > this.maxY) {
          this.maxY = tileRange.maxY;
        }
      }
      /**
       * @return {number} Height.
       */
      getHeight() {
        return this.maxY - this.minY + 1;
      }
      /**
       * @return {import("./size.js").Size} Size.
       */
      getSize() {
        return [this.getWidth(), this.getHeight()];
      }
      /**
       * @return {number} Width.
       */
      getWidth() {
        return this.maxX - this.minX + 1;
      }
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Intersects.
       */
      intersects(tileRange) {
        return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
      }
    };
    TileRange_default = TileRange;
  }
});

// node_modules/ol/extent/Relationship.js
var Relationship_default;
var init_Relationship = __esm({
  "node_modules/ol/extent/Relationship.js"() {
    Relationship_default = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16
    };
  }
});

// node_modules/ol/extent.js
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i4 = 0, ii = coordinates2.length; i4 < ii; ++i4) {
    extendCoordinate(extent, coordinates2[i4]);
  }
  return extent;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate2(minX, minY, maxX, maxY, dest);
}
function closestSquaredDistanceXY(extent, x5, y4) {
  let dx, dy;
  if (x5 < extent[0]) {
    dx = extent[0] - x5;
  } else if (extent[2] < x5) {
    dx = x5 - extent[2];
  } else {
    dx = 0;
  }
  if (y4 < extent[1]) {
    dy = extent[1] - y4;
  } else if (extent[3] < y4) {
    dy = y4 - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsXY(extent, x5, y4) {
  return extent[0] <= x5 && x5 <= extent[2] && extent[1] <= y4 && y4 <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x5 = coordinate[0];
  const y4 = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x5 < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x5 > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y4 < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y4 > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate2(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate2(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x5 = coordinate[0];
  const y4 = coordinate[1];
  return createOrUpdate2(x5, y4, x5, y4, dest);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function equals2(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function extend2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}
function extendXY(extent, x5, y4) {
  extent[0] = Math.min(extent[0], x5);
  extent[1] = Math.min(extent[1], y4);
  extent[2] = Math.max(extent[2], x5);
  extent[3] = Math.max(extent[3], y4);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent) {
  let area = 0;
  if (!isEmpty2(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getCorner(extent, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent);
  } else {
    throw new Error("Invalid corner");
  }
  return coordinate;
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x22, y22, x32, y32] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate2(
    Math.min(x0, x1, x22, x32),
    Math.min(y0, y1, y22, y32),
    Math.max(x0, x1, x22, x32),
    Math.max(y0, y1, y22, y32),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x5 = center[0];
  const y4 = center[1];
  return [
    x5 - xCos + ySin,
    y4 - xSin - yCos,
    x5 - xCos - ySin,
    y4 - xSin + yCos,
    x5 + xCos - ySin,
    y4 + xSin + yCos,
    x5 + xCos + ySin,
    y4 + xSin - yCos,
    x5 - xCos + ySin,
    y4 - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty2(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function intersectsSegment(extent, start2, end) {
  let intersects2 = false;
  const startRel = coordinateRelationship(extent, start2);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects2 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start2[0];
    const startY = start2[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x5, y4;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x5 = endX - (endY - maxY) / slope;
      intersects2 = x5 >= minX && x5 <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y4 = endY - (endX - maxX) * slope;
      intersects2 = y4 >= minY && y4 <= maxY;
    }
    if (!intersects2 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x5 = endX - (endY - minY) / slope;
      intersects2 = x5 >= minX && x5 <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y4 = endY - (endX - minX) * slope;
      intersects2 = y4 >= minY && y4 <= maxY;
    }
  }
  return intersects2;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty2(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i4 = 0; i4 < stops; ++i4) {
      coordinates2.push(
        extent[0] + width * i4 / stops,
        extent[1],
        extent[2],
        extent[1] + height * i4 / stops,
        extent[2] - width * i4 / stops,
        extent[3],
        extent[0],
        extent[3] - height * i4 / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i4 = 0, l5 = coordinates2.length; i4 < l5; i4 += 2) {
    xs.push(coordinates2[i4]);
    ys.push(coordinates2[i4 + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}
function wrapAndSliceX(extent, projection, multiWorld) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth && !multiWorld) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}
var init_extent = __esm({
  "node_modules/ol/extent.js"() {
    init_Relationship();
  }
});

// node_modules/ol/console.js
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}
var levels, level;
var init_console = __esm({
  "node_modules/ol/console.js"() {
    levels = {
      info: 1,
      warn: 2,
      error: 3,
      none: 4
    };
    level = levels.info;
  }
});

// node_modules/ol/math.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x5, y4, x1, y1, x22, y22) {
  const dx = x22 - x1;
  const dy = y22 - y1;
  if (dx !== 0 || dy !== 0) {
    const t3 = ((x5 - x1) * dx + (y4 - y1) * dy) / (dx * dx + dy * dy);
    if (t3 > 1) {
      x1 = x22;
      y1 = y22;
    } else if (t3 > 0) {
      x1 += dx * t3;
      y1 += dy * t3;
    }
  }
  return squaredDistance(x5, y4, x1, y1);
}
function squaredDistance(x1, y1, x22, y22) {
  const dx = x22 - x1;
  const dy = y22 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n3 = mat.length;
  for (let i4 = 0; i4 < n3; i4++) {
    let maxRow = i4;
    let maxEl = Math.abs(mat[i4][i4]);
    for (let r4 = i4 + 1; r4 < n3; r4++) {
      const absValue = Math.abs(mat[r4][i4]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r4;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i4];
    mat[i4] = tmp;
    for (let j3 = i4 + 1; j3 < n3; j3++) {
      const coef = -mat[j3][i4] / mat[i4][i4];
      for (let k2 = i4; k2 < n3 + 1; k2++) {
        if (i4 == k2) {
          mat[j3][k2] = 0;
        } else {
          mat[j3][k2] += coef * mat[i4][k2];
        }
      }
    }
  }
  const x5 = new Array(n3);
  for (let l5 = n3 - 1; l5 >= 0; l5--) {
    x5[l5] = mat[l5][n3] / mat[l5][l5];
    for (let m5 = l5 - 1; m5 >= 0; m5--) {
      mat[m5][n3] -= mat[m5][l5] * x5[l5];
    }
  }
  return x5;
}
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a4, b5) {
  const r4 = a4 % b5;
  return r4 * b5 < 0 ? r4 + b5 : r4;
}
function lerp(a4, b5, x5) {
  return a4 + x5 * (b5 - a4);
}
function toFixed(n3, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n3 * factor) / factor;
}
function floor(n3, decimals) {
  return Math.floor(toFixed(n3, decimals));
}
function ceil(n3, decimals) {
  return Math.ceil(toFixed(n3, decimals));
}
function wrap(n3, min, max) {
  if (n3 >= min && n3 < max) {
    return n3;
  }
  const range = max - min;
  return ((n3 - min) % range + range) % range + min;
}
var init_math = __esm({
  "node_modules/ol/math.js"() {
  }
});

// node_modules/ol/coordinate.js
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function equals3(coordinate1, coordinate2) {
  let equals4 = true;
  for (let i4 = coordinate1.length - 1; i4 >= 0; --i4) {
    if (coordinate1[i4] != coordinate2[i4]) {
      equals4 = false;
      break;
    }
  }
  return equals4;
}
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x5 = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y4 = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x5;
  coordinate[1] = y4;
  return coordinate;
}
var init_coordinate = __esm({
  "node_modules/ol/coordinate.js"() {
  }
});

// node_modules/ol/proj/Units.js
var METERS_PER_UNIT;
var init_Units = __esm({
  "node_modules/ol/proj/Units.js"() {
    METERS_PER_UNIT = {
      // use the radius of the Normal sphere
      "radians": 6370997 / (2 * Math.PI),
      "degrees": 2 * Math.PI * 6370997 / 360,
      "ft": 0.3048,
      "m": 1,
      "us-ft": 1200 / 3937
    };
  }
});

// node_modules/ol/proj/Projection.js
var Projection, Projection_default;
var init_Projection = __esm({
  "node_modules/ol/proj/Projection.js"() {
    init_Units();
    Projection = class {
      /**
       * @param {Options} options Projection options.
       */
      constructor(options) {
        this.code_ = options.code;
        this.units_ = /** @type {import("./Units.js").Units} */
        options.units;
        this.extent_ = options.extent !== void 0 ? options.extent : null;
        this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
        this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
        this.global_ = options.global !== void 0 ? options.global : false;
        this.canWrapX_ = !!(this.global_ && this.extent_);
        this.getPointResolutionFunc_ = options.getPointResolution;
        this.defaultTileGrid_ = null;
        this.metersPerUnit_ = options.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      canWrapX() {
        return this.canWrapX_;
      }
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      getCode() {
        return this.code_;
      }
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        return this.extent_;
      }
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").Units} Units.
       * @api
       */
      getUnits() {
        return this.units_;
      }
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      getMetersPerUnit() {
        return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
      }
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getWorldExtent() {
        return this.worldExtent_;
      }
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      getAxisOrientation() {
        return this.axisOrientation_;
      }
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      isGlobal() {
        return this.global_;
      }
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
      }
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      getDefaultTileGrid() {
        return this.defaultTileGrid_;
      }
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
      }
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
      }
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
      }
      /**
       * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
      }
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {GetPointResolution|undefined} The custom point
       * resolution function (if set).
       */
      getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
      }
    };
    Projection_default = Projection;
  }
});

// node_modules/ol/proj/epsg3857.js
function fromEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i4 = 0; i4 < length; i4 += stride) {
    output[i4] = HALF_SIZE * input[i4] / 180;
    let y4 = RADIUS * Math.log(Math.tan(Math.PI * (+input[i4 + 1] + 90) / 360));
    if (y4 > MAX_SAFE_Y) {
      y4 = MAX_SAFE_Y;
    } else if (y4 < -MAX_SAFE_Y) {
      y4 = -MAX_SAFE_Y;
    }
    output[i4 + 1] = y4;
  }
  return output;
}
function toEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i4 = 0; i4 < length; i4 += stride) {
    output[i4] = 180 * input[i4] / HALF_SIZE;
    output[i4 + 1] = 360 * Math.atan(Math.exp(input[i4 + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}
var RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, MAX_SAFE_Y, EPSG3857Projection, PROJECTIONS;
var init_epsg3857 = __esm({
  "node_modules/ol/proj/epsg3857.js"() {
    init_Projection();
    RADIUS = 6378137;
    HALF_SIZE = Math.PI * RADIUS;
    EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
    WORLD_EXTENT = [-180, -85, 180, 85];
    MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
    EPSG3857Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       */
      constructor(code) {
        super({
          code,
          units: "m",
          extent: EXTENT,
          global: true,
          worldExtent: WORLD_EXTENT,
          getPointResolution: function(resolution, point) {
            return resolution / Math.cosh(point[1] / RADIUS);
          }
        });
      }
    };
    PROJECTIONS = [
      new EPSG3857Projection("EPSG:3857"),
      new EPSG3857Projection("EPSG:102100"),
      new EPSG3857Projection("EPSG:102113"),
      new EPSG3857Projection("EPSG:900913"),
      new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
      new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
    ];
  }
});

// node_modules/ol/proj/epsg4326.js
var RADIUS2, EXTENT2, METERS_PER_UNIT2, EPSG4326Projection, PROJECTIONS2;
var init_epsg4326 = __esm({
  "node_modules/ol/proj/epsg4326.js"() {
    init_Projection();
    RADIUS2 = 6378137;
    EXTENT2 = [-180, -90, 180, 90];
    METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
    EPSG4326Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       * @param {string} [axisOrientation] Axis orientation.
       */
      constructor(code, axisOrientation) {
        super({
          code,
          units: "degrees",
          extent: EXTENT2,
          axisOrientation,
          global: true,
          metersPerUnit: METERS_PER_UNIT2,
          worldExtent: EXTENT2
        });
      }
    };
    PROJECTIONS2 = [
      new EPSG4326Projection("CRS:84"),
      new EPSG4326Projection("EPSG:4326", "neu"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
      new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
    ];
  }
});

// node_modules/ol/proj/projections.js
function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add2(code, projection) {
  cache[code] = projection;
}
var cache;
var init_projections = __esm({
  "node_modules/ol/proj/projections.js"() {
    cache = {};
  }
});

// node_modules/ol/proj/transforms.js
function add3(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get2(sourceCode, destinationCode) {
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    return transforms[sourceCode][destinationCode];
  }
  return null;
}
var transforms;
var init_transforms = __esm({
  "node_modules/ol/proj/transforms.js"() {
    transforms = {};
  }
});

// node_modules/ol/proj/utm.js
function toLonLat(easting, northing, zone) {
  const x5 = easting - 5e5;
  const y4 = zone.north ? northing : northing - 1e7;
  const m5 = y4 / K0;
  const mu = m5 / (R5 * M1);
  const pRad = mu + P22 * Math.sin(2 * mu) + P3 * Math.sin(4 * mu) + P4 * Math.sin(6 * mu) + P5 * Math.sin(8 * mu);
  const pSin = Math.sin(pRad);
  const pSin2 = pSin * pSin;
  const pCos = Math.cos(pRad);
  const pTan = pSin / pCos;
  const pTan2 = pTan * pTan;
  const pTan4 = pTan2 * pTan2;
  const epSin = 1 - E5 * pSin2;
  const epSinSqrt = Math.sqrt(1 - E5 * pSin2);
  const n3 = R5 / epSinSqrt;
  const r4 = (1 - E5) / epSin;
  const c6 = E_P2 * pCos ** 2;
  const c22 = c6 * c6;
  const d2 = x5 / (n3 * K0);
  const d22 = d2 * d2;
  const d3 = d22 * d2;
  const d4 = d3 * d2;
  const d5 = d4 * d2;
  const d6 = d5 * d2;
  const latitude = pRad - pTan / r4 * (d22 / 2 - d4 / 24 * (5 + 3 * pTan2 + 10 * c6 - 4 * c22 - 9 * E_P2)) + d6 / 720 * (61 + 90 * pTan2 + 298 * c6 + 45 * pTan4 - 252 * E_P2 - 3 * c22);
  let longitude = (d2 - d3 / 6 * (1 + 2 * pTan2 + c6) + d5 / 120 * (5 - 2 * c6 + 28 * pTan2 - 3 * c22 + 8 * E_P2 + 24 * pTan4)) / pCos;
  longitude = wrap(
    longitude + toRadians(zoneToCentralLongitude(zone.number)),
    -Math.PI,
    Math.PI
  );
  return [toDegrees(longitude), toDegrees(latitude)];
}
function fromLonLat(longitude, latitude, zone) {
  longitude = wrap(longitude, MIN_LONGITUDE, MAX_LONGITUDE);
  if (latitude < MIN_LATITUDE) {
    latitude = MIN_LATITUDE;
  } else if (latitude > MAX_LATITUDE) {
    latitude = MAX_LATITUDE;
  }
  const latRad = toRadians(latitude);
  const latSin = Math.sin(latRad);
  const latCos = Math.cos(latRad);
  const latTan = latSin / latCos;
  const latTan2 = latTan * latTan;
  const latTan4 = latTan2 * latTan2;
  const lonRad = toRadians(longitude);
  const centralLon = zoneToCentralLongitude(zone.number);
  const centralLonRad = toRadians(centralLon);
  const n3 = R5 / Math.sqrt(1 - E5 * latSin ** 2);
  const c6 = E_P2 * latCos ** 2;
  const a4 = latCos * wrap(lonRad - centralLonRad, -Math.PI, Math.PI);
  const a22 = a4 * a4;
  const a32 = a22 * a4;
  const a42 = a32 * a4;
  const a5 = a42 * a4;
  const a6 = a5 * a4;
  const m5 = R5 * (M1 * latRad - M22 * Math.sin(2 * latRad) + M32 * Math.sin(4 * latRad) - M4 * Math.sin(6 * latRad));
  const easting = K0 * n3 * (a4 + a32 / 6 * (1 - latTan2 + c6) + a5 / 120 * (5 - 18 * latTan2 + latTan4 + 72 * c6 - 58 * E_P2)) + 5e5;
  let northing = K0 * (m5 + n3 * latTan * (a22 / 2 + a42 / 24 * (5 - latTan2 + 9 * c6 + 4 * c6 ** 2) + a6 / 720 * (61 - 58 * latTan2 + latTan4 + 600 * c6 - 330 * E_P2)));
  if (!zone.north) {
    northing += 1e7;
  }
  return [easting, northing];
}
function zoneToCentralLongitude(zone) {
  return (zone - 1) * 6 - 180 + 3;
}
function zoneFromCode(code) {
  let epsgId = 0;
  for (const re2 of epsgRegExes) {
    const match2 = code.match(re2);
    if (match2) {
      epsgId = parseInt(match2[1]);
      break;
    }
  }
  if (!epsgId) {
    return null;
  }
  let number = 0;
  let north = false;
  if (epsgId > 32700 && epsgId < 32761) {
    number = epsgId - 32700;
  } else if (epsgId > 32600 && epsgId < 32661) {
    north = true;
    number = epsgId - 32600;
  }
  if (!number) {
    return null;
  }
  return { number, north };
}
function makeTransformFunction(transformer2, zone) {
  return function(input, output, dimension, stride) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    stride = stride ?? dimension;
    if (!output) {
      if (dimension > 2) {
        output = input.slice();
      } else {
        output = new Array(length);
      }
    }
    for (let i4 = 0; i4 < length; i4 += stride) {
      const x5 = input[i4];
      const y4 = input[i4 + 1];
      const coord = transformer2(x5, y4, zone);
      output[i4] = coord[0];
      output[i4 + 1] = coord[1];
    }
    return output;
  };
}
function makeProjection(code) {
  const zone = zoneFromCode(code);
  if (!zone) {
    return null;
  }
  return new Projection_default({ code, units: "m" });
}
function makeTransforms(projection) {
  const zone = zoneFromCode(projection.getCode());
  if (!zone) {
    return null;
  }
  return {
    forward: makeTransformFunction(fromLonLat, zone),
    inverse: makeTransformFunction(toLonLat, zone)
  };
}
var K0, E5, E22, E32, E_P2, SQRT_E, _E, _E2, _E3, _E4, _E5, M1, M22, M32, M4, P22, P3, P4, P5, R5, MIN_LATITUDE, MAX_LATITUDE, MIN_LONGITUDE, MAX_LONGITUDE, epsgRegExes;
var init_utm = __esm({
  "node_modules/ol/proj/utm.js"() {
    init_math();
    init_Projection();
    K0 = 0.9996;
    E5 = 669438e-8;
    E22 = E5 * E5;
    E32 = E22 * E5;
    E_P2 = E5 / (1 - E5);
    SQRT_E = Math.sqrt(1 - E5);
    _E = (1 - SQRT_E) / (1 + SQRT_E);
    _E2 = _E * _E;
    _E3 = _E2 * _E;
    _E4 = _E3 * _E;
    _E5 = _E4 * _E;
    M1 = 1 - E5 / 4 - 3 * E22 / 64 - 5 * E32 / 256;
    M22 = 3 * E5 / 8 + 3 * E22 / 32 + 45 * E32 / 1024;
    M32 = 15 * E22 / 256 + 45 * E32 / 1024;
    M4 = 35 * E32 / 3072;
    P22 = 3 / 2 * _E - 27 / 32 * _E3 + 269 / 512 * _E5;
    P3 = 21 / 16 * _E2 - 55 / 32 * _E4;
    P4 = 151 / 96 * _E3 - 417 / 128 * _E5;
    P5 = 1097 / 512 * _E4;
    R5 = 6378137;
    MIN_LATITUDE = -80;
    MAX_LATITUDE = 84;
    MIN_LONGITUDE = -180;
    MAX_LONGITUDE = 180;
    epsgRegExes = [
      /^EPSG:(\d+)$/,
      /^urn:ogc:def:crs:EPSG::(\d+)$/,
      /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
    ];
  }
});

// node_modules/ol/sphere.js
function getDistance(c1, c22, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c22[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c22[0] - c1[0]) / 2;
  const a4 = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a4), Math.sqrt(1 - a4));
}
var DEFAULT_RADIUS;
var init_sphere = __esm({
  "node_modules/ol/sphere.js"() {
    init_math();
    DEFAULT_RADIUS = 63710088e-1;
  }
});

// node_modules/ol/proj.js
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i4 = 0, ii = input.length; i4 < ii; ++i4) {
      output[i4] = input[i4];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function addProjection(projection) {
  add2(projection.getCode(), projection);
  add3(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get3(projectionLike) {
  if (!(typeof projectionLike === "string")) {
    return projectionLike;
  }
  const projection = get(projectionLike);
  if (projection) {
    return projection;
  }
  for (const makeProjection2 of projectionFactories) {
    const projection2 = makeProjection2(projectionLike);
    if (projection2) {
      return projection2;
    }
  }
  return null;
}
function getPointResolution(projection, resolution, point, units) {
  projection = get3(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units || units == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(
        projection,
        get3("EPSG:4326")
      );
      if (!toEPSG43262 && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        add3(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add3(projection1, projection2, forwardTransform);
      add3(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get3(defaultCode);
  }
  if (typeof projection === "string") {
    return get3(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimensions that should be transformed.
     * @param {number} [stride] Stride.
     * @return {Array<number>} Output.
     */
    function(input, output, dimension, stride) {
      const length = input.length;
      dimension = dimension !== void 0 ? dimension : 2;
      stride = stride ?? dimension;
      output = output !== void 0 ? output : new Array(length);
      for (let i4 = 0; i4 < length; i4 += stride) {
        const point = coordTransform(input.slice(i4, i4 + dimension));
        const pointLength = point.length;
        for (let j3 = 0, jj = stride; j3 < jj; ++j3) {
          output[i4 + j3] = j3 >= pointLength ? input[i4 + j3] : point[j3];
        }
      }
      return output;
    }
  );
}
function fromLonLat2(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    "EPSG:4326",
    projection !== void 0 ? projection : "EPSG:3857"
  );
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(source, destination) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  let transformFunc = get2(sourceCode, destinationCode);
  if (transformFunc) {
    return transformFunc;
  }
  let sourceTransforms = null;
  let destinationTransforms = null;
  for (const makeTransforms2 of transformFactories) {
    if (!sourceTransforms) {
      sourceTransforms = makeTransforms2(source);
    }
    if (!destinationTransforms) {
      destinationTransforms = makeTransforms2(destination);
    }
  }
  if (!sourceTransforms && !destinationTransforms) {
    return null;
  }
  const intermediateCode = "EPSG:4326";
  if (!destinationTransforms) {
    const toDestination = get2(intermediateCode, destinationCode);
    if (toDestination) {
      transformFunc = composeTransformFuncs(
        sourceTransforms.inverse,
        toDestination
      );
    }
  } else if (!sourceTransforms) {
    const fromSource = get2(sourceCode, intermediateCode);
    if (fromSource) {
      transformFunc = composeTransformFuncs(
        fromSource,
        destinationTransforms.forward
      );
    }
  } else {
    transformFunc = composeTransformFuncs(
      sourceTransforms.inverse,
      destinationTransforms.forward
    );
  }
  if (transformFunc) {
    addProjection(source);
    addProjection(destination);
    add3(source, destination, transformFunc);
  }
  return transformFunc;
}
function composeTransformFuncs(t1, t22) {
  return function(input, output, dimensions, stride) {
    output = t1(input, output, dimensions, stride);
    return t22(output, output, dimensions, stride);
  };
}
function getTransform(source, destination) {
  const sourceProjection = get3(source);
  const destinationProjection = get3(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  if (!transformFunc) {
    const sourceCode = get3(source).getCode();
    const destinationCode = get3(destination).getCode();
    throw new Error(
      `No transform available between ${sourceCode} and ${destinationCode}`
    );
  }
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return applyTransform(extent, transformFunc, void 0, stops);
}
function getUserProjection() {
  return userProjection;
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals3(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
var transformFactories, projectionFactories, showCoordinateWarning, userProjection;
var init_proj = __esm({
  "node_modules/ol/proj.js"() {
    init_console();
    init_coordinate();
    init_extent();
    init_Units();
    init_epsg3857();
    init_epsg4326();
    init_projections();
    init_transforms();
    init_utm();
    init_sphere();
    transformFactories = [makeTransforms];
    projectionFactories = [makeProjection];
    showCoordinateWarning = true;
    userProjection = null;
    addCommon();
  }
});

// node_modules/ol/reproj.js
function drawTestTriangle(ctx, u1, v1, u22, v22) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u22, v22);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u22) + 1, Math.max(v1, v22));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset) {
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    releaseCanvas(ctx);
    canvasPool.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(
    targetProj,
    targetResolution,
    targetCenter
  );
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle, clipExtent) {
  const context = createCanvasContext2D(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool
  );
  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i4, arr) {
    extend2(sourceDataExtent, src.extent);
  });
  let stitchContext;
  const stitchScale = pixelRatio / sourceResolution;
  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;
  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    stitchContext = createCanvasContext2D(
      Math.round(getWidth(sourceDataExtent) * stitchScale),
      Math.round(getHeight(sourceDataExtent) * stitchScale),
      canvasPool
    );
    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    if (sourceExtent && clipExtent) {
      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;
      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;
      const width2 = getWidth(sourceExtent) * stitchScale;
      const height2 = getHeight(sourceExtent) * stitchScale;
      stitchContext.rect(xPos, yPos, width2, height2);
      stitchContext.clip();
    }
    sources.forEach(function(src, i4, arr) {
      if (src.image.width > 0 && src.image.height > 0) {
        if (src.clipExtent) {
          stitchContext.save();
          const xPos2 = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;
          const yPos2 = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;
          const width2 = getWidth(src.clipExtent) * stitchScale;
          const height2 = getHeight(src.clipExtent) * stitchScale;
          stitchContext.rect(
            interpolate ? xPos2 : Math.round(xPos2),
            interpolate ? yPos2 : Math.round(yPos2),
            interpolate ? width2 : Math.round(xPos2 + width2) - Math.round(xPos2),
            interpolate ? height2 : Math.round(yPos2 + height2) - Math.round(yPos2)
          );
          stitchContext.clip();
        }
        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;
        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;
        const srcWidth = getWidth(src.extent) * stitchScale;
        const srcHeight = getHeight(src.extent) * stitchScale;
        stitchContext.drawImage(
          src.image,
          gutter,
          gutter,
          src.image.width - 2 * gutter,
          src.image.height - 2 * gutter,
          interpolate ? xPos : Math.round(xPos),
          interpolate ? yPos : Math.round(yPos),
          interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),
          interpolate ? srcHeight : Math.round(yPos + srcHeight) - Math.round(yPos)
        );
        if (src.clipExtent) {
          stitchContext.restore();
        }
      }
    });
  }
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i4, arr) {
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0], y0 = source[0][1];
    let x1 = source[1][0], y1 = source[1][1];
    let x22 = source[2][0], y22 = source[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u22 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v22 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x22 -= sourceNumericalShiftX;
    y22 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x22, y22, 0, 0, u22 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x22, y22, v22 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context.lineTo(
          u1 + pixelRound((step + 1) * ud / steps),
          v1 + pixelRound(step * vd / (steps - 1))
        );
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound((step + 1) * ud / steps),
            v1 + pixelRound((step + 1) * vd / (steps - 1))
          );
        }
      }
      context.lineTo(u22, v22);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u22, v22);
    }
    context.clip();
    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );
    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );
    let image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context.scale(inverseScale, -inverseScale);
    } else {
      const source2 = sources[0];
      const extent = source2.extent;
      image = source2.image;
      context.scale(
        getWidth(extent) / image.width,
        -getHeight(extent) / image.height
      );
    }
    context.drawImage(image, 0, 0);
    context.restore();
  });
  if (stitchContext) {
    releaseCanvas(stitchContext);
    canvasPool.push(stitchContext.canvas);
  }
  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i4, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u22 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v22 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u22, v22);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}
var brokenDiagonalRendering_, canvasPool;
var init_reproj = __esm({
  "node_modules/ol/reproj.js"() {
    init_dom();
    init_extent();
    init_math();
    init_proj();
    canvasPool = [];
  }
});

// node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
var init_asserts = __esm({
  "node_modules/ol/asserts.js"() {
  }
});

// node_modules/ol/transform.js
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function apply(transform3, coordinate) {
  const x5 = coordinate[0];
  const y4 = coordinate[1];
  coordinate[0] = transform3[0] * x5 + transform3[2] * y4 + transform3[4];
  coordinate[1] = transform3[1] * x5 + transform3[3] * y4 + transform3[5];
  return coordinate;
}
function compose(transform3, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform3[0] = sx * cos;
  transform3[1] = sy * sin;
  transform3[2] = -sx * sin;
  transform3[3] = sy * cos;
  transform3[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform3[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform3;
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, "Transformation matrix cannot be inverted");
  const a4 = source[0];
  const b5 = source[1];
  const c6 = source[2];
  const d2 = source[3];
  const e3 = source[4];
  const f5 = source[5];
  target[0] = d2 / det;
  target[1] = -b5 / det;
  target[2] = -c6 / det;
  target[3] = a4 / det;
  target[4] = (c6 * f5 - d2 * e3) / det;
  target[5] = -(a4 * f5 - b5 * e3) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
function toString(mat) {
  const transformString = "matrix(" + mat.join(", ") + ")";
  return transformString;
}
function fromString(cssTransform) {
  const values = cssTransform.substring(7, cssTransform.length - 1).split(",");
  return values.map(parseFloat);
}
function equivalent2(cssTransform1, cssTransform2) {
  const mat1 = fromString(cssTransform1);
  const mat2 = fromString(cssTransform2);
  for (let i4 = 0; i4 < 6; ++i4) {
    if (Math.round((mat1[i4] - mat2[i4]) * matrixPrecision[i4]) !== 0) {
      return false;
    }
  }
  return true;
}
var tmp_, matrixPrecision;
var init_transform = __esm({
  "node_modules/ol/transform.js"() {
    init_asserts();
    tmp_ = new Array(6);
    matrixPrecision = [1e5, 1e5, 1e5, 1e5, 2, 2];
  }
});

// node_modules/ol/reproj/Triangulation.js
var MAX_SUBDIVISION, MAX_TRIANGLE_WIDTH, Triangulation, Triangulation_default;
var init_Triangulation = __esm({
  "node_modules/ol/reproj/Triangulation.js"() {
    init_extent();
    init_math();
    init_proj();
    init_transform();
    MAX_SUBDIVISION = 10;
    MAX_TRIANGLE_WIDTH = 0.25;
    Triangulation = class {
      /**
       * @param {import("../proj/Projection.js").default} sourceProj Source projection.
       * @param {import("../proj/Projection.js").default} targetProj Target projection.
       * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
       * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
       * @param {number} errorThreshold Acceptable error (in source units).
       * @param {?number} destinationResolution The (optional) resolution of the destination.
       * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
       */
      constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution, sourceMatrix) {
        this.sourceProj_ = sourceProj;
        this.targetProj_ = targetProj;
        let transformInvCache = {};
        const transformInv = sourceMatrix ? createTransformFromCoordinateTransform(
          (input) => apply(
            sourceMatrix,
            transform(input, this.targetProj_, this.sourceProj_)
          )
        ) : getTransform(this.targetProj_, this.sourceProj_);
        this.transformInv_ = function(c6) {
          const key = c6[0] + "/" + c6[1];
          if (!transformInvCache[key]) {
            transformInvCache[key] = transformInv(c6);
          }
          return transformInvCache[key];
        };
        this.maxSourceExtent_ = maxSourceExtent;
        this.errorThresholdSquared_ = errorThreshold * errorThreshold;
        this.triangles_ = [];
        this.wrapsXInSource_ = false;
        this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());
        this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
        this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
        const destinationTopLeft = getTopLeft(targetExtent);
        const destinationTopRight = getTopRight(targetExtent);
        const destinationBottomRight = getBottomRight(targetExtent);
        const destinationBottomLeft = getBottomLeft(targetExtent);
        const sourceTopLeft = this.transformInv_(destinationTopLeft);
        const sourceTopRight = this.transformInv_(destinationTopRight);
        const sourceBottomRight = this.transformInv_(destinationBottomRight);
        const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
        const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(
          0,
          Math.ceil(
            Math.log2(
              getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)
            )
          )
        ) : 0);
        this.addQuad_(
          destinationTopLeft,
          destinationTopRight,
          destinationBottomRight,
          destinationBottomLeft,
          sourceTopLeft,
          sourceTopRight,
          sourceBottomRight,
          sourceBottomLeft,
          maxSubdivision
        );
        if (this.wrapsXInSource_) {
          let leftBound = Infinity;
          this.triangles_.forEach(function(triangle, i4, arr) {
            leftBound = Math.min(
              leftBound,
              triangle.source[0][0],
              triangle.source[1][0],
              triangle.source[2][0]
            );
          });
          this.triangles_.forEach((triangle) => {
            if (Math.max(
              triangle.source[0][0],
              triangle.source[1][0],
              triangle.source[2][0]
            ) - leftBound > this.sourceWorldWidth_ / 2) {
              const newTriangle = [
                [triangle.source[0][0], triangle.source[0][1]],
                [triangle.source[1][0], triangle.source[1][1]],
                [triangle.source[2][0], triangle.source[2][1]]
              ];
              if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
                newTriangle[0][0] -= this.sourceWorldWidth_;
              }
              if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
                newTriangle[1][0] -= this.sourceWorldWidth_;
              }
              if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
                newTriangle[2][0] -= this.sourceWorldWidth_;
              }
              const minX = Math.min(
                newTriangle[0][0],
                newTriangle[1][0],
                newTriangle[2][0]
              );
              const maxX = Math.max(
                newTriangle[0][0],
                newTriangle[1][0],
                newTriangle[2][0]
              );
              if (maxX - minX < this.sourceWorldWidth_ / 2) {
                triangle.source = newTriangle;
              }
            }
          });
        }
        transformInvCache = {};
      }
      /**
       * Adds triangle to the triangulation.
       * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
       * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
       * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
       * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
       * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
       * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
       * @private
       */
      addTriangle_(a4, b5, c6, aSrc, bSrc, cSrc) {
        this.triangles_.push({
          source: [aSrc, bSrc, cSrc],
          target: [a4, b5, c6]
        });
      }
      /**
       * Adds quad (points in clock-wise order) to the triangulation
       * (and reprojects the vertices) if valid.
       * Performs quad subdivision if needed to increase precision.
       *
       * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
       * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
       * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
       * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
       * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
       * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
       * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
       * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
       * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
       * @private
       */
      addQuad_(a4, b5, c6, d2, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
        const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
        const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
        const sourceWorldWidth = (
          /** @type {number} */
          this.sourceWorldWidth_
        );
        const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
        let needsSubdivision = false;
        if (maxSubdivision > 0) {
          if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
            const targetQuadExtent = boundingExtent([a4, b5, c6, d2]);
            const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
            needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
          }
          if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
            needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
          }
        }
        if (!needsSubdivision && this.maxSourceExtent_) {
          if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
            if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
              return;
            }
          }
        }
        let isNotFinite = 0;
        if (!needsSubdivision) {
          if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
            if (maxSubdivision > 0) {
              needsSubdivision = true;
            } else {
              isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
              if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
                return;
              }
            }
          }
        }
        if (maxSubdivision > 0) {
          if (!needsSubdivision) {
            const center = [(a4[0] + c6[0]) / 2, (a4[1] + c6[1]) / 2];
            const centerSrc = this.transformInv_(center);
            let dx;
            if (wrapsX) {
              const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
              dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
            } else {
              dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
            }
            const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
            const centerSrcErrorSquared = dx * dx + dy * dy;
            needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
          }
          if (needsSubdivision) {
            if (Math.abs(a4[0] - c6[0]) <= Math.abs(a4[1] - c6[1])) {
              const bc4 = [(b5[0] + c6[0]) / 2, (b5[1] + c6[1]) / 2];
              const bcSrc = this.transformInv_(bc4);
              const da2 = [(d2[0] + a4[0]) / 2, (d2[1] + a4[1]) / 2];
              const daSrc = this.transformInv_(da2);
              this.addQuad_(
                a4,
                b5,
                bc4,
                da2,
                aSrc,
                bSrc,
                bcSrc,
                daSrc,
                maxSubdivision - 1
              );
              this.addQuad_(
                da2,
                bc4,
                c6,
                d2,
                daSrc,
                bcSrc,
                cSrc,
                dSrc,
                maxSubdivision - 1
              );
            } else {
              const ab4 = [(a4[0] + b5[0]) / 2, (a4[1] + b5[1]) / 2];
              const abSrc = this.transformInv_(ab4);
              const cd2 = [(c6[0] + d2[0]) / 2, (c6[1] + d2[1]) / 2];
              const cdSrc = this.transformInv_(cd2);
              this.addQuad_(
                a4,
                ab4,
                cd2,
                d2,
                aSrc,
                abSrc,
                cdSrc,
                dSrc,
                maxSubdivision - 1
              );
              this.addQuad_(
                ab4,
                b5,
                c6,
                cd2,
                abSrc,
                bSrc,
                cSrc,
                cdSrc,
                maxSubdivision - 1
              );
            }
            return;
          }
        }
        if (wrapsX) {
          if (!this.canWrapXInSource_) {
            return;
          }
          this.wrapsXInSource_ = true;
        }
        if ((isNotFinite & 11) == 0) {
          this.addTriangle_(a4, c6, d2, aSrc, cSrc, dSrc);
        }
        if ((isNotFinite & 14) == 0) {
          this.addTriangle_(a4, c6, b5, aSrc, cSrc, bSrc);
        }
        if (isNotFinite) {
          if ((isNotFinite & 13) == 0) {
            this.addTriangle_(b5, d2, a4, bSrc, dSrc, aSrc);
          }
          if ((isNotFinite & 7) == 0) {
            this.addTriangle_(b5, d2, c6, bSrc, dSrc, cSrc);
          }
        }
      }
      /**
       * Calculates extent of the `source` coordinates from all the triangles.
       *
       * @return {import("../extent.js").Extent} Calculated extent.
       */
      calculateSourceExtent() {
        const extent = createEmpty();
        this.triangles_.forEach(function(triangle, i4, arr) {
          const src = triangle.source;
          extendCoordinate(extent, src[0]);
          extendCoordinate(extent, src[1]);
          extendCoordinate(extent, src[2]);
        });
        return extent;
      }
      /**
       * @return {Array<Triangle>} Array of the calculated triangles.
       */
      getTriangles() {
        return this.triangles_;
      }
    };
    Triangulation_default = Triangulation;
  }
});

// node_modules/ol/reproj/common.js
var ERROR_THRESHOLD;
var init_common = __esm({
  "node_modules/ol/reproj/common.js"() {
    ERROR_THRESHOLD = 0.5;
  }
});

// node_modules/ol/reproj/Tile.js
var ReprojTile, Tile_default2;
var init_Tile2 = __esm({
  "node_modules/ol/reproj/Tile.js"() {
    init_Tile();
    init_TileState();
    init_dom();
    init_EventType();
    init_events();
    init_extent();
    init_math();
    init_reproj();
    init_Triangulation();
    init_common();
    ReprojTile = class extends Tile_default {
      /**
       * @param {import("../proj/Projection.js").default} sourceProj Source projection.
       * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
       * @param {import("../proj/Projection.js").default} targetProj Target projection.
       * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
       * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
       * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} gutter Gutter of the source tiles.
       * @param {FunctionType} getTileFunction
       *     Function returning source tiles (z, x, y, pixelRatio).
       * @param {number} [errorThreshold] Acceptable reprojection error (in px).
       * @param {boolean} [renderEdges] Render reprojection edges.
       * @param {import("../Tile.js").Options} [options] Tile options.
       */
      constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {
        super(tileCoord, TileState_default.IDLE, options);
        this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
        this.pixelRatio_ = pixelRatio;
        this.gutter_ = gutter;
        this.canvas_ = null;
        this.sourceTileGrid_ = sourceTileGrid;
        this.targetTileGrid_ = targetTileGrid;
        this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
        this.sourceTiles_ = [];
        this.sourcesListenerKeys_ = null;
        this.sourceZ_ = 0;
        this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : void 0;
        const targetExtent = targetTileGrid.getTileCoordExtent(
          this.wrappedTileCoord_
        );
        const maxTargetExtent = this.targetTileGrid_.getExtent();
        let maxSourceExtent = this.sourceTileGrid_.getExtent();
        const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
        if (getArea(limitedTargetExtent) === 0) {
          this.state = TileState_default.EMPTY;
          return;
        }
        const sourceProjExtent = sourceProj.getExtent();
        if (sourceProjExtent) {
          if (!maxSourceExtent) {
            maxSourceExtent = sourceProjExtent;
          } else {
            maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
          }
        }
        const targetResolution = targetTileGrid.getResolution(
          this.wrappedTileCoord_[0]
        );
        const sourceResolution = calculateSourceExtentResolution(
          sourceProj,
          targetProj,
          limitedTargetExtent,
          targetResolution
        );
        if (!isFinite(sourceResolution) || sourceResolution <= 0) {
          this.state = TileState_default.EMPTY;
          return;
        }
        const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
        this.triangulation_ = new Triangulation_default(
          sourceProj,
          targetProj,
          limitedTargetExtent,
          maxSourceExtent,
          sourceResolution * errorThresholdInPixels,
          targetResolution
        );
        if (this.triangulation_.getTriangles().length === 0) {
          this.state = TileState_default.EMPTY;
          return;
        }
        this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
        let sourceExtent = this.triangulation_.calculateSourceExtent();
        if (maxSourceExtent) {
          if (sourceProj.canWrapX()) {
            sourceExtent[1] = clamp(
              sourceExtent[1],
              maxSourceExtent[1],
              maxSourceExtent[3]
            );
            sourceExtent[3] = clamp(
              sourceExtent[3],
              maxSourceExtent[1],
              maxSourceExtent[3]
            );
          } else {
            sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
          }
        }
        if (!getArea(sourceExtent)) {
          this.state = TileState_default.EMPTY;
        } else {
          let worldWidth = 0;
          let worldsAway = 0;
          if (sourceProj.canWrapX()) {
            worldWidth = getWidth(sourceProjExtent);
            worldsAway = Math.floor(
              (sourceExtent[0] - sourceProjExtent[0]) / worldWidth
            );
          }
          const sourceExtents = wrapAndSliceX(
            sourceExtent.slice(),
            sourceProj,
            true
          );
          sourceExtents.forEach((extent) => {
            const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
              extent,
              this.sourceZ_
            );
            for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
              for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
                const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
                if (tile) {
                  const offset = worldsAway * worldWidth;
                  this.sourceTiles_.push({ tile, offset });
                }
              }
            }
            ++worldsAway;
          });
          if (this.sourceTiles_.length === 0) {
            this.state = TileState_default.EMPTY;
          }
        }
      }
      /**
       * Get the HTML Canvas element for this tile.
       * @return {HTMLCanvasElement} Canvas.
       */
      getImage() {
        return this.canvas_;
      }
      /**
       * @private
       */
      reproject_() {
        const sources = [];
        this.sourceTiles_.forEach((source) => {
          const tile = source.tile;
          if (tile && tile.getState() == TileState_default.LOADED) {
            const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
            extent[0] += source.offset;
            extent[2] += source.offset;
            const clipExtent = this.clipExtent_?.slice();
            if (clipExtent) {
              clipExtent[0] += source.offset;
              clipExtent[2] += source.offset;
            }
            sources.push({
              extent,
              clipExtent,
              image: tile.getImage()
            });
          }
        });
        this.sourceTiles_.length = 0;
        if (sources.length === 0) {
          this.state = TileState_default.ERROR;
        } else {
          const z3 = this.wrappedTileCoord_[0];
          const size = this.targetTileGrid_.getTileSize(z3);
          const width = typeof size === "number" ? size : size[0];
          const height = typeof size === "number" ? size : size[1];
          const targetResolution = this.targetTileGrid_.getResolution(z3);
          const sourceResolution = this.sourceTileGrid_.getResolution(
            this.sourceZ_
          );
          const targetExtent = this.targetTileGrid_.getTileCoordExtent(
            this.wrappedTileCoord_
          );
          this.canvas_ = render(
            width,
            height,
            this.pixelRatio_,
            sourceResolution,
            this.sourceTileGrid_.getExtent(),
            targetResolution,
            targetExtent,
            this.triangulation_,
            sources,
            this.gutter_,
            this.renderEdges_,
            this.interpolate
          );
          this.state = TileState_default.LOADED;
        }
        this.changed();
      }
      /**
       * Load not yet loaded URI.
       * @override
       */
      load() {
        if (this.state == TileState_default.IDLE) {
          this.state = TileState_default.LOADING;
          this.changed();
          let leftToLoad = 0;
          this.sourcesListenerKeys_ = [];
          this.sourceTiles_.forEach(({ tile }) => {
            const state = tile.getState();
            if (state == TileState_default.IDLE || state == TileState_default.LOADING) {
              leftToLoad++;
              const sourceListenKey = listen(tile, EventType_default.CHANGE, (e3) => {
                const state2 = tile.getState();
                if (state2 == TileState_default.LOADED || state2 == TileState_default.ERROR || state2 == TileState_default.EMPTY) {
                  unlistenByKey(sourceListenKey);
                  leftToLoad--;
                  if (leftToLoad === 0) {
                    this.unlistenSources_();
                    this.reproject_();
                  }
                }
              });
              this.sourcesListenerKeys_.push(sourceListenKey);
            }
          });
          if (leftToLoad === 0) {
            setTimeout(this.reproject_.bind(this), 0);
          } else {
            this.sourceTiles_.forEach(function({ tile }, i4, arr) {
              const state = tile.getState();
              if (state == TileState_default.IDLE) {
                tile.load();
              }
            });
          }
        }
      }
      /**
       * @private
       */
      unlistenSources_() {
        this.sourcesListenerKeys_.forEach(unlistenByKey);
        this.sourcesListenerKeys_ = null;
      }
      /**
       * Remove from the cache due to expiry
       * @override
       */
      release() {
        if (this.canvas_) {
          releaseCanvas(this.canvas_.getContext("2d"));
          canvasPool.push(this.canvas_);
          this.canvas_ = null;
        }
        super.release();
      }
    };
    Tile_default2 = ReprojTile;
  }
});

// node_modules/ol/size.js
function scale(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}
var init_size = __esm({
  "node_modules/ol/size.js"() {
  }
});

// node_modules/ol/structs/LRUCache.js
var LRUCache, LRUCache_default;
var init_LRUCache = __esm({
  "node_modules/ol/structs/LRUCache.js"() {
    init_Disposable();
    init_asserts();
    LRUCache = class {
      /**
       * @param {number} [highWaterMark] High water mark.
       */
      constructor(highWaterMark) {
        this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
        this.count_ = 0;
        this.entries_ = {};
        this.oldest_ = null;
        this.newest_ = null;
      }
      deleteOldest() {
        const entry = this.pop();
        if (entry instanceof Disposable_default) {
          entry.dispose();
        }
      }
      /**
       * @return {boolean} Can expire cache.
       */
      canExpireCache() {
        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
      }
      /**
       * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
       * the entry will be disposed.
       * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
       */
      expireCache(keep) {
        while (this.canExpireCache()) {
          this.deleteOldest();
        }
      }
      /**
       * FIXME empty description for jsdoc
       */
      clear() {
        while (this.oldest_) {
          this.deleteOldest();
        }
      }
      /**
       * @param {string} key Key.
       * @return {boolean} Contains key.
       */
      containsKey(key) {
        return this.entries_.hasOwnProperty(key);
      }
      /**
       * @param {function(T, string, LRUCache<T>): ?} f The function
       *     to call for every entry from the oldest to the newer. This function takes
       *     3 arguments (the entry value, the entry key and the LRUCache object).
       *     The return value is ignored.
       */
      forEach(f5) {
        let entry = this.oldest_;
        while (entry) {
          f5(entry.value_, entry.key_, this);
          entry = entry.newer;
        }
      }
      /**
       * @param {string} key Key.
       * @param {*} [options] Options (reserved for subclasses).
       * @return {T} Value.
       */
      get(key, options) {
        const entry = this.entries_[key];
        assert(
          entry !== void 0,
          "Tried to get a value for a key that does not exist in the cache"
        );
        if (entry === this.newest_) {
          return entry.value_;
        }
        if (entry === this.oldest_) {
          this.oldest_ = /** @type {Entry} */
          this.oldest_.newer;
          this.oldest_.older = null;
        } else {
          entry.newer.older = entry.older;
          entry.older.newer = entry.newer;
        }
        entry.newer = null;
        entry.older = this.newest_;
        this.newest_.newer = entry;
        this.newest_ = entry;
        return entry.value_;
      }
      /**
       * Remove an entry from the cache.
       * @param {string} key The entry key.
       * @return {T} The removed entry.
       */
      remove(key) {
        const entry = this.entries_[key];
        assert(
          entry !== void 0,
          "Tried to get a value for a key that does not exist in the cache"
        );
        if (entry === this.newest_) {
          this.newest_ = /** @type {Entry} */
          entry.older;
          if (this.newest_) {
            this.newest_.newer = null;
          }
        } else if (entry === this.oldest_) {
          this.oldest_ = /** @type {Entry} */
          entry.newer;
          if (this.oldest_) {
            this.oldest_.older = null;
          }
        } else {
          entry.newer.older = entry.older;
          entry.older.newer = entry.newer;
        }
        delete this.entries_[key];
        --this.count_;
        return entry.value_;
      }
      /**
       * @return {number} Count.
       */
      getCount() {
        return this.count_;
      }
      /**
       * @return {Array<string>} Keys.
       */
      getKeys() {
        const keys = new Array(this.count_);
        let i4 = 0;
        let entry;
        for (entry = this.newest_; entry; entry = entry.older) {
          keys[i4++] = entry.key_;
        }
        return keys;
      }
      /**
       * @return {Array<T>} Values.
       */
      getValues() {
        const values = new Array(this.count_);
        let i4 = 0;
        let entry;
        for (entry = this.newest_; entry; entry = entry.older) {
          values[i4++] = entry.value_;
        }
        return values;
      }
      /**
       * @return {T} Last value.
       */
      peekLast() {
        return this.oldest_.value_;
      }
      /**
       * @return {string} Last key.
       */
      peekLastKey() {
        return this.oldest_.key_;
      }
      /**
       * Get the key of the newest item in the cache.  Throws if the cache is empty.
       * @return {string} The newest key.
       */
      peekFirstKey() {
        return this.newest_.key_;
      }
      /**
       * Return an entry without updating least recently used time.
       * @param {string} key Key.
       * @return {T|undefined} Value.
       */
      peek(key) {
        return this.entries_[key]?.value_;
      }
      /**
       * @return {T} value Value.
       */
      pop() {
        const entry = this.oldest_;
        delete this.entries_[entry.key_];
        if (entry.newer) {
          entry.newer.older = null;
        }
        this.oldest_ = /** @type {Entry} */
        entry.newer;
        if (!this.oldest_) {
          this.newest_ = null;
        }
        --this.count_;
        return entry.value_;
      }
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      replace(key, value) {
        this.get(key);
        this.entries_[key].value_ = value;
      }
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      set(key, value) {
        assert(
          !(key in this.entries_),
          "Tried to set a value for a key that is used already"
        );
        const entry = {
          key_: key,
          newer: null,
          older: this.newest_,
          value_: value
        };
        if (!this.newest_) {
          this.oldest_ = entry;
        } else {
          this.newest_.newer = entry;
        }
        this.newest_ = entry;
        this.entries_[key] = entry;
        ++this.count_;
      }
      /**
       * Set a maximum number of entries for the cache.
       * @param {number} size Cache size.
       * @api
       */
      setSize(size) {
        this.highWaterMark = size;
      }
    };
    LRUCache_default = LRUCache;
  }
});

// node_modules/ol/tilecoord.js
function createOrUpdate3(z3, x5, y4, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z3;
    tileCoord[1] = x5;
    tileCoord[2] = y4;
    return tileCoord;
  }
  return [z3, x5, y4];
}
function getKeyZXY(z3, x5, y4) {
  return z3 + "/" + x5 + "/" + y4;
}
function hash(tileCoord) {
  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function hashZXY(z3, x5, y4) {
  return (x5 << z3) + y4;
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z3 = tileCoord[0];
  const x5 = tileCoord[1];
  const y4 = tileCoord[2];
  if (tileGrid.getMinZoom() > z3 || z3 > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z3);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x5, y4);
}
var init_tilecoord = __esm({
  "node_modules/ol/tilecoord.js"() {
  }
});

// node_modules/ol/color.js
function getColorParseContext() {
  if (!colorParseContext) {
    colorParseContext = createCanvasContext2D(1, 1, void 0, {
      willReadFrequently: true,
      desynchronized: true
    });
  }
  return colorParseContext;
}
function toColorComponent(s6, divider) {
  return s6.endsWith("%") ? Number(s6.substring(0, s6.length - 1)) / divider : Number(s6);
}
function throwInvalidColor(color) {
  throw new Error('failed to parse "' + color + '" as color');
}
function parseRgba(color) {
  if (color.toLowerCase().startsWith("rgb")) {
    const rgb = color.match(rgbLegacyAbsoluteRegEx) || color.match(rgbModernRegEx) || color.match(rgbLegacyPercentageRegEx);
    if (rgb) {
      const alpha = rgb[4];
      const rgbDivider = 100 / 255;
      return [
        clamp(toColorComponent(rgb[1], rgbDivider) + 0.5 | 0, 0, 255),
        clamp(toColorComponent(rgb[2], rgbDivider) + 0.5 | 0, 0, 255),
        clamp(toColorComponent(rgb[3], rgbDivider) + 0.5 | 0, 0, 255),
        alpha !== void 0 ? clamp(toColorComponent(alpha, 100), 0, 1) : 1
      ];
    }
    throwInvalidColor(color);
  }
  if (color.startsWith("#")) {
    if (hexRegEx.test(color)) {
      const hex = color.substring(1);
      const step = hex.length <= 4 ? 1 : 2;
      const colorFromHex = [0, 0, 0, 255];
      for (let i4 = 0, ii = hex.length; i4 < ii; i4 += step) {
        let colorComponent = parseInt(hex.substring(i4, i4 + step), 16);
        if (step === 1) {
          colorComponent += colorComponent << 4;
        }
        colorFromHex[i4 / step] = colorComponent;
      }
      colorFromHex[3] = colorFromHex[3] / 255;
      return colorFromHex;
    }
    throwInvalidColor(color);
  }
  const context = getColorParseContext();
  context.fillStyle = "#abcdef";
  let invalidCheckFillStyle = context.fillStyle;
  context.fillStyle = color;
  if (context.fillStyle === invalidCheckFillStyle) {
    context.fillStyle = "#fedcba";
    invalidCheckFillStyle = context.fillStyle;
    context.fillStyle = color;
    if (context.fillStyle === invalidCheckFillStyle) {
      throwInvalidColor(color);
    }
  }
  const colorString = context.fillStyle;
  if (colorString.startsWith("#") || colorString.startsWith("rgba")) {
    return parseRgba(colorString);
  }
  context.clearRect(0, 0, 1, 1);
  context.fillRect(0, 0, 1, 1);
  const colorFromImage = Array.from(context.getImageData(0, 0, 1, 1).data);
  colorFromImage[3] = toFixed(colorFromImage[3] / 255, 3);
  return colorFromImage;
}
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString2(color);
}
function fromString2(s6) {
  if (s6 === "none") {
    return NO_COLOR;
  }
  if (cache2.hasOwnProperty(s6)) {
    return cache2[s6];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i4 = 0;
    for (const key in cache2) {
      if ((i4++ & 3) === 0) {
        delete cache2[key];
        --cacheSize;
      }
    }
  }
  const color = parseRgba(s6);
  if (color.length !== 4) {
    throwInvalidColor(s6);
  }
  for (const c6 of color) {
    if (isNaN(c6)) {
      throwInvalidColor(s6);
    }
  }
  cache2[s6] = color;
  ++cacheSize;
  return color;
}
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString2(color);
}
function toString2(color) {
  let r4 = color[0];
  if (r4 != (r4 | 0)) {
    r4 = r4 + 0.5 | 0;
  }
  let g3 = color[1];
  if (g3 != (g3 | 0)) {
    g3 = g3 + 0.5 | 0;
  }
  let b5 = color[2];
  if (b5 != (b5 | 0)) {
    b5 = b5 + 0.5 | 0;
  }
  const a4 = color[3] === void 0 ? 1 : Math.round(color[3] * 1e3) / 1e3;
  return "rgba(" + r4 + "," + g3 + "," + b5 + "," + a4 + ")";
}
var NO_COLOR, colorParseContext, rgbModernRegEx, rgbLegacyAbsoluteRegEx, rgbLegacyPercentageRegEx, hexRegEx, MAX_CACHE_SIZE, cache2, cacheSize;
var init_color = __esm({
  "node_modules/ol/color.js"() {
    init_dom();
    init_math();
    NO_COLOR = [NaN, NaN, NaN, 0];
    rgbModernRegEx = /^rgba?\(\s*(\d+%?)\s+(\d+%?)\s+(\d+%?)(?:\s*\/\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
    rgbLegacyAbsoluteRegEx = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
    rgbLegacyPercentageRegEx = /^rgba?\(\s*(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
    hexRegEx = /^#([\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;
    MAX_CACHE_SIZE = 1024;
    cache2 = {};
    cacheSize = 0;
  }
});

// node_modules/ol/render/Event.js
var RenderEvent, Event_default2;
var init_Event2 = __esm({
  "node_modules/ol/render/Event.js"() {
    init_Event();
    RenderEvent = class extends Event_default {
      /**
       * @param {import("./EventType.js").default} type Type.
       * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
       *     CSS pixels to rendered pixels.
       * @param {import("../Map.js").FrameState} [frameState] Frame state.
       * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
       */
      constructor(type, inversePixelTransform, frameState, context) {
        super(type);
        this.inversePixelTransform = inversePixelTransform;
        this.frameState = frameState;
        this.context = context;
      }
    };
    Event_default2 = RenderEvent;
  }
});

// node_modules/ol/render/EventType.js
var EventType_default2;
var init_EventType2 = __esm({
  "node_modules/ol/render/EventType.js"() {
    EventType_default2 = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: "prerender",
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered before layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: "precompose",
      /**
       * Triggered after layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: "postcompose",
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: "rendercomplete"
    };
  }
});

// node_modules/ol/render/canvas/ZIndexContext.js
var ZIndexContext, ZIndexContext_default;
var init_ZIndexContext = __esm({
  "node_modules/ol/render/canvas/ZIndexContext.js"() {
    init_dom();
    ZIndexContext = class {
      constructor() {
        this.instructions_ = [];
        this.zIndex = 0;
        this.offset_ = 0;
        this.context_ = /** @type {ZIndexContextProxy} */
        new Proxy(getSharedCanvasContext2D(), {
          get: (target, property) => {
            if (typeof /** @type {*} */
            getSharedCanvasContext2D()[property] !== "function") {
              return void 0;
            }
            this.push_(property);
            return this.pushMethodArgs_;
          },
          set: (target, property, value) => {
            this.push_(property, value);
            return true;
          }
        });
      }
      /**
       * @param {...*} args Arguments to push to the instructions array.
       * @private
       */
      push_(...args) {
        const instructions = this.instructions_;
        const index6 = this.zIndex + this.offset_;
        if (!instructions[index6]) {
          instructions[index6] = [];
        }
        instructions[index6].push(...args);
      }
      /**
       * @private
       * @param {...*} args Args.
       * @return {ZIndexContext} This.
       */
      pushMethodArgs_ = (...args) => {
        this.push_(args);
        return this;
      };
      /**
       * Push a function that renders to the context directly.
       * @param {function(CanvasRenderingContext2D): void} render Function.
       */
      pushFunction(render2) {
        this.push_(render2);
      }
      /**
       * Get a proxy for CanvasRenderingContext2D which does not support getting state
       * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
       * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
       * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
       * @return {ZIndexContextProxy} Context.
       */
      getContext() {
        return this.context_;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       */
      draw(context) {
        this.instructions_.forEach((instructionsAtIndex) => {
          for (let i4 = 0, ii = instructionsAtIndex.length; i4 < ii; ++i4) {
            const property = instructionsAtIndex[i4];
            if (typeof property === "function") {
              property(context);
              continue;
            }
            const instructionAtIndex = instructionsAtIndex[++i4];
            if (typeof /** @type {*} */
            context[property] === "function") {
              context[property](...instructionAtIndex);
            } else {
              if (typeof instructionAtIndex === "function") {
                context[property] = instructionAtIndex(context);
                continue;
              }
              context[property] = instructionAtIndex;
            }
          }
        });
      }
      clear() {
        this.instructions_.length = 0;
        this.zIndex = 0;
        this.offset_ = 0;
      }
      /**
       * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
       * avoid conflicting context.clip() or context.save()/restore() calls.
       */
      offset() {
        this.offset_ = this.instructions_.length;
        this.zIndex = 0;
      }
    };
    ZIndexContext_default = ZIndexContext;
  }
});

// node_modules/ol/Observable.js
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i4 = 0, ii = key.length; i4 < ii; ++i4) {
      unlistenByKey(key[i4]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
var Observable, Observable_default;
var init_Observable = __esm({
  "node_modules/ol/Observable.js"() {
    init_EventType();
    init_Target();
    init_events();
    Observable = class extends Target_default {
      constructor() {
        super();
        this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onInternal;
        this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onceInternal;
        this.un = /** @type {ObservableOnSignature<void>} */
        this.unInternal;
        this.revision_ = 0;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      changed() {
        ++this.revision_;
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      getRevision() {
        return this.revision_;
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onInternal(type, listener) {
        if (Array.isArray(type)) {
          const len = type.length;
          const keys = new Array(len);
          for (let i4 = 0; i4 < len; ++i4) {
            keys[i4] = listen(this, type[i4], listener);
          }
          return keys;
        }
        return listen(
          this,
          /** @type {string} */
          type,
          listener
        );
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
          const len = type.length;
          key = new Array(len);
          for (let i4 = 0; i4 < len; ++i4) {
            key[i4] = listenOnce(this, type[i4], listener);
          }
        } else {
          key = listenOnce(
            this,
            /** @type {string} */
            type,
            listener
          );
        }
        listener.ol_key = key;
        return key;
      }
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @protected
       */
      unInternal(type, listener) {
        const key = (
          /** @type {Object} */
          listener.ol_key
        );
        if (key) {
          unByKey(key);
        } else if (Array.isArray(type)) {
          for (let i4 = 0, ii = type.length; i4 < ii; ++i4) {
            this.removeEventListener(type[i4], listener);
          }
        } else {
          this.removeEventListener(type, listener);
        }
      }
    };
    Observable.prototype.on;
    Observable.prototype.once;
    Observable.prototype.un;
    Observable_default = Observable;
  }
});

// node_modules/ol/renderer/Layer.js
var maxStaleKeys, LayerRenderer, Layer_default;
var init_Layer = __esm({
  "node_modules/ol/renderer/Layer.js"() {
    init_ImageState();
    init_Observable();
    init_EventType();
    init_util();
    maxStaleKeys = 5;
    LayerRenderer = class extends Observable_default {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super();
        this.ready = true;
        this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        this.layer_ = layer;
        this.staleKeys_ = new Array();
        this.maxStaleKeys = maxStaleKeys;
      }
      /**
       * @return {Array<string>} Get the list of stale keys.
       */
      getStaleKeys() {
        return this.staleKeys_;
      }
      /**
       * @param {string} key The new stale key.
       */
      prependStaleKey(key) {
        this.staleKeys_.unshift(key);
        if (this.staleKeys_.length > this.maxStaleKeys) {
          this.staleKeys_.length = this.maxStaleKeys;
        }
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        return abstract();
      }
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        return null;
      }
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      prepareFrame(frameState) {
        return abstract();
      }
      /**
       * Render the layer.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      renderFrame(frameState, target) {
        return abstract();
      }
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return void 0;
      }
      /**
       * @return {LayerType} Layer.
       */
      getLayer() {
        return this.layer_;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */
      handleFontsChanged() {
      }
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */
      handleImageChange_(event) {
        const image = (
          /** @type {import("../Image.js").default} */
          event.target
        );
        if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
          this.renderIfReadyAndVisible();
        }
      }
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../Image.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      loadImage(image) {
        let imageState = image.getState();
        if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
          image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
        }
        if (imageState == ImageState_default.IDLE) {
          image.load();
          imageState = image.getState();
        }
        return imageState == ImageState_default.LOADED;
      }
      /**
       * @protected
       */
      renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
          layer.changed();
        }
      }
      /**
       * @param {import("../Map.js").FrameState} frameState Frame state.
       */
      renderDeferred(frameState) {
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
      }
    };
    Layer_default = LayerRenderer;
  }
});

// node_modules/ol/renderer/canvas/Layer.js
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
var pixelContext, CanvasLayerRenderer, Layer_default2;
var init_Layer2 = __esm({
  "node_modules/ol/renderer/canvas/Layer.js"() {
    init_array();
    init_color();
    init_dom();
    init_extent();
    init_Event2();
    init_EventType2();
    init_ZIndexContext();
    init_transform();
    init_Layer();
    pixelContext = null;
    CanvasLayerRenderer = class extends Layer_default {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super(layer);
        this.container = null;
        this.renderedResolution;
        this.tempTransform = create();
        this.pixelTransform = create();
        this.inversePixelTransform = create();
        this.context = null;
        this.deferredContext_ = null;
        this.containerReused = false;
        this.frameState = null;
      }
      /**
       * @param {import('../../DataTile.js').ImageLike} image Image.
       * @param {number} col The column index.
       * @param {number} row The row index.
       * @return {Uint8ClampedArray|null} The image data.
       */
      getImageData(image, col, row) {
        if (!pixelContext) {
          createPixelContext();
        }
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
          pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
          data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch {
          pixelContext = null;
          return null;
        }
        return data;
      }
      /**
       * @param {import('../../Map.js').FrameState} frameState Frame state.
       * @return {string} Background color.
       */
      getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === "function") {
          background = background(frameState.viewState.resolution);
        }
        return background || void 0;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS transform matrix.
       * @param {string} [backgroundColor] Background color.
       */
      useContainer(target, transform3, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(
          asArray(target.style.backgroundColor),
          asArray(backgroundColor)
        ))) {
          const canvas = target.firstElementChild;
          if (canvas instanceof HTMLCanvasElement) {
            context = canvas.getContext("2d");
          }
        }
        if (context && equivalent2(context.canvas.style.transform, transform3)) {
          this.container = target;
          this.context = context;
          this.containerReused = true;
        } else if (this.containerReused) {
          this.container = null;
          this.context = null;
          this.containerReused = false;
        } else if (this.container) {
          this.container.style.backgroundColor = null;
        }
        if (!this.container) {
          container = document.createElement("div");
          container.className = layerClassName;
          let style = container.style;
          style.position = "absolute";
          style.width = "100%";
          style.height = "100%";
          context = createCanvasContext2D();
          const canvas = context.canvas;
          container.appendChild(canvas);
          style = canvas.style;
          style.position = "absolute";
          style.left = "0";
          style.transformOrigin = "top left";
          this.container = container;
          this.context = context;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
          this.container.style.backgroundColor = backgroundColor;
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      clipUnrotated(context, frameState, extent) {
        const topLeft = getTopLeft(extent);
        const topRight = getTopRight(extent);
        const bottomRight = getBottomRight(extent);
        const bottomLeft = getBottomLeft(extent);
        apply(frameState.coordinateToPixelTransform, topLeft);
        apply(frameState.coordinateToPixelTransform, topRight);
        apply(frameState.coordinateToPixelTransform, bottomRight);
        apply(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        apply(inverted, topLeft);
        apply(inverted, topRight);
        apply(inverted, bottomRight);
        apply(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @protected
       */
      prepareContainer(frameState, target) {
        const extent = frameState.extent;
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const pixelRatio = frameState.pixelRatio;
        const width = Math.round(getWidth(extent) / resolution * pixelRatio);
        const height = Math.round(getHeight(extent) / resolution * pixelRatio);
        compose(
          this.pixelTransform,
          frameState.size[0] / 2,
          frameState.size[1] / 2,
          1 / pixelRatio,
          1 / pixelRatio,
          rotation,
          -width / 2,
          -height / 2
        );
        makeInverse(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = toString(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        if (!this.containerReused) {
          const canvas = this.context.canvas;
          if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
          } else {
            this.context.clearRect(0, 0, width, height);
          }
          if (canvasTransform !== canvas.style.transform) {
            canvas.style.transform = canvasTransform;
          }
        }
      }
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @private
       */
      dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
          const event = new Event_default2(
            type,
            this.inversePixelTransform,
            frameState,
            context
          );
          layer.dispatchEvent(event);
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      preRender(context, frameState) {
        this.frameState = frameState;
        if (frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(EventType_default2.PRERENDER, context, frameState);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      postRender(context, frameState) {
        if (frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context, frameState);
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      renderDeferredInternal(frameState) {
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
       */
      getRenderContext(frameState) {
        if (frameState.declutter && !this.deferredContext_) {
          this.deferredContext_ = new ZIndexContext_default();
        }
        return frameState.declutter ? this.deferredContext_.getContext() : this.context;
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @override
       */
      renderDeferred(frameState) {
        if (!frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(
          EventType_default2.PRERENDER,
          this.context,
          frameState
        );
        if (frameState.declutter && this.deferredContext_) {
          this.deferredContext_.draw(this.context);
          this.deferredContext_.clear();
        }
        this.renderDeferredInternal(frameState);
        this.dispatchRenderEvent_(
          EventType_default2.POSTRENDER,
          this.context,
          frameState
        );
      }
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */
      getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return compose(
          this.tempTransform,
          dx1,
          dy1,
          sx,
          sy,
          -rotation,
          dx2,
          dy2
        );
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
      }
    };
    Layer_default2 = CanvasLayerRenderer;
  }
});

// node_modules/ol/renderer/canvas/TileLayer.js
function getCacheKey(source, sourceKey, z3, x5, y4) {
  return `${getUid(source)},${sourceKey},${getKeyZXY(z3, x5, y4)}`;
}
function addTileToLookup(tilesByZ, tile, z3) {
  if (!(z3 in tilesByZ)) {
    tilesByZ[z3] = /* @__PURE__ */ new Set([tile]);
    return true;
  }
  const set = tilesByZ[z3];
  const existing = set.has(tile);
  if (!existing) {
    set.add(tile);
  }
  return !existing;
}
function removeTileFromLookup(tilesByZ, tile, z3) {
  const set = tilesByZ[z3];
  if (set) {
    return set.delete(tile);
  }
  return false;
}
function getRenderExtent(frameState, extent) {
  const layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent = getIntersection(
      extent,
      fromUserExtent(layerState.extent, frameState.viewState.projection)
    );
  }
  const source = (
    /** @type {import("../../source/Tile.js").default} */
    layerState.layer.getRenderSource()
  );
  if (!source.getWrapX()) {
    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent = getIntersection(extent, gridExtent);
    }
  }
  return extent;
}
var CanvasTileLayerRenderer, TileLayer_default;
var init_TileLayer = __esm({
  "node_modules/ol/renderer/canvas/TileLayer.js"() {
    init_DataTile();
    init_ImageTile();
    init_TileRange();
    init_TileState();
    init_array();
    init_extent();
    init_proj();
    init_Tile2();
    init_size();
    init_LRUCache();
    init_tilecoord();
    init_transform();
    init_util();
    init_Layer2();
    CanvasTileLayerRenderer = class extends Layer_default2 {
      /**
       * @param {LayerType} tileLayer Tile layer.
       * @param {Options} [options] Options.
       */
      constructor(tileLayer, options) {
        super(tileLayer);
        options = options || {};
        this.extentChanged = true;
        this.renderComplete = false;
        this.renderedExtent_ = null;
        this.renderedPixelRatio;
        this.renderedProjection = null;
        this.renderedTiles = [];
        this.renderedSourceKey_;
        this.renderedSourceRevision_;
        this.tempExtent = createEmpty();
        this.tempTileRange_ = new TileRange_default(0, 0, 0, 0);
        this.tempTileCoord_ = createOrUpdate3(0, 0, 0);
        const cacheSize2 = options.cacheSize !== void 0 ? options.cacheSize : 512;
        this.tileCache_ = new LRUCache_default(cacheSize2);
        this.maxStaleKeys = cacheSize2 * 0.5;
      }
      /**
       * @return {LRUCache} Tile cache.
       */
      getTileCache() {
        return this.tileCache_;
      }
      /**
       * Get a tile from the cache or create one if needed.
       *
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
       * @protected
       */
      getOrCreateTile(z3, x5, y4, frameState) {
        const tileCache = this.tileCache_;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getSource();
        const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z3, x5, y4);
        let tile;
        if (tileCache.containsKey(cacheKey)) {
          tile = tileCache.get(cacheKey);
        } else {
          tile = tileSource.getTile(
            z3,
            x5,
            y4,
            frameState.pixelRatio,
            frameState.viewState.projection
          );
          if (!tile) {
            return null;
          }
          tileCache.set(cacheKey, tile);
        }
        return tile;
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
       * @protected
       */
      getTile(z3, x5, y4, frameState) {
        const tile = this.getOrCreateTile(z3, x5, y4, frameState);
        if (!tile) {
          return null;
        }
        return tile;
      }
      /**
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray} Data at the pixel location.
       * @override
       */
      getData(pixel) {
        const frameState = this.frameState;
        if (!frameState) {
          return null;
        }
        const layer = this.getLayer();
        const coordinate = apply(
          frameState.pixelToCoordinateTransform,
          pixel.slice()
        );
        const layerExtent = layer.getExtent();
        if (layerExtent) {
          if (!containsCoordinate(layerExtent, coordinate)) {
            return null;
          }
        }
        const viewState = frameState.viewState;
        const source = layer.getRenderSource();
        const tileGrid = source.getTileGridForProjection(viewState.projection);
        const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
        for (let z3 = tileGrid.getZForResolution(viewState.resolution); z3 >= tileGrid.getMinZoom(); --z3) {
          const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z3);
          const tile = this.getTile(z3, tileCoord[1], tileCoord[2], frameState);
          if (!tile || tile.getState() !== TileState_default.LOADED) {
            continue;
          }
          const tileOrigin = tileGrid.getOrigin(z3);
          const tileSize = toSize(tileGrid.getTileSize(z3));
          const tileResolution = tileGrid.getResolution(z3);
          let image;
          if (tile instanceof ImageTile_default || tile instanceof Tile_default2) {
            image = tile.getImage();
          } else if (tile instanceof DataTile_default) {
            image = asImageLike(tile.getData());
            if (!image) {
              continue;
            }
          } else {
            continue;
          }
          const col = Math.floor(
            tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0])
          );
          const row = Math.floor(
            tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1])
          );
          const gutter = Math.round(
            tilePixelRatio * source.getGutterForProjection(viewState.projection)
          );
          return this.getImageData(image, col + gutter, row + gutter);
        }
        return null;
      }
      /**
       * Determine whether render should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       * @override
       */
      prepareFrame(frameState) {
        if (!this.renderedProjection) {
          this.renderedProjection = frameState.viewState.projection;
        } else if (frameState.viewState.projection !== this.renderedProjection) {
          this.tileCache_.clear();
          this.renderedProjection = frameState.viewState.projection;
        }
        const source = this.getLayer().getSource();
        if (!source) {
          return false;
        }
        const sourceRevision = source.getRevision();
        if (!this.renderedSourceRevision_) {
          this.renderedSourceRevision_ = sourceRevision;
        } else if (this.renderedSourceRevision_ !== sourceRevision) {
          this.renderedSourceRevision_ = sourceRevision;
          if (this.renderedSourceKey_ === source.getKey()) {
            this.tileCache_.clear();
          }
        }
        return true;
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent The extent to be rendered.
       * @param {number} initialZ The zoom level.
       * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
       * @param {number} preload Number of additional levels to load.
       */
      enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {
        const viewState = frameState.viewState;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getRenderSource();
        const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
        const tileSourceKey = getUid(tileSource);
        if (!(tileSourceKey in frameState.wantedTiles)) {
          frameState.wantedTiles[tileSourceKey] = {};
        }
        const wantedTiles = frameState.wantedTiles[tileSourceKey];
        const map = tileLayer.getMapInternal();
        const minZ = Math.max(
          initialZ - preload,
          tileGrid.getMinZoom(),
          tileGrid.getZForResolution(
            Math.min(
              tileLayer.getMaxResolution(),
              map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)
            ),
            tileSource.zDirection
          )
        );
        const rotation = viewState.rotation;
        const viewport = rotation ? getRotatedViewport(
          viewState.center,
          viewState.resolution,
          rotation,
          frameState.size
        ) : void 0;
        for (let z3 = initialZ; z3 >= minZ; --z3) {
          const tileRange = tileGrid.getTileRangeForExtentAndZ(
            extent,
            z3,
            this.tempTileRange_
          );
          const tileResolution = tileGrid.getResolution(z3);
          for (let x5 = tileRange.minX; x5 <= tileRange.maxX; ++x5) {
            for (let y4 = tileRange.minY; y4 <= tileRange.maxY; ++y4) {
              if (rotation && !tileGrid.tileCoordIntersectsViewport([z3, x5, y4], viewport)) {
                continue;
              }
              const tile = this.getTile(z3, x5, y4, frameState);
              if (!tile) {
                continue;
              }
              const added = addTileToLookup(tilesByZ, tile, z3);
              if (!added) {
                continue;
              }
              const tileQueueKey = tile.getKey();
              wantedTiles[tileQueueKey] = true;
              if (tile.getState() === TileState_default.IDLE) {
                if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
                  const tileCoord = createOrUpdate3(z3, x5, y4, this.tempTileCoord_);
                  frameState.tileQueue.enqueue([
                    tile,
                    tileSourceKey,
                    tileGrid.getTileCoordCenter(tileCoord),
                    tileResolution
                  ]);
                }
              }
            }
          }
        }
      }
      /**
       * Look for tiles covering the provided tile coordinate at an alternate
       * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
       * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
       * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
       * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
       * @private
       */
      findStaleTile_(tileCoord, tilesByZ) {
        const tileCache = this.tileCache_;
        const z3 = tileCoord[0];
        const x5 = tileCoord[1];
        const y4 = tileCoord[2];
        const staleKeys = this.getStaleKeys();
        for (let i4 = 0; i4 < staleKeys.length; ++i4) {
          const cacheKey = getCacheKey(
            this.getLayer().getSource(),
            staleKeys[i4],
            z3,
            x5,
            y4
          );
          if (tileCache.containsKey(cacheKey)) {
            const tile = tileCache.peek(cacheKey);
            if (tile.getState() === TileState_default.LOADED) {
              tile.endTransition(getUid(this));
              addTileToLookup(tilesByZ, tile, z3);
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Look for tiles covering the provided tile coordinate at an alternate
       * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
       * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
       * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
       * @param {number} altZ The alternate zoom level.
       * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
       * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
       * @private
       */
      findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {
        const tileRange = tileGrid.getTileRangeForTileCoordAndZ(
          tileCoord,
          altZ,
          this.tempTileRange_
        );
        if (!tileRange) {
          return false;
        }
        let covered = true;
        const tileCache = this.tileCache_;
        const source = this.getLayer().getRenderSource();
        const sourceKey = source.getKey();
        for (let x5 = tileRange.minX; x5 <= tileRange.maxX; ++x5) {
          for (let y4 = tileRange.minY; y4 <= tileRange.maxY; ++y4) {
            const cacheKey = getCacheKey(source, sourceKey, altZ, x5, y4);
            let loaded = false;
            if (tileCache.containsKey(cacheKey)) {
              const tile = tileCache.peek(cacheKey);
              if (tile.getState() === TileState_default.LOADED) {
                addTileToLookup(tilesByZ, tile, altZ);
                loaded = true;
              }
            }
            if (!loaded) {
              covered = false;
            }
          }
        }
        return covered;
      }
      /**
       * Render the layer.
       *
       * The frame rendering logic has three parts:
       *
       *  1. Enqueue tiles
       *  2. Find alt tiles for those that are not yet loaded
       *  3. Render loaded tiles
       *
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       * @override
       */
      renderFrame(frameState, target) {
        this.renderComplete = true;
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const viewResolution = viewState.resolution;
        const viewCenter = viewState.center;
        const pixelRatio = frameState.pixelRatio;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getSource();
        const tileGrid = tileSource.getTileGridForProjection(projection);
        const z3 = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
        const tileResolution = tileGrid.getResolution(z3);
        const sourceKey = tileSource.getKey();
        if (!this.renderedSourceKey_) {
          this.renderedSourceKey_ = sourceKey;
        } else if (this.renderedSourceKey_ !== sourceKey) {
          this.prependStaleKey(this.renderedSourceKey_);
          this.renderedSourceKey_ = sourceKey;
        }
        let frameExtent = frameState.extent;
        const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
        this.prepareContainer(frameState, target);
        const width = this.context.canvas.width;
        const height = this.context.canvas.height;
        const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
        if (layerExtent) {
          frameExtent = getIntersection(
            frameExtent,
            fromUserExtent(layerState.extent, projection)
          );
        }
        const dx = tileResolution * width / 2 / tilePixelRatio;
        const dy = tileResolution * height / 2 / tilePixelRatio;
        const canvasExtent = [
          viewCenter[0] - dx,
          viewCenter[1] - dy,
          viewCenter[0] + dx,
          viewCenter[1] + dy
        ];
        const tilesByZ = {};
        this.renderedTiles.length = 0;
        const preload = tileLayer.getPreload();
        if (frameState.nextExtent) {
          const targetZ = tileGrid.getZForResolution(
            viewState.nextResolution,
            tileSource.zDirection
          );
          const nextExtent = getRenderExtent(frameState, frameState.nextExtent);
          this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);
        }
        const renderExtent = getRenderExtent(frameState, frameExtent);
        this.enqueueTiles(frameState, renderExtent, z3, tilesByZ, 0);
        if (preload > 0) {
          setTimeout(() => {
            this.enqueueTiles(
              frameState,
              renderExtent,
              z3 - 1,
              tilesByZ,
              preload - 1
            );
          }, 0);
        }
        if (!(z3 in tilesByZ)) {
          return this.container;
        }
        const uid = getUid(this);
        const time = frameState.time;
        for (const tile of tilesByZ[z3]) {
          const tileState = tile.getState();
          if (tileState === TileState_default.EMPTY) {
            continue;
          }
          const tileCoord = tile.tileCoord;
          if (tileState === TileState_default.LOADED) {
            const alpha = tile.getAlpha(uid, time);
            if (alpha === 1) {
              tile.endTransition(uid);
              continue;
            }
          }
          if (tileState !== TileState_default.ERROR) {
            this.renderComplete = false;
          }
          const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);
          if (hasStaleTile) {
            removeTileFromLookup(tilesByZ, tile, z3);
            frameState.animate = true;
            continue;
          }
          const coveredByChildren = this.findAltTiles_(
            tileGrid,
            tileCoord,
            z3 + 1,
            tilesByZ
          );
          if (coveredByChildren) {
            continue;
          }
          const minZoom = tileGrid.getMinZoom();
          for (let parentZ = z3 - 1; parentZ >= minZoom; --parentZ) {
            const coveredByParent = this.findAltTiles_(
              tileGrid,
              tileCoord,
              parentZ,
              tilesByZ
            );
            if (coveredByParent) {
              break;
            }
          }
        }
        const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
        const context = this.getRenderContext(frameState);
        compose(
          this.tempTransform,
          width / 2,
          height / 2,
          canvasScale,
          canvasScale,
          0,
          -width / 2,
          -height / 2
        );
        if (layerState.extent) {
          this.clipUnrotated(context, frameState, layerExtent);
        }
        if (!tileSource.getInterpolate()) {
          context.imageSmoothingEnabled = false;
        }
        this.preRender(context, frameState);
        const zs = Object.keys(tilesByZ).map(Number);
        zs.sort(ascending);
        let currentClip;
        const clips = [];
        const clipZs = [];
        for (let i4 = zs.length - 1; i4 >= 0; --i4) {
          const currentZ = zs[i4];
          const currentTilePixelSize = tileSource.getTilePixelSize(
            currentZ,
            pixelRatio,
            projection
          );
          const currentResolution = tileGrid.getResolution(currentZ);
          const currentScale = currentResolution / tileResolution;
          const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
          const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
          const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
            getTopLeft(canvasExtent),
            currentZ
          );
          const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
          const origin = apply(this.tempTransform, [
            tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
            tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
          ]);
          const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
          for (const tile of tilesByZ[currentZ]) {
            if (tile.getState() !== TileState_default.LOADED) {
              continue;
            }
            const tileCoord = tile.tileCoord;
            const xIndex = originTileCoord[1] - tileCoord[1];
            const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
            const yIndex = originTileCoord[2] - tileCoord[2];
            const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
            const x5 = Math.round(origin[0] - xIndex * dx2);
            const y4 = Math.round(origin[1] - yIndex * dy2);
            const w3 = nextX - x5;
            const h3 = nextY - y4;
            const transition = zs.length === 1;
            let contextSaved = false;
            currentClip = [x5, y4, x5 + w3, y4, x5 + w3, y4 + h3, x5, y4 + h3];
            for (let i5 = 0, ii = clips.length; i5 < ii; ++i5) {
              if (!transition && currentZ < clipZs[i5]) {
                const clip = clips[i5];
                if (intersects(
                  [x5, y4, x5 + w3, y4 + h3],
                  [clip[0], clip[3], clip[4], clip[7]]
                )) {
                  if (!contextSaved) {
                    context.save();
                    contextSaved = true;
                  }
                  context.beginPath();
                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]);
                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
            this.drawTile(tile, frameState, x5, y4, w3, h3, tileGutter, transition);
            if (contextSaved) {
              context.restore();
            }
            this.renderedTiles.unshift(tile);
            this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
          }
        }
        this.renderedResolution = tileResolution;
        this.extentChanged = !this.renderedExtent_ || !equals2(this.renderedExtent_, canvasExtent);
        this.renderedExtent_ = canvasExtent;
        this.renderedPixelRatio = pixelRatio;
        this.postRender(this.context, frameState);
        if (layerState.extent) {
          context.restore();
        }
        context.imageSmoothingEnabled = true;
        if (this.renderComplete) {
          const postRenderFunction = (map, frameState2) => {
            const tileSourceKey = getUid(tileSource);
            const wantedTiles = frameState2.wantedTiles[tileSourceKey];
            const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;
            this.updateCacheSize(tilesCount);
            this.tileCache_.expireCache();
          };
          frameState.postRenderFunctions.push(postRenderFunction);
        }
        return this.container;
      }
      /**
       * Increases the cache size if needed
       * @param {number} tileCount Minimum number of tiles needed.
       */
      updateCacheSize(tileCount) {
        this.tileCache_.highWaterMark = Math.max(
          this.tileCache_.highWaterMark,
          tileCount * 2
        );
      }
      /**
       * @param {import("../../Tile.js").default} tile Tile.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {number} x Left of the tile.
       * @param {number} y Top of the tile.
       * @param {number} w Width of the tile.
       * @param {number} h Height of the tile.
       * @param {number} gutter Tile gutter.
       * @param {boolean} transition Apply an alpha transition.
       * @protected
       */
      drawTile(tile, frameState, x5, y4, w3, h3, gutter, transition) {
        let image;
        if (tile instanceof DataTile_default) {
          image = asImageLike(tile.getData());
          if (!image) {
            throw new Error("Rendering array data is not yet supported");
          }
        } else {
          image = this.getTileImage(
            /** @type {import("../../ImageTile.js").default} */
            tile
          );
        }
        if (!image) {
          return;
        }
        const context = this.getRenderContext(frameState);
        const uid = getUid(this);
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
        const alphaChanged = alpha !== context.globalAlpha;
        if (alphaChanged) {
          context.save();
          context.globalAlpha = alpha;
        }
        context.drawImage(
          image,
          gutter,
          gutter,
          image.width - 2 * gutter,
          image.height - 2 * gutter,
          x5,
          y4,
          w3,
          h3
        );
        if (alphaChanged) {
          context.restore();
        }
        if (alpha !== layerState.opacity) {
          frameState.animate = true;
        } else if (transition) {
          tile.endTransition(uid);
        }
      }
      /**
       * @return {HTMLCanvasElement} Image
       */
      getImage() {
        const context = this.context;
        return context ? context.canvas : null;
      }
      /**
       * Get the image from a tile.
       * @param {import("../../ImageTile.js").default} tile Tile.
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @protected
       */
      getTileImage(tile) {
        return tile.getImage();
      }
      /**
       * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import('../../Tile.js').default} tile Tile.
       * @protected
       */
      updateUsedTiles(usedTiles, tileSource, tile) {
        const tileSourceKey = getUid(tileSource);
        if (!(tileSourceKey in usedTiles)) {
          usedTiles[tileSourceKey] = {};
        }
        usedTiles[tileSourceKey][tile.getKey()] = true;
      }
    };
    TileLayer_default = CanvasTileLayerRenderer;
  }
});

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default;
var init_ObjectEventType = __esm({
  "node_modules/ol/ObjectEventType.js"() {
    ObjectEventType_default = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: "propertychange"
    };
  }
});

// node_modules/ol/Object.js
var ObjectEvent, BaseObject, Object_default;
var init_Object = __esm({
  "node_modules/ol/Object.js"() {
    init_ObjectEventType();
    init_Observable();
    init_Event();
    init_obj();
    init_util();
    ObjectEvent = class extends Event_default {
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      constructor(type, key, oldValue) {
        super(type);
        this.key = key;
        this.oldValue = oldValue;
      }
    };
    BaseObject = class extends Observable_default {
      /**
       * @param {Object<string, *>} [values] An object with key-value pairs.
       */
      constructor(values) {
        super();
        this.on;
        this.once;
        this.un;
        getUid(this);
        this.values_ = null;
        if (values !== void 0) {
          this.setProperties(values);
        }
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) {
          value = this.values_[key];
        }
        return value;
      }
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.values_;
      }
      /**
       * @return {boolean} The object has properties.
       */
      hasProperties() {
        return !!this.values_;
      }
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
        eventType = ObjectEventType_default.PROPERTYCHANGE;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
      }
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) {
          values[key] = value;
        } else {
          const oldValue = values[key];
          values[key] = value;
          if (oldValue !== value) {
            this.notify(key, oldValue);
          }
        }
      }
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      setProperties(values, silent) {
        for (const key in values) {
          this.set(key, values[key], silent);
        }
      }
      /**
       * Apply any properties from another object without triggering events.
       * @param {BaseObject} source The source object.
       * @protected
       */
      applyProperties(source) {
        if (!source.values_) {
          return;
        }
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
      }
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean} [silent] Unset without triggering an event.
       * @api
       */
      unset(key, silent) {
        if (this.values_ && key in this.values_) {
          const oldValue = this.values_[key];
          delete this.values_[key];
          if (isEmpty(this.values_)) {
            this.values_ = null;
          }
          if (!silent) {
            this.notify(key, oldValue);
          }
        }
      }
    };
    Object_default = BaseObject;
  }
});

// node_modules/ol/ViewHint.js
var ViewHint_default;
var init_ViewHint = __esm({
  "node_modules/ol/ViewHint.js"() {
    ViewHint_default = {
      ANIMATING: 0,
      INTERACTING: 1
    };
  }
});

// node_modules/ol/ViewProperty.js
var ViewProperty_default;
var init_ViewProperty = __esm({
  "node_modules/ol/ViewProperty.js"() {
    ViewProperty_default = {
      CENTER: "center",
      RESOLUTION: "resolution",
      ROTATION: "rotation"
    };
  }
});

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x5 = clamp(center[0], minX, maxX);
      let y4 = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x5 += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y4 += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x5, y4];
    }
  );
}
function none(center) {
  return center;
}
var init_centerconstraint = __esm({
  "node_modules/ol/centerconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset, end, stride, transform3, dest, destinationStride) {
  dest = dest ? dest : [];
  destinationStride = destinationStride ? destinationStride : 2;
  let i4 = 0;
  for (let j3 = offset; j3 < end; j3 += stride) {
    const x5 = flatCoordinates[j3];
    const y4 = flatCoordinates[j3 + 1];
    dest[i4++] = transform3[0] * x5 + transform3[2] * y4 + transform3[4];
    dest[i4++] = transform3[1] * x5 + transform3[3] * y4 + transform3[5];
    for (let k2 = 2; k2 < destinationStride; k2++) {
      dest[i4++] = flatCoordinates[j3 + k2];
    }
  }
  if (dest && dest.length != i4) {
    dest.length = i4;
  }
  return dest;
}
function rotate2(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i4 = 0;
  for (let j3 = offset; j3 < end; j3 += stride) {
    const deltaX = flatCoordinates[j3] - anchorX;
    const deltaY = flatCoordinates[j3 + 1] - anchorY;
    dest[i4++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i4++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k2 = j3 + 2; k2 < j3 + stride; ++k2) {
      dest[i4++] = flatCoordinates[k2];
    }
  }
  if (dest && dest.length != i4) {
    dest.length = i4;
  }
  return dest;
}
function scale2(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i4 = 0;
  for (let j3 = offset; j3 < end; j3 += stride) {
    const deltaX = flatCoordinates[j3] - anchorX;
    const deltaY = flatCoordinates[j3 + 1] - anchorY;
    dest[i4++] = anchorX + sx * deltaX;
    dest[i4++] = anchorY + sy * deltaY;
    for (let k2 = j3 + 2; k2 < j3 + stride; ++k2) {
      dest[i4++] = flatCoordinates[k2];
    }
  }
  if (dest && dest.length != i4) {
    dest.length = i4;
  }
  return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i4 = 0;
  for (let j3 = offset; j3 < end; j3 += stride) {
    dest[i4++] = flatCoordinates[j3] + deltaX;
    dest[i4++] = flatCoordinates[j3 + 1] + deltaY;
    for (let k2 = j3 + 2; k2 < j3 + stride; ++k2) {
      dest[i4++] = flatCoordinates[k2];
    }
  }
  if (dest && dest.length != i4) {
    dest.length = i4;
  }
  return dest;
}
var init_transform2 = __esm({
  "node_modules/ol/geom/flat/transform.js"() {
  }
});

// node_modules/ol/geom/Geometry.js
var tmpTransform, tmpPoint, Geometry, Geometry_default;
var init_Geometry = __esm({
  "node_modules/ol/geom/Geometry.js"() {
    init_Object();
    init_extent();
    init_functions();
    init_proj();
    init_transform();
    init_util();
    init_transform2();
    tmpTransform = create();
    tmpPoint = [NaN, NaN];
    Geometry = class extends Object_default {
      constructor() {
        super();
        this.extent_ = createEmpty();
        this.extentRevision_ = -1;
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = 0;
        this.simplifyTransformedInternal = memoizeOne(
          (revision, squaredTolerance, transform3) => {
            if (!transform3) {
              return this.getSimplifiedGeometry(squaredTolerance);
            }
            const clone = this.clone();
            clone.applyTransform(transform3);
            return clone.getSimplifiedGeometry(squaredTolerance);
          }
        );
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform3) {
        return this.simplifyTransformedInternal(
          this.getRevision(),
          squaredTolerance,
          transform3
        );
      }
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */
      clone() {
        return abstract();
      }
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x5, y4, closestPoint, minSquaredDistance) {
        return abstract();
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x5, y4) {
        return this.closestPointXY(x5, y4, tmpPoint, Number.MIN_VALUE) === 0;
      }
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */
      getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [NaN, NaN];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
      }
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
      }
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return abstract();
      }
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */
      getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
          const extent2 = this.computeExtent(this.extent_);
          if (isNaN(extent2[0]) || isNaN(extent2[1])) {
            createOrUpdateEmpty(extent2);
          }
          this.extentRevision_ = this.getRevision();
        }
        return returnOrUpdate(this.extent_, extent);
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        abstract();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      scale(sx, sy, anchor) {
        abstract();
      }
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */
      simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return abstract();
      }
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {Type} Geometry type.
       */
      getType() {
        return abstract();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */
      applyTransform(transformFn) {
        abstract();
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      intersectsExtent(extent) {
        return abstract();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      translate(deltaX, deltaY) {
        abstract();
      }
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {this} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      transform(source, destination) {
        const sourceProj = get3(source);
        const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
          const pixelExtent = sourceProj.getExtent();
          const projectedExtent = sourceProj.getWorldExtent();
          const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform,
            projectedExtent[0],
            projectedExtent[3],
            scale4,
            -scale4,
            0,
            0,
            0
          );
          const transformed = transform2D(
            inCoordinates,
            0,
            inCoordinates.length,
            stride,
            tmpTransform,
            outCoordinates
          );
          const projTransform = getTransform(sourceProj, destination);
          if (projTransform) {
            return projTransform(transformed, transformed, stride);
          }
          return transformed;
        } : getTransform(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
      }
    };
    Geometry_default = Geometry;
  }
});

// node_modules/ol/geom/SimpleGeometry.js
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
var SimpleGeometry, SimpleGeometry_default;
var init_SimpleGeometry = __esm({
  "node_modules/ol/geom/SimpleGeometry.js"() {
    init_extent();
    init_util();
    init_Geometry();
    init_transform2();
    SimpleGeometry = class extends Geometry_default {
      constructor() {
        super();
        this.layout = "XY";
        this.stride = 2;
        this.flatCoordinates;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        return createOrUpdateFromFlatCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent
        );
      }
      /**
       * @abstract
       * @return {Array<*> | null} Coordinates.
       */
      getCoordinates() {
        return abstract();
      }
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */
      getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getFlatCoordinates() {
        return this.flatCoordinates;
      }
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */
      getLastCoordinate() {
        return this.flatCoordinates.slice(
          this.flatCoordinates.length - this.stride
        );
      }
      /**
       * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
       * @return {import("./Geometry.js").GeometryLayout} Layout.
       * @api
       */
      getLayout() {
        return this.layout;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @override
       */
      getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }
        const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
          return simplifiedGeometry;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride;
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */
      setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
      }
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      setCoordinates(coordinates2, layout) {
        abstract();
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      setLayout(layout, coordinates2, nesting) {
        let stride;
        if (layout) {
          stride = getStrideForLayout(layout);
        } else {
          for (let i4 = 0; i4 < nesting; ++i4) {
            if (coordinates2.length === 0) {
              this.layout = "XY";
              this.stride = 2;
              return;
            }
            coordinates2 = /** @type {Array<unknown>} */
            coordinates2[0];
          }
          stride = coordinates2.length;
          layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       * @override
       */
      applyTransform(transformFn) {
        if (this.flatCoordinates) {
          transformFn(
            this.flatCoordinates,
            this.flatCoordinates,
            this.layout.startsWith("XYZ") ? 3 : 2,
            this.stride
          );
          this.changed();
        }
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       * @override
       */
      rotate(angle, anchor) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          rotate2(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            angle,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       * @override
       */
      scale(sx, sy, anchor) {
        if (sy === void 0) {
          sy = sx;
        }
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          scale2(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            sx,
            sy,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       * @override
       */
      translate(deltaX, deltaY) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          translate(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            deltaX,
            deltaY,
            flatCoordinates
          );
          this.changed();
        }
      }
    };
    SimpleGeometry_default = SimpleGeometry;
  }
});

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  const x0 = flatCoordinates[end - stride];
  const y0 = flatCoordinates[end - stride + 1];
  let dx1 = 0;
  let dy1 = 0;
  for (; offset < end; offset += stride) {
    const dx2 = flatCoordinates[offset] - x0;
    const dy2 = flatCoordinates[offset + 1] - y0;
    twiceArea += dy1 * dx2 - dx1 * dy2;
    dx1 = dx2;
    dy1 = dy2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    const end = ends[i4];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}
function linearRingss(flatCoordinates, offset, endss, stride) {
  let area = 0;
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    const ends = endss[i4];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}
var init_area = __esm({
  "node_modules/ol/geom/flat/area.js"() {
  }
});

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x5, y4, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t3 = ((x5 - x1) * dx + (y4 - y1) * dy) / (dx * dx + dy * dy);
    if (t3 > 1) {
      offset = offset2;
    } else if (t3 > 0) {
      for (let i4 = 0; i4 < stride; ++i4) {
        closestPoint[i4] = lerp(
          flatCoordinates[offset1 + i4],
          flatCoordinates[offset2 + i4],
          t3
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i4 = 0; i4 < stride; ++i4) {
    closestPoint[i4] = flatCoordinates[offset + i4];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x22 = flatCoordinates[offset];
    const y22 = flatCoordinates[offset + 1];
    const squaredDelta = squaredDistance(x1, y1, x22, y22);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x22;
    y1 = y22;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    const end = ends[i4];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    const ends = endss[i4];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing2, x5, y4, closestPoint, minSquaredDistance, tmpPoint2) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i4, squaredDistance3;
  if (maxDelta === 0) {
    squaredDistance3 = squaredDistance(
      x5,
      y4,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance3 < minSquaredDistance) {
      for (i4 = 0; i4 < stride; ++i4) {
        closestPoint[i4] = flatCoordinates[offset + i4];
      }
      closestPoint.length = stride;
      return squaredDistance3;
    }
    return minSquaredDistance;
  }
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  let index6 = offset + stride;
  while (index6 < end) {
    assignClosest(
      flatCoordinates,
      index6 - stride,
      index6,
      stride,
      x5,
      y4,
      tmpPoint2
    );
    squaredDistance3 = squaredDistance(x5, y4, tmpPoint2[0], tmpPoint2[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i4 = 0; i4 < stride; ++i4) {
        closestPoint[i4] = tmpPoint2[i4];
      }
      closestPoint.length = stride;
      index6 += stride;
    } else {
      index6 += stride * Math.max(
        (Math.sqrt(squaredDistance3) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing2) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x5,
      y4,
      tmpPoint2
    );
    squaredDistance3 = squaredDistance(x5, y4, tmpPoint2[0], tmpPoint2[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i4 = 0; i4 < stride; ++i4) {
        closestPoint[i4] = tmpPoint2[i4];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing2, x5, y4, closestPoint, minSquaredDistance, tmpPoint2) {
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    const end = ends[i4];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing2,
      x5,
      y4,
      closestPoint,
      minSquaredDistance,
      tmpPoint2
    );
    offset = end;
  }
  return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing2, x5, y4, closestPoint, minSquaredDistance, tmpPoint2) {
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    const ends = endss[i4];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates,
      offset,
      ends,
      stride,
      maxDelta,
      isRing2,
      x5,
      y4,
      closestPoint,
      minSquaredDistance,
      tmpPoint2
    );
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}
var init_closest = __esm({
  "node_modules/ol/geom/flat/closest.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i4 = 0, ii = coordinate.length; i4 < ii; ++i4) {
    flatCoordinates[offset++] = coordinate[i4];
  }
  return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates2, stride) {
  for (let i4 = 0, ii = coordinates2.length; i4 < ii; ++i4) {
    const coordinate = coordinates2[i4];
    for (let j3 = 0; j3 < stride; ++j3) {
      flatCoordinates[offset++] = coordinate[j3];
    }
  }
  return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i4 = 0;
  for (let j3 = 0, jj = coordinatess.length; j3 < jj; ++j3) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j3],
      stride
    );
    ends[i4++] = end;
    offset = end;
  }
  ends.length = i4;
  return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, endss) {
  endss = endss ? endss : [];
  let i4 = 0;
  for (let j3 = 0, jj = coordinatesss.length; j3 < jj; ++j3) {
    const ends = deflateCoordinatesArray(
      flatCoordinates,
      offset,
      coordinatesss[j3],
      stride,
      endss[i4]
    );
    if (ends.length === 0) {
      ends[0] = offset;
    }
    endss[i4++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i4;
  return endss;
}
var init_deflate = __esm({
  "node_modules/ol/geom/flat/deflate.js"() {
  }
});

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i4 = 0;
  for (let j3 = offset; j3 < end; j3 += stride) {
    coordinates2[i4++] = flatCoordinates.slice(j3, j3 + stride);
  }
  coordinates2.length = i4;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i4 = 0;
  for (let j3 = 0, jj = ends.length; j3 < jj; ++j3) {
    const end = ends[j3];
    coordinatess[i4++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i4]
    );
    offset = end;
  }
  coordinatess.length = i4;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i4 = 0;
  for (let j3 = 0, jj = endss.length; j3 < jj; ++j3) {
    const ends = endss[j3];
    coordinatesss[i4++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      coordinatesss[i4]
    );
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i4;
  return coordinatesss;
}
var init_inflate = __esm({
  "node_modules/ol/geom/flat/inflate.js"() {
  }
});

// node_modules/ol/geom/flat/simplify.js
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n3 = (end - offset) / stride;
  if (n3 < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n3);
  markers[0] = 1;
  markers[n3 - 1] = 1;
  const stack = [offset, end - stride];
  let index6 = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x22 = flatCoordinates[last];
    const y22 = flatCoordinates[last + 1];
    for (let i4 = first + stride; i4 < last; i4 += stride) {
      const x5 = flatCoordinates[i4];
      const y4 = flatCoordinates[i4 + 1];
      const squaredDistance3 = squaredSegmentDistance(x5, y4, x1, y1, x22, y22);
      if (squaredDistance3 > maxSquaredDistance) {
        index6 = i4;
        maxSquaredDistance = squaredDistance3;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index6 - offset) / stride] = 1;
      if (first + stride < index6) {
        stack.push(first, index6);
      }
      if (index6 + stride < last) {
        stack.push(index6, last);
      }
    }
  }
  for (let i4 = 0; i4 < n3; ++i4) {
    if (markers[i4]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i4 * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i4 * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    const end = ends[i4];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x22, y22;
  do {
    x22 = snap(flatCoordinates[offset], tolerance);
    y22 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x22;
      simplifiedFlatCoordinates[simplifiedOffset++] = y22;
      return simplifiedOffset;
    }
  } while (x22 == x1 && y22 == y1);
  while (offset < end) {
    const x32 = snap(flatCoordinates[offset], tolerance);
    const y32 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (x32 == x22 && y32 == y22) {
      continue;
    }
    const dx1 = x22 - x1;
    const dy1 = y22 - y1;
    const dx2 = x32 - x1;
    const dy2 = y32 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x22 = x32;
      y22 = y32;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x22;
    simplifiedFlatCoordinates[simplifiedOffset++] = y22;
    x1 = x22;
    y1 = y22;
    x22 = x32;
    y22 = y32;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x22;
  simplifiedFlatCoordinates[simplifiedOffset++] = y22;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    const end = ends[i4];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    const ends = endss[i4];
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
var init_simplify = __esm({
  "node_modules/ol/geom/flat/simplify.js"() {
    init_math();
  }
});

// node_modules/ol/geom/LinearRing.js
var LinearRing, LinearRing_default;
var init_LinearRing = __esm({
  "node_modules/ol/geom/LinearRing.js"() {
    init_extent();
    init_SimpleGeometry();
    init_area();
    init_closest();
    init_deflate();
    init_inflate();
    init_simplify();
    LinearRing = class _LinearRing extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LinearRing} Clone.
       * @api
       * @override
       */
      clone() {
        return new _LinearRing(this.flatCoordinates.slice(), this.layout);
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x5, y4, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x5, y4)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          true,
          x5,
          y4,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRing(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LinearRing(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "LinearRing";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return false;
      }
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LinearRing_default = LinearRing;
  }
});

// node_modules/ol/geom/Point.js
var Point, Point_default;
var init_Point = __esm({
  "node_modules/ol/geom/Point.js"() {
    init_extent();
    init_math();
    init_SimpleGeometry();
    init_deflate();
    Point = class _Point extends SimpleGeometry_default {
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.setCoordinates(coordinates2, layout);
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Point} Clone.
       * @api
       * @override
       */
      clone() {
        const point = new _Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x5, y4, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const squaredDistance3 = squaredDistance(
          x5,
          y4,
          flatCoordinates[0],
          flatCoordinates[1]
        );
        if (squaredDistance3 < minSquaredDistance) {
          const stride = this.stride;
          for (let i4 = 0; i4 < stride; ++i4) {
            closestPoint[i4] = flatCoordinates[i4];
          }
          closestPoint.length = stride;
          return squaredDistance3;
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return this.flatCoordinates.slice();
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "Point";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      }
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinate(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    Point_default = Point;
  }
});

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x5, y4) {
  let wn2 = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x22 = flatCoordinates[offset];
    const y22 = flatCoordinates[offset + 1];
    if (y1 <= y4) {
      if (y22 > y4 && (x22 - x1) * (y4 - y1) - (x5 - x1) * (y22 - y1) > 0) {
        wn2++;
      }
    } else if (y22 <= y4 && (x22 - x1) * (y4 - y1) - (x5 - x1) * (y22 - y1) < 0) {
      wn2--;
    }
    x1 = x22;
    y1 = y22;
  }
  return wn2 !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x5, y4) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x5, y4)) {
    return false;
  }
  for (let i4 = 1, ii = ends.length; i4 < ii; ++i4) {
    if (linearRingContainsXY(flatCoordinates, ends[i4 - 1], ends[i4], stride, x5, y4)) {
      return false;
    }
  }
  return true;
}
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x5, y4) {
  if (endss.length === 0) {
    return false;
  }
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    const ends = endss[i4];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x5, y4)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}
var init_contains = __esm({
  "node_modules/ol/geom/flat/contains.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i4, ii, x5, x1, x22, y1, y22;
  const y4 = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r4 = 0, rr = ends.length; r4 < rr; ++r4) {
    const end = ends[r4];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i4 = offset; i4 < end; i4 += stride) {
      x22 = flatCoordinates[i4];
      y22 = flatCoordinates[i4 + 1];
      if (y4 <= y1 && y22 <= y4 || y1 <= y4 && y4 <= y22) {
        x5 = (y4 - y1) / (y22 - y1) * (x22 - x1) + x1;
        intersections.push(x5);
      }
      x1 = x22;
      y1 = y22;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i4 = 1, ii = intersections.length; i4 < ii; ++i4) {
    x22 = intersections[i4];
    const segmentLength = Math.abs(x22 - x1);
    if (segmentLength > maxSegmentLength) {
      x5 = (x1 + x22) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x5, y4)) {
        pointX = x5;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x22;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y4, maxSegmentLength);
    return dest;
  }
  return [pointX, y4, maxSegmentLength];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  let interiorPoints = [];
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    const ends = endss[i4];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      flatCenters,
      2 * i4,
      interiorPoints
    );
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}
var init_interiorpoint = __esm({
  "node_modules/ol/geom/flat/interiorpoint.js"() {
    init_array();
    init_contains();
  }
});

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}
var init_segments = __esm({
  "node_modules/ol/geom/flat/segments.js"() {
  }
});

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset, end, stride, extent, coordinatesExtent) {
  coordinatesExtent = coordinatesExtent ?? extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2] || coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    if (intersectsLineString(flatCoordinates, offset, ends[i4], stride, extent)) {
      return true;
    }
    offset = ends[i4];
  }
  return false;
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i4 = 1, ii = ends.length; i4 < ii; ++i4) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i4 - 1],
      ends[i4],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i4 - 1],
        ends[i4],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    const ends = endss[i4];
    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}
var init_intersectsextent = __esm({
  "node_modules/ol/geom/flat/intersectsextent.js"() {
    init_extent();
    init_contains();
    init_segments();
  }
});

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i4 = 0; i4 < stride; ++i4) {
      const tmp = flatCoordinates[offset + i4];
      flatCoordinates[offset + i4] = flatCoordinates[end - stride + i4];
      flatCoordinates[end - stride + i4] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}
var init_reverse = __esm({
  "node_modules/ol/geom/flat/reverse.js"() {
  }
});

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x22 = flatCoordinates[offset];
    const y22 = flatCoordinates[offset + 1];
    edge += (x22 - x1) * (y22 + y1);
    x1 = x22;
    y1 = y22;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    const end = ends[i4];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i4 === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}
function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    const ends = endss[i4];
    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    const end = ends[i4];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse = i4 === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    offset = orientLinearRings(
      flatCoordinates,
      offset,
      endss[i4],
      stride,
      right
    );
  }
  return offset;
}
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset = 0;
  let prevEndIndex = 0;
  let startOrientation;
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    const end = ends[i4];
    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
    if (startOrientation === void 0) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i4 + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i4 + 1;
    offset = end;
  }
  return endss;
}
var init_orient = __esm({
  "node_modules/ol/geom/flat/orient.js"() {
    init_reverse();
  }
});

// node_modules/ol/geom/Polygon.js
function fromExtent(extent) {
  if (isEmpty2(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}
var Polygon, Polygon_default;
var init_Polygon = __esm({
  "node_modules/ol/geom/Polygon.js"() {
    init_array();
    init_extent();
    init_LinearRing();
    init_Point();
    init_SimpleGeometry();
    init_area();
    init_closest();
    init_contains();
    init_deflate();
    init_inflate();
    init_interiorpoint();
    init_intersectsextent();
    init_orient();
    init_simplify();
    Polygon = class _Polygon extends SimpleGeometry_default {
      /**
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
       *     Array of linear rings that define the polygon. The first linear ring of the
       *     array defines the outer-boundary or surface of the polygon. Each subsequent
       *     linear ring defines a hole in the surface of the polygon. A linear ring is
       *     an array of vertices' coordinates where the first coordinate and the last are
       *     equivalent. (For internal use, flat coordinates in combination with
       *     `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.flatInteriorPointRevision_ = -1;
        this.flatInteriorPoint_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed linear ring to this polygon.
       * @param {LinearRing} linearRing Linear ring.
       * @api
       */
      appendLinearRing(linearRing2) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
        } else {
          extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       * @override
       */
      clone() {
        const polygon = new _Polygon(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        polygon.applyProperties(this);
        return polygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x5, y4, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x5, y4)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          true,
          x5,
          y4,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x5, y4) {
        return linearRingsContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          x5,
          y4
        );
      }
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRings(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       * @override
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * @return {Array<number>} Interior point.
       */
      getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoint_ = getInteriorPointOfArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.ends_,
            this.stride,
            flatCenter,
            0
          );
          this.flatInteriorPointRevision_ = this.getRevision();
        }
        return (
          /** @type {import("../coordinate.js").Coordinate} */
          this.flatInteriorPoint_
        );
      }
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoint() {
        return new Point_default(this.getFlatInteriorPoint(), "XYM");
      }
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      getLinearRingCount() {
        return this.ends_.length;
      }
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing|null} Linear ring.
       * @api
       */
      getLinearRing(index6) {
        if (index6 < 0 || this.ends_.length <= index6) {
          return null;
        }
        return new LinearRing_default(
          this.flatCoordinates.slice(
            index6 === 0 ? 0 : this.ends_[index6 - 1],
            this.ends_[index6]
          ),
          this.layout
        );
      }
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */
      getLinearRings() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const linearRings2 = [];
        let offset = 0;
        for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
          const end = ends[i4];
          const linearRing2 = new LinearRing_default(
            flatCoordinates.slice(offset, end),
            layout
          );
          linearRings2.push(linearRing2);
          offset = end;
        }
        return linearRings2;
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRings(
              this.orientedFlatCoordinates_,
              0,
              this.ends_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = quantizeArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "Polygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLinearRingArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    Polygon_default = Polygon;
  }
});

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z3 = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z3] > cappedMaxRes && z3 < resolutions.length - 1) {
          return resolutions[z3 + 1];
        }
        return resolutions[z3];
      }
      return void 0;
    }
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    }
  );
}
var init_resolutionconstraint = __esm({
  "node_modules/ol/resolutionconstraint.js"() {
    init_array();
    init_extent();
    init_math();
  }
});

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n3) {
  const theta = 2 * Math.PI / n3;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    }
  );
}
function createSnapToZero(tolerance) {
  const t3 = tolerance === void 0 ? toRadians(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t3) {
        return 0;
      }
      return rotation;
    }
  );
}
var init_rotationconstraint = __esm({
  "node_modules/ol/rotationconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/tilegrid/common.js
var DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE;
var init_common2 = __esm({
  "node_modules/ol/tilegrid/common.js"() {
    DEFAULT_MAX_ZOOM = 42;
    DEFAULT_TILE_SIZE = 256;
  }
});

// node_modules/ol/View.js
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals3(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var DEFAULT_MIN_ZOOM, View, View_default;
var init_View = __esm({
  "node_modules/ol/View.js"() {
    init_Object();
    init_ViewHint();
    init_ViewProperty();
    init_array();
    init_asserts();
    init_centerconstraint();
    init_coordinate();
    init_easing();
    init_extent();
    init_functions();
    init_Polygon();
    init_math();
    init_proj();
    init_resolutionconstraint();
    init_rotationconstraint();
    init_common2();
    DEFAULT_MIN_ZOOM = 0;
    View = class extends Object_default {
      /**
       * @param {ViewOptions} [options] View options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        options = Object.assign({}, options);
        this.hints_ = [0, 0];
        this.animations_ = [];
        this.updateAnimationKey_;
        this.projection_ = createProjection(options.projection, "EPSG:3857");
        this.viewportSize_ = [100, 100];
        this.targetCenter_ = null;
        this.targetResolution_;
        this.targetRotation_;
        this.nextCenter_ = null;
        this.nextResolution_;
        this.nextRotation_;
        this.cancelAnchor_ = void 0;
        if (options.projection) {
          disableCoordinateWarning();
        }
        if (options.center) {
          options.center = fromUserCoordinate(options.center, this.projection_);
        }
        if (options.extent) {
          options.extent = fromUserExtent(options.extent, this.projection_);
        }
        this.applyOptions_(options);
      }
      /**
       * Set up the view with the given options.
       * @param {ViewOptions} options View options.
       */
      applyOptions_(options) {
        const properties = Object.assign({}, options);
        for (const key in ViewProperty_default) {
          delete properties[key];
        }
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options);
        this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        this.minResolution_ = resolutionConstraintInfo.minResolution;
        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        this.resolutions_ = options.resolutions;
        this.padding_ = options.padding;
        this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options);
        this.constraints_ = {
          center: centerConstraint,
          resolution: resolutionConstraint,
          rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
        this.setCenterInternal(
          options.center !== void 0 ? options.center : null
        );
        if (options.resolution !== void 0) {
          this.setResolution(options.resolution);
        } else if (options.zoom !== void 0) {
          this.setZoom(options.zoom);
        }
      }
      /**
       * Padding (in css pixels).
       * If the map viewport is partially covered with other content (overlays) along
       * its edges, this setting allows to shift the center of the viewport away from that
       * content. The order of the values in the array is top, right, bottom, left.
       * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
       * @type {Array<number>|undefined}
       * @api
       */
      get padding() {
        return this.padding_;
      }
      set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenterInternal();
        if (center) {
          const newPadding = padding || [0, 0, 0, 0];
          oldPadding = oldPadding || [0, 0, 0, 0];
          const resolution = this.getResolution();
          const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
          const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
          this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
        }
      }
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */
      getUpdatedOptions_(newOptions) {
        const options = this.getProperties();
        if (options.resolution !== void 0) {
          options.resolution = this.getResolution();
        } else {
          options.zoom = this.getZoom();
        }
        options.center = this.getCenterInternal();
        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
      }
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      animate(var_args) {
        if (this.isDef() && !this.getAnimating()) {
          this.resolveConstraints(0);
        }
        const args = new Array(arguments.length);
        for (let i4 = 0; i4 < args.length; ++i4) {
          let options = arguments[i4];
          if (options.center) {
            options = Object.assign({}, options);
            options.center = fromUserCoordinate(
              options.center,
              this.getProjection()
            );
          }
          if (options.anchor) {
            options = Object.assign({}, options);
            options.anchor = fromUserCoordinate(
              options.anchor,
              this.getProjection()
            );
          }
          args[i4] = options;
        }
        this.animateInternal.apply(this, args);
      }
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */
      animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
          callback = arguments[animationCount - 1];
          --animationCount;
        }
        let i4 = 0;
        for (; i4 < animationCount && !this.isDef(); ++i4) {
          const state = arguments[i4];
          if (state.center) {
            this.setCenterInternal(state.center);
          }
          if (state.zoom !== void 0) {
            this.setZoom(state.zoom);
          } else if (state.resolution) {
            this.setResolution(state.resolution);
          }
          if (state.rotation !== void 0) {
            this.setRotation(state.rotation);
          }
        }
        if (i4 === animationCount) {
          if (callback) {
            animationCallback(callback, true);
          }
          return;
        }
        let start2 = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for (; i4 < animationCount; ++i4) {
          const options = (
            /** @type {AnimationOptions} */
            arguments[i4]
          );
          const animation = {
            start: start2,
            complete: false,
            anchor: options.anchor,
            duration: options.duration !== void 0 ? options.duration : 1e3,
            easing: options.easing || inAndOut,
            callback
          };
          if (options.center) {
            animation.sourceCenter = center;
            animation.targetCenter = options.center.slice();
            center = animation.targetCenter;
          }
          if (options.zoom !== void 0) {
            animation.sourceResolution = resolution;
            animation.targetResolution = this.getResolutionForZoom(options.zoom);
            resolution = animation.targetResolution;
          } else if (options.resolution) {
            animation.sourceResolution = resolution;
            animation.targetResolution = options.resolution;
            resolution = animation.targetResolution;
          }
          if (options.rotation !== void 0) {
            animation.sourceRotation = rotation;
            const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
            animation.targetRotation = rotation + delta;
            rotation = animation.targetRotation;
          }
          if (isNoopAnimation(animation)) {
            animation.complete = true;
          } else {
            start2 += animation.duration;
          }
          series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(ViewHint_default.ANIMATING, 1);
        this.updateAnimations_();
      }
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      getAnimating() {
        return this.hints_[ViewHint_default.ANIMATING] > 0;
      }
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      getInteracting() {
        return this.hints_[ViewHint_default.INTERACTING] > 0;
      }
      /**
       * Cancel any ongoing animations.
       * @api
       */
      cancelAnimations() {
        this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
        let anchor;
        for (let i4 = 0, ii = this.animations_.length; i4 < ii; ++i4) {
          const series = this.animations_[i4];
          if (series[0].callback) {
            animationCallback(series[0].callback, false);
          }
          if (!anchor) {
            for (let j3 = 0, jj = series.length; j3 < jj; ++j3) {
              const animation = series[j3];
              if (!animation.complete) {
                anchor = animation.anchor;
                break;
              }
            }
          }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
      }
      /**
       * Update all animations.
       */
      updateAnimations_() {
        if (this.updateAnimationKey_ !== void 0) {
          cancelAnimationFrame(this.updateAnimationKey_);
          this.updateAnimationKey_ = void 0;
        }
        if (!this.getAnimating()) {
          return;
        }
        const now = Date.now();
        let more = false;
        for (let i4 = this.animations_.length - 1; i4 >= 0; --i4) {
          const series = this.animations_[i4];
          let seriesComplete = true;
          for (let j3 = 0, jj = series.length; j3 < jj; ++j3) {
            const animation = series[j3];
            if (animation.complete) {
              continue;
            }
            const elapsed = now - animation.start;
            let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
            if (fraction >= 1) {
              animation.complete = true;
              fraction = 1;
            } else {
              seriesComplete = false;
            }
            const progress = animation.easing(fraction);
            if (animation.sourceCenter) {
              const x0 = animation.sourceCenter[0];
              const y0 = animation.sourceCenter[1];
              const x1 = animation.targetCenter[0];
              const y1 = animation.targetCenter[1];
              this.nextCenter_ = animation.targetCenter;
              const x5 = x0 + progress * (x1 - x0);
              const y4 = y0 + progress * (y1 - y0);
              this.targetCenter_ = [x5, y4];
            }
            if (animation.sourceResolution && animation.targetResolution) {
              const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
              if (animation.anchor) {
                const size = this.getViewportSize_(this.getRotation());
                const constrainedResolution = this.constraints_.resolution(
                  resolution,
                  0,
                  size,
                  true
                );
                this.targetCenter_ = this.calculateCenterZoom(
                  constrainedResolution,
                  animation.anchor
                );
              }
              this.nextResolution_ = animation.targetResolution;
              this.targetResolution_ = resolution;
              this.applyTargetState_(true);
            }
            if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
              const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
              if (animation.anchor) {
                const constrainedRotation = this.constraints_.rotation(
                  rotation,
                  true
                );
                this.targetCenter_ = this.calculateCenterRotate(
                  constrainedRotation,
                  animation.anchor
                );
              }
              this.nextRotation_ = animation.targetRotation;
              this.targetRotation_ = rotation;
            }
            this.applyTargetState_(true);
            more = true;
            if (!animation.complete) {
              break;
            }
          }
          if (seriesComplete) {
            this.animations_[i4] = null;
            this.setHint(ViewHint_default.ANIMATING, -1);
            this.nextCenter_ = null;
            this.nextResolution_ = NaN;
            this.nextRotation_ = NaN;
            const callback = series[0].callback;
            if (callback) {
              animationCallback(callback, true);
            }
          }
        }
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === void 0) {
          this.updateAnimationKey_ = requestAnimationFrame(
            this.updateAnimations_.bind(this)
          );
        }
      }
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */
      calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== void 0) {
          center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
          rotate(center, rotation - this.getRotation());
          add(center, anchor);
        }
        return center;
      }
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */
      calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== void 0 && currentResolution !== void 0) {
          const x5 = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
          const y4 = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
          center = [x5, y4];
        }
        return center;
      }
      /**
       * Returns the current viewport size.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
          const w3 = size[0];
          const h3 = size[1];
          return [
            Math.abs(w3 * Math.cos(rotation)) + Math.abs(h3 * Math.sin(rotation)),
            Math.abs(w3 * Math.sin(rotation)) + Math.abs(h3 * Math.cos(rotation))
          ];
        }
        return size;
      }
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
       */
      setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
        if (!this.getAnimating()) {
          this.resolveConstraints(0);
        }
      }
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      getCenter() {
        const center = this.getCenterInternal();
        if (!center) {
          return center;
        }
        return toUserCoordinate(center, this.getProjection());
      }
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */
      getCenterInternal() {
        return (
          /** @type {import("./coordinate.js").Coordinate|undefined} */
          this.get(ViewProperty_default.CENTER)
        );
      }
      /**
       * @return {Constraints} Constraints.
       */
      getConstraints() {
        return this.constraints_;
      }
      /**
       * @return {boolean} Resolution constraint is set
       */
      getConstrainResolution() {
        return this.get("constrainResolution");
      }
      /**
       * @param {Array<number>} [hints] Destination array.
       * @return {Array<number>} Hint.
       */
      getHints(hints) {
        if (hints !== void 0) {
          hints[0] = this.hints_[0];
          hints[1] = this.hints_[1];
          return hints;
        }
        return this.hints_.slice();
      }
      /**
       * Calculate the extent for the current view state and the passed box size.
       * @param {import("./size.js").Size} [size] The pixel dimensions of the box
       * into which the calculated extent should fit. Defaults to the size of the
       * map the view is associated with.
       * If no map or multiple maps are connected to the view, provide the desired
       * box size (e.g. `map.getSize()`).
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */
      calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return toUserExtent(extent, this.getProjection());
      }
      /**
       * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
       * the map's last known viewport size will be used.
       * @return {import("./extent.js").Extent} Extent.
       */
      calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = (
          /** @type {!import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        assert(center, "The view center is not defined");
        const resolution = (
          /** @type {!number} */
          this.getResolution()
        );
        assert(resolution !== void 0, "The view resolution is not defined");
        const rotation = (
          /** @type {!number} */
          this.getRotation()
        );
        assert(rotation !== void 0, "The view rotation is not defined");
        return getForViewAndSize(center, resolution, rotation, size);
      }
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      getMaxResolution() {
        return this.maxResolution_;
      }
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      getMinResolution() {
        return this.minResolution_;
      }
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.minResolution_)
        );
      }
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
      }
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.maxResolution_)
        );
      }
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
      }
      /**
       * Set whether the view should allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */
      setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
      }
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */
      getProjection() {
        return this.projection_;
      }
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      getResolution() {
        return (
          /** @type {number|undefined} */
          this.get(ViewProperty_default.RESOLUTION)
        );
      }
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */
      getResolutions() {
        return this.resolutions_;
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal(
          fromUserExtent(extent, this.getProjection()),
          size
        );
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */
      getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = getWidth(extent) / size[0];
        const yResolution = getHeight(extent) / size[1];
        return Math.max(xResolution, yResolution);
      }
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Resolution for value function.
       */
      getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
          }
        );
      }
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      getRotation() {
        return (
          /** @type {number} */
          this.get(ViewProperty_default.ROTATION)
        );
      }
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Value for resolution function.
       */
      getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
          }
        );
      }
      /**
       * Returns the size of the viewport minus padding.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size reduced by the padding.
       */
      getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) {
          size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
          ];
        }
        return size;
      }
      /**
       * @return {State} View state.
       */
      getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = (
          /** @type {import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        const padding = this.padding_;
        if (padding) {
          const reducedSize = this.getViewportSizeMinusPadding_();
          center = calculateCenterOn(
            center,
            this.getViewportSize_(),
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
        }
        return {
          center: center.slice(0),
          projection: projection !== void 0 ? projection : null,
          resolution,
          nextCenter: this.nextCenter_,
          nextResolution: this.nextResolution_,
          nextRotation: this.nextRotation_,
          rotation,
          zoom: this.getZoom()
        };
      }
      /**
       * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
       */
      getViewStateAndExtent() {
        return {
          viewState: this.getState(),
          extent: this.calculateExtent()
        };
      }
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */
      getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== void 0) {
          zoom = this.getZoomForResolution(resolution);
        }
        return zoom;
      }
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      getZoomForResolution(resolution) {
        let offset = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
          const nearest = linearFindNearest(this.resolutions_, resolution, 1);
          offset = nearest;
          max = this.resolutions_[nearest];
          if (nearest == this.resolutions_.length - 1) {
            zoomFactor = 2;
          } else {
            zoomFactor = max / this.resolutions_[nearest + 1];
          }
        } else {
          max = this.maxResolution_;
          zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
      }
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      getResolutionForZoom(zoom) {
        if (this.resolutions_?.length) {
          if (this.resolutions_.length === 1) {
            return this.resolutions_[0];
          }
          const baseLevel = clamp(
            Math.floor(zoom),
            0,
            this.resolutions_.length - 2
          );
          const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
          return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
      }
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions} [options] Options.
       * @api
       */
      fit(geometryOrExtent, options) {
        let geometry;
        assert(
          Array.isArray(geometryOrExtent) || typeof /** @type {?} */
          geometryOrExtent.getSimplifiedGeometry === "function",
          "Invalid extent or geometry provided as `geometry`"
        );
        if (Array.isArray(geometryOrExtent)) {
          assert(
            !isEmpty2(geometryOrExtent),
            "Cannot fit empty extent provided as `geometry`"
          );
          const extent = fromUserExtent(geometryOrExtent, this.getProjection());
          geometry = fromExtent(extent);
        } else if (geometryOrExtent.getType() === "Circle") {
          const extent = fromUserExtent(
            geometryOrExtent.getExtent(),
            this.getProjection()
          );
          geometry = fromExtent(extent);
          geometry.rotate(this.getRotation(), getCenter(extent));
        } else {
          const userProjection2 = getUserProjection();
          if (userProjection2) {
            geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
            geometryOrExtent.clone().transform(userProjection2, this.getProjection());
          } else {
            geometry = geometryOrExtent;
          }
        }
        this.fitInternal(geometry, options);
      }
      /**
       * Calculate rotated extent
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @return {import("./extent").Extent} The rotated extent for the geometry.
       */
      rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = Infinity;
        let minRotY = Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for (let i4 = 0, ii = coords.length; i4 < ii; i4 += stride) {
          const rotX = coords[i4] * cosAngle - coords[i4 + 1] * sinAngle;
          const rotY = coords[i4] * sinAngle + coords[i4 + 1] * cosAngle;
          minRotX = Math.min(minRotX, rotX);
          minRotY = Math.min(minRotY, rotY);
          maxRotX = Math.max(maxRotX, rotX);
          maxRotY = Math.max(maxRotY, rotY);
        }
        return [minRotX, minRotY, maxRotX, maxRotY];
      }
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions} [options] Options.
       */
      fitInternal(geometry, options) {
        options = options || {};
        let size = options.size;
        if (!size) {
          size = this.getViewportSizeMinusPadding_();
        }
        const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
        const nearest = options.nearest !== void 0 ? options.nearest : false;
        let minResolution;
        if (options.minResolution !== void 0) {
          minResolution = options.minResolution;
        } else if (options.maxZoom !== void 0) {
          minResolution = this.getResolutionForZoom(options.maxZoom);
        } else {
          minResolution = 0;
        }
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
          size[0] - padding[1] - padding[3],
          size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = getCenter(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([centerX, centerY], resolution);
        const callback = options.callback ? options.callback : VOID;
        if (options.duration !== void 0) {
          this.animateInternal(
            {
              resolution,
              center,
              duration: options.duration,
              easing: options.easing
            },
            callback
          );
        } else {
          this.targetResolution_ = resolution;
          this.targetCenter_ = center;
          this.applyTargetState_(false, true);
          animationCallback(callback, true);
        }
      }
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */
      centerOn(coordinate, size, position) {
        this.centerOnInternal(
          fromUserCoordinate(coordinate, this.getProjection()),
          size,
          position
        );
      }
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */
      centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(
          calculateCenterOn(
            coordinate,
            size,
            position,
            this.getResolution(),
            this.getRotation()
          )
        );
      }
      /**
       * Calculates the shift between map and viewport center.
       * @param {import("./coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {import("./size.js").Size} size Size.
       * @return {Array<number>|undefined} Center shift.
       */
      calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
          const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
          const shiftedCenter = calculateCenterOn(
            center,
            size,
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
          centerShift = [
            center[0] - shiftedCenter[0],
            center[1] - shiftedCenter[1]
          ];
        }
        return centerShift;
      }
      /**
       * @return {boolean} Is defined.
       */
      isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== void 0;
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */
      adjustCenter(deltaCoordinates) {
        const center = toUserCoordinate(this.targetCenter_, this.getProjection());
        this.setCenter([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */
      adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustResolution(ratio, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(
          this.targetResolution_ * ratio,
          0,
          size,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        }
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
      }
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
      }
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       * @api
       */
      adjustRotation(delta, anchor) {
        if (anchor) {
          anchor = fromUserCoordinate(anchor, this.getProjection());
        }
        this.adjustRotationInternal(delta, anchor);
      }
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       */
      adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(
          this.targetRotation_ + delta,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        }
        this.targetRotation_ += delta;
        this.applyTargetState_();
      }
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      setCenter(center) {
        this.setCenterInternal(
          center ? fromUserCoordinate(center, this.getProjection()) : center
        );
      }
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */
      setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
      }
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
      }
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
      }
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
      }
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */
      setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
      }
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean} [doNotCancelAnims] Do not cancel animations.
       * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
       * @private
       */
      applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        const newRotation = this.constraints_.rotation(
          this.targetRotation_,
          isMoving
        );
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          0,
          size,
          isMoving
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          isMoving,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
          this.set(ViewProperty_default.ROTATION, newRotation);
        }
        if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
          this.set(ViewProperty_default.RESOLUTION, newResolution);
          this.set("zoom", this.getZoom(), true);
        }
        if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
          this.set(ViewProperty_default.CENTER, newCenter);
        }
        if (this.getAnimating() && !doNotCancelAnims) {
          this.cancelAnimations();
        }
        this.cancelAnchor_ = void 0;
      }
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number} [duration] The animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== void 0 ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          direction,
          size
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          false,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (duration === 0 && !this.cancelAnchor_) {
          this.targetResolution_ = newResolution;
          this.targetRotation_ = newRotation;
          this.targetCenter_ = newCenter;
          this.applyTargetState_();
          return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
        this.cancelAnchor_ = void 0;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
          if (this.getAnimating()) {
            this.cancelAnimations();
          }
          this.animateInternal({
            rotation: newRotation,
            center: newCenter,
            resolution: newResolution,
            duration,
            easing: easeOut,
            anchor
          });
        }
      }
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */
      beginInteraction() {
        this.resolveConstraints(0);
        this.setHint(ViewHint_default.INTERACTING, 1);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      endInteractionInternal(duration, resolutionDirection, anchor) {
        if (!this.getInteracting()) {
          return;
        }
        this.setHint(ViewHint_default.INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
      }
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */
      getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(
          targetCenter,
          targetResolution || this.getResolution(),
          size
        );
      }
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number} [direction] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */
      getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(
          this.getConstrainedResolution(targetRes, direction)
        );
      }
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number} [direction] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */
      getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
      }
    };
    View_default = View;
  }
});

// node_modules/ol/layer/Property.js
var Property_default;
var init_Property = __esm({
  "node_modules/ol/layer/Property.js"() {
    Property_default = {
      OPACITY: "opacity",
      VISIBLE: "visible",
      EXTENT: "extent",
      Z_INDEX: "zIndex",
      MAX_RESOLUTION: "maxResolution",
      MIN_RESOLUTION: "minResolution",
      MAX_ZOOM: "maxZoom",
      MIN_ZOOM: "minZoom",
      SOURCE: "source",
      MAP: "map"
    };
  }
});

// node_modules/ol/layer/Base.js
var BaseLayer, Base_default;
var init_Base = __esm({
  "node_modules/ol/layer/Base.js"() {
    init_Object();
    init_asserts();
    init_math();
    init_util();
    init_Property();
    BaseLayer = class extends Object_default {
      /**
       * @param {Options} options Layer options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        this.background_ = options.background;
        const properties = Object.assign({}, options);
        if (typeof options.properties === "object") {
          delete properties.properties;
          Object.assign(properties, options.properties);
        }
        properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
        assert(
          typeof properties[Property_default.OPACITY] === "number",
          "Layer opacity must be a number"
        );
        properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
        properties[Property_default.Z_INDEX] = options.zIndex;
        properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
        properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
        properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
        properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
        this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
        delete properties.className;
        this.setProperties(properties);
        this.state_ = null;
      }
      /**
       * Get the background for this layer.
       * @return {BackgroundColor|false} Layer background.
       */
      getBackground() {
        return this.background_;
      }
      /**
       * @return {string} CSS class name.
       */
      getClassName() {
        return this.className_;
      }
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean} [managed] Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      getLayerState(managed) {
        const state = this.state_ || /** @type {?} */
        {
          layer: this,
          managed: managed === void 0 ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        return abstract();
      }
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      getExtent() {
        return (
          /** @type {import("../extent.js").Extent|undefined} */
          this.get(Property_default.EXTENT)
        );
      }
      /**
       * Return the maximum resolution of the layer. Returns Infinity if
       * the layer has no maximum resolution set.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      getMaxResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_RESOLUTION)
        );
      }
      /**
       * Return the minimum resolution of the layer. Returns 0 if
       * the layer has no minimum resolution set.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      getMinResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_RESOLUTION)
        );
      }
      /**
       * Return the minimum zoom level of the layer. Returns -Infinity if
       * the layer has no minimum zoom set.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_ZOOM)
        );
      }
      /**
       * Return the maximum zoom level of the layer. Returns Infinity if
       * the layer has no maximum zoom set.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_ZOOM)
        );
      }
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      getOpacity() {
        return (
          /** @type {number} */
          this.get(Property_default.OPACITY)
        );
      }
      /**
       * @abstract
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        return abstract();
      }
      /**
       * Return the value of this layer's `visible` property. To find out whether the layer
       * is visible on a map, use `isVisible()` instead.
       * @return {boolean} The value of the `visible` property of the layer.
       * @observable
       * @api
       */
      getVisible() {
        return (
          /** @type {boolean} */
          this.get(Property_default.VISIBLE)
        );
      }
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. Returns undefined if the layer is unmanaged.
       * @return {number|undefined} The Z-index of the layer.
       * @observable
       * @api
       */
      getZIndex() {
        return (
          /** @type {number|undefined} */
          this.get(Property_default.Z_INDEX)
        );
      }
      /**
       * Sets the background color.
       * @param {BackgroundColor} [background] Background color.
       */
      setBackground(background) {
        this.background_ = background;
        this.changed();
      }
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      setExtent(extent) {
        this.set(Property_default.EXTENT, extent);
      }
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      setMaxResolution(maxResolution) {
        this.set(Property_default.MAX_RESOLUTION, maxResolution);
      }
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      setMinResolution(minResolution) {
        this.set(Property_default.MIN_RESOLUTION, minResolution);
      }
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      setMaxZoom(maxZoom) {
        this.set(Property_default.MAX_ZOOM, maxZoom);
      }
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      setMinZoom(minZoom) {
        this.set(Property_default.MIN_ZOOM, minZoom);
      }
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      setOpacity(opacity) {
        assert(typeof opacity === "number", "Layer opacity must be a number");
        this.set(Property_default.OPACITY, opacity);
      }
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      setVisible(visible) {
        this.set(Property_default.VISIBLE, visible);
      }
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      setZIndex(zindex) {
        this.set(Property_default.Z_INDEX, zindex);
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        if (this.state_) {
          this.state_.layer = null;
          this.state_ = null;
        }
        super.disposeInternal();
      }
    };
    Base_default = BaseLayer;
  }
});

// node_modules/ol/layer/Layer.js
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer, Layer_default3;
var init_Layer3 = __esm({
  "node_modules/ol/layer/Layer.js"() {
    init_View();
    init_asserts();
    init_EventType();
    init_events();
    init_extent();
    init_EventType2();
    init_Base();
    init_Property();
    Layer = class extends Base_default {
      /**
       * @param {Options<SourceType>} options Layer options.
       */
      constructor(options) {
        const baseOptions = Object.assign({}, options);
        delete baseOptions.source;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.mapPrecomposeKey_ = null;
        this.mapRenderKey_ = null;
        this.sourceChangeKey_ = null;
        this.renderer_ = null;
        this.sourceReady_ = false;
        this.rendered = false;
        if (options.render) {
          this.render = options.render;
        }
        if (options.map) {
          this.setMap(options.map);
        }
        this.addChangeListener(
          Property_default.SOURCE,
          this.handleSourcePropertyChange_
        );
        const source = options.source ? (
          /** @type {SourceType} */
          options.source
        ) : null;
        this.setSource(source);
      }
      /**
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       * @override
       */
      getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
      }
      /**
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       * @override
       */
      getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
      }
      /**
       * Get the layer source.
       * @return {SourceType|null} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      getSource() {
        return (
          /** @type {SourceType} */
          this.get(Property_default.SOURCE) || null
        );
      }
      /**
       * @return {SourceType|null} The source being rendered.
       */
      getRenderSource() {
        return this.getSource();
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       * @override
       */
      getSourceState() {
        const source = this.getSource();
        return !source ? "undefined" : source.getState();
      }
      /**
       * @private
       */
      handleSourceChange_() {
        this.changed();
        if (this.sourceReady_ || this.getSource().getState() !== "ready") {
          return;
        }
        this.sourceReady_ = true;
        this.dispatchEvent("sourceready");
      }
      /**
       * @private
       */
      handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
          unlistenByKey(this.sourceChangeKey_);
          this.sourceChangeKey_ = null;
        }
        this.sourceReady_ = false;
        const source = this.getSource();
        if (source) {
          this.sourceChangeKey_ = listen(
            source,
            EventType_default.CHANGE,
            this.handleSourceChange_,
            this
          );
          if (source.getState() === "ready") {
            this.sourceReady_ = true;
            setTimeout(() => {
              this.dispatchEvent("sourceready");
            }, 0);
          }
        }
        this.changed();
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        if (!this.renderer_) {
          return Promise.resolve([]);
        }
        return this.renderer_.getFeatures(pixel);
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        if (!this.renderer_ || !this.rendered) {
          return null;
        }
        return this.renderer_.getData(pixel);
      }
      /**
       * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
       * extent, not set to `visible: false`, and not inside a layer group that is set
       * to `visible: false`.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {boolean} The layer is visible in the map view.
       * @api
       */
      isVisible(view) {
        let frameState;
        const map = this.getMapInternal();
        if (!view && map) {
          view = map.getView();
        }
        if (view instanceof View_default) {
          frameState = {
            viewState: view.getState(),
            extent: view.calculateExtent()
          };
        } else {
          frameState = view;
        }
        if (!frameState.layerStatesArray && map) {
          frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
        }
        let layerState;
        if (frameState.layerStatesArray) {
          layerState = frameState.layerStatesArray.find(
            (layerState2) => layerState2.layer === this
          );
          if (!layerState) {
            return false;
          }
        } else {
          layerState = this.getLayerState();
        }
        const layerExtent = this.getExtent();
        return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
      }
      /**
       * Get the attributions of the source of this layer for the given view.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {Array<string>} Attributions for this layer at the given view.
       * @api
       */
      getAttributions(view) {
        if (!this.isVisible(view)) {
          return [];
        }
        const getAttributions = this.getSource()?.getAttributions();
        if (!getAttributions) {
          return [];
        }
        const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
        let attributions = getAttributions(frameState);
        if (!Array.isArray(attributions)) {
          attributions = [attributions];
        }
        return attributions;
      }
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement|null} The rendered element.
       */
      render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
          this.rendered = true;
          return layerRenderer.renderFrame(frameState, target);
        }
        return null;
      }
      /**
       * Called when a layer is not visible during a map render.
       */
      unrender() {
        this.rendered = false;
      }
      /** @return {string} Declutter */
      getDeclutter() {
        return void 0;
      }
      /**
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {import("../layer/Layer.js").State} layerState Layer state.
       */
      renderDeclutter(frameState, layerState) {
      }
      /**
       * When the renderer follows a layout -> render approach, do the final rendering here.
       * @param {import('../Map.js').FrameState} frameState Frame state
       */
      renderDeferred(frameState) {
        const layerRenderer = this.getRenderer();
        if (!layerRenderer) {
          return;
        }
        layerRenderer.renderDeferred(frameState);
      }
      /**
       * For use inside the library only.
       * @param {import("../Map.js").default|null} map Map.
       */
      setMapInternal(map) {
        if (!map) {
          this.unrender();
        }
        this.set(Property_default.MAP, map);
      }
      /**
       * For use inside the library only.
       * @return {import("../Map.js").default|null} Map.
       */
      getMapInternal() {
        return this.get(Property_default.MAP);
      }
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map~Map#addLayer} instead.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.mapPrecomposeKey_) {
          unlistenByKey(this.mapPrecomposeKey_);
          this.mapPrecomposeKey_ = null;
        }
        if (!map) {
          this.changed();
        }
        if (this.mapRenderKey_) {
          unlistenByKey(this.mapRenderKey_);
          this.mapRenderKey_ = null;
        }
        if (map) {
          this.mapPrecomposeKey_ = listen(
            map,
            EventType_default2.PRECOMPOSE,
            this.handlePrecompose_,
            this
          );
          this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map.render, map);
          this.changed();
        }
      }
      /**
       * @param {import("../events/Event.js").default} renderEvent Render event
       * @private
       */
      handlePrecompose_(renderEvent) {
        const layerStatesArray = (
          /** @type {import("../render/Event.js").default} */
          renderEvent.frameState.layerStatesArray
        );
        const layerState = this.getLayerState(false);
        assert(
          !layerStatesArray.some(
            (arrayLayerState) => arrayLayerState.layer === layerState.layer
          ),
          "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
        );
        layerStatesArray.push(layerState);
      }
      /**
       * Set the layer source.
       * @param {SourceType|null} source The layer source.
       * @observable
       * @api
       */
      setSource(source) {
        this.set(Property_default.SOURCE, source);
      }
      /**
       * Get the renderer for this layer.
       * @return {RendererType|null} The layer renderer.
       */
      getRenderer() {
        if (!this.renderer_) {
          this.renderer_ = this.createRenderer();
        }
        return this.renderer_;
      }
      /**
       * @return {boolean} The layer has a renderer.
       */
      hasRenderer() {
        return !!this.renderer_;
      }
      /**
       * Create a renderer for this layer.
       * @return {RendererType} A layer renderer.
       * @protected
       */
      createRenderer() {
        return null;
      }
      /**
       * This will clear the renderer so that a new one can be created next time it is needed
       */
      clearRenderer() {
        if (this.renderer_) {
          this.renderer_.dispose();
          delete this.renderer_;
        }
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        this.clearRenderer();
        this.setSource(null);
        super.disposeInternal();
      }
    };
    Layer_default3 = Layer;
  }
});

// node_modules/ol/layer/TileProperty.js
var TileProperty_default;
var init_TileProperty = __esm({
  "node_modules/ol/layer/TileProperty.js"() {
    TileProperty_default = {
      PRELOAD: "preload",
      USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
    };
  }
});

// node_modules/ol/layer/BaseTile.js
var BaseTileLayer, BaseTile_default;
var init_BaseTile = __esm({
  "node_modules/ol/layer/BaseTile.js"() {
    init_Layer3();
    init_TileProperty();
    BaseTileLayer = class extends Layer_default3 {
      /**
       * @param {Options<TileSourceType>} [options] Tile layer options.
       */
      constructor(options) {
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        const cacheSize2 = options.cacheSize;
        delete options.cacheSize;
        delete baseOptions.preload;
        delete baseOptions.useInterimTilesOnError;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.cacheSize_ = cacheSize2;
        this.setPreload(options.preload !== void 0 ? options.preload : 0);
        this.setUseInterimTilesOnError(
          options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true
        );
      }
      /**
       * @return {number|undefined} The suggested cache size
       * @protected
       */
      getCacheSize() {
        return this.cacheSize_;
      }
      /**
       * Return the level as number to which we will preload tiles up to.
       * @return {number} The level to preload tiles up to.
       * @observable
       * @api
       */
      getPreload() {
        return (
          /** @type {number} */
          this.get(TileProperty_default.PRELOAD)
        );
      }
      /**
       * Set the level as number to which we will preload tiles up to.
       * @param {number} preload The level to preload tiles up to.
       * @observable
       * @api
       */
      setPreload(preload) {
        this.set(TileProperty_default.PRELOAD, preload);
      }
      /**
       * Deprecated.  Whether we use interim tiles on error.
       * @return {boolean} Use interim tiles on error.
       * @observable
       * @api
       */
      getUseInterimTilesOnError() {
        return (
          /** @type {boolean} */
          this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR)
        );
      }
      /**
       * Deprecated.  Set whether we use interim tiles on error.
       * @param {boolean} useInterimTilesOnError Use interim tiles on error.
       * @observable
       * @api
       */
      setUseInterimTilesOnError(useInterimTilesOnError) {
        this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
      }
      /**
       * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
       * a four element RGBA array will be returned.  For data tiles, the array length will match the
       * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
       * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
       *
       * ```js
       * // display layer data on every pointer move
       * map.on('pointermove', (event) => {
       *   console.log(layer.getData(event.pixel));
       * });
       * ```
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       * @api
       * @override
       */
      getData(pixel) {
        return super.getData(pixel);
      }
    };
    BaseTile_default = BaseTileLayer;
  }
});

// node_modules/ol/layer/Tile.js
var TileLayer, Tile_default3;
var init_Tile3 = __esm({
  "node_modules/ol/layer/Tile.js"() {
    init_TileLayer();
    init_BaseTile();
    TileLayer = class extends BaseTile_default {
      /**
       * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
       */
      constructor(options) {
        super(options);
      }
      /**
       * @override
       */
      createRenderer() {
        return new TileLayer_default(this, {
          cacheSize: this.getCacheSize()
        });
      }
    };
    Tile_default3 = TileLayer;
  }
});

// node_modules/ol/tilegrid/TileGrid.js
var tmpTileCoord, DECIMALS, TileGrid, TileGrid_default;
var init_TileGrid = __esm({
  "node_modules/ol/tilegrid/TileGrid.js"() {
    init_TileRange();
    init_array();
    init_asserts();
    init_extent();
    init_intersectsextent();
    init_math();
    init_size();
    init_tilecoord();
    init_common2();
    tmpTileCoord = [0, 0, 0];
    DECIMALS = 5;
    TileGrid = class {
      /**
       * @param {Options} options Tile grid options.
       */
      constructor(options) {
        this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
        this.resolutions_ = options.resolutions;
        assert(
          isSorted(
            this.resolutions_,
            /**
             * @param {number} a First resolution
             * @param {number} b Second resolution
             * @return {number} Comparison result
             */
            (a4, b5) => b5 - a4,
            true
          ),
          "`resolutions` must be sorted in descending order"
        );
        let zoomFactor;
        if (!options.origins) {
          for (let i4 = 0, ii = this.resolutions_.length - 1; i4 < ii; ++i4) {
            if (!zoomFactor) {
              zoomFactor = this.resolutions_[i4] / this.resolutions_[i4 + 1];
            } else {
              if (this.resolutions_[i4] / this.resolutions_[i4 + 1] !== zoomFactor) {
                zoomFactor = void 0;
                break;
              }
            }
          }
        }
        this.zoomFactor_ = zoomFactor;
        this.maxZoom = this.resolutions_.length - 1;
        this.origin_ = options.origin !== void 0 ? options.origin : null;
        this.origins_ = null;
        if (options.origins !== void 0) {
          this.origins_ = options.origins;
          assert(
            this.origins_.length == this.resolutions_.length,
            "Number of `origins` and `resolutions` must be equal"
          );
        }
        const extent = options.extent;
        if (extent !== void 0 && !this.origin_ && !this.origins_) {
          this.origin_ = getTopLeft(extent);
        }
        assert(
          !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
          "Either `origin` or `origins` must be configured, never both"
        );
        this.tileSizes_ = null;
        if (options.tileSizes !== void 0) {
          this.tileSizes_ = options.tileSizes;
          assert(
            this.tileSizes_.length == this.resolutions_.length,
            "Number of `tileSizes` and `resolutions` must be equal"
          );
        }
        this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
        assert(
          !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
          "Either `tileSize` or `tileSizes` must be configured, never both"
        );
        this.extent_ = extent !== void 0 ? extent : null;
        this.fullTileRanges_ = null;
        this.tmpSize_ = [0, 0];
        this.tmpExtent_ = [0, 0, 0, 0];
        if (options.sizes !== void 0) {
          this.fullTileRanges_ = options.sizes.map((size, z3) => {
            const tileRange = new TileRange_default(
              Math.min(0, size[0]),
              Math.max(size[0] - 1, -1),
              Math.min(0, size[1]),
              Math.max(size[1] - 1, -1)
            );
            if (extent) {
              const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z3);
              tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
              tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
              tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
              tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
            }
            return tileRange;
          });
        } else if (extent) {
          this.calculateTileRanges_(extent);
        }
      }
      /**
       * Call a function with each tile coordinate for a given extent and zoom level.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} zoom Integer zoom level.
       * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
       * @api
       */
      forEachTileCoord(extent, zoom, callback) {
        const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
        for (let i4 = tileRange.minX, ii = tileRange.maxX; i4 <= ii; ++i4) {
          for (let j3 = tileRange.minY, jj = tileRange.maxY; j3 <= jj; ++j3) {
            callback([zoom, i4, j3]);
          }
        }
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
       * @return {boolean} Callback succeeded.
       */
      forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
        let tileRange, x5, y4;
        let tileCoordExtent = null;
        let z3 = tileCoord[0] - 1;
        if (this.zoomFactor_ === 2) {
          x5 = tileCoord[1];
          y4 = tileCoord[2];
        } else {
          tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
        }
        while (z3 >= this.minZoom) {
          if (x5 !== void 0 && y4 !== void 0) {
            x5 = Math.floor(x5 / 2);
            y4 = Math.floor(y4 / 2);
            tileRange = createOrUpdate(x5, x5, y4, y4, tempTileRange);
          } else {
            tileRange = this.getTileRangeForExtentAndZ(
              tileCoordExtent,
              z3,
              tempTileRange
            );
          }
          if (callback(z3, tileRange)) {
            return true;
          }
          --z3;
        }
        return false;
      }
      /**
       * Get the extent for this tile grid, if it was configured.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        return this.extent_;
      }
      /**
       * Get the maximum zoom level for the grid.
       * @return {number} Max zoom.
       * @api
       */
      getMaxZoom() {
        return this.maxZoom;
      }
      /**
       * Get the minimum zoom level for the grid.
       * @return {number} Min zoom.
       * @api
       */
      getMinZoom() {
        return this.minZoom;
      }
      /**
       * Get the origin for the grid at the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {import("../coordinate.js").Coordinate} Origin.
       * @api
       */
      getOrigin(z3) {
        if (this.origin_) {
          return this.origin_;
        }
        return this.origins_[z3];
      }
      /**
       * Get the resolution for the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {number} Resolution.
       * @api
       */
      getResolution(z3) {
        return this.resolutions_[z3];
      }
      /**
       * Get the list of resolutions for the tile grid.
       * @return {Array<number>} Resolutions.
       * @api
       */
      getResolutions() {
        return this.resolutions_;
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
       * @return {import("../TileRange.js").default|null} Tile range.
       */
      getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
        if (tileCoord[0] < this.maxZoom) {
          if (this.zoomFactor_ === 2) {
            const minX = tileCoord[1] * 2;
            const minY = tileCoord[2] * 2;
            return createOrUpdate(
              minX,
              minX + 1,
              minY,
              minY + 1,
              tempTileRange
            );
          }
          const tileCoordExtent = this.getTileCoordExtent(
            tileCoord,
            tempExtent || this.tmpExtent_
          );
          return this.getTileRangeForExtentAndZ(
            tileCoordExtent,
            tileCoord[0] + 1,
            tempTileRange
          );
        }
        return null;
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
       * @return {import("../TileRange.js").default|null} Tile range.
       */
      getTileRangeForTileCoordAndZ(tileCoord, z3, tempTileRange) {
        if (z3 > this.maxZoom || z3 < this.minZoom) {
          return null;
        }
        const tileCoordZ = tileCoord[0];
        const tileCoordX = tileCoord[1];
        const tileCoordY = tileCoord[2];
        if (z3 === tileCoordZ) {
          return createOrUpdate(
            tileCoordX,
            tileCoordY,
            tileCoordX,
            tileCoordY,
            tempTileRange
          );
        }
        if (this.zoomFactor_) {
          const factor = Math.pow(this.zoomFactor_, z3 - tileCoordZ);
          const minX = Math.floor(tileCoordX * factor);
          const minY = Math.floor(tileCoordY * factor);
          if (z3 < tileCoordZ) {
            return createOrUpdate(minX, minX, minY, minY, tempTileRange);
          }
          const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
          const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
          return createOrUpdate(minX, maxX, minY, maxY, tempTileRange);
        }
        const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, z3, tempTileRange);
      }
      /**
       * Get a tile range for the given extent and integer zoom level.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
       * @return {import("../TileRange.js").default} Tile range.
       */
      getTileRangeForExtentAndZ(extent, z3, tempTileRange) {
        this.getTileCoordForXYAndZ_(extent[0], extent[3], z3, false, tmpTileCoord);
        const minX = tmpTileCoord[1];
        const minY = tmpTileCoord[2];
        this.getTileCoordForXYAndZ_(extent[2], extent[1], z3, true, tmpTileCoord);
        const maxX = tmpTileCoord[1];
        const maxY = tmpTileCoord[2];
        return createOrUpdate(minX, maxX, minY, maxY, tempTileRange);
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {import("../coordinate.js").Coordinate} Tile center.
       */
      getTileCoordCenter(tileCoord) {
        const origin = this.getOrigin(tileCoord[0]);
        const resolution = this.getResolution(tileCoord[0]);
        const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
        return [
          origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
          origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
        ];
      }
      /**
       * Get the extent of a tile coordinate.
       *
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getTileCoordExtent(tileCoord, tempExtent) {
        const origin = this.getOrigin(tileCoord[0]);
        const resolution = this.getResolution(tileCoord[0]);
        const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
        const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
        const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
        const maxX = minX + tileSize[0] * resolution;
        const maxY = minY + tileSize[1] * resolution;
        return createOrUpdate2(minX, minY, maxX, maxY, tempExtent);
      }
      /**
       * Get the tile coordinate for the given map coordinate and resolution.  This
       * method considers that coordinates that intersect tile boundaries should be
       * assigned the higher tile coordinate.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */
      getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
        return this.getTileCoordForXYAndResolution_(
          coordinate[0],
          coordinate[1],
          resolution,
          false,
          opt_tileCoord
        );
      }
      /**
       * Note that this method should not be called for resolutions that correspond
       * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
       * @param {number} x X.
       * @param {number} y Y.
       * @param {number} resolution Resolution (for a non-integer zoom level).
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */
      getTileCoordForXYAndResolution_(x5, y4, resolution, reverseIntersectionPolicy, opt_tileCoord) {
        const z3 = this.getZForResolution(resolution);
        const scale4 = resolution / this.getResolution(z3);
        const origin = this.getOrigin(z3);
        const tileSize = toSize(this.getTileSize(z3), this.tmpSize_);
        let tileCoordX = scale4 * (x5 - origin[0]) / resolution / tileSize[0];
        let tileCoordY = scale4 * (origin[1] - y4) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
          tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
          tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
        } else {
          tileCoordX = floor(tileCoordX, DECIMALS);
          tileCoordY = floor(tileCoordY, DECIMALS);
        }
        return createOrUpdate3(z3, tileCoordX, tileCoordY, opt_tileCoord);
      }
      /**
       * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
       * they should have separate implementations.  This method is for integer zoom
       * levels.  The other method should only be called for resolutions corresponding
       * to non-integer zoom levels.
       * @param {number} x Map x coordinate.
       * @param {number} y Map y coordinate.
       * @param {number} z Integer zoom level.
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */
      getTileCoordForXYAndZ_(x5, y4, z3, reverseIntersectionPolicy, opt_tileCoord) {
        const origin = this.getOrigin(z3);
        const resolution = this.getResolution(z3);
        const tileSize = toSize(this.getTileSize(z3), this.tmpSize_);
        let tileCoordX = (x5 - origin[0]) / resolution / tileSize[0];
        let tileCoordY = (origin[1] - y4) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
          tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
          tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
        } else {
          tileCoordX = floor(tileCoordX, DECIMALS);
          tileCoordY = floor(tileCoordY, DECIMALS);
        }
        return createOrUpdate3(z3, tileCoordX, tileCoordY, opt_tileCoord);
      }
      /**
       * Get a tile coordinate given a map coordinate and zoom level.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */
      getTileCoordForCoordAndZ(coordinate, z3, opt_tileCoord) {
        return this.getTileCoordForXYAndZ_(
          coordinate[0],
          coordinate[1],
          z3,
          false,
          opt_tileCoord
        );
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {number} Tile resolution.
       */
      getTileCoordResolution(tileCoord) {
        return this.resolutions_[tileCoord[0]];
      }
      /**
       * Get the tile size for a zoom level. The type of the return value matches the
       * `tileSize` or `tileSizes` that the tile grid was configured with. To always
       * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
       * @param {number} z Z.
       * @return {number|import("../size.js").Size} Tile size.
       * @api
       */
      getTileSize(z3) {
        if (this.tileSize_) {
          return this.tileSize_;
        }
        return this.tileSizes_[z3];
      }
      /**
       * @param {number} z Zoom level.
       * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
       */
      getFullTileRange(z3) {
        if (!this.fullTileRanges_) {
          return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z3) : null;
        }
        return this.fullTileRanges_[z3];
      }
      /**
       * @param {number} resolution Resolution.
       * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
       *     If 0, the nearest resolution will be used.
       *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
       *     nearest lower resolution (higher Z) will be used. Default is 0.
       *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
       *
       * For example to change tile Z at the midpoint of zoom levels
       * ```js
       * function(value, high, low) {
       *   return value - low * Math.sqrt(high / low);
       * }
       * ```
       * @return {number} Z.
       * @api
       */
      getZForResolution(resolution, opt_direction) {
        const z3 = linearFindNearest(
          this.resolutions_,
          resolution,
          opt_direction || 0
        );
        return clamp(z3, this.minZoom, this.maxZoom);
      }
      /**
       * The tile with the provided tile coordinate intersects the given viewport.
       * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
       * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
       * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
       */
      tileCoordIntersectsViewport(tileCoord, viewport) {
        return intersectsLinearRing(
          viewport,
          0,
          viewport.length,
          2,
          this.getTileCoordExtent(tileCoord)
        );
      }
      /**
       * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
       * @private
       */
      calculateTileRanges_(extent) {
        const length = this.resolutions_.length;
        const fullTileRanges = new Array(length);
        for (let z3 = this.minZoom; z3 < length; ++z3) {
          fullTileRanges[z3] = this.getTileRangeForExtentAndZ(extent, z3);
        }
        this.fullTileRanges_ = fullTileRanges;
      }
    };
    TileGrid_default = TileGrid;
  }
});

// node_modules/ol/tilegrid.js
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX2(tileGrid, tileCoord, projection) {
  const z3 = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z3);
  }
  return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new TileGrid_default({
    extent,
    origin: getCorner(extent, corner),
    resolutions,
    tileSize
  });
}
function createXYZ(options) {
  const xyzOptions = options || {};
  const extent = xyzOptions.extent || get3("EPSG:3857").getExtent();
  const gridOptions = {
    extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution
    )
  };
  return new TileGrid_default(gridOptions);
}
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent);
  const width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z3 = 0; z3 < length; ++z3) {
    resolutions[z3] = maxResolution / Math.pow(2, z3);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get3(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half = 180 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate2(-half, -half, half, half);
  }
  return extent;
}
var init_tilegrid = __esm({
  "node_modules/ol/tilegrid.js"() {
    init_extent();
    init_proj();
    init_size();
    init_TileGrid();
    init_common2();
  }
});

// node_modules/ol/uri.js
function renderXYZTemplate(template, z3, x5, y4, maxY) {
  return template.replace(zRegEx, z3.toString()).replace(xRegEx, x5.toString()).replace(yRegEx, y4.toString()).replace(dashYRegEx, function() {
    if (maxY === void 0) {
      throw new Error(
        "If the URL template has a {-y} placeholder, the grid extent must be known"
      );
    }
    return (maxY - y4).toString();
  });
}
function expandUrl(url) {
  const urls = [];
  let match2 = /\{([a-z])-([a-z])\}/.exec(url);
  if (match2) {
    const startCharCode = match2[1].charCodeAt(0);
    const stopCharCode = match2[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match2[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match2 = /\{(\d+)-(\d+)\}/.exec(url);
  if (match2) {
    const stop = parseInt(match2[2], 10);
    for (let i4 = parseInt(match2[1], 10); i4 <= stop; i4++) {
      urls.push(url.replace(match2[0], i4.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}
var zRegEx, xRegEx, yRegEx, dashYRegEx;
var init_uri = __esm({
  "node_modules/ol/uri.js"() {
    zRegEx = /\{z\}/g;
    xRegEx = /\{x\}/g;
    yRegEx = /\{y\}/g;
    dashYRegEx = /\{-y\}/g;
  }
});

// node_modules/ol/tileurlfunction.js
function createFromTemplate(template, tileGrid) {
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      let maxY;
      const z3 = tileCoord[0];
      if (tileGrid) {
        const range = tileGrid.getFullTileRange(z3);
        if (range) {
          maxY = range.getHeight() - 1;
        }
      }
      return renderXYZTemplate(template, z3, tileCoord[1], tileCoord[2], maxY);
    }
  );
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i4 = 0; i4 < len; ++i4) {
    tileUrlFunctions[i4] = createFromTemplate(templates[i4], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const h3 = hash(tileCoord);
      const index6 = modulo(h3, tileUrlFunctions.length);
      return tileUrlFunctions[index6](tileCoord, pixelRatio, projection);
    }
  );
}
var init_tileurlfunction = __esm({
  "node_modules/ol/tileurlfunction.js"() {
    init_math();
    init_tilecoord();
    init_uri();
  }
});

// node_modules/ol/source/Source.js
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  if (!Array.isArray(attributionLike)) {
    attributionLike = [attributionLike];
  }
  return (frameState) => attributionLike;
}
var Source, Source_default;
var init_Source = __esm({
  "node_modules/ol/source/Source.js"() {
    init_Object();
    init_proj();
    Source = class extends Object_default {
      /**
       * @param {Options} options Source options.
       */
      constructor(options) {
        super();
        this.projection = get3(options.projection);
        this.attributions_ = adaptAttributions(options.attributions);
        this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;
        this.loading = false;
        this.state_ = options.state !== void 0 ? options.state : "ready";
        this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
        this.interpolate_ = !!options.interpolate;
        this.viewResolver = null;
        this.viewRejector = null;
        const self2 = this;
        this.viewPromise_ = new Promise(function(resolve, reject) {
          self2.viewResolver = resolve;
          self2.viewRejector = reject;
        });
      }
      /**
       * Get the attribution function for the source.
       * @return {?Attribution} Attribution function.
       * @api
       */
      getAttributions() {
        return this.attributions_;
      }
      /**
       * @return {boolean} Attributions are collapsible.
       * @api
       */
      getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
      }
      /**
       * Get the projection of the source.
       * @return {import("../proj/Projection.js").default|null} Projection.
       * @api
       */
      getProjection() {
        return this.projection;
      }
      /**
       * @param {import("../proj/Projection").default} [projection] Projection.
       * @return {Array<number>|null} Resolutions.
       */
      getResolutions(projection) {
        return null;
      }
      /**
       * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
       */
      getView() {
        return this.viewPromise_;
      }
      /**
       * Get the state of the source, see {@link import("./Source.js").State} for possible states.
       * @return {import("./Source.js").State} State.
       * @api
       */
      getState() {
        return this.state_;
      }
      /**
       * @return {boolean|undefined} Wrap X.
       */
      getWrapX() {
        return this.wrapX_;
      }
      /**
       * @return {boolean} Use linear interpolation when resampling.
       */
      getInterpolate() {
        return this.interpolate_;
      }
      /**
       * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
       * @api
       */
      refresh() {
        this.changed();
      }
      /**
       * Set the attributions of the source.
       * @param {AttributionLike|undefined} attributions Attributions.
       *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
       *     or `undefined`.
       * @api
       */
      setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
      }
      /**
       * Set the state of the source.
       * @param {import("./Source.js").State} state State.
       */
      setState(state) {
        this.state_ = state;
        this.changed();
      }
    };
    Source_default = Source;
  }
});

// node_modules/ol/source/Tile.js
var TileSource, TileSourceEvent, Tile_default4;
var init_Tile4 = __esm({
  "node_modules/ol/source/Tile.js"() {
    init_Event();
    init_size();
    init_tilecoord();
    init_tilegrid();
    init_util();
    init_Source();
    TileSource = class extends Source_default {
      /**
       * @param {Options} options SourceTile source options.
       */
      constructor(options) {
        super({
          attributions: options.attributions,
          attributionsCollapsible: options.attributionsCollapsible,
          projection: options.projection,
          state: options.state,
          wrapX: options.wrapX,
          interpolate: options.interpolate
        });
        this.on;
        this.once;
        this.un;
        this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
        this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
        const tileSize = [256, 256];
        if (this.tileGrid) {
          toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
        }
        this.tmpSize = [0, 0];
        this.key_ = options.key || getUid(this);
        this.tileOptions = {
          transition: options.transition,
          interpolate: options.interpolate
        };
        this.zDirection = options.zDirection ? options.zDirection : 0;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       */
      getGutterForProjection(projection) {
        return 0;
      }
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       */
      getKey() {
        return this.key_;
      }
      /**
       * Set the value to be used as the key for all tiles in the source.
       * @param {string} key The key for tiles.
       * @protected
       */
      setKey(key) {
        if (this.key_ !== key) {
          this.key_ = key;
          this.changed();
        }
      }
      /**
       * @param {import("../proj/Projection").default} [projection] Projection.
       * @return {Array<number>|null} Resolutions.
       * @override
       */
      getResolutions(projection) {
        const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
        if (!tileGrid) {
          return null;
        }
        return tileGrid.getResolutions();
      }
      /**
       * @abstract
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {TileType|null} Tile.
       */
      getTile(z3, x5, y4, pixelRatio, projection) {
        return abstract();
      }
      /**
       * Return the tile grid of the tile source.
       * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
       * @api
       */
      getTileGrid() {
        return this.tileGrid;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       */
      getTileGridForProjection(projection) {
        if (!this.tileGrid) {
          return getForProjection(projection);
        }
        return this.tileGrid;
      }
      /**
       * Get the tile pixel ratio for this source. Subclasses may override this
       * method, which is meant to return a supported pixel ratio that matches the
       * provided `pixelRatio` as close as possible.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Tile pixel ratio.
       */
      getTilePixelRatio(pixelRatio) {
        return this.tilePixelRatio_;
      }
      /**
       * @param {number} z Z.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../size.js").Size} Tile size.
       */
      getTilePixelSize(z3, pixelRatio, projection) {
        const tileGrid = this.getTileGridForProjection(projection);
        const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
        const tileSize = toSize(tileGrid.getTileSize(z3), this.tmpSize);
        if (tilePixelRatio == 1) {
          return tileSize;
        }
        return scale(tileSize, tilePixelRatio, this.tmpSize);
      }
      /**
       * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
       * is outside the resolution and extent range of the tile grid, `null` will be
       * returned.
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../proj/Projection.js").default} [projection] Projection.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
       *     null if no tile URL should be created for the passed `tileCoord`.
       */
      getTileCoordForTileUrlFunction(tileCoord, projection) {
        const gridProjection = projection !== void 0 ? projection : this.getProjection();
        const tileGrid = projection !== void 0 ? this.getTileGridForProjection(gridProjection) : this.tileGrid || this.getTileGridForProjection(gridProjection);
        if (this.getWrapX() && gridProjection.isGlobal()) {
          tileCoord = wrapX2(tileGrid, tileCoord, gridProjection);
        }
        return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
      }
      /**
       * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
       * @api
       */
      clear() {
      }
      /**
       * @override
       */
      refresh() {
        this.clear();
        super.refresh();
      }
    };
    TileSourceEvent = class extends Event_default {
      /**
       * @param {string} type Type.
       * @param {import("../Tile.js").default} tile The tile.
       */
      constructor(type, tile) {
        super(type);
        this.tile = tile;
      }
    };
    Tile_default4 = TileSource;
  }
});

// node_modules/ol/source/TileEventType.js
var TileEventType_default;
var init_TileEventType = __esm({
  "node_modules/ol/source/TileEventType.js"() {
    TileEventType_default = {
      /**
       * Triggered when a tile starts loading.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
       * @api
       */
      TILELOADSTART: "tileloadstart",
      /**
       * Triggered when a tile finishes loading, either when its data is loaded,
       * or when loading was aborted because the tile is no longer needed.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadend
       * @api
       */
      TILELOADEND: "tileloadend",
      /**
       * Triggered if tile loading results in an error. Note that this is not the
       * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
       * for details.
       * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
       * @api
       */
      TILELOADERROR: "tileloaderror"
    };
  }
});

// node_modules/ol/source/UrlTile.js
var UrlTile, UrlTile_default;
var init_UrlTile = __esm({
  "node_modules/ol/source/UrlTile.js"() {
    init_TileState();
    init_tileurlfunction();
    init_uri();
    init_util();
    init_Tile4();
    init_TileEventType();
    UrlTile = class _UrlTile extends Tile_default4 {
      /**
       * @param {Options} options Image tile options.
       */
      constructor(options) {
        super({
          attributions: options.attributions,
          cacheSize: options.cacheSize,
          projection: options.projection,
          state: options.state,
          tileGrid: options.tileGrid,
          tilePixelRatio: options.tilePixelRatio,
          wrapX: options.wrapX,
          transition: options.transition,
          interpolate: options.interpolate,
          key: options.key,
          attributionsCollapsible: options.attributionsCollapsible,
          zDirection: options.zDirection
        });
        this.generateTileUrlFunction_ = this.tileUrlFunction === _UrlTile.prototype.tileUrlFunction;
        this.tileLoadFunction = options.tileLoadFunction;
        if (options.tileUrlFunction) {
          this.tileUrlFunction = options.tileUrlFunction;
        }
        this.urls = null;
        if (options.urls) {
          this.setUrls(options.urls);
        } else if (options.url) {
          this.setUrl(options.url);
        }
        this.tileLoadingKeys_ = {};
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Return the tile load function of the source.
       * @return {import("../Tile.js").LoadFunction} TileLoadFunction
       * @api
       */
      getTileLoadFunction() {
        return this.tileLoadFunction;
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Return the tile URL function of the source.
       * @return {import("../Tile.js").UrlFunction} TileUrlFunction
       * @api
       */
      getTileUrlFunction() {
        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Return the URLs used for this source.
       * When a tileUrlFunction is used instead of url or urls,
       * null will be returned.
       * @return {!Array<string>|null} URLs.
       * @api
       */
      getUrls() {
        return this.urls;
      }
      /**
       * Handle tile change events.
       * @param {import("../events/Event.js").default} event Event.
       * @protected
       */
      handleTileChange(event) {
        const tile = (
          /** @type {import("../Tile.js").default} */
          event.target
        );
        const uid = getUid(tile);
        const tileState = tile.getState();
        let type;
        if (tileState == TileState_default.LOADING) {
          this.tileLoadingKeys_[uid] = true;
          type = TileEventType_default.TILELOADSTART;
        } else if (uid in this.tileLoadingKeys_) {
          delete this.tileLoadingKeys_[uid];
          type = tileState == TileState_default.ERROR ? TileEventType_default.TILELOADERROR : tileState == TileState_default.LOADED ? TileEventType_default.TILELOADEND : void 0;
        }
        if (type != void 0) {
          this.dispatchEvent(new TileSourceEvent(type, tile));
        }
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Set the tile load function of the source.
       * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
       * @api
       */
      setTileLoadFunction(tileLoadFunction) {
        this.tileLoadFunction = tileLoadFunction;
        this.changed();
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Set the tile URL function of the source.
       * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
       * @param {string} [key] Optional new tile key for the source.
       * @api
       */
      setTileUrlFunction(tileUrlFunction, key) {
        this.tileUrlFunction = tileUrlFunction;
        if (typeof key !== "undefined") {
          this.setKey(key);
        } else {
          this.changed();
        }
      }
      /**
       * Set the URL to use for requests.
       * @param {string} url URL.
       * @api
       */
      setUrl(url) {
        const urls = expandUrl(url);
        this.urls = urls;
        this.setUrls(urls);
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Set the URLs to use for requests.
       * @param {Array<string>} urls URLs.
       * @api
       */
      setUrls(urls) {
        this.urls = urls;
        const key = urls.join("\n");
        if (this.generateTileUrlFunction_) {
          this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
        } else {
          this.setKey(key);
        }
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      tileUrlFunction(tileCoord, pixelRatio, projection) {
        return void 0;
      }
    };
    UrlTile_default = UrlTile;
  }
});

// node_modules/ol/source/TileImage.js
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
var TileImage, TileImage_default;
var init_TileImage = __esm({
  "node_modules/ol/source/TileImage.js"() {
    init_ImageTile();
    init_TileState();
    init_EventType();
    init_proj();
    init_Tile2();
    init_tilegrid();
    init_util();
    init_UrlTile();
    TileImage = class extends UrlTile_default {
      /**
       * @param {!Options} options Image tile options.
       */
      constructor(options) {
        super({
          attributions: options.attributions,
          cacheSize: options.cacheSize,
          projection: options.projection,
          state: options.state,
          tileGrid: options.tileGrid,
          tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
          tilePixelRatio: options.tilePixelRatio,
          tileUrlFunction: options.tileUrlFunction,
          url: options.url,
          urls: options.urls,
          wrapX: options.wrapX,
          transition: options.transition,
          interpolate: options.interpolate !== void 0 ? options.interpolate : true,
          key: options.key,
          attributionsCollapsible: options.attributionsCollapsible,
          zDirection: options.zDirection
        });
        this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
        this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile_default;
        this.tileGridForProjection = {};
        this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
        this.renderReprojectionEdges_ = false;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       * @override
       */
      getGutterForProjection(projection) {
        if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
          return 0;
        }
        return this.getGutter();
      }
      /**
       * @return {number} Gutter.
       */
      getGutter() {
        return 0;
      }
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       * @override
       */
      getKey() {
        let key = super.getKey();
        if (!this.getInterpolate()) {
          key += ":disable-interpolation";
        }
        return key;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       * @override
       */
      getTileGridForProjection(projection) {
        const thisProj = this.getProjection();
        if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
          return this.tileGrid;
        }
        const projKey = getUid(projection);
        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = getForProjection(projection);
        }
        return this.tileGridForProjection[projKey];
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {string} key The key set on the tile.
       * @return {!ImageTile} Tile.
       * @private
       */
      createTile_(z3, x5, y4, pixelRatio, projection, key) {
        const tileCoord = [z3, x5, y4];
        const urlTileCoord = this.getTileCoordForTileUrlFunction(
          tileCoord,
          projection
        );
        const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
        const tile = new this.tileClass(
          tileCoord,
          tileUrl !== void 0 ? TileState_default.IDLE : TileState_default.EMPTY,
          tileUrl !== void 0 ? tileUrl : "",
          this.crossOrigin,
          this.tileLoadFunction,
          this.tileOptions
        );
        tile.key = key;
        tile.addEventListener(EventType_default.CHANGE, this.handleTileChange.bind(this));
        return tile;
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!(ImageTile|ReprojTile)} Tile.
       * @override
       */
      getTile(z3, x5, y4, pixelRatio, projection) {
        const sourceProjection = this.getProjection();
        if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
          return this.getTileInternal(
            z3,
            x5,
            y4,
            pixelRatio,
            sourceProjection || projection
          );
        }
        const tileCoord = [z3, x5, y4];
        const key = this.getKey();
        const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        const targetTileGrid = this.getTileGridForProjection(projection);
        const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
          tileCoord,
          projection
        );
        const tile = new Tile_default2(
          sourceProjection,
          sourceTileGrid,
          projection,
          targetTileGrid,
          tileCoord,
          wrappedTileCoord,
          this.getTilePixelRatio(pixelRatio),
          this.getGutter(),
          (z4, x6, y5, pixelRatio2) => this.getTileInternal(z4, x6, y5, pixelRatio2, sourceProjection),
          this.reprojectionErrorThreshold_,
          this.renderReprojectionEdges_,
          this.tileOptions
        );
        tile.key = key;
        return tile;
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {!import("../proj/Projection.js").default} projection Projection.
       * @return {!ImageTile} Tile.
       * @protected
       */
      getTileInternal(z3, x5, y4, pixelRatio, projection) {
        const key = this.getKey();
        return this.createTile_(z3, x5, y4, pixelRatio, projection, key);
      }
      /**
       * Sets whether to render reprojection edges or not (usually for debugging).
       * @param {boolean} render Render the edges.
       * @api
       */
      setRenderReprojectionEdges(render2) {
        if (this.renderReprojectionEdges_ == render2) {
          return;
        }
        this.renderReprojectionEdges_ = render2;
        this.changed();
      }
      /**
       * Sets the tile grid to use when reprojecting the tiles to the given
       * projection instead of the default tile grid for the projection.
       *
       * This can be useful when the default tile grid cannot be created
       * (e.g. projection has no extent defined) or
       * for optimization reasons (custom tile size, resolutions, ...).
       *
       * @param {import("../proj.js").ProjectionLike} projection Projection.
       * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
       * @api
       */
      setTileGridForProjection(projection, tilegrid) {
        const proj = get3(projection);
        if (proj) {
          const projKey = getUid(proj);
          if (!(projKey in this.tileGridForProjection)) {
            this.tileGridForProjection[projKey] = tilegrid;
          }
        }
      }
    };
    TileImage_default = TileImage;
  }
});

// node_modules/ol/source/XYZ.js
var XYZ, XYZ_default;
var init_XYZ = __esm({
  "node_modules/ol/source/XYZ.js"() {
    init_tilegrid();
    init_TileImage();
    XYZ = class extends TileImage_default {
      /**
       * @param {Options} [options] XYZ options.
       */
      constructor(options) {
        options = options || {};
        const projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
        const tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
          extent: extentFromProjection(projection),
          maxResolution: options.maxResolution,
          maxZoom: options.maxZoom,
          minZoom: options.minZoom,
          tileSize: options.tileSize
        });
        super({
          attributions: options.attributions,
          cacheSize: options.cacheSize,
          crossOrigin: options.crossOrigin,
          interpolate: options.interpolate,
          projection,
          reprojectionErrorThreshold: options.reprojectionErrorThreshold,
          tileGrid,
          tileLoadFunction: options.tileLoadFunction,
          tilePixelRatio: options.tilePixelRatio,
          tileUrlFunction: options.tileUrlFunction,
          url: options.url,
          urls: options.urls,
          wrapX: options.wrapX !== void 0 ? options.wrapX : true,
          transition: options.transition,
          attributionsCollapsible: options.attributionsCollapsible,
          zDirection: options.zDirection
        });
        this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
      }
      /**
       * @return {number} Gutter.
       * @override
       */
      getGutter() {
        return this.gutter_;
      }
    };
    XYZ_default = XYZ;
  }
});

// .svelte-kit/output/server/chunks/constants.js
var m4;
var init_constants2 = __esm({
  ".svelte-kit/output/server/chunks/constants.js"() {
    init_Tile3();
    init_XYZ();
    init_proj();
    fromLonLat2([106.70098, 10.77653]);
    m4 = [{ key: "g-streets", label: "Google Maps", layer: () => new Tile_default3({ source: new XYZ_default({ urls: ["https://mt0.google.com/vt/lyrs=m&x={x}&y={y}&z={z}", "https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}", "https://mt2.google.com/vt/lyrs=m&x={x}&y={y}&z={z}", "https://mt3.google.com/vt/lyrs=m&x={x}&y={y}&z={z}"], attributions: "Tiles \xA9 Google", maxZoom: 22, crossOrigin: "anonymous" }), visible: true, properties: { name: "g-streets", base: true }, zIndex: 0 }) }, { key: "g-satellite", label: "Google Satellite", layer: () => new Tile_default3({ source: new XYZ_default({ urls: ["https://mt0.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", "https://mt2.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", "https://mt3.google.com/vt/lyrs=s&x={x}&y={y}&z={z}"], attributions: "Tiles \xA9 Google", maxZoom: 22, crossOrigin: "anonymous" }), visible: false, properties: { name: "g-satellite", base: true }, zIndex: 0 }) }];
  }
});

// .svelte-kit/output/server/entries/pages/_page.svelte.js
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => x4
});
function x4(r4, y4) {
  r4.component((a4) => {
    let l5, i4, u6 = false, v4 = [], g3 = [], c6 = "all";
    if (l5 = Array.from(new Set(v4.map((e3) => e3.type).filter(Boolean))).sort(), i4 = Array.from(new Set(g3.map((e3) => e3.type).filter(Boolean))).sort(), ct2(a4, (e3) => {
      e3.title((t3) => {
        t3.push("<title>Vietnam Map Archive \u2014 Historical Maps of Vietnam</title>");
      }), e3.push('<meta name="description" content="Explore georeferenced historical maps of Vietnam. Overlay vintage cartography on modern basemaps, track your location through history." class="svelte-1uha8ag"/> <link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet" class="svelte-1uha8ag"/>');
    }), a4.push(`<div${lt2("page svelte-1uha8ag", void 0, { mounted: u6 })}><header class="hero svelte-1uha8ag"><div class="hero-content svelte-1uha8ag"><div class="hero-icon svelte-1uha8ag">\u{1F5FA}\uFE0F</div> <h1 class="hero-title svelte-1uha8ag">Vietnam Map Archive</h1> <p class="hero-subtitle svelte-1uha8ag">Explore historical maps of Vietnam overlaid on the modern world</p></div> <div class="hero-decoration svelte-1uha8ag"></div></header> <main class="main svelte-1uha8ag"><section class="features svelte-1uha8ag"><a href="/trip" class="feature-card featured svelte-1uha8ag"><div class="feature-icon svelte-1uha8ag">\u{1F4CD}</div> <div class="feature-content svelte-1uha8ag"><h2 class="feature-title svelte-1uha8ag">Viewer</h2> <p class="feature-description svelte-1uha8ag">Walk through history with real-time GPS tracking on vintage maps.
						See where you are on maps from decades past.</p> <span class="feature-cta svelte-1uha8ag"><span class="cta-text svelte-1uha8ag">Start Exploring</span> <span class="cta-arrow svelte-1uha8ag">\u2192</span></span></div></a> <a href="/temp-viewer" class="feature-card svelte-1uha8ag"><div class="feature-icon svelte-1uha8ag">\u{1F5BC}\uFE0F</div> <div class="feature-content svelte-1uha8ag"><h2 class="feature-title svelte-1uha8ag">Studio <span class="beta-badge svelte-1uha8ag">Beta</span></h2> <p class="feature-description svelte-1uha8ag">Browse and annotate historical maps. Draw points, lines, and regions
						to mark places of interest.</p> <span class="feature-cta svelte-1uha8ag"><span class="cta-text svelte-1uha8ag">Open Studio</span> <span class="cta-arrow svelte-1uha8ag">\u2192</span></span></div></a></section> <section class="maps-section svelte-1uha8ag"><div class="section-header svelte-1uha8ag"><span class="section-icon svelte-1uha8ag">\u{1F5FA}\uFE0F</span> <h2 class="section-title svelte-1uha8ag">Featured Maps</h2></div> `), i4.length > 1) {
      a4.push("<!--[-->"), a4.push(`<div class="city-filter svelte-1uha8ag"><button${lt2("city-filter-btn svelte-1uha8ag", void 0, { active: c6 === "all" })}>All</button> <!--[-->`);
      const e3 = Et2(i4);
      for (let t3 = 0, o5 = e3.length; t3 < o5; t3++) {
        let s6 = e3[t3];
        a4.push(`<button${lt2("city-filter-btn svelte-1uha8ag", void 0, { active: c6 === s6 })}>${On(s6)}</button>`);
      }
      a4.push("<!--]--></div>");
    } else a4.push("<!--[!-->");
    if (a4.push("<!--]--> "), a4.push("<!--[-->"), a4.push('<div class="maps-loading svelte-1uha8ag"><span class="loading-icon svelte-1uha8ag">\u23F3</span> <span class="svelte-1uha8ag">Loading collection...</span></div>'), a4.push(`<!--]--></section> <section class="about svelte-1uha8ag"><div class="about-header svelte-1uha8ag"><span class="about-icon svelte-1uha8ag">\u2726</span> <h2 class="about-title svelte-1uha8ag">About This Project</h2></div> <p class="about-text svelte-1uha8ag">Vietnam Map Archive brings historical cartography to life by georeferencing vintage maps
				and overlaying them on modern satellite imagery. Using the <a href="https://allmaps.org" target="_blank" rel="noopener" class="svelte-1uha8ag">Allmaps</a> platform,
				we transform static historical documents into interactive explorations of how places have changed over time.</p> <p class="about-text svelte-1uha8ag">Our collection spans maps of Saigon, Hanoi, Hu\u1EBF, \u0110\xE0 N\u1EB5ng, and other Vietnamese cities
				from various periods of history.</p></section> `), l5.length > 0) {
      a4.push("<!--[-->"), a4.push('<section class="cities svelte-1uha8ag"><div class="cities-header svelte-1uha8ag"><span class="cities-icon svelte-1uha8ag">\u{1F3DB}\uFE0F</span> <h2 class="cities-title svelte-1uha8ag">Browse by City</h2></div> <div class="cities-grid svelte-1uha8ag"><!--[-->');
      const e3 = Et2(l5);
      for (let t3 = 0, o5 = e3.length; t3 < o5; t3++) {
        let s6 = e3[t3];
        a4.push(`<a${W2("href", `/trip?city=${ut2(encodeURIComponent(s6))}`)} class="city-tag svelte-1uha8ag">${On(s6)}</a>`);
      }
      a4.push("<!--]--></div></section>");
    } else a4.push("<!--[!-->");
    a4.push('<!--]--></main> <footer class="footer svelte-1uha8ag"><div class="footer-content svelte-1uha8ag"><p class="footer-text svelte-1uha8ag">Built with <a href="https://allmaps.org" target="_blank" rel="noopener" class="svelte-1uha8ag">Allmaps</a>, <a href="https://openlayers.org" target="_blank" rel="noopener" class="svelte-1uha8ag">OpenLayers</a>, and <a href="https://svelte.dev" target="_blank" rel="noopener" class="svelte-1uha8ag">SvelteKit</a></p> <p class="footer-contact svelte-1uha8ag">Contact: <a href="mailto:vietnamma.project@gmail.com" class="svelte-1uha8ag">vietnamma.project@gmail.com</a></p></div></footer></div>');
  });
}
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_page.svelte.js"() {
    init_index2();
    init_constants2();
    init_context();
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  stylesheets: () => stylesheets3,
  universal: () => universal,
  universal_id: () => universal_id
});
var index3, component_cache3, component3, universal, universal_id, imports3, stylesheets3, fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    index3 = 2;
    component3 = async () => component_cache3 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default;
    universal = {
      "ssr": false
    };
    universal_id = "src/routes/+page.ts";
    imports3 = ["_app/immutable/nodes/2.WHlDI9qe.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/CUqaGiYm.js", "_app/immutable/chunks/obLiwMeQ.js", "_app/immutable/chunks/6ds4e1Hj.js", "_app/immutable/chunks/uRYNcqzp.js", "_app/immutable/chunks/iPpcYJ_L.js", "_app/immutable/chunks/d6K977q5.js"];
    stylesheets3 = ["_app/immutable/assets/2.CSh8h2Ha.css"];
    fonts3 = [];
  }
});

// .svelte-kit/output/server/chunks/ol.js
function s4(o5) {
  Y.r.on_destroy(o5);
}
var init_ol = __esm({
  ".svelte-kit/output/server/chunks/ol.js"() {
    init_context();
  }
});

// node_modules/ol/Feature.js
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(
      typeof /** @type {?} */
      obj.getZIndex === "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    );
    const style = (
      /** @type {import("./style/Style.js").default} */
      obj
    );
    styles = [style];
  }
  return function() {
    return styles;
  };
}
var Feature, Feature_default;
var init_Feature = __esm({
  "node_modules/ol/Feature.js"() {
    init_Object();
    init_asserts();
    init_EventType();
    init_events();
    Feature = class _Feature extends Object_default {
      /**
       * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
       *     You may pass a Geometry object directly, or an object literal containing
       *     properties. If you pass an object literal, you may include a Geometry
       *     associated with a `geometry` key.
       */
      constructor(geometryOrProperties) {
        super();
        this.on;
        this.once;
        this.un;
        this.id_ = void 0;
        this.geometryName_ = "geometry";
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
          if (typeof /** @type {?} */
          geometryOrProperties.getSimplifiedGeometry === "function") {
            const geometry = (
              /** @type {Geometry} */
              geometryOrProperties
            );
            this.setGeometry(geometry);
          } else {
            const properties = geometryOrProperties;
            this.setProperties(properties);
          }
        }
      }
      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {Feature<Geometry>} The clone.
       * @api
       */
      clone() {
        const clone = (
          /** @type {Feature<Geometry>} */
          new _Feature(this.hasProperties() ? this.getProperties() : null)
        );
        clone.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) {
          clone.setGeometry(
            /** @type {Geometry} */
            geometry.clone()
          );
        }
        const style = this.getStyle();
        if (style) {
          clone.setStyle(style);
        }
        return clone;
      }
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      getGeometry() {
        return (
          /** @type {Geometry|undefined} */
          this.get(this.geometryName_)
        );
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      getGeometryName() {
        return this.geometryName_;
      }
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @private
       */
      handleGeometryChange_() {
        this.changed();
      }
      /**
       * @private
       */
      handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
          unlistenByKey(this.geometryChangeKey_);
          this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) {
          this.geometryChangeKey_ = listen(
            geometry,
            EventType_default.CHANGE,
            this.handleGeometryChange_,
            this
          );
        }
        this.changed();
      }
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
      }
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
        this.changed();
      }
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setId(id) {
        this.id_ = id;
        this.changed();
      }
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
      }
    };
    Feature_default = Feature;
  }
});

// node_modules/ol/geom/flat/center.js
function linearRingss2(flatCoordinates, offset, endss, stride) {
  const flatCenters = [];
  let extent = createEmpty();
  for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
    const ends = endss[i4];
    extent = createOrUpdateFromFlatCoordinates(
      flatCoordinates,
      offset,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}
var init_center = __esm({
  "node_modules/ol/geom/flat/center.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/flat/interpolate.js
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
  let o5, t3;
  const n3 = (end - offset) / stride;
  if (n3 === 1) {
    o5 = offset;
  } else if (n3 === 2) {
    o5 = offset;
    t3 = fraction;
  } else if (n3 !== 0) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i4 = offset + stride; i4 < end; i4 += stride) {
      const x22 = flatCoordinates[i4];
      const y22 = flatCoordinates[i4 + 1];
      length += Math.sqrt((x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1));
      cumulativeLengths.push(length);
      x1 = x22;
      y1 = y22;
    }
    const target = fraction * length;
    const index6 = binarySearch(cumulativeLengths, target);
    if (index6 < 0) {
      t3 = (target - cumulativeLengths[-index6 - 2]) / (cumulativeLengths[-index6 - 1] - cumulativeLengths[-index6 - 2]);
      o5 = offset + (-index6 - 2) * stride;
    } else {
      o5 = offset + index6 * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i4 = 0; i4 < dimension; ++i4) {
    dest[i4] = o5 === void 0 ? NaN : t3 === void 0 ? flatCoordinates[o5 + i4] : lerp(flatCoordinates[o5 + i4], flatCoordinates[o5 + stride + i4], t3);
  }
  return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m5, extrapolate) {
  if (end == offset) {
    return null;
  }
  let coordinate;
  if (m5 < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m5;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[end - 1] < m5) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m5;
      return coordinate;
    }
    return null;
  }
  if (m5 == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  let lo = offset / stride;
  let hi = end / stride;
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (m5 < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  const m0 = flatCoordinates[lo * stride - 1];
  if (m5 == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  const m1 = flatCoordinates[(lo + 1) * stride - 1];
  const t3 = (m5 - m0) / (m1 - m0);
  coordinate = [];
  for (let i4 = 0; i4 < stride - 1; ++i4) {
    coordinate.push(
      lerp(
        flatCoordinates[(lo - 1) * stride + i4],
        flatCoordinates[lo * stride + i4],
        t3
      )
    );
  }
  coordinate.push(m5);
  return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m5, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates,
      offset,
      ends[ends.length - 1],
      stride,
      m5,
      extrapolate
    );
  }
  let coordinate;
  if (m5 < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m5;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m5) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m5;
      return coordinate;
    }
    return null;
  }
  for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
    const end = ends[i4];
    if (offset == end) {
      continue;
    }
    if (m5 < flatCoordinates[offset + stride - 1]) {
      return null;
    }
    if (m5 <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates,
        offset,
        end,
        stride,
        m5,
        false
      );
    }
    offset = end;
  }
  return null;
}
var init_interpolate = __esm({
  "node_modules/ol/geom/flat/interpolate.js"() {
    init_array();
    init_math();
  }
});

// node_modules/ol/geom/GeometryCollection.js
function cloneGeometries(geometries) {
  return geometries.map((geometry) => geometry.clone());
}
var GeometryCollection, GeometryCollection_default;
var init_GeometryCollection = __esm({
  "node_modules/ol/geom/GeometryCollection.js"() {
    init_EventType();
    init_events();
    init_extent();
    init_Geometry();
    GeometryCollection = class _GeometryCollection extends Geometry_default {
      /**
       * @param {Array<Geometry>} geometries Geometries.
       */
      constructor(geometries) {
        super();
        this.geometries_ = geometries;
        this.changeEventsKeys_ = [];
        this.listenGeometriesChange_();
      }
      /**
       * @private
       */
      unlistenGeometriesChange_() {
        this.changeEventsKeys_.forEach(unlistenByKey);
        this.changeEventsKeys_.length = 0;
      }
      /**
       * @private
       */
      listenGeometriesChange_() {
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          this.changeEventsKeys_.push(
            listen(geometries[i4], EventType_default.CHANGE, this.changed, this)
          );
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!GeometryCollection} Clone.
       * @api
       * @override
       */
      clone() {
        const geometryCollection = new _GeometryCollection(
          cloneGeometries(this.geometries_)
        );
        geometryCollection.applyProperties(this);
        return geometryCollection;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x5, y4, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x5, y4)) {
          return minSquaredDistance;
        }
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          minSquaredDistance = geometries[i4].closestPointXY(
            x5,
            y4,
            closestPoint,
            minSquaredDistance
          );
        }
        return minSquaredDistance;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x5, y4) {
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          if (geometries[i4].containsXY(x5, y4)) {
            return true;
          }
        }
        return false;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        createOrUpdateEmpty(extent);
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          extend2(extent, geometries[i4].getExtent());
        }
        return extent;
      }
      /**
       * Return the geometries that make up this geometry collection.
       * @return {Array<Geometry>} Geometries.
       * @api
       */
      getGeometries() {
        return cloneGeometries(this.geometries_);
      }
      /**
       * @return {Array<Geometry>} Geometries.
       */
      getGeometriesArray() {
        return this.geometries_;
      }
      /**
       * @return {Array<Geometry>} Geometries.
       */
      getGeometriesArrayRecursive() {
        let geometriesArray = [];
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          if (geometries[i4].getType() === this.getType()) {
            geometriesArray = geometriesArray.concat(
              /** @type {GeometryCollection} */
              geometries[i4].getGeometriesArrayRecursive()
            );
          } else {
            geometriesArray.push(geometries[i4]);
          }
        }
        return geometriesArray;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {GeometryCollection} Simplified GeometryCollection.
       * @override
       */
      getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }
        const simplifiedGeometries = [];
        const geometries = this.geometries_;
        let simplified = false;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          const geometry = geometries[i4];
          const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
          simplifiedGeometries.push(simplifiedGeometry);
          if (simplifiedGeometry !== geometry) {
            simplified = true;
          }
        }
        if (simplified) {
          const simplifiedGeometryCollection = new _GeometryCollection(
            simplifiedGeometries
          );
          return simplifiedGeometryCollection;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "GeometryCollection";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          if (geometries[i4].intersectsExtent(extent)) {
            return true;
          }
        }
        return false;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return this.geometries_.length === 0;
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       * @override
       */
      rotate(angle, anchor) {
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          geometries[i4].rotate(angle, anchor);
        }
        this.changed();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       * @override
       */
      scale(sx, sy, anchor) {
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          geometries[i4].scale(sx, sy, anchor);
        }
        this.changed();
      }
      /**
       * Set the geometries that make up this geometry collection.
       * @param {Array<Geometry>} geometries Geometries.
       * @api
       */
      setGeometries(geometries) {
        this.setGeometriesArray(cloneGeometries(geometries));
      }
      /**
       * @param {Array<Geometry>} geometries Geometries.
       */
      setGeometriesArray(geometries) {
        this.unlistenGeometriesChange_();
        this.geometries_ = geometries;
        this.listenGeometriesChange_();
        this.changed();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       * @override
       */
      applyTransform(transformFn) {
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          geometries[i4].applyTransform(transformFn);
        }
        this.changed();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       * @override
       */
      translate(deltaX, deltaY) {
        const geometries = this.geometries_;
        for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
          geometries[i4].translate(deltaX, deltaY);
        }
        this.changed();
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        this.unlistenGeometriesChange_();
        super.disposeInternal();
      }
    };
    GeometryCollection_default = GeometryCollection;
  }
});

// node_modules/ol/geom/flat/length.js
function lineStringLength(flatCoordinates, offset, end, stride) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  let length = 0;
  for (let i4 = offset + stride; i4 < end; i4 += stride) {
    const x22 = flatCoordinates[i4];
    const y22 = flatCoordinates[i4 + 1];
    length += Math.sqrt((x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1));
    x1 = x22;
    y1 = y22;
  }
  return length;
}
var init_length = __esm({
  "node_modules/ol/geom/flat/length.js"() {
  }
});

// node_modules/ol/geom/LineString.js
var LineString, LineString_default;
var init_LineString = __esm({
  "node_modules/ol/geom/LineString.js"() {
    init_array();
    init_extent();
    init_SimpleGeometry();
    init_closest();
    init_deflate();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    init_length();
    init_segments();
    init_simplify();
    LineString = class _LineString extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.flatMidpoint_ = null;
        this.flatMidpointRevision_ = -1;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed coordinate to the coordinates of the linestring.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @api
       */
      appendCoordinate(coordinate) {
        extend(this.flatCoordinates, coordinate);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LineString} Clone.
       * @api
       * @override
       */
      clone() {
        const lineString = new _LineString(
          this.flatCoordinates.slice(),
          this.layout
        );
        lineString.applyProperties(this);
        return lineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x5, y4, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x5, y4)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          false,
          x5,
          y4,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
       *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */
      forEachSegment(callback) {
        return forEach(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          callback
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m5, extrapolate) {
        if (this.layout != "XYM" && this.layout != "XYZM") {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        return lineStringCoordinateAtM(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          m5,
          extrapolate
        );
      }
      /**
       * Return the coordinates of the linestring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
       * @api
       */
      getCoordinateAt(fraction, dest) {
        return interpolatePoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          fraction,
          dest,
          this.stride
        );
      }
      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */
      getLength() {
        return lineStringLength(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
          this.flatMidpoint_ = this.getCoordinateAt(
            0.5,
            this.flatMidpoint_ ?? void 0
          );
          this.flatMidpointRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatMidpoint_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LineString} Simplified LineString.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LineString(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "LineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLineString(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent,
          this.getExtent()
        );
      }
      /**
       * Set the coordinates of the linestring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LineString_default = LineString;
  }
});

// node_modules/ol/geom/MultiLineString.js
var MultiLineString, MultiLineString_default;
var init_MultiLineString = __esm({
  "node_modules/ol/geom/MultiLineString.js"() {
    init_array();
    init_extent();
    init_LineString();
    init_SimpleGeometry();
    init_closest();
    init_deflate();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    init_length();
    init_simplify();
    MultiLineString = class _MultiLineString extends SimpleGeometry_default {
      /**
       * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
       *     Coordinates or LineString geometries. (For internal use, flat coordinates in
       *     combination with `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Flat coordinate ends for internal use.
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates2[0])) {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        } else if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          const lineStrings = (
            /** @type {Array<LineString>} */
            coordinates2
          );
          const flatCoordinates = [];
          const ends2 = [];
          for (let i4 = 0, ii = lineStrings.length; i4 < ii; ++i4) {
            const lineString = lineStrings[i4];
            extend(flatCoordinates, lineString.getFlatCoordinates());
            ends2.push(flatCoordinates.length);
          }
          const layout2 = lineStrings.length === 0 ? this.getLayout() : lineStrings[0].getLayout();
          this.setFlatCoordinates(layout2, flatCoordinates);
          this.ends_ = ends2;
        }
      }
      /**
       * Append the passed linestring to the multilinestring.
       * @param {LineString} lineString LineString.
       * @api
       */
      appendLineString(lineString) {
        extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiLineString} Clone.
       * @api
       * @override
       */
      clone() {
        const multiLineString = new _MultiLineString(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        multiLineString.applyProperties(this);
        return multiLineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x5, y4, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x5, y4)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          false,
          x5,
          y4,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @param {boolean} [interpolate] Interpolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m5, extrapolate, interpolate) {
        if (this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0) {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        interpolate = interpolate !== void 0 ? interpolate : false;
        return lineStringsCoordinateAtM(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          m5,
          extrapolate,
          interpolate
        );
      }
      /**
       * Return the coordinates of the multilinestring.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinatesArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {LineString} LineString.
       * @api
       */
      getLineString(index6) {
        if (index6 < 0 || this.ends_.length <= index6) {
          return null;
        }
        return new LineString_default(
          this.flatCoordinates.slice(
            index6 === 0 ? 0 : this.ends_[index6 - 1],
            this.ends_[index6]
          ),
          this.layout
        );
      }
      /**
       * Return the linestrings of this multilinestring.
       * @return {Array<LineString>} LineStrings.
       * @api
       */
      getLineStrings() {
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const layout = this.layout;
        const lineStrings = [];
        let offset = 0;
        for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
          const end = ends[i4];
          const lineString = new LineString_default(
            flatCoordinates.slice(offset, end),
            layout
          );
          lineStrings.push(lineString);
          offset = end;
        }
        return lineStrings;
      }
      /**
       * Return the sum of all line string lengths
       * @return {number} Length (on projected plane).
       * @api
       */
      getLength() {
        const ends = this.ends_;
        let start2 = 0;
        let length = 0;
        for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
          length += lineStringLength(
            this.flatCoordinates,
            start2,
            ends[i4],
            this.stride
          );
          start2 = ends[i4];
        }
        return length;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        const midpoints = [];
        const flatCoordinates = this.flatCoordinates;
        let offset = 0;
        const ends = this.ends_;
        const stride = this.stride;
        for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
          const end = ends[i4];
          const midpoint = interpolatePoint(
            flatCoordinates,
            offset,
            end,
            stride,
            0.5
          );
          extend(midpoints, midpoint);
          offset = end;
        }
        return midpoints;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiLineString} Simplified MultiLineString.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = douglasPeuckerArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _MultiLineString(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "MultiLineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLineStringArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    MultiLineString_default = MultiLineString;
  }
});

// node_modules/ol/geom/MultiPoint.js
var MultiPoint, MultiPoint_default;
var init_MultiPoint = __esm({
  "node_modules/ol/geom/MultiPoint.js"() {
    init_array();
    init_extent();
    init_math();
    init_Point();
    init_SimpleGeometry();
    init_deflate();
    init_inflate();
    MultiPoint = class _MultiPoint extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        if (layout && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed point to this multipoint.
       * @param {Point} point Point.
       * @api
       */
      appendPoint(point) {
        extend(this.flatCoordinates, point.getFlatCoordinates());
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPoint} Clone.
       * @api
       * @override
       */
      clone() {
        const multiPoint = new _MultiPoint(
          this.flatCoordinates.slice(),
          this.layout
        );
        multiPoint.applyProperties(this);
        return multiPoint;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x5, y4, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x5, y4)) {
          return minSquaredDistance;
        }
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i4 = 0, ii = flatCoordinates.length; i4 < ii; i4 += stride) {
          const squaredDistance3 = squaredDistance(
            x5,
            y4,
            flatCoordinates[i4],
            flatCoordinates[i4 + 1]
          );
          if (squaredDistance3 < minSquaredDistance) {
            minSquaredDistance = squaredDistance3;
            for (let j3 = 0; j3 < stride; ++j3) {
              closestPoint[j3] = flatCoordinates[i4 + j3];
            }
            closestPoint.length = stride;
          }
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinates of the multipoint.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {Point} Point.
       * @api
       */
      getPoint(index6) {
        const n3 = this.flatCoordinates.length / this.stride;
        if (index6 < 0 || n3 <= index6) {
          return null;
        }
        return new Point_default(
          this.flatCoordinates.slice(
            index6 * this.stride,
            (index6 + 1) * this.stride
          ),
          this.layout
        );
      }
      /**
       * Return the points of this multipoint.
       * @return {Array<Point>} Points.
       * @api
       */
      getPoints() {
        const flatCoordinates = this.flatCoordinates;
        const layout = this.layout;
        const stride = this.stride;
        const points = [];
        for (let i4 = 0, ii = flatCoordinates.length; i4 < ii; i4 += stride) {
          const point = new Point_default(flatCoordinates.slice(i4, i4 + stride), layout);
          points.push(point);
        }
        return points;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "MultiPoint";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i4 = 0, ii = flatCoordinates.length; i4 < ii; i4 += stride) {
          const x5 = flatCoordinates[i4];
          const y4 = flatCoordinates[i4 + 1];
          if (containsXY(extent, x5, y4)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Set the coordinates of the multipoint.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    MultiPoint_default = MultiPoint;
  }
});

// node_modules/ol/geom/MultiPolygon.js
var MultiPolygon, MultiPolygon_default;
var init_MultiPolygon = __esm({
  "node_modules/ol/geom/MultiPolygon.js"() {
    init_array();
    init_extent();
    init_MultiPoint();
    init_Polygon();
    init_SimpleGeometry();
    init_area();
    init_center();
    init_closest();
    init_contains();
    init_deflate();
    init_inflate();
    init_interiorpoint();
    init_intersectsextent();
    init_orient();
    init_simplify();
    MultiPolygon = class _MultiPolygon extends SimpleGeometry_default {
      /**
       * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
       */
      constructor(coordinates2, layout, endss) {
        super();
        this.endss_ = [];
        this.flatInteriorPointsRevision_ = -1;
        this.flatInteriorPoints_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (!endss && !Array.isArray(coordinates2[0])) {
          const polygons = (
            /** @type {Array<Polygon>} */
            coordinates2
          );
          const flatCoordinates = [];
          const thisEndss = [];
          for (let i4 = 0, ii = polygons.length; i4 < ii; ++i4) {
            const polygon = polygons[i4];
            const offset = flatCoordinates.length;
            const ends = polygon.getEnds();
            for (let j3 = 0, jj = ends.length; j3 < jj; ++j3) {
              ends[j3] += offset;
            }
            extend(flatCoordinates, polygon.getFlatCoordinates());
            thisEndss.push(ends);
          }
          layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();
          coordinates2 = flatCoordinates;
          endss = thisEndss;
        }
        if (layout !== void 0 && endss) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.endss_ = endss;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed polygon to this multipolygon.
       * @param {Polygon} polygon Polygon.
       * @api
       */
      appendPolygon(polygon) {
        let ends;
        if (!this.flatCoordinates) {
          this.flatCoordinates = polygon.getFlatCoordinates().slice();
          ends = polygon.getEnds().slice();
          this.endss_.push();
        } else {
          const offset = this.flatCoordinates.length;
          extend(this.flatCoordinates, polygon.getFlatCoordinates());
          ends = polygon.getEnds().slice();
          for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
            ends[i4] += offset;
          }
        }
        this.endss_.push(ends);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPolygon} Clone.
       * @api
       * @override
       */
      clone() {
        const len = this.endss_.length;
        const newEndss = new Array(len);
        for (let i4 = 0; i4 < len; ++i4) {
          newEndss[i4] = this.endss_[i4].slice();
        }
        const multiPolygon = new _MultiPolygon(
          this.flatCoordinates.slice(),
          this.layout,
          newEndss
        );
        multiPolygon.applyProperties(this);
        return multiPolygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x5, y4, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x5, y4)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            multiArrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.endss_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestMultiArrayPoint(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          this.maxDelta_,
          true,
          x5,
          y4,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x5, y4) {
        return linearRingssContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          x5,
          y4
        );
      }
      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRingss(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
       * @api
       * @override
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRingsArray(
            flatCoordinates,
            0,
            this.endss_,
            this.stride,
            right
          );
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateMultiCoordinatesArray(
          flatCoordinates,
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * @return {Array<Array<number>>} Endss.
       */
      getEndss() {
        return this.endss_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
          const flatCenters = linearRingss2(
            this.flatCoordinates,
            0,
            this.endss_,
            this.stride
          );
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.endss_,
            this.stride,
            flatCenters
          );
          this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatInteriorPoints_
        );
      }
      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
       * @return {MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoints() {
        return new MultiPoint_default(this.getFlatInteriorPoints().slice(), "XYM");
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRingsArray(
              this.orientedFlatCoordinates_,
              0,
              this.endss_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiPolygon} Simplified MultiPolygon.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEndss = [];
        simplifiedFlatCoordinates.length = quantizeMultiArray(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEndss
        );
        return new _MultiPolygon(simplifiedFlatCoordinates, "XY", simplifiedEndss);
      }
      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {Polygon} Polygon.
       * @api
       */
      getPolygon(index6) {
        if (index6 < 0 || this.endss_.length <= index6) {
          return null;
        }
        let offset;
        if (index6 === 0) {
          offset = 0;
        } else {
          const prevEnds = this.endss_[index6 - 1];
          offset = prevEnds[prevEnds.length - 1];
        }
        const ends = this.endss_[index6].slice();
        const end = ends[ends.length - 1];
        if (offset !== 0) {
          for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
            ends[i4] -= offset;
          }
        }
        return new Polygon_default(
          this.flatCoordinates.slice(offset, end),
          this.layout,
          ends
        );
      }
      /**
       * Return the polygons of this multipolygon.
       * @return {Array<Polygon>} Polygons.
       * @api
       */
      getPolygons() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const endss = this.endss_;
        const polygons = [];
        let offset = 0;
        for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
          const ends = endss[i4].slice();
          const end = ends[ends.length - 1];
          if (offset !== 0) {
            for (let j3 = 0, jj = ends.length; j3 < jj; ++j3) {
              ends[j3] -= offset;
            }
          }
          const polygon = new Polygon_default(
            flatCoordinates.slice(offset, end),
            layout,
            ends
          );
          polygons.push(polygon);
          offset = end;
        }
        return polygons;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "MultiPolygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLinearRingMultiArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 3);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const endss = deflateMultiCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.endss_
        );
        if (endss.length === 0) {
          this.flatCoordinates.length = 0;
        } else {
          const lastEnds = endss[endss.length - 1];
          this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
      }
    };
    MultiPolygon_default = MultiPolygon;
  }
});

// node_modules/ol/geom.js
var init_geom = __esm({
  "node_modules/ol/geom.js"() {
    init_GeometryCollection();
    init_LineString();
    init_MultiLineString();
    init_MultiPoint();
    init_MultiPolygon();
    init_Point();
    init_Polygon();
  }
});

// node_modules/ol/render/Feature.js
var tmpTransform2, RenderFeature, Feature_default2;
var init_Feature2 = __esm({
  "node_modules/ol/render/Feature.js"() {
    init_array();
    init_extent();
    init_functions();
    init_center();
    init_interiorpoint();
    init_interpolate();
    init_orient();
    init_simplify();
    init_transform2();
    init_proj();
    init_transform();
    tmpTransform2 = create();
    RenderFeature = class _RenderFeature {
      /**
       * @param {Type} type Geometry type.
       * @param {Array<number>} flatCoordinates Flat coordinates. These always need
       *     to be right-handed for polygons.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Object<string, *>} properties Properties.
       * @param {number|string|undefined} id Feature id.
       */
      constructor(type, flatCoordinates, ends, stride, properties, id) {
        this.styleFunction;
        this.extent_;
        this.id_ = id;
        this.type_ = type;
        this.flatCoordinates_ = flatCoordinates;
        this.flatInteriorPoints_ = null;
        this.flatMidpoints_ = null;
        this.ends_ = ends || null;
        this.properties_ = properties;
        this.squaredTolerance_;
        this.stride_ = stride;
        this.simplifiedGeometry_;
      }
      /**
       * Get a feature property by its key.
       * @param {string} key Key
       * @return {*} Value for the requested key.
       * @api
       */
      get(key) {
        return this.properties_[key];
      }
      /**
       * Get the extent of this feature's geometry.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        if (!this.extent_) {
          this.extent_ = this.type_ === "Point" ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2
          );
        }
        return this.extent_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoints_ = getInteriorPointOfArray(
            this.flatCoordinates_,
            0,
            this.ends_,
            2,
            flatCenter,
            0
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
          const ends = inflateEnds(this.flatCoordinates_, this.ends_);
          const flatCenters = linearRingss2(this.flatCoordinates_, 0, ends, 2);
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.flatCoordinates_,
            0,
            ends,
            2,
            flatCenters
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = interpolatePoint(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            0.5
          );
        }
        return this.flatMidpoints_;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = [];
          const flatCoordinates = this.flatCoordinates_;
          let offset = 0;
          const ends = (
            /** @type {Array<number>} */
            this.ends_
          );
          for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
            const end = ends[i4];
            const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);
            extend(this.flatMidpoints_, midpoint);
            offset = end;
          }
        }
        return this.flatMidpoints_;
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is set when reading data from a remote source.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
      }
      /**
       * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
       * determining the geometry type in style function (see {@link #getType}).
       * @return {RenderFeature} Feature.
       * @api
       */
      getGeometry() {
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {RenderFeature} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return this;
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {RenderFeature} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform3) {
        return this;
      }
      /**
       * Get the feature properties.
       * @return {Object<string, *>} Feature properties.
       * @api
       */
      getProperties() {
        return this.properties_;
      }
      /**
       * Get an object of all property names and values.  This has the same behavior as getProperties,
       * but is here to conform with the {@link module:ol/Feature~Feature} interface.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.properties_;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride_;
      }
      /**
       * @return {import('../style/Style.js').StyleFunction|undefined} Style
       */
      getStyleFunction() {
        return this.styleFunction;
      }
      /**
       * Get the type of this feature's geometry.
       * @return {Type} Geometry type.
       * @api
       */
      getType() {
        return this.type_;
      }
      /**
       * Transform geometry coordinates from tile pixel space to projected.
       *
       * @param {import("../proj.js").ProjectionLike} projection The data projection
       */
      transform(projection) {
        projection = get3(projection);
        const pixelExtent = projection.getExtent();
        const projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
          const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform2,
            projectedExtent[0],
            projectedExtent[3],
            scale4,
            -scale4,
            0,
            0,
            0
          );
          transform2D(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            tmpTransform2,
            this.flatCoordinates_
          );
        }
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       */
      applyTransform(transformFn) {
        transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
      }
      /**
       * @return {RenderFeature} A cloned render feature.
       */
      clone() {
        return new _RenderFeature(
          this.type_,
          this.flatCoordinates_.slice(),
          this.ends_?.slice(),
          this.stride_,
          Object.assign({}, this.properties_),
          this.id_
        );
      }
      /**
       * @return {Array<number>|null} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Add transform and resolution based geometry simplification to this instance.
       * @return {RenderFeature} This render feature.
       */
      enableSimplifyTransformed() {
        this.simplifyTransformed = memoizeOne((squaredTolerance, transform3) => {
          if (squaredTolerance === this.squaredTolerance_) {
            return this.simplifiedGeometry_;
          }
          this.simplifiedGeometry_ = this.clone();
          if (transform3) {
            this.simplifiedGeometry_.applyTransform(transform3);
          }
          const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();
          let simplifiedEnds;
          switch (this.type_) {
            case "LineString":
              simplifiedFlatCoordinates.length = douglasPeucker(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.flatCoordinates_.length,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0
              );
              simplifiedEnds = [simplifiedFlatCoordinates.length];
              break;
            case "MultiLineString":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = douglasPeuckerArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            case "Polygon":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = quantizeArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                Math.sqrt(squaredTolerance),
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            default:
          }
          if (simplifiedEnds) {
            this.simplifiedGeometry_ = new _RenderFeature(
              this.type_,
              simplifiedFlatCoordinates,
              simplifiedEnds,
              2,
              this.properties_,
              this.id_
            );
          }
          this.squaredTolerance_ = squaredTolerance;
          return this.simplifiedGeometry_;
        });
        return this;
      }
    };
    RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
    Feature_default2 = RenderFeature;
  }
});

// node_modules/ol/format/Feature.js
function transformGeometryWithOptions(geometry, write, options) {
  const featureProjection = options ? get3(options.featureProjection) : null;
  const dataProjection = options ? get3(options.dataProjection) : null;
  let transformed = geometry;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    if (write) {
      transformed = /** @type {T} */
      geometry.clone();
    }
    const fromProjection = write ? featureProjection : dataProjection;
    const toProjection = write ? dataProjection : featureProjection;
    if (fromProjection.getUnits() === "tile-pixels") {
      transformed.transform(fromProjection, toProjection);
    } else {
      transformed.applyTransform(getTransform(fromProjection, toProjection));
    }
  }
  if (write && options && /** @type {WriteOptions} */
  options.decimals !== void 0) {
    const power = Math.pow(
      10,
      /** @type {WriteOptions} */
      options.decimals
    );
    const transform3 = function(coordinates2) {
      for (let i4 = 0, ii = coordinates2.length; i4 < ii; ++i4) {
        coordinates2[i4] = Math.round(coordinates2[i4] * power) / power;
      }
      return coordinates2;
    };
    if (transformed === geometry) {
      transformed = /** @type {T} */
      geometry.clone();
    }
    transformed.applyTransform(transform3);
  }
  return transformed;
}
function orientFlatCoordinates(flatCoordinates, ends, stride) {
  if (Array.isArray(ends[0])) {
    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {
      flatCoordinates = flatCoordinates.slice();
      orientLinearRingsArray(flatCoordinates, 0, ends, stride);
    }
    return flatCoordinates;
  }
  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {
    flatCoordinates = flatCoordinates.slice();
    orientLinearRings(flatCoordinates, 0, ends, stride);
  }
  return flatCoordinates;
}
function createRenderFeature(object, options) {
  const geometry = object.geometry;
  if (!geometry) {
    return [];
  }
  if (Array.isArray(geometry)) {
    return geometry.map((geometry2) => createRenderFeature({ ...object, geometry: geometry2 })).flat();
  }
  const geometryType = geometry.type === "MultiPolygon" ? "Polygon" : geometry.type;
  if (geometryType === "GeometryCollection" || geometryType === "Circle") {
    throw new Error("Unsupported geometry type: " + geometryType);
  }
  const stride = geometry.layout.length;
  return transformGeometryWithOptions(
    new Feature_default2(
      geometryType,
      geometryType === "Polygon" ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride) : geometry.flatCoordinates,
      geometry.ends?.flat(),
      stride,
      object.properties || {},
      object.id
    ).enableSimplifyTransformed(),
    false,
    options
  );
}
function createGeometry(object, options) {
  if (!object) {
    return null;
  }
  if (Array.isArray(object)) {
    const geometries = object.map(
      (geometry) => createGeometry(geometry, options)
    );
    return new GeometryCollection_default(geometries);
  }
  const Geometry2 = GeometryConstructor[object.type];
  return transformGeometryWithOptions(
    new Geometry2(object.flatCoordinates, object.layout || "XY", object.ends),
    false,
    options
  );
}
var FeatureFormat, Feature_default3, GeometryConstructor;
var init_Feature3 = __esm({
  "node_modules/ol/format/Feature.js"() {
    init_Feature();
    init_orient();
    init_geom();
    init_proj();
    init_Feature2();
    init_util();
    FeatureFormat = class {
      constructor() {
        this.dataProjection = void 0;
        this.defaultFeatureProjection = void 0;
        this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */
        Feature_default;
        this.supportedMediaTypes = null;
      }
      /**
       * Adds the data projection to the read options.
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Options.
       * @return {ReadOptions|undefined} Options.
       * @protected
       */
      getReadOptions(source, options) {
        if (options) {
          let dataProjection = options.dataProjection ? get3(options.dataProjection) : this.readProjection(source);
          if (options.extent && dataProjection && dataProjection.getUnits() === "tile-pixels") {
            dataProjection = get3(dataProjection);
            dataProjection.setWorldExtent(options.extent);
          }
          options = {
            dataProjection,
            featureProjection: options.featureProjection
          };
        }
        return this.adaptOptions(options);
      }
      /**
       * Sets the `dataProjection` on the options, if no `dataProjection`
       * is set.
       * @param {WriteOptions|ReadOptions|undefined} options
       *     Options.
       * @protected
       * @return {WriteOptions|ReadOptions|undefined}
       *     Updated options.
       */
      adaptOptions(options) {
        return Object.assign(
          {
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection,
            featureClass: this.featureClass
          },
          options
        );
      }
      /**
       * @abstract
       * @return {Type} The format type.
       */
      getType() {
        return abstract();
      }
      /**
       * Read a single feature from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {FeatureType|Array<FeatureType>} Feature.
       */
      readFeature(source, options) {
        return abstract();
      }
      /**
       * Read all features from a source.
       *
       * @abstract
       * @param {Document|Element|ArrayBuffer|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {Array<FeatureType>} Features.
       */
      readFeatures(source, options) {
        return abstract();
      }
      /**
       * Read a single geometry from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      readGeometry(source, options) {
        return abstract();
      }
      /**
       * Read the projection from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default|undefined} Projection.
       */
      readProjection(source) {
        return abstract();
      }
      /**
       * Encode a feature in this format.
       *
       * @abstract
       * @param {Feature} feature Feature.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */
      writeFeature(feature, options) {
        return abstract();
      }
      /**
       * Encode an array of features in this format.
       *
       * @abstract
       * @param {Array<Feature>} features Features.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */
      writeFeatures(features, options) {
        return abstract();
      }
      /**
       * Write a single geometry in this format.
       *
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */
      writeGeometry(geometry, options) {
        return abstract();
      }
    };
    Feature_default3 = FeatureFormat;
    GeometryConstructor = {
      Point: Point_default,
      LineString: LineString_default,
      Polygon: Polygon_default,
      MultiPoint: MultiPoint_default,
      MultiLineString: MultiLineString_default,
      MultiPolygon: MultiPolygon_default
    };
  }
});

// node_modules/ol/format/JSONFeature.js
function getObject(source) {
  if (typeof source === "string") {
    const object = JSON.parse(source);
    return object ? (
      /** @type {Object} */
      object
    ) : null;
  }
  if (source !== null) {
    return source;
  }
  return null;
}
var JSONFeature, JSONFeature_default;
var init_JSONFeature = __esm({
  "node_modules/ol/format/JSONFeature.js"() {
    init_util();
    init_Feature3();
    JSONFeature = class extends Feature_default3 {
      constructor() {
        super();
      }
      /**
       * @return {import("./Feature.js").Type} Format.
       * @override
       */
      getType() {
        return "json";
      }
      /**
       * Read a feature.  Only works for a single feature. Use `readFeatures` to
       * read a feature collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {FeatureType|Array<FeatureType>} Feature.
       * @api
       * @override
       */
      readFeature(source, options) {
        return this.readFeatureFromObject(
          getObject(source),
          this.getReadOptions(source, options)
        );
      }
      /**
       * Read all features.  Works with both a single feature and a feature
       * collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {Array<FeatureType>} Features.
       * @api
       * @override
       */
      readFeatures(source, options) {
        return this.readFeaturesFromObject(
          getObject(source),
          this.getReadOptions(source, options)
        );
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {FeatureType|Array<FeatureType>} Feature.
       */
      readFeatureFromObject(object, options) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {Array<FeatureType>} Features.
       */
      readFeaturesFromObject(object, options) {
        return abstract();
      }
      /**
       * Read a geometry.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       * @api
       * @override
       */
      readGeometry(source, options) {
        return this.readGeometryFromObject(
          getObject(source),
          this.getReadOptions(source, options)
        );
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      readGeometryFromObject(object, options) {
        return abstract();
      }
      /**
       * Read the projection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default} Projection.
       * @api
       * @override
       */
      readProjection(source) {
        return this.readProjectionFromObject(getObject(source));
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       */
      readProjectionFromObject(object) {
        return abstract();
      }
      /**
       * Encode a feature as string.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded feature.
       * @api
       * @override
       */
      writeFeature(feature, options) {
        return JSON.stringify(this.writeFeatureObject(feature, options));
      }
      /**
       * @abstract
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */
      writeFeatureObject(feature, options) {
        return abstract();
      }
      /**
       * Encode an array of features as string.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded features.
       * @api
       * @override
       */
      writeFeatures(features, options) {
        return JSON.stringify(this.writeFeaturesObject(features, options));
      }
      /**
       * @abstract
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */
      writeFeaturesObject(features, options) {
        return abstract();
      }
      /**
       * Encode a geometry as string.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded geometry.
       * @api
       * @override
       */
      writeGeometry(geometry, options) {
        return JSON.stringify(this.writeGeometryObject(geometry, options));
      }
      /**
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */
      writeGeometryObject(geometry, options) {
        return abstract();
      }
    };
    JSONFeature_default = JSONFeature;
  }
});

// node_modules/ol/format/GeoJSON.js
function readGeometryInternal(object, options) {
  if (!object) {
    return null;
  }
  let geometry;
  switch (object["type"]) {
    case "Point": {
      geometry = readPointGeometry(
        /** @type {GeoJSONPoint} */
        object
      );
      break;
    }
    case "LineString": {
      geometry = readLineStringGeometry(
        /** @type {GeoJSONLineString} */
        object
      );
      break;
    }
    case "Polygon": {
      geometry = readPolygonGeometry(
        /** @type {GeoJSONPolygon} */
        object
      );
      break;
    }
    case "MultiPoint": {
      geometry = readMultiPointGeometry(
        /** @type {GeoJSONMultiPoint} */
        object
      );
      break;
    }
    case "MultiLineString": {
      geometry = readMultiLineStringGeometry(
        /** @type {GeoJSONMultiLineString} */
        object
      );
      break;
    }
    case "MultiPolygon": {
      geometry = readMultiPolygonGeometry(
        /** @type {GeoJSONMultiPolygon} */
        object
      );
      break;
    }
    case "GeometryCollection": {
      geometry = readGeometryCollectionGeometry(
        /** @type {GeoJSONGeometryCollection} */
        object
      );
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object["type"]);
    }
  }
  return geometry;
}
function readGeometry(object, options) {
  const geometryObject = readGeometryInternal(object, options);
  return createGeometry(geometryObject, options);
}
function readGeometryCollectionGeometry(object, options) {
  const geometries = object["geometries"].map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */
    function(geometry) {
      return readGeometryInternal(geometry, options);
    }
  );
  return geometries;
}
function readPointGeometry(object) {
  const flatCoordinates = object["coordinates"];
  return {
    type: "Point",
    flatCoordinates,
    layout: getLayoutForStride(flatCoordinates.length)
  };
}
function readLineStringGeometry(object) {
  const coordinates2 = object["coordinates"];
  const flatCoordinates = coordinates2.flat();
  return {
    type: "LineString",
    flatCoordinates,
    ends: [flatCoordinates.length],
    layout: getLayoutForStride(coordinates2[0]?.length || 2)
  };
}
function readMultiLineStringGeometry(object) {
  const coordinates2 = object["coordinates"];
  const stride = coordinates2[0]?.[0]?.length || 2;
  const flatCoordinates = [];
  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates2, stride);
  return {
    type: "MultiLineString",
    flatCoordinates,
    ends,
    layout: getLayoutForStride(stride)
  };
}
function readMultiPointGeometry(object) {
  const coordinates2 = object["coordinates"];
  return {
    type: "MultiPoint",
    flatCoordinates: coordinates2.flat(),
    layout: getLayoutForStride(coordinates2[0]?.length || 2)
  };
}
function readMultiPolygonGeometry(object) {
  const coordinates2 = object["coordinates"];
  const flatCoordinates = [];
  const stride = coordinates2[0]?.[0]?.[0].length || 2;
  const endss = deflateMultiCoordinatesArray(
    flatCoordinates,
    0,
    coordinates2,
    stride
  );
  return {
    type: "MultiPolygon",
    flatCoordinates,
    ends: endss,
    layout: getLayoutForStride(stride)
  };
}
function readPolygonGeometry(object) {
  const coordinates2 = object["coordinates"];
  const flatCoordinates = [];
  const stride = coordinates2[0]?.[0]?.length;
  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates2, stride);
  return {
    type: "Polygon",
    flatCoordinates,
    ends,
    layout: getLayoutForStride(stride)
  };
}
function writeGeometry(geometry, options) {
  geometry = transformGeometryWithOptions(geometry, true, options);
  const type = geometry.getType();
  let geoJSON;
  switch (type) {
    case "Point": {
      geoJSON = writePointGeometry(
        /** @type {import("../geom/Point.js").default} */
        geometry,
        options
      );
      break;
    }
    case "LineString": {
      geoJSON = writeLineStringGeometry(
        /** @type {import("../geom/LineString.js").default} */
        geometry,
        options
      );
      break;
    }
    case "Polygon": {
      geoJSON = writePolygonGeometry(
        /** @type {import("../geom/Polygon.js").default} */
        geometry,
        options
      );
      break;
    }
    case "MultiPoint": {
      geoJSON = writeMultiPointGeometry(
        /** @type {import("../geom/MultiPoint.js").default} */
        geometry,
        options
      );
      break;
    }
    case "MultiLineString": {
      geoJSON = writeMultiLineStringGeometry(
        /** @type {import("../geom/MultiLineString.js").default} */
        geometry,
        options
      );
      break;
    }
    case "MultiPolygon": {
      geoJSON = writeMultiPolygonGeometry(
        /** @type {import("../geom/MultiPolygon.js").default} */
        geometry,
        options
      );
      break;
    }
    case "GeometryCollection": {
      geoJSON = writeGeometryCollectionGeometry(
        /** @type {import("../geom/GeometryCollection.js").default} */
        geometry,
        options
      );
      break;
    }
    case "Circle": {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, options) {
  options = Object.assign({}, options);
  delete options.featureProjection;
  const geometries = geometry.getGeometriesArray().map(function(geometry2) {
    return writeGeometry(geometry2, options);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry(geometry, options) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry(geometry, options) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry(geometry, options) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry(geometry, options) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
var GeoJSON, GeoJSON_default;
var init_GeoJSON = __esm({
  "node_modules/ol/format/GeoJSON.js"() {
    init_Feature();
    init_SimpleGeometry();
    init_deflate();
    init_obj();
    init_proj();
    init_Feature2();
    init_Feature3();
    init_JSONFeature();
    GeoJSON = class extends JSONFeature_default {
      /**
       * @param {Options<FeatureType>} [options] Options.
       */
      constructor(options) {
        options = options ? options : {};
        super();
        this.dataProjection = get3(
          options.dataProjection ? options.dataProjection : "EPSG:4326"
        );
        if (options.featureProjection) {
          this.defaultFeatureProjection = get3(options.featureProjection);
        }
        if (options.featureClass) {
          this.featureClass = options.featureClass;
        }
        this.geometryName_ = options.geometryName;
        this.extractGeometryName_ = options.extractGeometryName;
        this.supportedMediaTypes = [
          "application/geo+json",
          "application/vnd.geo+json"
        ];
      }
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {FeatureType|Array<FeatureType>} Feature.
       * @override
       */
      readFeatureFromObject(object, options) {
        let geoJSONFeature = null;
        if (object["type"] === "Feature") {
          geoJSONFeature = /** @type {GeoJSONFeature} */
          object;
        } else {
          geoJSONFeature = {
            "type": "Feature",
            "geometry": (
              /** @type {GeoJSONGeometry} */
              object
            ),
            "properties": null
          };
        }
        const geometry = readGeometryInternal(geoJSONFeature["geometry"], options);
        if (this.featureClass === Feature_default2) {
          return (
            /** @type {FeatureType|Array<FeatureType>} */
            createRenderFeature(
              {
                geometry,
                id: geoJSONFeature["id"],
                properties: geoJSONFeature["properties"]
              },
              options
            )
          );
        }
        const feature = new Feature_default();
        if (this.geometryName_) {
          feature.setGeometryName(this.geometryName_);
        } else if (this.extractGeometryName_ && geoJSONFeature["geometry_name"]) {
          feature.setGeometryName(geoJSONFeature["geometry_name"]);
        }
        feature.setGeometry(createGeometry(geometry, options));
        if ("id" in geoJSONFeature) {
          feature.setId(geoJSONFeature["id"]);
        }
        if (geoJSONFeature["properties"]) {
          feature.setProperties(geoJSONFeature["properties"], true);
        }
        return (
          /** @type {FeatureType|Array<FeatureType>} */
          feature
        );
      }
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {Array<FeatureType>} Features.
       * @override
       */
      readFeaturesFromObject(object, options) {
        const geoJSONObject = (
          /** @type {GeoJSONObject} */
          object
        );
        let features = null;
        if (geoJSONObject["type"] === "FeatureCollection") {
          const geoJSONFeatureCollection = (
            /** @type {GeoJSONFeatureCollection} */
            object
          );
          features = [];
          const geoJSONFeatures = geoJSONFeatureCollection["features"];
          for (let i4 = 0, ii = geoJSONFeatures.length; i4 < ii; ++i4) {
            const featureObject = this.readFeatureFromObject(
              geoJSONFeatures[i4],
              options
            );
            if (!featureObject) {
              continue;
            }
            features.push(featureObject);
          }
        } else {
          features = [this.readFeatureFromObject(object, options)];
        }
        return (
          /** @type {Array<FeatureType>} */
          features.flat()
        );
      }
      /**
       * @param {GeoJSONGeometry} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       * @override
       */
      readGeometryFromObject(object, options) {
        return readGeometry(object, options);
      }
      /**
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       * @override
       */
      readProjectionFromObject(object) {
        const crs = object["crs"];
        let projection;
        if (crs) {
          if (crs["type"] == "name") {
            projection = get3(crs["properties"]["name"]);
          } else if (crs["type"] === "EPSG") {
            projection = get3("EPSG:" + crs["properties"]["code"]);
          } else {
            throw new Error("Unknown SRS type");
          }
        } else {
          projection = this.dataProjection;
        }
        return (
          /** @type {import("../proj/Projection.js").default} */
          projection
        );
      }
      /**
       * Encode a feature as a GeoJSON Feature object.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONFeature} Object.
       * @api
       * @override
       */
      writeFeatureObject(feature, options) {
        options = this.adaptOptions(options);
        const object = {
          "type": "Feature",
          geometry: null,
          properties: null
        };
        const id = feature.getId();
        if (id !== void 0) {
          object.id = id;
        }
        if (!feature.hasProperties()) {
          return object;
        }
        const properties = feature.getProperties();
        const geometry = feature.getGeometry();
        if (geometry) {
          object.geometry = writeGeometry(geometry, options);
          delete properties[feature.getGeometryName()];
        }
        if (!isEmpty(properties)) {
          object.properties = properties;
        }
        return object;
      }
      /**
       * Encode an array of features as a GeoJSON object.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONFeatureCollection} GeoJSON Object.
       * @api
       * @override
       */
      writeFeaturesObject(features, options) {
        options = this.adaptOptions(options);
        const objects = [];
        for (let i4 = 0, ii = features.length; i4 < ii; ++i4) {
          objects.push(this.writeFeatureObject(features[i4], options));
        }
        return {
          type: "FeatureCollection",
          features: objects
        };
      }
      /**
       * Encode a geometry as a GeoJSON object.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
       * @api
       * @override
       */
      writeGeometryObject(geometry, options) {
        return writeGeometry(geometry, this.adaptOptions(options));
      }
    };
    GeoJSON_default = GeoJSON;
  }
});

// node_modules/@allmaps/stdlib/dist/fetch.js
var init_fetch = __esm({
  "node_modules/@allmaps/stdlib/dist/fetch.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/api.js
var init_api = __esm({
  "node_modules/@allmaps/stdlib/dist/api.js"() {
    init_fetch();
  }
});

// node_modules/@allmaps/stdlib/dist/background-color.js
var init_background_color = __esm({
  "node_modules/@allmaps/stdlib/dist/background-color.js"() {
  }
});

// node_modules/monotone-chain-convex-hull/lib-esm/index.js
var init_lib_esm = __esm({
  "node_modules/monotone-chain-convex-hull/lib-esm/index.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/geometry.js
var init_geometry = __esm({
  "node_modules/@allmaps/stdlib/dist/geometry.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/geojson.js
var init_geojson = __esm({
  "node_modules/@allmaps/stdlib/dist/geojson.js"() {
    init_geometry();
  }
});

// node_modules/@allmaps/stdlib/dist/bbox.js
var init_bbox = __esm({
  "node_modules/@allmaps/stdlib/dist/bbox.js"() {
    init_lib_esm();
    init_geojson();
    init_geometry();
  }
});

// node_modules/@allmaps/stdlib/dist/cache.js
var init_cache = __esm({
  "node_modules/@allmaps/stdlib/dist/cache.js"() {
  }
});

// node_modules/hex-rgb/index.js
var hexCharacters, match3or4Hex, match6or8Hex, nonHexChars, validHexSize;
var init_hex_rgb = __esm({
  "node_modules/hex-rgb/index.js"() {
    hexCharacters = "a-f\\d";
    match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;
    match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;
    nonHexChars = new RegExp(`[^#${hexCharacters}]`, "gi");
    validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, "i");
  }
});

// node_modules/rgb-hex/index.js
var init_rgb_hex = __esm({
  "node_modules/rgb-hex/index.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/color.js
var init_color2 = __esm({
  "node_modules/@allmaps/stdlib/dist/color.js"() {
    init_hex_rgb();
    init_rgb_hex();
  }
});

// node_modules/@allmaps/stdlib/dist/main.js
var init_main = __esm({
  "node_modules/@allmaps/stdlib/dist/main.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/masks.js
var init_masks = __esm({
  "node_modules/@allmaps/stdlib/dist/masks.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/matrix.js
var init_matrix = __esm({
  "node_modules/@allmaps/stdlib/dist/matrix.js"() {
    init_main();
  }
});

// node_modules/@allmaps/stdlib/dist/options.js
var init_options = __esm({
  "node_modules/@allmaps/stdlib/dist/options.js"() {
  }
});

// node_modules/svg-parser/dist/svg-parser.esm.js
var init_svg_parser_esm = __esm({
  "node_modules/svg-parser/dist/svg-parser.esm.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/svg.js
var init_svg = __esm({
  "node_modules/@allmaps/stdlib/dist/svg.js"() {
    init_svg_parser_esm();
  }
});

// node_modules/@allmaps/stdlib/dist/self-intersect.js
var init_self_intersect = __esm({
  "node_modules/@allmaps/stdlib/dist/self-intersect.js"() {
    init_geometry();
    init_main();
  }
});

// node_modules/@allmaps/stdlib/dist/index.js
var init_dist = __esm({
  "node_modules/@allmaps/stdlib/dist/index.js"() {
    init_api();
    init_background_color();
    init_bbox();
    init_cache();
    init_color2();
    init_fetch();
    init_geojson();
    init_geometry();
    init_main();
    init_masks();
    init_matrix();
    init_options();
    init_svg();
    init_self_intersect();
  }
});

// node_modules/@allmaps/transform/dist/shared/distortion.js
var init_distortion = __esm({
  "node_modules/@allmaps/transform/dist/shared/distortion.js"() {
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BaseTransformation.js
var init_BaseTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BaseTransformation.js"() {
    init_dist();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BaseLinearWeightsTransformation.js
var init_BaseLinearWeightsTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BaseLinearWeightsTransformation.js"() {
    init_BaseTransformation();
  }
});

// node_modules/@allmaps/transform/dist/shared/solve-functions.js
var init_solve_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/solve-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Helmert.js
var init_Helmert = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Helmert.js"() {
    init_dist();
    init_BaseLinearWeightsTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Straight.js
var init_Straight = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Straight.js"() {
    init_Helmert();
    init_BaseTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BaseIndependentLinearWeightsTransformation.js
var init_BaseIndependentLinearWeightsTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BaseIndependentLinearWeightsTransformation.js"() {
    init_BaseLinearWeightsTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BasePolynomialTransformation.js
var init_BasePolynomialTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BasePolynomialTransformation.js"() {
    init_dist();
    init_BaseIndependentLinearWeightsTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial1.js
var init_Polynomial1 = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Polynomial1.js"() {
    init_BasePolynomialTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial2.js
var init_Polynomial2 = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Polynomial2.js"() {
    init_BasePolynomialTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial3.js
var init_Polynomial3 = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Polynomial3.js"() {
    init_BasePolynomialTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Projective.js
var init_Projective = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Projective.js"() {
    init_dist();
    init_BaseTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/RBF.js
var init_RBF = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/RBF.js"() {
    init_dist();
    init_Polynomial1();
    init_BaseIndependentLinearWeightsTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/shared/kernel-functions.js
var init_kernel_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/kernel-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/shared/norm-functions.js
var init_norm_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/norm-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/shared/refinement-functions.js
var init_refinement_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/refinement-functions.js"() {
    init_dist();
  }
});

// node_modules/@allmaps/transform/dist/shared/transform-functions.js
function generalGcpTransformOptionsToGcpTransformOptions(generalGcpTransformOptions) {
  if (generalGcpTransformOptions === void 0) {
    return {};
  }
  const gcpTransformOptions = generalGcpTransformOptions;
  if (generalGcpTransformOptions.destinationIsGeographic) {
    gcpTransformOptions.geoIsGeographic = generalGcpTransformOptions.destinationIsGeographic;
  }
  if (generalGcpTransformOptions.postForward) {
    gcpTransformOptions.postToGeo = generalGcpTransformOptions.postForward;
  }
  if (generalGcpTransformOptions.preBackward) {
    gcpTransformOptions.preToResource = generalGcpTransformOptions.preBackward;
  }
  return gcpTransformOptions;
}
function generalGcpTransformerOptionsToGcpTransformerOptions(generalGcpTransformerOptions) {
  if (generalGcpTransformerOptions == void 0) {
    return {};
  }
  const gcpTransformerOptions = generalGcpTransformerOptions;
  return gcpTransformerOptions;
}
var defaultGeneralGcpTransformOptions, defaultGeneralGcpTransformerOptions, defaultGcpTransformOptions, defaultGcpTransformerOptions;
var init_transform_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/transform-functions.js"() {
    init_dist();
    init_refinement_functions();
    defaultGeneralGcpTransformOptions = {
      maxDepth: 0,
      minOffsetRatio: 0,
      minOffsetDistance: Infinity,
      minLineDistance: Infinity,
      sourceIsGeographic: false,
      destinationIsGeographic: false,
      isMultiGeometry: false,
      distortionMeasures: [],
      referenceScale: 1,
      preForward: (point) => point,
      postForward: (point) => point,
      preBackward: (point) => point,
      postBackward: (point) => point
    };
    defaultGeneralGcpTransformerOptions = {
      differentHandedness: false,
      ...defaultGeneralGcpTransformOptions
    };
    defaultGcpTransformOptions = generalGcpTransformOptionsToGcpTransformOptions(defaultGeneralGcpTransformOptions);
    defaultGcpTransformerOptions = generalGcpTransformerOptionsToGcpTransformerOptions(defaultGeneralGcpTransformerOptions);
  }
});

// node_modules/@allmaps/transform/dist/shared/conversion-functions.js
var init_conversion_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/conversion-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/transformers/BaseGcpTransformer.js
var init_BaseGcpTransformer = __esm({
  "node_modules/@allmaps/transform/dist/transformers/BaseGcpTransformer.js"() {
    init_dist();
    init_distortion();
    init_Straight();
    init_Helmert();
    init_Polynomial1();
    init_Polynomial2();
    init_Polynomial3();
    init_Projective();
    init_RBF();
    init_kernel_functions();
    init_norm_functions();
    init_transform_functions();
    init_refinement_functions();
    init_conversion_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformers/GcpTransformer.js
var init_GcpTransformer = __esm({
  "node_modules/@allmaps/transform/dist/transformers/GcpTransformer.js"() {
    init_dist();
    init_BaseGcpTransformer();
    init_transform_functions();
    init_conversion_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformers/GeneralGcpTransformer.js
var init_GeneralGcpTransformer = __esm({
  "node_modules/@allmaps/transform/dist/transformers/GeneralGcpTransformer.js"() {
    init_BaseGcpTransformer();
    init_conversion_functions();
  }
});

// node_modules/@allmaps/transform/dist/shared/types.js
var init_types = __esm({
  "node_modules/@allmaps/transform/dist/shared/types.js"() {
  }
});

// node_modules/@allmaps/transform/dist/index.js
var init_dist2 = __esm({
  "node_modules/@allmaps/transform/dist/index.js"() {
    init_GcpTransformer();
    init_GeneralGcpTransformer();
    init_BaseIndependentLinearWeightsTransformation();
    init_BaseLinearWeightsTransformation();
    init_BasePolynomialTransformation();
    init_BaseTransformation();
    init_Helmert();
    init_Polynomial1();
    init_Polynomial2();
    init_Polynomial3();
    init_Projective();
    init_RBF();
    init_Straight();
    init_types();
    init_distortion();
    init_transform_functions();
    init_solve_functions();
  }
});

// node_modules/@allmaps/tailwind/dist/colors.js
var black, white, inherit, current, transparent, originalColorIndex, blueShades, darkblueShades, purpleShades, pinkShades, orangeShades, redShades, greenShades, yellowShades, grayShades, shades, blue, darkblue, purple, pink, orange, red, green, yellow, gray;
var init_colors = __esm({
  "node_modules/@allmaps/tailwind/dist/colors.js"() {
    black = "#222222";
    white = "#ffffff";
    inherit = "inherit";
    current = "currentColor";
    transparent = "transparent";
    originalColorIndex = 4;
    blueShades = [
      "#dff7fa",
      "#c0eff5",
      "#a1e7f0",
      "#82dfeb",
      "#63d8e6",
      // Original color
      "#4facb8",
      "#3b818a",
      "#27565c",
      "#132b2d"
    ];
    darkblueShades = [
      "#d7d9ee",
      "#b0b4de",
      "#898ecd",
      "#6269bd",
      "#3b44ad",
      // Original color
      "#2f368a",
      "#232867",
      "#171b45",
      "#0b0d22"
    ];
    purpleShades = [
      "#f3dcf0",
      "#e7b9e1",
      "#dc97d2",
      "#d074c3",
      "#c552b5",
      // Original color
      "#9d4190",
      "#76316c",
      "#4e2048",
      "#271024"
    ];
    pinkShades = [
      "#ffddf1",
      "#ffbbe3",
      "#ff99d5",
      "#ff77c7",
      "#ff56ba",
      // Original color
      "#cc4494",
      "#99336f",
      "#66224a",
      "#321125"
    ];
    orangeShades = [
      "#ffe3d0",
      "#ffc7a1",
      "#ffab72",
      "#ff8f43",
      "#ff7415",
      // Original color
      "#cc5c10",
      "#99450c",
      "#662e08",
      "#321704"
    ];
    redShades = [
      "#fededf",
      "#febebf",
      "#fe9e9f",
      "#fe7e7f",
      "#fe5e60",
      // Original color
      "#cb4b4c",
      "#983839",
      "#652526",
      "#321213"
    ];
    greenShades = [
      "#e0f2e8",
      "#c1e6d2",
      "#a2d9bb",
      "#83cda5",
      "#64c18f",
      // Original color
      "#509a72",
      "#3c7355",
      "#284d39",
      "#13261c"
    ];
    yellowShades = [
      "#fff3d9",
      "#ffe8b3",
      "#ffdd8d",
      "#ffd267",
      "#ffc742",
      // Original color
      "#cc9f34",
      "#997727",
      "#664f1a",
      "#32270d"
    ];
    grayShades = [
      "#efefef",
      "#e0e0e0",
      "#d0d0d0",
      "#c1c1c1",
      "#b2b2b2",
      "#8e8e8e",
      "#6a6a6a",
      "#474747",
      "#232323"
    ];
    shades = {
      blue: blueShades,
      darkblue: darkblueShades,
      purple: purpleShades,
      pink: pinkShades,
      orange: orangeShades,
      red: redShades,
      green: greenShades,
      yellow: yellowShades,
      gray: grayShades
    };
    blue = blueShades[originalColorIndex];
    darkblue = darkblueShades[originalColorIndex];
    purple = purpleShades[originalColorIndex];
    pink = pinkShades[originalColorIndex];
    orange = orangeShades[originalColorIndex];
    red = redShades[originalColorIndex];
    green = greenShades[originalColorIndex];
    yellow = yellowShades[originalColorIndex];
    gray = grayShades[originalColorIndex];
  }
});

// node_modules/@allmaps/tailwind/dist/theme-colors.js
function flattenShades(color, shades2) {
  return shades2.reduce((flattened, hex, index6) => {
    const shade = (index6 + 1) * 100;
    const key = `${color}-${shade}`;
    flattened[key] = hex;
    return flattened;
  }, {});
}
var themeColors;
var init_theme_colors = __esm({
  "node_modules/@allmaps/tailwind/dist/theme-colors.js"() {
    init_colors();
    themeColors = {
      blue,
      darkblue,
      purple,
      pink,
      orange,
      red,
      green,
      yellow,
      gray,
      black,
      white,
      inherit,
      current,
      transparent,
      // Add shades
      ...flattenShades("blue", shades.blue),
      ...flattenShades("darkblue", shades.darkblue),
      ...flattenShades("purple", shades.purple),
      ...flattenShades("pink", shades.pink),
      ...flattenShades("orange", shades.orange),
      ...flattenShades("red", shades.red),
      ...flattenShades("green", shades.green),
      ...flattenShades("yellow", shades.yellow),
      ...flattenShades("gray", shades.gray)
    };
  }
});

// node_modules/@allmaps/tailwind/dist/theme.js
var theme;
var init_theme = __esm({
  "node_modules/@allmaps/tailwind/dist/theme.js"() {
    init_theme_colors();
    theme = {
      extend: {
        textColor: {
          DEFAULT: themeColors.black
        },
        transitionDuration: {
          0: "0ms"
        }
      },
      colors: themeColors,
      fontFamily: {
        sans: ["Geograph", "sans-serif"],
        // Consider using https://tosche.net/fonts/codelia
        mono: ["DM Mono", "monospace"]
      }
    };
  }
});

// node_modules/@allmaps/tailwind/dist/index.js
var init_dist3 = __esm({
  "node_modules/@allmaps/tailwind/dist/index.js"() {
    init_theme_colors();
    init_theme();
    init_colors();
  }
});

// node_modules/@allmaps/render/dist/shared/events.js
var init_events2 = __esm({
  "node_modules/@allmaps/render/dist/shared/events.js"() {
  }
});

// node_modules/@allmaps/render/dist/shared/tiles.js
var init_tiles = __esm({
  "node_modules/@allmaps/render/dist/shared/tiles.js"() {
    init_dist();
  }
});

// node_modules/@allmaps/render/dist/tilecache/TileCache.js
var init_TileCache = __esm({
  "node_modules/@allmaps/render/dist/tilecache/TileCache.js"() {
    init_dist();
    init_events2();
    init_tiles();
  }
});

// node_modules/@allmaps/id/dist/checksum.js
var init_checksum = __esm({
  "node_modules/@allmaps/id/dist/checksum.js"() {
  }
});

// node_modules/@allmaps/id/dist/index.js
var init_dist4 = __esm({
  "node_modules/@allmaps/id/dist/index.js"() {
    init_checksum();
  }
});

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType;
var init_util2 = __esm({
  "node_modules/zod/v3/helpers/util.js"() {
    (function(util2) {
      util2.assertEqual = (_3) => {
      };
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
        const filtered = {};
        for (const k2 of validKeys) {
          filtered[k2] = obj[k2];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e3) {
          return obj[e3];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_3, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t3 = typeof data;
      switch (t3) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
  }
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson, ZodError;
var init_ZodError = __esm({
  "node_modules/zod/v3/ZodError.js"() {
    init_util2();
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json2 = JSON.stringify(obj, null, 2);
      return json2.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class _ZodError extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error2) => {
          for (const issue of error2.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i4 = 0;
              while (i4 < issue.path.length) {
                const el = issue.path[i4];
                const terminal = i4 === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i4++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error2 = new ZodError(issues);
      return error2;
    };
  }
});

// node_modules/zod/v3/locales/en.js
var errorMap, en_default;
var init_en = __esm({
  "node_modules/zod/v3/locales/en.js"() {
    init_ZodError();
    init_util2();
    errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "bigint")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    en_default = errorMap;
  }
});

// node_modules/zod/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors = __esm({
  "node_modules/zod/v3/errors.js"() {
    init_en();
    overrideErrorMap = en_default;
  }
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x5) => !!x5)
  });
  ctx.common.issues.push(issue);
}
var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync;
var init_parseUtil = __esm({
  "node_modules/zod/v3/helpers/parseUtil.js"() {
    init_errors();
    init_en();
    makeIssue = (params2) => {
      const { data, path, errorMaps, issueData } = params2;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m5) => !!m5).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s6 of results) {
          if (s6.status === "aborted")
            return INVALID;
          if (s6.status === "dirty")
            status.dirty();
          arrayValue.push(s6.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x5) => x5.status === "aborted";
    isDirty = (x5) => x5.status === "dirty";
    isValid = (x5) => x5.status === "valid";
    isAsync = (x5) => typeof Promise !== "undefined" && x5 instanceof Promise;
  }
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = __esm({
  "node_modules/zod/v3/helpers/typeAliases.js"() {
  }
});

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm({
  "node_modules/zod/v3/helpers/errorUtil.js"() {
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (errorUtil = {}));
  }
});

// node_modules/zod/v3/types.js
function processCreateParams(params2) {
  if (!params2)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params2;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a4, b5) {
  const aType = getParsedType(a4);
  const bType = getParsedType(b5);
  if (a4 === b5) {
    return { valid: true, data: a4 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b5);
    const sharedKeys = util.objectKeys(a4).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a4, ...b5 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a4[key], b5[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a4.length !== b5.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index6 = 0; index6 < a4.length; index6++) {
      const itemA = a4[index6];
      const itemB = b5[index6];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a4 === +b5) {
    return { valid: true, data: a4 };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params2) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params2)
  });
}
function cleanParams(params2, data) {
  const p4 = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
  const p22 = typeof p4 === "string" ? { message: p4 } : p4;
  return p22;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r4 = check(data);
      if (r4 instanceof Promise) {
        return r4.then((r5) => {
          if (!r5) {
            const params2 = cleanParams(_params, data);
            const _fatal = params2.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params2, fatal: _fatal });
          }
        });
      }
      if (!r4) {
        const params2 = cleanParams(_params, data);
        const _fatal = params2.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params2, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER;
var init_types2 = __esm({
  "node_modules/zod/v3/types.js"() {
    init_ZodError();
    init_errors();
    init_errorUtil();
    init_parseUtil();
    init_util2();
    ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error2 = new ZodError(ctx.common.issues);
            this._error = error2;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params2) {
        const result = this.safeParse(data, params2);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params2) {
        const ctx = {
          common: {
            issues: [],
            async: params2?.async ?? false,
            contextualErrorMap: params2?.errorMap
          },
          path: params2?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params2) {
        const result = await this.safeParseAsync(data, params2);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params2) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params2?.errorMap,
            async: true
          },
          path: params2?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform3) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform: transform3 }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params2) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params2?.coerce ?? false,
        ...processCreateParams(params2)
      });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params2) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params2?.coerce || false,
        ...processCreateParams(params2)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params2) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params2?.coerce ?? false,
        ...processCreateParams(params2)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params2) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params2?.coerce || false,
        ...processCreateParams(params2)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params2) => {
      return new ZodDate({
        checks: [],
        coerce: params2?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params2)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params2) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params2)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params2) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params2)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params2) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params2)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params2) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params2)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params2) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params2)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params2) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params2)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params2) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params2)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i4) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i4) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params2) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params2)
      });
    };
    ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index6) {
        return new _ZodObject({
          ...this._def,
          catchall: index6
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params2) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.strictCreate = (shape, params2) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.lazycreate = (shape, params2) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params2) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params2)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params2) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params2)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params2) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params2)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x5) => !!x5);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params2) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params2)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index6) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index6, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index6, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params2) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params2)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i4) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i4)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params2) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params2)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error2) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x5) => !!x5),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error2
            }
          });
        }
        function makeReturnsIssue(returns, error2) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x5) => !!x5),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error2
            }
          });
        }
        const params2 = { errorMap: ctx.common.contextualErrorMap };
        const fn3 = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me3 = this;
          return OK(async function(...args) {
            const error2 = new ZodError([]);
            const parsedArgs = await me3._def.args.parseAsync(args, params2).catch((e3) => {
              error2.addIssue(makeArgsIssue(args, e3));
              throw error2;
            });
            const result = await Reflect.apply(fn3, this, parsedArgs);
            const parsedReturns = await me3._def.returns._def.type.parseAsync(result, params2).catch((e3) => {
              error2.addIssue(makeReturnsIssue(result, e3));
              throw error2;
            });
            return parsedReturns;
          });
        } else {
          const me3 = this;
          return OK(function(...args) {
            const parsedArgs = me3._def.args.safeParse(args, params2);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn3, this, parsedArgs.data);
            const parsedReturns = me3._def.returns.safeParse(result, params2);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params2) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params2)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params2) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params2)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params2) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params2)
      });
    };
    ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params2) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params2)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params2) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params2)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params2) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params2)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params2) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params2)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params2) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params2)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params2) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params2)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params2) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default,
        ...processCreateParams(params2)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params2) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch,
        ...processCreateParams(params2)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params2) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params2)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a4, b5) {
        return new _ZodPipeline({
          in: a4,
          out: b5,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params2) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params2)
      });
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params2 = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params2);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
  }
});

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
var init_external = __esm({
  "node_modules/zod/v3/external.js"() {
    init_errors();
    init_parseUtil();
    init_typeAliases();
    init_util2();
    init_types2();
    init_ZodError();
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_external();
    init_external();
  }
});

// node_modules/@allmaps/annotation/dist/schemas/shared.js
function ensureArray(val) {
  if (val) {
    return Array.isArray(val) ? val : [val];
  }
}
function parseInvalidTransformation(val) {
  const valLowerCase = val.toLowerCase();
  if (valLowerCase === "thinplatespline" || valLowerCase === "thin-plate-spline") {
    return {
      type: "thinPlateSpline"
    };
  } else if (valLowerCase === "polynomial1") {
    return {
      type: "polynomial",
      options: { order: 1 }
    };
  } else if (valLowerCase === "polynomial2") {
    return {
      type: "polynomial",
      options: { order: 2 }
    };
  }
}
var SingleValueSchema, LanguageValueSchema, PointSchema, PointGeometrySchema, ResourceMaskSchema, ImageServices, ResourceTypes, ImageServiceSchema, ResourceTypeSchema, basePartOfItemSchema, PartOfItemSchema, PartOfSchema, ValidTransformationSchema, TransformationSchema, ProjectionSchema, ContextSchema;
var init_shared = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/shared.js"() {
    init_zod();
    SingleValueSchema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]);
    LanguageValueSchema = external_exports.record(external_exports.string(), SingleValueSchema.array());
    PointSchema = external_exports.tuple([external_exports.number(), external_exports.number()]);
    PointGeometrySchema = external_exports.object({
      type: external_exports.literal("Point"),
      coordinates: PointSchema
    });
    ResourceMaskSchema = PointSchema.array().min(3);
    ImageServices = [
      "ImageService1",
      "ImageService2",
      "ImageService3"
    ];
    ResourceTypes = [...ImageServices, ...["Canvas"]];
    ImageServiceSchema = external_exports.enum(ImageServices);
    ResourceTypeSchema = external_exports.enum(ResourceTypes);
    basePartOfItemSchema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string(),
      label: LanguageValueSchema.optional()
    });
    PartOfItemSchema = basePartOfItemSchema.extend({
      partOf: external_exports.lazy(() => PartOfItemSchema.array()).optional()
    });
    PartOfSchema = external_exports.union([PartOfItemSchema.array(), PartOfItemSchema]).transform(ensureArray);
    ValidTransformationSchema = external_exports.object({
      type: external_exports.enum(["helmert", "polynomial", "thinPlateSpline", "projective"]),
      options: external_exports.object({}).passthrough().optional()
    });
    TransformationSchema = external_exports.union([
      ValidTransformationSchema,
      // Catchall for unknown transformation types
      external_exports.unknown()
    ]).transform((val) => {
      const { success, data } = ValidTransformationSchema.safeParse(val);
      if (success) {
        return data;
      } else if (val === "string") {
        return parseInvalidTransformation(val);
      } else if (val && typeof val === "object" && "type" in val && typeof val.type === "string") {
        return parseInvalidTransformation(val.type);
      }
    });
    ProjectionSchema = external_exports.object({
      name: external_exports.string().optional(),
      definition: external_exports.union([external_exports.string(), external_exports.unknown()])
    });
    ContextSchema = external_exports.union([
      external_exports.string().url().array(),
      external_exports.string().url()
    ]);
  }
});

// node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.0.js
var svg, SvgSelectorSchema, TargetSchema, FeaturePropertiesSchema, BodySchema, AnnotationSchema, AnnotationPageSchema;
var init_annotation_0 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.0.js"() {
    init_zod();
    init_shared();
    svg = /^<svg\s+width="\d+"\s+height="\d+"\s*>\s*<polygon\s+points="\s*(-?\d+(\.\d+)?,-?\d+(\.\d+)?\s+){2,}-?\d+(\.\d+)?,-?\d+(\.\d+)?\s*"\s*\/>\s*<\/svg>$/;
    SvgSelectorSchema = external_exports.object({
      type: external_exports.literal("SvgSelector"),
      value: external_exports.string().regex(svg)
    });
    TargetSchema = external_exports.object({
      source: external_exports.string().url(),
      service: external_exports.array(external_exports.object({
        "@id": external_exports.string().url(),
        type: ResourceTypeSchema
      })).length(1),
      selector: SvgSelectorSchema
    });
    FeaturePropertiesSchema = external_exports.object({
      pixelCoords: PointSchema
    });
    BodySchema = external_exports.object({
      type: external_exports.literal("FeatureCollection"),
      transformation: TransformationSchema.optional(),
      features: external_exports.array(external_exports.object({
        type: external_exports.literal("Feature"),
        properties: FeaturePropertiesSchema,
        geometry: PointGeometrySchema
      }))
    });
    AnnotationSchema = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("Annotation"),
      "@context": ContextSchema.optional(),
      motivation: external_exports.string().default("georeferencing").optional(),
      target: TargetSchema,
      body: BodySchema
    });
    AnnotationPageSchema = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("AnnotationPage"),
      "@context": ContextSchema.optional(),
      items: external_exports.array(AnnotationSchema)
    });
  }
});

// node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.1.js
var polygonRegex, svgWidthHeightRegex, svgHeightWidthRegex, svgRegex, SvgRegexSchema, SvgWidthHeightRegexSchema, SvgHeightWidthRegexSchema, SvgSelectorSchema2, Source1Schema, Source2Schema, Canvas3Schema, SourceSchema, TargetSchema2, FeaturePropertiesSchema2, BodySchema2, AnnotationSchema2, AnnotationPageSchema2;
var init_annotation_1 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.1.js"() {
    init_zod();
    init_shared();
    polygonRegex = /<polygon\s+points="\s*(-?\d+(\.\d+)?,-?\d+(\.\d+)?\s+){2,}-?\d+(\.\d+)?,-?\d+(\.\d+)?\s*"\s*\/>/;
    svgWidthHeightRegex = new RegExp(`^<svg\\s+width="\\d+"\\s+height="\\d+"\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
    svgHeightWidthRegex = new RegExp(`^<svg\\s+height="\\d+"\\s+width="\\d+"\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
    svgRegex = new RegExp(`^<svg\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
    SvgRegexSchema = external_exports.string().regex(svgRegex);
    SvgWidthHeightRegexSchema = external_exports.string().regex(svgWidthHeightRegex);
    SvgHeightWidthRegexSchema = external_exports.string().regex(svgHeightWidthRegex);
    SvgSelectorSchema2 = external_exports.object({
      type: external_exports.literal("SvgSelector"),
      value: external_exports.union([
        SvgRegexSchema,
        SvgWidthHeightRegexSchema,
        SvgHeightWidthRegexSchema
      ])
    });
    Source1Schema = external_exports.object({
      "@id": external_exports.string().url(),
      type: ImageServiceSchema,
      height: external_exports.number().positive(),
      width: external_exports.number().positive(),
      partOf: PartOfSchema.optional()
    });
    Source2Schema = external_exports.object({
      id: external_exports.string().url(),
      type: ImageServiceSchema,
      height: external_exports.number().positive().optional(),
      width: external_exports.number().positive().optional(),
      partOf: PartOfSchema.optional()
    });
    Canvas3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Canvas"),
      height: external_exports.number().positive().optional(),
      width: external_exports.number().positive().optional(),
      partOf: PartOfSchema.optional()
    });
    SourceSchema = external_exports.union([
      Source1Schema,
      Source2Schema,
      Canvas3Schema
    ]);
    TargetSchema2 = external_exports.object({
      type: external_exports.literal("SpecificResource"),
      source: SourceSchema,
      // selector: z.union([SvgSelectorSchema, ImageApiSelectorSchema])
      selector: SvgSelectorSchema2
    });
    FeaturePropertiesSchema2 = external_exports.object({
      resourceCoords: PointSchema
    });
    BodySchema2 = external_exports.object({
      type: external_exports.literal("FeatureCollection"),
      transformation: TransformationSchema.optional(),
      resourceCrs: ProjectionSchema.optional(),
      features: external_exports.array(external_exports.object({
        type: external_exports.literal("Feature"),
        properties: FeaturePropertiesSchema2,
        geometry: PointGeometrySchema
      }))
    });
    AnnotationSchema2 = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("Annotation"),
      "@context": ContextSchema.optional(),
      motivation: external_exports.string().default("georeferencing").optional(),
      created: external_exports.string().datetime().optional(),
      modified: external_exports.string().datetime().optional(),
      target: TargetSchema2,
      body: BodySchema2
    });
    AnnotationPageSchema2 = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("AnnotationPage"),
      "@context": ContextSchema.optional(),
      items: external_exports.array(AnnotationSchema2)
    });
  }
});

// node_modules/@allmaps/annotation/dist/schemas/annotation.js
var AnnotationAllVersionsSchema, AnnotationPageAllVersionsSchema, FeaturePropertiesAllVersionsSchema;
var init_annotation = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/annotation.js"() {
    init_zod();
    init_annotation_0();
    init_annotation_1();
    init_shared();
    AnnotationAllVersionsSchema = external_exports.union([
      AnnotationSchema,
      AnnotationSchema2
    ]);
    AnnotationPageAllVersionsSchema = external_exports.union([
      AnnotationPageSchema,
      AnnotationPageSchema2
    ]);
    FeaturePropertiesAllVersionsSchema = external_exports.union([
      FeaturePropertiesSchema,
      FeaturePropertiesSchema2
    ]);
  }
});

// node_modules/@allmaps/annotation/dist/before-parse.js
var init_before_parse = __esm({
  "node_modules/@allmaps/annotation/dist/before-parse.js"() {
  }
});

// node_modules/@allmaps/annotation/dist/guards.js
var init_guards = __esm({
  "node_modules/@allmaps/annotation/dist/guards.js"() {
  }
});

// node_modules/@allmaps/annotation/dist/parser.js
var init_parser = __esm({
  "node_modules/@allmaps/annotation/dist/parser.js"() {
    init_annotation();
    init_before_parse();
    init_guards();
  }
});

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.1.js
var GCPSchema, ImageSchema, GeoreferencedMapSchema, GeoreferencedMapsSchema;
var init_georeferenced_map_1 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.1.js"() {
    init_zod();
    init_shared();
    GCPSchema = external_exports.object({
      image: PointSchema,
      world: PointSchema
    });
    ImageSchema = external_exports.object({
      uri: external_exports.string().url(),
      width: external_exports.number(),
      height: external_exports.number(),
      type: ImageServiceSchema
    });
    GeoreferencedMapSchema = external_exports.object({
      id: external_exports.string().optional(),
      version: external_exports.number().min(1).max(1).default(1),
      image: ImageSchema,
      gcps: GCPSchema.array(),
      pixelMask: ResourceMaskSchema,
      transformation: TransformationSchema.optional()
    });
    GeoreferencedMapsSchema = external_exports.array(GeoreferencedMapSchema);
  }
});

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.2.js
var GCPSchema2, ResourceSchema, GeoreferencedMapSchema2, GeoreferencedMapsSchema2;
var init_georeferenced_map_2 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.2.js"() {
    init_zod();
    init_shared();
    GCPSchema2 = external_exports.object({
      resource: PointSchema,
      geo: PointSchema
    });
    ResourceSchema = external_exports.object({
      id: external_exports.string().url(),
      height: external_exports.number().positive().optional(),
      width: external_exports.number().positive().optional(),
      type: ResourceTypeSchema,
      partOf: PartOfSchema.optional()
    });
    GeoreferencedMapSchema2 = external_exports.object({
      "@context": external_exports.literal("https://schemas.allmaps.org/map/2/context.json").optional(),
      type: external_exports.literal("GeoreferencedMap"),
      id: external_exports.string().optional(),
      created: external_exports.string().datetime().optional(),
      modified: external_exports.string().datetime().optional(),
      resource: ResourceSchema,
      gcps: GCPSchema2.array(),
      resourceMask: ResourceMaskSchema,
      transformation: TransformationSchema.optional(),
      resourceCrs: ProjectionSchema.optional()
    });
    GeoreferencedMapsSchema2 = external_exports.array(GeoreferencedMapSchema2);
  }
});

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map.js
var GeoreferencedMapAllVersionsSchema, GeoreferencedMapsAllVersionsSchema, GCPAllVersionsSchema;
var init_georeferenced_map = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/georeferenced-map.js"() {
    init_zod();
    init_georeferenced_map_1();
    init_georeferenced_map_2();
    init_shared();
    GeoreferencedMapAllVersionsSchema = external_exports.union([
      GeoreferencedMapSchema,
      GeoreferencedMapSchema2
    ]);
    GeoreferencedMapsAllVersionsSchema = external_exports.union([
      GeoreferencedMapsSchema,
      GeoreferencedMapsSchema2
    ]);
    GCPAllVersionsSchema = external_exports.union([
      GCPSchema,
      GCPSchema2
    ]);
  }
});

// node_modules/@allmaps/annotation/dist/generator.js
var init_generator = __esm({
  "node_modules/@allmaps/annotation/dist/generator.js"() {
    init_georeferenced_map();
    init_before_parse();
    init_guards();
  }
});

// node_modules/@allmaps/annotation/dist/convert.js
var init_convert = __esm({
  "node_modules/@allmaps/annotation/dist/convert.js"() {
    init_parser();
    init_generator();
    init_guards();
  }
});

// node_modules/@allmaps/annotation/dist/validator.js
var init_validator = __esm({
  "node_modules/@allmaps/annotation/dist/validator.js"() {
    init_annotation();
    init_georeferenced_map();
    init_convert();
    init_before_parse();
  }
});

// node_modules/@allmaps/annotation/dist/index.js
var init_dist5 = __esm({
  "node_modules/@allmaps/annotation/dist/index.js"() {
    init_parser();
    init_generator();
    init_validator();
    init_georeferenced_map();
    init_annotation();
    init_shared();
  }
});

// node_modules/proj4/lib/global.js
function global_default(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var i4 = 1; i4 <= 60; ++i4) {
    defs2("EPSG:" + (32600 + i4), "+proj=utm +zone=" + i4 + " +datum=WGS84 +units=m");
    defs2("EPSG:" + (32700 + i4), "+proj=utm +zone=" + i4 + " +south +datum=WGS84 +units=m");
  }
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}
var init_global = __esm({
  "node_modules/proj4/lib/global.js"() {
  }
});

// node_modules/proj4/lib/constants/values.js
var PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT, PJD_WGS84, PJD_NODATUM, SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR, SRS_WGS84_ESQUARED, SEC_TO_RAD, HALF_PI, SIXTH, RA4, RA6, EPSLN, D2R, R2D, FORTPI, TWO_PI, SPI;
var init_values = __esm({
  "node_modules/proj4/lib/constants/values.js"() {
    PJD_3PARAM = 1;
    PJD_7PARAM = 2;
    PJD_GRIDSHIFT = 3;
    PJD_WGS84 = 4;
    PJD_NODATUM = 5;
    SRS_WGS84_SEMIMAJOR = 6378137;
    SRS_WGS84_SEMIMINOR = 6356752314e-3;
    SRS_WGS84_ESQUARED = 0.0066943799901413165;
    SEC_TO_RAD = 484813681109536e-20;
    HALF_PI = Math.PI / 2;
    SIXTH = 0.16666666666666666;
    RA4 = 0.04722222222222222;
    RA6 = 0.022156084656084655;
    EPSLN = 1e-10;
    D2R = 0.017453292519943295;
    R2D = 57.29577951308232;
    FORTPI = Math.PI / 4;
    TWO_PI = Math.PI * 2;
    SPI = 3.14159265359;
  }
});

// node_modules/proj4/lib/constants/PrimeMeridian.js
var primeMeridian, PrimeMeridian_default;
var init_PrimeMeridian = __esm({
  "node_modules/proj4/lib/constants/PrimeMeridian.js"() {
    primeMeridian = {};
    primeMeridian.greenwich = 0;
    primeMeridian.lisbon = -9.131906111111;
    primeMeridian.paris = 2.337229166667;
    primeMeridian.bogota = -74.080916666667;
    primeMeridian.madrid = -3.687938888889;
    primeMeridian.rome = 12.452333333333;
    primeMeridian.bern = 7.439583333333;
    primeMeridian.jakarta = 106.807719444444;
    primeMeridian.ferro = -17.666666666667;
    primeMeridian.brussels = 4.367975;
    primeMeridian.stockholm = 18.058277777778;
    primeMeridian.athens = 23.7163375;
    primeMeridian.oslo = 10.722916666667;
    PrimeMeridian_default = primeMeridian;
  }
});

// node_modules/proj4/lib/constants/units.js
var units_default;
var init_units = __esm({
  "node_modules/proj4/lib/constants/units.js"() {
    units_default = {
      mm: { to_meter: 1e-3 },
      cm: { to_meter: 0.01 },
      ft: { to_meter: 0.3048 },
      "us-ft": { to_meter: 1200 / 3937 },
      fath: { to_meter: 1.8288 },
      kmi: { to_meter: 1852 },
      "us-ch": { to_meter: 20.1168402336805 },
      "us-mi": { to_meter: 1609.34721869444 },
      km: { to_meter: 1e3 },
      "ind-ft": { to_meter: 0.30479841 },
      "ind-yd": { to_meter: 0.91439523 },
      mi: { to_meter: 1609.344 },
      yd: { to_meter: 0.9144 },
      ch: { to_meter: 20.1168 },
      link: { to_meter: 0.201168 },
      dm: { to_meter: 0.1 },
      in: { to_meter: 0.0254 },
      "ind-ch": { to_meter: 20.11669506 },
      "us-in": { to_meter: 0.025400050800101 },
      "us-yd": { to_meter: 0.914401828803658 }
    };
  }
});

// node_modules/proj4/lib/match.js
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i4 = -1;
  var testkey, processedKey;
  while (++i4 < keys.length) {
    testkey = keys[i4];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}
var ignoredChar;
var init_match = __esm({
  "node_modules/proj4/lib/match.js"() {
    ignoredChar = /[\s_\-\/\(\)]/g;
  }
});

// node_modules/proj4/lib/projString.js
function projString_default(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v4) {
    return v4.trim();
  }).filter(function(a4) {
    return a4;
  }).reduce(function(p4, a4) {
    var split = a4.split("=");
    split.push(true);
    p4[split[0].toLowerCase()] = split[1];
    return p4;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v4) {
      self2.rf = parseFloat(v4);
    },
    lat_0: function(v4) {
      self2.lat0 = v4 * D2R;
    },
    lat_1: function(v4) {
      self2.lat1 = v4 * D2R;
    },
    lat_2: function(v4) {
      self2.lat2 = v4 * D2R;
    },
    lat_ts: function(v4) {
      self2.lat_ts = v4 * D2R;
    },
    lon_0: function(v4) {
      self2.long0 = v4 * D2R;
    },
    lon_1: function(v4) {
      self2.long1 = v4 * D2R;
    },
    lon_2: function(v4) {
      self2.long2 = v4 * D2R;
    },
    alpha: function(v4) {
      self2.alpha = parseFloat(v4) * D2R;
    },
    gamma: function(v4) {
      self2.rectified_grid_angle = parseFloat(v4) * D2R;
    },
    lonc: function(v4) {
      self2.longc = v4 * D2R;
    },
    x_0: function(v4) {
      self2.x0 = parseFloat(v4);
    },
    y_0: function(v4) {
      self2.y0 = parseFloat(v4);
    },
    k_0: function(v4) {
      self2.k0 = parseFloat(v4);
    },
    k: function(v4) {
      self2.k0 = parseFloat(v4);
    },
    a: function(v4) {
      self2.a = parseFloat(v4);
    },
    b: function(v4) {
      self2.b = parseFloat(v4);
    },
    r: function(v4) {
      self2.a = self2.b = parseFloat(v4);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v4) {
      self2.zone = parseInt(v4, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v4) {
      self2.datum_params = v4.split(",").map(function(a4) {
        return parseFloat(a4);
      });
    },
    to_meter: function(v4) {
      self2.to_meter = parseFloat(v4);
    },
    units: function(v4) {
      self2.units = v4;
      var unit = match(units_default, v4);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v4) {
      self2.from_greenwich = v4 * D2R;
    },
    pm: function(v4) {
      var pm = match(PrimeMeridian_default, v4);
      self2.from_greenwich = (pm ? pm : parseFloat(v4)) * D2R;
    },
    nadgrids: function(v4) {
      if (v4 === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v4;
      }
    },
    axis: function(v4) {
      var legalAxis = "ewnsud";
      if (v4.length === 3 && legalAxis.indexOf(v4.substr(0, 1)) !== -1 && legalAxis.indexOf(v4.substr(1, 1)) !== -1 && legalAxis.indexOf(v4.substr(2, 1)) !== -1) {
        self2.axis = v4;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}
var init_projString = __esm({
  "node_modules/proj4/lib/projString.js"() {
    init_values();
    init_PrimeMeridian();
    init_units();
    init_match();
  }
});

// node_modules/wkt-parser/PROJJSONBuilderBase.js
var PROJJSONBuilderBase, PROJJSONBuilderBase_default;
var init_PROJJSONBuilderBase = __esm({
  "node_modules/wkt-parser/PROJJSONBuilderBase.js"() {
    PROJJSONBuilderBase = class {
      static getId(node) {
        const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
        if (idNode && idNode.length >= 3) {
          return {
            authority: idNode[1],
            code: parseInt(idNode[2], 10)
          };
        }
        return null;
      }
      static convertUnit(node, type = "unit") {
        if (!node || node.length < 3) {
          return { type, name: "unknown", conversion_factor: null };
        }
        const name = node[1];
        const conversionFactor = parseFloat(node[2]) || null;
        const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
        const id = idNode ? {
          authority: idNode[1],
          code: parseInt(idNode[2], 10)
        } : null;
        return {
          type,
          name,
          conversion_factor: conversionFactor,
          id
        };
      }
      static convertAxis(node) {
        const name = node[1] || "Unknown";
        let direction;
        const abbreviationMatch = name.match(/^\((.)\)$/);
        if (abbreviationMatch) {
          const abbreviation = abbreviationMatch[1].toUpperCase();
          if (abbreviation === "E") direction = "east";
          else if (abbreviation === "N") direction = "north";
          else if (abbreviation === "U") direction = "up";
          else throw new Error(`Unknown axis abbreviation: ${abbreviation}`);
        } else {
          direction = node[2] ? node[2].toLowerCase() : "unknown";
        }
        const orderNode = node.find((child) => Array.isArray(child) && child[0] === "ORDER");
        const order = orderNode ? parseInt(orderNode[1], 10) : null;
        const unitNode = node.find(
          (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
        );
        const unit = this.convertUnit(unitNode);
        return {
          name,
          direction,
          // Use the valid PROJJSON direction value
          unit,
          order
        };
      }
      static extractAxes(node) {
        return node.filter((child) => Array.isArray(child) && child[0] === "AXIS").map((axis) => this.convertAxis(axis)).sort((a4, b5) => (a4.order || 0) - (b5.order || 0));
      }
      static convert(node, result = {}) {
        switch (node[0]) {
          case "PROJCRS":
            result.type = "ProjectedCRS";
            result.name = node[1];
            result.base_crs = node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS")) : null;
            result.conversion = node.find((child) => Array.isArray(child) && child[0] === "CONVERSION") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "CONVERSION")) : null;
            const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
            if (csNode) {
              result.coordinate_system = {
                type: csNode[1],
                axis: this.extractAxes(node)
              };
            }
            const lengthUnitNode = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT");
            if (lengthUnitNode) {
              const unit2 = this.convertUnit(lengthUnitNode);
              result.coordinate_system.unit = unit2;
            }
            result.id = this.getId(node);
            break;
          case "BASEGEOGCRS":
          case "GEOGCRS":
            result.type = "GeographicCRS";
            result.name = node[1];
            const datumOrEnsembleNode = node.find(
              (child) => Array.isArray(child) && (child[0] === "DATUM" || child[0] === "ENSEMBLE")
            );
            if (datumOrEnsembleNode) {
              const datumOrEnsemble = this.convert(datumOrEnsembleNode);
              if (datumOrEnsembleNode[0] === "ENSEMBLE") {
                result.datum_ensemble = datumOrEnsemble;
              } else {
                result.datum = datumOrEnsemble;
              }
              const primem = node.find((child) => Array.isArray(child) && child[0] === "PRIMEM");
              if (primem && primem[1] !== "Greenwich") {
                datumOrEnsemble.prime_meridian = {
                  name: primem[1],
                  longitude: parseFloat(primem[2])
                };
              }
            }
            result.coordinate_system = {
              type: "ellipsoidal",
              axis: this.extractAxes(node)
            };
            result.id = this.getId(node);
            break;
          case "DATUM":
            result.type = "GeodeticReferenceFrame";
            result.name = node[1];
            result.ellipsoid = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID")) : null;
            break;
          case "ENSEMBLE":
            result.type = "DatumEnsemble";
            result.name = node[1];
            result.members = node.filter((child) => Array.isArray(child) && child[0] === "MEMBER").map((member) => ({
              type: "DatumEnsembleMember",
              name: member[1],
              id: this.getId(member)
              // Extract ID as { authority, code }
            }));
            const accuracyNode = node.find((child) => Array.isArray(child) && child[0] === "ENSEMBLEACCURACY");
            if (accuracyNode) {
              result.accuracy = parseFloat(accuracyNode[1]);
            }
            const ellipsoidNode = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID");
            if (ellipsoidNode) {
              result.ellipsoid = this.convert(ellipsoidNode);
            }
            result.id = this.getId(node);
            break;
          case "ELLIPSOID":
            result.type = "Ellipsoid";
            result.name = node[1];
            result.semi_major_axis = parseFloat(node[2]);
            result.inverse_flattening = parseFloat(node[3]);
            const units = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT"), result) : null;
            break;
          case "CONVERSION":
            result.type = "Conversion";
            result.name = node[1];
            result.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
            result.parameters = node.filter((child) => Array.isArray(child) && child[0] === "PARAMETER").map((param) => this.convert(param));
            break;
          case "METHOD":
            result.type = "Method";
            result.name = node[1];
            result.id = this.getId(node);
            break;
          case "PARAMETER":
            result.type = "Parameter";
            result.name = node[1];
            result.value = parseFloat(node[2]);
            result.unit = this.convertUnit(
              node.find(
                (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
              )
            );
            result.id = this.getId(node);
            break;
          case "BOUNDCRS":
            result.type = "BoundCRS";
            const sourceCrsNode = node.find((child) => Array.isArray(child) && child[0] === "SOURCECRS");
            if (sourceCrsNode) {
              const sourceCrsContent = sourceCrsNode.find((child) => Array.isArray(child));
              result.source_crs = sourceCrsContent ? this.convert(sourceCrsContent) : null;
            }
            const targetCrsNode = node.find((child) => Array.isArray(child) && child[0] === "TARGETCRS");
            if (targetCrsNode) {
              const targetCrsContent = targetCrsNode.find((child) => Array.isArray(child));
              result.target_crs = targetCrsContent ? this.convert(targetCrsContent) : null;
            }
            const transformationNode = node.find((child) => Array.isArray(child) && child[0] === "ABRIDGEDTRANSFORMATION");
            if (transformationNode) {
              result.transformation = this.convert(transformationNode);
            } else {
              result.transformation = null;
            }
            break;
          case "ABRIDGEDTRANSFORMATION":
            result.type = "Transformation";
            result.name = node[1];
            result.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
            result.parameters = node.filter((child) => Array.isArray(child) && (child[0] === "PARAMETER" || child[0] === "PARAMETERFILE")).map((param) => {
              if (param[0] === "PARAMETER") {
                return this.convert(param);
              } else if (param[0] === "PARAMETERFILE") {
                return {
                  name: param[1],
                  value: param[2],
                  id: {
                    "authority": "EPSG",
                    "code": 8656
                  }
                };
              }
            });
            if (result.parameters.length === 7) {
              const scaleDifference = result.parameters[6];
              if (scaleDifference.name === "Scale difference") {
                scaleDifference.value = Math.round((scaleDifference.value - 1) * 1e12) / 1e6;
              }
            }
            result.id = this.getId(node);
            break;
          case "AXIS":
            if (!result.coordinate_system) {
              result.coordinate_system = { type: "unspecified", axis: [] };
            }
            result.coordinate_system.axis.push(this.convertAxis(node));
            break;
          case "LENGTHUNIT":
            const unit = this.convertUnit(node, "LinearUnit");
            if (result.coordinate_system && result.coordinate_system.axis) {
              result.coordinate_system.axis.forEach((axis) => {
                if (!axis.unit) {
                  axis.unit = unit;
                }
              });
            }
            if (unit.conversion_factor && unit.conversion_factor !== 1) {
              if (result.semi_major_axis) {
                result.semi_major_axis = {
                  value: result.semi_major_axis,
                  unit
                };
              }
            }
            break;
          default:
            result.keyword = node[0];
            break;
        }
        return result;
      }
    };
    PROJJSONBuilderBase_default = PROJJSONBuilderBase;
  }
});

// node_modules/wkt-parser/PROJJSONBuilder2015.js
var PROJJSONBuilder2015, PROJJSONBuilder2015_default;
var init_PROJJSONBuilder2015 = __esm({
  "node_modules/wkt-parser/PROJJSONBuilder2015.js"() {
    init_PROJJSONBuilderBase();
    PROJJSONBuilder2015 = class extends PROJJSONBuilderBase_default {
      static convert(node, result = {}) {
        super.convert(node, result);
        if (result.coordinate_system && result.coordinate_system.subtype === "Cartesian") {
          delete result.coordinate_system;
        }
        if (result.usage) {
          delete result.usage;
        }
        return result;
      }
    };
    PROJJSONBuilder2015_default = PROJJSONBuilder2015;
  }
});

// node_modules/wkt-parser/PROJJSONBuilder2019.js
var PROJJSONBuilder2019, PROJJSONBuilder2019_default;
var init_PROJJSONBuilder2019 = __esm({
  "node_modules/wkt-parser/PROJJSONBuilder2019.js"() {
    init_PROJJSONBuilderBase();
    PROJJSONBuilder2019 = class extends PROJJSONBuilderBase_default {
      static convert(node, result = {}) {
        super.convert(node, result);
        const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
        if (csNode) {
          result.coordinate_system = {
            subtype: csNode[1],
            axis: this.extractAxes(node)
          };
        }
        const usageNode = node.find((child) => Array.isArray(child) && child[0] === "USAGE");
        if (usageNode) {
          const scope = usageNode.find((child) => Array.isArray(child) && child[0] === "SCOPE");
          const area = usageNode.find((child) => Array.isArray(child) && child[0] === "AREA");
          const bbox = usageNode.find((child) => Array.isArray(child) && child[0] === "BBOX");
          result.usage = {};
          if (scope) {
            result.usage.scope = scope[1];
          }
          if (area) {
            result.usage.area = area[1];
          }
          if (bbox) {
            result.usage.bbox = bbox.slice(1);
          }
        }
        return result;
      }
    };
    PROJJSONBuilder2019_default = PROJJSONBuilder2019;
  }
});

// node_modules/wkt-parser/buildPROJJSON.js
function detectWKT2Version(root) {
  if (root.find((child) => Array.isArray(child) && child[0] === "USAGE")) {
    return "2019";
  }
  if (root.find((child) => Array.isArray(child) && child[0] === "CS")) {
    return "2015";
  }
  if (root[0] === "BOUNDCRS" || root[0] === "PROJCRS" || root[0] === "GEOGCRS") {
    return "2015";
  }
  return "2015";
}
function buildPROJJSON(root) {
  const version = detectWKT2Version(root);
  const builder = version === "2019" ? PROJJSONBuilder2019_default : PROJJSONBuilder2015_default;
  return builder.convert(root);
}
var init_buildPROJJSON = __esm({
  "node_modules/wkt-parser/buildPROJJSON.js"() {
    init_PROJJSONBuilder2015();
    init_PROJJSONBuilder2019();
  }
});

// node_modules/wkt-parser/detectWKTVersion.js
function detectWKTVersion(wkt) {
  const normalizedWKT = wkt.toUpperCase();
  if (normalizedWKT.includes("PROJCRS") || normalizedWKT.includes("GEOGCRS") || normalizedWKT.includes("BOUNDCRS") || normalizedWKT.includes("VERTCRS") || normalizedWKT.includes("LENGTHUNIT") || normalizedWKT.includes("ANGLEUNIT") || normalizedWKT.includes("SCALEUNIT")) {
    return "WKT2";
  }
  if (normalizedWKT.includes("PROJCS") || normalizedWKT.includes("GEOGCS") || normalizedWKT.includes("LOCAL_CS") || normalizedWKT.includes("VERT_CS") || normalizedWKT.includes("UNIT")) {
    return "WKT1";
  }
  return "WKT1";
}
var init_detectWKTVersion = __esm({
  "node_modules/wkt-parser/detectWKTVersion.js"() {
  }
});

// node_modules/wkt-parser/parser.js
function Parser(text2) {
  if (typeof text2 !== "string") {
    throw new Error("not a string");
  }
  this.text = text2.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
function parseString2(txt) {
  var parser = new Parser(txt);
  return parser.output();
}
var parser_default, NEUTRAL, KEYWORD, NUMBER, QUOTED, AFTERQUOTE, ENDED, whitespace, latin, keyword, endThings, digets;
var init_parser2 = __esm({
  "node_modules/wkt-parser/parser.js"() {
    parser_default = parseString2;
    NEUTRAL = 1;
    KEYWORD = 2;
    NUMBER = 3;
    QUOTED = 4;
    AFTERQUOTE = 5;
    ENDED = -1;
    whitespace = /\s/;
    latin = /[A-Za-z]/;
    keyword = /[A-Za-z84_]/;
    endThings = /[,\]]/;
    digets = /[\d\.E\-\+]/;
    Parser.prototype.readCharicter = function() {
      var char = this.text[this.place++];
      if (this.state !== QUOTED) {
        while (whitespace.test(char)) {
          if (this.place >= this.text.length) {
            return;
          }
          char = this.text[this.place++];
        }
      }
      switch (this.state) {
        case NEUTRAL:
          return this.neutral(char);
        case KEYWORD:
          return this.keyword(char);
        case QUOTED:
          return this.quoted(char);
        case AFTERQUOTE:
          return this.afterquote(char);
        case NUMBER:
          return this.number(char);
        case ENDED:
          return;
      }
    };
    Parser.prototype.afterquote = function(char) {
      if (char === '"') {
        this.word += '"';
        this.state = QUOTED;
        return;
      }
      if (endThings.test(char)) {
        this.word = this.word.trim();
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
    };
    Parser.prototype.afterItem = function(char) {
      if (char === ",") {
        if (this.word !== null) {
          this.currentObject.push(this.word);
        }
        this.word = null;
        this.state = NEUTRAL;
        return;
      }
      if (char === "]") {
        this.level--;
        if (this.word !== null) {
          this.currentObject.push(this.word);
          this.word = null;
        }
        this.state = NEUTRAL;
        this.currentObject = this.stack.pop();
        if (!this.currentObject) {
          this.state = ENDED;
        }
        return;
      }
    };
    Parser.prototype.number = function(char) {
      if (digets.test(char)) {
        this.word += char;
        return;
      }
      if (endThings.test(char)) {
        this.word = parseFloat(this.word);
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
    };
    Parser.prototype.quoted = function(char) {
      if (char === '"') {
        this.state = AFTERQUOTE;
        return;
      }
      this.word += char;
      return;
    };
    Parser.prototype.keyword = function(char) {
      if (keyword.test(char)) {
        this.word += char;
        return;
      }
      if (char === "[") {
        var newObjects = [];
        newObjects.push(this.word);
        this.level++;
        if (this.root === null) {
          this.root = newObjects;
        } else {
          this.currentObject.push(newObjects);
        }
        this.stack.push(this.currentObject);
        this.currentObject = newObjects;
        this.state = NEUTRAL;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
    };
    Parser.prototype.neutral = function(char) {
      if (latin.test(char)) {
        this.word = char;
        this.state = KEYWORD;
        return;
      }
      if (char === '"') {
        this.word = "";
        this.state = QUOTED;
        return;
      }
      if (digets.test(char)) {
        this.word = char;
        this.state = NUMBER;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
    };
    Parser.prototype.output = function() {
      while (this.place < this.text.length) {
        this.readCharicter();
      }
      if (this.state === ENDED) {
        return this.root;
      }
      throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
    };
  }
});

// node_modules/wkt-parser/process.js
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v4, obj) {
  if (!Array.isArray(v4)) {
    obj[v4] = true;
    return;
  }
  var key = v4.shift();
  if (key === "PARAMETER") {
    key = v4.shift();
  }
  if (v4.length === 1) {
    if (Array.isArray(v4[0])) {
      obj[key] = {};
      sExpr(v4[0], obj[key]);
      return;
    }
    obj[key] = v4[0];
    return;
  }
  if (!v4.length) {
    obj[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj[key] = v4;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v4);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i4;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key] = {
        name: v4[0].toLowerCase(),
        convert: v4[1]
      };
      if (v4.length === 3) {
        sExpr(v4[2], obj[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key] = {
        name: v4[0],
        a: v4[1],
        rf: v4[2]
      };
      if (v4.length === 4) {
        sExpr(v4[3], obj[key]);
      }
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      v4[0] = ["name", v4[0]];
      mapit(obj, key, v4);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      v4[0] = ["name", v4[0]];
      mapit(obj, key, v4);
      obj[key].type = key;
      return;
    default:
      i4 = -1;
      while (++i4 < v4.length) {
        if (!Array.isArray(v4[i4])) {
          return sExpr(v4, obj[key]);
        }
      }
      return mapit(obj, key, v4);
  }
}
var init_process = __esm({
  "node_modules/wkt-parser/process.js"() {
  }
});

// node_modules/wkt-parser/util.js
function d2r(input) {
  return input * D2R2;
}
function applyProjectionDefaults(wkt) {
  const normalizedProjName = (wkt.projName || "").toLowerCase().replace(/_/g, " ");
  if (!wkt.long0 && wkt.longc && (normalizedProjName === "albers conic equal area" || normalizedProjName === "lambert azimuthal equal area")) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (normalizedProjName === "stereographic south pole" || normalizedProjName === "polar stereographic (variant b)")) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
    delete wkt.lat1;
  } else if (!wkt.lat_ts && wkt.lat0 && (normalizedProjName === "polar stereographic" || normalizedProjName === "polar stereographic (variant a)")) {
    wkt.lat_ts = wkt.lat0;
    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
    delete wkt.lat1;
  }
}
var D2R2;
var init_util3 = __esm({
  "node_modules/wkt-parser/util.js"() {
    D2R2 = 0.017453292519943295;
  }
});

// node_modules/wkt-parser/transformPROJJSON.js
function processUnit(unit) {
  let result = { units: null, to_meter: void 0 };
  if (typeof unit === "string") {
    result.units = unit.toLowerCase();
    if (result.units === "metre") {
      result.units = "meter";
    }
    if (result.units === "meter") {
      result.to_meter = 1;
    }
  } else if (unit && unit.name) {
    result.units = unit.name.toLowerCase();
    if (result.units === "metre") {
      result.units = "meter";
    }
    result.to_meter = unit.conversion_factor;
  }
  return result;
}
function toValue(valueOrObject) {
  if (typeof valueOrObject === "object") {
    return valueOrObject.value * valueOrObject.unit.conversion_factor;
  }
  return valueOrObject;
}
function calculateEllipsoid(value, result) {
  if (value.ellipsoid.radius) {
    result.a = value.ellipsoid.radius;
    result.rf = 0;
  } else {
    result.a = toValue(value.ellipsoid.semi_major_axis);
    if (value.ellipsoid.inverse_flattening !== void 0) {
      result.rf = value.ellipsoid.inverse_flattening;
    } else if (value.ellipsoid.semi_major_axis !== void 0 && value.ellipsoid.semi_minor_axis !== void 0) {
      result.rf = result.a / (result.a - toValue(value.ellipsoid.semi_minor_axis));
    }
  }
}
function transformPROJJSON(projjson, result = {}) {
  if (!projjson || typeof projjson !== "object") {
    return projjson;
  }
  if (projjson.type === "BoundCRS") {
    transformPROJJSON(projjson.source_crs, result);
    if (projjson.transformation) {
      if (projjson.transformation.method && projjson.transformation.method.name === "NTv2") {
        result.nadgrids = projjson.transformation.parameters[0].value;
      } else {
        result.datum_params = projjson.transformation.parameters.map((param) => param.value);
      }
    }
    return result;
  }
  Object.keys(projjson).forEach((key) => {
    const value = projjson[key];
    if (value === null) {
      return;
    }
    switch (key) {
      case "name":
        if (result.srsCode) {
          break;
        }
        result.name = value;
        result.srsCode = value;
        break;
      case "type":
        if (value === "GeographicCRS") {
          result.projName = "longlat";
        } else if (value === "ProjectedCRS" && projjson.conversion && projjson.conversion.method) {
          result.projName = projjson.conversion.method.name;
        }
        break;
      case "datum":
      case "datum_ensemble":
        if (value.ellipsoid) {
          result.ellps = value.ellipsoid.name;
          calculateEllipsoid(value, result);
        }
        if (value.prime_meridian) {
          result.from_greenwich = value.prime_meridian.longitude * Math.PI / 180;
        }
        break;
      case "ellipsoid":
        result.ellps = value.name;
        calculateEllipsoid(value, result);
        break;
      case "prime_meridian":
        result.long0 = (value.longitude || 0) * Math.PI / 180;
        break;
      case "coordinate_system":
        if (value.axis) {
          result.axis = value.axis.map((axis) => {
            const direction = axis.direction;
            if (direction === "east") return "e";
            if (direction === "north") return "n";
            if (direction === "west") return "w";
            if (direction === "south") return "s";
            throw new Error(`Unknown axis direction: ${direction}`);
          }).join("") + "u";
          if (value.unit) {
            const { units, to_meter } = processUnit(value.unit);
            result.units = units;
            result.to_meter = to_meter;
          } else if (value.axis[0] && value.axis[0].unit) {
            const { units, to_meter } = processUnit(value.axis[0].unit);
            result.units = units;
            result.to_meter = to_meter;
          }
        }
        break;
      case "id":
        if (value.authority && value.code) {
          result.title = value.authority + ":" + value.code;
        }
        break;
      case "conversion":
        if (value.method && value.method.name) {
          result.projName = value.method.name;
        }
        if (value.parameters) {
          value.parameters.forEach((param) => {
            const paramName = param.name.toLowerCase().replace(/\s+/g, "_");
            const paramValue = param.value;
            if (param.unit && param.unit.conversion_factor) {
              result[paramName] = paramValue * param.unit.conversion_factor;
            } else if (param.unit === "degree") {
              result[paramName] = paramValue * Math.PI / 180;
            } else {
              result[paramName] = paramValue;
            }
          });
        }
        break;
      case "unit":
        if (value.name) {
          result.units = value.name.toLowerCase();
          if (result.units === "metre") {
            result.units = "meter";
          }
        }
        if (value.conversion_factor) {
          result.to_meter = value.conversion_factor;
        }
        break;
      case "base_crs":
        transformPROJJSON(value, result);
        result.datumCode = value.id ? value.id.authority + "_" + value.id.code : value.name;
        break;
      default:
        break;
    }
  });
  if (result.latitude_of_false_origin !== void 0) {
    result.lat0 = result.latitude_of_false_origin;
  }
  if (result.longitude_of_false_origin !== void 0) {
    result.long0 = result.longitude_of_false_origin;
  }
  if (result.latitude_of_standard_parallel !== void 0) {
    result.lat0 = result.latitude_of_standard_parallel;
    result.lat1 = result.latitude_of_standard_parallel;
  }
  if (result.latitude_of_1st_standard_parallel !== void 0) {
    result.lat1 = result.latitude_of_1st_standard_parallel;
  }
  if (result.latitude_of_2nd_standard_parallel !== void 0) {
    result.lat2 = result.latitude_of_2nd_standard_parallel;
  }
  if (result.latitude_of_projection_centre !== void 0) {
    result.lat0 = result.latitude_of_projection_centre;
  }
  if (result.longitude_of_projection_centre !== void 0) {
    result.longc = result.longitude_of_projection_centre;
  }
  if (result.easting_at_false_origin !== void 0) {
    result.x0 = result.easting_at_false_origin;
  }
  if (result.northing_at_false_origin !== void 0) {
    result.y0 = result.northing_at_false_origin;
  }
  if (result.latitude_of_natural_origin !== void 0) {
    result.lat0 = result.latitude_of_natural_origin;
  }
  if (result.longitude_of_natural_origin !== void 0) {
    result.long0 = result.longitude_of_natural_origin;
  }
  if (result.longitude_of_origin !== void 0) {
    result.long0 = result.longitude_of_origin;
  }
  if (result.false_easting !== void 0) {
    result.x0 = result.false_easting;
  }
  if (result.easting_at_projection_centre) {
    result.x0 = result.easting_at_projection_centre;
  }
  if (result.false_northing !== void 0) {
    result.y0 = result.false_northing;
  }
  if (result.northing_at_projection_centre) {
    result.y0 = result.northing_at_projection_centre;
  }
  if (result.standard_parallel_1 !== void 0) {
    result.lat1 = result.standard_parallel_1;
  }
  if (result.standard_parallel_2 !== void 0) {
    result.lat2 = result.standard_parallel_2;
  }
  if (result.scale_factor_at_natural_origin !== void 0) {
    result.k0 = result.scale_factor_at_natural_origin;
  }
  if (result.scale_factor_at_projection_centre !== void 0) {
    result.k0 = result.scale_factor_at_projection_centre;
  }
  if (result.scale_factor_on_pseudo_standard_parallel !== void 0) {
    result.k0 = result.scale_factor_on_pseudo_standard_parallel;
  }
  if (result.azimuth !== void 0) {
    result.alpha = result.azimuth;
  }
  if (result.azimuth_at_projection_centre !== void 0) {
    result.alpha = result.azimuth_at_projection_centre;
  }
  if (result.angle_from_rectified_to_skew_grid) {
    result.rectified_grid_angle = result.angle_from_rectified_to_skew_grid;
  }
  applyProjectionDefaults(result);
  return result;
}
var init_transformPROJJSON = __esm({
  "node_modules/wkt-parser/transformPROJJSON.js"() {
    init_util3();
  }
});

// node_modules/wkt-parser/index.js
function rename(obj, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params2.length === 3) {
      obj[outName] = params2[2](obj[outName]);
    }
  }
}
function cleanWKT(wkt) {
  var keys = Object.keys(wkt);
  for (var i4 = 0, ii = keys.length; i4 < ii; ++i4) {
    var key = keys[i4];
    if (knownTypes.indexOf(key) !== -1) {
      setPropertiesFromWkt(wkt[key]);
    }
    if (typeof wkt[key] === "object") {
      cleanWKT(wkt[key]);
    }
  }
}
function setPropertiesFromWkt(wkt) {
  if (wkt.AUTHORITY) {
    var authority = Object.keys(wkt.AUTHORITY)[0];
    if (authority && authority in wkt.AUTHORITY) {
      wkt.title = authority + ":" + wkt.AUTHORITY[authority];
    }
  }
  if (wkt.type === "GEOGCS") {
    wkt.projName = "longlat";
  } else if (wkt.type === "LOCAL_CS") {
    wkt.projName = "identity";
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = "";
    for (var i4 = 0, ii = wkt.AXIS.length; i4 < ii; ++i4) {
      var axis = [wkt.AXIS[i4][0].toLowerCase(), wkt.AXIS[i4][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === "metre") {
      wkt.units = "meter";
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === "GEOGCS") {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === "GEOGCS") {
    geogcs = wkt;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === "d_") {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === "new_zealand_1949") {
      wkt.datumCode = "nzgd49";
    }
    if (wkt.datumCode === "wgs_1984" || wkt.datumCode === "world_geodetic_system_1984") {
      if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt.sphere = true;
      }
      wkt.datumCode = "wgs84";
    }
    if (wkt.datumCode === "belge_1972") {
      wkt.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = "intl";
      }
      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf("osgb_1936")) {
      wkt.datumCode = "osgb36";
    }
    if (~wkt.datumCode.indexOf("osni_1952")) {
      wkt.datumCode = "osni52";
    }
    if (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt.datumCode = "ire65";
    }
    if (wkt.datumCode === "ch1903+") {
      wkt.datumCode = "ch1903";
    }
    if (~wkt.datumCode.indexOf("israel")) {
      wkt.datumCode = "isr93";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }
  if (wkt.rectified_grid_angle) {
    wkt.rectified_grid_angle = d2r(wkt.rectified_grid_angle);
  }
  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a4) {
    return rename(wkt, a4);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  applyProjectionDefaults(wkt);
}
function wkt_parser_default(wkt) {
  if (typeof wkt === "object") {
    return transformPROJJSON(wkt);
  }
  const version = detectWKTVersion(wkt);
  var lisp = parser_default(wkt);
  if (version === "WKT2") {
    const projjson = buildPROJJSON(lisp);
    return transformPROJJSON(projjson);
  }
  var type = lisp[0];
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj[type];
}
var knownTypes;
var init_wkt_parser = __esm({
  "node_modules/wkt-parser/index.js"() {
    init_buildPROJJSON();
    init_detectWKTVersion();
    init_parser2();
    init_process();
    init_transformPROJJSON();
    init_util3();
    knownTypes = [
      "PROJECTEDCRS",
      "PROJCRS",
      "GEOGCS",
      "GEOCCS",
      "PROJCS",
      "LOCAL_CS",
      "GEODCRS",
      "GEODETICCRS",
      "GEODETICDATUM",
      "ENGCRS",
      "ENGINEERINGCRS"
    ];
  }
});

// node_modules/proj4/lib/defs.js
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[
          /** @type {string} */
          name
        ] = projString_default(arguments[1]);
      } else {
        defs[
          /** @type {string} */
          name
        ] = wkt_parser_default(arguments[1]);
      }
    } else {
      defs[
        /** @type {string} */
        name
      ] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v4) {
        if (Array.isArray(v4)) {
          return defs.apply(that, v4);
        } else {
          return defs(v4);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
var defs_default;
var init_defs = __esm({
  "node_modules/proj4/lib/defs.js"() {
    init_global();
    init_projString();
    init_wkt_parser();
    global_default(defs);
    defs_default = defs;
  }
});

// node_modules/proj4/lib/parseCode.js
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs_default;
}
function testWKT(code) {
  return code.indexOf("+") !== 0 && code.indexOf("[") !== -1 || typeof code === "object" && !("srsCode" in code);
}
function checkMercator(item) {
  var auth = match(item, "authority");
  if (!auth) {
    return;
  }
  var code = match(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, "extension");
  if (!ext) {
    return;
  }
  return match(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse3(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs_default[code];
    }
    if (testWKT(code)) {
      var out = wkt_parser_default(code);
      if (checkMercator(out)) {
        return defs_default["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString_default(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projString_default(code);
    }
  } else if (!("projName" in code)) {
    return wkt_parser_default(code);
  } else {
    return code;
  }
}
var codes, parseCode_default;
var init_parseCode = __esm({
  "node_modules/proj4/lib/parseCode.js"() {
    init_defs();
    init_wkt_parser();
    init_projString();
    init_match();
    codes = ["3857", "900913", "3785", "102113"];
    parseCode_default = parse3;
  }
});

// node_modules/proj4/lib/extend.js
function extend_default(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== void 0) {
      destination[property] = value;
    }
  }
  return destination;
}
var init_extend = __esm({
  "node_modules/proj4/lib/extend.js"() {
  }
});

// node_modules/proj4/lib/common/msfnz.js
function msfnz_default(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}
var init_msfnz = __esm({
  "node_modules/proj4/lib/common/msfnz.js"() {
  }
});

// node_modules/proj4/lib/common/sign.js
function sign_default(x5) {
  return x5 < 0 ? -1 : 1;
}
var init_sign = __esm({
  "node_modules/proj4/lib/common/sign.js"() {
  }
});

// node_modules/proj4/lib/common/adjust_lon.js
function adjust_lon_default(x5) {
  return Math.abs(x5) <= SPI ? x5 : x5 - sign_default(x5) * TWO_PI;
}
var init_adjust_lon = __esm({
  "node_modules/proj4/lib/common/adjust_lon.js"() {
    init_values();
    init_sign();
  }
});

// node_modules/proj4/lib/common/tsfnz.js
function tsfnz_default(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}
var init_tsfnz = __esm({
  "node_modules/proj4/lib/common/tsfnz.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/common/phi2z.js
function phi2z_default(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i4 = 0; i4 <= 15; i4++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}
var init_phi2z = __esm({
  "node_modules/proj4/lib/common/phi2z.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/projections/merc.js
function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward(p4) {
  var lon = p4.x;
  var lat = p4.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x5, y4;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x5 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y4 = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz_default(this.e, lat, sinphi);
      x5 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y4 = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p4.x = x5;
    p4.y = y4;
    return p4;
  }
}
function inverse(p4) {
  var x5 = p4.x - this.x0;
  var y4 = p4.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y4 / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y4 / (this.a * this.k0));
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon_default(this.long0 + x5 / (this.a * this.k0));
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names, merc_default;
var init_merc = __esm({
  "node_modules/proj4/lib/projections/merc.js"() {
    init_msfnz();
    init_adjust_lon();
    init_tsfnz();
    init_phi2z();
    init_values();
    names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "Mercator_Variant_A", "merc"];
    merc_default = {
      init,
      forward,
      inverse,
      names
    };
  }
});

// node_modules/proj4/lib/projections/longlat.js
function init2() {
}
function identity(pt4) {
  return pt4;
}
var names2, longlat_default;
var init_longlat = __esm({
  "node_modules/proj4/lib/projections/longlat.js"() {
    names2 = ["longlat", "identity"];
    longlat_default = {
      init: init2,
      forward: identity,
      inverse: identity,
      names: names2
    };
  }
});

// node_modules/proj4/lib/projections.js
function add4(proj, i4) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i4);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n3) {
    names3[n3.toLowerCase()] = len;
  });
  return this;
}
function getNormalizedProjName(n3) {
  return n3.replace(/[-\(\)\s]+/g, " ").trim().replace(/ /g, "_");
}
function get4(name) {
  if (!name) {
    return false;
  }
  var n3 = name.toLowerCase();
  if (typeof names3[n3] !== "undefined" && projStore[names3[n3]]) {
    return projStore[names3[n3]];
  }
  n3 = getNormalizedProjName(n3);
  if (n3 in names3 && projStore[names3[n3]]) {
    return projStore[names3[n3]];
  }
}
function start() {
  projs.forEach(add4);
}
var projs, names3, projStore, projections_default;
var init_projections2 = __esm({
  "node_modules/proj4/lib/projections.js"() {
    init_merc();
    init_longlat();
    projs = [merc_default, longlat_default];
    names3 = {};
    projStore = [];
    projections_default = {
      start,
      add: add4,
      get: get4
    };
  }
});

// node_modules/proj4/lib/constants/Ellipsoid.js
var ellipsoids, Ellipsoid_default;
var init_Ellipsoid = __esm({
  "node_modules/proj4/lib/constants/Ellipsoid.js"() {
    ellipsoids = {
      MERIT: {
        a: 6378137,
        rf: 298.257,
        ellipseName: "MERIT 1983"
      },
      SGS85: {
        a: 6378136,
        rf: 298.257,
        ellipseName: "Soviet Geodetic System 85"
      },
      GRS80: {
        a: 6378137,
        rf: 298.257222101,
        ellipseName: "GRS 1980(IUGG, 1980)"
      },
      IAU76: {
        a: 6378140,
        rf: 298.257,
        ellipseName: "IAU 1976"
      },
      airy: {
        a: 6377563396e-3,
        b: 635625691e-2,
        ellipseName: "Airy 1830"
      },
      APL4: {
        a: 6378137,
        rf: 298.25,
        ellipseName: "Appl. Physics. 1965"
      },
      NWL9D: {
        a: 6378145,
        rf: 298.25,
        ellipseName: "Naval Weapons Lab., 1965"
      },
      mod_airy: {
        a: 6377340189e-3,
        b: 6356034446e-3,
        ellipseName: "Modified Airy"
      },
      andrae: {
        a: 637710443e-2,
        rf: 300,
        ellipseName: "Andrae 1876 (Den., Iclnd.)"
      },
      aust_SA: {
        a: 6378160,
        rf: 298.25,
        ellipseName: "Australian Natl & S. Amer. 1969"
      },
      GRS67: {
        a: 6378160,
        rf: 298.247167427,
        ellipseName: "GRS 67(IUGG 1967)"
      },
      bessel: {
        a: 6377397155e-3,
        rf: 299.1528128,
        ellipseName: "Bessel 1841"
      },
      bess_nam: {
        a: 6377483865e-3,
        rf: 299.1528128,
        ellipseName: "Bessel 1841 (Namibia)"
      },
      clrk66: {
        a: 63782064e-1,
        b: 63565838e-1,
        ellipseName: "Clarke 1866"
      },
      clrk80: {
        a: 6378249145e-3,
        rf: 293.4663,
        ellipseName: "Clarke 1880 mod."
      },
      clrk80ign: {
        a: 63782492e-1,
        b: 6356515,
        rf: 293.4660213,
        ellipseName: "Clarke 1880 (IGN)"
      },
      clrk58: {
        a: 6378293645208759e-9,
        rf: 294.2606763692654,
        ellipseName: "Clarke 1858"
      },
      CPM: {
        a: 63757387e-1,
        rf: 334.29,
        ellipseName: "Comm. des Poids et Mesures 1799"
      },
      delmbr: {
        a: 6376428,
        rf: 311.5,
        ellipseName: "Delambre 1810 (Belgium)"
      },
      engelis: {
        a: 637813605e-2,
        rf: 298.2566,
        ellipseName: "Engelis 1985"
      },
      evrst30: {
        a: 6377276345e-3,
        rf: 300.8017,
        ellipseName: "Everest 1830"
      },
      evrst48: {
        a: 6377304063e-3,
        rf: 300.8017,
        ellipseName: "Everest 1948"
      },
      evrst56: {
        a: 6377301243e-3,
        rf: 300.8017,
        ellipseName: "Everest 1956"
      },
      evrst69: {
        a: 6377295664e-3,
        rf: 300.8017,
        ellipseName: "Everest 1969"
      },
      evrstSS: {
        a: 6377298556e-3,
        rf: 300.8017,
        ellipseName: "Everest (Sabah & Sarawak)"
      },
      fschr60: {
        a: 6378166,
        rf: 298.3,
        ellipseName: "Fischer (Mercury Datum) 1960"
      },
      fschr60m: {
        a: 6378155,
        rf: 298.3,
        ellipseName: "Fischer 1960"
      },
      fschr68: {
        a: 6378150,
        rf: 298.3,
        ellipseName: "Fischer 1968"
      },
      helmert: {
        a: 6378200,
        rf: 298.3,
        ellipseName: "Helmert 1906"
      },
      hough: {
        a: 6378270,
        rf: 297,
        ellipseName: "Hough"
      },
      intl: {
        a: 6378388,
        rf: 297,
        ellipseName: "International 1909 (Hayford)"
      },
      kaula: {
        a: 6378163,
        rf: 298.24,
        ellipseName: "Kaula 1961"
      },
      lerch: {
        a: 6378139,
        rf: 298.257,
        ellipseName: "Lerch 1979"
      },
      mprts: {
        a: 6397300,
        rf: 191,
        ellipseName: "Maupertius 1738"
      },
      new_intl: {
        a: 63781575e-1,
        b: 63567722e-1,
        ellipseName: "New International 1967"
      },
      plessis: {
        a: 6376523,
        rf: 6355863,
        ellipseName: "Plessis 1817 (France)"
      },
      krass: {
        a: 6378245,
        rf: 298.3,
        ellipseName: "Krassovsky, 1942"
      },
      SEasia: {
        a: 6378155,
        b: 63567733205e-4,
        ellipseName: "Southeast Asia"
      },
      walbeck: {
        a: 6376896,
        b: 63558348467e-4,
        ellipseName: "Walbeck"
      },
      WGS60: {
        a: 6378165,
        rf: 298.3,
        ellipseName: "WGS 60"
      },
      WGS66: {
        a: 6378145,
        rf: 298.25,
        ellipseName: "WGS 66"
      },
      WGS7: {
        a: 6378135,
        rf: 298.26,
        ellipseName: "WGS 72"
      },
      WGS84: {
        a: 6378137,
        rf: 298.257223563,
        ellipseName: "WGS 84"
      },
      sphere: {
        a: 6370997,
        b: 6370997,
        ellipseName: "Normal Sphere (r=6370997)"
      }
    };
    Ellipsoid_default = ellipsoids;
  }
});

// node_modules/proj4/lib/deriveConstants.js
function eccentricity(a4, b5, rf, R_A) {
  var a22 = a4 * a4;
  var b22 = b5 * b5;
  var es = (a22 - b22) / a22;
  var e3 = 0;
  if (R_A) {
    a4 *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a22 = a4 * a4;
    es = 0;
  } else {
    e3 = Math.sqrt(es);
  }
  var ep2 = (a22 - b22) / b22;
  return {
    es,
    e: e3,
    ep2
  };
}
function sphere(a4, b5, rf, ellps, sphere2) {
  if (!a4) {
    var ellipse = match(Ellipsoid_default, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a4 = ellipse.a;
    b5 = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b5) {
    b5 = (1 - 1 / rf) * a4;
  }
  if (rf === 0 || Math.abs(a4 - b5) < EPSLN) {
    sphere2 = true;
    b5 = a4;
  }
  return {
    a: a4,
    b: b5,
    rf,
    sphere: sphere2
  };
}
var WGS84;
var init_deriveConstants = __esm({
  "node_modules/proj4/lib/deriveConstants.js"() {
    init_values();
    init_Ellipsoid();
    init_match();
    WGS84 = Ellipsoid_default.WGS84;
  }
});

// node_modules/proj4/lib/constants/Datum.js
var datums, datum2, key, Datum_default;
var init_Datum = __esm({
  "node_modules/proj4/lib/constants/Datum.js"() {
    datums = {
      wgs84: {
        towgs84: "0,0,0",
        ellipse: "WGS84",
        datumName: "WGS84"
      },
      ch1903: {
        towgs84: "674.374,15.056,405.346",
        ellipse: "bessel",
        datumName: "swiss"
      },
      ggrs87: {
        towgs84: "-199.87,74.79,246.62",
        ellipse: "GRS80",
        datumName: "Greek_Geodetic_Reference_System_1987"
      },
      nad83: {
        towgs84: "0,0,0",
        ellipse: "GRS80",
        datumName: "North_American_Datum_1983"
      },
      nad27: {
        nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
        ellipse: "clrk66",
        datumName: "North_American_Datum_1927"
      },
      potsdam: {
        towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
        ellipse: "bessel",
        datumName: "Potsdam Rauenberg 1950 DHDN"
      },
      carthage: {
        towgs84: "-263.0,6.0,431.0",
        ellipse: "clark80",
        datumName: "Carthage 1934 Tunisia"
      },
      hermannskogel: {
        towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
        ellipse: "bessel",
        datumName: "Hermannskogel"
      },
      mgi: {
        towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
        ellipse: "bessel",
        datumName: "Militar-Geographische Institut"
      },
      osni52: {
        towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
        ellipse: "airy",
        datumName: "Irish National"
      },
      ire65: {
        towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
        ellipse: "mod_airy",
        datumName: "Ireland 1965"
      },
      rassadiran: {
        towgs84: "-133.63,-157.5,-158.62",
        ellipse: "intl",
        datumName: "Rassadiran"
      },
      nzgd49: {
        towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
        ellipse: "intl",
        datumName: "New Zealand Geodetic Datum 1949"
      },
      osgb36: {
        towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
        ellipse: "airy",
        datumName: "Ordnance Survey of Great Britain 1936"
      },
      s_jtsk: {
        towgs84: "589,76,480",
        ellipse: "bessel",
        datumName: "S-JTSK (Ferro)"
      },
      beduaram: {
        towgs84: "-106,-87,188",
        ellipse: "clrk80",
        datumName: "Beduaram"
      },
      gunung_segara: {
        towgs84: "-403,684,41",
        ellipse: "bessel",
        datumName: "Gunung Segara Jakarta"
      },
      rnb72: {
        towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
        ellipse: "intl",
        datumName: "Reseau National Belge 1972"
      },
      EPSG_5451: {
        towgs84: "6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649"
      },
      IGNF_LURESG: {
        towgs84: "-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43"
      },
      EPSG_4614: {
        towgs84: "-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065"
      },
      EPSG_4615: {
        towgs84: "-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748"
      },
      ESRI_37241: {
        towgs84: "-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031"
      },
      ESRI_37249: {
        towgs84: "-440.296,58.548,296.265,1.128,10.202,4.559,-0.438"
      },
      ESRI_37245: {
        towgs84: "-511.151,-181.269,139.609,1.05,2.703,1.798,3.071"
      },
      EPSG_4178: {
        towgs84: "24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01"
      },
      EPSG_4622: {
        towgs84: "-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984"
      },
      EPSG_4625: {
        towgs84: "126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227"
      },
      EPSG_5252: {
        towgs84: "0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439"
      },
      EPSG_4314: {
        towgs84: "597.1,71.4,412.1,0.894,0.068,-1.563,7.58"
      },
      EPSG_4282: {
        towgs84: "-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166"
      },
      EPSG_4231: {
        towgs84: "-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218"
      },
      EPSG_4274: {
        towgs84: "-230.994,102.591,25.199,0.633,-0.239,0.9,1.95"
      },
      EPSG_4134: {
        towgs84: "-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006"
      },
      EPSG_4254: {
        towgs84: "18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013"
      },
      EPSG_4159: {
        towgs84: "-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175"
      },
      EPSG_4687: {
        towgs84: "0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093"
      },
      EPSG_4227: {
        towgs84: "-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225"
      },
      EPSG_4746: {
        towgs84: "599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46"
      },
      EPSG_4745: {
        towgs84: "612.4,77,440.2,-0.054,0.057,-2.797,2.55"
      },
      EPSG_6311: {
        towgs84: "8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926"
      },
      EPSG_4289: {
        towgs84: "565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244"
      },
      EPSG_4230: {
        towgs84: "-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4"
      },
      EPSG_4154: {
        towgs84: "-123.02,-158.95,-168.47"
      },
      EPSG_4156: {
        towgs84: "570.8,85.7,462.8,4.998,1.587,5.261,3.56"
      },
      EPSG_4299: {
        towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
      },
      EPSG_4179: {
        towgs84: "33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84"
      },
      EPSG_4313: {
        towgs84: "-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747"
      },
      EPSG_4194: {
        towgs84: "163.511,127.533,-159.789"
      },
      EPSG_4195: {
        towgs84: "105,326,-102.5"
      },
      EPSG_4196: {
        towgs84: "-45,417,-3.5"
      },
      EPSG_4611: {
        towgs84: "-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246"
      },
      EPSG_4633: {
        towgs84: "137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824"
      },
      EPSG_4641: {
        towgs84: "-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993"
      },
      EPSG_4643: {
        towgs84: "-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002"
      },
      EPSG_4300: {
        towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
      },
      EPSG_4188: {
        towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
      },
      EPSG_4660: {
        towgs84: "982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805"
      },
      EPSG_4662: {
        towgs84: "97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259"
      },
      EPSG_3906: {
        towgs84: "577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664"
      },
      EPSG_4307: {
        towgs84: "-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547"
      },
      EPSG_6892: {
        towgs84: "-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686"
      },
      EPSG_4690: {
        towgs84: "221.597,152.441,176.523,2.403,1.3893,0.884,11.4648"
      },
      EPSG_4691: {
        towgs84: "218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817"
      },
      EPSG_4629: {
        towgs84: "72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653"
      },
      EPSG_4630: {
        towgs84: "165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111"
      },
      EPSG_4692: {
        towgs84: "217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093"
      },
      EPSG_9333: {
        towgs84: "0,0,0,-8.393,0.749,-10.276,0"
      },
      EPSG_9059: {
        towgs84: "0,0,0"
      },
      EPSG_4312: {
        towgs84: "601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887"
      },
      EPSG_4123: {
        towgs84: "-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496"
      },
      EPSG_4309: {
        towgs84: "-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365"
      },
      ESRI_104106: {
        towgs84: "-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058"
      },
      EPSG_4281: {
        towgs84: "-219.247,-73.802,269.529"
      },
      EPSG_4322: {
        towgs84: "0,0,4.5"
      },
      EPSG_4324: {
        towgs84: "0,0,1.9"
      },
      EPSG_4284: {
        towgs84: "43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549"
      },
      EPSG_4277: {
        towgs84: "446.448,-125.157,542.06,0.15,0.247,0.842,-20.489"
      },
      EPSG_4207: {
        towgs84: "-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46"
      },
      EPSG_4688: {
        towgs84: "347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647"
      },
      EPSG_4689: {
        towgs84: "410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218"
      },
      EPSG_4720: {
        towgs84: "0,0,4.5"
      },
      EPSG_4273: {
        towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
      },
      EPSG_4240: {
        towgs84: "204.64,834.74,293.8"
      },
      EPSG_4817: {
        towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
      },
      ESRI_104131: {
        towgs84: "426.62,142.62,460.09,4.98,4.49,-12.42,-17.1"
      },
      EPSG_4265: {
        towgs84: "-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68"
      },
      EPSG_4263: {
        towgs84: "-111.92,-87.85,114.5,1.875,0.202,0.219,0.032"
      },
      EPSG_4298: {
        towgs84: "-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536"
      },
      EPSG_4270: {
        towgs84: "-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424"
      },
      EPSG_4229: {
        towgs84: "-121.8,98.1,-10.7"
      },
      EPSG_4220: {
        towgs84: "-55.5,-348,-229.2"
      },
      EPSG_4214: {
        towgs84: "12.646,-155.176,-80.863"
      },
      EPSG_4232: {
        towgs84: "-345,3,223"
      },
      EPSG_4238: {
        towgs84: "-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037"
      },
      EPSG_4168: {
        towgs84: "-170,33,326"
      },
      EPSG_4131: {
        towgs84: "199,931,318.9"
      },
      EPSG_4152: {
        towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
      },
      EPSG_5228: {
        towgs84: "572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378"
      },
      EPSG_8351: {
        towgs84: "485.021,169.465,483.839,7.786342,4.397554,4.102655,0"
      },
      EPSG_4683: {
        towgs84: "-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06"
      },
      EPSG_4133: {
        towgs84: "0,0,0"
      },
      EPSG_7373: {
        towgs84: "0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693"
      },
      EPSG_9075: {
        towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
      },
      EPSG_9072: {
        towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
      },
      EPSG_9294: {
        towgs84: "1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388"
      },
      EPSG_4212: {
        towgs84: "-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492"
      },
      EPSG_4191: {
        towgs84: "-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703"
      },
      EPSG_4237: {
        towgs84: "52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191"
      },
      EPSG_4740: {
        towgs84: "-1.08,-0.27,-0.9"
      },
      EPSG_4124: {
        towgs84: "419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496"
      },
      EPSG_5681: {
        towgs84: "584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922"
      },
      EPSG_4141: {
        towgs84: "23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262"
      },
      EPSG_4204: {
        towgs84: "-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194"
      },
      EPSG_4319: {
        towgs84: "226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798"
      },
      EPSG_4200: {
        towgs84: "24.82,-131.21,-82.66"
      },
      EPSG_4130: {
        towgs84: "0,0,0"
      },
      EPSG_4127: {
        towgs84: "-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359"
      },
      EPSG_4149: {
        towgs84: "674.374,15.056,405.346"
      },
      EPSG_4617: {
        towgs84: "-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0"
      },
      EPSG_4663: {
        towgs84: "-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485"
      },
      EPSG_4664: {
        towgs84: "-211.939,137.626,58.3,-0.089,0.251,0.079,0.384"
      },
      EPSG_4665: {
        towgs84: "-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048"
      },
      EPSG_4666: {
        towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
      },
      EPSG_4756: {
        towgs84: "-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188"
      },
      EPSG_4723: {
        towgs84: "-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925"
      },
      EPSG_4726: {
        towgs84: "8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081"
      },
      EPSG_4267: {
        towgs84: "-8.0,160.0,176.0"
      },
      EPSG_5365: {
        towgs84: "-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693"
      },
      EPSG_4218: {
        towgs84: "304.5,306.5,-318.1"
      },
      EPSG_4242: {
        towgs84: "-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95"
      },
      EPSG_4216: {
        towgs84: "-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289"
      },
      ESRI_104105: {
        towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
      },
      ESRI_104129: {
        towgs84: "0,0,0"
      },
      EPSG_4673: {
        towgs84: "174.05,-25.49,112.57"
      },
      EPSG_4202: {
        towgs84: "-124,-60,154"
      },
      EPSG_4203: {
        towgs84: "-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191"
      },
      EPSG_3819: {
        towgs84: "595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408"
      },
      EPSG_8694: {
        towgs84: "-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169"
      },
      EPSG_4145: {
        towgs84: "275.57,676.78,229.6"
      },
      EPSG_4283: {
        towgs84: "61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994"
      },
      EPSG_4317: {
        towgs84: "2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266"
      },
      EPSG_4272: {
        towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993"
      },
      EPSG_4248: {
        towgs84: "-307.7,265.3,-363.5"
      },
      EPSG_5561: {
        towgs84: "24,-121,-76"
      },
      EPSG_5233: {
        towgs84: "-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338"
      },
      ESRI_104130: {
        towgs84: "-86,-98,-119"
      },
      ESRI_104102: {
        towgs84: "682,-203,480"
      },
      ESRI_37207: {
        towgs84: "7,-10,-26"
      },
      EPSG_4675: {
        towgs84: "59.935,118.4,-10.871"
      },
      ESRI_104109: {
        towgs84: "-89.121,-348.182,260.871"
      },
      ESRI_104112: {
        towgs84: "-185.583,-230.096,281.361"
      },
      ESRI_104113: {
        towgs84: "25.1,-275.6,222.6"
      },
      IGNF_WGS72G: {
        towgs84: "0,12,6"
      },
      IGNF_NTFG: {
        towgs84: "-168,-60,320"
      },
      IGNF_EFATE57G: {
        towgs84: "-127,-769,472"
      },
      IGNF_PGP50G: {
        towgs84: "324.8,153.6,172.1"
      },
      IGNF_REUN47G: {
        towgs84: "94,-948,-1262"
      },
      IGNF_CSG67G: {
        towgs84: "-186,230,110"
      },
      IGNF_GUAD48G: {
        towgs84: "-467,-16,-300"
      },
      IGNF_TAHI51G: {
        towgs84: "162,117,154"
      },
      IGNF_TAHAAG: {
        towgs84: "65,342,77"
      },
      IGNF_NUKU72G: {
        towgs84: "84,274,65"
      },
      IGNF_PETRELS72G: {
        towgs84: "365,194,166"
      },
      IGNF_WALL78G: {
        towgs84: "253,-133,-127"
      },
      IGNF_MAYO50G: {
        towgs84: "-382,-59,-262"
      },
      IGNF_TANNAG: {
        towgs84: "-139,-967,436"
      },
      IGNF_IGN72G: {
        towgs84: "-13,-348,292"
      },
      IGNF_ATIGG: {
        towgs84: "1118,23,66"
      },
      IGNF_FANGA84G: {
        towgs84: "150.57,158.33,118.32"
      },
      IGNF_RUSAT84G: {
        towgs84: "202.13,174.6,-15.74"
      },
      IGNF_KAUE70G: {
        towgs84: "126.74,300.1,-75.49"
      },
      IGNF_MOP90G: {
        towgs84: "-10.8,-1.8,12.77"
      },
      IGNF_MHPF67G: {
        towgs84: "338.08,212.58,-296.17"
      },
      IGNF_TAHI79G: {
        towgs84: "160.61,116.05,153.69"
      },
      IGNF_ANAA92G: {
        towgs84: "1.5,3.84,4.81"
      },
      IGNF_MARQUI72G: {
        towgs84: "330.91,-13.92,58.56"
      },
      IGNF_APAT86G: {
        towgs84: "143.6,197.82,74.05"
      },
      IGNF_TUBU69G: {
        towgs84: "237.17,171.61,-77.84"
      },
      IGNF_STPM50G: {
        towgs84: "11.363,424.148,373.13"
      },
      EPSG_4150: {
        towgs84: "674.374,15.056,405.346"
      },
      EPSG_4754: {
        towgs84: "-208.4058,-109.8777,-2.5764"
      },
      ESRI_104101: {
        towgs84: "374,150,588"
      },
      EPSG_4693: {
        towgs84: "0,-0.15,0.68"
      },
      EPSG_6207: {
        towgs84: "293.17,726.18,245.36"
      },
      EPSG_4153: {
        towgs84: "-133.63,-157.5,-158.62"
      },
      EPSG_4132: {
        towgs84: "-241.54,-163.64,396.06"
      },
      EPSG_4221: {
        towgs84: "-154.5,150.7,100.4"
      },
      EPSG_4266: {
        towgs84: "-80.7,-132.5,41.1"
      },
      EPSG_4193: {
        towgs84: "-70.9,-151.8,-41.4"
      },
      EPSG_5340: {
        towgs84: "-0.41,0.46,-0.35"
      },
      EPSG_4246: {
        towgs84: "-294.7,-200.1,525.5"
      },
      EPSG_4318: {
        towgs84: "-3.2,-5.7,2.8"
      },
      EPSG_4121: {
        towgs84: "-199.87,74.79,246.62"
      },
      EPSG_4223: {
        towgs84: "-260.1,5.5,432.2"
      },
      EPSG_4158: {
        towgs84: "-0.465,372.095,171.736"
      },
      EPSG_4285: {
        towgs84: "-128.16,-282.42,21.93"
      },
      EPSG_4613: {
        towgs84: "-404.78,685.68,45.47"
      },
      EPSG_4607: {
        towgs84: "195.671,332.517,274.607"
      },
      EPSG_4475: {
        towgs84: "-381.788,-57.501,-256.673"
      },
      EPSG_4208: {
        towgs84: "-157.84,308.54,-146.6"
      },
      EPSG_4743: {
        towgs84: "70.995,-335.916,262.898"
      },
      EPSG_4710: {
        towgs84: "-323.65,551.39,-491.22"
      },
      EPSG_7881: {
        towgs84: "-0.077,0.079,0.086"
      },
      EPSG_4682: {
        towgs84: "283.729,735.942,261.143"
      },
      EPSG_4739: {
        towgs84: "-156,-271,-189"
      },
      EPSG_4679: {
        towgs84: "-80.01,253.26,291.19"
      },
      EPSG_4750: {
        towgs84: "-56.263,16.136,-22.856"
      },
      EPSG_4644: {
        towgs84: "-10.18,-350.43,291.37"
      },
      EPSG_4695: {
        towgs84: "-103.746,-9.614,-255.95"
      },
      EPSG_4292: {
        towgs84: "-355,21,72"
      },
      EPSG_4302: {
        towgs84: "-61.702,284.488,472.052"
      },
      EPSG_4143: {
        towgs84: "-124.76,53,466.79"
      },
      EPSG_4606: {
        towgs84: "-153,153,307"
      },
      EPSG_4699: {
        towgs84: "-770.1,158.4,-498.2"
      },
      EPSG_4247: {
        towgs84: "-273.5,110.6,-357.9"
      },
      EPSG_4160: {
        towgs84: "8.88,184.86,106.69"
      },
      EPSG_4161: {
        towgs84: "-233.43,6.65,173.64"
      },
      EPSG_9251: {
        towgs84: "-9.5,122.9,138.2"
      },
      EPSG_9253: {
        towgs84: "-78.1,101.6,133.3"
      },
      EPSG_4297: {
        towgs84: "-198.383,-240.517,-107.909"
      },
      EPSG_4269: {
        towgs84: "0,0,0"
      },
      EPSG_4301: {
        towgs84: "-147,506,687"
      },
      EPSG_4618: {
        towgs84: "-59,-11,-52"
      },
      EPSG_4612: {
        towgs84: "0,0,0"
      },
      EPSG_4678: {
        towgs84: "44.585,-131.212,-39.544"
      },
      EPSG_4250: {
        towgs84: "-130,29,364"
      },
      EPSG_4144: {
        towgs84: "214,804,268"
      },
      EPSG_4147: {
        towgs84: "-17.51,-108.32,-62.39"
      },
      EPSG_4259: {
        towgs84: "-254.1,-5.36,-100.29"
      },
      EPSG_4164: {
        towgs84: "-76,-138,67"
      },
      EPSG_4211: {
        towgs84: "-378.873,676.002,-46.255"
      },
      EPSG_4182: {
        towgs84: "-422.651,-172.995,84.02"
      },
      EPSG_4224: {
        towgs84: "-143.87,243.37,-33.52"
      },
      EPSG_4225: {
        towgs84: "-205.57,168.77,-4.12"
      },
      EPSG_5527: {
        towgs84: "-67.35,3.88,-38.22"
      },
      EPSG_4752: {
        towgs84: "98,390,-22"
      },
      EPSG_4310: {
        towgs84: "-30,190,89"
      },
      EPSG_9248: {
        towgs84: "-192.26,65.72,132.08"
      },
      EPSG_4680: {
        towgs84: "124.5,-63.5,-281"
      },
      EPSG_4701: {
        towgs84: "-79.9,-158,-168.9"
      },
      EPSG_4706: {
        towgs84: "-146.21,112.63,4.05"
      },
      EPSG_4805: {
        towgs84: "682,-203,480"
      },
      EPSG_4201: {
        towgs84: "-165,-11,206"
      },
      EPSG_4210: {
        towgs84: "-157,-2,-299"
      },
      EPSG_4183: {
        towgs84: "-104,167,-38"
      },
      EPSG_4139: {
        towgs84: "11,72,-101"
      },
      EPSG_4668: {
        towgs84: "-86,-98,-119"
      },
      EPSG_4717: {
        towgs84: "-2,151,181"
      },
      EPSG_4732: {
        towgs84: "102,52,-38"
      },
      EPSG_4280: {
        towgs84: "-377,681,-50"
      },
      EPSG_4209: {
        towgs84: "-138,-105,-289"
      },
      EPSG_4261: {
        towgs84: "31,146,47"
      },
      EPSG_4658: {
        towgs84: "-73,46,-86"
      },
      EPSG_4721: {
        towgs84: "265.025,384.929,-194.046"
      },
      EPSG_4222: {
        towgs84: "-136,-108,-292"
      },
      EPSG_4601: {
        towgs84: "-255,-15,71"
      },
      EPSG_4602: {
        towgs84: "725,685,536"
      },
      EPSG_4603: {
        towgs84: "72,213.7,93"
      },
      EPSG_4605: {
        towgs84: "9,183,236"
      },
      EPSG_4621: {
        towgs84: "137,248,-430"
      },
      EPSG_4657: {
        towgs84: "-28,199,5"
      },
      EPSG_4316: {
        towgs84: "103.25,-100.4,-307.19"
      },
      EPSG_4642: {
        towgs84: "-13,-348,292"
      },
      EPSG_4698: {
        towgs84: "145,-187,103"
      },
      EPSG_4192: {
        towgs84: "-206.1,-174.7,-87.7"
      },
      EPSG_4311: {
        towgs84: "-265,120,-358"
      },
      EPSG_4135: {
        towgs84: "58,-283,-182"
      },
      ESRI_104138: {
        towgs84: "198,-226,-347"
      },
      EPSG_4245: {
        towgs84: "-11,851,5"
      },
      EPSG_4142: {
        towgs84: "-125,53,467"
      },
      EPSG_4213: {
        towgs84: "-106,-87,188"
      },
      EPSG_4253: {
        towgs84: "-133,-77,-51"
      },
      EPSG_4129: {
        towgs84: "-132,-110,-335"
      },
      EPSG_4713: {
        towgs84: "-77,-128,142"
      },
      EPSG_4239: {
        towgs84: "217,823,299"
      },
      EPSG_4146: {
        towgs84: "295,736,257"
      },
      EPSG_4155: {
        towgs84: "-83,37,124"
      },
      EPSG_4165: {
        towgs84: "-173,253,27"
      },
      EPSG_4672: {
        towgs84: "175,-38,113"
      },
      EPSG_4236: {
        towgs84: "-637,-549,-203"
      },
      EPSG_4251: {
        towgs84: "-90,40,88"
      },
      EPSG_4271: {
        towgs84: "-2,374,172"
      },
      EPSG_4175: {
        towgs84: "-88,4,101"
      },
      EPSG_4716: {
        towgs84: "298,-304,-375"
      },
      EPSG_4315: {
        towgs84: "-23,259,-9"
      },
      EPSG_4744: {
        towgs84: "-242.2,-144.9,370.3"
      },
      EPSG_4244: {
        towgs84: "-97,787,86"
      },
      EPSG_4293: {
        towgs84: "616,97,-251"
      },
      EPSG_4714: {
        towgs84: "-127,-769,472"
      },
      EPSG_4736: {
        towgs84: "260,12,-147"
      },
      EPSG_6883: {
        towgs84: "-235,-110,393"
      },
      EPSG_6894: {
        towgs84: "-63,176,185"
      },
      EPSG_4205: {
        towgs84: "-43,-163,45"
      },
      EPSG_4256: {
        towgs84: "41,-220,-134"
      },
      EPSG_4262: {
        towgs84: "639,405,60"
      },
      EPSG_4604: {
        towgs84: "174,359,365"
      },
      EPSG_4169: {
        towgs84: "-115,118,426"
      },
      EPSG_4620: {
        towgs84: "-106,-129,165"
      },
      EPSG_4184: {
        towgs84: "-203,141,53"
      },
      EPSG_4616: {
        towgs84: "-289,-124,60"
      },
      EPSG_9403: {
        towgs84: "-307,-92,127"
      },
      EPSG_4684: {
        towgs84: "-133,-321,50"
      },
      EPSG_4708: {
        towgs84: "-491,-22,435"
      },
      EPSG_4707: {
        towgs84: "114,-116,-333"
      },
      EPSG_4709: {
        towgs84: "145,75,-272"
      },
      EPSG_4712: {
        towgs84: "-205,107,53"
      },
      EPSG_4711: {
        towgs84: "124,-234,-25"
      },
      EPSG_4718: {
        towgs84: "230,-199,-752"
      },
      EPSG_4719: {
        towgs84: "211,147,111"
      },
      EPSG_4724: {
        towgs84: "208,-435,-229"
      },
      EPSG_4725: {
        towgs84: "189,-79,-202"
      },
      EPSG_4735: {
        towgs84: "647,1777,-1124"
      },
      EPSG_4722: {
        towgs84: "-794,119,-298"
      },
      EPSG_4728: {
        towgs84: "-307,-92,127"
      },
      EPSG_4734: {
        towgs84: "-632,438,-609"
      },
      EPSG_4727: {
        towgs84: "912,-58,1227"
      },
      EPSG_4729: {
        towgs84: "185,165,42"
      },
      EPSG_4730: {
        towgs84: "170,42,84"
      },
      EPSG_4733: {
        towgs84: "276,-57,149"
      },
      ESRI_37218: {
        towgs84: "230,-199,-752"
      },
      ESRI_37240: {
        towgs84: "-7,215,225"
      },
      ESRI_37221: {
        towgs84: "252,-209,-751"
      },
      ESRI_4305: {
        towgs84: "-123,-206,219"
      },
      ESRI_104139: {
        towgs84: "-73,-247,227"
      },
      EPSG_4748: {
        towgs84: "51,391,-36"
      },
      EPSG_4219: {
        towgs84: "-384,664,-48"
      },
      EPSG_4255: {
        towgs84: "-333,-222,114"
      },
      EPSG_4257: {
        towgs84: "-587.8,519.75,145.76"
      },
      EPSG_4646: {
        towgs84: "-963,510,-359"
      },
      EPSG_6881: {
        towgs84: "-24,-203,268"
      },
      EPSG_6882: {
        towgs84: "-183,-15,273"
      },
      EPSG_4715: {
        towgs84: "-104,-129,239"
      },
      IGNF_RGF93GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGM04GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGSPM06GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGTAAF07GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGFG95GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGNCG: {
        towgs84: "0,0,0"
      },
      IGNF_RGPFGDD: {
        towgs84: "0,0,0"
      },
      IGNF_ETRS89G: {
        towgs84: "0,0,0"
      },
      IGNF_RGR92GDD: {
        towgs84: "0,0,0"
      },
      EPSG_4173: {
        towgs84: "0,0,0"
      },
      EPSG_4180: {
        towgs84: "0,0,0"
      },
      EPSG_4619: {
        towgs84: "0,0,0"
      },
      EPSG_4667: {
        towgs84: "0,0,0"
      },
      EPSG_4075: {
        towgs84: "0,0,0"
      },
      EPSG_6706: {
        towgs84: "0,0,0"
      },
      EPSG_7798: {
        towgs84: "0,0,0"
      },
      EPSG_4661: {
        towgs84: "0,0,0"
      },
      EPSG_4669: {
        towgs84: "0,0,0"
      },
      EPSG_8685: {
        towgs84: "0,0,0"
      },
      EPSG_4151: {
        towgs84: "0,0,0"
      },
      EPSG_9702: {
        towgs84: "0,0,0"
      },
      EPSG_4758: {
        towgs84: "0,0,0"
      },
      EPSG_4761: {
        towgs84: "0,0,0"
      },
      EPSG_4765: {
        towgs84: "0,0,0"
      },
      EPSG_8997: {
        towgs84: "0,0,0"
      },
      EPSG_4023: {
        towgs84: "0,0,0"
      },
      EPSG_4670: {
        towgs84: "0,0,0"
      },
      EPSG_4694: {
        towgs84: "0,0,0"
      },
      EPSG_4148: {
        towgs84: "0,0,0"
      },
      EPSG_4163: {
        towgs84: "0,0,0"
      },
      EPSG_4167: {
        towgs84: "0,0,0"
      },
      EPSG_4189: {
        towgs84: "0,0,0"
      },
      EPSG_4190: {
        towgs84: "0,0,0"
      },
      EPSG_4176: {
        towgs84: "0,0,0"
      },
      EPSG_4659: {
        towgs84: "0,0,0"
      },
      EPSG_3824: {
        towgs84: "0,0,0"
      },
      EPSG_3889: {
        towgs84: "0,0,0"
      },
      EPSG_4046: {
        towgs84: "0,0,0"
      },
      EPSG_4081: {
        towgs84: "0,0,0"
      },
      EPSG_4558: {
        towgs84: "0,0,0"
      },
      EPSG_4483: {
        towgs84: "0,0,0"
      },
      EPSG_5013: {
        towgs84: "0,0,0"
      },
      EPSG_5264: {
        towgs84: "0,0,0"
      },
      EPSG_5324: {
        towgs84: "0,0,0"
      },
      EPSG_5354: {
        towgs84: "0,0,0"
      },
      EPSG_5371: {
        towgs84: "0,0,0"
      },
      EPSG_5373: {
        towgs84: "0,0,0"
      },
      EPSG_5381: {
        towgs84: "0,0,0"
      },
      EPSG_5393: {
        towgs84: "0,0,0"
      },
      EPSG_5489: {
        towgs84: "0,0,0"
      },
      EPSG_5593: {
        towgs84: "0,0,0"
      },
      EPSG_6135: {
        towgs84: "0,0,0"
      },
      EPSG_6365: {
        towgs84: "0,0,0"
      },
      EPSG_5246: {
        towgs84: "0,0,0"
      },
      EPSG_7886: {
        towgs84: "0,0,0"
      },
      EPSG_8431: {
        towgs84: "0,0,0"
      },
      EPSG_8427: {
        towgs84: "0,0,0"
      },
      EPSG_8699: {
        towgs84: "0,0,0"
      },
      EPSG_8818: {
        towgs84: "0,0,0"
      },
      EPSG_4757: {
        towgs84: "0,0,0"
      },
      EPSG_9140: {
        towgs84: "0,0,0"
      },
      EPSG_8086: {
        towgs84: "0,0,0"
      },
      EPSG_4686: {
        towgs84: "0,0,0"
      },
      EPSG_4737: {
        towgs84: "0,0,0"
      },
      EPSG_4702: {
        towgs84: "0,0,0"
      },
      EPSG_4747: {
        towgs84: "0,0,0"
      },
      EPSG_4749: {
        towgs84: "0,0,0"
      },
      EPSG_4674: {
        towgs84: "0,0,0"
      },
      EPSG_4755: {
        towgs84: "0,0,0"
      },
      EPSG_4759: {
        towgs84: "0,0,0"
      },
      EPSG_4762: {
        towgs84: "0,0,0"
      },
      EPSG_4763: {
        towgs84: "0,0,0"
      },
      EPSG_4764: {
        towgs84: "0,0,0"
      },
      EPSG_4166: {
        towgs84: "0,0,0"
      },
      EPSG_4170: {
        towgs84: "0,0,0"
      },
      EPSG_5546: {
        towgs84: "0,0,0"
      },
      EPSG_7844: {
        towgs84: "0,0,0"
      },
      EPSG_4818: {
        towgs84: "589,76,480"
      }
    };
    for (key in datums) {
      datum2 = datums[key];
      if (!datum2.datumName) {
        continue;
      }
      datums[datum2.datumName] = datum2;
    }
    Datum_default = datums;
  }
});

// node_modules/proj4/lib/datum.js
function datum(datumCode, datum_params, a4, b5, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a4;
  out.b = b5;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var datum_default;
var init_datum = __esm({
  "node_modules/proj4/lib/datum.js"() {
    init_values();
    datum_default = datum;
  }
});

// node_modules/proj4/lib/nadgrid.js
function nadgrid(key, data, options) {
  if (data instanceof ArrayBuffer) {
    return readNTV2Grid(key, data, options);
  }
  return { ready: readGeotiffGrid(key, data) };
}
function readNTV2Grid(key, data, options) {
  var includeErrorFields = true;
  if (options !== void 0 && options.includeErrorFields === false) {
    includeErrorFields = false;
  }
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  var subgrids = readSubgrids(view, header, isLittleEndian, includeErrorFields);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key] = nadgrid2;
  return nadgrid2;
}
async function readGeotiffGrid(key, tiff) {
  var subgrids = [];
  var subGridCount = await tiff.getImageCount();
  for (var subgridIndex = subGridCount - 1; subgridIndex >= 0; subgridIndex--) {
    var image = await tiff.getImage(subgridIndex);
    var rasters = await image.readRasters();
    var data = rasters;
    var lim = [image.getWidth(), image.getHeight()];
    var imageBBoxRadians = image.getBoundingBox().map(degreesToRadians2);
    var del = [image.fileDirectory.ModelPixelScale[0], image.fileDirectory.ModelPixelScale[1]].map(degreesToRadians2);
    var maxX = imageBBoxRadians[0] + (lim[0] - 1) * del[0];
    var minY = imageBBoxRadians[3] - (lim[1] - 1) * del[1];
    var latitudeOffsetBand = data[0];
    var longitudeOffsetBand = data[1];
    var nodes = [];
    for (let i4 = lim[1] - 1; i4 >= 0; i4--) {
      for (let j3 = lim[0] - 1; j3 >= 0; j3--) {
        var index6 = i4 * lim[0] + j3;
        nodes.push([-secondsToRadians(longitudeOffsetBand[index6]), secondsToRadians(latitudeOffsetBand[index6])]);
      }
    }
    subgrids.push({
      del,
      lim,
      ll: [-maxX, minY],
      cvs: nodes
    });
  }
  var tifGrid = {
    header: {
      nSubgrids: subGridCount
    },
    subgrids
  };
  loadedNadgrids[key] = tifGrid;
  return tifGrid;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === "@";
  if (optional) {
    value = value.slice(1);
  }
  if (value === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function degreesToRadians2(degrees) {
  return degrees * Math.PI / 180;
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian, includeErrorFields) {
  var gridOffset = 176;
  var grids = [];
  for (var i4 = 0; i4 < header.nSubgrids; i4++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian, includeErrorFields);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
    );
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
    );
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
    var rowSize = 16;
    if (includeErrorFields === false) {
      rowSize = 8;
    }
    gridOffset += 176 + subHeader.gridNodeCount * rowSize;
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r4) {
    return [secondsToRadians(r4.longitudeShift), secondsToRadians(r4.latitudeShift)];
  });
}
function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset, gridHeader, isLittleEndian, includeErrorFields) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  if (includeErrorFields === false) {
    gridRecordLength = 8;
  }
  var gridShiftRecords = [];
  for (var i4 = 0; i4 < gridHeader.gridNodeCount; i4++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i4 * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i4 * gridRecordLength + 4, isLittleEndian)
    };
    if (includeErrorFields !== false) {
      record.latitudeAccuracy = view.getFloat32(nodesOffset + i4 * gridRecordLength + 8, isLittleEndian);
      record.longitudeAccuracy = view.getFloat32(nodesOffset + i4 * gridRecordLength + 12, isLittleEndian);
    }
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}
var loadedNadgrids;
var init_nadgrid = __esm({
  "node_modules/proj4/lib/nadgrid.js"() {
    loadedNadgrids = {};
  }
});

// node_modules/proj4/lib/Proj.js
function Projection2(srsCode, callback) {
  if (!(this instanceof Projection2)) {
    return new Projection2(srsCode);
  }
  this.forward = null;
  this.inverse = null;
  this.init = null;
  this.name;
  this.names = null;
  this.title;
  callback = callback || function(error2) {
    if (error2) {
      throw error2;
    }
  };
  var json2 = parseCode_default(srsCode);
  if (typeof json2 !== "object") {
    callback("Could not parse to valid json: " + srsCode);
    return;
  }
  var ourProj = Projection2.projections.get(json2.projName);
  if (!ourProj) {
    callback("Could not get projection name from: " + srsCode);
    return;
  }
  if (json2.datumCode && json2.datumCode !== "none") {
    var datumDef = match(Datum_default, json2.datumCode);
    if (datumDef) {
      json2.datum_params = json2.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json2.ellps = datumDef.ellipse;
      json2.datumName = datumDef.datumName ? datumDef.datumName : json2.datumCode;
    }
  }
  json2.k0 = json2.k0 || 1;
  json2.axis = json2.axis || "enu";
  json2.ellps = json2.ellps || "wgs84";
  json2.lat1 = json2.lat1 || json2.lat0;
  var sphere_ = sphere(json2.a, json2.b, json2.rf, json2.ellps, json2.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json2.R_A);
  var nadgrids = getNadgrids(json2.nadgrids);
  var datumObj = json2.datum || datum_default(
    json2.datumCode,
    json2.datum_params,
    sphere_.a,
    sphere_.b,
    ecc.es,
    ecc.ep2,
    nadgrids
  );
  extend_default(this, json2);
  extend_default(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  if ("init" in this && typeof this.init === "function") {
    this.init();
  }
  callback(null, this);
}
var Proj_default;
var init_Proj = __esm({
  "node_modules/proj4/lib/Proj.js"() {
    init_parseCode();
    init_extend();
    init_projections2();
    init_deriveConstants();
    init_Datum();
    init_datum();
    init_match();
    init_nadgrid();
    Projection2.projections = projections_default;
    Projection2.projections.start();
    Proj_default = Projection2;
  }
});

// node_modules/proj4/lib/datumUtils.js
function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false;
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p4, es, a4) {
  var Longitude = p4.x;
  var Latitude = p4.y;
  var Height = p4.z ? p4.z : 0;
  var Rn2;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p4.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p4.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn2 = a4 / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn2 + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn2 + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn2 * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p4, es, a4, b5) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P6;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X4 = p4.x;
  var Y4 = p4.y;
  var Z5 = p4.z ? p4.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P6 = Math.sqrt(X4 * X4 + Y4 * Y4);
  RR = Math.sqrt(X4 * X4 + Y4 * Y4 + Z5 * Z5);
  if (P6 / a4 < genau) {
    Longitude = 0;
    if (RR / a4 < genau) {
      Latitude = HALF_PI;
      Height = -b5;
      return {
        x: p4.x,
        y: p4.y,
        z: p4.z
      };
    }
  } else {
    Longitude = Math.atan2(Y4, X4);
  }
  CT = Z5 / RR;
  ST = P6 / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a4 / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P6 * CPHI0 + Z5 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p4, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p4.x + datum_params[0],
      y: p4.y + datum_params[1],
      z: p4.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p4.x - Rz_BF * p4.y + Ry_BF * p4.z) + Dx_BF,
      y: M_BF * (Rz_BF * p4.x + p4.y - Rx_BF * p4.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p4.x + Rx_BF * p4.y + p4.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p4, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p4.x - datum_params[0],
      y: p4.y - datum_params[1],
      z: p4.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p4.x - Dx_BF) / M_BF;
    var y_tmp = (p4.y - Dy_BF) / M_BF;
    var z_tmp = (p4.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}
var init_datumUtils = __esm({
  "node_modules/proj4/lib/datumUtils.js"() {
    "use strict";
    init_values();
  }
});

// node_modules/proj4/lib/datum_transform.js
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform_default(source, dest, point) {
  if (compareDatums(source, dest)) {
    return point;
  }
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }
  point = geodeticToGeocentric(point, source_es, source_a);
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point;
}
function applyGridShift(source, inverse33, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point.x, y: point.y };
  var output = { x: Number.NaN, y: Number.NaN };
  var attemptedGrids = [];
  outer:
    for (var i4 = 0; i4 < source.grids.length; i4++) {
      var grid = source.grids[i4];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrids = grid.grid.subgrids;
      for (var j3 = 0, jj = subgrids.length; j3 < jj; j3++) {
        var subgrid = subgrids[j3];
        var epsilon2 = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
        var minX = subgrid.ll[0] - epsilon2;
        var minY = subgrid.ll[1] - epsilon2;
        var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon2;
        var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon2;
        if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
          continue;
        }
        output = applySubgridShift(input, inverse33, subgrid);
        if (!isNaN(output.x)) {
          break outer;
        }
      }
    }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse33, ct5) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct5.ll[0];
  tb.y -= ct5.ll[1];
  tb.x = adjust_lon_default(tb.x - Math.PI) + Math.PI;
  var t3 = nadInterpolate(tb, ct5);
  if (inverse33) {
    if (isNaN(t3.x)) {
      return val;
    }
    t3.x = tb.x - t3.x;
    t3.y = tb.y - t3.y;
    var i4 = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t3, ct5);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del.x + t3.x), y: tb.y - (del.y + t3.y) };
      t3.x += dif.x;
      t3.y += dif.y;
    } while (i4-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i4 < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon_default(t3.x + ct5.ll[0]);
    val.y = t3.y + ct5.ll[1];
  } else {
    if (!isNaN(t3.x)) {
      val.x = pin.x + t3.x;
      val.y = pin.y + t3.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct5) {
  var t3 = { x: pin.x / ct5.del[0], y: pin.y / ct5.del[1] };
  var indx = { x: Math.floor(t3.x), y: Math.floor(t3.y) };
  var frct = { x: t3.x - 1 * indx.x, y: t3.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct5.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct5.lim[1]) {
    return val;
  }
  inx = indx.y * ct5.lim[0] + indx.x;
  var f00 = { x: ct5.cvs[inx][0], y: ct5.cvs[inx][1] };
  inx++;
  var f10 = { x: ct5.cvs[inx][0], y: ct5.cvs[inx][1] };
  inx += ct5.lim[0];
  var f11 = { x: ct5.cvs[inx][0], y: ct5.cvs[inx][1] };
  inx--;
  var f01 = { x: ct5.cvs[inx][0], y: ct5.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
var init_datum_transform = __esm({
  "node_modules/proj4/lib/datum_transform.js"() {
    init_values();
    init_datumUtils();
    init_adjust_lon();
  }
});

// node_modules/proj4/lib/adjust_axis.js
function adjust_axis_default(crs, denorm, point) {
  var xin = point.x, yin = point.y, zin = point.z || 0;
  var v4, t3, i4;
  var out = {};
  for (i4 = 0; i4 < 3; i4++) {
    if (denorm && i4 === 2 && point.z === void 0) {
      continue;
    }
    if (i4 === 0) {
      v4 = xin;
      if ("ew".indexOf(crs.axis[i4]) !== -1) {
        t3 = "x";
      } else {
        t3 = "y";
      }
    } else if (i4 === 1) {
      v4 = yin;
      if ("ns".indexOf(crs.axis[i4]) !== -1) {
        t3 = "y";
      } else {
        t3 = "x";
      }
    } else {
      v4 = zin;
      t3 = "z";
    }
    switch (crs.axis[i4]) {
      case "e":
        out[t3] = v4;
        break;
      case "w":
        out[t3] = -v4;
        break;
      case "n":
        out[t3] = v4;
        break;
      case "s":
        out[t3] = -v4;
        break;
      case "u":
        if (point[t3] !== void 0) {
          out.z = v4;
        }
        break;
      case "d":
        if (point[t3] !== void 0) {
          out.z = -v4;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}
var init_adjust_axis = __esm({
  "node_modules/proj4/lib/adjust_axis.js"() {
  }
});

// node_modules/proj4/lib/common/toPoint.js
function toPoint_default(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}
var init_toPoint = __esm({
  "node_modules/proj4/lib/common/toPoint.js"() {
  }
});

// node_modules/proj4/lib/checkSanity.js
function checkSanity_default(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}
var init_checkSanity = __esm({
  "node_modules/proj4/lib/checkSanity.js"() {
  }
});

// node_modules/proj4/lib/transform.js
function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== "WGS84";
}
function transform2(source, dest, point, enforceAxis) {
  var wgs842;
  if (Array.isArray(point)) {
    point = toPoint_default(point);
  } else {
    point = {
      x: point.x,
      y: point.y,
      z: point.z,
      m: point.m
    };
  }
  var hasZ = point.z !== void 0;
  checkSanity_default(point);
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs842 = new Proj_default("WGS84");
    point = transform2(source, wgs842, point, enforceAxis);
    source = wgs842;
  }
  if (enforceAxis && source.axis !== "enu") {
    point = adjust_axis_default(source, false, point);
  }
  if (source.projName === "longlat") {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point);
    if (!point) {
      return;
    }
  }
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }
  point = datum_transform_default(source.datum, dest.datum, point);
  if (!point) {
    return;
  }
  point = /** @type {import('./core').InterfaceCoordinates} */
  point;
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis_default(dest, true, point);
  }
  if (point && !hasZ) {
    delete point.z;
  }
  return point;
}
var init_transform3 = __esm({
  "node_modules/proj4/lib/transform.js"() {
    init_values();
    init_datum_transform();
    init_adjust_axis();
    init_Proj();
    init_toPoint();
    init_checkSanity();
  }
});

// node_modules/proj4/lib/core.js
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform2(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return (
            /** @type {T} */
            [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.slice(3))
          );
        } else {
          return (
            /** @type {T} */
            [transformedArray.x, transformedArray.y, coords[2]].concat(coords.slice(3))
          );
        }
      } else {
        return (
          /** @type {T} */
          [transformedArray.x, transformedArray.y].concat(coords.slice(2))
        );
      }
    } else {
      return (
        /** @type {T} */
        [transformedArray.x, transformedArray.y]
      );
    }
  } else {
    out = transform2(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return (
        /** @type {T} */
        out
      );
    }
    keys.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return (
      /** @type {T} */
      out
    );
  }
}
function checkProj(item) {
  if (item instanceof Proj_default) {
    return item;
  }
  if (typeof item === "object" && "oProj" in item) {
    return item.oProj;
  }
  return Proj_default(
    /** @type {string | PROJJSONDefinition} */
    item
  );
}
function proj4(fromProjOrToProj, toProjOrCoord, coord) {
  var fromProj;
  var toProj;
  var single = false;
  var obj;
  if (typeof toProjOrCoord === "undefined") {
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  } else if (typeof /** @type {?} */
  toProjOrCoord.x !== "undefined" || Array.isArray(toProjOrCoord)) {
    coord = /** @type {T} */
    /** @type {?} */
    toProjOrCoord;
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  }
  if (!fromProj) {
    fromProj = checkProj(fromProjOrToProj);
  }
  if (!toProj) {
    toProj = checkProj(
      /** @type {string | PROJJSONDefinition | proj } */
      toProjOrCoord
    );
  }
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var wgs84, core_default;
var init_core = __esm({
  "node_modules/proj4/lib/core.js"() {
    init_Proj();
    init_transform3();
    wgs84 = Proj_default("WGS84");
    core_default = proj4;
  }
});

// node_modules/mgrs/mgrs.js
function forward2(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse2(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
function toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a4 = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N3, T4, C4, A5, M6;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N3 = a4 / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T4 = Math.tan(LatRad) * Math.tan(LatRad);
  C4 = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A5 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M6 = a4 * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N3 * (A5 + (1 - T4 + C4) * A5 * A5 * A5 / 6 + (5 - 18 * T4 + T4 * T4 + 72 * C4 - 58 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 / 120) + 5e5;
  var UTMNorthing = k0 * (M6 + N3 * Math.tan(LatRad) * (A5 * A5 / 2 + (5 - T4 + 9 * C4 + 4 * C4 * C4) * A5 * A5 * A5 * A5 / 24 + (61 - 58 * T4 + T4 * T4 + 600 * C4 - 330 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 * A5 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm) {
  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a4 = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C13, R1, D5, M6;
  var LongOrigin;
  var mu, phi1Rad;
  var x5 = UTMEasting - 5e5;
  var y4 = UTMNorthing;
  if (zoneLetter < "N") {
    y4 -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M6 = y4 / k0;
  mu = M6 / (a4 * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a4 / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C13 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a4 * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D5 = x5 / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D5 * D5 / 2 - (5 + 3 * T1 + 10 * C13 - 4 * C13 * C13 - 9 * eccPrimeSquared) * D5 * D5 * D5 * D5 / 24 + (61 + 90 * T1 + 298 * C13 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C13 * C13) * D5 * D5 * D5 * D5 * D5 * D5 / 720);
  lat = radToDeg(lat);
  var lon = (D5 - (1 + 2 * T1 + C13) * D5 * D5 * D5 / 6 + (5 - 2 * C13 + 28 * T1 - 3 * C13 * C13 + 8 * eccPrimeSquared + 24 * T1 * T1) * D5 * D5 * D5 * D5 * D5 / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat,
      lon
    };
  }
  return result;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode(utm, accuracy) {
  var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i4) {
  var setParm = i4 % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index6 = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index6);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index6);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z4) {
    colInt = colInt - Z4 + A2 - 1;
    rollover = true;
  }
  if (colInt === I2 || colOrigin < I2 && colInt > I2 || (colInt > I2 || colOrigin < I2) && rollover) {
    colInt++;
  }
  if (colInt === O4 || colOrigin < O4 && colInt > O4 || (colInt > O4 || colOrigin < O4) && rollover) {
    colInt++;
    if (colInt === I2) {
      colInt++;
    }
  }
  if (colInt > Z4) {
    colInt = colInt - Z4 + A2 - 1;
  }
  if (rowInt > V2) {
    rowInt = rowInt - V2 + A2 - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I2 || rowOrigin < I2 && rowInt > I2 || (rowInt > I2 || rowOrigin < I2) && rollover) {
    rowInt++;
  }
  if (rowInt === O4 || rowOrigin < O4 && rowInt > O4 || (rowInt > O4 || rowOrigin < O4) && rollover) {
    rowInt++;
    if (rowInt === I2) {
      rowInt++;
    }
  }
  if (rowInt > V2) {
    rowInt = rowInt - V2 + A2 - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i4 = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i4))) {
    if (i4 >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i4++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i4 === 0 || i4 + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i4++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i4, i4 += 2);
  var set = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i4;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i4, i4 + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i4 + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e3, set) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e3.charCodeAt(0)) {
    curCol++;
    if (curCol === I2) {
      curCol++;
    }
    if (curCol === O4) {
      curCol++;
    }
    if (curCol > Z4) {
      if (rewindMarker) {
        throw "Bad character: " + e3;
      }
      curCol = A2;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n3, set) {
  if (n3 > "V") {
    throw "MGRSPoint given invalid Northing " + n3;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n3.charCodeAt(0)) {
    curRow++;
    if (curRow === I2) {
      curRow++;
    }
    if (curRow === O4) {
      curRow++;
    }
    if (curRow > V2) {
      if (rewindMarker) {
        throw "Bad character: " + n3;
      }
      curRow = A2;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
var NUM_100K_SETS, SET_ORIGIN_COLUMN_LETTERS, SET_ORIGIN_ROW_LETTERS, A2, I2, O4, V2, Z4, mgrs_default;
var init_mgrs = __esm({
  "node_modules/mgrs/mgrs.js"() {
    NUM_100K_SETS = 6;
    SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
    SET_ORIGIN_ROW_LETTERS = "AFAFAF";
    A2 = 65;
    I2 = 73;
    O4 = 79;
    V2 = 86;
    Z4 = 90;
    mgrs_default = {
      forward: forward2,
      inverse: inverse2,
      toPoint
    };
  }
});

// node_modules/proj4/lib/Point.js
function Point2(x5, y4, z3) {
  if (!(this instanceof Point2)) {
    return new Point2(x5, y4, z3);
  }
  if (Array.isArray(x5)) {
    this.x = x5[0];
    this.y = x5[1];
    this.z = x5[2] || 0;
  } else if (typeof x5 === "object") {
    this.x = x5.x;
    this.y = x5.y;
    this.z = x5.z || 0;
  } else if (typeof x5 === "string" && typeof y4 === "undefined") {
    var coords = x5.split(",");
    this.x = parseFloat(coords[0]);
    this.y = parseFloat(coords[1]);
    this.z = parseFloat(coords[2]) || 0;
  } else {
    this.x = x5;
    this.y = y4;
    this.z = z3 || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
var Point_default2;
var init_Point2 = __esm({
  "node_modules/proj4/lib/Point.js"() {
    init_mgrs();
    Point2.fromMGRS = function(mgrsStr) {
      return new Point2(toPoint(mgrsStr));
    };
    Point2.prototype.toMGRS = function(accuracy) {
      return forward2([this.x, this.y], accuracy);
    };
    Point_default2 = Point2;
  }
});

// node_modules/proj4/lib/common/pj_enfn.js
function pj_enfn_default(es) {
  var en3 = [];
  en3[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en3[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t3 = es * es;
  en3[2] = t3 * (C44 - es * (C46 + es * C48));
  t3 *= es;
  en3[3] = t3 * (C66 - es * C68);
  en3[4] = t3 * es * C88;
  return en3;
}
var C00, C02, C04, C06, C08, C22, C44, C46, C48, C66, C68, C88;
var init_pj_enfn = __esm({
  "node_modules/proj4/lib/common/pj_enfn.js"() {
    C00 = 1;
    C02 = 0.25;
    C04 = 0.046875;
    C06 = 0.01953125;
    C08 = 0.01068115234375;
    C22 = 0.75;
    C44 = 0.46875;
    C46 = 0.013020833333333334;
    C48 = 0.007120768229166667;
    C66 = 0.3645833333333333;
    C68 = 0.005696614583333333;
    C88 = 0.3076171875;
  }
});

// node_modules/proj4/lib/common/pj_mlfn.js
function pj_mlfn_default(phi, sphi, cphi, en3) {
  cphi *= sphi;
  sphi *= sphi;
  return en3[0] * phi - cphi * (en3[1] + sphi * (en3[2] + sphi * (en3[3] + sphi * en3[4])));
}
var init_pj_mlfn = __esm({
  "node_modules/proj4/lib/common/pj_mlfn.js"() {
  }
});

// node_modules/proj4/lib/common/pj_inv_mlfn.js
function pj_inv_mlfn_default(arg, es, en3) {
  var k2 = 1 / (1 - es);
  var phi = arg;
  for (var i4 = MAX_ITER; i4; --i4) {
    var s6 = Math.sin(phi);
    var t3 = 1 - es * s6 * s6;
    t3 = (pj_mlfn_default(phi, s6, Math.cos(phi), en3) - arg) * (t3 * Math.sqrt(t3)) * k2;
    phi -= t3;
    if (Math.abs(t3) < EPSLN) {
      return phi;
    }
  }
  return phi;
}
var MAX_ITER;
var init_pj_inv_mlfn = __esm({
  "node_modules/proj4/lib/common/pj_inv_mlfn.js"() {
    init_pj_mlfn();
    init_values();
    MAX_ITER = 20;
  }
});

// node_modules/proj4/lib/projections/tmerc.js
function init3() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.ml0 = pj_mlfn_default(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward3(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var con;
  var x5, y4;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b5 = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b5) - 1) < EPSLN) {
      return 93;
    } else {
      x5 = 0.5 * this.a * this.k0 * Math.log((1 + b5) / (1 - b5)) + this.x0;
      y4 = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b5, 2));
      b5 = Math.abs(y4);
      if (b5 >= 1) {
        if (b5 - 1 > EPSLN) {
          return 93;
        } else {
          y4 = 0;
        }
      } else {
        y4 = Math.acos(y4);
      }
      if (lat < 0) {
        y4 = -y4;
      }
      y4 = this.a * this.k0 * (y4 - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als2 = Math.pow(al, 2);
    var c6 = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c6, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t3 = Math.pow(tq, 2);
    var ts = Math.pow(t3, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn_default(lat, sin_phi, cos_phi, this.en);
    x5 = this.a * (this.k0 * al * (1 + als2 / 6 * (1 - t3 + c6 + als2 / 20 * (5 - 18 * t3 + ts + 14 * c6 - 58 * t3 * c6 + als2 / 42 * (61 + 179 * ts - ts * t3 - 479 * t3))))) + this.x0;
    y4 = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als2 / 12 * (5 - t3 + 9 * c6 + 4 * cs + als2 / 30 * (61 + ts - 58 * t3 + 270 * c6 - 330 * t3 * c6 + als2 / 56 * (1385 + 543 * ts - ts * t3 - 3111 * t3)))))) + this.y0;
  }
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse3(p4) {
  var con, phi;
  var lat, lon;
  var x5 = (p4.x - this.x0) * (1 / this.a);
  var y4 = (p4.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f5 = Math.exp(x5 / this.k0);
    var g3 = 0.5 * (f5 - 1 / f5);
    var temp = this.lat0 + y4 / this.k0;
    var h3 = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h3, 2)) / (1 + Math.pow(g3, 2)));
    lat = Math.asin(con);
    if (y4 < 0) {
      lat = -lat;
    }
    if (g3 === 0 && h3 === 0) {
      lon = 0;
    } else {
      lon = adjust_lon_default(Math.atan2(g3, h3) + this.long0);
    }
  } else {
    con = this.ml0 + y4 / this.k0;
    phi = pj_inv_mlfn_default(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c6 = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c6, 2);
      var t3 = Math.pow(tan_phi, 2);
      var ts = Math.pow(t3, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d2 = x5 * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d2, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t3 - 9 * c6 * t3 + c6 - 4 * cs - ds / 30 * (61 + 90 * t3 - 252 * c6 * t3 + 45 * ts + 46 * c6 - ds / 56 * (1385 + 3633 * t3 + 4095 * ts + 1574 * ts * t3))));
      lon = adjust_lon_default(this.long0 + d2 * (1 - ds / 6 * (1 + 2 * t3 + c6 - ds / 20 * (5 + 28 * t3 + 24 * ts + 8 * c6 * t3 + 6 * c6 - ds / 42 * (61 + 662 * t3 + 1320 * ts + 720 * ts * t3)))) / cos_phi);
    } else {
      lat = HALF_PI * sign_default(y4);
      lon = 0;
    }
  }
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names4, tmerc_default;
var init_tmerc = __esm({
  "node_modules/proj4/lib/projections/tmerc.js"() {
    init_pj_enfn();
    init_pj_mlfn();
    init_pj_inv_mlfn();
    init_adjust_lon();
    init_values();
    init_sign();
    names4 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
    tmerc_default = {
      init: init3,
      forward: forward3,
      inverse: inverse3,
      names: names4
    };
  }
});

// node_modules/proj4/lib/common/sinh.js
function sinh_default(x5) {
  var r4 = Math.exp(x5);
  r4 = (r4 - 1 / r4) / 2;
  return r4;
}
var init_sinh = __esm({
  "node_modules/proj4/lib/common/sinh.js"() {
  }
});

// node_modules/proj4/lib/common/hypot.js
function hypot_default(x5, y4) {
  x5 = Math.abs(x5);
  y4 = Math.abs(y4);
  var a4 = Math.max(x5, y4);
  var b5 = Math.min(x5, y4) / (a4 ? a4 : 1);
  return a4 * Math.sqrt(1 + Math.pow(b5, 2));
}
var init_hypot = __esm({
  "node_modules/proj4/lib/common/hypot.js"() {
  }
});

// node_modules/proj4/lib/common/log1py.js
function log1py_default(x5) {
  var y4 = 1 + x5;
  var z3 = y4 - 1;
  return z3 === 0 ? x5 : x5 * Math.log(y4) / z3;
}
var init_log1py = __esm({
  "node_modules/proj4/lib/common/log1py.js"() {
  }
});

// node_modules/proj4/lib/common/asinhy.js
function asinhy_default(x5) {
  var y4 = Math.abs(x5);
  y4 = log1py_default(y4 * (1 + y4 / (hypot_default(1, y4) + 1)));
  return x5 < 0 ? -y4 : y4;
}
var init_asinhy = __esm({
  "node_modules/proj4/lib/common/asinhy.js"() {
    init_hypot();
    init_log1py();
  }
});

// node_modules/proj4/lib/common/gatg.js
function gatg_default(pp, B4) {
  var cos_2B = 2 * Math.cos(2 * B4);
  var i4 = pp.length - 1;
  var h1 = pp[i4];
  var h22 = 0;
  var h3;
  while (--i4 >= 0) {
    h3 = -h22 + cos_2B * h1 + pp[i4];
    h22 = h1;
    h1 = h3;
  }
  return B4 + h3 * Math.sin(2 * B4);
}
var init_gatg = __esm({
  "node_modules/proj4/lib/common/gatg.js"() {
  }
});

// node_modules/proj4/lib/common/clens.js
function clens_default(pp, arg_r) {
  var r4 = 2 * Math.cos(arg_r);
  var i4 = pp.length - 1;
  var hr1 = pp[i4];
  var hr2 = 0;
  var hr3;
  while (--i4 >= 0) {
    hr3 = -hr2 + r4 * hr1 + pp[i4];
    hr2 = hr1;
    hr1 = hr3;
  }
  return Math.sin(arg_r) * hr3;
}
var init_clens = __esm({
  "node_modules/proj4/lib/common/clens.js"() {
  }
});

// node_modules/proj4/lib/common/cosh.js
function cosh_default(x5) {
  var r4 = Math.exp(x5);
  r4 = (r4 + 1 / r4) / 2;
  return r4;
}
var init_cosh = __esm({
  "node_modules/proj4/lib/common/cosh.js"() {
  }
});

// node_modules/proj4/lib/common/clens_cmplx.js
function clens_cmplx_default(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh_default(arg_i);
  var cosh_arg_i = cosh_default(arg_i);
  var r4 = 2 * cos_arg_r * cosh_arg_i;
  var i4 = -2 * sin_arg_r * sinh_arg_i;
  var j3 = pp.length - 1;
  var hr2 = pp[j3];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr22;
  var hi2;
  while (--j3 >= 0) {
    hr22 = hr1;
    hi2 = hi1;
    hr1 = hr2;
    hi1 = hi;
    hr2 = -hr22 + r4 * hr1 - i4 * hi1 + pp[j3];
    hi = -hi2 + i4 * hr1 + r4 * hi1;
  }
  r4 = sin_arg_r * cosh_arg_i;
  i4 = cos_arg_r * sinh_arg_i;
  return [r4 * hr2 - i4 * hi, r4 * hi + i4 * hr2];
}
var init_clens_cmplx = __esm({
  "node_modules/proj4/lib/common/clens_cmplx.js"() {
    init_sinh();
    init_cosh();
  }
});

// node_modules/proj4/lib/projections/etmerc.js
function init4() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc_default.init.apply(this);
    this.forward = tmerc_default.forward;
    this.inverse = tmerc_default.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f5 = this.es / (1 + Math.sqrt(1 - this.es));
  var n3 = f5 / (2 - f5);
  var np = n3;
  this.cgb[0] = n3 * (2 + n3 * (-2 / 3 + n3 * (-2 + n3 * (116 / 45 + n3 * (26 / 45 + n3 * (-2854 / 675))))));
  this.cbg[0] = n3 * (-2 + n3 * (2 / 3 + n3 * (4 / 3 + n3 * (-82 / 45 + n3 * (32 / 45 + n3 * (4642 / 4725))))));
  np = np * n3;
  this.cgb[1] = np * (7 / 3 + n3 * (-8 / 5 + n3 * (-227 / 45 + n3 * (2704 / 315 + n3 * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n3 * (-16 / 15 + n3 * (-13 / 9 + n3 * (904 / 315 + n3 * (-1522 / 945)))));
  np = np * n3;
  this.cgb[2] = np * (56 / 15 + n3 * (-136 / 35 + n3 * (-1262 / 105 + n3 * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n3 * (34 / 21 + n3 * (8 / 5 + n3 * (-12686 / 2835))));
  np = np * n3;
  this.cgb[3] = np * (4279 / 630 + n3 * (-332 / 35 + n3 * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n3 * (-12 / 5 + n3 * (-24832 / 14175)));
  np = np * n3;
  this.cgb[4] = np * (4174 / 315 + n3 * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n3 * (109598 / 31185));
  np = np * n3;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n3, 2);
  this.Qn = this.k0 / (1 + n3) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n3 * (-0.5 + n3 * (2 / 3 + n3 * (-37 / 96 + n3 * (1 / 360 + n3 * (81 / 512 + n3 * (-96199 / 604800))))));
  this.gtu[0] = n3 * (0.5 + n3 * (-2 / 3 + n3 * (5 / 16 + n3 * (41 / 180 + n3 * (-127 / 288 + n3 * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n3 * (-1 / 15 + n3 * (437 / 1440 + n3 * (-46 / 105 + n3 * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n3 * (-3 / 5 + n3 * (557 / 1440 + n3 * (281 / 630 + n3 * (-1983433 / 1935360)))));
  np = np * n3;
  this.utg[2] = np * (-17 / 480 + n3 * (37 / 840 + n3 * (209 / 4480 + n3 * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n3 * (-103 / 140 + n3 * (15061 / 26880 + n3 * (167603 / 181440))));
  np = np * n3;
  this.utg[3] = np * (-4397 / 161280 + n3 * (11 / 504 + n3 * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n3 * (-179 / 168 + n3 * (6601661 / 7257600)));
  np = np * n3;
  this.utg[4] = np * (-4583 / 161280 + n3 * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n3 * (-3418889 / 1995840));
  np = np * n3;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z5 = gatg_default(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z5 + clens_default(this.gtu, 2 * Z5));
}
function forward4(p4) {
  var Ce3 = adjust_lon_default(p4.x - this.long0);
  var Cn2 = p4.y;
  Cn2 = gatg_default(this.cbg, Cn2);
  var sin_Cn = Math.sin(Cn2);
  var cos_Cn = Math.cos(Cn2);
  var sin_Ce = Math.sin(Ce3);
  var cos_Ce = Math.cos(Ce3);
  Cn2 = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce3 = Math.atan2(sin_Ce * cos_Cn, hypot_default(sin_Cn, cos_Cn * cos_Ce));
  Ce3 = asinhy_default(Math.tan(Ce3));
  var tmp = clens_cmplx_default(this.gtu, 2 * Cn2, 2 * Ce3);
  Cn2 = Cn2 + tmp[0];
  Ce3 = Ce3 + tmp[1];
  var x5;
  var y4;
  if (Math.abs(Ce3) <= 2.623395162778) {
    x5 = this.a * (this.Qn * Ce3) + this.x0;
    y4 = this.a * (this.Qn * Cn2 + this.Zb) + this.y0;
  } else {
    x5 = Infinity;
    y4 = Infinity;
  }
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse4(p4) {
  var Ce3 = (p4.x - this.x0) * (1 / this.a);
  var Cn2 = (p4.y - this.y0) * (1 / this.a);
  Cn2 = (Cn2 - this.Zb) / this.Qn;
  Ce3 = Ce3 / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce3) <= 2.623395162778) {
    var tmp = clens_cmplx_default(this.utg, 2 * Cn2, 2 * Ce3);
    Cn2 = Cn2 + tmp[0];
    Ce3 = Ce3 + tmp[1];
    Ce3 = Math.atan(sinh_default(Ce3));
    var sin_Cn = Math.sin(Cn2);
    var cos_Cn = Math.cos(Cn2);
    var sin_Ce = Math.sin(Ce3);
    var cos_Ce = Math.cos(Ce3);
    Cn2 = Math.atan2(sin_Cn * cos_Ce, hypot_default(sin_Ce, cos_Ce * cos_Cn));
    Ce3 = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon_default(Ce3 + this.long0);
    lat = gatg_default(this.cgb, Cn2);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names5, etmerc_default;
var init_etmerc = __esm({
  "node_modules/proj4/lib/projections/etmerc.js"() {
    init_tmerc();
    init_sinh();
    init_hypot();
    init_asinhy();
    init_gatg();
    init_clens();
    init_clens_cmplx();
    init_adjust_lon();
    names5 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
    etmerc_default = {
      init: init4,
      forward: forward4,
      inverse: inverse4,
      names: names5
    };
  }
});

// node_modules/proj4/lib/common/adjust_zone.js
function adjust_zone_default(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon_default(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}
var init_adjust_zone = __esm({
  "node_modules/proj4/lib/common/adjust_zone.js"() {
    init_adjust_lon();
  }
});

// node_modules/proj4/lib/projections/utm.js
function init5() {
  var zone = adjust_zone_default(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc_default.init.apply(this);
  this.forward = etmerc_default.forward;
  this.inverse = etmerc_default.inverse;
}
var dependsOn, names6, utm_default;
var init_utm2 = __esm({
  "node_modules/proj4/lib/projections/utm.js"() {
    init_adjust_zone();
    init_etmerc();
    init_values();
    dependsOn = "etmerc";
    names6 = ["Universal Transverse Mercator System", "utm"];
    utm_default = {
      init: init5,
      names: names6,
      dependsOn
    };
  }
});

// node_modules/proj4/lib/common/srat.js
function srat_default(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
var init_srat = __esm({
  "node_modules/proj4/lib/common/srat.js"() {
  }
});

// node_modules/proj4/lib/projections/gauss.js
function init6() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat_default(this.e * sphi, this.ratexp));
}
function forward5(p4) {
  var lon = p4.x;
  var lat = p4.y;
  p4.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat_default(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p4.x = this.C * lon;
  return p4;
}
function inverse5(p4) {
  var DEL_TOL = 1e-14;
  var lon = p4.x / this.C;
  var lat = p4.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i4 = MAX_ITER2; i4 > 0; --i4) {
    lat = 2 * Math.atan(num * srat_default(this.e * Math.sin(p4.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p4.y) < DEL_TOL) {
      break;
    }
    p4.y = lat;
  }
  if (!i4) {
    return null;
  }
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var MAX_ITER2, names7, gauss_default;
var init_gauss = __esm({
  "node_modules/proj4/lib/projections/gauss.js"() {
    init_srat();
    init_values();
    MAX_ITER2 = 20;
    names7 = ["gauss"];
    gauss_default = {
      init: init6,
      forward: forward5,
      inverse: inverse5,
      names: names7
    };
  }
});

// node_modules/proj4/lib/projections/sterea.js
function init7() {
  gauss_default.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward6(p4) {
  var sinc, cosc, cosl, k2;
  p4.x = adjust_lon_default(p4.x - this.long0);
  gauss_default.forward.apply(this, [p4]);
  sinc = Math.sin(p4.y);
  cosc = Math.cos(p4.y);
  cosl = Math.cos(p4.x);
  k2 = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p4.x = k2 * cosc * Math.sin(p4.x);
  p4.y = k2 * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p4.x = this.a * p4.x + this.x0;
  p4.y = this.a * p4.y + this.y0;
  return p4;
}
function inverse6(p4) {
  var sinc, cosc, lon, lat, rho;
  p4.x = (p4.x - this.x0) / this.a;
  p4.y = (p4.y - this.y0) / this.a;
  p4.x /= this.k0;
  p4.y /= this.k0;
  if (rho = hypot_default(p4.x, p4.y)) {
    var c6 = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c6);
    cosc = Math.cos(c6);
    lat = Math.asin(cosc * this.sinc0 + p4.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p4.x * sinc, rho * this.cosc0 * cosc - p4.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p4.x = lon;
  p4.y = lat;
  gauss_default.inverse.apply(this, [p4]);
  p4.x = adjust_lon_default(p4.x + this.long0);
  return p4;
}
var names8, sterea_default;
var init_sterea = __esm({
  "node_modules/proj4/lib/projections/sterea.js"() {
    init_gauss();
    init_adjust_lon();
    init_hypot();
    names8 = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
    sterea_default = {
      init: init7,
      forward: forward6,
      inverse: inverse6,
      names: names8
    };
  }
});

// node_modules/proj4/lib/projections/stere.js
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init8() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign_default(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && Math.abs(Math.cos(this.lat_ts)) > EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz_default(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz_default(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward7(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A5, X4, sinX, cosX, ts, rh;
  var dlon = adjust_lon_default(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p4.x = NaN;
    p4.y = NaN;
    return p4;
  }
  if (this.sphere) {
    A5 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p4.x = this.a * A5 * coslat * Math.sin(dlon) + this.x0;
    p4.y = this.a * A5 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p4;
  } else {
    X4 = 2 * Math.atan(ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X4);
    sinX = Math.sin(X4);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz_default(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p4.x = this.x0 + rh * Math.sin(lon - this.long0);
      p4.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p4;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A5 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p4.y = A5 * sinX;
    } else {
      A5 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p4.y = A5 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p4.x = A5 * cosX * Math.sin(dlon) + this.x0;
  }
  return p4;
}
function inverse7(p4) {
  p4.x -= this.x0;
  p4.y -= this.y0;
  var lon, lat, ts, ce3, Chi;
  var rh = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
  if (this.sphere) {
    var c6 = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p4.x = lon;
      p4.y = lat;
      return p4;
    }
    lat = Math.asin(Math.cos(c6) * this.sinlat0 + p4.y * Math.sin(c6) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon_default(this.long0 + Math.atan2(p4.x, -1 * p4.y));
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p4.x, p4.y));
      }
    } else {
      lon = adjust_lon_default(this.long0 + Math.atan2(p4.x * Math.sin(c6), rh * this.coslat0 * Math.cos(c6) - p4.y * this.sinlat0 * Math.sin(c6)));
    }
    p4.x = lon;
    p4.y = lat;
    return p4;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p4.x = lon;
        p4.y = lat;
        return p4;
      }
      p4.x *= this.con;
      p4.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z_default(this.e, ts);
      lon = this.con * adjust_lon_default(this.con * this.long0 + Math.atan2(p4.x, -1 * p4.y));
    } else {
      ce3 = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce3) * this.sinX0 + p4.y * Math.sin(ce3) * this.cosX0 / rh);
        lon = adjust_lon_default(this.long0 + Math.atan2(p4.x * Math.sin(ce3), rh * this.cosX0 * Math.cos(ce3) - p4.y * this.sinX0 * Math.sin(ce3)));
      }
      lat = -1 * phi2z_default(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names9, stere_default;
var init_stere = __esm({
  "node_modules/proj4/lib/projections/stere.js"() {
    init_values();
    init_sign();
    init_msfnz();
    init_tsfnz();
    init_phi2z();
    init_adjust_lon();
    names9 = ["stere", "Stereographic_South_Pole", "Polar_Stereographic_variant_A", "Polar_Stereographic_variant_B", "Polar_Stereographic"];
    stere_default = {
      init: init8,
      forward: forward7,
      inverse: inverse7,
      names: names9,
      ssfn_
    };
  }
});

// node_modules/proj4/lib/projections/somerc.js
function init9() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e23 = 2 * flattening - Math.pow(flattening, 2);
  var e3 = this.e = Math.sqrt(e23);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e23) / (1 - e23 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e23 / (1 - e23) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e3 * sinPhy0) / (1 - e3 * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e3 / 2 * k3;
}
function forward8(p4) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p4.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p4.y)) / (1 - this.e * Math.sin(p4.y)));
  var S3 = -this.alpha * (Sa1 + Sa2) + this.K;
  var b5 = 2 * (Math.atan(Math.exp(S3)) - Math.PI / 4);
  var I4 = this.alpha * (p4.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I4) / (Math.sin(this.b0) * Math.tan(b5) + Math.cos(this.b0) * Math.cos(I4)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b5) - Math.sin(this.b0) * Math.cos(b5) * Math.cos(I4));
  p4.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p4.x = this.R * rotI + this.x0;
  return p4;
}
function inverse8(p4) {
  var Y4 = p4.x - this.x0;
  var X4 = p4.y - this.y0;
  var rotI = Y4 / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X4 / this.R)) - Math.PI / 4);
  var b5 = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I4 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I4 / this.alpha;
  var S3 = 0;
  var phy = b5;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S3 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b5 / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S3)) - Math.PI / 2;
  }
  p4.x = lambda;
  p4.y = phy;
  return p4;
}
var names10, somerc_default;
var init_somerc = __esm({
  "node_modules/proj4/lib/projections/somerc.js"() {
    names10 = ["somerc"];
    somerc_default = {
      init: init9,
      forward: forward8,
      inverse: inverse8,
      names: names10
    };
  }
});

// node_modules/proj4/lib/projections/omerc.js
function isTypeA(P6) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P6.projName === "object" ? Object.keys(P6.projName)[0] : P6.projName;
  return "no_uoff" in P6 || "no_off" in P6 || typeAProjections.indexOf(projectionName) !== -1 || typeAProjections.indexOf(getNormalizedProjName(projectionName)) !== -1;
}
function init10() {
  var con, com, cosph0, D5, F3, H5, L3, sinph0, p4, J3, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D5 = this.B * com / (cosph0 * Math.sqrt(con));
    F3 = D5 * D5 - 1;
    if (F3 <= 0) {
      F3 = 0;
    } else {
      F3 = Math.sqrt(F3);
      if (this.lat0 < 0) {
        F3 = -F3;
      }
    }
    this.E = F3 += D5;
    this.E *= Math.pow(tsfnz_default(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D5 = F3 = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D5);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D5 * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F3 - 1 / F3) * Math.tan(gamma0)) / this.B;
  } else {
    H5 = Math.pow(tsfnz_default(this.e, phi1, Math.sin(phi1)), this.B);
    L3 = Math.pow(tsfnz_default(this.e, phi2, Math.sin(phi2)), this.B);
    F3 = this.E / H5;
    p4 = (L3 - H5) / (L3 + H5);
    J3 = this.E * this.E;
    J3 = (J3 - L3 * H5) / (J3 + L3 * H5);
    con = lam1 - lam2;
    if (con < -Math.PI) {
      lam2 -= TWO_PI;
    } else if (con > Math.PI) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon_default(0.5 * (lam1 + lam2) - Math.atan(J3 * Math.tan(0.5 * this.B * (lam1 - lam2)) / p4) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon_default(lam1 - this.lam0)) / (F3 - 1 / F3));
    gamma = alpha_c = Math.asin(D5 * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D5 * D5 - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F3 = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F3));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F3));
}
function forward9(p4) {
  var coords = {};
  var S3, T4, U4, V4, W3, temp, u6, v4;
  p4.x = p4.x - this.lam0;
  if (Math.abs(Math.abs(p4.y) - HALF_PI) > EPSLN) {
    W3 = this.E / Math.pow(tsfnz_default(this.e, p4.y, Math.sin(p4.y)), this.B);
    temp = 1 / W3;
    S3 = 0.5 * (W3 - temp);
    T4 = 0.5 * (W3 + temp);
    V4 = Math.sin(this.B * p4.x);
    U4 = (S3 * this.singam - V4 * this.cosgam) / T4;
    if (Math.abs(Math.abs(U4) - 1) < EPSLN) {
      throw new Error();
    }
    v4 = 0.5 * this.ArB * Math.log((1 - U4) / (1 + U4));
    temp = Math.cos(this.B * p4.x);
    if (Math.abs(temp) < TOL) {
      u6 = this.A * p4.x;
    } else {
      u6 = this.ArB * Math.atan2(S3 * this.cosgam + V4 * this.singam, temp);
    }
  } else {
    v4 = p4.y > 0 ? this.v_pole_n : this.v_pole_s;
    u6 = this.ArB * p4.y;
  }
  if (this.no_rot) {
    coords.x = u6;
    coords.y = v4;
  } else {
    u6 -= this.u_0;
    coords.x = v4 * this.cosrot + u6 * this.sinrot;
    coords.y = u6 * this.cosrot - v4 * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse9(p4) {
  var u6, v4, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p4.x = (p4.x - this.x0) * (1 / this.a);
  p4.y = (p4.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v4 = p4.y;
    u6 = p4.x;
  } else {
    v4 = p4.x * this.cosrot - p4.y * this.sinrot;
    u6 = p4.y * this.cosrot + p4.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v4);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u6);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z_default(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u6));
  }
  coords.x += this.lam0;
  return coords;
}
var TOL, names11, omerc_default;
var init_omerc = __esm({
  "node_modules/proj4/lib/projections/omerc.js"() {
    init_tsfnz();
    init_adjust_lon();
    init_phi2z();
    init_values();
    init_projections2();
    TOL = 1e-7;
    names11 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Variant_B", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
    omerc_default = {
      init: init10,
      forward: forward9,
      inverse: inverse9,
      names: names11
    };
  }
});

// node_modules/proj4/lib/projections/lcc.js
function init11() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz_default(this.e, sin1, cos1);
  var ts1 = tsfnz_default(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz_default(this.e, sin2, cos2);
  var ts2 = tsfnz_default(this.e, this.lat2, sin2);
  var ts0 = Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN ? 0 : tsfnz_default(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward10(p4) {
  var lon = p4.x;
  var lat = p4.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign_default(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz_default(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  p4.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p4.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p4;
}
function inverse10(p4) {
  var rh1, con, ts;
  var lat, lon;
  var x5 = (p4.x - this.x0) / this.k0;
  var y4 = this.rh - (p4.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x5 * x5 + y4 * y4);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x5 * x5 + y4 * y4);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x5, con * y4);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon_default(theta / this.ns + this.long0);
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names12, lcc_default;
var init_lcc = __esm({
  "node_modules/proj4/lib/projections/lcc.js"() {
    init_msfnz();
    init_tsfnz();
    init_sign();
    init_adjust_lon();
    init_phi2z();
    init_values();
    names12 = [
      "Lambert Tangential Conformal Conic Projection",
      "Lambert_Conformal_Conic",
      "Lambert_Conformal_Conic_1SP",
      "Lambert_Conformal_Conic_2SP",
      "lcc",
      "Lambert Conic Conformal (1SP)",
      "Lambert Conic Conformal (2SP)"
    ];
    lcc_default = {
      init: init11,
      forward: forward10,
      inverse: inverse10,
      names: names12
    };
  }
});

// node_modules/proj4/lib/projections/krovak.js
function init12() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward11(p4) {
  var gfi, u6, deltav, s6, d2, eps, ro;
  var lon = p4.x;
  var lat = p4.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u6 = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s6 = Math.asin(Math.cos(this.ad) * Math.sin(u6) + Math.sin(this.ad) * Math.cos(u6) * Math.cos(deltav));
  d2 = Math.asin(Math.cos(u6) * Math.sin(deltav) / Math.cos(s6));
  eps = this.n * d2;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s6 / 2 + this.s45), this.n);
  p4.y = ro * Math.cos(eps) / 1;
  p4.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p4.y *= -1;
    p4.x *= -1;
  }
  return p4;
}
function inverse11(p4) {
  var u6, deltav, s6, d2, eps, ro, fi1;
  var ok;
  var tmp = p4.x;
  p4.x = p4.y;
  p4.y = tmp;
  if (!this.czech) {
    p4.y *= -1;
    p4.x *= -1;
  }
  ro = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
  eps = Math.atan2(p4.y, p4.x);
  d2 = eps / Math.sin(this.s0);
  s6 = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u6 = Math.asin(Math.cos(this.ad) * Math.sin(s6) - Math.sin(this.ad) * Math.cos(s6) * Math.cos(d2));
  deltav = Math.asin(Math.cos(s6) * Math.sin(d2) / Math.cos(u6));
  p4.x = this.long0 - deltav / this.alfa;
  fi1 = u6;
  ok = 0;
  var iter = 0;
  do {
    p4.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u6 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p4.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p4.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p4;
}
var names13, krovak_default;
var init_krovak = __esm({
  "node_modules/proj4/lib/projections/krovak.js"() {
    init_adjust_lon();
    names13 = ["Krovak", "krovak"];
    krovak_default = {
      init: init12,
      forward: forward11,
      inverse: inverse11,
      names: names13
    };
  }
});

// node_modules/proj4/lib/common/mlfn.js
function mlfn_default(e0, e1, e23, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e23 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}
var init_mlfn = __esm({
  "node_modules/proj4/lib/common/mlfn.js"() {
  }
});

// node_modules/proj4/lib/common/e0fn.js
function e0fn_default(x5) {
  return 1 - 0.25 * x5 * (1 + x5 / 16 * (3 + 1.25 * x5));
}
var init_e0fn = __esm({
  "node_modules/proj4/lib/common/e0fn.js"() {
  }
});

// node_modules/proj4/lib/common/e1fn.js
function e1fn_default(x5) {
  return 0.375 * x5 * (1 + 0.25 * x5 * (1 + 0.46875 * x5));
}
var init_e1fn = __esm({
  "node_modules/proj4/lib/common/e1fn.js"() {
  }
});

// node_modules/proj4/lib/common/e2fn.js
function e2fn_default(x5) {
  return 0.05859375 * x5 * x5 * (1 + 0.75 * x5);
}
var init_e2fn = __esm({
  "node_modules/proj4/lib/common/e2fn.js"() {
  }
});

// node_modules/proj4/lib/common/e3fn.js
function e3fn_default(x5) {
  return x5 * x5 * x5 * (35 / 3072);
}
var init_e3fn = __esm({
  "node_modules/proj4/lib/common/e3fn.js"() {
  }
});

// node_modules/proj4/lib/common/gN.js
function gN_default(a4, e3, sinphi) {
  var temp = e3 * sinphi;
  return a4 / Math.sqrt(1 - temp * temp);
}
var init_gN = __esm({
  "node_modules/proj4/lib/common/gN.js"() {
  }
});

// node_modules/proj4/lib/common/adjust_lat.js
function adjust_lat_default(x5) {
  return Math.abs(x5) < HALF_PI ? x5 : x5 - sign_default(x5) * Math.PI;
}
var init_adjust_lat = __esm({
  "node_modules/proj4/lib/common/adjust_lat.js"() {
    init_values();
    init_sign();
  }
});

// node_modules/proj4/lib/common/imlfn.js
function imlfn_default(ml, e0, e1, e23, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i4 = 0; i4 < 15; i4++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e23 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e23 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
var init_imlfn = __esm({
  "node_modules/proj4/lib/common/imlfn.js"() {
  }
});

// node_modules/proj4/lib/projections/cass.js
function init13() {
  if (!this.sphere) {
    this.e0 = e0fn_default(this.es);
    this.e1 = e1fn_default(this.es);
    this.e2 = e2fn_default(this.es);
    this.e3 = e3fn_default(this.es);
    this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward12(p4) {
  var x5, y4;
  var lam = p4.x;
  var phi = p4.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    x5 = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y4 = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN_default(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
    x5 = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y4 = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p4.x = x5 + this.x0;
  p4.y = y4 + this.y0;
  return p4;
}
function inverse12(p4) {
  p4.x -= this.x0;
  p4.y -= this.y0;
  var x5 = p4.x / this.a;
  var y4 = p4.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y4 + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x5));
    lam = Math.atan2(Math.tan(x5), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y4;
    var phi1 = imlfn_default(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p4.x = this.long0;
      p4.y = HALF_PI;
      if (y4 < 0) {
        p4.y *= -1;
      }
      return p4;
    }
    var nl1 = gN_default(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x5 * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p4.x = adjust_lon_default(lam + this.long0);
  p4.y = adjust_lat_default(phi);
  return p4;
}
var names14, cass_default;
var init_cass = __esm({
  "node_modules/proj4/lib/projections/cass.js"() {
    init_mlfn();
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_gN();
    init_adjust_lon();
    init_adjust_lat();
    init_imlfn();
    init_values();
    names14 = ["Cassini", "Cassini_Soldner", "cass"];
    cass_default = {
      init: init13,
      forward: forward12,
      inverse: inverse12,
      names: names14
    };
  }
});

// node_modules/proj4/lib/common/qsfnz.js
function qsfnz_default(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}
var init_qsfnz = __esm({
  "node_modules/proj4/lib/common/qsfnz.js"() {
  }
});

// node_modules/proj4/lib/projections/laea.js
function init14() {
  var t3 = Math.abs(this.lat0);
  if (Math.abs(t3 - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? S_POLE : N_POLE;
  } else if (Math.abs(t3) < EPSLN) {
    this.mode = EQUIT;
  } else {
    this.mode = OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz_default(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case N_POLE:
        this.dd = 1;
        break;
      case S_POLE:
        this.dd = 1;
        break;
      case EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz_default(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward13(p4) {
  var x5, y4, coslam, sinlam, sinphi, q5, sinb, cosb, b5, cosphi;
  var lam = p4.x;
  var phi = p4.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y4 = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y4 <= EPSLN) {
        return null;
      }
      y4 = Math.sqrt(2 / y4);
      x5 = y4 * cosphi * Math.sin(lam);
      y4 *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y4 = FORTPI - phi * 0.5;
      y4 = 2 * (this.mode === this.S_POLE ? Math.cos(y4) : Math.sin(y4));
      x5 = y4 * Math.sin(lam);
      y4 *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b5 = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q5 = qsfnz_default(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q5 / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b5 = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b5 = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b5 = HALF_PI + phi;
        q5 = this.qp - q5;
        break;
      case this.S_POLE:
        b5 = phi - HALF_PI;
        q5 = this.qp + q5;
        break;
    }
    if (Math.abs(b5) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b5 = Math.sqrt(2 / b5);
        if (this.mode === this.OBLIQ) {
          y4 = this.ymf * b5 * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y4 = (b5 = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x5 = this.xmf * b5 * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q5 >= 0) {
          x5 = (b5 = Math.sqrt(q5)) * sinlam;
          y4 = coslam * (this.mode === this.S_POLE ? b5 : -b5);
        } else {
          x5 = y4 = 0;
        }
        break;
    }
  }
  p4.x = this.a * x5 + this.x0;
  p4.y = this.a * y4 + this.y0;
  return p4;
}
function inverse13(p4) {
  p4.x -= this.x0;
  p4.y -= this.y0;
  var x5 = p4.x / this.a;
  var y4 = p4.y / this.a;
  var lam, phi, cCe, sCe, q5, rho, ab4;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x5 * x5 + y4 * y4);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y4 * sinz / rh);
        x5 *= sinz;
        y4 = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y4 * sinz * this.cosph0 / rh);
        x5 *= sinz * this.cosph0;
        y4 = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y4 = -y4;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y4 === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x5, y4);
  } else {
    ab4 = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x5 /= this.dd;
      y4 *= this.dd;
      rho = Math.sqrt(x5 * x5 + y4 * y4);
      if (rho < EPSLN) {
        p4.x = this.long0;
        p4.y = this.lat0;
        return p4;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x5 *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab4 = cCe * this.sinb1 + y4 * sCe * this.cosb1 / rho;
        q5 = this.qp * ab4;
        y4 = rho * this.cosb1 * cCe - y4 * this.sinb1 * sCe;
      } else {
        ab4 = y4 * sCe / rho;
        q5 = this.qp * ab4;
        y4 = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y4 = -y4;
      }
      q5 = x5 * x5 + y4 * y4;
      if (!q5) {
        p4.x = this.long0;
        p4.y = this.lat0;
        return p4;
      }
      ab4 = 1 - q5 / this.qp;
      if (this.mode === this.S_POLE) {
        ab4 = -ab4;
      }
    }
    lam = Math.atan2(x5, y4);
    phi = authlat(Math.asin(ab4), this.apa);
  }
  p4.x = adjust_lon_default(this.long0 + lam);
  p4.y = phi;
  return p4;
}
function authset(es) {
  var t3;
  var APA = [];
  APA[0] = es * P00;
  t3 = es * es;
  APA[0] += t3 * P01;
  APA[1] = t3 * P10;
  t3 *= es;
  APA[0] += t3 * P02;
  APA[1] += t3 * P11;
  APA[2] = t3 * P20;
  return APA;
}
function authlat(beta, APA) {
  var t3 = beta + beta;
  return beta + APA[0] * Math.sin(t3) + APA[1] * Math.sin(t3 + t3) + APA[2] * Math.sin(t3 + t3 + t3);
}
var S_POLE, N_POLE, EQUIT, OBLIQ, P00, P01, P02, P10, P11, P20, names15, laea_default;
var init_laea = __esm({
  "node_modules/proj4/lib/projections/laea.js"() {
    init_values();
    init_qsfnz();
    init_adjust_lon();
    S_POLE = 1;
    N_POLE = 2;
    EQUIT = 3;
    OBLIQ = 4;
    P00 = 0.3333333333333333;
    P01 = 0.17222222222222222;
    P02 = 0.10257936507936508;
    P10 = 0.06388888888888888;
    P11 = 0.0664021164021164;
    P20 = 0.016415012942191543;
    names15 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
    laea_default = {
      init: init14,
      forward: forward13,
      inverse: inverse13,
      names: names15,
      S_POLE,
      N_POLE,
      EQUIT,
      OBLIQ
    };
  }
});

// node_modules/proj4/lib/common/asinz.js
function asinz_default(x5) {
  if (Math.abs(x5) > 1) {
    x5 = x5 > 1 ? 1 : -1;
  }
  return Math.asin(x5);
}
var init_asinz = __esm({
  "node_modules/proj4/lib/common/asinz.js"() {
  }
});

// node_modules/proj4/lib/projections/aea.js
function init15() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz_default(this.e3, this.sin_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward14(p4) {
  var lon = p4.x;
  var lat = p4.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz_default(this.e3, this.sin_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon_default(lon - this.long0);
  var x5 = rh1 * Math.sin(theta) + this.x0;
  var y4 = this.rh - rh1 * Math.cos(theta) + this.y0;
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse14(p4) {
  var rh1, qs, con, theta, lon, lat;
  p4.x -= this.x0;
  p4.y = this.rh - p4.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p4.x * p4.x + p4.y * p4.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p4.x, con * p4.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon_default(theta / this.ns0 + this.long0);
  p4.x = lon;
  p4.y = lat;
  return p4;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz_default(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i4 = 1; i4 <= 25; i4++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names16, aea_default;
var init_aea = __esm({
  "node_modules/proj4/lib/projections/aea.js"() {
    init_msfnz();
    init_qsfnz();
    init_adjust_lon();
    init_asinz();
    init_values();
    names16 = ["Albers_Conic_Equal_Area", "Albers_Equal_Area", "Albers", "aea"];
    aea_default = {
      init: init15,
      forward: forward14,
      inverse: inverse14,
      names: names16,
      phi1z
    };
  }
});

// node_modules/proj4/lib/projections/gnom.js
function init16() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward15(p4) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g3;
  var x5, y4;
  var lon = p4.x;
  var lat = p4.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g3 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g3 > 0 || Math.abs(g3) <= EPSLN) {
    x5 = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g3;
    y4 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g3;
  } else {
    x5 = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y4 = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse15(p4) {
  var rh;
  var sinc, cosc;
  var c6;
  var lon, lat;
  p4.x = (p4.x - this.x0) / this.a;
  p4.y = (p4.y - this.y0) / this.a;
  p4.x /= this.k0;
  p4.y /= this.k0;
  if (rh = Math.sqrt(p4.x * p4.x + p4.y * p4.y)) {
    c6 = Math.atan2(rh, this.rc);
    sinc = Math.sin(c6);
    cosc = Math.cos(c6);
    lat = asinz_default(cosc * this.sin_p14 + p4.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p4.x * sinc, rh * this.cos_p14 * cosc - p4.y * this.sin_p14 * sinc);
    lon = adjust_lon_default(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names17, gnom_default;
var init_gnom = __esm({
  "node_modules/proj4/lib/projections/gnom.js"() {
    init_adjust_lon();
    init_asinz();
    init_values();
    names17 = ["gnom"];
    gnom_default = {
      init: init16,
      forward: forward15,
      inverse: inverse15,
      names: names17
    };
  }
});

// node_modules/proj4/lib/common/iqsfnz.js
function iqsfnz_default(eccent, q5) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q5) - temp) < 1e-6) {
    if (q5 < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q5);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i4 = 0; i4 < 30; i4++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q5 / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
var init_iqsfnz = __esm({
  "node_modules/proj4/lib/common/iqsfnz.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/projections/cea.js
function init17() {
  if (!this.sphere) {
    this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward16(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var x5, y4;
  var dlon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    x5 = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y4 = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz_default(this.e, Math.sin(lat));
    x5 = this.x0 + this.a * this.k0 * dlon;
    y4 = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse16(p4) {
  p4.x -= this.x0;
  p4.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + p4.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p4.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz_default(this.e, 2 * p4.y * this.k0 / this.a);
    lon = adjust_lon_default(this.long0 + p4.x / (this.a * this.k0));
  }
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names18, cea_default;
var init_cea = __esm({
  "node_modules/proj4/lib/projections/cea.js"() {
    init_adjust_lon();
    init_qsfnz();
    init_msfnz();
    init_iqsfnz();
    names18 = ["cea"];
    cea_default = {
      init: init17,
      forward: forward16,
      inverse: inverse16,
      names: names18
    };
  }
});

// node_modules/proj4/lib/projections/eqc.js
function init18() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward17(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var dlat = adjust_lat_default(lat - this.lat0);
  p4.x = this.x0 + this.a * dlon * this.rc;
  p4.y = this.y0 + this.a * dlat;
  return p4;
}
function inverse17(p4) {
  var x5 = p4.x;
  var y4 = p4.y;
  p4.x = adjust_lon_default(this.long0 + (x5 - this.x0) / (this.a * this.rc));
  p4.y = adjust_lat_default(this.lat0 + (y4 - this.y0) / this.a);
  return p4;
}
var names19, eqc_default;
var init_eqc = __esm({
  "node_modules/proj4/lib/projections/eqc.js"() {
    init_adjust_lon();
    init_adjust_lat();
    names19 = ["Equirectangular", "Equidistant_Cylindrical", "Equidistant_Cylindrical_Spherical", "eqc"];
    eqc_default = {
      init: init18,
      forward: forward17,
      inverse: inverse17,
      names: names19
    };
  }
});

// node_modules/proj4/lib/projections/poly.js
function init19() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward18(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var x5, y4, el;
  var dlon = adjust_lon_default(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x5 = this.a * dlon;
      y4 = -1 * this.a * this.lat0;
    } else {
      x5 = this.a * Math.sin(el) / Math.tan(lat);
      y4 = this.a * (adjust_lat_default(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x5 = this.a * dlon;
      y4 = -1 * this.ml0;
    } else {
      var nl = gN_default(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x5 = nl * Math.sin(el);
      y4 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p4.x = x5 + this.x0;
  p4.y = y4 + this.y0;
  return p4;
}
function inverse18(p4) {
  var lon, lat, x5, y4, i4;
  var al, bl;
  var phi, dphi;
  x5 = p4.x - this.x0;
  y4 = p4.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y4 + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon_default(x5 / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y4 / this.a;
      bl = x5 * x5 / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i4 = MAX_ITER3; i4; --i4) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon_default(this.long0 + Math.asin(x5 * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y4 + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon_default(this.long0 + x5 / this.a);
    } else {
      al = (this.ml0 + y4) / this.a;
      bl = x5 * x5 / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i4 = MAX_ITER3; i4; --i4) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon_default(this.long0 + Math.asin(x5 * cl / this.a) / Math.sin(lat));
    }
  }
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var MAX_ITER3, names20, poly_default;
var init_poly = __esm({
  "node_modules/proj4/lib/projections/poly.js"() {
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_adjust_lon();
    init_adjust_lat();
    init_mlfn();
    init_values();
    init_gN();
    MAX_ITER3 = 20;
    names20 = ["Polyconic", "American_Polyconic", "poly"];
    poly_default = {
      init: init19,
      forward: forward18,
      inverse: inverse18,
      names: names20
    };
  }
});

// node_modules/proj4/lib/projections/nzmg.js
function init20() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward19(p4) {
  var n3;
  var lon = p4.x;
  var lat = p4.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n3 = 1; n3 <= 10; n3++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n3] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n3 = 1; n3 <= 6; n3++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n3] * th_n_re - this.B_im[n3] * th_n_im;
    z_im = z_im + this.B_im[n3] * th_n_re + this.B_re[n3] * th_n_im;
  }
  p4.x = z_im * this.a + this.x0;
  p4.y = z_re * this.a + this.y0;
  return p4;
}
function inverse19(p4) {
  var n3;
  var x5 = p4.x;
  var y4 = p4.y;
  var delta_x = x5 - this.x0;
  var delta_y = y4 - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n3 = 1; n3 <= 6; n3++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n3] * z_n_re - this.C_im[n3] * z_n_im;
    th_im = th_im + this.C_im[n3] * z_n_re + this.C_re[n3] * z_n_im;
  }
  for (var i4 = 0; i4 < this.iterations; i4++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n3 = 2; n3 <= 6; n3++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n3 - 1) * (this.B_re[n3] * th_n_re - this.B_im[n3] * th_n_im);
      num_im = num_im + (n3 - 1) * (this.B_im[n3] * th_n_re + this.B_re[n3] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n3 = 2; n3 <= 6; n3++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n3 * (this.B_re[n3] * th_n_re - this.B_im[n3] * th_n_im);
      den_im = den_im + n3 * (this.B_im[n3] * th_n_re + this.B_re[n3] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n3 = 1; n3 <= 9; n3++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n3] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names21, nzmg_default;
var init_nzmg = __esm({
  "node_modules/proj4/lib/projections/nzmg.js"() {
    init_values();
    names21 = ["New_Zealand_Map_Grid", "nzmg"];
    nzmg_default = {
      init: init20,
      forward: forward19,
      inverse: inverse19,
      names: names21
    };
  }
});

// node_modules/proj4/lib/projections/mill.js
function init21() {
}
function forward20(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x5 = this.x0 + this.a * dlon;
  var y4 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse20(p4) {
  p4.x -= this.x0;
  p4.y -= this.y0;
  var lon = adjust_lon_default(this.long0 + p4.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p4.y / this.a)) - Math.PI / 4);
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names22, mill_default;
var init_mill = __esm({
  "node_modules/proj4/lib/projections/mill.js"() {
    init_adjust_lon();
    names22 = ["Miller_Cylindrical", "mill"];
    mill_default = {
      init: init21,
      forward: forward20,
      inverse: inverse20,
      names: names22
    };
  }
});

// node_modules/proj4/lib/projections/sinu.js
function init22() {
  if (!this.sphere) {
    this.en = pj_enfn_default(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward21(p4) {
  var x5, y4;
  var lon = p4.x;
  var lat = p4.y;
  lon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k2 = this.n * Math.sin(lat);
      for (var i4 = MAX_ITER4; i4; --i4) {
        var V4 = (this.m * lat + Math.sin(lat) - k2) / (this.m + Math.cos(lat));
        lat -= V4;
        if (Math.abs(V4) < EPSLN) {
          break;
        }
      }
    }
    x5 = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y4 = this.a * this.C_y * lat;
  } else {
    var s6 = Math.sin(lat);
    var c6 = Math.cos(lat);
    y4 = this.a * pj_mlfn_default(lat, s6, c6, this.en);
    x5 = this.a * lon * c6 / Math.sqrt(1 - this.es * s6 * s6);
  }
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse21(p4) {
  var lat, temp, lon, s6;
  p4.x -= this.x0;
  lon = p4.x / this.a;
  p4.y -= this.y0;
  lat = p4.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz_default((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz_default(Math.sin(lat) / this.n);
    }
    lon = adjust_lon_default(lon + this.long0);
    lat = adjust_lat_default(lat);
  } else {
    lat = pj_inv_mlfn_default(p4.y / this.a, this.es, this.en);
    s6 = Math.abs(lat);
    if (s6 < HALF_PI) {
      s6 = Math.sin(lat);
      temp = this.long0 + p4.x * Math.sqrt(1 - this.es * s6 * s6) / (this.a * Math.cos(lat));
      lon = adjust_lon_default(temp);
    } else if (s6 - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var MAX_ITER4, names23, sinu_default;
var init_sinu = __esm({
  "node_modules/proj4/lib/projections/sinu.js"() {
    init_adjust_lon();
    init_adjust_lat();
    init_pj_enfn();
    init_pj_mlfn();
    init_pj_inv_mlfn();
    init_values();
    init_asinz();
    MAX_ITER4 = 20;
    names23 = ["Sinusoidal", "sinu"];
    sinu_default = {
      init: init22,
      forward: forward21,
      inverse: inverse21,
      names: names23
    };
  }
});

// node_modules/proj4/lib/projections/moll.js
function init23() {
}
function forward22(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x5 = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y4 = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse22(p4) {
  var theta;
  var arg;
  p4.x -= this.x0;
  p4.y -= this.y0;
  arg = p4.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon_default(this.long0 + p4.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names24, moll_default;
var init_moll = __esm({
  "node_modules/proj4/lib/projections/moll.js"() {
    init_adjust_lon();
    init_values();
    names24 = ["Mollweide", "moll"];
    moll_default = {
      init: init23,
      forward: forward22,
      inverse: inverse22,
      names: names24
    };
  }
});

// node_modules/proj4/lib/projections/eqdc.js
function init24() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.sin_phi = Math.sin(this.lat1);
  this.cos_phi = Math.cos(this.lat1);
  this.ms1 = msfnz_default(this.e, this.sin_phi, this.cos_phi);
  this.ml1 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sin_phi;
  } else {
    this.sin_phi = Math.sin(this.lat2);
    this.cos_phi = Math.cos(this.lat2);
    this.ms2 = msfnz_default(this.e, this.sin_phi, this.cos_phi);
    this.ml2 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward23(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn_default(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  var x5 = this.x0 + rh1 * Math.sin(theta);
  var y4 = this.y0 + this.rh - rh1 * Math.cos(theta);
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse23(p4) {
  p4.x -= this.x0;
  p4.y = this.rh - p4.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p4.x * p4.x + p4.y * p4.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p4.x, con * p4.y);
  }
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    lat = adjust_lat_default(this.g - rh1 / this.a);
    p4.x = lon;
    p4.y = lat;
    return p4;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn_default(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    p4.x = lon;
    p4.y = lat;
    return p4;
  }
}
var names25, eqdc_default;
var init_eqdc = __esm({
  "node_modules/proj4/lib/projections/eqdc.js"() {
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_msfnz();
    init_mlfn();
    init_adjust_lon();
    init_adjust_lat();
    init_imlfn();
    init_values();
    names25 = ["Equidistant_Conic", "eqdc"];
    eqdc_default = {
      init: init24,
      forward: forward23,
      inverse: inverse23,
      names: names25
    };
  }
});

// node_modules/proj4/lib/projections/vandg.js
function init25() {
  this.R = this.a;
}
function forward24(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x5, y4;
  if (Math.abs(lat) <= EPSLN) {
    x5 = this.x0 + this.R * dlon;
    y4 = this.y0;
  }
  var theta = asinz_default(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x5 = this.x0;
    if (lat >= 0) {
      y4 = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y4 = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g3 = costh / (sinth + costh - 1);
  var gsq = g3 * g3;
  var m5 = g3 * (2 / sinth - 1);
  var msq = m5 * m5;
  var con = Math.PI * this.R * (al * (g3 - msq) + Math.sqrt(asq * (g3 - msq) * (g3 - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x5 = this.x0 + con;
  var q5 = asq + g3;
  con = Math.PI * this.R * (m5 * q5 - al * Math.sqrt((msq + asq) * (asq + 1) - q5 * q5)) / (msq + asq);
  if (lat >= 0) {
    y4 = this.y0 + con;
  } else {
    y4 = this.y0 - con;
  }
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse24(p4) {
  var lon, lat;
  var xx, yy, xys, c1, c22, c32;
  var a1;
  var m1;
  var con;
  var th1;
  var d2;
  p4.x -= this.x0;
  p4.y -= this.y0;
  con = Math.PI * this.R;
  xx = p4.x / con;
  yy = p4.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c22 = c1 - 2 * yy * yy + xx * xx;
  c32 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d2 = yy * yy / c32 + (2 * c22 * c22 * c22 / c32 / c32 / c32 - 9 * c1 * c22 / c32 / c32) / 27;
  a1 = (c1 - c22 * c22 / 3 / c32) / c32;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d2 / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p4.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c22 / 3 / c32) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c22 / 3 / c32) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon_default(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names26, vandg_default;
var init_vandg = __esm({
  "node_modules/proj4/lib/projections/vandg.js"() {
    init_adjust_lon();
    init_values();
    init_asinz();
    names26 = ["Van_der_Grinten_I", "VanDerGrinten", "Van_der_Grinten", "vandg"];
    vandg_default = {
      init: init25,
      forward: forward24,
      inverse: inverse24,
      names: names26
    };
  }
});

// node_modules/proj4/lib/common/vincenty.js
function vincentyInverse(lat1, lon1, lat2, lon2, a4, f5) {
  const L3 = lon2 - lon1;
  const U1 = Math.atan((1 - f5) * Math.tan(lat1));
  const U22 = Math.atan((1 - f5) * Math.tan(lat2));
  const sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
  const sinU2 = Math.sin(U22), cosU2 = Math.cos(U22);
  let lambda = L3, lambdaP, iterLimit = 100;
  let sinLambda, cosLambda, sinSigma, cosSigma, sigma, sinAlpha, cos2Alpha, cos2SigmaM, C4;
  let uSq, A5, B4, deltaSigma, s6;
  do {
    sinLambda = Math.sin(lambda);
    cosLambda = Math.cos(lambda);
    sinSigma = Math.sqrt(
      cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)
    );
    if (sinSigma === 0) {
      return { azi1: 0, s12: 0 };
    }
    cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
    sigma = Math.atan2(sinSigma, cosSigma);
    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
    cos2Alpha = 1 - sinAlpha * sinAlpha;
    cos2SigmaM = cos2Alpha !== 0 ? cosSigma - 2 * sinU1 * sinU2 / cos2Alpha : 0;
    C4 = f5 / 16 * cos2Alpha * (4 + f5 * (4 - 3 * cos2Alpha));
    lambdaP = lambda;
    lambda = L3 + (1 - C4) * f5 * sinAlpha * (sigma + C4 * sinSigma * (cos2SigmaM + C4 * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return { azi1: NaN, s12: NaN };
  }
  uSq = cos2Alpha * (a4 * a4 - a4 * (1 - f5) * (a4 * (1 - f5))) / (a4 * (1 - f5) * (a4 * (1 - f5)));
  A5 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  B4 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  deltaSigma = B4 * sinSigma * (cos2SigmaM + B4 / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B4 / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
  s6 = a4 * (1 - f5) * A5 * (sigma - deltaSigma);
  const azi1 = Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
  return { azi1, s12: s6 };
}
function vincentyDirect(lat1, lon1, azi1, s12, a4, f5) {
  const U1 = Math.atan((1 - f5) * Math.tan(lat1));
  const sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
  const sinAlpha1 = Math.sin(azi1), cosAlpha1 = Math.cos(azi1);
  const sigma1 = Math.atan2(sinU1, cosU1 * cosAlpha1);
  const sinAlpha = cosU1 * sinAlpha1;
  const cos2Alpha = 1 - sinAlpha * sinAlpha;
  const uSq = cos2Alpha * (a4 * a4 - a4 * (1 - f5) * (a4 * (1 - f5))) / (a4 * (1 - f5) * (a4 * (1 - f5)));
  const A5 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  const B4 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  let sigma = s12 / (a4 * (1 - f5) * A5), sigmaP, iterLimit = 100;
  let cos2SigmaM, sinSigma, cosSigma, deltaSigma;
  do {
    cos2SigmaM = Math.cos(2 * sigma1 + sigma);
    sinSigma = Math.sin(sigma);
    cosSigma = Math.cos(sigma);
    deltaSigma = B4 * sinSigma * (cos2SigmaM + B4 / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B4 / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
    sigmaP = sigma;
    sigma = s12 / (a4 * (1 - f5) * A5) + deltaSigma;
  } while (Math.abs(sigma - sigmaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return { lat2: NaN, lon2: NaN };
  }
  const tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;
  const lat2 = Math.atan2(
    sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1,
    (1 - f5) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp)
  );
  const lambda = Math.atan2(
    sinSigma * sinAlpha1,
    cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1
  );
  const C4 = f5 / 16 * cos2Alpha * (4 + f5 * (4 - 3 * cos2Alpha));
  const L3 = lambda - (1 - C4) * f5 * sinAlpha * (sigma + C4 * sinSigma * (cos2SigmaM + C4 * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  const lon2 = lon1 + L3;
  return { lat2, lon2 };
}
var init_vincenty = __esm({
  "node_modules/proj4/lib/common/vincenty.js"() {
  }
});

// node_modules/proj4/lib/projections/aeqd.js
function init26() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
  this.f = this.es / (1 + Math.sqrt(1 - this.es));
}
function forward25(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var sinphi = Math.sin(p4.y);
  var cosphi = Math.cos(p4.y);
  var dlon = adjust_lon_default(lon - this.long0);
  var e0, e1, e23, e3, Mlp, Ml, c6, kp, cos_c, vars, azi1;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p4.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p4.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p4;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p4.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p4.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p4;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c6 = Math.acos(cos_c);
      kp = c6 ? c6 / Math.sin(c6) : 1;
      p4.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p4.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p4;
    }
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e23 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e23, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e23, e3, lat);
      p4.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p4.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p4;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e23, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e23, e3, lat);
      p4.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p4.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p4;
    } else {
      if (Math.abs(lon) < EPSLN && Math.abs(lat - this.lat0) < EPSLN) {
        p4.x = p4.y = 0;
        return p4;
      }
      vars = vincentyInverse(this.lat0, this.long0, lat, lon, this.a, this.f);
      azi1 = vars.azi1;
      p4.x = vars.s12 * Math.sin(azi1);
      p4.y = vars.s12 * Math.cos(azi1);
      return p4;
    }
  }
}
function inverse25(p4) {
  p4.x -= this.x0;
  p4.y -= this.y0;
  var rh, z3, sinz, cosz, lon, lat, con, e0, e1, e23, e3, Mlp, M6, azi1, s12, vars;
  if (this.sphere) {
    rh = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z3 = rh / this.a;
    sinz = Math.sin(z3);
    cosz = Math.cos(z3);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz_default(cosz * this.sin_p12 + p4.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon_default(this.long0 + Math.atan2(p4.x, -p4.y));
        } else {
          lon = adjust_lon_default(this.long0 - Math.atan2(-p4.x, p4.y));
        }
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p4.x * sinz, rh * this.cos_p12 * cosz - p4.y * this.sin_p12 * sinz));
      }
    }
    p4.x = lon;
    p4.y = lat;
    return p4;
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e23 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e23, e3, HALF_PI);
      rh = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
      M6 = Mlp - rh;
      lat = imlfn_default(M6 / this.a, e0, e1, e23, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p4.x, -1 * p4.y));
      p4.x = lon;
      p4.y = lat;
      return p4;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e23, e3, HALF_PI);
      rh = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
      M6 = rh - Mlp;
      lat = imlfn_default(M6 / this.a, e0, e1, e23, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p4.x, p4.y));
      p4.x = lon;
      p4.y = lat;
      return p4;
    } else {
      azi1 = Math.atan2(p4.x, p4.y);
      s12 = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
      vars = vincentyDirect(this.lat0, this.long0, azi1, s12, this.a, this.f);
      p4.x = vars.lon2;
      p4.y = vars.lat2;
      return p4;
    }
  }
}
var names27, aeqd_default;
var init_aeqd = __esm({
  "node_modules/proj4/lib/projections/aeqd.js"() {
    init_adjust_lon();
    init_values();
    init_mlfn();
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_asinz();
    init_imlfn();
    init_vincenty();
    names27 = ["Azimuthal_Equidistant", "aeqd"];
    aeqd_default = {
      init: init26,
      forward: forward25,
      inverse: inverse25,
      names: names27
    };
  }
});

// node_modules/proj4/lib/projections/ortho.js
function init27() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward26(p4) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g3, x5, y4;
  var lon = p4.x;
  var lat = p4.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g3 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g3 > 0 || Math.abs(g3) <= EPSLN) {
    x5 = this.a * ksp * cosphi * Math.sin(dlon);
    y4 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p4.x = x5;
  p4.y = y4;
  return p4;
}
function inverse26(p4) {
  var rh;
  var z3;
  var sinz, cosz;
  var con;
  var lon, lat;
  p4.x -= this.x0;
  p4.y -= this.y0;
  rh = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
  z3 = asinz_default(rh / this.a);
  sinz = Math.sin(z3);
  cosz = Math.cos(z3);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p4.x = lon;
    p4.y = lat;
    return p4;
  }
  lat = asinz_default(cosz * this.sin_p14 + p4.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon_default(this.long0 + Math.atan2(p4.x, -p4.y));
    } else {
      lon = adjust_lon_default(this.long0 - Math.atan2(-p4.x, p4.y));
    }
    p4.x = lon;
    p4.y = lat;
    return p4;
  }
  lon = adjust_lon_default(this.long0 + Math.atan2(p4.x * sinz, rh * this.cos_p14 * cosz - p4.y * this.sin_p14 * sinz));
  p4.x = lon;
  p4.y = lat;
  return p4;
}
var names28, ortho_default;
var init_ortho = __esm({
  "node_modules/proj4/lib/projections/ortho.js"() {
    init_adjust_lon();
    init_asinz();
    init_values();
    names28 = ["ortho"];
    ortho_default = {
      init: init27,
      forward: forward26,
      inverse: inverse26,
      names: names28
    };
  }
});

// node_modules/proj4/lib/projections/qsc.js
function init28() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward27(p4) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t3, mu;
  var area = { value: 0 };
  p4.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p4.y));
  } else {
    lat = p4.y;
  }
  lon = p4.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q5, r4, s6;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q5 = coslat * coslon;
    r4 = coslat * sinlon;
    s6 = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q5);
      theta = qsc_fwd_equat_face_theta(phi, s6, r4, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r4);
      theta = qsc_fwd_equat_face_theta(phi, s6, -q5, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q5);
      theta = qsc_fwd_equat_face_theta(phi, s6, -r4, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r4);
      theta = qsc_fwd_equat_face_theta(phi, s6, q5, area);
    } else {
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t3 = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t3 * Math.cos(mu);
  xy.y = t3 * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p4.x = xy.x;
  p4.y = xy.y;
  return p4;
}
function inverse27(p4) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t3;
  var area = { value: 0 };
  p4.x = (p4.x - this.x0) / this.a;
  p4.y = (p4.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p4.x * p4.x + p4.y * p4.y));
  mu = Math.atan2(p4.y, p4.x);
  if (p4.x >= 0 && p4.x >= Math.abs(p4.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p4.y >= 0 && p4.y >= Math.abs(p4.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p4.x < 0 && -p4.x >= Math.abs(p4.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t3 = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t3) / (Math.cos(t3) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q5, r4, s6;
    q5 = cosphi;
    t3 = q5 * q5;
    if (t3 >= 1) {
      s6 = 0;
    } else {
      s6 = Math.sqrt(1 - t3) * Math.sin(theta);
    }
    t3 += s6 * s6;
    if (t3 >= 1) {
      r4 = 0;
    } else {
      r4 = Math.sqrt(1 - t3);
    }
    if (area.value === AREA_ENUM.AREA_1) {
      t3 = r4;
      r4 = -s6;
      s6 = t3;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r4 = -r4;
      s6 = -s6;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t3 = r4;
      r4 = s6;
      s6 = -t3;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t3 = q5;
      q5 = -r4;
      r4 = t3;
    } else if (this.face === FACE_ENUM.BACK) {
      q5 = -q5;
      r4 = -r4;
    } else if (this.face === FACE_ENUM.LEFT) {
      t3 = q5;
      q5 = r4;
      r4 = -t3;
    }
    lp.phi = Math.acos(-s6) - HALF_PI;
    lp.lam = Math.atan2(r4, q5);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p4.x = lp.lam;
  p4.y = lp.phi;
  return p4;
}
function qsc_fwd_equat_face_theta(phi, y4, x5, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y4, x5);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var FACE_ENUM, AREA_ENUM, names29, qsc_default;
var init_qsc = __esm({
  "node_modules/proj4/lib/projections/qsc.js"() {
    init_values();
    FACE_ENUM = {
      FRONT: 1,
      RIGHT: 2,
      BACK: 3,
      LEFT: 4,
      TOP: 5,
      BOTTOM: 6
    };
    AREA_ENUM = {
      AREA_0: 1,
      AREA_1: 2,
      AREA_2: 3,
      AREA_3: 4
    };
    names29 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
    qsc_default = {
      init: init28,
      forward: forward27,
      inverse: inverse27,
      names: names29
    };
  }
});

// node_modules/proj4/lib/projections/robin.js
function newton_rapshon(f_df, start2, max_err, iters) {
  var x5 = start2;
  for (; iters; --iters) {
    var upd = f_df(x5);
    x5 -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x5;
}
function init29() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward28(ll) {
  var lon = adjust_lon_default(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i4 = Math.floor(dphi * C1);
  if (i4 < 0) {
    i4 = 0;
  } else if (i4 >= NODES) {
    i4 = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i4);
  var xy = {
    x: poly3_val(COEFS_X[i4], dphi) * lon,
    y: poly3_val(COEFS_Y[i4], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse28(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i4 = Math.floor(ll.y * NODES);
    if (i4 < 0) {
      i4 = 0;
    } else if (i4 >= NODES) {
      i4 = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i4][0] > ll.y) {
        --i4;
      } else if (COEFS_Y[i4 + 1][0] <= ll.y) {
        ++i4;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i4];
    var t3 = 5 * (ll.y - coefs[0]) / (COEFS_Y[i4 + 1][0] - coefs[0]);
    t3 = newton_rapshon(function(x5) {
      return (poly3_val(coefs, x5) - ll.y) / poly3_der(coefs, x5);
    }, t3, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i4], t3);
    ll.y = (5 * i4 + t3) * D2R;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon_default(ll.x + this.long0);
  return ll;
}
var COEFS_X, COEFS_Y, FXC, FYC, C1, RC1, NODES, poly3_val, poly3_der, names30, robin_default;
var init_robin = __esm({
  "node_modules/proj4/lib/projections/robin.js"() {
    init_values();
    init_adjust_lon();
    COEFS_X = [
      [1, 22199e-21, -715515e-10, 31103e-10],
      [0.9986, -482243e-9, -24897e-9, -13309e-10],
      [0.9954, -83103e-8, -448605e-10, -986701e-12],
      [0.99, -135364e-8, -59661e-9, 36777e-10],
      [0.9822, -167442e-8, -449547e-11, -572411e-11],
      [0.973, -214868e-8, -903571e-10, 18736e-12],
      [0.96, -305085e-8, -900761e-10, 164917e-11],
      [0.9427, -382792e-8, -653386e-10, -26154e-10],
      [0.9216, -467746e-8, -10457e-8, 481243e-11],
      [0.8962, -536223e-8, -323831e-10, -543432e-11],
      [0.8679, -609363e-8, -113898e-9, 332484e-11],
      [0.835, -698325e-8, -640253e-10, 934959e-12],
      [0.7986, -755338e-8, -500009e-10, 935324e-12],
      [0.7597, -798324e-8, -35971e-9, -227626e-11],
      [0.7186, -851367e-8, -701149e-10, -86303e-10],
      [0.6732, -986209e-8, -199569e-9, 191974e-10],
      [0.6213, -0.010418, 883923e-10, 624051e-11],
      [0.5722, -906601e-8, 182e-6, 624051e-11],
      [0.5322, -677797e-8, 275608e-9, 624051e-11]
    ];
    COEFS_Y = [
      [-520417e-23, 0.0124, 121431e-23, -845284e-16],
      [0.062, 0.0124, -126793e-14, 422642e-15],
      [0.124, 0.0124, 507171e-14, -160604e-14],
      [0.186, 0.0123999, -190189e-13, 600152e-14],
      [0.248, 0.0124002, 710039e-13, -224e-10],
      [0.31, 0.0123992, -264997e-12, 835986e-13],
      [0.372, 0.0124029, 988983e-12, -311994e-12],
      [0.434, 0.0123893, -369093e-11, -435621e-12],
      [0.4958, 0.0123198, -102252e-10, -345523e-12],
      [0.5571, 0.0121916, -154081e-10, -582288e-12],
      [0.6176, 0.0119938, -241424e-10, -525327e-12],
      [0.6769, 0.011713, -320223e-10, -516405e-12],
      [0.7346, 0.0113541, -397684e-10, -609052e-12],
      [0.7903, 0.0109107, -489042e-10, -104739e-11],
      [0.8435, 0.0103431, -64615e-9, -140374e-14],
      [0.8936, 969686e-8, -64636e-9, -8547e-9],
      [0.9394, 840947e-8, -192841e-9, -42106e-10],
      [0.9761, 616527e-8, -256e-6, -42106e-10],
      [1, 328947e-8, -319159e-9, -42106e-10]
    ];
    FXC = 0.8487;
    FYC = 1.3523;
    C1 = R2D / 5;
    RC1 = 1 / C1;
    NODES = 18;
    poly3_val = function(coefs, x5) {
      return coefs[0] + x5 * (coefs[1] + x5 * (coefs[2] + x5 * coefs[3]));
    };
    poly3_der = function(coefs, x5) {
      return coefs[1] + x5 * (2 * coefs[2] + x5 * 3 * coefs[3]);
    };
    names30 = ["Robinson", "robin"];
    robin_default = {
      init: init29,
      forward: forward28,
      inverse: inverse28,
      names: names30
    };
  }
});

// node_modules/proj4/lib/projections/geocent.js
function init30() {
  this.name = "geocent";
}
function forward29(p4) {
  var point = geodeticToGeocentric(p4, this.es, this.a);
  return point;
}
function inverse29(p4) {
  var point = geocentricToGeodetic(p4, this.es, this.a, this.b);
  return point;
}
var names31, geocent_default;
var init_geocent = __esm({
  "node_modules/proj4/lib/projections/geocent.js"() {
    init_datumUtils();
    names31 = ["Geocentric", "geocentric", "geocent", "Geocent"];
    geocent_default = {
      init: init30,
      forward: forward29,
      inverse: inverse29,
      names: names31
    };
  }
});

// node_modules/proj4/lib/projections/tpers.js
function init31() {
  Object.keys(params).forEach(function(p4) {
    if (typeof this[p4] === "undefined") {
      this[p4] = params[p4].def;
    } else if (params[p4].num && isNaN(this[p4])) {
      throw new Error("Invalid parameter value, must be numeric " + p4 + " = " + this[p4]);
    } else if (params[p4].num) {
      this[p4] = parseFloat(this[p4]);
    }
    if (params[p4].degrees) {
      this[p4] = this[p4] * D2R;
    }
  }.bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward30(p4) {
  p4.x -= this.long0;
  var sinphi = Math.sin(p4.y);
  var cosphi = Math.cos(p4.y);
  var coslam = Math.cos(p4.x);
  var x5, y4;
  switch (this.mode) {
    case mode.OBLIQ:
      y4 = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y4 = cosphi * coslam;
      break;
    case mode.S_POLE:
      y4 = -sinphi;
      break;
    case mode.N_POLE:
      y4 = sinphi;
      break;
  }
  y4 = this.pn1 / (this.p - y4);
  x5 = y4 * cosphi * Math.sin(p4.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y4 *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y4 *= sinphi;
      break;
    case mode.N_POLE:
      y4 *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y4 *= cosphi * coslam;
      break;
  }
  var yt4, ba;
  yt4 = y4 * this.cg + x5 * this.sg;
  ba = 1 / (yt4 * this.sw * this.h1 + this.cw);
  x5 = (x5 * this.cg - y4 * this.sg) * this.cw * ba;
  y4 = yt4 * ba;
  p4.x = x5 * this.a;
  p4.y = y4 * this.a;
  return p4;
}
function inverse30(p4) {
  p4.x /= this.a;
  p4.y /= this.a;
  var r4 = { x: p4.x, y: p4.y };
  var bm, bq, yt4;
  yt4 = 1 / (this.pn1 - p4.y * this.sw);
  bm = this.pn1 * p4.x * yt4;
  bq = this.pn1 * p4.y * this.cw * yt4;
  p4.x = bm * this.cg + bq * this.sg;
  p4.y = bq * this.cg - bm * this.sg;
  var rh = hypot_default(p4.x, p4.y);
  if (Math.abs(rh) < EPSLN) {
    r4.x = 0;
    r4.y = p4.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r4.y = Math.asin(cosz * this.sinph0 + p4.y * sinz * this.cosph0 / rh);
        p4.y = (cosz - this.sinph0 * Math.sin(r4.y)) * rh;
        p4.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r4.y = Math.asin(p4.y * sinz / rh);
        p4.y = cosz * rh;
        p4.x *= sinz;
        break;
      case mode.N_POLE:
        r4.y = Math.asin(cosz);
        p4.y = -p4.y;
        break;
      case mode.S_POLE:
        r4.y = -Math.asin(cosz);
        break;
    }
    r4.x = Math.atan2(p4.x, p4.y);
  }
  p4.x = r4.x + this.long0;
  p4.y = r4.y;
  return p4;
}
var mode, params, names32, tpers_default;
var init_tpers = __esm({
  "node_modules/proj4/lib/projections/tpers.js"() {
    init_values();
    init_hypot();
    mode = {
      N_POLE: 0,
      S_POLE: 1,
      EQUIT: 2,
      OBLIQ: 3
    };
    params = {
      h: { def: 1e5, num: true },
      // default is Karman line, no default in PROJ.7
      azi: { def: 0, num: true, degrees: true },
      // default is North
      tilt: { def: 0, num: true, degrees: true },
      // default is Nadir
      long0: { def: 0, num: true },
      // default is Greenwich, conversion to rad is automatic
      lat0: { def: 0, num: true }
      // default is Equator, conversion to rad is automatic
    };
    names32 = ["Tilted_Perspective", "tpers"];
    tpers_default = {
      init: init31,
      forward: forward30,
      inverse: inverse30,
      names: names32
    };
  }
});

// node_modules/proj4/lib/projections/geos.js
function init32() {
  this.flip_axis = this.sweep === "x" ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;
  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }
  this.radius_g = 1 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1;
  if (this.es !== 0) {
    var one_es = 1 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = "ellipse";
  } else {
    this.radius_p = 1;
    this.radius_p2 = 1;
    this.radius_p_inv2 = 1;
    this.shape = "sphere";
  }
  if (!this.title) {
    this.title = "Geostationary Satellite View";
  }
}
function forward31(p4) {
  var lon = p4.x;
  var lat = p4.y;
  var tmp, v_x, v_y, v_z;
  lon = lon - this.long0;
  if (this.shape === "ellipse") {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r4 = this.radius_p / hypot_default(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r4 * Math.cos(lon) * Math.cos(lat);
    v_y = r4 * Math.sin(lon) * Math.cos(lat);
    v_z = r4 * Math.sin(lat);
    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
      p4.x = Number.NaN;
      p4.y = Number.NaN;
      return p4;
    }
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p4.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p4.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p4.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p4.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  } else if (this.shape === "sphere") {
    tmp = Math.cos(lat);
    v_x = Math.cos(lon) * tmp;
    v_y = Math.sin(lon) * tmp;
    v_z = Math.sin(lat);
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p4.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p4.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p4.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p4.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  }
  p4.x = p4.x * this.a;
  p4.y = p4.y * this.a;
  return p4;
}
function inverse31(p4) {
  var v_x = -1;
  var v_y = 0;
  var v_z = 0;
  var a4, b5, det, k2;
  p4.x = p4.x / this.a;
  p4.y = p4.y / this.a;
  if (this.shape === "ellipse") {
    if (this.flip_axis) {
      v_z = Math.tan(p4.y / this.radius_g_1);
      v_y = Math.tan(p4.x / this.radius_g_1) * hypot_default(1, v_z);
    } else {
      v_y = Math.tan(p4.x / this.radius_g_1);
      v_z = Math.tan(p4.y / this.radius_g_1) * hypot_default(1, v_y);
    }
    var v_zp = v_z / this.radius_p;
    a4 = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b5 = 2 * this.radius_g * v_x;
    det = b5 * b5 - 4 * a4 * this.C;
    if (det < 0) {
      p4.x = Number.NaN;
      p4.y = Number.NaN;
      return p4;
    }
    k2 = (-b5 - Math.sqrt(det)) / (2 * a4);
    v_x = this.radius_g + k2 * v_x;
    v_y *= k2;
    v_z *= k2;
    p4.x = Math.atan2(v_y, v_x);
    p4.y = Math.atan(v_z * Math.cos(p4.x) / v_x);
    p4.y = Math.atan(this.radius_p_inv2 * Math.tan(p4.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis) {
      v_z = Math.tan(p4.y / this.radius_g_1);
      v_y = Math.tan(p4.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
    } else {
      v_y = Math.tan(p4.x / this.radius_g_1);
      v_z = Math.tan(p4.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
    }
    a4 = v_y * v_y + v_z * v_z + v_x * v_x;
    b5 = 2 * this.radius_g * v_x;
    det = b5 * b5 - 4 * a4 * this.C;
    if (det < 0) {
      p4.x = Number.NaN;
      p4.y = Number.NaN;
      return p4;
    }
    k2 = (-b5 - Math.sqrt(det)) / (2 * a4);
    v_x = this.radius_g + k2 * v_x;
    v_y *= k2;
    v_z *= k2;
    p4.x = Math.atan2(v_y, v_x);
    p4.y = Math.atan(v_z * Math.cos(p4.x) / v_x);
  }
  p4.x = p4.x + this.long0;
  return p4;
}
var names33, geos_default;
var init_geos = __esm({
  "node_modules/proj4/lib/projections/geos.js"() {
    init_hypot();
    names33 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
    geos_default = {
      init: init32,
      forward: forward31,
      inverse: inverse31,
      names: names33
    };
  }
});

// node_modules/proj4/lib/projections/eqearth.js
function init33() {
  this.es = 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function forward32(p4) {
  var lam = adjust_lon_default(p4.x - this.long0);
  var phi = p4.y;
  var paramLat = Math.asin(M5 * Math.sin(phi)), paramLatSq = paramLat * paramLat, paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p4.x = lam * Math.cos(paramLat) / (M5 * (A1 + 3 * A22 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)));
  p4.y = paramLat * (A1 + A22 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq));
  p4.x = this.a * p4.x + this.x0;
  p4.y = this.a * p4.y + this.y0;
  return p4;
}
function inverse32(p4) {
  p4.x = (p4.x - this.x0) / this.a;
  p4.y = (p4.y - this.y0) / this.a;
  var EPS = 1e-9, NITER = 12, paramLat = p4.y, paramLatSq, paramLatPow6, fy, fpy, dlat, i4;
  for (i4 = 0; i4 < NITER; ++i4) {
    paramLatSq = paramLat * paramLat;
    paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
    fy = paramLat * (A1 + A22 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq)) - p4.y;
    fpy = A1 + 3 * A22 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq);
    paramLat -= dlat = fy / fpy;
    if (Math.abs(dlat) < EPS) {
      break;
    }
  }
  paramLatSq = paramLat * paramLat;
  paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p4.x = M5 * p4.x * (A1 + 3 * A22 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)) / Math.cos(paramLat);
  p4.y = Math.asin(Math.sin(paramLat) / M5);
  p4.x = adjust_lon_default(p4.x + this.long0);
  return p4;
}
var A1, A22, A3, A4, M5, names34, eqearth_default;
var init_eqearth = __esm({
  "node_modules/proj4/lib/projections/eqearth.js"() {
    init_adjust_lon();
    A1 = 1.340264;
    A22 = -0.081106;
    A3 = 893e-6;
    A4 = 3796e-6;
    M5 = Math.sqrt(3) / 2;
    names34 = ["eqearth", "Equal Earth", "Equal_Earth"];
    eqearth_default = {
      init: init33,
      forward: forward32,
      inverse: inverse32,
      names: names34
    };
  }
});

// node_modules/proj4/lib/projections/bonne.js
function init34() {
  var c6;
  this.phi1 = this.lat1;
  if (Math.abs(this.phi1) < EPS10) {
    throw new Error();
  }
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.m1 = pj_mlfn_default(
      this.phi1,
      this.am1 = Math.sin(this.phi1),
      c6 = Math.cos(this.phi1),
      this.en
    );
    this.am1 = c6 / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1);
    this.inverse = e_inv;
    this.forward = e_fwd;
  } else {
    if (Math.abs(this.phi1) + EPS10 >= HALF_PI) {
      this.cphi1 = 0;
    } else {
      this.cphi1 = 1 / Math.tan(this.phi1);
    }
    this.inverse = s_inv;
    this.forward = s_fwd;
  }
}
function e_fwd(p4) {
  var lam = adjust_lon_default(p4.x - (this.long0 || 0));
  var phi = p4.y;
  var rh, E6, c6;
  rh = this.am1 + this.m1 - pj_mlfn_default(phi, E6 = Math.sin(phi), c6 = Math.cos(phi), this.en);
  E6 = c6 * lam / (rh * Math.sqrt(1 - this.es * E6 * E6));
  p4.x = rh * Math.sin(E6);
  p4.y = this.am1 - rh * Math.cos(E6);
  p4.x = this.a * p4.x + (this.x0 || 0);
  p4.y = this.a * p4.y + (this.y0 || 0);
  return p4;
}
function e_inv(p4) {
  p4.x = (p4.x - (this.x0 || 0)) / this.a;
  p4.y = (p4.y - (this.y0 || 0)) / this.a;
  var s6, rh, lam, phi;
  rh = hypot_default(p4.x, p4.y = this.am1 - p4.y);
  phi = pj_inv_mlfn_default(this.am1 + this.m1 - rh, this.es, this.en);
  if ((s6 = Math.abs(phi)) < HALF_PI) {
    s6 = Math.sin(phi);
    lam = rh * Math.atan2(p4.x, p4.y) * Math.sqrt(1 - this.es * s6 * s6) / Math.cos(phi);
  } else if (Math.abs(s6 - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    throw new Error();
  }
  p4.x = adjust_lon_default(lam + (this.long0 || 0));
  p4.y = adjust_lat_default(phi);
  return p4;
}
function s_fwd(p4) {
  var lam = adjust_lon_default(p4.x - (this.long0 || 0));
  var phi = p4.y;
  var E6, rh;
  rh = this.cphi1 + this.phi1 - phi;
  if (Math.abs(rh) > EPS10) {
    p4.x = rh * Math.sin(E6 = lam * Math.cos(phi) / rh);
    p4.y = this.cphi1 - rh * Math.cos(E6);
  } else {
    p4.x = p4.y = 0;
  }
  p4.x = this.a * p4.x + (this.x0 || 0);
  p4.y = this.a * p4.y + (this.y0 || 0);
  return p4;
}
function s_inv(p4) {
  p4.x = (p4.x - (this.x0 || 0)) / this.a;
  p4.y = (p4.y - (this.y0 || 0)) / this.a;
  var lam, phi;
  var rh = hypot_default(p4.x, p4.y = this.cphi1 - p4.y);
  phi = this.cphi1 + this.phi1 - rh;
  if (Math.abs(phi) > HALF_PI) {
    throw new Error();
  }
  if (Math.abs(Math.abs(phi) - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    lam = rh * Math.atan2(p4.x, p4.y) / Math.cos(phi);
  }
  p4.x = adjust_lon_default(lam + (this.long0 || 0));
  p4.y = adjust_lat_default(phi);
  return p4;
}
var EPS10, names35, bonne_default;
var init_bonne = __esm({
  "node_modules/proj4/lib/projections/bonne.js"() {
    init_adjust_lat();
    init_adjust_lon();
    init_hypot();
    init_pj_enfn();
    init_pj_inv_mlfn();
    init_pj_mlfn();
    init_values();
    EPS10 = 1e-10;
    names35 = ["bonne", "Bonne (Werner lat_1=90)"];
    bonne_default = {
      init: init34,
      names: names35
    };
  }
});

// node_modules/proj4/projs.js
function projs_default(proj43) {
  proj43.Proj.projections.add(tmerc_default);
  proj43.Proj.projections.add(etmerc_default);
  proj43.Proj.projections.add(utm_default);
  proj43.Proj.projections.add(sterea_default);
  proj43.Proj.projections.add(stere_default);
  proj43.Proj.projections.add(somerc_default);
  proj43.Proj.projections.add(omerc_default);
  proj43.Proj.projections.add(lcc_default);
  proj43.Proj.projections.add(krovak_default);
  proj43.Proj.projections.add(cass_default);
  proj43.Proj.projections.add(laea_default);
  proj43.Proj.projections.add(aea_default);
  proj43.Proj.projections.add(gnom_default);
  proj43.Proj.projections.add(cea_default);
  proj43.Proj.projections.add(eqc_default);
  proj43.Proj.projections.add(poly_default);
  proj43.Proj.projections.add(nzmg_default);
  proj43.Proj.projections.add(mill_default);
  proj43.Proj.projections.add(sinu_default);
  proj43.Proj.projections.add(moll_default);
  proj43.Proj.projections.add(eqdc_default);
  proj43.Proj.projections.add(vandg_default);
  proj43.Proj.projections.add(aeqd_default);
  proj43.Proj.projections.add(ortho_default);
  proj43.Proj.projections.add(qsc_default);
  proj43.Proj.projections.add(robin_default);
  proj43.Proj.projections.add(geocent_default);
  proj43.Proj.projections.add(tpers_default);
  proj43.Proj.projections.add(geos_default);
  proj43.Proj.projections.add(eqearth_default);
  proj43.Proj.projections.add(bonne_default);
}
var init_projs = __esm({
  "node_modules/proj4/projs.js"() {
    init_tmerc();
    init_etmerc();
    init_utm2();
    init_sterea();
    init_stere();
    init_somerc();
    init_omerc();
    init_lcc();
    init_krovak();
    init_cass();
    init_laea();
    init_aea();
    init_gnom();
    init_cea();
    init_eqc();
    init_poly();
    init_nzmg();
    init_mill();
    init_sinu();
    init_moll();
    init_eqdc();
    init_vandg();
    init_aeqd();
    init_ortho();
    init_qsc();
    init_robin();
    init_geocent();
    init_tpers();
    init_geos();
    init_eqearth();
    init_bonne();
  }
});

// node_modules/proj4/lib/index.js
var proj42, lib_default;
var init_lib = __esm({
  "node_modules/proj4/lib/index.js"() {
    init_core();
    init_Proj();
    init_Point2();
    init_toPoint();
    init_defs();
    init_nadgrid();
    init_transform3();
    init_mgrs();
    init_projs();
    proj42 = Object.assign(core_default, {
      defaultDatum: "WGS84",
      Proj: Proj_default,
      WGS84: new Proj_default("WGS84"),
      Point: Point_default2,
      toPoint: toPoint_default,
      defs: defs_default,
      nadgrid,
      transform: transform2,
      mgrs: mgrs_default,
      version: "__VERSION__"
    });
    projs_default(proj42);
    lib_default = proj42;
  }
});

// node_modules/@allmaps/project/dist/shared/project-functions.js
var lonLatEquivalentDefinitions, webMercatorEquivalentDefinitions, lonLatProjection, webMercatorProjection, defaultProjectedGcpTransformerOptions, defaultProjectedGcpTransformOptions, lonLatProjectionToWebMecatorProjectionConverter, lonLatToWebMercator, webMercatorToLonLat;
var init_project_functions = __esm({
  "node_modules/@allmaps/project/dist/shared/project-functions.js"() {
    init_lib();
    init_dist2();
    lonLatEquivalentDefinitions = [
      "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees",
      "+proj=longlat +datum=WGS84 +no_defs +type=crs",
      "EPSG:4326",
      "WGS84"
    ];
    webMercatorEquivalentDefinitions = [
      "+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs +type=crs",
      "EPSG:3857",
      "EPSG:3785",
      "GOOGLE",
      "EPSG:900913",
      "EPSG:102113"
    ];
    lonLatProjection = {
      name: "EPSG:4326",
      definition: lonLatEquivalentDefinitions[0]
    };
    webMercatorProjection = {
      name: "EPSG:3857",
      definition: webMercatorEquivalentDefinitions[0]
    };
    defaultProjectedGcpTransformerOptions = {
      internalProjection: webMercatorProjection,
      projection: webMercatorProjection,
      ...defaultGcpTransformerOptions
    };
    defaultProjectedGcpTransformOptions = {
      projection: webMercatorProjection,
      ...defaultGcpTransformerOptions
    };
    lonLatProjectionToWebMecatorProjectionConverter = lib_default(lonLatProjection.definition, webMercatorProjection.definition);
    lonLatToWebMercator = lonLatProjectionToWebMecatorProjectionConverter.forward;
    webMercatorToLonLat = lonLatProjectionToWebMecatorProjectionConverter.inverse;
  }
});

// node_modules/@allmaps/project/dist/projected-transformers/ProjectedGcpTransformer.js
var init_ProjectedGcpTransformer = __esm({
  "node_modules/@allmaps/project/dist/projected-transformers/ProjectedGcpTransformer.js"() {
    init_lib();
    init_dist();
    init_dist2();
    init_project_functions();
  }
});

// node_modules/@allmaps/project/dist/index.js
var init_dist6 = __esm({
  "node_modules/@allmaps/project/dist/index.js"() {
    init_lib();
    init_ProjectedGcpTransformer();
    init_project_functions();
  }
});

// node_modules/quickselect/index.js
var init_quickselect = __esm({
  "node_modules/quickselect/index.js"() {
  }
});

// node_modules/rbush/index.js
var init_rbush = __esm({
  "node_modules/rbush/index.js"() {
    init_quickselect();
  }
});

// node_modules/robust-predicates/esm/util.js
function sum(elen, e3, flen, f5, h3) {
  let Q4, Qnew, hh, bvirt;
  let enow = e3[0];
  let fnow = f5[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q4 = enow;
    enow = e3[++eindex];
  } else {
    Q4 = fnow;
    fnow = f5[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q4;
      hh = Q4 - (Qnew - enow);
      enow = e3[++eindex];
    } else {
      Qnew = fnow + Q4;
      hh = Q4 - (Qnew - fnow);
      fnow = f5[++findex];
    }
    Q4 = Qnew;
    if (hh !== 0) {
      h3[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q4 + enow;
        bvirt = Qnew - Q4;
        hh = Q4 - (Qnew - bvirt) + (enow - bvirt);
        enow = e3[++eindex];
      } else {
        Qnew = Q4 + fnow;
        bvirt = Qnew - Q4;
        hh = Q4 - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f5[++findex];
      }
      Q4 = Qnew;
      if (hh !== 0) {
        h3[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q4 + enow;
    bvirt = Qnew - Q4;
    hh = Q4 - (Qnew - bvirt) + (enow - bvirt);
    enow = e3[++eindex];
    Q4 = Qnew;
    if (hh !== 0) {
      h3[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q4 + fnow;
    bvirt = Qnew - Q4;
    hh = Q4 - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f5[++findex];
    Q4 = Qnew;
    if (hh !== 0) {
      h3[hindex++] = hh;
    }
  }
  if (Q4 !== 0 || hindex === 0) {
    h3[hindex++] = Q4;
  }
  return hindex;
}
function sum_three(alen, a4, blen, b5, clen, c6, tmp, out) {
  return sum(sum(alen, a4, blen, b5, tmp), tmp, clen, c6, out);
}
function scale3(elen, e3, b5, h3) {
  let Q4, sum2, hh, product1, product0;
  let bvirt, c6, ahi, alo, bhi, blo;
  c6 = splitter * b5;
  bhi = c6 - (c6 - b5);
  blo = b5 - bhi;
  let enow = e3[0];
  Q4 = enow * b5;
  c6 = splitter * enow;
  ahi = c6 - (c6 - enow);
  alo = enow - ahi;
  hh = alo * blo - (Q4 - ahi * bhi - alo * bhi - ahi * blo);
  let hindex = 0;
  if (hh !== 0) {
    h3[hindex++] = hh;
  }
  for (let i4 = 1; i4 < elen; i4++) {
    enow = e3[i4];
    product1 = enow * b5;
    c6 = splitter * enow;
    ahi = c6 - (c6 - enow);
    alo = enow - ahi;
    product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);
    sum2 = Q4 + product0;
    bvirt = sum2 - Q4;
    hh = Q4 - (sum2 - bvirt) + (product0 - bvirt);
    if (hh !== 0) {
      h3[hindex++] = hh;
    }
    Q4 = product1 + sum2;
    hh = sum2 - (Q4 - product1);
    if (hh !== 0) {
      h3[hindex++] = hh;
    }
  }
  if (Q4 !== 0 || hindex === 0) {
    h3[hindex++] = Q4;
  }
  return hindex;
}
function estimate(elen, e3) {
  let Q4 = e3[0];
  for (let i4 = 1; i4 < elen; i4++) Q4 += e3[i4];
  return Q4;
}
function vec(n3) {
  return new Float64Array(n3);
}
var epsilon, splitter, resulterrbound;
var init_util4 = __esm({
  "node_modules/robust-predicates/esm/util.js"() {
    epsilon = 11102230246251565e-32;
    splitter = 134217729;
    resulterrbound = (3 + 8 * epsilon) * epsilon;
  }
});

// node_modules/robust-predicates/esm/orient2d.js
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c6, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c6 = splitter * acx;
  ahi = c6 - (c6 - acx);
  alo = acx - ahi;
  c6 = splitter * bcy;
  bhi = c6 - (c6 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c6 = splitter * acy;
  ahi = c6 - (c6 - acy);
  alo = acy - ahi;
  c6 = splitter * bcx;
  bhi = c6 - (c6 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B3[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B3[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B3[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B3[3] = u32;
  let det = estimate(4, B3);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c6 = splitter * acxtail;
  ahi = c6 - (c6 - acxtail);
  alo = acxtail - ahi;
  c6 = splitter * bcy;
  bhi = c6 - (c6 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c6 = splitter * acytail;
  ahi = c6 - (c6 - acytail);
  alo = acytail - ahi;
  c6 = splitter * bcx;
  bhi = c6 - (c6 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u3[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u3[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u3[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u3[3] = u32;
  const C1len = sum(4, B3, 4, u3, C12);
  s1 = acx * bcytail;
  c6 = splitter * acx;
  ahi = c6 - (c6 - acx);
  alo = acx - ahi;
  c6 = splitter * bcytail;
  bhi = c6 - (c6 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c6 = splitter * acy;
  ahi = c6 - (c6 - acy);
  alo = acy - ahi;
  c6 = splitter * bcxtail;
  bhi = c6 - (c6 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u3[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u3[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u3[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u3[3] = u32;
  const C2len = sum(C1len, C12, 4, u3, C23);
  s1 = acxtail * bcytail;
  c6 = splitter * acxtail;
  ahi = c6 - (c6 - acxtail);
  alo = acxtail - ahi;
  c6 = splitter * bcytail;
  bhi = c6 - (c6 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c6 = splitter * acytail;
  ahi = c6 - (c6 - acytail);
  alo = acytail - ahi;
  c6 = splitter * bcxtail;
  bhi = c6 - (c6 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u3[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u3[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u3[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u3[3] = u32;
  const Dlen = sum(C2len, C23, 4, u3, D3);
  return D3[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
var ccwerrboundA, ccwerrboundB, ccwerrboundC, B3, C12, C23, D3, u3;
var init_orient2d = __esm({
  "node_modules/robust-predicates/esm/orient2d.js"() {
    init_util4();
    ccwerrboundA = (3 + 16 * epsilon) * epsilon;
    ccwerrboundB = (2 + 12 * epsilon) * epsilon;
    ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
    B3 = vec(4);
    C12 = vec(8);
    C23 = vec(12);
    D3 = vec(16);
    u3 = vec(4);
  }
});

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA, o3derrboundB, o3derrboundC, bc, ca, ab, at_b, at_c, bt_c, bt_a, ct_a, ct_b, bct, cat, abt, u4, _8, _8b, _16, _12, fin, fin2;
var init_orient3d = __esm({
  "node_modules/robust-predicates/esm/orient3d.js"() {
    init_util4();
    o3derrboundA = (7 + 56 * epsilon) * epsilon;
    o3derrboundB = (3 + 28 * epsilon) * epsilon;
    o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
    bc = vec(4);
    ca = vec(4);
    ab = vec(4);
    at_b = vec(4);
    at_c = vec(4);
    bt_c = vec(4);
    bt_a = vec(4);
    ct_a = vec(4);
    ct_b = vec(4);
    bct = vec(8);
    cat = vec(8);
    abt = vec(8);
    u4 = vec(4);
    _8 = vec(8);
    _8b = vec(8);
    _16 = vec(8);
    _12 = vec(12);
    fin = vec(192);
    fin2 = vec(192);
  }
});

// node_modules/robust-predicates/esm/incircle.js
function finadd(finlen, a4, alen) {
  finlen = sum(finlen, fin3, a4, alen, fin22);
  const tmp = fin3;
  fin3 = fin22;
  fin22 = tmp;
  return finlen;
}
function incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {
  let finlen;
  let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;
  let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;
  let abtlen, bctlen, catlen;
  let abttlen, bcttlen, cattlen;
  let n1, n0;
  let bvirt, c6, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  s1 = bdx * cdy;
  c6 = splitter * bdx;
  ahi = c6 - (c6 - bdx);
  alo = bdx - ahi;
  c6 = splitter * cdy;
  bhi = c6 - (c6 - cdy);
  blo = cdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cdx * bdy;
  c6 = splitter * cdx;
  ahi = c6 - (c6 - cdx);
  alo = cdx - ahi;
  c6 = splitter * bdy;
  bhi = c6 - (c6 - bdy);
  blo = bdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bc2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bc2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  bc2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  bc2[3] = u32;
  s1 = cdx * ady;
  c6 = splitter * cdx;
  ahi = c6 - (c6 - cdx);
  alo = cdx - ahi;
  c6 = splitter * ady;
  bhi = c6 - (c6 - ady);
  blo = ady - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = adx * cdy;
  c6 = splitter * adx;
  ahi = c6 - (c6 - adx);
  alo = adx - ahi;
  c6 = splitter * cdy;
  bhi = c6 - (c6 - cdy);
  blo = cdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ca2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ca2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  ca2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  ca2[3] = u32;
  s1 = adx * bdy;
  c6 = splitter * adx;
  ahi = c6 - (c6 - adx);
  alo = adx - ahi;
  c6 = splitter * bdy;
  bhi = c6 - (c6 - bdy);
  blo = bdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = bdx * ady;
  c6 = splitter * bdx;
  ahi = c6 - (c6 - bdx);
  alo = bdx - ahi;
  c6 = splitter * ady;
  bhi = c6 - (c6 - ady);
  blo = ady - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ab2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ab2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  ab2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  ab2[3] = u32;
  finlen = sum(
    sum(
      sum(
        scale3(scale3(4, bc2, adx, _82), _82, adx, _162),
        _162,
        scale3(scale3(4, bc2, ady, _82), _82, ady, _16b),
        _16b,
        _32
      ),
      _32,
      sum(
        scale3(scale3(4, ca2, bdx, _82), _82, bdx, _162),
        _162,
        scale3(scale3(4, ca2, bdy, _82), _82, bdy, _16b),
        _16b,
        _32b
      ),
      _32b,
      _64
    ),
    _64,
    sum(
      scale3(scale3(4, ab2, cdx, _82), _82, cdx, _162),
      _162,
      scale3(scale3(4, ab2, cdy, _82), _82, cdy, _16b),
      _16b,
      _32
    ),
    _32,
    fin3
  );
  let det = estimate(finlen, fin3);
  let errbound = iccerrboundB * permanent;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - adx;
  adxtail = ax - (adx + bvirt) + (bvirt - dx);
  bvirt = ay - ady;
  adytail = ay - (ady + bvirt) + (bvirt - dy);
  bvirt = bx - bdx;
  bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
  bvirt = by - bdy;
  bdytail = by - (bdy + bvirt) + (bvirt - dy);
  bvirt = cx - cdx;
  cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
  bvirt = cy - cdy;
  cdytail = cy - (cdy + bvirt) + (bvirt - dy);
  if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) {
    return det;
  }
  errbound = iccerrboundC * permanent + resulterrbound * Math.abs(det);
  det += (adx * adx + ady * ady) * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + 2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx) + ((bdx * bdx + bdy * bdy) * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + 2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) + ((cdx * cdx + cdy * cdy) * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + 2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
    s1 = adx * adx;
    c6 = splitter * adx;
    ahi = c6 - (c6 - adx);
    alo = adx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = ady * ady;
    c6 = splitter * ady;
    ahi = c6 - (c6 - ady);
    alo = ady - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    aa[2] = _j - (u32 - bvirt) + (_i - bvirt);
    aa[3] = u32;
  }
  if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
    s1 = bdx * bdx;
    c6 = splitter * bdx;
    ahi = c6 - (c6 - bdx);
    alo = bdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = bdy * bdy;
    c6 = splitter * bdy;
    ahi = c6 - (c6 - bdy);
    alo = bdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    bb[2] = _j - (u32 - bvirt) + (_i - bvirt);
    bb[3] = u32;
  }
  if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
    s1 = cdx * cdx;
    c6 = splitter * cdx;
    ahi = c6 - (c6 - cdx);
    alo = cdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = cdy * cdy;
    c6 = splitter * cdy;
    ahi = c6 - (c6 - cdy);
    alo = cdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    cc[2] = _j - (u32 - bvirt) + (_i - bvirt);
    cc[3] = u32;
  }
  if (adxtail !== 0) {
    axtbclen = scale3(4, bc2, adxtail, axtbc);
    finlen = finadd(finlen, sum_three(
      scale3(axtbclen, axtbc, 2 * adx, _162),
      _162,
      scale3(scale3(4, cc, adxtail, _82), _82, bdy, _16b),
      _16b,
      scale3(scale3(4, bb, adxtail, _82), _82, -cdy, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (adytail !== 0) {
    aytbclen = scale3(4, bc2, adytail, aytbc);
    finlen = finadd(finlen, sum_three(
      scale3(aytbclen, aytbc, 2 * ady, _162),
      _162,
      scale3(scale3(4, bb, adytail, _82), _82, cdx, _16b),
      _16b,
      scale3(scale3(4, cc, adytail, _82), _82, -bdx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (bdxtail !== 0) {
    bxtcalen = scale3(4, ca2, bdxtail, bxtca);
    finlen = finadd(finlen, sum_three(
      scale3(bxtcalen, bxtca, 2 * bdx, _162),
      _162,
      scale3(scale3(4, aa, bdxtail, _82), _82, cdy, _16b),
      _16b,
      scale3(scale3(4, cc, bdxtail, _82), _82, -ady, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (bdytail !== 0) {
    bytcalen = scale3(4, ca2, bdytail, bytca);
    finlen = finadd(finlen, sum_three(
      scale3(bytcalen, bytca, 2 * bdy, _162),
      _162,
      scale3(scale3(4, cc, bdytail, _82), _82, adx, _16b),
      _16b,
      scale3(scale3(4, aa, bdytail, _82), _82, -cdx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (cdxtail !== 0) {
    cxtablen = scale3(4, ab2, cdxtail, cxtab);
    finlen = finadd(finlen, sum_three(
      scale3(cxtablen, cxtab, 2 * cdx, _162),
      _162,
      scale3(scale3(4, bb, cdxtail, _82), _82, ady, _16b),
      _16b,
      scale3(scale3(4, aa, cdxtail, _82), _82, -bdy, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (cdytail !== 0) {
    cytablen = scale3(4, ab2, cdytail, cytab);
    finlen = finadd(finlen, sum_three(
      scale3(cytablen, cytab, 2 * cdy, _162),
      _162,
      scale3(scale3(4, aa, cdytail, _82), _82, bdx, _16b),
      _16b,
      scale3(scale3(4, bb, cdytail, _82), _82, -adx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (adxtail !== 0 || adytail !== 0) {
    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
      s1 = bdxtail * cdy;
      c6 = splitter * bdxtail;
      ahi = c6 - (c6 - bdxtail);
      alo = bdxtail - ahi;
      c6 = splitter * cdy;
      bhi = c6 - (c6 - cdy);
      blo = cdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * cdytail;
      c6 = splitter * bdx;
      ahi = c6 - (c6 - bdx);
      alo = bdx - ahi;
      c6 = splitter * cdytail;
      bhi = c6 - (c6 - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u5[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u5[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u5[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u5[3] = u32;
      s1 = cdxtail * -bdy;
      c6 = splitter * cdxtail;
      ahi = c6 - (c6 - cdxtail);
      alo = cdxtail - ahi;
      c6 = splitter * -bdy;
      bhi = c6 - (c6 - -bdy);
      blo = -bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * -bdytail;
      c6 = splitter * cdx;
      ahi = c6 - (c6 - cdx);
      alo = cdx - ahi;
      c6 = splitter * -bdytail;
      bhi = c6 - (c6 - -bdytail);
      blo = -bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v3[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v3[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v3[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v3[3] = u32;
      bctlen = sum(4, u5, 4, v3, bct2);
      s1 = bdxtail * cdytail;
      c6 = splitter * bdxtail;
      ahi = c6 - (c6 - bdxtail);
      alo = bdxtail - ahi;
      c6 = splitter * cdytail;
      bhi = c6 - (c6 - cdytail);
      blo = cdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdxtail * bdytail;
      c6 = splitter * cdxtail;
      ahi = c6 - (c6 - cdxtail);
      alo = cdxtail - ahi;
      c6 = splitter * bdytail;
      bhi = c6 - (c6 - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      bctt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      bctt[3] = u32;
      bcttlen = 4;
    } else {
      bct2[0] = 0;
      bctlen = 1;
      bctt[0] = 0;
      bcttlen = 1;
    }
    if (adxtail !== 0) {
      const len = scale3(bctlen, bct2, adxtail, _16c);
      finlen = finadd(finlen, sum(
        scale3(axtbclen, axtbc, adxtail, _162),
        _162,
        scale3(len, _16c, 2 * adx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale3(bcttlen, bctt, adxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale3(len2, _82, 2 * adx, _162),
        _162,
        scale3(len2, _82, adxtail, _16b),
        _16b,
        scale3(len, _16c, adxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (bdytail !== 0) {
        finlen = finadd(finlen, scale3(scale3(4, cc, adxtail, _82), _82, bdytail, _162), _162);
      }
      if (cdytail !== 0) {
        finlen = finadd(finlen, scale3(scale3(4, bb, -adxtail, _82), _82, cdytail, _162), _162);
      }
    }
    if (adytail !== 0) {
      const len = scale3(bctlen, bct2, adytail, _16c);
      finlen = finadd(finlen, sum(
        scale3(aytbclen, aytbc, adytail, _162),
        _162,
        scale3(len, _16c, 2 * ady, _32),
        _32,
        _48
      ), _48);
      const len2 = scale3(bcttlen, bctt, adytail, _82);
      finlen = finadd(finlen, sum_three(
        scale3(len2, _82, 2 * ady, _162),
        _162,
        scale3(len2, _82, adytail, _16b),
        _16b,
        scale3(len, _16c, adytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  if (bdxtail !== 0 || bdytail !== 0) {
    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
      s1 = cdxtail * ady;
      c6 = splitter * cdxtail;
      ahi = c6 - (c6 - cdxtail);
      alo = cdxtail - ahi;
      c6 = splitter * ady;
      bhi = c6 - (c6 - ady);
      blo = ady - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * adytail;
      c6 = splitter * cdx;
      ahi = c6 - (c6 - cdx);
      alo = cdx - ahi;
      c6 = splitter * adytail;
      bhi = c6 - (c6 - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u5[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u5[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u5[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u5[3] = u32;
      n1 = -cdy;
      n0 = -cdytail;
      s1 = adxtail * n1;
      c6 = splitter * adxtail;
      ahi = c6 - (c6 - adxtail);
      alo = adxtail - ahi;
      c6 = splitter * n1;
      bhi = c6 - (c6 - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * n0;
      c6 = splitter * adx;
      ahi = c6 - (c6 - adx);
      alo = adx - ahi;
      c6 = splitter * n0;
      bhi = c6 - (c6 - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v3[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v3[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v3[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v3[3] = u32;
      catlen = sum(4, u5, 4, v3, cat2);
      s1 = cdxtail * adytail;
      c6 = splitter * cdxtail;
      ahi = c6 - (c6 - cdxtail);
      alo = cdxtail - ahi;
      c6 = splitter * adytail;
      bhi = c6 - (c6 - adytail);
      blo = adytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adxtail * cdytail;
      c6 = splitter * adxtail;
      ahi = c6 - (c6 - adxtail);
      alo = adxtail - ahi;
      c6 = splitter * cdytail;
      bhi = c6 - (c6 - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      catt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      catt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      catt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      catt[3] = u32;
      cattlen = 4;
    } else {
      cat2[0] = 0;
      catlen = 1;
      catt[0] = 0;
      cattlen = 1;
    }
    if (bdxtail !== 0) {
      const len = scale3(catlen, cat2, bdxtail, _16c);
      finlen = finadd(finlen, sum(
        scale3(bxtcalen, bxtca, bdxtail, _162),
        _162,
        scale3(len, _16c, 2 * bdx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale3(cattlen, catt, bdxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale3(len2, _82, 2 * bdx, _162),
        _162,
        scale3(len2, _82, bdxtail, _16b),
        _16b,
        scale3(len, _16c, bdxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (cdytail !== 0) {
        finlen = finadd(finlen, scale3(scale3(4, aa, bdxtail, _82), _82, cdytail, _162), _162);
      }
      if (adytail !== 0) {
        finlen = finadd(finlen, scale3(scale3(4, cc, -bdxtail, _82), _82, adytail, _162), _162);
      }
    }
    if (bdytail !== 0) {
      const len = scale3(catlen, cat2, bdytail, _16c);
      finlen = finadd(finlen, sum(
        scale3(bytcalen, bytca, bdytail, _162),
        _162,
        scale3(len, _16c, 2 * bdy, _32),
        _32,
        _48
      ), _48);
      const len2 = scale3(cattlen, catt, bdytail, _82);
      finlen = finadd(finlen, sum_three(
        scale3(len2, _82, 2 * bdy, _162),
        _162,
        scale3(len2, _82, bdytail, _16b),
        _16b,
        scale3(len, _16c, bdytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  if (cdxtail !== 0 || cdytail !== 0) {
    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
      s1 = adxtail * bdy;
      c6 = splitter * adxtail;
      ahi = c6 - (c6 - adxtail);
      alo = adxtail - ahi;
      c6 = splitter * bdy;
      bhi = c6 - (c6 - bdy);
      blo = bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * bdytail;
      c6 = splitter * adx;
      ahi = c6 - (c6 - adx);
      alo = adx - ahi;
      c6 = splitter * bdytail;
      bhi = c6 - (c6 - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u5[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u5[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u5[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u5[3] = u32;
      n1 = -ady;
      n0 = -adytail;
      s1 = bdxtail * n1;
      c6 = splitter * bdxtail;
      ahi = c6 - (c6 - bdxtail);
      alo = bdxtail - ahi;
      c6 = splitter * n1;
      bhi = c6 - (c6 - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * n0;
      c6 = splitter * bdx;
      ahi = c6 - (c6 - bdx);
      alo = bdx - ahi;
      c6 = splitter * n0;
      bhi = c6 - (c6 - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v3[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v3[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v3[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v3[3] = u32;
      abtlen = sum(4, u5, 4, v3, abt2);
      s1 = adxtail * bdytail;
      c6 = splitter * adxtail;
      ahi = c6 - (c6 - adxtail);
      alo = adxtail - ahi;
      c6 = splitter * bdytail;
      bhi = c6 - (c6 - bdytail);
      blo = bdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdxtail * adytail;
      c6 = splitter * bdxtail;
      ahi = c6 - (c6 - bdxtail);
      alo = bdxtail - ahi;
      c6 = splitter * adytail;
      bhi = c6 - (c6 - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      abtt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      abtt[3] = u32;
      abttlen = 4;
    } else {
      abt2[0] = 0;
      abtlen = 1;
      abtt[0] = 0;
      abttlen = 1;
    }
    if (cdxtail !== 0) {
      const len = scale3(abtlen, abt2, cdxtail, _16c);
      finlen = finadd(finlen, sum(
        scale3(cxtablen, cxtab, cdxtail, _162),
        _162,
        scale3(len, _16c, 2 * cdx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale3(abttlen, abtt, cdxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale3(len2, _82, 2 * cdx, _162),
        _162,
        scale3(len2, _82, cdxtail, _16b),
        _16b,
        scale3(len, _16c, cdxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (adytail !== 0) {
        finlen = finadd(finlen, scale3(scale3(4, bb, cdxtail, _82), _82, adytail, _162), _162);
      }
      if (bdytail !== 0) {
        finlen = finadd(finlen, scale3(scale3(4, aa, -cdxtail, _82), _82, bdytail, _162), _162);
      }
    }
    if (cdytail !== 0) {
      const len = scale3(abtlen, abt2, cdytail, _16c);
      finlen = finadd(finlen, sum(
        scale3(cytablen, cytab, cdytail, _162),
        _162,
        scale3(len, _16c, 2 * cdy, _32),
        _32,
        _48
      ), _48);
      const len2 = scale3(abttlen, abtt, cdytail, _82);
      finlen = finadd(finlen, sum_three(
        scale3(len2, _82, 2 * cdy, _162),
        _162,
        scale3(len2, _82, cdytail, _16b),
        _16b,
        scale3(len, _16c, cdytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  return fin3[finlen - 1];
}
function incircle(ax, ay, bx, by, cx, cy, dx, dy) {
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  const bdxcdy = bdx * cdy;
  const cdxbdy = cdx * bdy;
  const alift = adx * adx + ady * ady;
  const cdxady = cdx * ady;
  const adxcdy = adx * cdy;
  const blift = bdx * bdx + bdy * bdy;
  const adxbdy = adx * bdy;
  const bdxady = bdx * ady;
  const clift = cdx * cdx + cdy * cdy;
  const det = alift * (bdxcdy - cdxbdy) + blift * (cdxady - adxcdy) + clift * (adxbdy - bdxady);
  const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift + (Math.abs(cdxady) + Math.abs(adxcdy)) * blift + (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;
  const errbound = iccerrboundA * permanent;
  if (det > errbound || -det > errbound) {
    return det;
  }
  return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);
}
var iccerrboundA, iccerrboundB, iccerrboundC, bc2, ca2, ab2, aa, bb, cc, u5, v3, axtbc, aytbc, bxtca, bytca, cxtab, cytab, abt2, bct2, cat2, abtt, bctt, catt, _82, _162, _16b, _16c, _32, _32b, _48, _64, fin3, fin22;
var init_incircle = __esm({
  "node_modules/robust-predicates/esm/incircle.js"() {
    init_util4();
    iccerrboundA = (10 + 96 * epsilon) * epsilon;
    iccerrboundB = (4 + 48 * epsilon) * epsilon;
    iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
    bc2 = vec(4);
    ca2 = vec(4);
    ab2 = vec(4);
    aa = vec(4);
    bb = vec(4);
    cc = vec(4);
    u5 = vec(4);
    v3 = vec(4);
    axtbc = vec(8);
    aytbc = vec(8);
    bxtca = vec(8);
    bytca = vec(8);
    cxtab = vec(8);
    cytab = vec(8);
    abt2 = vec(8);
    bct2 = vec(8);
    cat2 = vec(8);
    abtt = vec(4);
    bctt = vec(4);
    catt = vec(4);
    _82 = vec(8);
    _162 = vec(16);
    _16b = vec(16);
    _16c = vec(16);
    _32 = vec(32);
    _32b = vec(32);
    _48 = vec(48);
    _64 = vec(64);
    fin3 = vec(1152);
    fin22 = vec(1152);
  }
});

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA, isperrboundB, isperrboundC, ab3, bc3, cd, de3, ea, ac, bd, ce2, da, eb, abc, bcd, cde, dea, eab, abd, bce, cda, deb, eac, adet, bdet, cdet, ddet, edet, abdet, cddet, cdedet, deter, _83, _8b2, _8c, _163, _24, _482, _48b, _96, _192, _384x, _384y, _384z, _768, xdet, ydet, zdet, fin4;
var init_insphere = __esm({
  "node_modules/robust-predicates/esm/insphere.js"() {
    init_util4();
    isperrboundA = (16 + 224 * epsilon) * epsilon;
    isperrboundB = (5 + 72 * epsilon) * epsilon;
    isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
    ab3 = vec(4);
    bc3 = vec(4);
    cd = vec(4);
    de3 = vec(4);
    ea = vec(4);
    ac = vec(4);
    bd = vec(4);
    ce2 = vec(4);
    da = vec(4);
    eb = vec(4);
    abc = vec(24);
    bcd = vec(24);
    cde = vec(24);
    dea = vec(24);
    eab = vec(24);
    abd = vec(24);
    bce = vec(24);
    cda = vec(24);
    deb = vec(24);
    eac = vec(24);
    adet = vec(1152);
    bdet = vec(1152);
    cdet = vec(1152);
    ddet = vec(1152);
    edet = vec(1152);
    abdet = vec(2304);
    cddet = vec(2304);
    cdedet = vec(3456);
    deter = vec(5760);
    _83 = vec(8);
    _8b2 = vec(8);
    _8c = vec(8);
    _163 = vec(16);
    _24 = vec(24);
    _482 = vec(48);
    _48b = vec(48);
    _96 = vec(96);
    _192 = vec(192);
    _384x = vec(384);
    _384y = vec(384);
    _384z = vec(384);
    _768 = vec(768);
    xdet = vec(96);
    ydet = vec(96);
    zdet = vec(96);
    fin4 = vec(1152);
  }
});

// node_modules/robust-predicates/index.js
var init_robust_predicates = __esm({
  "node_modules/robust-predicates/index.js"() {
    init_orient2d();
    init_orient3d();
    init_incircle();
    init_insphere();
  }
});

// node_modules/point-in-polygon-hao/dist/esm/index.js
var init_esm = __esm({
  "node_modules/point-in-polygon-hao/dist/esm/index.js"() {
    init_robust_predicates();
  }
});

// node_modules/@allmaps/render/dist/maps/RTree.js
var init_RTree = __esm({
  "node_modules/@allmaps/render/dist/maps/RTree.js"() {
    init_rbush();
    init_esm();
    init_dist();
  }
});

// node_modules/@allmaps/render/dist/maps/WarpedMapList.js
var init_WarpedMapList = __esm({
  "node_modules/@allmaps/render/dist/maps/WarpedMapList.js"() {
    init_dist4();
    init_dist5();
    init_dist6();
    init_RTree();
    init_dist();
    init_events2();
  }
});

// node_modules/@allmaps/render/dist/tilecache/FetchableTile.js
var init_FetchableTile = __esm({
  "node_modules/@allmaps/render/dist/tilecache/FetchableTile.js"() {
    init_tiles();
  }
});

// node_modules/@allmaps/render/dist/renderers/BaseRenderer.js
var MAX_MAP_OVERVIEW_RESOLUTION;
var init_BaseRenderer = __esm({
  "node_modules/@allmaps/render/dist/renderers/BaseRenderer.js"() {
    init_TileCache();
    init_WarpedMapList();
    init_FetchableTile();
    init_events2();
    init_tiles();
    init_dist();
    init_dist6();
    MAX_MAP_OVERVIEW_RESOLUTION = 1024 * 1024;
  }
});

// node_modules/@allmaps/triangulate/dist/shared.js
var init_shared2 = __esm({
  "node_modules/@allmaps/triangulate/dist/shared.js"() {
    init_esm();
    init_dist();
  }
});

// node_modules/@kninnug/constrainautor/lib/Constrainautor.mjs
function nextEdge(e3) {
  return e3 % 3 === 2 ? e3 - 2 : e3 + 1;
}
function prevEdge(e3) {
  return e3 % 3 === 0 ? e3 + 2 : e3 - 1;
}
function intersectSegments(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
  const x0 = orient2d(p1x, p1y, p3x, p3y, p4x, p4y), y0 = orient2d(p2x, p2y, p3x, p3y, p4x, p4y);
  if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0) {
    return false;
  }
  const x1 = orient2d(p3x, p3y, p1x, p1y, p2x, p2y), y1 = orient2d(p4x, p4y, p1x, p1y, p2x, p2y);
  if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0) {
    return false;
  }
  if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return !(Math.max(p3x, p4x) < Math.min(p1x, p2x) || Math.max(p1x, p2x) < Math.min(p3x, p4x) || Math.max(p3y, p4y) < Math.min(p1y, p2y) || Math.max(p1y, p2y) < Math.min(p3y, p4y));
  }
  return true;
}
var BitSet, BitSet8, Constrainautor;
var init_Constrainautor = __esm({
  "node_modules/@kninnug/constrainautor/lib/Constrainautor.mjs"() {
    init_robust_predicates();
    BitSet = class {
      constructor(W3, bs) {
        this.W = W3;
        this.bs = bs;
      }
      /**
       * Add a number to the set.
       *
       * @param idx The number to add. Must be 0 <= idx < len.
       * @return this.
       */
      add(idx) {
        const W3 = this.W, byte = idx / W3 | 0, bit = idx % W3;
        this.bs[byte] |= 1 << bit;
        return this;
      }
      /**
       * Delete a number from the set.
       *
       * @param idx The number to delete. Must be 0 <= idx < len.
       * @return this.
       */
      delete(idx) {
        const W3 = this.W, byte = idx / W3 | 0, bit = idx % W3;
        this.bs[byte] &= ~(1 << bit);
        return this;
      }
      /**
       * Add or delete a number in the set, depending on the second argument.
       *
       * @param idx The number to add or delete. Must be 0 <= idx < len.
       * @param val If true, add the number, otherwise delete.
       * @return val.
       */
      set(idx, val) {
        const W3 = this.W, byte = idx / W3 | 0, bit = idx % W3, m5 = 1 << bit;
        this.bs[byte] ^= (-val ^ this.bs[byte]) & m5;
        return val;
      }
      /**
       * Whether the number is in the set.
       *
       * @param idx The number to test. Must be 0 <= idx < len.
       * @return True if the number is in the set.
       */
      has(idx) {
        const W3 = this.W, byte = idx / W3 | 0, bit = idx % W3;
        return !!(this.bs[byte] & 1 << bit);
      }
      /**
       * Iterate over the numbers that are in the set. The callback is invoked
       * with each number that is set. It is allowed to change the BitSet during
       * iteration. If it deletes a number that has not been iterated over, that
       * number will not show up in a later call. If it adds a number during
       * iteration, that number may or may not show up in a later call.
       *
       * @param fn The function to call for each number.
       * @return this.
       */
      forEach(fn3) {
        const W3 = this.W, bs = this.bs, len = bs.length;
        for (let byte = 0; byte < len; byte++) {
          let bit = 0;
          while (bs[byte] && bit < W3) {
            if (bs[byte] & 1 << bit) {
              fn3(byte * W3 + bit);
            }
            bit++;
          }
        }
        return this;
      }
    };
    BitSet8 = class extends BitSet {
      /**
       * Create a bit set.
       *
       * @param len The length of the bit set, limiting the maximum value that
       *        can be stored in it to len - 1.
       */
      constructor(len) {
        const W3 = 8, bs = new Uint8Array(Math.ceil(len / W3)).fill(0);
        super(W3, bs);
      }
    };
    Constrainautor = class {
      /**
       * Make a Constrainautor.
       *
       * @param del The triangulation output from Delaunator.
       * @param edges If provided, constrain these edges as by constrainAll.
       */
      constructor(del, edges) {
        if (!del || typeof del !== "object" || !del.triangles || !del.halfedges || !del.coords) {
          throw new Error("Expected an object with Delaunator output");
        }
        if (del.triangles.length % 3 || del.halfedges.length !== del.triangles.length || del.coords.length % 2) {
          throw new Error("Delaunator output appears inconsistent");
        }
        if (del.triangles.length < 3) {
          throw new Error("No edges in triangulation");
        }
        this.del = del;
        const U32NIL = 2 ** 32 - 1, numPoints = del.coords.length >> 1, numEdges = del.triangles.length;
        this.vertMap = new Uint32Array(numPoints).fill(U32NIL);
        this.flips = new BitSet8(numEdges);
        this.consd = new BitSet8(numEdges);
        for (let e3 = 0; e3 < numEdges; e3++) {
          const v4 = del.triangles[e3];
          if (this.vertMap[v4] === U32NIL) {
            this.updateVert(e3);
          }
        }
        if (edges) {
          this.constrainAll(edges);
        }
      }
      /**
       * Constrain the triangulation such that there is an edge between p1 and p2.
       *
       * @param segP1 The index of one segment end-point in the coords array.
       * @param segP2 The index of the other segment end-point in the coords array.
       * @return The id of the edge that points from p1 to p2. If the
       *         constrained edge lies on the hull and points in the opposite
       *         direction (p2 to p1), the negative of its id is returned.
       */
      constrainOne(segP1, segP2) {
        const { triangles, halfedges } = this.del, vm = this.vertMap, consd = this.consd, start2 = vm[segP1];
        let edg = start2;
        do {
          const p4 = triangles[edg], nxt = nextEdge(edg);
          if (p4 === segP2) {
            return this.protect(edg);
          }
          const opp = prevEdge(edg), p32 = triangles[opp];
          if (p32 === segP2) {
            this.protect(nxt);
            return nxt;
          }
          if (this.intersectSegments(segP1, segP2, p32, p4)) {
            edg = opp;
            break;
          }
          const adj = halfedges[nxt];
          edg = adj;
        } while (edg !== -1 && edg !== start2);
        let conEdge = edg;
        let rescan = -1;
        while (edg !== -1) {
          const adj = halfedges[edg], bot = prevEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj);
          if (adj === -1) {
            throw new Error("Constraining edge exited the hull");
          }
          if (consd.has(edg)) {
            throw new Error("Edge intersects already constrained edge");
          }
          if (this.isCollinear(segP1, segP2, triangles[edg]) || this.isCollinear(segP1, segP2, triangles[adj])) {
            throw new Error("Constraining edge intersects point");
          }
          const convex = this.intersectSegments(triangles[edg], triangles[adj], triangles[bot], triangles[top]);
          if (!convex) {
            if (rescan === -1) {
              rescan = edg;
            }
            if (triangles[top] === segP2) {
              if (edg === rescan) {
                throw new Error("Infinite loop: non-convex quadrilateral");
              }
              edg = rescan;
              rescan = -1;
              continue;
            }
            if (this.intersectSegments(segP1, segP2, triangles[top], triangles[adj])) {
              edg = top;
            } else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {
              edg = rgt;
            } else if (rescan === edg) {
              throw new Error("Infinite loop: no further intersect after non-convex");
            }
            continue;
          }
          this.flipDiagonal(edg);
          if (this.intersectSegments(segP1, segP2, triangles[bot], triangles[top])) {
            if (rescan === -1) {
              rescan = bot;
            }
            if (rescan === bot) {
              throw new Error("Infinite loop: flipped diagonal still intersects");
            }
          }
          if (triangles[top] === segP2) {
            conEdge = top;
            edg = rescan;
            rescan = -1;
          } else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {
            edg = rgt;
          }
        }
        const flips = this.flips;
        this.protect(conEdge);
        do {
          var flipped = 0;
          flips.forEach((edg2) => {
            flips.delete(edg2);
            const adj = halfedges[edg2];
            if (adj === -1) {
              return;
            }
            flips.delete(adj);
            if (!this.isDelaunay(edg2)) {
              this.flipDiagonal(edg2);
              flipped++;
            }
          });
        } while (flipped > 0);
        return this.findEdge(segP1, segP2);
      }
      /**
       * Fix the Delaunay condition. It is no longer necessary to call this
       * method after constraining (many) edges, since constrainOne will do it
       * after each.
       *
       * @param deep If true, keep checking & flipping edges until all
       *        edges are Delaunay, otherwise only check the edges once.
       * @return The triangulation object.
       */
      delaunify(deep = false) {
        const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd, len = halfedges.length;
        do {
          var flipped = 0;
          for (let edg = 0; edg < len; edg++) {
            if (consd.has(edg)) {
              continue;
            }
            flips.delete(edg);
            const adj = halfedges[edg];
            if (adj === -1) {
              continue;
            }
            flips.delete(adj);
            if (!this.isDelaunay(edg)) {
              this.flipDiagonal(edg);
              flipped++;
            }
          }
        } while (deep && flipped > 0);
        return this;
      }
      /**
       * Call constrainOne on each edge, and delaunify afterwards.
       *
       * @param edges The edges to constrain: each element is an array with
       *        [p1, p2] which are indices into the points array originally
       *        supplied to Delaunator.
       * @return The triangulation object.
       */
      constrainAll(edges) {
        const len = edges.length;
        for (let i4 = 0; i4 < len; i4++) {
          const e3 = edges[i4];
          this.constrainOne(e3[0], e3[1]);
        }
        return this;
      }
      /**
       * Whether an edge is a constrained edge.
       *
       * @param edg The edge id.
       * @return True if the edge is constrained.
       */
      isConstrained(edg) {
        return this.consd.has(edg);
      }
      /**
       * Find the edge that points from p1 -> p2. If there is only an edge from
       * p2 -> p1 (i.e. it is on the hull), returns the negative id of it.
       *
       * @param p1 The index of the first point into the points array.
       * @param p2 The index of the second point into the points array.
       * @return The id of the edge that points from p1 -> p2, or the negative
       *         id of the edge that goes from p2 -> p1, or Infinity if there is
       *         no edge between p1 and p2.
       */
      findEdge(p1, p22) {
        const start1 = this.vertMap[p22], { triangles, halfedges } = this.del;
        let edg = start1, prv = -1;
        do {
          if (triangles[edg] === p1) {
            return edg;
          }
          prv = nextEdge(edg);
          edg = halfedges[prv];
        } while (edg !== -1 && edg !== start1);
        if (triangles[nextEdge(prv)] === p1) {
          return -prv;
        }
        return Infinity;
      }
      /**
       * Mark an edge as constrained, i.e. should not be touched by `delaunify`.
       *
       * @private
       * @param edg The edge id.
       * @return If edg has an adjacent, returns that, otherwise -edg.
       */
      protect(edg) {
        const adj = this.del.halfedges[edg], flips = this.flips, consd = this.consd;
        flips.delete(edg);
        consd.add(edg);
        if (adj !== -1) {
          flips.delete(adj);
          consd.add(adj);
          return adj;
        }
        return -edg;
      }
      /**
       * Mark an edge as flipped, unless it is already marked as constrained.
       *
       * @private
       * @param edg The edge id.
       * @return True if edg was not constrained.
       */
      markFlip(edg) {
        const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd;
        if (consd.has(edg)) {
          return false;
        }
        const adj = halfedges[edg];
        if (adj !== -1) {
          flips.add(edg);
          flips.add(adj);
        }
        return true;
      }
      /**
       * Flip the edge shared by two triangles.
       *
       * @private
       * @param edg The edge shared by the two triangles, must have an
       *        adjacent half-edge.
       * @return The new diagonal.
       */
      flipDiagonal(edg) {
        const { triangles, halfedges } = this.del, flips = this.flips, consd = this.consd, adj = halfedges[edg], bot = prevEdge(edg), lft = nextEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj), adjBot = halfedges[bot], adjTop = halfedges[top];
        if (consd.has(edg)) {
          throw new Error("Trying to flip a constrained edge");
        }
        triangles[edg] = triangles[top];
        halfedges[edg] = adjTop;
        if (!flips.set(edg, flips.has(top))) {
          consd.set(edg, consd.has(top));
        }
        if (adjTop !== -1) {
          halfedges[adjTop] = edg;
        }
        halfedges[bot] = top;
        triangles[adj] = triangles[bot];
        halfedges[adj] = adjBot;
        if (!flips.set(adj, flips.has(bot))) {
          consd.set(adj, consd.has(bot));
        }
        if (adjBot !== -1) {
          halfedges[adjBot] = adj;
        }
        halfedges[top] = bot;
        this.markFlip(edg);
        this.markFlip(lft);
        this.markFlip(adj);
        this.markFlip(rgt);
        flips.add(bot);
        consd.delete(bot);
        flips.add(top);
        consd.delete(top);
        this.updateVert(edg);
        this.updateVert(lft);
        this.updateVert(adj);
        this.updateVert(rgt);
        return bot;
      }
      /**
       * Whether the two triangles sharing edg conform to the Delaunay condition.
       * As a shortcut, if the given edge has no adjacent (is on the hull), it is
       * certainly Delaunay.
       *
       * @private
       * @param edg The edge shared by the triangles to test.
       * @return True if they are Delaunay.
       */
      isDelaunay(edg) {
        const { triangles, halfedges } = this.del, adj = halfedges[edg];
        if (adj === -1) {
          return true;
        }
        const p1 = triangles[prevEdge(edg)], p22 = triangles[edg], p32 = triangles[nextEdge(edg)], px = triangles[prevEdge(adj)];
        return !this.inCircle(p1, p22, p32, px);
      }
      /**
       * Update the vertex -> incoming edge map.
       *
       * @private
       * @param start The id of an *outgoing* edge.
       * @return The id of the right-most incoming edge.
       */
      updateVert(start2) {
        const { triangles, halfedges } = this.del, vm = this.vertMap, v4 = triangles[start2];
        let inc = prevEdge(start2), adj = halfedges[inc];
        while (adj !== -1 && adj !== start2) {
          inc = prevEdge(adj);
          adj = halfedges[inc];
        }
        vm[v4] = inc;
        return inc;
      }
      /**
       * Whether the segment between [p1, p2] intersects with [p3, p4]. When the
       * segments share an end-point (e.g. p1 == p3 etc.), they are not considered
       * intersecting.
       *
       * @private
       * @param p1 The index of point 1 into this.del.coords.
       * @param p2 The index of point 2 into this.del.coords.
       * @param p3 The index of point 3 into this.del.coords.
       * @param p4 The index of point 4 into this.del.coords.
       * @return True if the segments intersect.
       */
      intersectSegments(p1, p22, p32, p4) {
        const pts = this.del.coords;
        if (p1 === p32 || p1 === p4 || p22 === p32 || p22 === p4) {
          return false;
        }
        return intersectSegments(pts[p1 * 2], pts[p1 * 2 + 1], pts[p22 * 2], pts[p22 * 2 + 1], pts[p32 * 2], pts[p32 * 2 + 1], pts[p4 * 2], pts[p4 * 2 + 1]);
      }
      /**
       * Whether point px is in the circumcircle of the triangle formed by p1, p2,
       * and p3 (which are in counter-clockwise order).
       *
       * @param p1 The index of point 1 into this.del.coords.
       * @param p2 The index of point 2 into this.del.coords.
       * @param p3 The index of point 3 into this.del.coords.
       * @param px The index of point x into this.del.coords.
       * @return True if (px, py) is in the circumcircle.
       */
      inCircle(p1, p22, p32, px) {
        const pts = this.del.coords;
        return incircle(pts[p1 * 2], pts[p1 * 2 + 1], pts[p22 * 2], pts[p22 * 2 + 1], pts[p32 * 2], pts[p32 * 2 + 1], pts[px * 2], pts[px * 2 + 1]) < 0;
      }
      /**
       * Whether point p1, p2, and p are collinear.
       *
       * @private
       * @param p1 The index of segment point 1 into this.del.coords.
       * @param p2 The index of segment point 2 into this.del.coords.
       * @param p The index of the point p into this.del.coords.
       * @return True if the points are collinear.
       */
      isCollinear(p1, p22, p4) {
        const pts = this.del.coords;
        return orient2d(pts[p1 * 2], pts[p1 * 2 + 1], pts[p22 * 2], pts[p22 * 2 + 1], pts[p4 * 2], pts[p4 * 2 + 1]) === 0;
      }
    };
    Constrainautor.intersectSegments = intersectSegments;
  }
});

// node_modules/@allmaps/triangulate/dist/index.js
var init_dist7 = __esm({
  "node_modules/@allmaps/triangulate/dist/index.js"() {
    init_shared2();
    init_dist();
    init_Constrainautor();
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image.1.js
var image1ProfileUriRegex, Image1ProfileUri, Image1ProfileSchema, Image1ContextString, Image1Context, Image1Schema;
var init_image_1 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image.1.js"() {
    init_zod();
    image1ProfileUriRegex = /^https?:\/\/library.stanford.edu\/iiif\/image-api\/1.1\/compliance.html#level(?<level>[012])$/;
    Image1ProfileUri = external_exports.string().regex(image1ProfileUriRegex);
    Image1ProfileSchema = Image1ProfileUri;
    Image1ContextString = "http://library.stanford.edu/iiif/image-api/1.1/context.json";
    Image1Context = external_exports.literal(Image1ContextString);
    Image1Schema = external_exports.object({
      "@context": Image1Context,
      "@id": external_exports.string().url(),
      profile: Image1ProfileUri.optional(),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      scale_factors: external_exports.number().array().optional(),
      tile_width: external_exports.number().optional(),
      tile_height: external_exports.number().optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/shared.js
var SizeSchema, TilesetSchema, imageServiceTypes, ImageServiceTypesSchema, ValidNavDateSchema, NavDateSchema, NavPlaceSchema;
var init_shared3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/shared.js"() {
    init_zod();
    SizeSchema = external_exports.object({
      width: external_exports.number().int(),
      height: external_exports.number().int()
    });
    TilesetSchema = external_exports.object({
      width: external_exports.number().int(),
      height: external_exports.number().int().optional(),
      scaleFactors: external_exports.array(external_exports.number().int())
    });
    imageServiceTypes = [
      "ImageService1",
      "ImageService2",
      "ImageService3"
    ];
    ImageServiceTypesSchema = external_exports.enum(imageServiceTypes);
    ValidNavDateSchema = external_exports.coerce.date();
    NavDateSchema = external_exports.union([
      ValidNavDateSchema,
      // Catchall for incorrect values
      external_exports.any()
    ]).transform((val) => {
      const { success, data } = ValidNavDateSchema.safeParse(val);
      if (success) {
        return data;
      }
    });
    NavPlaceSchema = external_exports.object({}).passthrough();
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image.2.js
function isValidImage2ProfileArrayItem(item) {
  return item !== void 0;
}
var image2ProfileUriRegex, Image2ProfileUri, Image2ProfileDescriptionSchema, ValidImage2ProfileArrayItemSchema, Image2ProfileSchema, Image2ContextString, Image2Context, Image2Schema;
var init_image_2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image.2.js"() {
    init_zod();
    init_shared3();
    image2ProfileUriRegex = /^https?:\/\/iiif.io\/api\/image\/2.*level(?<level>[012])(.json)?$/;
    Image2ProfileUri = external_exports.string().regex(image2ProfileUriRegex);
    Image2ProfileDescriptionSchema = external_exports.object({
      formats: external_exports.string().array().optional(),
      maxArea: external_exports.number().int().optional(),
      maxHeight: external_exports.number().int().optional(),
      maxWidth: external_exports.number().int().optional(),
      qualities: external_exports.string().array().optional(),
      supports: external_exports.string().array().optional()
    });
    ValidImage2ProfileArrayItemSchema = external_exports.union([
      Image2ProfileUri,
      Image2ProfileDescriptionSchema
    ]);
    Image2ProfileSchema = external_exports.union([
      Image2ProfileUri,
      external_exports.array(external_exports.union([
        ValidImage2ProfileArrayItemSchema,
        // Catchall for incorrect profiles
        external_exports.unknown()
      ]).transform((val) => {
        const { success, data } = ValidImage2ProfileArrayItemSchema.safeParse(val);
        if (success) {
          return data;
        }
      }))
    ]).transform((val) => {
      if (val && Array.isArray(val)) {
        const firstProfile = val[0];
        if (typeof firstProfile !== "string") {
          throw new Error("First profile must be a string");
        }
        return [
          firstProfile,
          ...val.slice(1).filter(isValidImage2ProfileArrayItem)
        ];
      }
      return val;
    });
    Image2ContextString = "http://iiif.io/api/image/2/context.json";
    Image2Context = external_exports.union([
      external_exports.literal(Image2ContextString),
      // Invalid, but used by https://iiif.archivelab.org
      external_exports.literal("https://iiif.io/api/image/2/context.json"),
      external_exports.string().url()
    ]);
    Image2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.union([external_exports.literal("iiif:Image"), external_exports.literal("ImageService2")]).optional(),
      "@context": Image2Context,
      protocol: external_exports.literal("http://iiif.io/api/image"),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      profile: Image2ProfileSchema,
      sizes: SizeSchema.array().optional(),
      tiles: TilesetSchema.array().optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image.3.js
var image3Profiles, Image3ProfileSchema, Image3Schema;
var init_image_3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image.3.js"() {
    init_zod();
    init_shared3();
    image3Profiles = ["level0", "level1", "level2"];
    Image3ProfileSchema = external_exports.enum(image3Profiles);
    Image3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("ImageService3"),
      protocol: external_exports.literal("http://iiif.io/api/image"),
      profile: Image3ProfileSchema,
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      maxWidth: external_exports.number().int().optional(),
      maxHeight: external_exports.number().int().optional(),
      maxArea: external_exports.number().int().optional(),
      sizes: SizeSchema.array().optional(),
      tiles: TilesetSchema.array().optional(),
      extraFeatures: external_exports.string().array().optional()
      // TODO: add partOf, seeAlso, and service
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image-service.2.js
var ImageService2Schema;
var init_image_service_2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image-service.2.js"() {
    init_zod();
    init_image_1();
    init_image_2();
    init_image_3();
    init_shared3();
    ImageService2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": ImageServiceTypesSchema.optional(),
      profile: external_exports.union([
        Image1ProfileSchema,
        Image2ProfileSchema,
        Image3ProfileSchema
      ]),
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional(),
      "@context": external_exports.union([
        Image1Context,
        external_exports.literal("http://iiif.io/api/image/1/context.json"),
        Image2Context
      ]).optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image-service.3.js
var complianceLevels, Presentation3ImageService2Schema, Presentation3ImageService3Schema, ImageService3Schema;
var init_image_service_3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image-service.3.js"() {
    init_zod();
    init_image_2();
    init_shared3();
    complianceLevels = ["level0", "level1", "level2"];
    Presentation3ImageService2Schema = external_exports.union([
      external_exports.object({
        id: external_exports.string().url(),
        type: external_exports.literal("ImageService2"),
        profile: Image2ProfileSchema
      }),
      external_exports.object({
        "@id": external_exports.string().url(),
        "@type": external_exports.literal("ImageService2"),
        profile: Image2ProfileSchema
      })
    ]);
    Presentation3ImageService3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: ImageServiceTypesSchema,
      profile: external_exports.enum(complianceLevels)
    });
    ImageService3Schema = external_exports.union([
      Presentation3ImageService2Schema,
      Presentation3ImageService3Schema
    ]);
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image-service.js
var ImageServiceSchema2;
var init_image_service = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image-service.js"() {
    init_zod();
    init_image_service_2();
    init_image_service_3();
    ImageServiceSchema2 = external_exports.union([
      ImageService2Schema,
      ImageService3Schema
    ]);
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/convert.js
function ensureArray2(val) {
  if (val) {
    return Array.isArray(val) ? val : [val];
  }
}
var LanguageString3Schema, MetadataStringItem3Schema;
var init_convert2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/convert.js"() {
    init_zod();
    LanguageString3Schema = external_exports.record(external_exports.string(), external_exports.string().array());
    MetadataStringItem3Schema = external_exports.object({
      label: LanguageString3Schema.optional(),
      value: LanguageString3Schema.optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/presentation.2.js
var SingleValue2Schema, Value2Schema, RelatedItem2Schema, Related2Schema, ThumbnailItem2Schema, Thumbnail2Schema, RenderingItem2Schema, Rendering2Schema, ValidLanguageValue2Schema, LanguageValue2Schema, PossibleLanguageValue2Schema, Attribution2Schema, ValidMetadataItem2Schema, MetadataItem2Schema, Metadata2Schema, ImageResource2Schema, Annotation2Schema, Canvas2Schema, Sequence2Schema, Manifest2Schema, EmbeddedManifest2Schema, Collection2Schema, EmbeddedCollection2Schema;
var init_presentation_2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/presentation.2.js"() {
    init_zod();
    init_image_service();
    init_shared3();
    init_convert2();
    SingleValue2Schema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]).transform((val) => String(val));
    Value2Schema = external_exports.union([
      SingleValue2Schema.array(),
      SingleValue2Schema
    ]);
    RelatedItem2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      format: external_exports.string().optional(),
      label: Value2Schema.optional()
    });
    Related2Schema = external_exports.union([
      RelatedItem2Schema.array(),
      RelatedItem2Schema,
      SingleValue2Schema
    ]);
    ThumbnailItem2Schema = external_exports.union([
      external_exports.string(),
      external_exports.object({
        "@id": external_exports.string().url(),
        "@type": external_exports.string().optional(),
        format: external_exports.string().optional(),
        height: external_exports.number().optional(),
        width: external_exports.number().optional()
      })
    ]);
    Thumbnail2Schema = external_exports.union([ThumbnailItem2Schema.array(), ThumbnailItem2Schema]).transform(ensureArray2);
    RenderingItem2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.string().optional(),
      label: Value2Schema.optional(),
      format: external_exports.string().optional()
    });
    Rendering2Schema = external_exports.union([RenderingItem2Schema.array(), RenderingItem2Schema]).transform(ensureArray2);
    ValidLanguageValue2Schema = external_exports.union([
      external_exports.object({ "@value": Value2Schema, "@language": external_exports.string().optional() }),
      // This is invalid but some IIIF manifests use this incorrect format
      external_exports.object({ value: Value2Schema, language: external_exports.string().optional() })
    ]).transform((val) => {
      if ("value" in val) {
        return {
          "@value": val.value,
          "@language": val.language
        };
      } else {
        return val;
      }
    });
    LanguageValue2Schema = ValidLanguageValue2Schema;
    PossibleLanguageValue2Schema = external_exports.union([
      LanguageValue2Schema.array(),
      LanguageValue2Schema,
      Value2Schema
    ]);
    Attribution2Schema = external_exports.union([
      external_exports.string(),
      PossibleLanguageValue2Schema
    ]);
    ValidMetadataItem2Schema = external_exports.object({
      label: PossibleLanguageValue2Schema.optional(),
      value: PossibleLanguageValue2Schema.optional()
    });
    MetadataItem2Schema = external_exports.union([
      ValidMetadataItem2Schema,
      // Catchall for incorrect values
      external_exports.any()
    ]).transform((val) => {
      const { success, data } = ValidMetadataItem2Schema.safeParse(val);
      if (success) {
        return data;
      }
    });
    Metadata2Schema = MetadataItem2Schema.array();
    ImageResource2Schema = external_exports.object({
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional(),
      service: ImageServiceSchema2
    });
    Annotation2Schema = external_exports.object({
      resource: ImageResource2Schema
    });
    Canvas2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Canvas"),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      images: Annotation2Schema.array().length(1),
      label: PossibleLanguageValue2Schema.optional(),
      description: PossibleLanguageValue2Schema.optional(),
      related: Related2Schema.optional(),
      attribution: Attribution2Schema.optional(),
      thumbnail: Thumbnail2Schema.optional(),
      rendering: Rendering2Schema.optional(),
      metadata: Metadata2Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional()
    });
    Sequence2Schema = external_exports.object({
      canvases: Canvas2Schema.array().nonempty()
    });
    Manifest2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Manifest"),
      sequences: Sequence2Schema.array().length(1),
      label: PossibleLanguageValue2Schema.optional(),
      description: PossibleLanguageValue2Schema.optional(),
      metadata: Metadata2Schema.optional(),
      related: Related2Schema.optional(),
      attribution: Attribution2Schema.optional(),
      rendering: Rendering2Schema.optional(),
      thumbnail: Thumbnail2Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional()
    });
    EmbeddedManifest2Schema = external_exports.lazy(() => external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Manifest"),
      label: PossibleLanguageValue2Schema.optional()
    }));
    Collection2Schema = external_exports.lazy(() => external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Collection"),
      manifests: EmbeddedManifest2Schema.array().optional(),
      collections: Collection2Schema.array().optional(),
      members: external_exports.union([
        EmbeddedManifest2Schema,
        Collection2Schema,
        EmbeddedCollection2Schema
      ]).array().optional(),
      label: PossibleLanguageValue2Schema.optional(),
      description: PossibleLanguageValue2Schema.optional(),
      metadata: Metadata2Schema.optional(),
      related: Related2Schema.optional(),
      attribution: Attribution2Schema.optional(),
      thumbnail: Thumbnail2Schema.optional(),
      rendering: Rendering2Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional()
    }));
    EmbeddedCollection2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Collection"),
      label: PossibleLanguageValue2Schema.optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/presentation.3.js
var SingleValue3Schema, LanguageValue3Schema, Summary3Schema, HomepageItem3Schema, Rendering3ItemSchema, Rendering3Schema, Homepage3Schema, ThumbnailItem3Schema, Thumbnail3Schema, SeeAlsoItem3Schema, SeeAlso3Schema, NonPaintingAnnotations3, ValidMetadataItem3Schema, MetadataItem3Schema, Metadata3Schema, RequiredStatement3Schema, AnnotationBody3Schema, Choice3Schema, Annotation3Schema, AnnotationPage3Schema, Canvas3Schema2, Manifest3Schema, EmbeddedManifest3Schema, Collection3Schema, EmbeddedCollection3Schema;
var init_presentation_3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/presentation.3.js"() {
    init_zod();
    init_image_service();
    init_shared3();
    init_convert2();
    SingleValue3Schema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]).transform((val) => String(val));
    LanguageValue3Schema = external_exports.record(external_exports.string(), SingleValue3Schema.array());
    Summary3Schema = LanguageValue3Schema;
    HomepageItem3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      label: LanguageValue3Schema,
      format: external_exports.string().optional(),
      language: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional()
    });
    Rendering3ItemSchema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      label: LanguageValue3Schema,
      format: external_exports.string().optional()
    });
    Rendering3Schema = external_exports.union([Rendering3ItemSchema.array(), Rendering3ItemSchema]).transform(ensureArray2);
    Homepage3Schema = external_exports.union([HomepageItem3Schema.array(), HomepageItem3Schema]).transform(ensureArray2);
    ThumbnailItem3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      format: external_exports.string().optional(),
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional()
    });
    Thumbnail3Schema = external_exports.union([ThumbnailItem3Schema.array(), ThumbnailItem3Schema]).transform(ensureArray2);
    SeeAlsoItem3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      format: external_exports.string().optional(),
      profile: external_exports.string().optional()
    });
    SeeAlso3Schema = external_exports.union([SeeAlsoItem3Schema.array(), SeeAlsoItem3Schema]).transform(ensureArray2);
    NonPaintingAnnotations3 = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("AnnotationPage"),
      items: external_exports.object({}).passthrough().array().optional()
    }).array();
    ValidMetadataItem3Schema = external_exports.object({
      label: LanguageValue3Schema,
      value: LanguageValue3Schema
    });
    MetadataItem3Schema = external_exports.union([
      ValidMetadataItem3Schema,
      // Catchall for incorrect values
      external_exports.any()
    ]).transform((val) => {
      const { success, data } = ValidMetadataItem3Schema.safeParse(val);
      if (success) {
        return data;
      }
    });
    Metadata3Schema = MetadataItem3Schema.array();
    RequiredStatement3Schema = MetadataItem3Schema;
    AnnotationBody3Schema = external_exports.object({
      type: external_exports.literal("Image"),
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional(),
      service: ImageServiceSchema2.array()
    });
    Choice3Schema = external_exports.object({
      type: external_exports.literal("Choice"),
      items: AnnotationBody3Schema.array()
    });
    Annotation3Schema = external_exports.object({
      type: external_exports.literal("Annotation"),
      body: external_exports.union([
        AnnotationBody3Schema,
        AnnotationBody3Schema.array().length(1),
        Choice3Schema
      ])
    });
    AnnotationPage3Schema = external_exports.object({
      type: external_exports.literal("AnnotationPage"),
      items: Annotation3Schema.array().length(1)
    });
    Canvas3Schema2 = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Canvas"),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      items: AnnotationPage3Schema.array().length(1),
      label: LanguageValue3Schema.optional(),
      description: LanguageValue3Schema.optional(),
      metadata: Metadata3Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional(),
      homepage: Homepage3Schema.optional(),
      thumbnail: Thumbnail3Schema.optional(),
      rendering: Rendering3Schema.optional(),
      seeAlso: SeeAlso3Schema.optional(),
      summary: Summary3Schema.optional(),
      requiredStatement: RequiredStatement3Schema.optional(),
      annotations: NonPaintingAnnotations3.optional()
    });
    Manifest3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Manifest"),
      items: Canvas3Schema2.array().nonempty(),
      label: LanguageValue3Schema.optional(),
      description: LanguageValue3Schema.optional(),
      metadata: Metadata3Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional(),
      homepage: Homepage3Schema.optional(),
      thumbnail: Thumbnail3Schema.optional(),
      rendering: Rendering3Schema.optional(),
      seeAlso: SeeAlso3Schema.optional(),
      summary: Summary3Schema.optional(),
      requiredStatement: RequiredStatement3Schema.optional(),
      annotations: NonPaintingAnnotations3.optional()
    });
    EmbeddedManifest3Schema = external_exports.lazy(() => external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Manifest"),
      label: LanguageValue3Schema.optional()
    }));
    Collection3Schema = external_exports.lazy(() => external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Collection"),
      items: external_exports.union([
        EmbeddedManifest3Schema,
        Collection3Schema,
        EmbeddedCollection3Schema
      ]).array(),
      label: LanguageValue3Schema.optional(),
      description: LanguageValue3Schema.optional(),
      metadata: Metadata3Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional(),
      homepage: Homepage3Schema.optional(),
      thumbnail: Thumbnail3Schema.optional(),
      rendering: Rendering3Schema.optional(),
      seeAlso: SeeAlso3Schema.optional(),
      summary: Summary3Schema.optional(),
      requiredStatement: RequiredStatement3Schema.optional(),
      annotations: NonPaintingAnnotations3.optional()
    }));
    EmbeddedCollection3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Collection"),
      label: LanguageValue3Schema.optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/iiif.js
var ImageSchema2, CanvasSchema, ManifestSchema, CollectionSchema, IIIF1Schema, IIIF2Schema, IIIF3Schema, IIIFSchema;
var init_iiif = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/iiif.js"() {
    init_zod();
    init_image_1();
    init_image_2();
    init_image_3();
    init_presentation_2();
    init_presentation_3();
    ImageSchema2 = external_exports.union([Image1Schema, Image2Schema, Image3Schema]);
    CanvasSchema = external_exports.union([Canvas2Schema, Canvas3Schema2]);
    ManifestSchema = external_exports.union([Manifest2Schema, Manifest3Schema]);
    CollectionSchema = external_exports.union([Collection2Schema, Collection3Schema]);
    IIIF1Schema = Image1Schema;
    IIIF2Schema = external_exports.union([
      Collection2Schema,
      Manifest2Schema,
      Canvas2Schema,
      Image2Schema
    ]);
    IIIF3Schema = external_exports.union([
      Collection3Schema,
      Manifest3Schema,
      Canvas3Schema2,
      Image3Schema
    ]);
    IIIFSchema = external_exports.union([IIIF1Schema, IIIF2Schema, IIIF3Schema]);
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/tiles.js
var init_tiles2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/tiles.js"() {
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/image-requests.js
var init_image_requests = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/image-requests.js"() {
    init_tiles2();
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/profile.js
var init_profile = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/profile.js"() {
    init_image_1();
    init_image_2();
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/image.js
var init_image = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/image.js"() {
    init_iiif();
    init_image_1();
    init_image_2();
    init_tiles2();
    init_image_requests();
    init_profile();
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/canvas.js
var init_canvas = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/canvas.js"() {
    init_image();
    init_convert2();
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/manifest.js
var init_manifest = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/manifest.js"() {
    init_iiif();
    init_image();
    init_canvas();
    init_convert2();
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/collection.js
var defaulfFetchNextOptions;
var init_collection = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/collection.js"() {
    init_iiif();
    init_manifest();
    init_convert2();
    defaulfFetchNextOptions = {
      maxDepth: Number.POSITIVE_INFINITY,
      fetchCollections: true,
      fetchManifests: true,
      fetchImages: false,
      fetchFn: globalThis.fetch
    };
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/iiif.js
var init_iiif2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/iiif.js"() {
    init_iiif();
    init_image_1();
    init_image();
    init_manifest();
    init_collection();
  }
});

// node_modules/@allmaps/iiif-parser/dist/index.js
var init_dist8 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/index.js"() {
    init_iiif2();
    init_collection();
    init_manifest();
    init_canvas();
    init_image();
  }
});

// node_modules/@allmaps/render/dist/shared/homogeneous-transform.js
var init_homogeneous_transform = __esm({
  "node_modules/@allmaps/render/dist/shared/homogeneous-transform.js"() {
  }
});

// node_modules/@allmaps/render/dist/maps/WarpedMap.js
var init_WarpedMap = __esm({
  "node_modules/@allmaps/render/dist/maps/WarpedMap.js"() {
    init_dist8();
    init_dist6();
    init_dist();
    init_homogeneous_transform();
    init_events2();
  }
});

// node_modules/@allmaps/render/dist/maps/TriangulatedWarpedMap.js
var init_TriangulatedWarpedMap = __esm({
  "node_modules/@allmaps/render/dist/maps/TriangulatedWarpedMap.js"() {
    init_dist7();
    init_dist();
    init_WarpedMap();
  }
});

// node_modules/@allmaps/render/dist/shared/webgl2.js
var init_webgl2 = __esm({
  "node_modules/@allmaps/render/dist/shared/webgl2.js"() {
  }
});

// node_modules/@allmaps/render/dist/maps/WebGL2WarpedMap.js
var init_WebGL2WarpedMap = __esm({
  "node_modules/@allmaps/render/dist/maps/WebGL2WarpedMap.js"() {
    init_dist();
    init_dist3();
    init_TriangulatedWarpedMap();
    init_events2();
    init_homogeneous_transform();
    init_webgl2();
    init_tiles();
  }
});

// node_modules/@allmaps/render/dist/tilecache/CacheableTile.js
var init_CacheableTile = __esm({
  "node_modules/@allmaps/render/dist/tilecache/CacheableTile.js"() {
  }
});

// node_modules/@allmaps/render/dist/tilecache/CacheableWorkerImageDataTile.js
var init_CacheableWorkerImageDataTile = __esm({
  "node_modules/@allmaps/render/dist/tilecache/CacheableWorkerImageDataTile.js"() {
    init_CacheableTile();
    init_events2();
  }
});

// node_modules/@allmaps/render/dist/viewport/Viewport.js
var init_Viewport = __esm({
  "node_modules/@allmaps/render/dist/viewport/Viewport.js"() {
    init_dist();
    init_dist6();
    init_homogeneous_transform();
  }
});

// node_modules/@allmaps/render/dist/shaders/map/vertex-shader.glsl.js
var init_vertex_shader_glsl = __esm({
  "node_modules/@allmaps/render/dist/shaders/map/vertex-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/map/fragment-shader.glsl.js
var init_fragment_shader_glsl = __esm({
  "node_modules/@allmaps/render/dist/shaders/map/fragment-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/lines/vertex-shader.glsl.js
var init_vertex_shader_glsl2 = __esm({
  "node_modules/@allmaps/render/dist/shaders/lines/vertex-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/lines/fragment-shader.glsl.js
var init_fragment_shader_glsl2 = __esm({
  "node_modules/@allmaps/render/dist/shaders/lines/fragment-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/points/vertex-shader.glsl.js
var init_vertex_shader_glsl3 = __esm({
  "node_modules/@allmaps/render/dist/shaders/points/vertex-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/points/fragment-shader.glsl.js
var init_fragment_shader_glsl3 = __esm({
  "node_modules/@allmaps/render/dist/shaders/points/fragment-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/workers/fetch-and-get-image-data.js
var encodedJs, decodeBase64, blob;
var init_fetch_and_get_image_data = __esm({
  "node_modules/@allmaps/render/dist/workers/fetch-and-get-image-data.js"() {
    encodedJs = "LyoqCiAqIEBsaWNlbnNlCiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAKICovCmNvbnN0IHByb3h5TWFya2VyID0gU3ltYm9sKCJDb21saW5rLnByb3h5Iik7CmNvbnN0IGNyZWF0ZUVuZHBvaW50ID0gU3ltYm9sKCJDb21saW5rLmVuZHBvaW50Iik7CmNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbCgiQ29tbGluay5yZWxlYXNlUHJveHkiKTsKY29uc3QgZmluYWxpemVyID0gU3ltYm9sKCJDb21saW5rLmZpbmFsaXplciIpOwpjb25zdCB0aHJvd01hcmtlciA9IFN5bWJvbCgiQ29tbGluay50aHJvd24iKTsKY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAib2JqZWN0IiAmJiB2YWwgIT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gImZ1bmN0aW9uIjsKY29uc3QgcHJveHlUcmFuc2ZlckhhbmRsZXIgPSB7CiAgY2FuSGFuZGxlOiAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIHZhbFtwcm94eU1hcmtlcl0sCiAgc2VyaWFsaXplKG9iaikgewogICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpOwogICAgZXhwb3NlKG9iaiwgcG9ydDEpOwogICAgcmV0dXJuIFtwb3J0MiwgW3BvcnQyXV07CiAgfSwKICBkZXNlcmlhbGl6ZShwb3J0KSB7CiAgICBwb3J0LnN0YXJ0KCk7CiAgICByZXR1cm4gd3JhcChwb3J0KTsKICB9Cn07CmNvbnN0IHRocm93VHJhbnNmZXJIYW5kbGVyID0gewogIGNhbkhhbmRsZTogKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgdGhyb3dNYXJrZXIgaW4gdmFsdWUsCiAgc2VyaWFsaXplKHsgdmFsdWUgfSkgewogICAgbGV0IHNlcmlhbGl6ZWQ7CiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikgewogICAgICBzZXJpYWxpemVkID0gewogICAgICAgIGlzRXJyb3I6IHRydWUsCiAgICAgICAgdmFsdWU6IHsKICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsCiAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lLAogICAgICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrCiAgICAgICAgfQogICAgICB9OwogICAgfSBlbHNlIHsKICAgICAgc2VyaWFsaXplZCA9IHsgaXNFcnJvcjogZmFsc2UsIHZhbHVlIH07CiAgICB9CiAgICByZXR1cm4gW3NlcmlhbGl6ZWQsIFtdXTsKICB9LAogIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHsKICAgIGlmIChzZXJpYWxpemVkLmlzRXJyb3IpIHsKICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3Ioc2VyaWFsaXplZC52YWx1ZS5tZXNzYWdlKSwgc2VyaWFsaXplZC52YWx1ZSk7CiAgICB9CiAgICB0aHJvdyBzZXJpYWxpemVkLnZhbHVlOwogIH0KfTsKY29uc3QgdHJhbnNmZXJIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFsKICBbInByb3h5IiwgcHJveHlUcmFuc2ZlckhhbmRsZXJdLAogIFsidGhyb3ciLCB0aHJvd1RyYW5zZmVySGFuZGxlcl0KXSk7CmZ1bmN0aW9uIGlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgb3JpZ2luKSB7CiAgZm9yIChjb25zdCBhbGxvd2VkT3JpZ2luIG9mIGFsbG93ZWRPcmlnaW5zKSB7CiAgICBpZiAob3JpZ2luID09PSBhbGxvd2VkT3JpZ2luIHx8IGFsbG93ZWRPcmlnaW4gPT09ICIqIikgewogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIGlmIChhbGxvd2VkT3JpZ2luIGluc3RhbmNlb2YgUmVnRXhwICYmIGFsbG93ZWRPcmlnaW4udGVzdChvcmlnaW4pKSB7CiAgICAgIHJldHVybiB0cnVlOwogICAgfQogIH0KICByZXR1cm4gZmFsc2U7Cn0KZnVuY3Rpb24gZXhwb3NlKG9iaiwgZXAgPSBnbG9iYWxUaGlzLCBhbGxvd2VkT3JpZ2lucyA9IFsiKiJdKSB7CiAgZXAuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGZ1bmN0aW9uIGNhbGxiYWNrKGV2KSB7CiAgICBpZiAoIWV2IHx8ICFldi5kYXRhKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICghaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBldi5vcmlnaW4pKSB7CiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBvcmlnaW4gJyR7ZXYub3JpZ2lufScgZm9yIGNvbWxpbmsgcHJveHlgKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgeyBpZCwgdHlwZSwgcGF0aCB9ID0gT2JqZWN0LmFzc2lnbih7IHBhdGg6IFtdIH0sIGV2LmRhdGEpOwogICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7CiAgICBsZXQgcmV0dXJuVmFsdWU7CiAgICB0cnkgewogICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iajIsIHByb3ApID0+IG9iajJbcHJvcF0sIG9iaik7CiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcGF0aC5yZWR1Y2UoKG9iajIsIHByb3ApID0+IG9iajJbcHJvcF0sIG9iaik7CiAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgIGNhc2UgIkdFVCI6CiAgICAgICAgICB7CiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJTRVQiOgogICAgICAgICAgewogICAgICAgICAgICBwYXJlbnRbcGF0aC5zbGljZSgtMSlbMF1dID0gZnJvbVdpcmVWYWx1ZShldi5kYXRhLnZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiQVBQTFkiOgogICAgICAgICAgewogICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlLmFwcGx5KHBhcmVudCwgYXJndW1lbnRMaXN0KTsKICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgIkNPTlNUUlVDVCI6CiAgICAgICAgICB7CiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7CiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcHJveHkodmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiRU5EUE9JTlQiOgogICAgICAgICAgewogICAgICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7CiAgICAgICAgICAgIGV4cG9zZShvYmosIHBvcnQyKTsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cmFuc2Zlcihwb3J0MSwgW3BvcnQxXSk7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJSRUxFQVNFIjoKICAgICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICB9IGNhdGNoICh2YWx1ZSkgewogICAgICByZXR1cm5WYWx1ZSA9IHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTsKICAgIH0KICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkuY2F0Y2goKHZhbHVlKSA9PiB7CiAgICAgIHJldHVybiB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07CiAgICB9KS50aGVuKChyZXR1cm5WYWx1ZTIpID0+IHsKICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyZXR1cm5WYWx1ZTIpOwogICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpOwogICAgICBpZiAodHlwZSA9PT0gIlJFTEVBU0UiKSB7CiAgICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGNhbGxiYWNrKTsKICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTsKICAgICAgICBpZiAoZmluYWxpemVyIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpbmFsaXplcl0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIG9ialtmaW5hbGl6ZXJdKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsKICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZSh7CiAgICAgICAgdmFsdWU6IG5ldyBUeXBlRXJyb3IoIlVuc2VyaWFsaXphYmxlIHJldHVybiB2YWx1ZSIpLAogICAgICAgIFt0aHJvd01hcmtlcl06IDAKICAgICAgfSk7CiAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7CiAgICB9KTsKICB9KTsKICBpZiAoZXAuc3RhcnQpIHsKICAgIGVwLnN0YXJ0KCk7CiAgfQp9CmZ1bmN0aW9uIGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpIHsKICByZXR1cm4gZW5kcG9pbnQuY29uc3RydWN0b3IubmFtZSA9PT0gIk1lc3NhZ2VQb3J0IjsKfQpmdW5jdGlvbiBjbG9zZUVuZFBvaW50KGVuZHBvaW50KSB7CiAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKQogICAgZW5kcG9pbnQuY2xvc2UoKTsKfQpmdW5jdGlvbiB3cmFwKGVwLCB0YXJnZXQpIHsKICBjb25zdCBwZW5kaW5nTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBlcC5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldikgewogICAgY29uc3QgeyBkYXRhIH0gPSBldjsKICAgIGlmICghZGF0YSB8fCAhZGF0YS5pZCkgewogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCByZXNvbHZlciA9IHBlbmRpbmdMaXN0ZW5lcnMuZ2V0KGRhdGEuaWQpOwogICAgaWYgKCFyZXNvbHZlcikgewogICAgICByZXR1cm47CiAgICB9CiAgICB0cnkgewogICAgICByZXNvbHZlcihkYXRhKTsKICAgIH0gZmluYWxseSB7CiAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuZGVsZXRlKGRhdGEuaWQpOwogICAgfQogIH0pOwogIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgW10sIHRhcmdldCk7Cn0KZnVuY3Rpb24gdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNSZWxlYXNlZCkgewogIGlmIChpc1JlbGVhc2VkKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZSIpOwogIH0KfQpmdW5jdGlvbiByZWxlYXNlRW5kcG9pbnQoZXApIHsKICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgewogICAgdHlwZTogIlJFTEVBU0UiCiAgfSkudGhlbigoKSA9PiB7CiAgICBjbG9zZUVuZFBvaW50KGVwKTsKICB9KTsKfQpjb25zdCBwcm94eUNvdW50ZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTsKY29uc3QgcHJveHlGaW5hbGl6ZXJzID0gIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiBpbiBnbG9iYWxUaGlzICYmIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoZXApID0+IHsKICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSAtIDE7CiAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpOwogIGlmIChuZXdDb3VudCA9PT0gMCkgewogICAgcmVsZWFzZUVuZHBvaW50KGVwKTsKICB9Cn0pOwpmdW5jdGlvbiByZWdpc3RlclByb3h5KHByb3h5MiwgZXApIHsKICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSArIDE7CiAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpOwogIGlmIChwcm94eUZpbmFsaXplcnMpIHsKICAgIHByb3h5RmluYWxpemVycy5yZWdpc3Rlcihwcm94eTIsIGVwLCBwcm94eTIpOwogIH0KfQpmdW5jdGlvbiB1bnJlZ2lzdGVyUHJveHkocHJveHkyKSB7CiAgaWYgKHByb3h5RmluYWxpemVycykgewogICAgcHJveHlGaW5hbGl6ZXJzLnVucmVnaXN0ZXIocHJveHkyKTsKICB9Cn0KZnVuY3Rpb24gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHBhdGggPSBbXSwgdGFyZ2V0ID0gZnVuY3Rpb24oKSB7Cn0pIHsKICBsZXQgaXNQcm94eVJlbGVhc2VkID0gZmFsc2U7CiAgY29uc3QgcHJveHkyID0gbmV3IFByb3h5KHRhcmdldCwgewogICAgZ2V0KF90YXJnZXQsIHByb3ApIHsKICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTsKICAgICAgaWYgKHByb3AgPT09IHJlbGVhc2VQcm94eSkgewogICAgICAgIHJldHVybiAoKSA9PiB7CiAgICAgICAgICB1bnJlZ2lzdGVyUHJveHkocHJveHkyKTsKICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7CiAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmNsZWFyKCk7CiAgICAgICAgICBpc1Byb3h5UmVsZWFzZWQgPSB0cnVlOwogICAgICAgIH07CiAgICAgIH0KICAgICAgaWYgKHByb3AgPT09ICJ0aGVuIikgewogICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gcHJveHkyIH07CiAgICAgICAgfQogICAgICAgIGNvbnN0IHIgPSByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgICB0eXBlOiAiR0VUIiwKICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpCiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgICAgICByZXR1cm4gci50aGVuLmJpbmQocik7CiAgICAgIH0KICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBbLi4ucGF0aCwgcHJvcF0pOwogICAgfSwKICAgIHNldChfdGFyZ2V0LCBwcm9wLCByYXdWYWx1ZSkgewogICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpOwogICAgICBjb25zdCBbdmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmF3VmFsdWUpOwogICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgewogICAgICAgIHR5cGU6ICJTRVQiLAogICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksCiAgICAgICAgdmFsdWUKICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgIH0sCiAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgcmF3QXJndW1lbnRMaXN0KSB7CiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7CiAgICAgIGNvbnN0IGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07CiAgICAgIGlmIChsYXN0ID09PSBjcmVhdGVFbmRwb2ludCkgewogICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgICB0eXBlOiAiRU5EUE9JTlQiCiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgICAgfQogICAgICBpZiAobGFzdCA9PT0gImJpbmQiKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBwYXRoLnNsaWNlKDAsIC0xKSk7CiAgICAgIH0KICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7CiAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgdHlwZTogIkFQUExZIiwKICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSwKICAgICAgICBhcmd1bWVudExpc3QKICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgIH0sCiAgICBjb25zdHJ1Y3QoX3RhcmdldCwgcmF3QXJndW1lbnRMaXN0KSB7CiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7CiAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpOwogICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgewogICAgICAgIHR5cGU6ICJDT05TVFJVQ1QiLAogICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLAogICAgICAgIGFyZ3VtZW50TGlzdAogICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpOwogICAgfQogIH0pOwogIHJlZ2lzdGVyUHJveHkocHJveHkyLCBlcCk7CiAgcmV0dXJuIHByb3h5MjsKfQpmdW5jdGlvbiBteUZsYXQoYXJyKSB7CiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7Cn0KZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3QpIHsKICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTsKICByZXR1cm4gW3Byb2Nlc3NlZC5tYXAoKHYpID0+IHZbMF0pLCBteUZsYXQocHJvY2Vzc2VkLm1hcCgodikgPT4gdlsxXSkpXTsKfQpjb25zdCB0cmFuc2ZlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7CmZ1bmN0aW9uIHRyYW5zZmVyKG9iaiwgdHJhbnNmZXJzKSB7CiAgdHJhbnNmZXJDYWNoZS5zZXQob2JqLCB0cmFuc2ZlcnMpOwogIHJldHVybiBvYmo7Cn0KZnVuY3Rpb24gcHJveHkob2JqKSB7CiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCB7IFtwcm94eU1hcmtlcl06IHRydWUgfSk7Cn0KZnVuY3Rpb24gdG9XaXJlVmFsdWUodmFsdWUpIHsKICBmb3IgKGNvbnN0IFtuYW1lLCBoYW5kbGVyXSBvZiB0cmFuc2ZlckhhbmRsZXJzKSB7CiAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodmFsdWUpKSB7CiAgICAgIGNvbnN0IFtzZXJpYWxpemVkVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gaGFuZGxlci5zZXJpYWxpemUodmFsdWUpOwogICAgICByZXR1cm4gWwogICAgICAgIHsKICAgICAgICAgIHR5cGU6ICJIQU5ETEVSIiwKICAgICAgICAgIG5hbWUsCiAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFZhbHVlCiAgICAgICAgfSwKICAgICAgICB0cmFuc2ZlcmFibGVzCiAgICAgIF07CiAgICB9CiAgfQogIHJldHVybiBbCiAgICB7CiAgICAgIHR5cGU6ICJSQVciLAogICAgICB2YWx1ZQogICAgfSwKICAgIHRyYW5zZmVyQ2FjaGUuZ2V0KHZhbHVlKSB8fCBbXQogIF07Cn0KZnVuY3Rpb24gZnJvbVdpcmVWYWx1ZSh2YWx1ZSkgewogIHN3aXRjaCAodmFsdWUudHlwZSkgewogICAgY2FzZSAiSEFORExFUiI6CiAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7CiAgICBjYXNlICJSQVciOgogICAgICByZXR1cm4gdmFsdWUudmFsdWU7CiAgfQp9CmZ1bmN0aW9uIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIG1zZywgdHJhbnNmZXJzKSB7CiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpOwogICAgcGVuZGluZ0xpc3RlbmVycy5zZXQoaWQsIHJlc29sdmUpOwogICAgaWYgKGVwLnN0YXJ0KSB7CiAgICAgIGVwLnN0YXJ0KCk7CiAgICB9CiAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKHsgaWQgfSwgbXNnKSwgdHJhbnNmZXJzKTsKICB9KTsKfQpmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7CiAgcmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKDApLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikudG9TdHJpbmcoMTYpKS5qb2luKCItIik7Cn0KYXN5bmMgZnVuY3Rpb24gZmV0Y2hVcmwoaW5wdXQsIGluaXQsIGZldGNoRm4pIHsKICBsZXQgcmVzcG9uc2U7CiAgaWYgKHR5cGVvZiBmZXRjaEZuID09PSAiZnVuY3Rpb24iKSB7CiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoRm4oaW5wdXQsIGluaXQpOwogIH0gZWxzZSB7CiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKGlucHV0LCBpbml0KTsKICB9CiAgaWYgKCFyZXNwb25zZS5vaykgewogICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTsKICAgIGlmIChqc29uICYmIGpzb24uZXJyb3IpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKGpzb24uZXJyb3IpOwogICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNUZXh0KSB7CiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTsKICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgZm91bmQ6ICR7aW5wdXR9ICg0MDQpYCk7CiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAwKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiSW50ZXJuYWwgc2VydmVyIGVycm9yICg1MDApIik7CiAgICB9IGVsc2UgewogICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaDogJHtpbnB1dH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSlgKTsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3BvbnNlOwp9CmNvbnN0IGZldGNoQW5kR2V0SW1hZ2VEYXRhV29ya2VyID0gewogIGFzeW5jIGdldEltYWdlRGF0YSh0aWxlVXJsLCBvbkFib3J0LCBmZXRjaEZuLCB3aWR0aCwgaGVpZ2h0KSB7CiAgICBjb25zdCB3b3JrZXJBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7CiAgICBvbkFib3J0KCk7CiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoVXJsKAogICAgICB0aWxlVXJsLAogICAgICB7CiAgICAgICAgc2lnbmFsOiB3b3JrZXJBYm9ydENvbnRyb2xsZXIuc2lnbmFsCiAgICAgIH0sCiAgICAgIGZldGNoRm4KICAgICk7CiAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpOwogICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7CiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICBpZiAoIWNvbnRleHQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJDb3VsZCBub3QgY3JlYXRlIE9mZnNjcmVlbkNhbnZhcyBjb250ZXh0Iik7CiAgICB9CiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZUJpdG1hcCwgMCwgMCk7CiAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgIHJldHVybiB0cmFuc2ZlcihpbWFnZURhdGEsIFtpbWFnZURhdGEuZGF0YS5idWZmZXJdKTsKICB9Cn07CmV4cG9zZShmZXRjaEFuZEdldEltYWdlRGF0YVdvcmtlcik7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLWFuZC1nZXQtaW1hZ2UtZGF0YS1CQzRZc0lHNy5qcy5tYXAK";
    decodeBase64 = (base64) => Uint8Array.from(atob(base64), (c6) => c6.charCodeAt(0));
    blob = typeof self !== "undefined" && self.Blob && new Blob(["URL.revokeObjectURL(import.meta.url);", decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
  }
});

// node_modules/@allmaps/render/dist/renderers/WebGL2Renderer.js
var SIGNIFICANT_VIEWPORT_EPSILON;
var init_WebGL2Renderer = __esm({
  "node_modules/@allmaps/render/dist/renderers/WebGL2Renderer.js"() {
    init_dist();
    init_dist2();
    init_dist3();
    init_BaseRenderer();
    init_WebGL2WarpedMap();
    init_CacheableWorkerImageDataTile();
    init_events2();
    init_homogeneous_transform();
    init_webgl2();
    init_Viewport();
    init_vertex_shader_glsl();
    init_fragment_shader_glsl();
    init_vertex_shader_glsl2();
    init_fragment_shader_glsl2();
    init_vertex_shader_glsl3();
    init_fragment_shader_glsl3();
    init_fetch_and_get_image_data();
    SIGNIFICANT_VIEWPORT_EPSILON = 100 * Number.EPSILON;
  }
});

// node_modules/@allmaps/render/dist/webgl2.js
var init_webgl22 = __esm({
  "node_modules/@allmaps/render/dist/webgl2.js"() {
    init_WebGL2Renderer();
    init_WebGL2WarpedMap();
  }
});

// node_modules/@allmaps/render/dist/index.js
var init_dist9 = __esm({
  "node_modules/@allmaps/render/dist/index.js"() {
    init_Viewport();
    init_WarpedMapList();
    init_WarpedMap();
    init_TriangulatedWarpedMap();
    init_events2();
  }
});

// node_modules/@allmaps/openlayers/dist/OLWarpedMapEvent.js
var init_OLWarpedMapEvent = __esm({
  "node_modules/@allmaps/openlayers/dist/OLWarpedMapEvent.js"() {
  }
});

// node_modules/@allmaps/openlayers/dist/WarpedMapLayer.js
var init_WarpedMapLayer = __esm({
  "node_modules/@allmaps/openlayers/dist/WarpedMapLayer.js"() {
    init_webgl22();
    init_dist9();
    init_dist();
    init_OLWarpedMapEvent();
  }
});

// node_modules/@allmaps/openlayers/dist/index.js
var init_dist10 = __esm({
  "node_modules/@allmaps/openlayers/dist/index.js"() {
    init_WarpedMapLayer();
    init_OLWarpedMapEvent();
    init_dist9();
  }
});

// node_modules/ol/style/IconImageCache.js
function getCacheKey2(src, crossOrigin, color) {
  const colorString = color ? asArray(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var IconImageCache, shared;
var init_IconImageCache = __esm({
  "node_modules/ol/style/IconImageCache.js"() {
    init_ImageState();
    init_color();
    init_dom();
    IconImageCache = class {
      constructor() {
        this.cache_ = {};
        this.patternCache_ = {};
        this.cacheSize_ = 0;
        this.maxCacheSize_ = 1024;
      }
      /**
       * FIXME empty description for jsdoc
       */
      clear() {
        this.cache_ = {};
        this.patternCache_ = {};
        this.cacheSize_ = 0;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
      }
      /**
       * FIXME empty description for jsdoc
       */
      expire() {
        if (this.canExpireCache()) {
          let i4 = 0;
          for (const key in this.cache_) {
            const iconImage = this.cache_[key];
            if ((i4++ & 3) === 0 && !iconImage.hasListener()) {
              delete this.cache_[key];
              delete this.patternCache_[key];
              --this.cacheSize_;
            }
          }
        }
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */
      get(src, crossOrigin, color) {
        const key = getCacheKey2(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @return {CanvasPattern} Icon image.
       */
      getPattern(src, crossOrigin, color) {
        const key = getCacheKey2(src, crossOrigin, color);
        return key in this.patternCache_ ? this.patternCache_[key] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @param {import("./IconImage.js").default|null} iconImage Icon image.
       * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
       */
      set(src, crossOrigin, color, iconImage, pattern) {
        const key = getCacheKey2(src, crossOrigin, color);
        const update = key in this.cache_;
        this.cache_[key] = iconImage;
        if (pattern) {
          if (iconImage.getImageState() === ImageState_default.IDLE) {
            iconImage.load();
          }
          if (iconImage.getImageState() === ImageState_default.LOADING) {
            iconImage.ready().then(() => {
              this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
                iconImage.getImage(1),
                "repeat"
              );
            });
          } else {
            this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
              iconImage.getImage(1),
              "repeat"
            );
          }
        }
        if (!update) {
          ++this.cacheSize_;
        }
      }
      /**
       * Set the cache size of the icon cache. Default is `1024`. Change this value when
       * your map uses more than 1024 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */
      setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
      }
    };
    shared = new IconImageCache();
  }
});

// node_modules/ol/style/IconImage.js
function get5(image, cacheKey, crossOrigin, imageState, color, pattern) {
  let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image && "src" in image ? image.src || void 0 : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  if (pattern && iconImage && !shared.getPattern(cacheKey, crossOrigin, color)) {
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  return iconImage;
}
var taintedTestContext, IconImage, IconImage_default;
var init_IconImage = __esm({
  "node_modules/ol/style/IconImage.js"() {
    init_Image();
    init_ImageState();
    init_color();
    init_dom();
    init_EventType();
    init_Target();
    init_IconImageCache();
    taintedTestContext = null;
    IconImage = class extends Target_default {
      /**
       * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
       * @param {string|undefined} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../ImageState.js").default|undefined} imageState Image state.
       * @param {import("../color.js").Color|string|null} color Color.
       */
      constructor(image, src, crossOrigin, imageState, color) {
        super();
        this.hitDetectionImage_ = null;
        this.image_ = image;
        this.crossOrigin_ = crossOrigin;
        this.canvas_ = {};
        this.color_ = color;
        this.imageState_ = imageState === void 0 ? ImageState_default.IDLE : imageState;
        this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
        this.src_ = src;
        this.tainted_;
        this.ready_ = null;
      }
      /**
       * @private
       */
      initializeImage_() {
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) {
          this.image_.crossOrigin = this.crossOrigin_;
        }
      }
      /**
       * @private
       * @return {boolean} The image canvas is tainted.
       */
      isTainted_() {
        if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
          if (!taintedTestContext) {
            taintedTestContext = createCanvasContext2D(1, 1, void 0, {
              willReadFrequently: true
            });
          }
          taintedTestContext.drawImage(this.image_, 0, 0);
          try {
            taintedTestContext.getImageData(0, 0, 1, 1);
            this.tainted_ = false;
          } catch {
            taintedTestContext = null;
            this.tainted_ = true;
          }
        }
        return this.tainted_ === true;
      }
      /**
       * @private
       */
      dispatchChangeEvent_() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * @private
       */
      handleImageError_() {
        this.imageState_ = ImageState_default.ERROR;
        this.dispatchChangeEvent_();
      }
      /**
       * @private
       */
      handleImageLoad_() {
        this.imageState_ = ImageState_default.LOADED;
        this.size_ = [this.image_.width, this.image_.height];
        this.dispatchChangeEvent_();
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
       */
      getImage(pixelRatio) {
        if (!this.image_) {
          this.initializeImage_();
        }
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Image or Canvas element.
       */
      getPixelRatio(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       */
      getHitDetectionImage() {
        if (!this.image_) {
          this.initializeImage_();
        }
        if (!this.hitDetectionImage_) {
          if (this.isTainted_()) {
            const width = this.size_[0];
            const height = this.size_[1];
            const context = createCanvasContext2D(width, height);
            context.fillRect(0, 0, width, height);
            this.hitDetectionImage_ = context.canvas;
          } else {
            this.hitDetectionImage_ = this.image_;
          }
        }
        return this.hitDetectionImage_;
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       */
      getSize() {
        return this.size_;
      }
      /**
       * @return {string|undefined} Image src.
       */
      getSrc() {
        return this.src_;
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
        if (this.imageState_ !== ImageState_default.IDLE) {
          return;
        }
        if (!this.image_) {
          this.initializeImage_();
        }
        this.imageState_ = ImageState_default.LOADING;
        try {
          if (this.src_ !== void 0) {
            this.image_.src = this.src_;
          }
        } catch {
          this.handleImageError_();
        }
        if (this.image_ instanceof HTMLImageElement) {
          decodeFallback(this.image_, this.src_).then((image) => {
            this.image_ = image;
            this.handleImageLoad_();
          }).catch(this.handleImageError_.bind(this));
        }
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @private
       */
      replaceColor_(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
          return;
        }
        const image = this.image_;
        const ctx = createCanvasContext2D(
          Math.ceil(image.width * pixelRatio),
          Math.ceil(image.height * pixelRatio)
        );
        const canvas = ctx.canvas;
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(image, 0, 0);
        ctx.globalCompositeOperation = "multiply";
        ctx.fillStyle = asString(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(image, 0, 0);
        this.canvas_[pixelRatio] = canvas;
      }
      /**
       * @return {Promise<void>} Promise that resolves when the image is loaded.
       */
      ready() {
        if (!this.ready_) {
          this.ready_ = new Promise((resolve) => {
            if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
              resolve();
            } else {
              const onChange = () => {
                if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
                  this.removeEventListener(EventType_default.CHANGE, onChange);
                  resolve();
                }
              };
              this.addEventListener(EventType_default.CHANGE, onChange);
            }
          });
        }
        return this.ready_;
      }
    };
    IconImage_default = IconImage;
  }
});

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (!color) {
    return null;
  }
  if (Array.isArray(color)) {
    return toString2(color);
  }
  if (typeof color === "object" && "src" in color) {
    return asCanvasPattern(color);
  }
  return color;
}
function asCanvasPattern(pattern) {
  if (!pattern.offset || !pattern.size) {
    return shared.getPattern(pattern.src, "anonymous", pattern.color);
  }
  const cacheKey = pattern.src + ":" + pattern.offset;
  const canvasPattern = shared.getPattern(
    cacheKey,
    void 0,
    pattern.color
  );
  if (canvasPattern) {
    return canvasPattern;
  }
  const iconImage = shared.get(pattern.src, "anonymous", null);
  if (iconImage.getImageState() !== ImageState_default.LOADED) {
    return null;
  }
  const patternCanvasContext = createCanvasContext2D(
    pattern.size[0],
    pattern.size[1]
  );
  patternCanvasContext.drawImage(
    iconImage.getImage(1),
    pattern.offset[0],
    pattern.offset[1],
    pattern.size[0],
    pattern.size[1],
    0,
    0,
    pattern.size[0],
    pattern.size[1]
  );
  get5(
    patternCanvasContext.canvas,
    cacheKey,
    void 0,
    ImageState_default.LOADED,
    pattern.color,
    true
  );
  return shared.getPattern(cacheKey, void 0, pattern.color);
}
var init_colorlike = __esm({
  "node_modules/ol/colorlike.js"() {
    init_ImageState();
    init_color();
    init_dom();
    init_IconImage();
    init_IconImageCache();
  }
});

// node_modules/ol/render/canvas.js
var defaultFillStyle, defaultLineCap, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultLineWidth, checkedFonts;
var init_canvas2 = __esm({
  "node_modules/ol/render/canvas.js"() {
    init_Object();
    defaultFillStyle = "#000";
    defaultLineCap = "round";
    defaultLineJoin = "round";
    defaultMiterLimit = 10;
    defaultStrokeStyle = "#000";
    defaultLineWidth = 1;
    checkedFonts = new Object_default();
  }
});

// node_modules/ol/style/Image.js
var ImageStyle, Image_default;
var init_Image2 = __esm({
  "node_modules/ol/style/Image.js"() {
    init_size();
    init_util();
    ImageStyle = class _ImageStyle {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        this.opacity_ = options.opacity;
        this.rotateWithView_ = options.rotateWithView;
        this.rotation_ = options.rotation;
        this.scale_ = options.scale;
        this.scaleArray_ = toSize(options.scale);
        this.displacement_ = options.displacement;
        this.declutterMode_ = options.declutterMode;
      }
      /**
       * Clones the style.
       * @return {ImageStyle} The cloned style.
       * @api
       */
      clone() {
        const scale4 = this.getScale();
        return new _ImageStyle({
          opacity: this.getOpacity(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the symbolizer opacity.
       * @return {number} Opacity.
       * @api
       */
      getOpacity() {
        return this.opacity_;
      }
      /**
       * Determine whether the symbolizer rotates with the map.
       * @return {boolean} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Get the symoblizer rotation.
       * @return {number} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the symbolizer scale.
       * @return {number|import("../size.js").Size} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the displacement of the shape
       * @return {Array<number>} Shape's center displacement
       * @api
       */
      getDisplacement() {
        return this.displacement_;
      }
      /**
       * Get the declutter mode of the shape
       * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
       * @api
       */
      getDeclutterMode() {
        return this.declutterMode_;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @abstract
       * @return {Array<number>} Anchor.
       */
      getAnchor() {
        return abstract();
      }
      /**
       * Get the image element for the symbolizer.
       * @abstract
       * @param {number} pixelRatio Pixel ratio.
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getImage(pixelRatio) {
        return abstract();
      }
      /**
       * @abstract
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getHitDetectionImage() {
        return abstract();
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       */
      getPixelRatio(pixelRatio) {
        return 1;
      }
      /**
       * @abstract
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return abstract();
      }
      /**
       * @abstract
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return abstract();
      }
      /**
       * Get the origin of the symbolizer.
       * @abstract
       * @return {Array<number>} Origin.
       */
      getOrigin() {
        return abstract();
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @abstract
       * @return {import("../size.js").Size} Size.
       */
      getSize() {
        return abstract();
      }
      /**
       * Set the displacement.
       *
       * @param {Array<number>} displacement Displacement.
       * @api
       */
      setDisplacement(displacement) {
        this.displacement_ = displacement;
      }
      /**
       * Set the opacity.
       *
       * @param {number} opacity Opacity.
       * @api
       */
      setOpacity(opacity) {
        this.opacity_ = opacity;
      }
      /**
       * Set whether to rotate the style with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set the rotation.
       *
       * @param {number} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      setScale(scale4) {
        this.scale_ = scale4;
        this.scaleArray_ = toSize(scale4);
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
        abstract();
      }
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      load() {
        abstract();
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
        abstract();
      }
      /**
       * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
       */
      ready() {
        return Promise.resolve();
      }
    };
    Image_default = ImageStyle;
  }
});

// node_modules/ol/style/RegularShape.js
var RegularShape, RegularShape_default;
var init_RegularShape = __esm({
  "node_modules/ol/style/RegularShape.js"() {
    init_ImageState();
    init_color();
    init_colorlike();
    init_dom();
    init_canvas2();
    init_IconImage();
    init_IconImageCache();
    init_Image2();
    RegularShape = class _RegularShape extends Image_default {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        super({
          opacity: 1,
          rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          scale: options.scale !== void 0 ? options.scale : 1,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
        this.hitDetectionCanvas_ = null;
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.origin_ = [0, 0];
        this.points_ = options.points;
        this.radius = options.radius;
        this.radius2_ = options.radius2;
        this.angle_ = options.angle !== void 0 ? options.angle : 0;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.size_;
        this.renderOptions_;
        this.imageState_ = this.fill_ && this.fill_.loading() ? ImageState_default.LOADING : ImageState_default.LOADED;
        if (this.imageState_ === ImageState_default.LOADING) {
          this.ready().then(() => this.imageState_ = ImageState_default.LOADED);
        }
        this.render();
      }
      /**
       * Clones the style.
       * @return {RegularShape} The cloned style.
       * @api
       * @override
       */
      clone() {
        const scale4 = this.getScale();
        const style = new _RegularShape({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          points: this.getPoints(),
          radius: this.getRadius(),
          radius2: this.getRadius2(),
          angle: this.getAngle(),
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       * @override
       */
      getAnchor() {
        const size = this.size_;
        const displacement = this.getDisplacement();
        const scale4 = this.getScaleArray();
        return [
          size[0] / 2 - displacement[0] / scale4[0],
          size[1] / 2 + displacement[1] / scale4[1]
        ];
      }
      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      getAngle() {
        return this.angle_;
      }
      /**
       * Get the fill style for the shape.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
        this.render();
      }
      /**
       * @return {HTMLCanvasElement} Image element.
       * @override
       */
      getHitDetectionImage() {
        if (!this.hitDetectionCanvas_) {
          this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
            this.renderOptions_
          );
        }
        return this.hitDetectionCanvas_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement} Image or Canvas element.
       * @api
       * @override
       */
      getImage(pixelRatio) {
        const fillKey = this.fill_?.getKey();
        const cacheKey = `${pixelRatio},${this.angle_},${this.radius},${this.radius2_},${this.points_},${fillKey}` + Object.values(this.renderOptions_).join(",");
        let image = (
          /** @type {HTMLCanvasElement} */
          shared.get(cacheKey, null, null)?.getImage(1)
        );
        if (!image) {
          const renderOptions = this.renderOptions_;
          const size = Math.ceil(renderOptions.size * pixelRatio);
          const context = createCanvasContext2D(size, size);
          this.draw_(renderOptions, context, pixelRatio);
          image = context.canvas;
          shared.set(
            cacheKey,
            null,
            null,
            new IconImage_default(image, void 0, null, ImageState_default.LOADED, null)
          );
        }
        return image;
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       * @override
       */
      getPixelRatio(pixelRatio) {
        return pixelRatio;
      }
      /**
       * @return {import("../size.js").Size} Image size.
       * @override
       */
      getImageSize() {
        return this.size_;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       * @override
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       * @override
       */
      getOrigin() {
        return this.origin_;
      }
      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      getPoints() {
        return this.points_;
      }
      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      getRadius() {
        return this.radius;
      }
      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      getRadius2() {
        return this.radius2_;
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @return {import("../size.js").Size} Size.
       * @api
       * @override
       */
      getSize() {
        return this.size_;
      }
      /**
       * Get the stroke style for the shape.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
        this.render();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       * @override
       */
      listenImageChange(listener) {
      }
      /**
       * Load not yet loaded URI.
       * @override
       */
      load() {
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       * @override
       */
      unlistenImageChange(listener) {
      }
      /**
       * Calculate additional canvas size needed for the miter.
       * @param {string} lineJoin Line join
       * @param {number} strokeWidth Stroke width
       * @param {number} miterLimit Miter limit
       * @return {number} Additional canvas size needed
       * @private
       */
      calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
          return strokeWidth;
        }
        let r1 = this.radius;
        let r23 = this.radius2_ === void 0 ? r1 : this.radius2_;
        if (r1 < r23) {
          const tmp = r1;
          r1 = r23;
          r23 = tmp;
        }
        const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
        const alpha = 2 * Math.PI / points;
        const a4 = r23 * Math.sin(alpha);
        const b5 = Math.sqrt(r23 * r23 - a4 * a4);
        const d2 = r1 - b5;
        const e3 = Math.sqrt(a4 * a4 + d2 * d2);
        const miterRatio = e3 / a4;
        if (lineJoin === "miter" && miterRatio <= miterLimit) {
          return miterRatio * strokeWidth;
        }
        const k2 = strokeWidth / 2 / miterRatio;
        const l5 = strokeWidth / 2 * (d2 / e3);
        const maxr = Math.sqrt((r1 + k2) * (r1 + k2) + l5 * l5);
        const bevelAdd = maxr - r1;
        if (this.radius2_ === void 0 || lineJoin === "bevel") {
          return bevelAdd * 2;
        }
        const aa2 = r1 * Math.sin(alpha);
        const bb2 = Math.sqrt(r1 * r1 - aa2 * aa2);
        const dd = r23 - bb2;
        const ee3 = Math.sqrt(aa2 * aa2 + dd * dd);
        const innerMiterRatio = ee3 / aa2;
        if (innerMiterRatio <= miterLimit) {
          const innerLength = innerMiterRatio * strokeWidth / 2 - r23 - r1;
          return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
      }
      /**
       * @return {RenderOptions}  The render options
       * @protected
       */
      createRenderOptions() {
        let lineCap = defaultLineCap;
        let lineJoin = defaultLineJoin;
        let miterLimit = 0;
        let lineDash = null;
        let lineDashOffset = 0;
        let strokeStyle;
        let strokeWidth = 0;
        if (this.stroke_) {
          strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);
          strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;
          lineDash = this.stroke_.getLineDash();
          lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
          lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;
          lineCap = this.stroke_.getLineCap() ?? defaultLineCap;
          miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;
        }
        const add5 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        const maxRadius = Math.max(this.radius, this.radius2_ || 0);
        const size = Math.ceil(2 * maxRadius + add5);
        return {
          strokeStyle,
          strokeWidth,
          size,
          lineCap,
          lineDash,
          lineDashOffset,
          lineJoin,
          miterLimit
        };
      }
      /**
       * @protected
       */
      render() {
        this.renderOptions_ = this.createRenderOptions();
        const size = this.renderOptions_.size;
        this.hitDetectionCanvas_ = null;
        this.size_ = [size, size];
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} pixelRatio The pixel ratio.
       */
      draw_(renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
          let color = this.fill_.getColor();
          if (color === null) {
            color = defaultFillStyle;
          }
          context.fillStyle = asColorLike(color);
          context.fill();
        }
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineCap = renderOptions.lineCap;
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @return {HTMLCanvasElement} Canvas containing the icon
       */
      createHitDetectionCanvas_(renderOptions) {
        let context;
        if (this.fill_) {
          let color = this.fill_.getColor();
          let opacity = 0;
          if (typeof color === "string") {
            color = asArray(color);
          }
          if (color === null) {
            opacity = 1;
          } else if (Array.isArray(color)) {
            opacity = color.length === 4 ? color[3] : 1;
          }
          if (opacity === 0) {
            context = createCanvasContext2D(renderOptions.size, renderOptions.size);
            this.drawHitDetectionCanvas_(renderOptions, context);
          }
        }
        return context ? context.canvas : this.getImage(1);
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context The context to draw in.
       */
      createPath_(context) {
        let points = this.points_;
        const radius = this.radius;
        if (points === Infinity) {
          context.arc(0, 0, radius, 0, 2 * Math.PI);
        } else {
          const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
          if (this.radius2_ !== void 0) {
            points *= 2;
          }
          const startAngle = this.angle_ - Math.PI / 2;
          const step = 2 * Math.PI / points;
          for (let i4 = 0; i4 < points; i4++) {
            const angle0 = startAngle + i4 * step;
            const radiusC = i4 % 2 === 0 ? radius : radius2;
            context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
          }
          context.closePath();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       */
      drawHitDetectionCanvas_(renderOptions, context) {
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = defaultFillStyle;
        context.fill();
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
      /**
       * @override
       */
      ready() {
        return this.fill_ ? this.fill_.ready() : Promise.resolve();
      }
    };
    RegularShape_default = RegularShape;
  }
});

// node_modules/ol/style/Circle.js
var CircleStyle, Circle_default;
var init_Circle = __esm({
  "node_modules/ol/style/Circle.js"() {
    init_RegularShape();
    CircleStyle = class _CircleStyle extends RegularShape_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options ? options : { radius: 5 };
        super({
          points: Infinity,
          fill: options.fill,
          radius: options.radius,
          stroke: options.stroke,
          scale: options.scale !== void 0 ? options.scale : 1,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
      }
      /**
       * Clones the style.
       * @return {CircleStyle} The cloned style.
       * @api
       * @override
       */
      clone() {
        const scale4 = this.getScale();
        const style = new _CircleStyle({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          radius: this.getRadius(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Set the circle radius.
       *
       * @param {number} radius Circle radius.
       * @api
       */
      setRadius(radius) {
        this.radius = radius;
        this.render();
      }
    };
    Circle_default = CircleStyle;
  }
});

// node_modules/ol/style/Fill.js
var Fill, Fill_default;
var init_Fill = __esm({
  "node_modules/ol/style/Fill.js"() {
    init_ImageState();
    init_color();
    init_util();
    init_IconImage();
    Fill = class _Fill {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.patternImage_ = null;
        this.color_ = null;
        if (options.color !== void 0) {
          this.setColor(options.color);
        }
      }
      /**
       * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
       * @return {Fill} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Fill({
          color: Array.isArray(color) ? color.slice() : color || void 0
        });
      }
      /**
       * Get the fill color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
       * @api
       */
      setColor(color) {
        if (color !== null && typeof color === "object" && "src" in color) {
          const patternImage = get5(
            null,
            color.src,
            "anonymous",
            void 0,
            color.offset ? null : color.color ? color.color : null,
            !(color.offset && color.size)
          );
          patternImage.ready().then(() => {
            this.patternImage_ = null;
          });
          if (patternImage.getImageState() === ImageState_default.IDLE) {
            patternImage.load();
          }
          if (patternImage.getImageState() === ImageState_default.LOADING) {
            this.patternImage_ = patternImage;
          }
        }
        this.color_ = color;
      }
      /**
       * @return {string} Key of the fill for cache lookup.
       */
      getKey() {
        const fill = this.getColor();
        if (!fill) {
          return "";
        }
        return fill instanceof CanvasPattern || fill instanceof CanvasGradient ? getUid(fill) : typeof fill === "object" && "src" in fill ? fill.src + ":" + fill.offset : asArray(fill).toString();
      }
      /**
       * @return {boolean} The fill style is loading an image pattern.
       */
      loading() {
        return !!this.patternImage_;
      }
      /**
       * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
       */
      ready() {
        return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
      }
    };
    Fill_default = Fill;
  }
});

// node_modules/ol/style/Stroke.js
var Stroke, Stroke_default;
var init_Stroke = __esm({
  "node_modules/ol/style/Stroke.js"() {
    Stroke = class _Stroke {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.color_ = options.color !== void 0 ? options.color : null;
        this.lineCap_ = options.lineCap;
        this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
        this.lineDashOffset_ = options.lineDashOffset;
        this.lineJoin_ = options.lineJoin;
        this.miterLimit_ = options.miterLimit;
        this.width_ = options.width;
      }
      /**
       * Clones the style.
       * @return {Stroke} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Stroke({
          color: Array.isArray(color) ? color.slice() : color || void 0,
          lineCap: this.getLineCap(),
          lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
          lineDashOffset: this.getLineDashOffset(),
          lineJoin: this.getLineJoin(),
          miterLimit: this.getMiterLimit(),
          width: this.getWidth()
        });
      }
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */
      getLineCap() {
        return this.lineCap_;
      }
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>|null} Line dash.
       * @api
       */
      getLineDash() {
        return this.lineDash_;
      }
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */
      getLineDashOffset() {
        return this.lineDashOffset_;
      }
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */
      getLineJoin() {
        return this.lineJoin_;
      }
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */
      getMiterLimit() {
        return this.miterLimit_;
      }
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */
      getWidth() {
        return this.width_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      setColor(color) {
        this.color_ = color;
      }
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */
      setLineCap(lineCap) {
        this.lineCap_ = lineCap;
      }
      /**
       * Set the line dash.
       *
       * @param {Array<number>|null} lineDash Line dash.
       * @api
       */
      setLineDash(lineDash) {
        this.lineDash_ = lineDash;
      }
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */
      setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
      }
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */
      setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
      }
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */
      setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
      }
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */
      setWidth(width) {
        this.width_ = width;
      }
    };
    Stroke_default = Stroke;
  }
});

// node_modules/ol/style/Style.js
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style, Style_default;
var init_Style = __esm({
  "node_modules/ol/style/Style.js"() {
    Style = class _Style {
      /**
       * @param {Options} [options] Style options.
       */
      constructor(options) {
        options = options || {};
        this.geometry_ = null;
        this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== void 0) {
          this.setGeometry(options.geometry);
        }
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.image_ = options.image !== void 0 ? options.image : null;
        this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
        this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.text_ = options.text !== void 0 ? options.text : null;
        this.zIndex_ = options.zIndex;
      }
      /**
       * Clones the style.
       * @return {Style} The cloned style.
       * @api
       */
      clone() {
        let geometry = this.getGeometry();
        if (geometry && typeof geometry === "object") {
          geometry = /** @type {import("../geom/Geometry.js").default} */
          geometry.clone();
        }
        return new _Style({
          geometry: geometry ?? void 0,
          fill: this.getFill() ? this.getFill().clone() : void 0,
          image: this.getImage() ? this.getImage().clone() : void 0,
          renderer: this.getRenderer() ?? void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          text: this.getText() ? this.getText().clone() : void 0,
          zIndex: this.getZIndex()
        });
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setRenderer} or the `renderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getRenderer() {
        return this.renderer_;
      }
      /**
       * Sets a custom renderer function for this style. When set, `fill`, `stroke`
       * and `image` options of the style will be ignored.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setRenderer(renderer) {
        this.renderer_ = renderer;
      }
      /**
       * Sets a custom renderer function for this style used
       * in hit detection.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setHitDetectionRenderer(renderer) {
        this.hitDetectionRenderer_ = renderer;
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
      }
      /**
       * Get the geometry to be rendered.
       * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
       * Feature property or geometry or function that returns the geometry that will
       * be rendered with this style.
       * @api
       */
      getGeometry() {
        return this.geometry_;
      }
      /**
       * Get the function used to generate a geometry for rendering.
       * @return {!GeometryFunction} Function that is called with a feature
       * and returns the geometry to render instead of the feature's geometry.
       * @api
       */
      getGeometryFunction() {
        return this.geometryFunction_;
      }
      /**
       * Get the fill style.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Get the image style.
       * @return {import("./Image.js").default|null} Image style.
       * @api
       */
      getImage() {
        return this.image_;
      }
      /**
       * Set the image style.
       * @param {import("./Image.js").default} image Image style.
       * @api
       */
      setImage(image) {
        this.image_ = image;
      }
      /**
       * Get the stroke style.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Get the text style.
       * @return {import("./Text.js").default|null} Text style.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Set the text style.
       * @param {import("./Text.js").default} text Text style.
       * @api
       */
      setText(text2) {
        this.text_ = text2;
      }
      /**
       * Get the z-index for the style.
       * @return {number|undefined} ZIndex.
       * @api
       */
      getZIndex() {
        return this.zIndex_;
      }
      /**
       * Set a geometry that is rendered instead of the feature's geometry.
       *
       * @param {string|import("../geom/Geometry.js").default|GeometryFunction|null} geometry
       *     Feature property or geometry or function returning a geometry to render
       *     for this style.
       * @api
       */
      setGeometry(geometry) {
        if (typeof geometry === "function") {
          this.geometryFunction_ = geometry;
        } else if (typeof geometry === "string") {
          this.geometryFunction_ = function(feature) {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              feature.get(geometry)
            );
          };
        } else if (!geometry) {
          this.geometryFunction_ = defaultGeometryFunction;
        } else if (geometry !== void 0) {
          this.geometryFunction_ = function() {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              geometry
            );
          };
        }
        this.geometry_ = geometry;
      }
      /**
       * Set the z-index.
       *
       * @param {number|undefined} zIndex ZIndex.
       * @api
       */
      setZIndex(zIndex) {
        this.zIndex_ = zIndex;
      }
    };
    Style_default = Style;
  }
});

// .svelte-kit/output/server/entries/pages/temp-viewer/_page.svelte.js
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => is
});
function Rt3(d2 = Pt3) {
  const { subscribe: n3, update: t3, set: c6 } = z2({ history: [], future: [] });
  return { subscribe: n3, limit: d2, push(o5) {
    t3((u6) => ({ history: [...u6.history.slice(-d2 + 1), o5], future: [] }));
  }, undo() {
    let o5 = null;
    return t3((u6) => u6.history.length ? (o5 = u6.history[u6.history.length - 1], { history: u6.history.slice(0, -1), future: [...u6.future, o5] }) : u6), o5;
  }, redo() {
    let o5 = null;
    return t3((u6) => u6.future.length ? (o5 = u6.future[u6.future.length - 1], { history: [...u6.history, o5], future: u6.future.slice(0, -1) }) : u6), o5;
  }, reset() {
    c6({ history: [], future: [] });
  } };
}
function Vt2(d2, n3) {
  return n3 && d2.some((t3) => t3.id === n3) ? n3 : null;
}
function Bt3() {
  const { subscribe: d2, update: n3, set: t3 } = z2({ list: [], selectedId: null });
  return { subscribe: d2, setList(c6) {
    n3((o5) => ({ list: c6, selectedId: Vt2(c6, o5.selectedId) }));
  }, setSelected(c6) {
    n3((o5) => ({ ...o5, selectedId: c6 }));
  }, clearSelection() {
    n3((c6) => ({ ...c6, selectedId: null }));
  }, clearSelectionIfMatches(c6) {
    c6 && n3((o5) => ({ ...o5, selectedId: o5.selectedId === c6 ? null : o5.selectedId }));
  }, reset() {
    t3({ list: [], selectedId: null });
  } };
}
function jt4(d2) {
  In(Nt4, d2);
}
function Ut4(d2, n3) {
  d2.component((t3) => {
    var c6;
    let o5, u6, I4, N3, j3;
    new GeoJSON_default();
    const dt5 = 100;
    let U4 = nn(n3.initialMode, "explore"), Y4 = nn(n3.showWelcomeOverlay, true), r4 = null, K3 = [], A5 = [], M6 = [], C4 = false, D5 = false, k2 = false, f5 = false, S3 = false, L3 = "g-streets", ht4 = "all", O5 = "", m5 = [], W3 = [], X4 = 0.8, G3 = Y4, z3 = U4, vt3 = false, gt4 = false, rt5 = null, q5;
    const E6 = Rt3(dt5), T4 = Bt3();
    jt4({ history: E6, state: T4 });
    let w3 = [], J3 = null, bt4 = "", F3 = [], ft4 = false, Q4 = [], mt4 = 0, i4 = null, Z5 = null, H5 = null, P6 = null, R6 = null, V4 = null, $4 = [], _3 = "overlay", tt4 = null, b5 = null;
    function yt4(s6) {
      i4 && i4.getLayers().getArray().forEach((e3) => {
        const l5 = e3.getProperties();
        l5.base && e3.setVisible(l5.name === s6);
      });
    }
    function kt4() {
      return Z5?.getCanvas() ?? null;
    }
    function wt4() {
      const s6 = kt4();
      if (!s6 || !i4) return;
      const e3 = i4.getSize();
      if (!e3) return;
      const [l5, a4] = e3;
      s6.style.clipPath = "";
    }
    function St5() {
      if (!i4) return;
      const s6 = i4.getSize();
      if (!s6) return;
      const [e3, l5] = s6;
    }
    function _t3() {
      if (!i4) return;
      const s6 = i4.getSize();
      if (!s6) return;
      const [e3, l5] = s6;
    }
    function st3() {
      wt4(), St5(), _t3();
    }
    function xt4(s6) {
    }
    function et5() {
    }
    function lt5() {
      i4 && (b5 !== null && cancelAnimationFrame(b5), b5 = requestAnimationFrame(() => {
        b5 = null, i4?.updateSize(), st3();
      }));
    }
    function at5(s6) {
      return s6 ? "0px" : "minmax(260px, 0.25fr)";
    }
    function It4(s6, e3) {
      return s6 && e3 ? "1" : s6 || e3 ? 0.75.toString() : 0.5.toString();
    }
    function At4() {
      !i4 || !P6 || (i4.removeInteraction(P6), P6 = null);
    }
    s4(() => {
      tt4?.(), tt4 = null, window.removeEventListener("pointermove", xt4), window.removeEventListener("pointerup", et5), window.removeEventListener("pointercancel", et5), window.removeEventListener("resize", lt5), $4.forEach((s6) => unByKey(s6)), $4 = [], At4(), i4 && R6 && i4.removeInteraction(R6), i4 && V4 && i4.removeInteraction(V4), i4?.setTarget(void 0), i4 = null, Z5 = null, H5 = null, R6 = null, V4 = null, b5 !== null && (cancelAnimationFrame(b5), b5 = null);
    }), o5 = Q4.filter((s6) => !s6.hidden), u6 = Q4[mt4] ?? null, u6 && o5.findIndex((s6) => s6.id === u6.id) + 1, m4.find((s6) => s6.key === L3)?.label, I4 = Math.round(X4 * 100), r4 = m5.find((s6) => s6.id === O5) ?? null, K3 = Array.from(new Set(m5.map((s6) => s6.type || "Uncategorized"))).filter((s6) => s6 && s6.trim().length).sort((s6, e3) => s6.localeCompare(e3)), A5 = (() => {
      const s6 = m5.filter((l5) => l5.isFeatured);
      return (s6.length ? s6 : m5).slice(0, 4);
    })(), W3 = m5, M6 = W3, N3 = rt2(c6 ??= {}, "$annotationHistory", E6).history.length > 0, j3 = rt2(c6 ??= {}, "$annotationHistory", E6).future.length > 0, w3 = rt2(c6 ??= {}, "$annotationState", T4).list, J3 = rt2(c6 ??= {}, "$annotationState", T4).selectedId, G3 && (C4 = false), r4 || (C4 = false), G3 && (D5 = false), z3 !== "create" && (k2 = false, f5 = false, D5 = false, S3 = false), q5 = z3 === "create" ? `grid-template-columns: ${at5(k2)} minmax(0, ${It4(k2, f5)}fr) ${at5(f5)}; gap: 1.2rem; padding: 1.4rem;` : void 0, i4 && lt5(), yt4(L3), st3(), H5 && H5.setVisible(z3 === "create"), t3.push(`<div${lt2("viewer svelte-1gd50sk", void 0, { mobile: vt3, creator: true })}><div class="workspace svelte-1gd50sk"${ft2(q5)}>`);
    {
      if (t3.push("<!--[-->"), k2 ? (t3.push("<!--[-->"), t3.push('<button type="button" class="panel-toggle left svelte-1gd50sk">Show tools</button>')) : t3.push("<!--[!-->"), t3.push("<!--]--> "), k2) t3.push("<!--[!-->");
      else {
        if (t3.push("<!--[-->"), t3.push(`<aside class="creator-panel left svelte-1gd50sk"><button type="button" class="panel-collapse svelte-1gd50sk" aria-expanded="true">Hide tools</button> <div class="panel-scroll custom-scrollbar svelte-1gd50sk"><section class="panel-card svelte-1gd50sk"><header class="panel-card-header svelte-1gd50sk"><h2 class="svelte-1gd50sk">View control</h2></header> <section class="panel-card-section svelte-1gd50sk"><span class="section-title svelte-1gd50sk">View mode</span> <div class="button-group wrap svelte-1gd50sk"><button type="button"${lt2("svelte-1gd50sk", void 0, { selected: _3 === "overlay" })}>Overlay</button> <button type="button"${lt2("svelte-1gd50sk", void 0, { selected: _3 === "side-x" })}>Side-X</button> <button type="button"${lt2("svelte-1gd50sk", void 0, { selected: _3 === "side-y" })}>Side-Y</button> <button type="button"${lt2("svelte-1gd50sk", void 0, { selected: _3 === "spy" })}>Glass</button></div></section> <section class="panel-card-section svelte-1gd50sk"><span class="section-title svelte-1gd50sk">Overlay opacity</span> <div class="slider svelte-1gd50sk"><input type="range" min="0" max="1" step="0.05"${W2("value", X4)} class="svelte-1gd50sk"/> <span>${On(I4)}%</span></div></section></section> <section class="panel-card svelte-1gd50sk"><header class="panel-card-header svelte-1gd50sk"><h2 class="svelte-1gd50sk">Historical maps</h2></header> `), A5.length) {
          t3.push("<!--[-->"), t3.push('<section class="panel-card-section svelte-1gd50sk"><span class="section-title svelte-1gd50sk">Featured</span> <div class="history-featured svelte-1gd50sk"><!--[-->');
          const e3 = Et2(A5);
          for (let l5 = 0, a4 = e3.length; l5 < a4; l5++) {
            let h3 = e3[l5];
            t3.push(`<button type="button"${lt2("history-featured-card svelte-1gd50sk", void 0, { selected: h3.id === O5 })}><span class="history-title svelte-1gd50sk">${On(h3.name)}</span> `), h3.summary ? (t3.push("<!--[-->"), t3.push(`<span class="history-meta svelte-1gd50sk">${On(h3.summary)}</span>`)) : t3.push("<!--[!-->"), t3.push("<!--]--></button>");
          }
          t3.push("<!--]--></div></section>");
        } else t3.push("<!--[!-->");
        if (t3.push('<!--]--> <section class="panel-card-section svelte-1gd50sk"><label class="history-filter svelte-1gd50sk"><span>Filter by type</span> '), t3.select({ value: ht4, class: "" }, (e3) => {
          e3.option({ value: "all" }, (a4) => {
            a4.push(`All maps (${On(m5.length)})`);
          }), e3.push("<!--[-->");
          const l5 = Et2(K3);
          for (let a4 = 0, h3 = l5.length; a4 < h3; a4++) {
            let ot5 = l5[a4];
            e3.option({ value: ot5 }, (Mt5) => {
              Mt5.push(`${On(ot5)}`);
            });
          }
          e3.push("<!--]-->");
        }, "svelte-1gd50sk"), t3.push('</label></section> <div class="history-list custom-scrollbar svelte-1gd50sk">'), M6.length) {
          t3.push("<!--[-->"), t3.push("<!--[-->");
          const e3 = Et2(M6);
          for (let l5 = 0, a4 = e3.length; l5 < a4; l5++) {
            let h3 = e3[l5];
            t3.push(`<button type="button"${lt2("history-item svelte-1gd50sk", void 0, { selected: h3.id === O5 })}><span class="history-title svelte-1gd50sk">${On(h3.name)}</span> <span class="history-meta svelte-1gd50sk">${On(h3.summary || h3.type)}</span></button>`);
          }
          t3.push("<!--]-->");
        } else t3.push("<!--[!-->"), t3.push('<p class="empty-state svelte-1gd50sk">Map catalog is loading\u2026</p>');
        t3.push('<!--]--></div></section> <section class="panel-card svelte-1gd50sk"><header class="panel-card-header svelte-1gd50sk"><h2 class="svelte-1gd50sk">Basemap</h2></header> <section class="panel-card-section svelte-1gd50sk"><div class="button-group wrap svelte-1gd50sk"><!--[-->');
        const s6 = Et2(m4);
        for (let e3 = 0, l5 = s6.length; e3 < l5; e3++) {
          let a4 = s6[e3];
          t3.push(`<button type="button"${lt2("svelte-1gd50sk", void 0, { selected: L3 === a4.key })}>${On(a4.label)}</button>`);
        }
        t3.push("<!--]--></div></section></section></div></aside>");
      }
      t3.push("<!--]-->");
    }
    t3.push(`<!--]--> <div class="map-stage svelte-1gd50sk"><div class="map-surface svelte-1gd50sk"><div class="map svelte-1gd50sk"></div> <div class="divider vertical svelte-1gd50sk" aria-hidden="true"></div> <div class="divider horizontal svelte-1gd50sk" aria-hidden="true"></div> <button class="handle vertical svelte-1gd50sk" type="button" aria-label="Drag vertical split" title="Drag vertical split"></button> <button class="handle horizontal svelte-1gd50sk" type="button" aria-label="Drag horizontal split" title="Drag horizontal split"></button> <div class="lens svelte-1gd50sk" aria-hidden="true"></div> <button class="lens-handle svelte-1gd50sk" type="button" aria-label="Adjust spyglass radius" title="Adjust spyglass radius"></button></div> <div class="creator-toolbar svelte-1gd50sk"><div class="toolbar-cluster svelte-1gd50sk"><button type="button" title="Search places" aria-label="Search places" class="svelte-1gd50sk"><span class="toolbar-icon svelte-1gd50sk">\u{1F50D}</span></button></div> <div class="toolbar-cluster svelte-1gd50sk"><button type="button" title="Pan the map" aria-label="Pan the map"${lt2("svelte-1gd50sk", void 0, { selected: true })}><span class="toolbar-icon svelte-1gd50sk">\u{1F590}</span></button> <div class="toolbar-group svelte-1gd50sk"><button type="button" title="Draw annotations" aria-label="Draw annotations" aria-haspopup="true"${W2("aria-expanded", gt4)}${lt2("svelte-1gd50sk", void 0, { selected: false })}><span class="toolbar-icon svelte-1gd50sk">\u270F\uFE0F</span></button> `), t3.push("<!--[!-->"), t3.push(`<!--]--></div> <button type="button" title="Undo" aria-label="Undo"${W2("disabled", !N3, true)} class="svelte-1gd50sk"><span class="toolbar-icon svelte-1gd50sk">\u21BA</span></button> <button type="button" title="Redo" aria-label="Redo"${W2("disabled", !j3, true)} class="svelte-1gd50sk"><span class="toolbar-icon svelte-1gd50sk">\u21BB</span></button></div> <div class="toolbar-cluster svelte-1gd50sk"><div class="toolbar-group svelte-1gd50sk"><button type="button" title="Settings" aria-label="Settings" aria-haspopup="true"${W2("aria-expanded", S3)}${lt2("svelte-1gd50sk", void 0, { selected: S3 })}><span class="toolbar-icon svelte-1gd50sk">\u2699\uFE0F</span></button> `), S3 ? (t3.push("<!--[-->"), t3.push('<div class="toolbar-menu svelte-1gd50sk"><button type="button" class="svelte-1gd50sk">Clear cached state</button></div>')) : t3.push("<!--[!-->"), t3.push("<!--]--></div></div></div></div> ");
    {
      if (t3.push("<!--[-->"), f5 ? (t3.push("<!--[-->"), t3.push('<button type="button" class="panel-toggle right svelte-1gd50sk">Show panel</button>')) : t3.push("<!--[!-->"), t3.push("<!--]--> "), f5) t3.push("<!--[!-->");
      else {
        if (t3.push("<!--[-->"), t3.push(`<aside class="creator-panel right svelte-1gd50sk"><header class="creator-right-header svelte-1gd50sk"><button type="button" class="panel-collapse svelte-1gd50sk"${W2("aria-expanded", !f5)}>Hide panel</button> <div class="creator-right-controls svelte-1gd50sk"><h2 class="panel-heading svelte-1gd50sk">Annotations</h2> <div class="right-actions svelte-1gd50sk"><button type="button" class="chip ghost"${W2("disabled", !w3.length, true)}>Clear</button> <button type="button" class="chip ghost"${W2("disabled", !w3.length, true)}>Export</button> <label class="chip ghost upload">Import <input type="file" accept="application/geo+json,.geojson,.json"/></label></div></div></header> <div class="creator-right-body custom-scrollbar svelte-1gd50sk">`), t3.push("<!--[!-->"), t3.push("<!--]--> "), w3.length) {
          t3.push("<!--[-->"), t3.push("<!--[-->");
          const s6 = Et2(w3);
          for (let e3 = 0, l5 = s6.length; e3 < l5; e3++) {
            let a4 = s6[e3];
            t3.push(`<div${lt2("list-card svelte-1gd50sk", void 0, { selected: a4.id === J3 })}><div class="list-card-header svelte-1gd50sk"><input type="text"${W2("value", a4.label)} placeholder="Annotation name" class="svelte-1gd50sk"/> <div class="list-card-actions svelte-1gd50sk"><input type="color"${W2("value", a4.color)} title="Annotation colour" class="svelte-1gd50sk"/> <button type="button" class="chip ghost">${On(a4.hidden ? "Show" : "Hide")}</button> <button type="button" class="chip danger">Delete</button> <button type="button" class="icon-button svelte-1gd50sk" aria-label="Annotation actions">\u2630</button></div></div> <textarea rows="2" placeholder="Annotation details" class="svelte-1gd50sk">`);
            const h3 = On(a4.details);
            h3 && t3.push(`${h3}`), t3.push("</textarea> "), rt5 === a4.id ? (t3.push("<!--[-->"), t3.push('<div class="card-menu svelte-1gd50sk"><button type="button" class="svelte-1gd50sk">Zoom to</button> <button type="button" class="svelte-1gd50sk">Select</button></div>')) : t3.push("<!--[!-->"), t3.push("<!--]--></div>");
          }
          t3.push("<!--]-->");
        } else t3.push("<!--[!-->"), t3.push('<p class="empty-state svelte-1gd50sk">Draw or import annotations to see them here.</p>');
        t3.push("<!--]--></div></aside>");
      }
      t3.push("<!--]-->");
    }
    if (t3.push("<!--]--></div> "), C4 ? (t3.push("<!--[-->"), t3.push('<div class="metadata-overlay svelte-1gd50sk" role="dialog" aria-modal="true" tabindex="0"><div class="metadata-card svelte-1gd50sk"><header class="svelte-1gd50sk"><h2 class="svelte-1gd50sk">Map metadata</h2> <button type="button" class="chip ghost svelte-1gd50sk">Close</button></header> '), r4 ? (t3.push("<!--[-->"), t3.push(`<section class="metadata-section svelte-1gd50sk"><h3 class="svelte-1gd50sk">${On(r4.name)}</h3> <dl class="svelte-1gd50sk"><div><dt class="svelte-1gd50sk">Type</dt> <dd class="svelte-1gd50sk">${On(r4.type)}</dd></div> `), r4.summary ? (t3.push("<!--[-->"), t3.push(`<div><dt class="svelte-1gd50sk">Summary</dt> <dd class="svelte-1gd50sk">${On(r4.summary)}</dd></div>`)) : t3.push("<!--[!-->"), t3.push("<!--]--> "), r4.description ? (t3.push("<!--[-->"), t3.push(`<div><dt class="svelte-1gd50sk">Details</dt> <dd class="svelte-1gd50sk">${On(r4.description)}</dd></div>`)) : t3.push("<!--[!-->"), t3.push("<!--]--></dl></section>")) : (t3.push("<!--[!-->"), t3.push('<p class="empty-state svelte-1gd50sk">Select a map to view its metadata.</p>')), t3.push("<!--]--></div></div>")) : t3.push("<!--[!-->"), t3.push("<!--]--> "), D5) {
      if (t3.push("<!--[-->"), t3.push(`<div class="search-dialog svelte-1gd50sk" role="dialog" aria-modal="true" tabindex="0"><button type="button" class="dialog-backdrop svelte-1gd50sk" aria-label="Dismiss search"></button> <div class="search-card svelte-1gd50sk"><header class="svelte-1gd50sk"><h2 class="svelte-1gd50sk">Search</h2> <button type="button" class="chip ghost">Close</button></header> <div class="search-form svelte-1gd50sk"><input type="text" placeholder="Search for a place or address"${W2("value", bt4)} class="svelte-1gd50sk"/> <div class="search-form-actions svelte-1gd50sk"><button type="button" class="chip ghost"${W2("disabled", ft4, true)}>Locate me</button> <button type="button" class="chip ghost"${W2("disabled", !F3.length, true)}>Clear</button></div></div> `), t3.push("<!--[!-->"), t3.push("<!--[!-->"), t3.push("<!--]-->"), t3.push("<!--]--> "), F3.length) {
        t3.push("<!--[-->"), t3.push('<div class="search-results-list custom-scrollbar svelte-1gd50sk"><!--[-->');
        const s6 = Et2(F3);
        for (let e3 = 0, l5 = s6.length; e3 < l5; e3++) {
          let a4 = s6[e3];
          t3.push(`<div class="search-result-item svelte-1gd50sk"><button type="button" class="search-result-main svelte-1gd50sk"><span class="result-title">${On(a4.display_name)}</span> `), a4.type ? (t3.push("<!--[-->"), t3.push(`<span class="result-type">${On(a4.type)}</span>`)) : t3.push("<!--[!-->"), t3.push('<!--]--></button> <div class="search-result-actions svelte-1gd50sk"><button type="button" class="chip ghost">Add to annotations</button></div></div>');
        }
        t3.push("<!--]--></div>");
      } else t3.push("<!--[!-->");
      t3.push("<!--]--></div></div>");
    } else t3.push("<!--[!-->");
    t3.push("<!--]--></div>"), c6 && at2(c6), pt2(n3, { initialMode: U4, showWelcomeOverlay: Y4 });
  });
}
function Yt3(d2, n3) {
  let t3 = nn(n3.mode, "explore");
  Ut4(d2, { initialMode: t3 }), pt2(n3, { mode: t3 });
}
function is(d2) {
  ct2(d2, (n3) => {
    n3.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
  }), Yt3(d2, {});
}
var Pt3, Nt4;
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/temp-viewer/_page.svelte.js"() {
    init_index2();
    init_ol();
    init_proj();
    init_GeoJSON();
    init_Observable();
    init_dist10();
    init_dist8();
    init_dist();
    init_constants2();
    init_Style();
    init_Fill();
    init_Stroke();
    init_Circle();
    init_chunks();
    init_context();
    new Style_default({ image: new Circle_default({ radius: 6, fill: new Fill_default({ color: "#06b6d4" }), stroke: new Stroke_default({ color: "#0e7490", width: 2 }) }), stroke: new Stroke_default({ color: "#06b6d4", width: 2 }), fill: new Fill_default({ color: "rgba(6, 182, 212, 0.18)" }) });
    Pt3 = 100;
    Nt4 = Symbol("annotation-context");
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  stylesheets: () => stylesheets4
});
var index4, component_cache4, component4, imports4, stylesheets4, fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    index4 = 3;
    component4 = async () => component_cache4 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default;
    imports4 = ["_app/immutable/nodes/3.B-GcnMDk.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/CUqaGiYm.js", "_app/immutable/chunks/obLiwMeQ.js", "_app/immutable/chunks/CeIZ_WK-.js", "_app/immutable/chunks/ilhcaF4n.js", "_app/immutable/chunks/6ds4e1Hj.js", "_app/immutable/chunks/uRYNcqzp.js", "_app/immutable/chunks/iPpcYJ_L.js", "_app/immutable/chunks/d6K977q5.js", "_app/immutable/chunks/DVjjavt6.js"];
    stylesheets4 = ["_app/immutable/assets/ol.BtPuoxOl.css", "_app/immutable/assets/3.CCMcqWKT.css"];
    fonts4 = [];
  }
});

// .svelte-kit/output/server/entries/pages/trip/_page.svelte.js
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => Yt4
});
function at4(i4, s6) {
  const t3 = dt2(s6), e3 = Ft2(t3, ["as", "gap", "align", "justify", "wrap", "className", "style"]);
  i4.component((a4) => {
    let o5, u6, h3, c6;
    const m5 = { start: "flex-start", center: "center", end: "flex-end", stretch: "stretch", baseline: "baseline" }, b5 = { start: "flex-start", center: "center", end: "flex-end", between: "space-between", around: "space-around", evenly: "space-evenly" };
    let g3 = nn(s6.as, "div"), r4 = nn(s6.gap, "var(--space-4)"), f5 = nn(s6.align, "stretch"), k2 = nn(s6.justify, "start"), l5 = nn(s6.wrap, false), y4 = nn(s6.className, ""), x5 = nn(s6.style, void 0);
    const w3 = (C4, M6) => M6 in C4 ? C4[M6] : M6;
    o5 = w3(m5, String(f5)), u6 = w3(b5, String(k2)), h3 = ["stack", l5 ? "stack--wrap" : "", y4, t3.class].filter(Boolean).join(" "), c6 = [x5, t3.style, `--stack-gap:${r4}`, `--stack-align:${o5}`, `--stack-justify:${u6}`].filter(Boolean).join(";"), et2(a4, g3, () => {
      a4.push(`${L2({ ...e3, class: Z2(h3), style: c6 }, "svelte-h657km")}`);
    }, () => {
      a4.push("<!--[-->"), ht(a4, s6, "default", {}), a4.push("<!--]-->");
    }), pt2(s6, { as: g3, gap: r4, align: f5, justify: k2, wrap: l5, className: y4, style: x5 });
  });
}
function Y3() {
  return typeof window < "u";
}
function it3(i4, s6) {
  let t3;
  return (e3) => {
    t3 !== void 0 && clearTimeout(t3), t3 = setTimeout(() => {
      i4(e3), t3 = void 0;
    }, s6);
  };
}
function lt4(i4, s6, t3) {
  if (!Y3()) return s6;
  const e3 = t3 ?? window.localStorage;
  try {
    const a4 = e3.getItem(i4);
    if (a4) {
      const o5 = JSON.parse(a4);
      return typeof s6 == "object" && s6 !== null && !Array.isArray(s6) ? { ...s6, ...o5 } : o5;
    }
  } catch (a4) {
    console.warn(`[PersistedStore] Failed to load "${i4}":`, a4);
  }
  return s6;
}
function q4(i4, s6, t3) {
  if (!Y3()) return;
  const e3 = t3 ?? window.localStorage;
  try {
    e3.setItem(i4, JSON.stringify(s6));
  } catch (a4) {
    console.warn(`[PersistedStore] Failed to save "${i4}":`, a4);
  }
}
function D4(i4) {
  const { key: s6, defaultValue: t3, debounceMs: e3 = 0, storage: a4 } = i4, o5 = lt4(s6, t3, a4), { subscribe: u6, set: h3, update: c6 } = z2(o5), m5 = e3 > 0 ? it3((f5) => q4(s6, f5, a4), e3) : (f5) => q4(s6, f5, a4);
  function b5(f5) {
    h3(f5), m5(f5);
  }
  function g3(f5) {
    c6((k2) => {
      const l5 = f5(k2);
      return m5(l5), l5;
    });
  }
  function r4() {
    b5(t3);
  }
  return { subscribe: u6, set: b5, update: g3, reset: r4 };
}
function nt4() {
  const i4 = D4({ key: ot4, defaultValue: "en" });
  return { subscribe: i4.subscribe, setLanguage: (s6) => {
    i4.set(s6);
  }, toggleLanguage: () => {
    i4.update((s6) => s6 === "en" ? "vi" : "en");
  } };
}
function ht3(i4, s6) {
  i4.component((t3) => {
    var e3;
    let a4, o5, u6, h3 = nn(s6.maps, () => [], true), c6 = nn(s6.selected, null), m5 = nn(s6.loading, false), b5 = nn(s6.filterCity, null), g3 = nn(s6.initialOpen, false), r4 = "", f5 = "all", k2 = g3;
    b5 && (f5 = b5, k2 = true), a4 = Array.from(new Set(h3.map((l5) => l5.type).filter(Boolean))).sort(), o5 = h3.filter((l5) => {
      if (f5 !== "all" && l5.type !== f5) return false;
      if (!r4.trim()) return true;
      const y4 = r4.toLowerCase();
      return l5.name.toLowerCase().includes(y4) || l5.type.toLowerCase().includes(y4) || l5.summary?.toLowerCase().includes(y4);
    }), u6 = h3.find((l5) => l5.id === c6), ct2(t3, (l5) => {
      l5.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
    }), t3.push(`<div class="selector-container svelte-1twr28"><button class="selector-button svelte-1twr28"${W2("disabled", m5, true)}><span class="button-ornament svelte-1twr28">${On(rt2(e3 ??= {}, "$t", d).mapSelector.buttonOrnament)}</span> <span class="button-text svelte-1twr28">`), m5 ? (t3.push("<!--[-->"), t3.push(`${On(rt2(e3 ??= {}, "$t", d).mapSelector.consultingAtlas)}`)) : (t3.push("<!--[!-->"), u6 ? (t3.push("<!--[-->"), t3.push(`${On(u6.name)}`)) : (t3.push("<!--[!-->"), t3.push(`${On(rt2(e3 ??= {}, "$t", d).mapSelector.mapCollection)}`)), t3.push("<!--]-->")), t3.push(`<!--]--></span> <span${lt2("arrow svelte-1twr28", void 0, { open: k2 })}>\u25BC</span></button> `), k2 ? (t3.push("<!--[-->"), t3.push('<div class="selector-panel svelte-1twr28">'), at4(t3, { gap: "var(--space-2)", children: (l5) => {
      if (a4.length > 0 ? (l5.push("<!--[-->"), l5.select({ class: "city-select", value: f5 }, (y4) => {
        y4.option({ value: "all", class: "" }, (w3) => {
          w3.push(`${On(rt2(e3 ??= {}, "$t", d).mapSelector.allRegions)}`);
        }, "svelte-1twr28"), y4.push("<!--[-->");
        const x5 = Et2(a4);
        for (let w3 = 0, C4 = x5.length; w3 < C4; w3++) {
          let M6 = x5[w3];
          y4.option({ value: M6, class: "" }, (L3) => {
            L3.push(`${On(M6)}`);
          }, "svelte-1twr28");
        }
        y4.push("<!--]-->");
      }, "svelte-1twr28")) : l5.push("<!--[!-->"), l5.push(`<!--]--> <input type="text" class="search-input svelte-1twr28"${W2("placeholder", rt2(e3 ??= {}, "$t", d).mapSelector.searchPlaceholder)}${W2("value", r4)}/> <div class="map-list svelte-1twr28">`), c6 && u6?.bounds ? (l5.push("<!--[-->"), l5.push(`<button class="map-item zoom svelte-1twr28"><span class="zoom-icon svelte-1twr28">\u{1F50D}</span> <span>${On(rt2(e3 ??= {}, "$t", d).mapSelector.zoomButton.replace("\u{1F50D} ", ""))}</span></button>`)) : l5.push("<!--[!-->"), l5.push("<!--]--> "), o5.length === 0) l5.push("<!--[-->"), l5.push(`<div class="empty-state svelte-1twr28"><div class="empty-icon svelte-1twr28">\u2298</div> <p class="svelte-1twr28">${On(rt2(e3 ??= {}, "$t", d).mapSelector.noMapsFound.replace("\u2298 ", ""))}</p></div>`);
      else {
        l5.push("<!--[!-->"), l5.push("<!--[-->");
        const y4 = Et2(o5);
        for (let x5 = 0, w3 = y4.length; x5 < w3; x5++) {
          let C4 = y4[x5];
          l5.push(`<button${lt2("map-item svelte-1twr28", void 0, { selected: C4.id === c6 })}><div class="map-info svelte-1twr28"><div class="map-name svelte-1twr28">${On(C4.name)}</div> `), C4.type ? (l5.push("<!--[-->"), l5.push(`<div class="map-type svelte-1twr28">${On(C4.type)}</div>`)) : l5.push("<!--[!-->"), l5.push("<!--]--> "), C4.year ? (l5.push("<!--[-->"), l5.push(`<div class="map-year svelte-1twr28">${On(rt2(e3 ??= {}, "$t", d).mapSelector.anno)} ${On(C4.year)}</div>`)) : l5.push("<!--[!-->"), l5.push("<!--]--></div> "), C4.id === c6 ? (l5.push("<!--[-->"), l5.push('<div class="selected-mark svelte-1twr28">\u2713</div>')) : l5.push("<!--[!-->"), l5.push("<!--]--></button>");
        }
        l5.push("<!--]-->");
      }
      l5.push("<!--]--></div>");
    }, $$slots: { default: true } }), t3.push("<!----></div>")) : t3.push("<!--[!-->"), t3.push("<!--]--></div>"), e3 && at2(e3), pt2(s6, { maps: h3, selected: c6, loading: m5, filterCity: b5, initialOpen: g3 });
  });
}
function vt2(i4, s6) {
  i4.component((t3) => {
    let e3 = s6.map, a4 = s6.position, o5 = nn(s6.heading, 0), u6 = nn(s6.fieldOfView, 60), h3 = nn(s6.radius, 200), c6 = null;
    function m5(g3, r4, f5, k2) {
      const l5 = f5, y4 = (90 - r4) * Math.PI / 180, x5 = k2 / 2 * Math.PI / 180, w3 = [g3], C4 = y4 - x5, M6 = y4 + x5, L3 = 20;
      for (let B4 = 0; B4 <= L3; B4++) {
        const O5 = C4 + B4 / L3 * (M6 - C4), H5 = g3[0] + l5 * Math.cos(O5), A5 = g3[1] + l5 * Math.sin(O5);
        w3.push([H5, A5]);
      }
      return w3.push(g3), new Polygon_default([w3]);
    }
    function b5() {
      if (!a4 || !e3) {
        console.log("[DirectionCone] Cannot update: position or map missing", { position: !!a4, map: !!e3 });
        return;
      }
      const g3 = a4.getGeometry();
      if (!g3) {
        console.log("[DirectionCone] Cannot update: position geometry missing");
        return;
      }
      const r4 = g3.getCoordinates();
      if (console.log("[DirectionCone] Updating cone:", { center: r4, heading: o5, radius: h3, fieldOfView: u6, hasFeature: !!c6, hasSource: false }), c6) {
        const f5 = m5(r4, o5, h3, u6);
        c6.setGeometry(f5), console.log("[DirectionCone] Updated cone geometry");
      } else {
        const f5 = m5(r4, o5, h3, u6);
        c6 = new Feature_default({ geometry: f5 }), c6.setId("direction-cone"), console.log("[DirectionCone] Created new cone feature");
      }
    }
    s4(() => {
    }), e3 && a4 && o5 !== void 0 && (console.log("[DirectionCone] Reactive update triggered", { hasMap: !!e3, hasPosition: !!a4, heading: o5, hasDirectionSource: false }), b5()), pt2(s6, { map: e3, position: a4, heading: o5, fieldOfView: u6, radius: h3 });
  });
}
function dt4(i4, s6) {
  i4.component((t3) => {
    var e3;
    let a4 = nn(s6.isTracking, false), o5 = nn(s6.error, null);
    ct2(t3, (u6) => {
      u6.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet" class="svelte-1wnqptu"/>');
    }), t3.push(`<div class="location-button-container svelte-1wnqptu"><button${lt2("location-button svelte-1wnqptu", void 0, { active: a4, error: !!o5 })}${W2("title", a4 ? "Stop location tracking" : "Start location tracking")}><span class="icon svelte-1wnqptu">`), a4 ? (t3.push("<!--[-->"), t3.push("\u25C9")) : (t3.push("<!--[!-->"), t3.push("\u25CE")), t3.push(`<!--]--></span> <span class="label svelte-1wnqptu">${On(a4 ? rt2(e3 ??= {}, "$t", d).location.tracking : rt2(e3 ??= {}, "$t", d).location.myLocation)}</span></button> `), o5 ? (t3.push("<!--[-->"), t3.push(`<div class="error-tooltip svelte-1wnqptu">${On(o5)}</div>`)) : t3.push("<!--[!-->"), t3.push("<!--]--></div>"), e3 && at2(e3), pt2(s6, { isTracking: a4, error: o5 });
  });
}
function gt3(i4, s6) {
  i4.component((t3) => {
    var e3;
    let a4 = nn(s6.isOpen, false), o5 = "", u6 = [], h3 = false, c6 = null;
    if (a4 || (o5 = "", u6 = [], c6 = null), ct2(t3, (m5) => {
      m5.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
    }), t3.push(`<div class="search-container svelte-td9aje"><button class="search-toggle svelte-td9aje"${W2("title", rt2(e3 ??= {}, "$t", d).search.searchLocation)}><span class="icon svelte-td9aje">\u2315</span> `), a4 ? t3.push("<!--[!-->") : (t3.push("<!--[-->"), t3.push(`<span class="label svelte-td9aje">${On(rt2(e3 ??= {}, "$t", d).search.search)}</span>`)), t3.push("<!--]--></button> "), a4) {
      if (t3.push("<!--[-->"), t3.push(`<div class="search-panel svelte-td9aje"><div class="search-header svelte-td9aje"><span class="header-icon svelte-td9aje">\u{1F4CD}</span> <span class="header-text svelte-td9aje">${On(rt2(e3 ??= {}, "$t", d).search.searchLocation)}</span></div> <div class="search-input-container svelte-td9aje"><input type="text" class="search-input svelte-td9aje"${W2("placeholder", rt2(e3 ??= {}, "$t", d).search.searchPlaceholder)}${W2("value", o5)}${W2("disabled", h3, true)}/> <button class="search-button svelte-td9aje"${W2("disabled", !o5.trim(), true)}>${On(rt2(e3 ??= {}, "$t", d).search.search)}</button></div> `), c6 ? (t3.push("<!--[-->"), t3.push(`<div class="error-message svelte-td9aje">${On(c6)}</div>`)) : t3.push("<!--[!-->"), t3.push("<!--]--> "), u6.length > 0) {
        t3.push("<!--[-->"), t3.push('<div class="results-list svelte-td9aje"><!--[-->');
        const m5 = Et2(u6);
        for (let b5 = 0, g3 = m5.length; b5 < g3; b5++) {
          let r4 = m5[b5];
          t3.push(`<button class="result-item svelte-td9aje"><span class="result-icon svelte-td9aje">\u{1F4CC}</span> <div class="result-content svelte-td9aje"><div class="result-name svelte-td9aje">${On(r4.name || r4.display_name.split(",")[0])}</div> <div class="result-address svelte-td9aje">${On(r4.display_name)}</div></div></button>`);
        }
        t3.push("<!--]--></div>");
      } else t3.push("<!--[!-->");
      t3.push("<!--]--></div>");
    } else t3.push("<!--[!-->");
    t3.push("<!--]--></div>"), e3 && at2(e3), pt2(s6, { isOpen: a4 });
  });
}
function mt3(i4, s6) {
  i4.component((t3) => {
    var e3;
    let a4 = nn(s6.cityName, ""), o5 = nn(s6.isOpen, false);
    function u6(h3) {
      const c6 = h3.toLowerCase().replace(/\s+/g, "");
      return rt2(e3 ??= {}, "$t", d).cities[c6] || h3;
    }
    ct2(t3, (h3) => {
      h3.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
    }), o5 ? (t3.push("<!--[-->"), t3.push(`<div class="dialog-overlay svelte-r8jync"><div class="dialog-container svelte-r8jync"><div class="dialog-icon svelte-r8jync">${On(rt2(e3 ??= {}, "$t", d).cityFilter.icon)}</div> <div class="dialog-content svelte-r8jync"><h3 class="dialog-title svelte-r8jync">${On(rt2(e3 ??= {}, "$t", d).cityFilter.title)}</h3> <p class="dialog-message svelte-r8jync">${On(rt2(e3 ??= {}, "$t", d).cityFilter.message)} <strong class="svelte-r8jync">${On(u6(a4))}</strong>?</p></div> <div class="dialog-actions svelte-r8jync"><button class="dialog-button secondary svelte-r8jync">${On(rt2(e3 ??= {}, "$t", d).cityFilter.noShowAll)}</button> <button class="dialog-button primary svelte-r8jync">${On(rt2(e3 ??= {}, "$t", d).cityFilter.yesFilter)}</button></div></div></div>`)) : t3.push("<!--[!-->"), t3.push("<!--]-->"), e3 && at2(e3), pt2(s6, { cityName: a4, isOpen: o5 });
  });
}
function ft3(i4, s6) {
  i4.component((t3) => {
    var e3;
    let a4 = nn(s6.isOpen, false), o5 = nn(s6.cities, () => [], true), u6 = nn(s6.loadingCity, null);
    function h3(c6) {
      const m5 = c6.toLowerCase().replace(/\s+/g, "");
      return rt2(e3 ??= {}, "$t", d).cities[m5] || c6;
    }
    if (ct2(t3, (c6) => {
      c6.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
    }), a4) {
      t3.push("<!--[-->"), t3.push(`<div class="dialog-overlay svelte-1vbp4hf"><div class="dialog-container svelte-1vbp4hf"><div class="dialog-header svelte-1vbp4hf"><div class="dialog-icon svelte-1vbp4hf">\u{1F5FA}\uFE0F</div> <h2 class="dialog-title svelte-1vbp4hf">${On(rt2(e3 ??= {}, "$t", d).welcome.title)}</h2> <div class="language-toggle svelte-1vbp4hf"><button${lt2("lang-button svelte-1vbp4hf", void 0, { active: rt2(e3 ??= {}, "$currentLanguage", F2) === "en" })}>EN</button> <span class="lang-separator svelte-1vbp4hf">|</span> <button${lt2("lang-button svelte-1vbp4hf", void 0, { active: rt2(e3 ??= {}, "$currentLanguage", F2) === "vi" })}>VI</button></div></div> <div class="dialog-content svelte-1vbp4hf"><p class="dialog-message svelte-1vbp4hf">${On(rt2(e3 ??= {}, "$t", d).welcome.message)}</p> <div class="city-grid svelte-1vbp4hf"><!--[-->`);
      const c6 = Et2(o5);
      for (let m5 = 0, b5 = c6.length; m5 < b5; m5++) {
        let g3 = c6[m5];
        t3.push(`<button${lt2("city-button svelte-1vbp4hf", void 0, { loading: u6 === g3, disabled: u6 && u6 !== g3 })}${W2("disabled", !!u6, true)}>`), u6 === g3 ? (t3.push("<!--[-->"), t3.push(`<span class="loading-spinner svelte-1vbp4hf">\u23F3</span> <span class="city-name svelte-1vbp4hf">${On(rt2(e3 ??= {}, "$t", d).loading.loadingCity)}...</span>`)) : (t3.push("<!--[!-->"), t3.push(`<span class="city-icon svelte-1vbp4hf">${On(rt2(e3 ??= {}, "$t", d).welcome.cityIcon)}</span> <span class="city-name svelte-1vbp4hf">${On(h3(g3))}</span>`)), t3.push("<!--]--></button>");
      }
      t3.push(`<!--]--></div></div> <div class="dialog-actions svelte-1vbp4hf"><button class="dialog-button secondary svelte-1vbp4hf"${W2("disabled", !!u6, true)}>${On(rt2(e3 ??= {}, "$t", d).welcome.skipButton)}</button></div></div></div>`);
    } else t3.push("<!--[!-->");
    t3.push("<!--]-->"), e3 && at2(e3), pt2(s6, { isOpen: a4, cities: o5, loadingCity: u6 });
  });
}
function rt4(i4, s6) {
  i4.component((t3) => {
    var e3;
    let a4 = nn(s6.isVisible, false);
    ct2(t3, (o5) => {
      o5.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet" class="svelte-1lpq58w"/>');
    }), a4 ? (t3.push("<!--[-->"), t3.push(`<div class="hint-overlay svelte-1lpq58w"><div class="spotlight svelte-1lpq58w"></div></div> <div class="hint-popup svelte-1lpq58w"><div class="hint-content svelte-1lpq58w"><div class="hint-icon svelte-1lpq58w">${On(rt2(e3 ??= {}, "$t", d).mapHint.icon)}</div> <div class="hint-text svelte-1lpq58w"><div class="hint-title svelte-1lpq58w">${On(rt2(e3 ??= {}, "$t", d).mapHint.title)}</div> <div class="hint-description svelte-1lpq58w">${On(rt2(e3 ??= {}, "$t", d).mapHint.description)}</div></div></div> <button class="hint-dismiss svelte-1lpq58w">${On(rt2(e3 ??= {}, "$t", d).mapHint.button)}</button></div>`)) : t3.push("<!--[!-->"), t3.push("<!--]-->"), e3 && at2(e3), pt2(s6, { isVisible: a4 });
  });
}
function yt3(i4, s6) {
  i4.component((t3) => {
    let e3 = nn(s6.isTracking, false), a4 = nn(s6.error, null), o5 = nn(s6.opacity, 1), u6 = nn(s6.hasMapSelected, false), h3 = nn(s6.searchOpen, false), c6 = nn(s6.viewMode, "overlay"), m5 = false, b5 = false, g3 = "", r4 = [], f5 = false, k2 = null;
    if (h3 || (g3 = "", r4 = [], k2 = null), ct2(t3, (l5) => {
      l5.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet" class="svelte-ua832v"/>');
    }), t3.push(`<div class="mobile-controls svelte-ua832v"><div class="control-bar svelte-ua832v"><button${lt2("control-btn svelte-ua832v", void 0, { active: e3 })}${W2("title", e3 ? "Stop tracking" : "Start tracking")}><span class="btn-icon svelte-ua832v">`), e3 ? (t3.push("<!--[-->"), t3.push('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="svelte-ua832v"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" stroke="#6b5d52" stroke-width="1.5" fill="#d4af37" stroke-linejoin="round" class="svelte-ua832v"></path></svg>')) : (t3.push("<!--[!-->"), t3.push('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="svelte-ua832v"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" stroke="#6b5d52" stroke-width="1.5" fill="none" stroke-linejoin="round" class="svelte-ua832v"></path></svg>')), t3.push(`<!--]--></span></button> <button${lt2("control-btn svelte-ua832v", void 0, { active: h3 })} title="Search location"><span class="btn-icon svelte-ua832v"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="svelte-ua832v"><circle cx="11" cy="11" r="7" stroke="#6b5d52" stroke-width="1.5" class="svelte-ua832v"></circle><path d="M16 16L21 21" stroke="#6b5d52" stroke-width="1.5" stroke-linecap="round" class="svelte-ua832v"></path></svg></span></button> `), u6 ? (t3.push("<!--[-->"), t3.push(`<button${lt2("control-btn svelte-ua832v", void 0, { active: b5 })} title="View mode"><span class="btn-icon svelte-ua832v">`), c6 === "overlay" ? (t3.push("<!--[-->"), t3.push('<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#6b5d52" stroke-width="1.5" class="svelte-ua832v"><rect x="3" y="3" width="18" height="18" rx="2" class="svelte-ua832v"></rect></svg>')) : (t3.push("<!--[!-->"), c6 === "side-x" ? (t3.push("<!--[-->"), t3.push('<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#6b5d52" stroke-width="1.5" class="svelte-ua832v"><rect x="3" y="3" width="18" height="18" rx="2" class="svelte-ua832v"></rect><line x1="12" y1="3" x2="12" y2="21" class="svelte-ua832v"></line></svg>')) : (t3.push("<!--[!-->"), c6 === "side-y" ? (t3.push("<!--[-->"), t3.push('<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#6b5d52" stroke-width="1.5" class="svelte-ua832v"><rect x="3" y="3" width="18" height="18" rx="2" class="svelte-ua832v"></rect><line x1="3" y1="12" x2="21" y2="12" class="svelte-ua832v"></line></svg>')) : (t3.push("<!--[!-->"), t3.push('<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#6b5d52" stroke-width="1.5" class="svelte-ua832v"><rect x="3" y="3" width="18" height="18" rx="2" class="svelte-ua832v"></rect><circle cx="12" cy="12" r="5" class="svelte-ua832v"></circle></svg>')), t3.push("<!--]-->")), t3.push("<!--]-->")), t3.push("<!--]--></span></button>")) : t3.push("<!--[!-->"), t3.push("<!--]--> "), u6 ? (t3.push("<!--[-->"), t3.push(`<button${lt2("control-btn svelte-ua832v", void 0, { active: m5 })} title="Adjust opacity"><span class="btn-icon svelte-ua832v">\u25D0</span></button>`)) : t3.push("<!--[!-->"), t3.push("<!--]--></div> "), t3.push("<!--[!-->"), t3.push("<!--]--> "), t3.push("<!--[!-->"), t3.push("<!--]--> "), h3) {
      if (t3.push("<!--[-->"), t3.push(`<div class="expansion-panel search-panel svelte-ua832v"><div class="search-header svelte-ua832v"><span class="header-icon svelte-ua832v">\u{1F4CD}</span> <span class="header-text svelte-ua832v">Search Location</span></div> <div class="search-input-wrapper svelte-ua832v"><input type="text" class="search-input svelte-ua832v" placeholder="Enter city, address..."${W2("value", g3)}${W2("disabled", f5, true)}/> <button class="search-btn svelte-ua832v"${W2("disabled", !g3.trim(), true)}>${On("\u{1F50D}")}</button></div> `), k2 ? (t3.push("<!--[-->"), t3.push(`<div class="search-error svelte-ua832v">${On(k2)}</div>`)) : t3.push("<!--[!-->"), t3.push("<!--]--> "), r4.length > 0) {
        t3.push("<!--[-->"), t3.push('<div class="search-results svelte-ua832v"><!--[-->');
        const l5 = Et2(r4);
        for (let y4 = 0, x5 = l5.length; y4 < x5; y4++) {
          let w3 = l5[y4];
          t3.push(`<button class="result-item svelte-ua832v"><span class="result-icon svelte-ua832v">\u{1F4CC}</span> <div class="result-content svelte-ua832v"><div class="result-name svelte-ua832v">${On(w3.name || w3.display_name.split(",")[0])}</div> <div class="result-address svelte-ua832v">${On(w3.display_name)}</div></div></button>`);
        }
        t3.push("<!--]--></div>");
      } else t3.push("<!--[!-->");
      t3.push("<!--]--></div>");
    } else t3.push("<!--[!-->");
    t3.push("<!--]--> "), a4 ? (t3.push("<!--[-->"), t3.push(`<div class="error-badge svelte-ua832v">${On(a4)}</div>`)) : t3.push("<!--[!-->"), t3.push("<!--]--></div>"), pt2(s6, { isTracking: e3, error: a4, opacity: o5, hasMapSelected: u6, searchOpen: h3, viewMode: c6 });
  });
}
function St4() {
  const i4 = D4({ key: bt3, defaultValue: wt3, debounceMs: 100 });
  return { subscribe: i4.subscribe, setHasSeenWelcome: (s6) => {
    i4.update((t3) => ({ ...t3, hasSeenWelcome: s6 }));
  }, setHasCompletedTutorial: (s6) => {
    i4.update((t3) => ({ ...t3, hasCompletedTutorial: s6 }));
  }, setHasSeenMapHint: (s6) => {
    i4.update((t3) => ({ ...t3, hasSeenMapHint: s6 }));
  }, setAutoStartLocation: (s6) => {
    i4.update((t3) => ({ ...t3, autoStartLocation: s6 }));
  }, setLastKnownPosition: (s6) => {
    i4.update((t3) => ({ ...t3, lastKnownPosition: s6 }));
  }, reset: () => {
    i4.reset();
  } };
}
function Ct4() {
  const { subscribe: i4, set: s6, update: t3 } = z2(I3);
  return { subscribe: i4, setCurrentYear: (e3) => {
    t3((a4) => ({ ...a4, currentYear: e3 }));
  }, setAvailableYears: (e3) => {
    t3((a4) => {
      const o5 = [...e3].sort((h3, c6) => h3 - c6), u6 = o5.length > 0 ? Math.max(...o5) : a4.currentYear;
      return { ...a4, availableYears: o5, currentYear: u6 };
    });
  }, setActiveMap: (e3) => {
    t3((a4) => ({ ...a4, activeMapId: e3 }));
  }, setIsTransitioning: (e3) => {
    t3((a4) => ({ ...a4, isTransitioning: e3 }));
  }, reset: () => {
    s6(I3);
  } };
}
function xt3(i4) {
  In(kt3, i4);
}
function Mt4(i4, s6) {
  i4.component((t3) => {
    let e3, a4 = nn(s6.initialMapId, null), o5 = nn(s6.initialCity, null), u6 = null, h3 = "inactive", c6 = null, m5 = null, b5 = null, g3 = [], r4 = false, f5 = null;
    const k2 = St4(), l5 = Ct4();
    xt3({ preferences: k2, timeline: l5 });
    let y4 = 0, x5 = false, w3 = false, C4 = null, M6 = false, L3 = false, B4 = 0.8, O5 = "overlay", H5 = 0.5, A5 = 150;
    e3 = Array.from(new Set(g3.map((E6) => E6.type).filter(Boolean))).sort(), t3.push(`<div class="trip-container svelte-1id9u82"><div class="map svelte-1id9u82"></div> <div class="divider divider-x svelte-1id9u82"></div> <div class="divider-handle divider-handle-x svelte-1id9u82" role="slider" aria-label="Adjust horizontal split"${W2("aria-valuenow", Math.round(H5 * 100))} tabindex="0"></div> <div class="divider divider-y svelte-1id9u82"></div> <div class="divider-handle divider-handle-y svelte-1id9u82" role="slider" aria-label="Adjust vertical split"${W2("aria-valuenow", Math.round(H5 * 100))} tabindex="0"></div> <div class="lens svelte-1id9u82"></div> <div class="lens-handle svelte-1id9u82" role="slider" aria-label="Adjust lens size"${W2("aria-valuenow", A5)} tabindex="0"></div> `), dt4(t3, { isTracking: h3 === "active", error: m5 }), t3.push("<!----> "), gt3(t3, { isOpen: L3 }), t3.push("<!----> "), vt2(t3, { map: u6, position: c6, heading: y4 }), t3.push("<!----> "), ht3(t3, { maps: g3, selected: b5, loading: r4, filterCity: f5 }), t3.push("<!----> "), mt3(t3, { cityName: "", isOpen: x5 }), t3.push("<!----> "), ft3(t3, { isOpen: w3, cities: e3, loadingCity: C4 }), t3.push("<!----> "), rt4(t3, { isVisible: M6 }), t3.push("<!----> "), t3.push("<!--[!-->"), t3.push("<!--]--> "), yt3(t3, { isTracking: h3 === "active", error: m5, opacity: B4, viewMode: O5, hasMapSelected: false, searchOpen: L3 }), t3.push("<!----></div>"), pt2(s6, { initialMapId: a4, initialCity: o5 });
  });
}
function Yt4(i4, s6) {
  i4.component((t3) => {
    var e3;
    let a4, o5;
    a4 = rt2(e3 ??= {}, "$page", V3).url.searchParams.get("map"), o5 = rt2(e3 ??= {}, "$page", V3).url.searchParams.get("city"), Mt4(t3, { initialMapId: a4, initialCity: o5 }), e3 && at2(e3);
  });
}
var et4, V3, ot4, F2, ct4, ut4, pt3, d, bt3, wt3, I3, kt3;
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/trip/_page.svelte.js"() {
    init_index2();
    init_context();
    init_internal();
    init_exports();
    init_utils();
    init_clsx();
    init_server();
    init_state_svelte();
    init_proj();
    init_dist10();
    init_ol();
    init_constants2();
    init_chunks();
    init_Polygon();
    init_Feature();
    et4 = () => {
      const i4 = Fn("__svelte__");
      return { page: { subscribe: i4.page.subscribe }, navigating: { subscribe: i4.navigating.subscribe }, updated: i4.updated };
    };
    V3 = { subscribe(i4) {
      return et4().page.subscribe(i4);
    } };
    ot4 = "vma-trip-language-v1";
    F2 = nt4();
    ct4 = { welcome: { title: "Welcome to Historical Maps", message: "Choose your starting city to explore historical maps from different eras.", skipButton: "Skip for Now", cityIcon: "\u{1F4CD}" }, mapSelector: { consultingAtlas: "Consulting Atlas...", mapCollection: "Map Collection", allRegions: "All Regions", searchPlaceholder: "Search by year or name", zoomButton: "\u{1F50D} Zoom to Map", anno: "Anno", noMapsFound: "\u2298 No maps discovered in this region", buttonOrnament: "\u29C9" }, location: { tracking: "Tracking", myLocation: "My Location" }, mapHint: { icon: "\u{1F446}", title: "Explore Historical Maps", description: "Click here to browse our collection of vintage maps", button: "Got it!" }, cityFilter: { icon: "\u{1F5FA}\uFE0F", title: "Filter Map Collection?", message: "Would you like to filter the map collection to show only maps from", noShowAll: "No, Show All", yesFilter: "Yes, Filter" }, cities: { hanoi: "Hanoi", hue: "Hue", hochiminh: "Ho Chi Minh City", danang: "Da Nang", haiphong: "Hai Phong", cantho: "Can Tho", nhatrang: "Nha Trang", dalat: "Da Lat", vungtau: "Vung Tau", quinhon: "Quy Nhon" }, search: { search: "Search", searchLocation: "Search location", searchPlaceholder: "Enter location...", searching: "Searching..." }, viewControls: { overlayOpacity: "Overlay Opacity", opacity: "Opacity", viewMode: "View Mode", overlay: "Overlay", sideX: "Side X", sideY: "Side Y", spyglass: "Spyglass" }, loading: { preparingMap: "Preparing your map...", loadingCity: "Loading", findingMaps: "Finding historical maps...", almostReady: "Almost ready!" }, common: { loading: "Loading...", error: "Error", close: "Close", cancel: "Cancel", confirm: "Confirm", save: "Save" } };
    ut4 = { welcome: { title: "Ch\xE0o m\u1EEBng \u0111\u1EBFn v\u1EDBi B\u1EA3n \u0111\u1ED3 L\u1ECBch s\u1EED", message: "Ch\u1ECDn th\xE0nh ph\u1ED1 b\u1EAFt \u0111\u1EA7u \u0111\u1EC3 kh\xE1m ph\xE1 b\u1EA3n \u0111\u1ED3 l\u1ECBch s\u1EED t\u1EEB nhi\u1EC1u th\u1EDDi k\u1EF3 kh\xE1c nhau.", skipButton: "B\u1ECF qua", cityIcon: "\u{1F4CD}" }, mapSelector: { consultingAtlas: "\u0110ang t\u1EA3i b\u1EA3n \u0111\u1ED3...", mapCollection: "B\u1ED9 s\u01B0u t\u1EADp B\u1EA3n \u0111\u1ED3", allRegions: "T\u1EA5t c\u1EA3 V\xF9ng", searchPlaceholder: "T\xECm ki\u1EBFm theo n\u0103m ho\u1EB7c t\xEAn", zoomButton: "\u{1F50D} Ph\xF3ng to B\u1EA3n \u0111\u1ED3", anno: "N\u0103m", noMapsFound: "\u2298 Kh\xF4ng t\xECm th\u1EA5y b\u1EA3n \u0111\u1ED3 trong khu v\u1EF1c n\xE0y", buttonOrnament: "\u29C9" }, location: { tracking: "\u0110ang theo d\xF5i", myLocation: "V\u1ECB tr\xED c\u1EE7a t\xF4i" }, mapHint: { icon: "\u{1F446}", title: "Kh\xE1m ph\xE1 B\u1EA3n \u0111\u1ED3 L\u1ECBch s\u1EED", description: "Nh\u1EA5n v\xE0o \u0111\xE2y \u0111\u1EC3 xem b\u1ED9 s\u01B0u t\u1EADp b\u1EA3n \u0111\u1ED3 c\u1ED5 c\u1EE7a ch\xFAng t\xF4i", button: "\u0110\xE3 hi\u1EC3u!" }, cityFilter: { icon: "\u{1F5FA}\uFE0F", title: "L\u1ECDc B\u1ED9 s\u01B0u t\u1EADp B\u1EA3n \u0111\u1ED3?", message: "B\u1EA1n c\xF3 mu\u1ED1n l\u1ECDc b\u1ED9 s\u01B0u t\u1EADp b\u1EA3n \u0111\u1ED3 \u0111\u1EC3 ch\u1EC9 hi\u1EC3n th\u1ECB b\u1EA3n \u0111\u1ED3 t\u1EEB", noShowAll: "Kh\xF4ng, Hi\u1EC3n th\u1ECB T\u1EA5t c\u1EA3", yesFilter: "C\xF3, L\u1ECDc" }, cities: { hanoi: "H\xE0 N\u1ED9i", hue: "Hu\u1EBF", hochiminh: "Th\xE0nh ph\u1ED1 H\u1ED3 Ch\xED Minh", danang: "\u0110\xE0 N\u1EB5ng", haiphong: "H\u1EA3i Ph\xF2ng", cantho: "C\u1EA7n Th\u01A1", nhatrang: "Nha Trang", dalat: "\u0110\xE0 L\u1EA1t", vungtau: "V\u0169ng T\xE0u", quinhon: "Quy Nh\u01A1n" }, search: { search: "T\xECm ki\u1EBFm", searchLocation: "T\xECm ki\u1EBFm v\u1ECB tr\xED", searchPlaceholder: "Nh\u1EADp v\u1ECB tr\xED...", searching: "\u0110ang t\xECm..." }, viewControls: { overlayOpacity: "\u0110\u1ED9 trong su\u1ED1t", opacity: "\u0110\u1ED9 m\u1EDD", viewMode: "Ch\u1EBF \u0111\u1ED9 xem", overlay: "Ph\u1EE7", sideX: "Chia ngang", sideY: "Chia d\u1ECDc", spyglass: "K\xEDnh l\xFAp" }, loading: { preparingMap: "\u0110ang chu\u1EA9n b\u1ECB b\u1EA3n \u0111\u1ED3...", loadingCity: "\u0110ang t\u1EA3i", findingMaps: "\u0110ang t\xECm b\u1EA3n \u0111\u1ED3 l\u1ECBch s\u1EED...", almostReady: "G\u1EA7n ho\xE0n t\u1EA5t!" }, common: { loading: "\u0110ang t\u1EA3i...", error: "L\u1ED7i", close: "\u0110\xF3ng", cancel: "H\u1EE7y", confirm: "X\xE1c nh\u1EADn", save: "L\u01B0u" } };
    pt3 = { en: ct4, vi: ut4 };
    d = B2(F2, (i4) => pt3[i4]);
    bt3 = "vma-trip-preferences-v1";
    wt3 = { hasSeenWelcome: false, hasCompletedTutorial: false, hasSeenMapHint: false, autoStartLocation: false, lastKnownPosition: null };
    I3 = { currentYear: (/* @__PURE__ */ new Date()).getFullYear(), availableYears: [], activeMapId: null, isTransitioning: false };
    kt3 = Symbol("trip-context");
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  stylesheets: () => stylesheets5
});
var index5, component_cache5, component5, imports5, stylesheets5, fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    index5 = 4;
    component5 = async () => component_cache5 ??= (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default;
    imports5 = ["_app/immutable/nodes/4.Sh9ZFBJf.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/CUqaGiYm.js", "_app/immutable/chunks/obLiwMeQ.js", "_app/immutable/chunks/CeIZ_WK-.js", "_app/immutable/chunks/ilhcaF4n.js", "_app/immutable/chunks/DPtGKd3c.js", "_app/immutable/chunks/6ds4e1Hj.js", "_app/immutable/chunks/uRYNcqzp.js", "_app/immutable/chunks/d6K977q5.js", "_app/immutable/chunks/DVjjavt6.js", "_app/immutable/chunks/iPpcYJ_L.js"];
    stylesheets5 = ["_app/immutable/assets/ol.BtPuoxOl.css", "_app/immutable/assets/4.D-NxuxNd.css"];
    fonts5 = [];
  }
});

// .svelte-kit/output/server/index.js
init_false();

// node_modules/@sveltejs/kit/src/exports/index.js
init_internal();

// node_modules/esm-env/true.js
var true_default = true;

// node_modules/esm-env/dev-fallback.js
var node_env = globalThis.process?.env?.NODE_ENV;
var dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");

// node_modules/@sveltejs/kit/src/runtime/utils.js
var text_encoder = new TextEncoder();
var text_decoder = new TextDecoder();

// node_modules/@sveltejs/kit/src/exports/index.js
function error(status, body) {
  if ((!true_default || dev_fallback_default) && (isNaN(status) || status < 400 || status > 599)) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  throw new HttpError(status, body);
}
function json(data, init35) {
  const body = JSON.stringify(data);
  const headers = new Headers(init35?.headers);
  if (!headers.has("content-length")) {
    headers.set("content-length", text_encoder.encode(body).byteLength.toString());
  }
  if (!headers.has("content-type")) {
    headers.set("content-type", "application/json");
  }
  return new Response(body, {
    ...init35,
    headers
  });
}
function text(body, init35) {
  const headers = new Headers(init35?.headers);
  if (!headers.has("content-length")) {
    const encoded = text_encoder.encode(body);
    headers.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init35,
      headers
    });
  }
  return new Response(body, {
    ...init35,
    headers
  });
}

// .svelte-kit/output/server/index.js
init_internal();
init_server();

// .svelte-kit/output/server/chunks/environment.js
var e = "";
var t = e;
var i = "_app";
var r = true;
var a = { base: e, assets: t };
function o(s6) {
  e = s6.base, t = s6.assets;
}
function c() {
  e = a.base, t = a.assets;
}

// node_modules/devalue/src/utils.js
var escaped = {
  "<": "\\u003C",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var DevalueError = class extends Error {
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys) {
    super(message);
    this.name = "DevalueError";
    this.path = keys.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i4 = 0; i4 < len; i4 += 1) {
    const char = str[i4];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i4) + replacement;
      last_pos = i4 + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
var is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key) {
  return is_identifier.test(key) ? "." + key : "[" + JSON.stringify(key) + "]";
}

// node_modules/devalue/src/uneval.js
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom2 = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing, (value2) => uneval(value2, replacer));
        if (typeof str2 === "string") {
          custom2.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
        case "URL":
        case "URLSearchParams":
          return;
        case "Array":
          thing.forEach((value2, i4) => {
            keys.push(`[${i4}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key) ? stringify_primitive(key) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          walk(thing.buffer);
          return;
        case "ArrayBuffer":
          return;
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          return;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key in thing) {
            keys.push(stringify_key(key));
            walk(thing[key]);
            keys.pop();
          }
      }
    }
  }
  walk(value);
  const names36 = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a4, b5) => b5[1] - a4[1]).forEach((entry, i4) => {
    names36.set(entry[0], get_name(i4));
  });
  function stringify2(thing) {
    if (names36.has(thing)) {
      return names36.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive(thing);
    }
    if (custom2.has(thing)) {
      return custom2.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify2(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "URL":
        return `new URL(${stringify_string(thing.toString())})`;
      case "URLSearchParams":
        return `new URLSearchParams(${stringify_string(thing.toString())})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v4, i4) => i4 in thing ? stringify2(v4) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify2).join(",")}])`;
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array": {
        let str2 = `new ${type}`;
        if (counts.get(thing.buffer) === 1) {
          const array = new thing.constructor(thing.buffer);
          str2 += `([${array}])`;
        } else {
          str2 += `([${stringify2(thing.buffer)}])`;
        }
        const a4 = thing.byteOffset;
        const b5 = a4 + thing.byteLength;
        if (a4 > 0 || b5 !== thing.buffer.byteLength) {
          const m5 = +/(\d+)/.exec(type)[1] / 8;
          str2 += `.subarray(${a4 / m5},${b5 / m5})`;
        }
        return str2;
      }
      case "ArrayBuffer": {
        const ui8 = new Uint8Array(thing);
        return `new Uint8Array([${ui8.toString()}]).buffer`;
      }
      case "Temporal.Duration":
      case "Temporal.Instant":
      case "Temporal.PlainDate":
      case "Temporal.PlainTime":
      case "Temporal.PlainDateTime":
      case "Temporal.PlainMonthDay":
      case "Temporal.PlainYearMonth":
      case "Temporal.ZonedDateTime":
        return `${type}.from(${stringify_string(thing.toString())})`;
      default:
        const keys2 = Object.keys(thing);
        const obj = keys2.map((key) => `${safe_key(key)}:${stringify2(thing[key])}`).join(",");
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return keys2.length > 0 ? `{${obj},__proto__:null}` : `{__proto__:null}`;
        }
        return `{${obj}}`;
    }
  }
  const str = stringify2(value);
  if (names36.size) {
    const params2 = [];
    const statements = [];
    const values = [];
    names36.forEach((name, thing) => {
      params2.push(name);
      if (custom2.has(thing)) {
        values.push(
          /** @type {string} */
          custom2.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify2(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v4, i4) => {
            statements.push(`${name}[${i4}]=${stringify2(v4)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name}.${Array.from(thing).map((v4) => `add(${stringify2(v4)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name}.${Array.from(thing).map(([k2, v4]) => `set(${stringify2(k2)}, ${stringify2(v4)})`).join(".")}`
          );
          break;
        case "ArrayBuffer":
          values.push(
            `new Uint8Array([${new Uint8Array(thing).join(",")}]).buffer`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key) => {
            statements.push(
              `${name}${safe_prop(key)}=${stringify2(thing[key])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params2.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function get_name(num) {
  let name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
function escape_unsafe_char(c6) {
  return escaped[c6] || c6;
}
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escape_unsafe_chars(JSON.stringify(key));
}
function safe_prop(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? `.${key}` : `[${escape_unsafe_chars(JSON.stringify(key))}]`;
}
function stringify_primitive(thing) {
  if (typeof thing === "string") return stringify_string(thing);
  if (thing === void 0) return "void 0";
  if (thing === 0 && 1 / thing < 0) return "-0";
  const str = String(thing);
  if (typeof thing === "number") return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint") return thing + "n";
  return str;
}

// node_modules/devalue/src/base64.js
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i4 = 0; i4 < arraybuffer.byteLength; i4++) {
    binaryString += String.fromCharCode(dv.getUint8(i4));
  }
  return binaryToAscii(binaryString);
}
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i4 = 0; i4 < arraybuffer.byteLength; i4++) {
    dv.setUint8(i4, binaryString.charCodeAt(i4));
  }
  return arraybuffer;
}
var KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i4 = 0; i4 < data.length; i4++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i4]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
function binaryToAscii(str) {
  let out = "";
  for (let i4 = 0; i4 < str.length; i4 += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i4) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i4) & 3) << 4;
    if (str.length > i4 + 1) {
      groupsOfSix[1] |= str.charCodeAt(i4 + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i4 + 1) & 15) << 2;
    }
    if (str.length > i4 + 2) {
      groupsOfSix[2] |= str.charCodeAt(i4 + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i4 + 2) & 63;
    }
    for (let j3 = 0; j3 < groupsOfSix.length; j3++) {
      if (typeof groupsOfSix[j3] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j3]];
      }
    }
  }
  return out;
}

// node_modules/devalue/src/constants.js
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;

// node_modules/devalue/src/parse.js
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate(index6, standalone = false) {
    if (index6 === UNDEFINED) return void 0;
    if (index6 === NAN) return NaN;
    if (index6 === POSITIVE_INFINITY) return Infinity;
    if (index6 === NEGATIVE_INFINITY) return -Infinity;
    if (index6 === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index6 !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index6 in hydrated) return hydrated[index6];
    const value = values[index6];
    if (!value || typeof value !== "object") {
      hydrated[index6] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          let i4 = value[1];
          if (typeof i4 !== "number") {
            i4 = values.push(value[1]) - 1;
          }
          return hydrated[index6] = reviver(hydrate(i4));
        }
        switch (type) {
          case "Date":
            hydrated[index6] = new Date(value[1]);
            break;
          case "Set":
            const set = /* @__PURE__ */ new Set();
            hydrated[index6] = set;
            for (let i4 = 1; i4 < value.length; i4 += 1) {
              set.add(hydrate(value[i4]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index6] = map;
            for (let i4 = 1; i4 < value.length; i4 += 2) {
              map.set(hydrate(value[i4]), hydrate(value[i4 + 1]));
            }
            break;
          case "RegExp":
            hydrated[index6] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index6] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index6] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index6] = obj;
            for (let i4 = 1; i4 < value.length; i4 += 2) {
              obj[value[i4]] = hydrate(value[i4 + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate(value[1]));
            hydrated[index6] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base64 = value[1];
            const arraybuffer = decode64(base64);
            hydrated[index6] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index6] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url = new URL(value[1]);
            hydrated[index6] = url;
            break;
          }
          case "URLSearchParams": {
            const url = new URLSearchParams(value[1]);
            hydrated[index6] = url;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array = new Array(value.length);
        hydrated[index6] = array;
        for (let i4 = 0; i4 < value.length; i4 += 1) {
          const n3 = value[i4];
          if (n3 === HOLE) continue;
          array[i4] = hydrate(n3);
        }
      }
    } else {
      const object = {};
      hydrated[index6] = object;
      for (const key in value) {
        if (key === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n3 = value[key];
        object[key] = hydrate(n3);
      }
    }
    return hydrated[index6];
  }
  return hydrate(0);
}

// node_modules/devalue/src/stringify.js
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  if (reducers) {
    for (const key of Object.getOwnPropertyNames(reducers)) {
      custom2.push({ key, fn: reducers[key] });
    }
  }
  const keys = [];
  let p4 = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index7 = p4++;
    indexes.set(thing, index7);
    for (const { key, fn: fn3 } of custom2) {
      const value2 = fn3(thing);
      if (value2) {
        stringified[index7] = `["${key}",${flatten(value2)}]`;
        return index7;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive2(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive2(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source)},"${flags}"]` : `["RegExp",${stringify_string(source)}]`;
          break;
        case "Array":
          str = "[";
          for (let i4 = 0; i4 < thing.length; i4 += 1) {
            if (i4 > 0) str += ",";
            if (i4 in thing) {
              keys.push(`[${i4}]`);
              str += flatten(thing[i4]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key) ? stringify_primitive2(key) : "..."})`
            );
            str += `,${flatten(key)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a4 = thing.byteOffset;
          const b5 = a4 + thing.byteLength;
          if (a4 > 0 || b5 !== typedArray.buffer.byteLength) {
            const m5 = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a4 / m5},${b5 / m5}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base64 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base64}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key in thing) {
              keys.push(stringify_key(key));
              str += `,${stringify_string(key)},${flatten(thing[key])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key));
              str += `${stringify_string(key)}:${flatten(thing[key])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index7] = str;
    return index7;
  }
  const index6 = flatten(value);
  if (index6 < 0) return `${index6}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive2(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}

// .svelte-kit/output/server/index.js
init_exports();
init_utils();
init_chunks();

// .svelte-kit/output/server/chunks/internal.js
init_context();
init_index2();
init_clsx();
var Rt = {};
function Jt2(s6) {
}
function Kt2(s6) {
  Rt = s6;
}
function Q3(s6) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function Tt() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
var _2 = false;
function R4(s6) {
  _2 = s6;
}
var f3;
function E4(s6) {
  if (s6 === null) throw Q3(), _n;
  return f3 = s6;
}
function Ot2() {
  return E4(Qt(f3));
}
function St2(s6 = 1) {
  if (_2) {
    for (var t3 = s6, e3 = f3; t3--; ) e3 = Qt(e3);
    f3 = e3;
  }
}
function Ct2(s6 = true) {
  for (var t3 = 0, e3 = f3; ; ) {
    if (e3.nodeType === fn) {
      var i4 = e3.data;
      if (i4 === cn) {
        if (t3 === 0) return e3;
        t3 -= 1;
      } else (i4 === an || i4 === on) && (t3 += 1);
    }
    var a4 = Qt(e3);
    s6 && e3.remove(), e3 = a4;
  }
}
function Nt2(s6) {
  let t3 = 0, e3 = Wt(0), i4;
  return () => {
    Tn() && (lt(e3), kn(() => (t3 === 0 && (i4 = $e(() => s6(() => dt(e3)))), t3 += 1, () => {
      Ce(() => {
        t3 -= 1, t3 === 0 && (i4?.(), i4 = void 0, dt(e3));
      });
    })));
  };
}
var Pt = wt | mt | gt;
function Ft3(s6, t3, e3) {
  new At2(s6, t3, e3);
}
var At2 = class {
  parent;
  #e = false;
  #t;
  #g = _2 ? f3 : null;
  #r;
  #u;
  #i;
  #s = null;
  #n = null;
  #a = null;
  #o = null;
  #l = null;
  #f = 0;
  #h = 0;
  #d = false;
  #c = null;
  #y = () => {
    this.#c && Me(this.#c, this.#f);
  };
  #b = Nt2(() => (this.#c = Wt(this.#f), () => {
    this.#c = null;
  }));
  constructor(t3, e3, i4) {
    this.#t = t3, this.#r = e3, this.#u = i4, this.parent = p2.b, this.#e = !!this.#r.pending, this.#i = Sn(() => {
      if (p2.b = this, _2) {
        const n3 = this.#g;
        Ot2(), n3.nodeType === fn && n3.data === on ? this.#E() : this.#w();
      } else {
        var a4 = this.#v();
        try {
          this.#s = An(() => i4(a4));
        } catch (n3) {
          this.error(n3);
        }
        this.#h > 0 ? this.#p() : this.#e = false;
      }
      return () => {
        this.#l?.remove();
      };
    }, Pt), _2 && (this.#t = f3);
  }
  #w() {
    try {
      this.#s = An(() => this.#u(this.#t));
    } catch (t3) {
      this.error(t3);
    }
    this.#e = false;
  }
  #E() {
    const t3 = this.#r.pending;
    t3 && (this.#n = An(() => t3(this.#t)), z.enqueue(() => {
      var e3 = this.#v();
      this.#s = this.#_(() => (z.ensure(), An(() => this.#u(e3)))), this.#h > 0 ? this.#p() : (Be(this.#n, () => {
        this.#n = null;
      }), this.#e = false);
    }));
  }
  #v() {
    var t3 = this.#t;
    return this.#e && (this.#l = gn(), this.#t.before(this.#l), t3 = this.#l), t3;
  }
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#r.pending;
  }
  #_(t3) {
    var e3 = p2, i4 = c3, a4 = H;
    ot(this.#i), X(this.#i), At(this.#i.ctx);
    try {
      return t3();
    } catch (n3) {
      return Fe(n3), null;
    } finally {
      ot(e3), X(i4), At(a4);
    }
  }
  #p() {
    const t3 = this.#r.pending;
    this.#s !== null && (this.#o = document.createDocumentFragment(), this.#o.append(this.#l), Nn(this.#s, this.#o)), this.#n === null && (this.#n = An(() => t3(this.#t)));
  }
  #m(t3) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#m(t3);
      return;
    }
    this.#h += t3, this.#h === 0 && (this.#e = false, this.#n && Be(this.#n, () => {
      this.#n = null;
    }), this.#o && (this.#t.before(this.#o), this.#o = null));
  }
  update_pending_count(t3) {
    this.#m(t3), this.#f += t3, Nt.add(this.#y);
  }
  get_effect_pending() {
    return this.#b(), lt(this.#c);
  }
  error(t3) {
    var e3 = this.#r.onerror;
    let i4 = this.#r.failed;
    if (this.#d || !e3 && !i4) throw t3;
    this.#s && (G(this.#s), this.#s = null), this.#n && (G(this.#n), this.#n = null), this.#a && (G(this.#a), this.#a = null), _2 && (E4(this.#g), St2(), E4(Ct2()));
    var a4 = false, n3 = false;
    const r4 = () => {
      if (a4) {
        Tt();
        return;
      }
      a4 = true, n3 && un(), z.ensure(), this.#f = 0, this.#a !== null && Be(this.#a, () => {
        this.#a = null;
      }), this.#e = this.has_pending_snippet(), this.#s = this.#_(() => (this.#d = false, An(() => this.#u(this.#t)))), this.#h > 0 ? this.#p() : this.#e = false;
    };
    var o5 = c3;
    try {
      X(null), n3 = true, e3?.(t3, r4), n3 = false;
    } catch (c6) {
      Bt(c6, this.#i && this.#i.parent);
    } finally {
      X(o5);
    }
    i4 && Ce(() => {
      this.#a = this.#_(() => {
        z.ensure(), this.#d = true;
        try {
          return An(() => {
            i4(this.#t, () => t3, () => r4);
          });
        } catch (c6) {
          return Bt(c6, this.#i.parent), null;
        } finally {
          this.#d = false;
        }
      });
    });
  }
};
var Dt2 = /* @__PURE__ */ new Set();
var q3 = /* @__PURE__ */ new Set();
var H3 = null;
function T3(s6) {
  var t3 = this, e3 = t3.ownerDocument, i4 = s6.type, a4 = s6.composedPath?.() || [], n3 = a4[0] || s6.target;
  H3 = s6;
  var r4 = 0, o5 = H3 === s6 && s6.__root;
  if (o5) {
    var c6 = a4.indexOf(o5);
    if (c6 !== -1 && (t3 === document || t3 === window)) {
      s6.__root = t3;
      return;
    }
    var d2 = a4.indexOf(t3);
    if (d2 === -1) return;
    c6 <= d2 && (r4 = c6);
  }
  if (n3 = a4[r4] || s6.target, n3 !== t3) {
    en(s6, "currentTarget", { configurable: true, get() {
      return n3 || e3;
    } });
    var b5 = c3, u6 = p2;
    X(null), ot(null);
    try {
      for (var l5, h3 = []; n3 !== null; ) {
        var g3 = n3.assignedSlot || n3.parentNode || n3.host || null;
        try {
          var w3 = n3["__" + i4];
          w3 != null && (!n3.disabled || s6.target === n3) && w3.call(n3, s6);
        } catch (k2) {
          l5 ? h3.push(k2) : l5 = k2;
        }
        if (s6.cancelBubble || g3 === t3 || g3 === null) break;
        n3 = g3;
      }
      if (l5) {
        for (let k2 of h3) queueMicrotask(() => {
          throw k2;
        });
        throw l5;
      }
    } finally {
      s6.__root = t3, delete s6.currentTarget, X(b5), ot(u6);
    }
  }
}
function Lt2(s6, t3) {
  var e3 = p2;
  e3.nodes_start === null && (e3.nodes_start = s6, e3.nodes_end = t3);
}
function X3(s6, t3) {
  return Z3(s6, t3);
}
function Mt2(s6, t3) {
  bn(), t3.intro = t3.intro ?? false;
  const e3 = t3.target, i4 = _2, a4 = f3;
  try {
    for (var n3 = mn(e3); n3 && (n3.nodeType !== fn || n3.data !== an); ) n3 = Qt(n3);
    if (!n3) throw _n;
    R4(true), E4(n3);
    const r4 = Z3(s6, { ...t3, anchor: n3 });
    return R4(false), r4;
  } catch (r4) {
    if (r4 instanceof Error && r4.message.split(`
`).some((o5) => o5.startsWith("https://svelte.dev/e/"))) throw r4;
    return r4 !== _n && console.warn("Failed to hydrate: ", r4), t3.recover === false && ln(), bn(), xn(e3), R4(false), X3(s6, t3);
  } finally {
    R4(i4), E4(a4);
  }
}
var v2 = /* @__PURE__ */ new Map();
function Z3(s6, { target: t3, anchor: e3, props: i4 = {}, events: a4, context: n3, intro: r4 = true }) {
  bn();
  var o5 = /* @__PURE__ */ new Set(), c6 = (u6) => {
    for (var l5 = 0; l5 < u6.length; l5++) {
      var h3 = u6[l5];
      if (!o5.has(h3)) {
        o5.add(h3);
        var g3 = nt2(h3);
        t3.addEventListener(h3, T3, { passive: g3 });
        var w3 = v2.get(h3);
        w3 === void 0 ? (document.addEventListener(h3, T3, { passive: g3 }), v2.set(h3, 1)) : v2.set(h3, w3 + 1);
      }
    }
  };
  c6(tn(Dt2)), q3.add(c6);
  var d2 = void 0, b5 = Rn(() => {
    var u6 = e3 ?? t3.appendChild(gn());
    return Ft3(u6, { pending: () => {
    } }, (l5) => {
      if (n3) {
        dn({});
        var h3 = H;
        h3.c = n3;
      }
      if (a4 && (i4.$$events = a4), _2 && Lt2(l5, null), d2 = s6(l5, i4) || {}, _2 && (p2.nodes_end = f3, f3 === null || f3.nodeType !== fn || f3.data !== cn)) throw Q3(), _n;
      n3 && wn();
    }), () => {
      for (var l5 of o5) {
        t3.removeEventListener(l5, T3);
        var h3 = v2.get(l5);
        --h3 === 0 ? (document.removeEventListener(l5, T3), v2.delete(l5)) : v2.set(l5, h3);
      }
      q3.delete(c6), u6 !== e3 && u6.parentNode?.removeChild(u6);
    };
  });
  return M3.set(d2, b5), d2;
}
var M3 = /* @__PURE__ */ new WeakMap();
function Bt2(s6, t3) {
  const e3 = M3.get(s6);
  return e3 ? (M3.delete(s6), e3(t3)) : Promise.resolve();
}
function It2(s6) {
  return class extends jt2 {
    constructor(t3) {
      super({ component: s6, ...t3 });
    }
  };
}
var jt2 = class {
  #e;
  #t;
  constructor(t3) {
    var e3 = /* @__PURE__ */ new Map(), i4 = (n3, r4) => {
      var o5 = yn(r4, false, false);
      return e3.set(n3, o5), o5;
    };
    const a4 = new Proxy({ ...t3.props || {}, $$events: {} }, { get(n3, r4) {
      return lt(e3.get(r4) ?? i4(r4, Reflect.get(n3, r4)));
    }, has(n3, r4) {
      return r4 === rn ? true : (lt(e3.get(r4) ?? i4(r4, Reflect.get(n3, r4))), Reflect.has(n3, r4));
    }, set(n3, r4, o5) {
      return L(e3.get(r4) ?? i4(r4, o5), o5), Reflect.set(n3, r4, o5);
    } });
    this.#t = (t3.hydrate ? Mt2 : X3)(t3.component, { target: t3.target, anchor: t3.anchor, props: a4, context: t3.context, intro: t3.intro ?? false, recover: t3.recover }), (!t3?.props?.$$host || t3.sync === false) && En(), this.#e = a4.$$events;
    for (const n3 of Object.keys(this.#t)) n3 === "$set" || n3 === "$destroy" || n3 === "$on" || en(this, n3, { get() {
      return this.#t[n3];
    }, set(r4) {
      this.#t[n3] = r4;
    }, enumerable: true });
    this.#t.$set = (n3) => {
      Object.assign(a4, n3);
    }, this.#t.$destroy = () => {
      Bt2(this.#t);
    };
  }
  $set(t3) {
    this.#t.$set(t3);
  }
  $on(t3, e3) {
    this.#e[t3] = this.#e[t3] || [];
    const i4 = (...a4) => e3.call(this, ...a4);
    return this.#e[t3].push(i4), () => {
      this.#e[t3] = this.#e[t3].filter((a4) => a4 !== i4);
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
};
var qt2 = null;
function Qt2(s6) {
  qt2 = s6;
}
function Ht2(s6) {
  const t3 = It2(s6), e3 = (i4, { context: a4 } = {}) => {
    const n3 = ot2(s6, { props: i4, context: a4 }), r4 = Object.defineProperties({}, { css: { value: { code: "", map: null } }, head: { get: () => n3.head }, html: { get: () => n3.body }, then: { value: (o5, c6) => {
      {
        const d2 = o5({ css: r4.css, head: r4.head, html: r4.html });
        return Promise.resolve(d2);
      }
    } } });
    return r4;
  };
  return t3.render = e3, t3;
}
function Yt2(s6, t3) {
  s6.component((e3) => {
    let { stores: i4, page: a4, constructors: n3, components: r4 = [], form: o5, data_0: c6 = null, data_1: d2 = null } = t3;
    In("__svelte__", i4), i4.page.set(a4);
    const b5 = n3[1];
    if (n3[1]) {
      e3.push("<!--[-->");
      const u6 = n3[0];
      e3.push("<!---->"), u6(e3, { data: c6, form: o5, params: a4.params, children: (l5) => {
        l5.push("<!---->"), b5(l5, { data: d2, form: o5, params: a4.params }), l5.push("<!---->");
      }, $$slots: { default: true } }), e3.push("<!---->");
    } else {
      e3.push("<!--[!-->");
      const u6 = n3[0];
      e3.push("<!---->"), u6(e3, { data: c6, form: o5, params: a4.params }), e3.push("<!---->");
    }
    e3.push("<!--]--> "), e3.push("<!--[!-->"), e3.push("<!--]-->");
  });
}
var Ut2 = Ht2(Yt2);
var Zt2 = { app_template_contains_nonce: false, async: false, csp: { mode: "auto", directives: { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, reportOnly: { "upgrade-insecure-requests": false, "block-all-mixed-content": false } }, csrf_check_origin: true, csrf_trusted_origins: [], embedded: false, env_public_prefix: "PUBLIC_", env_private_prefix: "", hash_routing: false, hooks: null, preload_strategy: "modulepreload", root: Ut2, service_worker: false, service_worker_options: void 0, templates: { app: ({ head: s6, body: t3, assets: e3, nonce: i4, env: a4 }) => `<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="icon" href="/favicon.ico" sizes="any" />
		<link rel="icon" type="image/png" href="/favicon.png" />
		` + s6 + `
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">` + t3 + `</div>
	</body>
</html>
`, error: ({ status: s6, message: t3 }) => `<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>` + t3 + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + s6 + `</span>
			<div class="message">
				<h1>` + t3 + `</h1>
			</div>
		</div>
	</body>
</html>
` }, version_hash: "6b5124" };
async function $t2() {
  return { handle: void 0, handleFetch: void 0, handleError: void 0, handleValidationError: void 0, init: void 0, reroute: void 0, transport: void 0 };
}

// .svelte-kit/output/server/chunks/shared.js
init_utils();
var f4 = "x-sveltekit-invalidated";
var p3 = "x-sveltekit-trailing-slash";
function l4(e3, t3) {
  const r4 = Object.fromEntries(Object.entries(t3).map(([n3, s6]) => [n3, s6.encode]));
  return stringify(e3, r4);
}
function u(e3, t3) {
  if (!e3) return;
  const r4 = i2.decode(l2(e3.replaceAll("-", "+").replaceAll("_", "/"))), n3 = Object.fromEntries(Object.entries(t3).map(([s6, o5]) => [s6, o5.decode]));
  return parse(r4, n3);
}
function m3(e3, t3) {
  return e3 + "/" + t3;
}

// .svelte-kit/output/server/index.js
var import_cookie = __toESM(require_cookie(), 1);
var Ze2 = __toESM(require_set_cookie(), 1);
function ht2() {
  let e3, t3;
  return { promise: new Promise((n3, s6) => {
    e3 = n3, t3 = s6;
  }), resolve: e3, reject: t3 };
}
var ir = [101, 103, 204, 205, 304];
var cr = !!globalThis.process?.versions?.webcontainer;
var lr = "/_svelte_kit_assets";
var _t2 = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var dr = ["GET", "POST", "HEAD"];
function Ne2(e3, t3) {
  const r4 = [];
  e3.split(",").forEach((a4, o5) => {
    const i4 = /([^/ \t]+)\/([^; \t]+)[ \t]*(?:;[ \t]*q=([0-9.]+))?/.exec(a4);
    if (i4) {
      const [, c6, d2, l5 = "1"] = i4;
      r4.push({ type: c6, subtype: d2, q: +l5, i: o5 });
    }
  }), r4.sort((a4, o5) => a4.q !== o5.q ? o5.q - a4.q : a4.subtype === "*" != (o5.subtype === "*") ? a4.subtype === "*" ? 1 : -1 : a4.type === "*" != (o5.type === "*") ? a4.type === "*" ? 1 : -1 : a4.i - o5.i);
  let n3, s6 = 1 / 0;
  for (const a4 of t3) {
    const [o5, i4] = a4.split("/"), c6 = r4.findIndex((d2) => (d2.type === o5 || d2.type === "*") && (d2.subtype === i4 || d2.subtype === "*"));
    c6 !== -1 && c6 < s6 && (n3 = a4, s6 = c6);
  }
  return n3;
}
function ur(e3, ...t3) {
  const r4 = e3.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return t3.includes(r4.toLowerCase());
}
function He2(e3) {
  return ur(e3, "application/x-www-form-urlencoded", "multipart/form-data", "text/plain");
}
function fr(e3) {
  return e3 instanceof Error || e3 && e3.name && e3.message ? e3 : new Error(JSON.stringify(e3));
}
function ae2(e3) {
  return e3 instanceof HttpError || e3 instanceof SvelteKitError ? e3.status : 500;
}
function pr(e3) {
  return e3 instanceof SvelteKitError ? e3.text : "Internal Error";
}
var mt2 = { "&": "&amp;", '"': "&quot;" };
var yt2 = { "&": "&amp;", "<": "&lt;" };
var gt2 = "[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]";
var hr = new RegExp(`[${Object.keys(mt2).join("")}]|` + gt2, "g");
var _r = new RegExp(`[${Object.keys(yt2).join("")}]|` + gt2, "g");
function Ie2(e3, t3) {
  const r4 = t3 ? mt2 : yt2;
  return e3.replace(t3 ? hr : _r, (s6) => s6.length === 2 ? s6 : r4[s6] ?? `&#${s6.charCodeAt(0)};`);
}
function wt2(e3, t3) {
  return text(`${t3} method not allowed`, { status: 405, headers: { allow: mr(e3).join(", ") } });
}
function mr(e3) {
  const t3 = _t2.filter((r4) => r4 in e3);
  return "GET" in e3 && !("HEAD" in e3) && t3.push("HEAD"), t3;
}
function bt2(e3) {
  return `__sveltekit_${e3.version_hash}`;
}
function ye2(e3, t3, r4) {
  let n3 = e3.templates.error({ status: t3, message: Ie2(r4) });
  return text(n3, { headers: { "content-type": "text/html; charset=utf-8" }, status: t3 });
}
async function et3(e3, t3, r4, n3) {
  n3 = n3 instanceof HttpError ? n3 : fr(n3);
  const s6 = ae2(n3), a4 = await D2(e3, t3, r4, n3), o5 = Ne2(e3.request.headers.get("accept") || "text/html", ["application/json", "text/html"]);
  return e3.isDataRequest || o5 === "application/json" ? json(a4, { status: s6 }) : ye2(r4, s6, a4.message);
}
async function D2(e3, t3, r4, n3) {
  if (n3 instanceof HttpError) return { message: "Unknown Error", ...n3.body };
  const s6 = ae2(n3), a4 = pr(n3);
  return await with_request_store({ event: e3, state: t3 }, () => r4.hooks.handleError({ error: n3, event: e3, status: s6, message: a4 })) ?? { message: a4 };
}
function ge2(e3, t3) {
  return new Response(void 0, { status: e3, headers: { location: t3 } });
}
function kt2(e3, t3) {
  return t3.path ? `Data returned from \`load\` while rendering ${e3.route.id} is not serializable: ${t3.message} (${t3.path}). If you need to serialize/deserialize custom types, use transport hooks: https://svelte.dev/docs/kit/hooks#Universal-hooks-transport.` : t3.path === "" ? `Data returned from \`load\` while rendering ${e3.route.id} is not a plain object` : t3.message;
}
function $t3(e3) {
  const t3 = {};
  return e3.uses && e3.uses.dependencies.size > 0 && (t3.dependencies = Array.from(e3.uses.dependencies)), e3.uses && e3.uses.search_params.size > 0 && (t3.search_params = Array.from(e3.uses.search_params)), e3.uses && e3.uses.params.size > 0 && (t3.params = Array.from(e3.uses.params)), e3.uses?.parent && (t3.parent = 1), e3.uses?.route && (t3.route = 1), e3.uses?.url && (t3.url = 1), t3;
}
function vt(e3, t3) {
  return e3._.prerendered_routes.has(t3) || t3.at(-1) === "/" && e3._.prerendered_routes.has(t3.slice(0, -1));
}
function yr(e3, t3, r4) {
  const n3 = `
\x1B[1;31m[${e3}] ${r4.request.method} ${r4.url.pathname}\x1B[0m`;
  return e3 === 404 ? n3 : `${n3}
${t3.stack}`;
}
function xt2(e3) {
  const r4 = e3?.split("/")?.at(-1);
  return r4 ? r4.split(".").slice(0, -1).join(".") : "unknown";
}
async function gr(e3, t3, r4, n3) {
  const s6 = e3.request.method;
  let a4 = r4[s6] || r4.fallback;
  if (s6 === "HEAD" && !r4.HEAD && r4.GET && (a4 = r4.GET), !a4) return wt2(r4, s6);
  const o5 = r4.prerender ?? n3.prerender_default;
  if (o5 && (r4.POST || r4.PATCH || r4.PUT || r4.DELETE)) throw new Error("Cannot prerender endpoints that have mutative methods");
  if (n3.prerendering && !n3.prerendering.inside_reroute && !o5) {
    if (n3.depth > 0) throw new Error(`${e3.route.id} is not prerenderable`);
    return new Response(void 0, { status: 204 });
  }
  t3.is_endpoint_request = true;
  try {
    const i4 = await with_request_store({ event: e3, state: t3 }, () => a4(e3));
    if (!(i4 instanceof Response)) throw new Error(`Invalid response from route ${e3.url.pathname}: handler should return a Response object`);
    if (n3.prerendering && (!n3.prerendering.inside_reroute || o5)) {
      const c6 = new Response(i4.clone().body, { status: i4.status, statusText: i4.statusText, headers: new Headers(i4.headers) });
      if (c6.headers.set("x-sveltekit-prerender", String(o5)), n3.prerendering.inside_reroute && o5) c6.headers.set("x-sveltekit-routeid", encodeURI(e3.route.id)), n3.prerendering.dependencies.set(e3.url.pathname, { response: c6, body: null });
      else return c6;
    }
    return i4;
  } catch (i4) {
    if (i4 instanceof Redirect) return new Response(void 0, { status: i4.status, headers: { location: i4.location } });
    throw i4;
  }
}
function wr(e3) {
  const { method: t3, headers: r4 } = e3.request;
  if (_t2.includes(t3) && !dr.includes(t3)) return true;
  if (t3 === "POST" && r4.get("x-sveltekit-action") === "true") return false;
  const n3 = e3.request.headers.get("accept") ?? "*/*";
  return Ne2(n3, ["*", "text/html"]) !== "text/html";
}
function Oe2(e3) {
  return e3.filter((t3) => t3 != null);
}
var Le2 = "/__data.json";
var we2 = ".html__data.json";
function br(e3) {
  return e3.endsWith(Le2) || e3.endsWith(we2);
}
function De2(e3) {
  return e3.endsWith(".html") ? e3.replace(/\.html$/, we2) : e3.replace(/\/$/, "") + Le2;
}
function kr(e3) {
  return e3.endsWith(we2) ? e3.slice(0, -we2.length) + ".html" : e3.slice(0, -Le2.length);
}
var We2 = "/__route.js";
function $r(e3) {
  return e3.endsWith(We2);
}
function Et3(e3) {
  return e3.replace(/\/$/, "") + We2;
}
function vr(e3) {
  return e3.slice(0, -We2.length);
}
var xr = { spanContext() {
  return Er;
}, setAttribute() {
  return this;
}, setAttributes() {
  return this;
}, addEvent() {
  return this;
}, setStatus() {
  return this;
}, updateName() {
  return this;
}, end() {
  return this;
}, isRecording() {
  return false;
}, recordException() {
  return this;
}, addLink() {
  return this;
}, addLinks() {
  return this;
} };
var Er = { traceId: "", spanId: "", traceFlags: 0 };
async function ee2({ name: e3, attributes: t3, fn: r4 }) {
  return r4(xr);
}
function Rt2(e3) {
  return Ne2(e3.request.headers.get("accept") ?? "*/*", ["application/json", "text/html"]) === "application/json" && e3.request.method === "POST";
}
async function Rr(e3, t3, r4, n3) {
  const s6 = n3?.actions;
  if (!s6) {
    const a4 = new SvelteKitError(405, "Method Not Allowed", "POST method not allowed. No form actions exist for this page");
    return le2({ type: "error", error: await D2(e3, t3, r4, a4) }, { status: a4.status, headers: { allow: "GET" } });
  }
  St3(s6);
  try {
    const a4 = await Tt2(e3, t3, s6);
    return a4 instanceof ActionFailure ? le2({ type: "failure", status: a4.status, data: tt3(a4.data, e3.route.id, r4.hooks.transport) }) : le2({ type: "success", status: a4 ? 200 : 204, data: tt3(a4, e3.route.id, r4.hooks.transport) });
  } catch (a4) {
    const o5 = a4;
    return o5 instanceof Redirect ? jt3(o5) : le2({ type: "error", error: await D2(e3, t3, r4, Me2(o5)) }, { status: ae2(o5) });
  }
}
function Me2(e3) {
  return e3 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : e3;
}
function jt3(e3) {
  return le2({ type: "redirect", status: e3.status, location: e3.location });
}
function le2(e3, t3) {
  return json(e3, t3);
}
function jr(e3) {
  return e3.request.method === "POST";
}
async function Sr(e3, t3, r4) {
  const n3 = r4?.actions;
  if (!n3) return e3.setHeaders({ allow: "GET" }), { type: "error", error: new SvelteKitError(405, "Method Not Allowed", "POST method not allowed. No form actions exist for this page") };
  St3(n3);
  try {
    const s6 = await Tt2(e3, t3, n3);
    return s6 instanceof ActionFailure ? { type: "failure", status: s6.status, data: s6.data } : { type: "success", status: 200, data: s6 };
  } catch (s6) {
    const a4 = s6;
    return a4 instanceof Redirect ? { type: "redirect", status: a4.status, location: a4.location } : { type: "error", error: Me2(a4) };
  }
}
function St3(e3) {
  if (e3.default && Object.keys(e3).length > 1) throw new Error("When using named actions, the default action cannot be used. See the docs for more info: https://svelte.dev/docs/kit/form-actions#named-actions");
}
async function Tt2(e3, t3, r4) {
  const n3 = new URL(e3.request.url);
  let s6 = "default";
  for (const o5 of n3.searchParams) if (o5[0].startsWith("/")) {
    if (s6 = o5[0].slice(1), s6 === "default") throw new Error('Cannot use reserved action name "default"');
    break;
  }
  const a4 = r4[s6];
  if (!a4) throw new SvelteKitError(404, "Not Found", `No action with name '${s6}' found`);
  if (!He2(e3.request)) throw new SvelteKitError(415, "Unsupported Media Type", `Form actions expect form-encoded data \u2014 received ${e3.request.headers.get("content-type")}`);
  return ee2({ name: "sveltekit.form_action", attributes: { "http.route": e3.route.id || "unknown" }, fn: async (o5) => {
    const i4 = merge_tracing(e3, o5), c6 = await with_request_store({ event: i4, state: t3 }, () => a4(i4));
    return c6 instanceof ActionFailure && o5.setAttributes({ "sveltekit.form_action.result.type": "failure", "sveltekit.form_action.result.status": c6.status }), c6;
  } });
}
function Tr(e3, t3, r4) {
  const n3 = (s6) => {
    for (const a4 in r4) {
      const o5 = r4[a4].encode(s6);
      if (o5) return `app.decode('${a4}', ${uneval(o5, n3)})`;
    }
  };
  return At3(e3, (s6) => uneval(s6, n3), t3);
}
function tt3(e3, t3, r4) {
  const n3 = Object.fromEntries(Object.entries(r4).map(([s6, a4]) => [s6, a4.encode]));
  return At3(e3, (s6) => stringify(s6, n3), t3);
}
function At3(e3, t3, r4) {
  try {
    return t3(e3);
  } catch (n3) {
    const s6 = n3;
    if (e3 instanceof Response) throw new Error(`Data returned from action inside ${r4} is not serializable. Form actions need to return plain objects or fail(). E.g. return { success: true } or return fail(400, { message: "invalid" });`);
    if ("path" in s6) {
      let a4 = `Data returned from action inside ${r4} is not serializable: ${s6.message}`;
      throw s6.path !== "" && (a4 += ` (data.${s6.path})`), new Error(a4);
    }
    throw s6;
  }
}
function Ot3() {
  let e3 = -1, t3 = -1;
  const r4 = [];
  return { iterate: (n3 = (s6) => s6) => ({ [Symbol.asyncIterator]() {
    return { next: async () => {
      const s6 = r4[++t3];
      if (!s6) return { value: null, done: true };
      const a4 = await s6.promise;
      return { value: n3(a4), done: false };
    } };
  } }), add: (n3) => {
    r4.push(ht2()), n3.then((s6) => {
      r4[++e3].resolve(s6);
    });
  } };
}
function de2(e3, t3, r4) {
  let n3 = 1, s6 = -1;
  const a4 = Ot3(), o5 = bt2(r4);
  function i4(d2) {
    return function l5(h3) {
      if (typeof h3?.then == "function") {
        const b5 = n3++, p4 = h3.then((f5) => ({ data: f5 })).catch(async (f5) => ({ error: await D2(e3, t3, r4, f5) })).then(async ({ data: f5, error: u6 }) => {
          let _3;
          try {
            _3 = uneval(u6 ? [, u6] : [f5], l5);
          } catch {
            u6 = await D2(e3, t3, r4, new Error(`Failed to serialize promise while rendering ${e3.route.id}`)), f5 = void 0, _3 = uneval([, u6], l5);
          }
          return { index: d2, str: `${o5}.resolve(${b5}, ${_3.includes("app.decode") ? `(app) => ${_3}` : `() => ${_3}`})` };
        });
        return a4.add(p4), `${o5}.defer(${b5})`;
      } else for (const b5 in r4.hooks.transport) {
        const p4 = r4.hooks.transport[b5].encode(h3);
        if (p4) return `app.decode('${b5}', ${uneval(p4, l5)})`;
      }
    };
  }
  const c6 = [];
  return { set_max_nodes(d2) {
    s6 = d2;
  }, add_node(d2, l5) {
    try {
      if (!l5) {
        c6[d2] = "null";
        return;
      }
      const h3 = { type: "data", data: l5.data, uses: $t3(l5) };
      l5.slash && (h3.slash = l5.slash), c6[d2] = uneval(h3, i4(d2));
    } catch (h3) {
      throw h3.path = h3.path.slice(1), new Error(kt2(e3, h3));
    }
  }, get_data(d2) {
    const l5 = `<script${d2.script_needs_nonce ? ` nonce="${d2.nonce}"` : ""}>`, h3 = `<\/script>
`;
    return { data: `[${Oe2(s6 > -1 ? c6.slice(0, s6) : c6).join(",")}]`, chunks: n3 > 1 ? a4.iterate(({ index: b5, str: p4 }) => s6 > -1 && b5 >= s6 ? "" : l5 + p4 + h3) : null };
  } };
}
function qt3(e3, t3, r4) {
  let n3 = 1;
  const s6 = Ot3(), a4 = { ...Object.fromEntries(Object.entries(r4.hooks.transport).map(([i4, c6]) => [i4, c6.encode])), Promise: (i4) => {
    if (typeof i4?.then != "function") return;
    const c6 = n3++;
    let d2 = "data";
    const l5 = i4.catch(async (h3) => (d2 = "error", D2(e3, t3, r4, h3))).then(async (h3) => {
      let b5;
      try {
        b5 = stringify(h3, a4);
      } catch {
        const p4 = await D2(e3, t3, r4, new Error(`Failed to serialize promise while rendering ${e3.route.id}`));
        d2 = "error", b5 = stringify(p4, a4);
      }
      return `{"type":"chunk","id":${c6},"${d2}":${b5}}
`;
    });
    return s6.add(l5), c6;
  } }, o5 = [];
  return { add_node(i4, c6) {
    try {
      if (!c6) {
        o5[i4] = "null";
        return;
      }
      if (c6.type === "error" || c6.type === "skip") {
        o5[i4] = JSON.stringify(c6);
        return;
      }
      o5[i4] = `{"type":"data","data":${stringify(c6.data, a4)},"uses":${JSON.stringify($t3(c6))}${c6.slash ? `,"slash":${JSON.stringify(c6.slash)}` : ""}}`;
    } catch (d2) {
      throw d2.path = "data" + d2.path, new Error(kt2(e3, d2));
    }
  }, get_data() {
    return { data: `{"type":"data","nodes":[${o5.join(",")}]}
`, chunks: n3 > 1 ? s6.iterate() : null };
  } };
}
async function Fe2({ event: e3, event_state: t3, state: r4, node: n3, parent: s6 }) {
  if (!n3?.server) return null;
  let a4 = true;
  const o5 = { dependencies: /* @__PURE__ */ new Set(), params: /* @__PURE__ */ new Set(), parent: false, route: false, url: false, search_params: /* @__PURE__ */ new Set() }, i4 = n3.server.load, c6 = n3.server.trailingSlash;
  if (!i4) return { type: "data", data: null, uses: o5, slash: c6 };
  const d2 = y(e3.url, () => {
    a4 && (o5.url = true);
  }, (h3) => {
    a4 && o5.search_params.add(h3);
  });
  return r4.prerendering && j(d2), { type: "data", data: await ee2({ name: "sveltekit.load", attributes: { "sveltekit.load.node_id": n3.server_id || "unknown", "sveltekit.load.node_type": xt2(n3.server_id), "http.route": e3.route.id || "unknown" }, fn: async (h3) => {
    const b5 = merge_tracing(e3, h3);
    return await with_request_store({ event: b5, state: t3 }, () => i4.call(null, { ...b5, fetch: (f5, u6) => (new URL(f5 instanceof Request ? f5.url : f5, e3.url), e3.fetch(f5, u6)), depends: (...f5) => {
      for (const u6 of f5) {
        const { href: _3 } = new URL(u6, e3.url);
        o5.dependencies.add(_3);
      }
    }, params: new Proxy(e3.params, { get: (f5, u6) => (a4 && o5.params.add(u6), f5[u6]) }), parent: async () => (a4 && (o5.parent = true), s6()), route: new Proxy(e3.route, { get: (f5, u6) => (a4 && (o5.route = true), f5[u6]) }), url: d2, untrack(f5) {
      a4 = false;
      try {
        return f5();
      } finally {
        a4 = true;
      }
    } }));
  } }) ?? null, uses: o5, slash: c6 };
}
async function Pt2({ event: e3, event_state: t3, fetched: r4, node: n3, parent: s6, server_data_promise: a4, state: o5, resolve_opts: i4, csr: c6 }) {
  const d2 = await a4, l5 = n3?.universal?.load;
  return l5 ? await ee2({ name: "sveltekit.load", attributes: { "sveltekit.load.node_id": n3.universal_id || "unknown", "sveltekit.load.node_type": xt2(n3.universal_id), "http.route": e3.route.id || "unknown" }, fn: async (b5) => {
    const p4 = merge_tracing(e3, b5);
    return await with_request_store({ event: p4, state: t3 }, () => l5.call(null, { url: e3.url, params: e3.params, data: d2?.data ?? null, route: e3.route, fetch: Ar(e3, o5, r4, c6, i4), setHeaders: e3.setHeaders, depends: () => {
    }, parent: s6, untrack: (f5) => f5(), tracing: p4.tracing }));
  } }) ?? null : d2?.data ?? null;
}
function Ar(e3, t3, r4, n3, s6) {
  const a4 = async (o5, i4) => {
    const c6 = o5 instanceof Request && o5.body ? o5.clone().body : null, d2 = o5 instanceof Request && [...o5.headers].length ? new Headers(o5.headers) : i4?.headers;
    let l5 = await e3.fetch(o5, i4);
    const h3 = new URL(o5 instanceof Request ? o5.url : o5, e3.url), b5 = h3.origin === e3.url.origin;
    let p4;
    if (b5) t3.prerendering && (p4 = { response: l5, body: null }, t3.prerendering.dependencies.set(h3.pathname, p4));
    else if (h3.protocol === "https:" || h3.protocol === "http:") if ((o5 instanceof Request ? o5.mode : i4?.mode ?? "cors") === "no-cors") l5 = new Response("", { status: l5.status, statusText: l5.statusText, headers: l5.headers });
    else {
      const y4 = l5.headers.get("access-control-allow-origin");
      if (!y4 || y4 !== e3.url.origin && y4 !== "*") throw new Error(`CORS error: ${y4 ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`);
    }
    let f5;
    const u6 = new Proxy(l5, { get(_3, y4, $4) {
      async function j3(x5, m5) {
        const g3 = Number(_3.status);
        if (isNaN(g3)) throw new Error(`response.status is not a number. value: "${_3.status}" type: ${typeof _3.status}`);
        r4.push({ url: b5 ? h3.href.slice(e3.url.origin.length) : h3.href, method: e3.request.method, request_body: o5 instanceof Request && c6 ? await Or(c6) : i4?.body, request_headers: d2, response_body: x5, response: _3, is_b64: m5 });
      }
      if (y4 === "body") {
        if (_3.body === null) return null;
        if (f5) return f5;
        const [x5, m5] = _3.body.tee();
        return (async () => {
          let g3 = new Uint8Array();
          for await (const w3 of x5) {
            const k2 = new Uint8Array(g3.length + w3.length);
            k2.set(g3, 0), k2.set(w3, g3.length), g3 = k2;
          }
          p4 && (p4.body = new Uint8Array(g3)), j3(f2(g3), true);
        })(), f5 = m5;
      }
      if (y4 === "arrayBuffer") return async () => {
        const x5 = await _3.arrayBuffer(), m5 = new Uint8Array(x5);
        return p4 && (p4.body = m5), x5 instanceof ArrayBuffer && await j3(f2(m5), true), x5;
      };
      async function v4() {
        const x5 = await _3.text();
        if (x5 === "" && ir.includes(_3.status)) {
          await j3(void 0, false);
          return;
        }
        return (!x5 || typeof x5 == "string") && await j3(x5, false), p4 && (p4.body = x5), x5;
      }
      return y4 === "text" ? v4 : y4 === "json" ? async () => {
        const x5 = await v4();
        return x5 ? JSON.parse(x5) : void 0;
      } : Reflect.get(_3, y4, _3);
    } });
    if (n3) {
      const _3 = l5.headers.get;
      l5.headers.get = (y4) => {
        const $4 = y4.toLowerCase(), j3 = _3.call(l5.headers, $4);
        if (j3 && !$4.startsWith("x-sveltekit-") && !s6.filterSerializedResponseHeaders($4, j3)) throw new Error(`Failed to get response header "${$4}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://svelte.dev/docs/kit/hooks#Server-hooks-handle (at ${e3.route.id})`);
        return j3;
      };
    }
    return u6;
  };
  return (o5, i4) => {
    const c6 = a4(o5, i4);
    return c6.catch(() => {
    }), c6;
  };
}
async function Or(e3) {
  let t3 = "";
  const r4 = e3.getReader();
  for (; ; ) {
    const { done: n3, value: s6 } = await r4.read();
    if (n3) break;
    t3 += i2.decode(s6);
  }
  return t3;
}
function Ct3(...e3) {
  let t3 = 5381;
  for (const r4 of e3) if (typeof r4 == "string") {
    let n3 = r4.length;
    for (; n3; ) t3 = t3 * 33 ^ r4.charCodeAt(--n3);
  } else if (ArrayBuffer.isView(r4)) {
    const n3 = new Uint8Array(r4.buffer, r4.byteOffset, r4.byteLength);
    let s6 = n3.length;
    for (; s6; ) t3 = t3 * 33 ^ n3[--s6];
  } else throw new TypeError("value must be a string or TypedArray");
  return (t3 >>> 0).toString(36);
}
var zt2 = { "<": "\\u003C", "\u2028": "\\u2028", "\u2029": "\\u2029" };
var qr = new RegExp(`[${Object.keys(zt2).join("")}]`, "g");
function Pr(e3, t3, r4 = false) {
  const n3 = {};
  let s6 = null, a4 = null, o5 = false;
  for (const [l5, h3] of e3.response.headers) t3(l5, h3) && (n3[l5] = h3), l5 === "cache-control" ? s6 = h3 : l5 === "age" ? a4 = h3 : l5 === "vary" && h3.trim() === "*" && (o5 = true);
  const i4 = { status: e3.response.status, statusText: e3.response.statusText, headers: n3, body: e3.response_body }, c6 = JSON.stringify(i4).replace(qr, (l5) => zt2[l5]), d2 = ['type="application/json"', "data-sveltekit-fetched", `data-url="${Ie2(e3.url, true)}"`];
  if (e3.is_b64 && d2.push("data-b64"), e3.request_headers || e3.request_body) {
    const l5 = [];
    e3.request_headers && l5.push([...new Headers(e3.request_headers)].join(",")), e3.request_body && l5.push(e3.request_body), d2.push(`data-hash="${Ct3(...l5)}"`);
  }
  if (!r4 && e3.method === "GET" && s6 && !o5) {
    const l5 = /s-maxage=(\d+)/g.exec(s6) ?? /max-age=(\d+)/g.exec(s6);
    if (l5) {
      const h3 = +l5[1] - +(a4 ?? "0");
      d2.push(`data-ttl="${h3}"`);
    }
  }
  return `<script ${d2.join(" ")}>${c6}<\/script>`;
}
var H4 = JSON.stringify;
function rt3(e3) {
  qe2[0] || Cr();
  const t3 = Ut3.slice(0), r4 = zr(e3);
  for (let s6 = 0; s6 < r4.length; s6 += 16) {
    const a4 = r4.subarray(s6, s6 + 16);
    let o5, i4, c6, d2 = t3[0], l5 = t3[1], h3 = t3[2], b5 = t3[3], p4 = t3[4], f5 = t3[5], u6 = t3[6], _3 = t3[7];
    for (let y4 = 0; y4 < 64; y4++) y4 < 16 ? o5 = a4[y4] : (i4 = a4[y4 + 1 & 15], c6 = a4[y4 + 14 & 15], o5 = a4[y4 & 15] = (i4 >>> 7 ^ i4 >>> 18 ^ i4 >>> 3 ^ i4 << 25 ^ i4 << 14) + (c6 >>> 17 ^ c6 >>> 19 ^ c6 >>> 10 ^ c6 << 15 ^ c6 << 13) + a4[y4 & 15] + a4[y4 + 9 & 15] | 0), o5 = o5 + _3 + (p4 >>> 6 ^ p4 >>> 11 ^ p4 >>> 25 ^ p4 << 26 ^ p4 << 21 ^ p4 << 7) + (u6 ^ p4 & (f5 ^ u6)) + qe2[y4], _3 = u6, u6 = f5, f5 = p4, p4 = b5 + o5 | 0, b5 = h3, h3 = l5, l5 = d2, d2 = o5 + (l5 & h3 ^ b5 & (l5 ^ h3)) + (l5 >>> 2 ^ l5 >>> 13 ^ l5 >>> 22 ^ l5 << 30 ^ l5 << 19 ^ l5 << 10) | 0;
    t3[0] = t3[0] + d2 | 0, t3[1] = t3[1] + l5 | 0, t3[2] = t3[2] + h3 | 0, t3[3] = t3[3] + b5 | 0, t3[4] = t3[4] + p4 | 0, t3[5] = t3[5] + f5 | 0, t3[6] = t3[6] + u6 | 0, t3[7] = t3[7] + _3 | 0;
  }
  const n3 = new Uint8Array(t3.buffer);
  return Nt3(n3), btoa(String.fromCharCode(...n3));
}
var Ut3 = new Uint32Array(8);
var qe2 = new Uint32Array(64);
function Cr() {
  function e3(r4) {
    return (r4 - Math.floor(r4)) * 4294967296;
  }
  let t3 = 2;
  for (let r4 = 0; r4 < 64; t3++) {
    let n3 = true;
    for (let s6 = 2; s6 * s6 <= t3; s6++) if (t3 % s6 === 0) {
      n3 = false;
      break;
    }
    n3 && (r4 < 8 && (Ut3[r4] = e3(t3 ** (1 / 2))), qe2[r4] = e3(t3 ** (1 / 3)), r4++);
  }
}
function Nt3(e3) {
  for (let t3 = 0; t3 < e3.length; t3 += 4) {
    const r4 = e3[t3 + 0], n3 = e3[t3 + 1], s6 = e3[t3 + 2], a4 = e3[t3 + 3];
    e3[t3 + 0] = a4, e3[t3 + 1] = s6, e3[t3 + 2] = n3, e3[t3 + 3] = r4;
  }
}
function zr(e3) {
  const t3 = a2.encode(e3), r4 = t3.length * 8, n3 = 512 * Math.ceil((r4 + 65) / 512), s6 = new Uint8Array(n3 / 8);
  s6.set(t3), s6[t3.length] = 128, Nt3(s6);
  const a4 = new Uint32Array(s6.buffer);
  return a4[a4.length - 2] = Math.floor(r4 / 4294967296), a4[a4.length - 1] = r4, a4;
}
var nt3 = new Uint8Array(16);
function Ur() {
  return crypto.getRandomValues(nt3), btoa(String.fromCharCode(...nt3));
}
var Nr = /* @__PURE__ */ new Set(["self", "unsafe-eval", "unsafe-hashes", "unsafe-inline", "none", "strict-dynamic", "report-sample", "wasm-unsafe-eval", "script"]);
var Hr = /^(nonce|sha\d\d\d)-/;
var Ht3 = class {
  #e;
  #t;
  #c;
  #l;
  #d;
  #u;
  #f;
  #p;
  #n;
  #s;
  #a;
  #o;
  #i;
  #r;
  #h;
  constructor(t3, r4, n3) {
    this.#e = t3, this.#n = r4;
    const s6 = this.#n;
    this.#s = [], this.#a = [], this.#o = [], this.#i = [], this.#r = [];
    const a4 = s6["script-src"] || s6["default-src"], o5 = s6["script-src-elem"], i4 = s6["style-src"] || s6["default-src"], c6 = s6["style-src-attr"], d2 = s6["style-src-elem"], l5 = (h3) => !!h3 && !h3.some((b5) => b5 === "unsafe-inline");
    this.#c = l5(a4), this.#l = l5(o5), this.#u = l5(i4), this.#f = l5(c6), this.#p = l5(d2), this.#t = this.#c || this.#l, this.#d = this.#u || this.#f || this.#p, this.script_needs_nonce = this.#t && !this.#e, this.style_needs_nonce = this.#d && !this.#e, this.#h = n3;
  }
  add_script(t3) {
    if (!this.#t) return;
    const r4 = this.#e ? `sha256-${rt3(t3)}` : `nonce-${this.#h}`;
    this.#c && this.#s.push(r4), this.#l && this.#a.push(r4);
  }
  add_style(t3) {
    if (!this.#d) return;
    const r4 = this.#e ? `sha256-${rt3(t3)}` : `nonce-${this.#h}`;
    if (this.#u && this.#o.push(r4), this.#f && this.#i.push(r4), this.#p) {
      const n3 = "sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=", s6 = this.#n;
      s6["style-src-elem"] && !s6["style-src-elem"].includes(n3) && !this.#r.includes(n3) && this.#r.push(n3), r4 !== n3 && this.#r.push(r4);
    }
  }
  get_header(t3 = false) {
    const r4 = [], n3 = { ...this.#n };
    this.#o.length > 0 && (n3["style-src"] = [...n3["style-src"] || n3["default-src"] || [], ...this.#o]), this.#i.length > 0 && (n3["style-src-attr"] = [...n3["style-src-attr"] || [], ...this.#i]), this.#r.length > 0 && (n3["style-src-elem"] = [...n3["style-src-elem"] || [], ...this.#r]), this.#s.length > 0 && (n3["script-src"] = [...n3["script-src"] || n3["default-src"] || [], ...this.#s]), this.#a.length > 0 && (n3["script-src-elem"] = [...n3["script-src-elem"] || [], ...this.#a]);
    for (const s6 in n3) {
      if (t3 && (s6 === "frame-ancestors" || s6 === "report-uri" || s6 === "sandbox")) continue;
      const a4 = n3[s6];
      if (!a4) continue;
      const o5 = [s6];
      Array.isArray(a4) && a4.forEach((i4) => {
        Nr.has(i4) || Hr.test(i4) ? o5.push(`'${i4}'`) : o5.push(i4);
      }), r4.push(o5.join(" "));
    }
    return r4.join("; ");
  }
};
var Ir = class extends Ht3 {
  get_meta() {
    const t3 = this.get_header(true);
    if (t3) return `<meta http-equiv="content-security-policy" content="${Ie2(t3, true)}">`;
  }
};
var Lr = class extends Ht3 {
  constructor(t3, r4, n3) {
    if (super(t3, r4, n3), Object.values(r4).filter((s6) => !!s6).length > 0) {
      const s6 = r4["report-to"]?.length ?? false, a4 = r4["report-uri"]?.length ?? false;
      if (!s6 && !a4) throw Error("`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both");
    }
  }
};
var Dr = class {
  nonce = Ur();
  csp_provider;
  report_only_provider;
  constructor({ mode: t3, directives: r4, reportOnly: n3 }, { prerender: s6 }) {
    const a4 = t3 === "hash" || t3 === "auto" && s6;
    this.csp_provider = new Ir(a4, r4, this.nonce), this.report_only_provider = new Lr(a4, n3, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  add_script(t3) {
    this.csp_provider.add_script(t3), this.report_only_provider.add_script(t3);
  }
  add_style(t3) {
    this.csp_provider.add_style(t3), this.report_only_provider.add_style(t3);
  }
};
function It3(e3, t3, r4) {
  const n3 = {}, s6 = e3.slice(1), a4 = s6.filter((i4) => i4 !== void 0);
  let o5 = 0;
  for (let i4 = 0; i4 < t3.length; i4 += 1) {
    const c6 = t3[i4];
    let d2 = s6[i4 - o5];
    if (c6.chained && c6.rest && o5 && (d2 = s6.slice(i4 - o5, i4 + 1).filter((l5) => l5).join("/"), o5 = 0), d2 === void 0) {
      c6.rest && (n3[c6.name] = "");
      continue;
    }
    if (!c6.matcher || r4[c6.matcher](d2)) {
      n3[c6.name] = d2;
      const l5 = t3[i4 + 1], h3 = s6[i4 + 1];
      l5 && !l5.rest && l5.optional && h3 && c6.chained && (o5 = 0), !l5 && !h3 && Object.keys(n3).length === a4.length && (o5 = 0);
      continue;
    }
    if (c6.optional && c6.chained) {
      o5++;
      continue;
    }
    return;
  }
  if (!o5) return n3;
}
function Lt3(e3, t3, r4) {
  const { errors: n3, layouts: s6, leaf: a4 } = e3, o5 = [...n3, ...s6.map((i4) => i4?.[1]), a4[1]].filter((i4) => typeof i4 == "number").map((i4) => `'${i4}': () => ${Dt3(r4._.client.nodes?.[i4], t3)}`).join(`,
		`);
  return [`{
	id: ${H4(e3.id)}`, `errors: ${H4(e3.errors)}`, `layouts: ${H4(e3.layouts)}`, `leaf: ${H4(e3.leaf)}`, `nodes: {
		${o5}
	}
}`].join(`,
	`);
}
function Dt3(e3, t3) {
  if (!e3) return "Promise.resolve({})";
  if (e3[0] === "/") return `import('${e3}')`;
  if (t !== "") return `import('${t}/${e3}')`;
  let r4 = s2(t3.pathname, `${e}/${e3}`);
  return r4[0] !== "." && (r4 = `./${r4}`), `import('${r4}')`;
}
async function Wr(e3, t3, r4) {
  if (!r4._.client.routes) return text("Server-side route resolution disabled", { status: 400 });
  let n3 = null, s6 = {};
  const a4 = await r4._.matchers();
  for (const o5 of r4._.client.routes) {
    const i4 = o5.pattern.exec(e3);
    if (!i4) continue;
    const c6 = It3(i4, o5.params, a4);
    if (c6) {
      n3 = o5, s6 = x(c6);
      break;
    }
  }
  return Wt2(n3, s6, t3, r4).response;
}
function Wt2(e3, t3, r4, n3) {
  const s6 = new Headers({ "content-type": "application/javascript; charset=utf-8" });
  if (e3) {
    const a4 = Lt3(e3, r4, n3), o5 = `${Mr(e3, r4, n3)}
export const route = ${a4}; export const params = ${JSON.stringify(t3)};`;
    return { response: text(o5, { headers: s6 }), body: o5 };
  } else return { response: text("", { headers: s6 }), body: "" };
}
function Mr(e3, t3, r4) {
  const { errors: n3, layouts: s6, leaf: a4 } = e3;
  let o5 = "";
  for (const i4 of [...n3, ...s6.map((c6) => c6?.[1]), a4[1]]) {
    if (typeof i4 != "number") continue;
    const c6 = r4._.client.css?.[i4];
    for (const d2 of c6 ?? []) o5 += `'${t || e}/${d2}',`;
  }
  return o5 ? `${Dt3(r4._.client.start, t3)}.then(x => x.load_css([${o5}]));` : "";
}
var Fr = { ...x3(false), check: () => false };
async function ue2({ branch: e3, fetched: t3, options: r4, manifest: n3, state: s6, page_config: a4, status: o5, error: i4 = null, event: c6, event_state: d2, resolve_opts: l5, action_result: h3, data_serializer: b5 }) {
  if (s6.prerendering) {
    if (r4.csp.mode === "nonce") throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    if (r4.app_template_contains_nonce) throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
  }
  const { client: p4 } = n3._, f5 = new Set(p4.imports), u6 = new Set(p4.stylesheets), _3 = new Set(p4.fonts), y4 = /* @__PURE__ */ new Set(), $4 = /* @__PURE__ */ new Set(), j3 = /* @__PURE__ */ new Map();
  let v4;
  const x5 = h3?.type === "success" || h3?.type === "failure" ? h3.data ?? null : null;
  let m5 = e, g3 = t, w3 = H4(e);
  if (s6.prerendering?.fallback ? r4.hash_routing && (w3 = "new URL('.', location).pathname.slice(0, -1)") : (m5 = c6.url.pathname.slice(e.length).split("/").slice(2).map(() => "..").join("/") || ".", w3 = `new URL(${H4(m5)}, location).pathname.slice(0, -1)`, (!t || t[0] === "/" && t !== lr) && (g3 = m5)), a4.ssr) {
    const S3 = { stores: { page: z2(null), navigating: z2(null), updated: Fr }, constructors: await Promise.all(e3.map(({ node: q5 }) => {
      if (!q5.component) throw new Error(`Missing +page.svelte component for route ${c6.route.id}`);
      return q5.component();
    })), form: x5 };
    let A5 = {};
    for (let q5 = 0; q5 < e3.length; q5 += 1) A5 = { ...A5, ...e3[q5].data }, S3[`data_${q5}`] = A5;
    S3.page = { error: i4, params: c6.params, route: c6.route, status: o5, url: c6.url, data: A5, form: x5, state: {} };
    const G3 = { context: /* @__PURE__ */ new Map([["__request__", { page: S3.page }]]) }, re2 = globalThis.fetch;
    try {
      v4 = await with_request_store({ event: c6, state: d2 }, async () => {
        r && o({ base: m5, assets: g3 });
        const q5 = r4.root.render(S3, G3), W3 = r4.async && "then" in q5 ? q5.then((O5) => O5) : q5;
        r4.async && c();
        const { head: Q4, html: pe2, css: he2 } = r4.async ? await W3 : W3;
        return { head: Q4, html: pe2, css: he2 };
      });
    } finally {
      c();
    }
    for (const { node: q5 } of e3) {
      for (const W3 of q5.imports) f5.add(W3);
      for (const W3 of q5.stylesheets) u6.add(W3);
      for (const W3 of q5.fonts) _3.add(W3);
      q5.inline_styles && !p4.inline && Object.entries(await q5.inline_styles()).forEach(([W3, Q4]) => j3.set(W3, Q4));
    }
  } else v4 = { head: "", html: "", css: { code: "", map: null } };
  let k2 = "", E6 = v4.html;
  const R6 = new Dr(r4.csp, { prerender: !!s6.prerendering }), T4 = (S3) => S3.startsWith("/") ? e + S3 : `${g3}/${S3}`, P6 = p4.inline ? p4.inline?.style : Array.from(j3.values()).join(`
`);
  if (P6) {
    const S3 = [];
    R6.style_needs_nonce && S3.push(` nonce="${R6.nonce}"`), R6.add_style(P6), k2 += `
	<style${S3.join("")}>${P6}</style>`;
  }
  for (const S3 of u6) {
    const A5 = T4(S3), G3 = ['rel="stylesheet"'];
    j3.has(S3) ? G3.push("disabled", 'media="(max-width: 0)"') : l5.preload({ type: "css", path: A5 }) && y4.add(`<${encodeURI(A5)}>; rel="preload"; as="style"; nopush`), k2 += `
		<link href="${A5}" ${G3.join(" ")}>`;
  }
  for (const S3 of _3) {
    const A5 = T4(S3);
    if (l5.preload({ type: "font", path: A5 })) {
      const G3 = S3.slice(S3.lastIndexOf(".") + 1);
      $4.add(`<link rel="preload" as="font" type="font/${G3}" href="${A5}" crossorigin>`), y4.add(`<${encodeURI(A5)}>; rel="preload"; as="font"; type="font/${G3}"; crossorigin; nopush`);
    }
  }
  const M6 = bt2(r4), { data: F3, chunks: X4 } = b5.get_data(R6);
  if (a4.ssr && a4.csr && (E6 += `
			${t3.map((S3) => Pr(S3, l5.filterSerializedResponseHeaders, !!s6.prerendering)).join(`
			`)}`), a4.csr) {
    const S3 = n3._.client.routes?.find((O5) => O5.id === c6.route.id) ?? null;
    if (p4.uses_env_dynamic_public && s6.prerendering && f5.add(`${i}/env.js`), !p4.inline) {
      const O5 = Array.from(f5, (C4) => T4(C4)).filter((C4) => l5.preload({ type: "js", path: C4 }));
      for (const C4 of O5) y4.add(`<${encodeURI(C4)}>; rel="modulepreload"; nopush`), r4.preload_strategy !== "modulepreload" ? k2 += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${C4}">` : $4.add(`<link rel="modulepreload" href="${C4}">`);
    }
    if (s6.prerendering && $4.size > 0 && (k2 += Array.from($4).map((O5) => `
		${O5}`).join("")), n3._.client.routes && s6.prerendering && !s6.prerendering.fallback) {
      const O5 = Et3(c6.url.pathname);
      s6.prerendering.dependencies.set(O5, Wt2(S3, c6.params, new URL(O5, c6.url), n3));
    }
    const A5 = [], G3 = p4.uses_env_dynamic_public && s6.prerendering, re2 = [`base: ${w3}`];
    if (t && re2.push(`assets: ${H4(t)}`), p4.uses_env_dynamic_public && re2.push(`env: ${G3 ? "null" : H4(Rt)}`), X4) {
      A5.push("const deferred = new Map();"), re2.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      let O5 = "";
      Object.keys(r4.hooks.transport).length > 0 && (p4.inline ? O5 = `const app = __sveltekit_${r4.version_hash}.app.app;` : p4.app ? O5 = `const app = await import(${H4(T4(p4.app))});` : O5 = `const { app } = await import(${H4(T4(p4.start))});`);
      const C4 = O5 ? `${O5}
							const [data, error] = fn(app);` : "const [data, error] = fn();";
      re2.push(`resolve: async (id, fn) => {
							${C4}

							const try_to_resolve = () => {
								if (!deferred.has(id)) {
									setTimeout(try_to_resolve, 0);
									return;
								}
								const { fulfil, reject } = deferred.get(id);
								deferred.delete(id);
								if (error) reject(error);
								else fulfil(data);
							}
							try_to_resolve();
						}`);
    }
    A5.push(`${M6} = {
						${re2.join(`,
						`)}
					};`);
    const q5 = ["element"];
    if (A5.push("const element = document.currentScript.parentElement;"), a4.ssr) {
      const O5 = { form: "null", error: "null" };
      x5 && (O5.form = Tr(x5, c6.route.id, r4.hooks.transport)), i4 && (O5.error = uneval(i4));
      const C4 = [`node_ids: [${e3.map(({ node: Y4 }) => Y4.index).join(", ")}]`, `data: ${F3}`, `form: ${O5.form}`, `error: ${O5.error}`];
      if (o5 !== 200 && C4.push(`status: ${o5}`), n3._.client.routes) {
        if (S3) {
          const Y4 = Lt3(S3, c6.url, n3).replaceAll(`
`, `
							`);
          C4.push(`params: ${uneval(c6.params)}`, `server_route: ${Y4}`);
        }
      } else r4.embedded && C4.push(`params: ${uneval(c6.params)}`, `route: ${H4(c6.route)}`);
      const Z5 = "	".repeat(G3 ? 7 : 6);
      q5.push(`{
${Z5}	${C4.join(`,
${Z5}	`)}
${Z5}}`);
    }
    const { remote_data: W3 } = d2;
    let Q4 = "";
    if (W3) {
      const O5 = {};
      for (const [Z5, Y4] of W3) if (Z5.id) for (const ie2 in Y4) O5[m3(Z5.id, ie2)] = await Y4[ie2];
      const C4 = (Z5) => {
        for (const Y4 in r4.hooks.transport) {
          const ie2 = r4.hooks.transport[Y4].encode(Z5);
          if (ie2) return `app.decode('${Y4}', ${uneval(ie2, C4)})`;
        }
      };
      Q4 = `${M6}.data = ${uneval(O5, C4)};

						`;
    }
    const pe2 = p4.inline ? `${p4.inline.script}

					${Q4}${M6}.app.start(${q5.join(", ")});` : p4.app ? `Promise.all([
						import(${H4(T4(p4.start))}),
						import(${H4(T4(p4.app))})
					]).then(([kit, app]) => {
						${Q4}kit.start(app, ${q5.join(", ")});
					});` : `import(${H4(T4(p4.start))}).then((app) => {
						${Q4}app.start(${q5.join(", ")})
					});`;
    if (G3 ? A5.push(`import(${H4(`${m5}/${i}/env.js`)}).then(({ env }) => {
						${M6}.env = env;

						${pe2.replace(/\n/g, `
	`)}
					});`) : A5.push(pe2), r4.service_worker) {
      let O5 = "";
      if (r4.service_worker_options != null) {
        const C4 = { ...r4.service_worker_options };
        O5 = `, ${H4(C4)}`;
      }
      A5.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${T4("service-worker.js")}'${O5});
						});
					}`);
    }
    const he2 = `
				{
					${A5.join(`

					`)}
				}
			`;
    R6.add_script(he2), E6 += `
			<script${R6.script_needs_nonce ? ` nonce="${R6.nonce}"` : ""}>${he2}<\/script>
		`;
  }
  const K3 = new Headers({ "x-sveltekit-page": "true", "content-type": "text/html" });
  if (s6.prerendering) {
    const S3 = [], A5 = R6.csp_provider.get_meta();
    A5 && S3.push(A5), s6.prerendering.cache && S3.push(`<meta http-equiv="cache-control" content="${s6.prerendering.cache}">`), S3.length > 0 && (k2 = S3.join(`
`) + k2);
  } else {
    const S3 = R6.csp_provider.get_header();
    S3 && K3.set("content-security-policy", S3);
    const A5 = R6.report_only_provider.get_header();
    A5 && K3.set("content-security-policy-report-only", A5), y4.size && K3.set("link", Array.from(y4).join(", "));
  }
  k2 += v4.head;
  const ke2 = r4.templates.app({ head: k2, body: E6, assets: g3, nonce: R6.nonce, env: Rt }), $e2 = await l5.transformPageChunk({ html: ke2, done: true }) || "";
  return X4 || K3.set("etag", `"${Ct3($e2)}"`), X4 ? new Response(new ReadableStream({ async start(S3) {
    S3.enqueue(a2.encode($e2 + `
`));
    for await (const A5 of X4) A5.length && S3.enqueue(a2.encode(A5));
    S3.close();
  }, type: "bytes" }), { headers: K3 }) : text($e2, { status: o5, headers: K3 });
}
var Ge2 = class {
  data;
  constructor(t3) {
    this.data = t3;
  }
  layouts() {
    return this.data.slice(0, -1);
  }
  page() {
    return this.data.at(-1);
  }
  validate() {
    for (const r4 of this.layouts()) r4 && (R(r4.server, r4.server_id), E(r4.universal, r4.universal_id));
    const t3 = this.page();
    t3 && (U(t3.server, t3.server_id), O(t3.universal, t3.universal_id));
  }
  #e(t3) {
    return this.data.reduce((r4, n3) => n3?.universal?.[t3] ?? n3?.server?.[t3] ?? r4, void 0);
  }
  csr() {
    return this.#e("csr") ?? true;
  }
  ssr() {
    return this.#e("ssr") ?? true;
  }
  prerender() {
    return this.#e("prerender") ?? false;
  }
  trailing_slash() {
    return this.#e("trailingSlash") ?? "never";
  }
  get_config() {
    let t3 = {};
    for (const r4 of this.data) !r4?.universal?.config && !r4?.server?.config || (t3 = { ...t3, ...r4?.universal?.config, ...r4?.server?.config });
    return Object.keys(t3).length ? t3 : void 0;
  }
  should_prerender_data() {
    return this.data.some((t3) => t3?.server?.load || t3?.server?.trailingSlash !== void 0);
  }
};
async function Mt3({ event: e3, event_state: t3, options: r4, manifest: n3, state: s6, status: a4, error: o5, resolve_opts: i4 }) {
  if (e3.request.headers.get("x-sveltekit-error")) return ye2(r4, a4, o5.message);
  const c6 = [];
  try {
    const d2 = [], l5 = await n3._.nodes[0](), h3 = new Ge2([l5]), b5 = h3.ssr(), p4 = h3.csr(), f5 = de2(e3, t3, r4);
    if (b5) {
      s6.error = true;
      const u6 = Fe2({ event: e3, event_state: t3, state: s6, node: l5, parent: async () => ({}) }), _3 = await u6;
      f5.add_node(0, _3);
      const y4 = await Pt2({ event: e3, event_state: t3, fetched: c6, node: l5, parent: async () => ({}), resolve_opts: i4, server_data_promise: u6, state: s6, csr: p4 });
      d2.push({ node: l5, server_data: _3, data: y4 }, { node: await n3._.nodes[1](), data: null, server_data: null });
    }
    return await ue2({ options: r4, manifest: n3, state: s6, page_config: { ssr: b5, csr: p4 }, status: a4, error: await D2(e3, t3, r4, o5), branch: d2, fetched: c6, event: e3, event_state: t3, resolve_opts: i4, data_serializer: f5 });
  } catch (d2) {
    return d2 instanceof Redirect ? ge2(d2.status, d2.location) : ye2(r4, ae2(d2), (await D2(e3, t3, r4, d2)).message);
  }
}
async function Gr(e3, t3, r4, n3, s6) {
  return ee2({ name: "sveltekit.remote.call", attributes: {}, fn: (a4) => {
    const o5 = merge_tracing(e3, a4);
    return with_request_store({ event: o5, state: t3 }, () => Br(o5, t3, r4, n3, s6));
  } });
}
async function Br(e3, t3, r4, n3, s6) {
  const [a4, o5, i4] = s6.split("/"), c6 = n3._.remotes;
  c6[a4] || error(404);
  const l5 = (await c6[a4]()).default[o5];
  l5 || error(404);
  const h3 = l5.__, b5 = r4.hooks.transport;
  e3.tracing.current.setAttributes({ "sveltekit.remote.call.type": h3.type, "sveltekit.remote.call.name": h3.name });
  let p4;
  try {
    if (h3.type === "query_batch") {
      if (e3.request.method !== "POST") throw new SvelteKitError(405, "Method Not Allowed", `\`query.batch\` functions must be invoked via POST request, not ${e3.request.method}`);
      const { payloads: y4 } = await e3.request.json(), $4 = y4.map((x5) => u(x5, b5)), j3 = await with_request_store({ event: e3, state: t3 }, () => h3.run($4)), v4 = await Promise.all($4.map(async (x5, m5) => {
        try {
          return { type: "result", data: j3(x5, m5) };
        } catch (g3) {
          return { type: "error", error: await D2(e3, t3, r4, g3), status: g3 instanceof HttpError || g3 instanceof SvelteKitError ? g3.status : 500 };
        }
      }));
      return json({ type: "result", result: l4(v4, b5) });
    }
    if (h3.type === "form") {
      if (e3.request.method !== "POST") throw new SvelteKitError(405, "Method Not Allowed", `\`form\` functions must be invoked via POST request, not ${e3.request.method}`);
      if (!He2(e3.request)) throw new SvelteKitError(415, "Unsupported Media Type", `\`form\` functions expect form-encoded data \u2014 received ${e3.request.headers.get("content-type")}`);
      const y4 = await e3.request.formData();
      p4 = JSON.parse(y4.get("sveltekit:remote_refreshes") ?? "[]"), y4.delete("sveltekit:remote_refreshes"), i4 && y4.set("sveltekit:id", decodeURIComponent(i4));
      const $4 = h3.fn, j3 = await with_request_store({ event: e3, state: t3 }, () => $4(y4));
      return json({ type: "result", result: l4(j3, b5), refreshes: j3.issues ? {} : await f5(p4) });
    }
    if (h3.type === "command") {
      const { payload: y4, refreshes: $4 } = await e3.request.json(), j3 = u(y4, b5), v4 = await with_request_store({ event: e3, state: t3 }, () => l5(j3));
      return json({ type: "result", result: l4(v4, b5), refreshes: await f5($4) });
    }
    const u6 = h3.type === "prerender" ? i4 : new URL(e3.request.url).searchParams.get("payload"), _3 = await with_request_store({ event: e3, state: t3 }, () => l5(u(u6, b5)));
    return json({ type: "result", result: l4(_3, b5) });
  } catch (u6) {
    if (u6 instanceof Redirect) return json({ type: "redirect", location: u6.location, refreshes: await f5(p4 ?? []) });
    const _3 = u6 instanceof HttpError || u6 instanceof SvelteKitError ? u6.status : 500;
    return json({ type: "error", error: await D2(e3, t3, r4, u6), status: _3 }, { status: t3.prerendering ? _3 : void 0, headers: { "cache-control": "private, no-store" } });
  }
  async function f5(u6) {
    const _3 = t3.refreshes ?? {};
    for (const y4 of u6) {
      if (_3[y4] !== void 0) continue;
      const [$4, j3, v4] = y4.split("/"), x5 = n3._.remotes[$4], m5 = (await x5?.())?.default?.[j3];
      m5 || error(400, "Bad Request"), _3[y4] = with_request_store({ event: e3, state: t3 }, () => m5(u(v4, b5)));
    }
    if (Object.keys(_3).length !== 0) return l4(Object.fromEntries(await Promise.all(Object.entries(_3).map(async ([y4, $4]) => [y4, await $4]))), b5);
  }
}
async function Jr(e3, t3, r4, n3) {
  return ee2({ name: "sveltekit.remote.form.post", attributes: {}, fn: (s6) => {
    const a4 = merge_tracing(e3, s6);
    return with_request_store({ event: a4, state: t3 }, () => Vr(a4, t3, r4, n3));
  } });
}
async function Vr(e3, t3, r4, n3) {
  const [s6, a4, o5] = n3.split("/");
  let d2 = (await r4._.remotes[s6]?.())?.default[a4];
  if (!d2) return e3.setHeaders({ allow: "GET" }), { type: "error", error: new SvelteKitError(405, "Method Not Allowed", "POST method not allowed. No form actions exist for this page") };
  o5 && (d2 = with_request_store({ event: e3, state: t3 }, () => d2.for(JSON.parse(o5))));
  try {
    const l5 = await e3.request.formData(), h3 = d2.__.fn;
    return o5 && !l5.has("id") && l5.set("sveltekit:id", decodeURIComponent(o5)), await with_request_store({ event: e3, state: t3 }, () => h3(l5)), { type: "success", status: 200 };
  } catch (l5) {
    const h3 = l5;
    return h3 instanceof Redirect ? { type: "redirect", status: h3.status, location: h3.location } : { type: "error", error: Me2(h3) };
  }
}
function Xr(e3) {
  return e3.pathname.startsWith(`${e}/${i}/remote/`) && e3.pathname.replace(`${e}/${i}/remote/`, "");
}
function Kr(e3) {
  return e3.searchParams.get("/remote");
}
var Yr = 10;
async function Qr(e3, t3, r4, n3, s6, a4, o5, i4) {
  if (a4.depth > Yr) return text(`Not found: ${e3.url.pathname}`, { status: 404 });
  if (Rt2(e3)) {
    const c6 = await s6._.nodes[r4.leaf]();
    return Rr(e3, t3, n3, c6?.server);
  }
  try {
    const c6 = o5.page();
    let d2 = 200, l5;
    if (jr(e3)) {
      const g3 = Kr(e3.url);
      if (g3 ? l5 = await Jr(e3, t3, s6, g3) : l5 = await Sr(e3, t3, c6.server), l5?.type === "redirect") return ge2(l5.status, l5.location);
      l5?.type === "error" && (d2 = ae2(l5.error)), l5?.type === "failure" && (d2 = l5.status);
    }
    const h3 = o5.prerender();
    if (h3) {
      if (c6.server?.actions) throw new Error("Cannot prerender pages with actions");
    } else if (a4.prerendering) return new Response(void 0, { status: 204 });
    a4.prerender_default = h3;
    const b5 = o5.should_prerender_data(), p4 = De2(e3.url.pathname), f5 = [], u6 = o5.ssr(), _3 = o5.csr();
    if (u6 === false && !(a4.prerendering && b5)) return s && l5 && e3.request.headers.has("x-sveltekit-action"), await ue2({ branch: [], fetched: f5, page_config: { ssr: false, csr: _3 }, status: d2, error: null, event: e3, event_state: t3, options: n3, manifest: s6, state: a4, resolve_opts: i4, data_serializer: de2(e3, t3, n3) });
    const y4 = [];
    let $4 = null;
    const j3 = de2(e3, t3, n3), v4 = a4.prerendering && b5 ? qt3(e3, t3, n3) : null, x5 = o5.data.map((g3, w3) => {
      if ($4) throw $4;
      return Promise.resolve().then(async () => {
        try {
          if (g3 === c6 && l5?.type === "error") throw l5.error;
          const k2 = await Fe2({ event: e3, event_state: t3, state: a4, node: g3, parent: async () => {
            const E6 = {};
            for (let R6 = 0; R6 < w3; R6 += 1) {
              const T4 = await x5[R6];
              T4 && Object.assign(E6, T4.data);
            }
            return E6;
          } });
          return g3 && j3.add_node(w3, k2), v4?.add_node(w3, k2), k2;
        } catch (k2) {
          throw $4 = k2, $4;
        }
      });
    }), m5 = o5.data.map((g3, w3) => {
      if ($4) throw $4;
      return Promise.resolve().then(async () => {
        try {
          return await Pt2({ event: e3, event_state: t3, fetched: f5, node: g3, parent: async () => {
            const k2 = {};
            for (let E6 = 0; E6 < w3; E6 += 1) Object.assign(k2, await m5[E6]);
            return k2;
          }, resolve_opts: i4, server_data_promise: x5[w3], state: a4, csr: _3 });
        } catch (k2) {
          throw $4 = k2, $4;
        }
      });
    });
    for (const g3 of x5) g3.catch(() => {
    });
    for (const g3 of m5) g3.catch(() => {
    });
    for (let g3 = 0; g3 < o5.data.length; g3 += 1) {
      const w3 = o5.data[g3];
      if (w3) try {
        const k2 = await x5[g3], E6 = await m5[g3];
        y4.push({ node: w3, server_data: k2, data: E6 });
      } catch (k2) {
        const E6 = k2;
        if (E6 instanceof Redirect) {
          if (a4.prerendering && b5) {
            const P6 = JSON.stringify({ type: "redirect", location: E6.location });
            a4.prerendering.dependencies.set(p4, { response: text(P6), body: P6 });
          }
          return ge2(E6.status, E6.location);
        }
        const R6 = ae2(E6), T4 = await D2(e3, t3, n3, E6);
        for (; g3--; ) if (r4.errors[g3]) {
          const P6 = r4.errors[g3], M6 = await s6._.nodes[P6]();
          let F3 = g3;
          for (; !y4[F3]; ) F3 -= 1;
          j3.set_max_nodes(F3 + 1);
          const X4 = Oe2(y4.slice(0, F3 + 1)), K3 = new Ge2(X4.map((ke2) => ke2.node));
          return await ue2({ event: e3, event_state: t3, options: n3, manifest: s6, state: a4, resolve_opts: i4, page_config: { ssr: K3.ssr(), csr: K3.csr() }, status: R6, error: T4, branch: X4.concat({ node: M6, data: null, server_data: null }), fetched: f5, data_serializer: j3 });
        }
        return ye2(n3, R6, T4.message);
      }
      else y4.push(null);
    }
    if (a4.prerendering && v4) {
      let { data: g3, chunks: w3 } = v4.get_data();
      if (w3) for await (const k2 of w3) g3 += k2;
      a4.prerendering.dependencies.set(p4, { response: text(g3), body: g3 });
    }
    return await ue2({ event: e3, event_state: t3, options: n3, manifest: s6, state: a4, resolve_opts: i4, page_config: { csr: _3, ssr: u6 }, status: d2, error: null, branch: u6 === false ? [] : Oe2(y4), action_result: l5, fetched: f5, data_serializer: u6 === false ? de2(e3, t3, n3) : j3 });
  } catch (c6) {
    return await Mt3({ event: e3, event_state: t3, options: n3, manifest: s6, state: a4, status: 500, error: c6, resolve_opts: i4 });
  }
}
function Zr(e3) {
  let t3 = false, r4;
  return () => t3 ? r4 : (t3 = true, r4 = e3());
}
async function en2(e3, t3, r4, n3, s6, a4, o5, i4) {
  if (!r4.page) return new Response(void 0, { status: 404 });
  try {
    const c6 = [...r4.page.layouts, r4.page.leaf], d2 = o5 ?? c6.map(() => true);
    let l5 = false;
    const h3 = new URL(e3.url);
    h3.pathname = $(h3.pathname, i4);
    const b5 = { ...e3, url: h3 }, p4 = c6.map((v4, x5) => Zr(async () => {
      try {
        if (l5) return { type: "skip" };
        const m5 = v4 == null ? v4 : await s6._.nodes[v4]();
        return Fe2({ event: b5, event_state: t3, state: a4, node: m5, parent: async () => {
          const g3 = {};
          for (let w3 = 0; w3 < x5; w3 += 1) {
            const k2 = await p4[w3]();
            k2 && Object.assign(g3, k2.data);
          }
          return g3;
        } });
      } catch (m5) {
        throw l5 = true, m5;
      }
    })), f5 = p4.map(async (v4, x5) => d2[x5] ? v4() : { type: "skip" });
    let u6 = f5.length;
    const _3 = await Promise.all(f5.map((v4, x5) => v4.catch(async (m5) => {
      if (m5 instanceof Redirect) throw m5;
      return u6 = Math.min(u6, x5 + 1), { type: "error", error: await D2(e3, t3, n3, m5), status: m5 instanceof HttpError || m5 instanceof SvelteKitError ? m5.status : void 0 };
    }))), y4 = qt3(e3, t3, n3);
    for (let v4 = 0; v4 < _3.length; v4++) y4.add_node(v4, _3[v4]);
    const { data: $4, chunks: j3 } = y4.get_data();
    return j3 ? new Response(new ReadableStream({ async start(v4) {
      v4.enqueue(a2.encode($4));
      for await (const x5 of j3) v4.enqueue(a2.encode(x5));
      v4.close();
    }, type: "bytes" }), { headers: { "content-type": "text/sveltekit-data", "cache-control": "private, no-store" } }) : Pe2($4);
  } catch (c6) {
    const d2 = c6;
    return d2 instanceof Redirect ? Ce2(d2) : Pe2(await D2(e3, t3, n3, d2), 500);
  }
}
function Pe2(e3, t3 = 200) {
  return text(typeof e3 == "string" ? e3 : JSON.stringify(e3), { status: t3, headers: { "content-type": "application/json", "cache-control": "private, no-store" } });
}
function Ce2(e3) {
  return Pe2({ type: "redirect", location: e3.location });
}
var tn2 = /[\x00-\x1F\x7F()<>@,;:"/[\]?={} \t]/;
function xe2(e3) {
  if (e3?.path === void 0) throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
}
function rn2(e3, t3, r4) {
  return `${e3 || ""}${t3}?${encodeURIComponent(r4)}`;
}
function nn2(e3, t3) {
  const r4 = e3.headers.get("cookie") ?? "", n3 = (0, import_cookie.parse)(r4, { decode: (b5) => b5 });
  let s6;
  const a4 = /* @__PURE__ */ new Map(), o5 = { httpOnly: true, sameSite: "lax", secure: !(t3.hostname === "localhost" && t3.protocol === "http:") }, i4 = { get(b5, p4) {
    const f5 = Array.from(a4.values()).filter((y4) => y4.name === b5 && Ee2(t3.hostname, y4.options.domain) && Re2(t3.pathname, y4.options.path)).sort((y4, $4) => $4.options.path.length - y4.options.path.length)[0];
    return f5 ? f5.options.maxAge === 0 ? void 0 : f5.value : (0, import_cookie.parse)(r4, { decode: p4?.decode })[b5];
  }, getAll(b5) {
    const p4 = (0, import_cookie.parse)(r4, { decode: b5?.decode }), f5 = /* @__PURE__ */ new Map();
    for (const u6 of a4.values()) if (Ee2(t3.hostname, u6.options.domain) && Re2(t3.pathname, u6.options.path)) {
      const _3 = f5.get(u6.name);
      (!_3 || u6.options.path.length > _3.options.path.length) && f5.set(u6.name, u6);
    }
    for (const u6 of f5.values()) p4[u6.name] = u6.value;
    return Object.entries(p4).map(([u6, _3]) => ({ name: u6, value: _3 }));
  }, set(b5, p4, f5) {
    const u6 = b5.match(tn2);
    u6 && console.warn(`The cookie name "${b5}" will be invalid in SvelteKit 3.0 as it contains ${u6.join(" and ")}. See RFC 2616 for more details https://datatracker.ietf.org/doc/html/rfc2616#section-2.2`), xe2(f5), l5(b5, p4, { ...o5, ...f5 });
  }, delete(b5, p4) {
    xe2(p4), i4.set(b5, "", { ...p4, maxAge: 0 });
  }, serialize(b5, p4, f5) {
    xe2(f5);
    let u6 = f5.path;
    if (!f5.domain || f5.domain === t3.hostname) {
      if (!s6) throw new Error("Cannot serialize cookies until after the route is determined");
      u6 = b(s6, u6);
    }
    return (0, import_cookie.serialize)(b5, p4, { ...o5, ...f5, path: u6 });
  } };
  function c6(b5, p4) {
    const f5 = { ...n3 };
    for (const u6 of a4.values()) {
      if (!Ee2(b5.hostname, u6.options.domain) || !Re2(b5.pathname, u6.options.path)) continue;
      const _3 = u6.options.encode || encodeURIComponent;
      f5[u6.name] = _3(u6.value);
    }
    if (p4) {
      const u6 = (0, import_cookie.parse)(p4, { decode: (_3) => _3 });
      for (const _3 in u6) f5[_3] = u6[_3];
    }
    return Object.entries(f5).map(([u6, _3]) => `${u6}=${_3}`).join("; ");
  }
  const d2 = [];
  function l5(b5, p4, f5) {
    if (!s6) {
      d2.push(() => l5(b5, p4, f5));
      return;
    }
    let u6 = f5.path;
    (!f5.domain || f5.domain === t3.hostname) && (u6 = b(s6, u6));
    const _3 = rn2(f5.domain, u6, b5), y4 = { name: b5, value: p4, options: { ...f5, path: u6 } };
    a4.set(_3, y4);
  }
  function h3(b5) {
    s6 = $(t3.pathname, b5), d2.forEach((p4) => p4());
  }
  return { cookies: i4, new_cookies: a4, get_cookie_header: c6, set_internal: l5, set_trailing_slash: h3 };
}
function Ee2(e3, t3) {
  if (!t3) return true;
  const r4 = t3[0] === "." ? t3.slice(1) : t3;
  return e3 === r4 ? true : e3.endsWith("." + r4);
}
function Re2(e3, t3) {
  if (!t3) return true;
  const r4 = t3.endsWith("/") ? t3.slice(0, -1) : t3;
  return e3 === r4 ? true : e3.startsWith(r4 + "/");
}
function st2(e3, t3) {
  for (const r4 of t3) {
    const { name: n3, value: s6, options: a4 } = r4;
    if (e3.append("set-cookie", (0, import_cookie.serialize)(n3, s6, a4)), a4.path.endsWith(".html")) {
      const o5 = De2(a4.path);
      e3.append("set-cookie", (0, import_cookie.serialize)(n3, s6, { ...a4, path: o5 }));
    }
  }
}
function sn({ event: e3, options: t3, manifest: r4, state: n3, get_cookie_header: s6, set_internal: a4 }) {
  const o5 = async (i4, c6) => {
    const d2 = at3(i4, c6, e3.url);
    let l5 = (i4 instanceof Request ? i4.mode : c6?.mode) ?? "cors", h3 = (i4 instanceof Request ? i4.credentials : c6?.credentials) ?? "same-origin";
    return t3.hooks.handleFetch({ event: e3, request: d2, fetch: async (b5, p4) => {
      const f5 = at3(b5, p4, e3.url), u6 = new URL(f5.url);
      if (f5.headers.has("origin") || f5.headers.set("origin", e3.url.origin), b5 !== d2 && (l5 = (b5 instanceof Request ? b5.mode : p4?.mode) ?? "cors", h3 = (b5 instanceof Request ? b5.credentials : p4?.credentials) ?? "same-origin"), (f5.method === "GET" || f5.method === "HEAD") && (l5 === "no-cors" && u6.origin !== e3.url.origin || u6.origin === e3.url.origin) && f5.headers.delete("origin"), u6.origin !== e3.url.origin) {
        if (`.${u6.hostname}`.endsWith(`.${e3.url.hostname}`) && h3 !== "omit") {
          const w3 = s6(u6, f5.headers.get("cookie"));
          w3 && f5.headers.set("cookie", w3);
        }
        return fetch(f5);
      }
      const _3 = t || e, y4 = decodeURIComponent(u6.pathname), $4 = (y4.startsWith(_3) ? y4.slice(_3.length) : y4).slice(1), j3 = `${$4}/index.html`, v4 = r4.assets.has($4) || $4 in r4._.server_assets, x5 = r4.assets.has(j3) || j3 in r4._.server_assets;
      if (v4 || x5) {
        const w3 = v4 ? $4 : j3;
        if (n3.read) {
          const k2 = v4 ? r4.mimeTypes[$4.slice($4.lastIndexOf("."))] : "text/html";
          return new Response(n3.read(w3), { headers: k2 ? { "content-type": k2 } : {} });
        } else if (qt2 && w3 in r4._.server_assets) {
          const k2 = r4._.server_assets[w3], E6 = r4.mimeTypes[w3.slice(w3.lastIndexOf("."))];
          return new Response(qt2(w3), { headers: { "Content-Length": "" + k2, "Content-Type": E6 } });
        }
        return await fetch(f5);
      }
      if (vt(r4, e + y4)) return await fetch(f5);
      if (h3 !== "omit") {
        const w3 = s6(u6, f5.headers.get("cookie"));
        w3 && f5.headers.set("cookie", w3);
        const k2 = e3.request.headers.get("authorization");
        k2 && !f5.headers.has("authorization") && f5.headers.set("authorization", k2);
      }
      f5.headers.has("accept") || f5.headers.set("accept", "*/*"), f5.headers.has("accept-language") || f5.headers.set("accept-language", e3.request.headers.get("accept-language"));
      const m5 = await an2(f5, t3, r4, n3), g3 = m5.headers.get("set-cookie");
      if (g3) for (const w3 of Ze2.splitCookiesString(g3)) {
        const { name: k2, value: E6, ...R6 } = Ze2.parseString(w3, { decodeValues: false }), T4 = R6.path ?? (u6.pathname.split("/").slice(0, -1).join("/") || "/");
        a4(k2, E6, { path: T4, encode: (P6) => P6, ...R6 });
      }
      return m5;
    } });
  };
  return (i4, c6) => {
    const d2 = o5(i4, c6);
    return d2.catch(() => {
    }), d2;
  };
}
function at3(e3, t3, r4) {
  return e3 instanceof Request ? e3 : new Request(typeof e3 == "string" ? new URL(e3, r4) : e3, t3);
}
async function an2(e3, t3, r4, n3) {
  if (e3.signal) {
    if (e3.signal.aborted) throw new DOMException("The operation was aborted.", "AbortError");
    let s6 = () => {
    };
    const a4 = new Promise((i4, c6) => {
      const d2 = () => {
        c6(new DOMException("The operation was aborted.", "AbortError"));
      };
      e3.signal.addEventListener("abort", d2, { once: true }), s6 = () => e3.signal.removeEventListener("abort", d2);
    }), o5 = await Promise.race([ze2(e3, t3, r4, { ...n3, depth: n3.depth + 1 }), a4]);
    return s6(), o5;
  } else return await ze2(e3, t3, r4, { ...n3, depth: n3.depth + 1 });
}
var ot3;
var je2;
var Se2;
function on2(e3) {
  return ot3 ??= `export const env=${JSON.stringify(Rt)}`, je2 ??= `W/${Date.now()}`, Se2 ??= new Headers({ "content-type": "application/javascript; charset=utf-8", etag: je2 }), e3.headers.get("if-none-match") === je2 ? new Response(void 0, { status: 304, headers: Se2 }) : new Response(ot3, { headers: Se2 });
}
var it2 = ({ html: e3 }) => e3;
var ct3 = () => false;
var lt3 = ({ type: e3 }) => e3 === "js" || e3 === "css";
var cn2 = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var ln2 = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
var ze2 = fn2(dn2);
async function dn2(e3, t3, r4, n3) {
  const s6 = new URL(e3.url), a4 = $r(s6.pathname), o5 = br(s6.pathname), i4 = Xr(s6);
  {
    const m5 = e3.headers.get("origin");
    if (i4) {
      if (e3.method !== "GET" && m5 !== s6.origin) return json({ message: "Cross-site remote requests are forbidden" }, { status: 403 });
    } else if (t3.csrf_check_origin && He2(e3) && (e3.method === "POST" || e3.method === "PUT" || e3.method === "PATCH" || e3.method === "DELETE") && m5 !== s6.origin && (!m5 || !t3.csrf_trusted_origins.includes(m5))) {
      const w3 = `Cross-site ${e3.method} form submissions are forbidden`, k2 = { status: 403 };
      return e3.headers.get("accept") === "application/json" ? json({ message: w3 }, k2) : text(w3, k2);
    }
  }
  if (t3.hash_routing && s6.pathname !== e + "/" && s6.pathname !== "/[fallback]") return text("Not found", { status: 404 });
  let c6;
  a4 ? s6.pathname = vr(s6.pathname) : o5 ? (s6.pathname = kr(s6.pathname) + (s6.searchParams.get(p3) === "1" ? "/" : "") || "/", s6.searchParams.delete(p3), c6 = s6.searchParams.get(f4)?.split("").map((m5) => m5 === "1"), s6.searchParams.delete(f4)) : i4 && (s6.pathname = e3.headers.get("x-sveltekit-pathname") ?? e, s6.search = e3.headers.get("x-sveltekit-search") ?? "");
  const d2 = {}, { cookies: l5, new_cookies: h3, get_cookie_header: b5, set_internal: p4, set_trailing_slash: f5 } = nn2(e3, s6), u6 = { prerendering: n3.prerendering, transport: t3.hooks.transport, handleValidationError: t3.hooks.handleValidationError, tracing: { record_span: ee2 }, is_in_remote_function: false }, _3 = { cookies: l5, fetch: null, getClientAddress: n3.getClientAddress || (() => {
    throw new Error("@sveltejs/adapter-cloudflare does not specify getClientAddress. Please raise an issue");
  }), locals: {}, params: {}, platform: n3.platform, request: e3, route: { id: null }, setHeaders: (m5) => {
    for (const g3 in m5) {
      const w3 = g3.toLowerCase(), k2 = m5[g3];
      if (w3 === "set-cookie") throw new Error("Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies");
      if (w3 in d2) throw new Error(`"${g3}" header is already set`);
      d2[w3] = k2, n3.prerendering && w3 === "cache-control" && (n3.prerendering.cache = k2);
    }
  }, url: s6, isDataRequest: o5, isSubRequest: n3.depth > 0, isRemoteRequest: !!i4 };
  _3.fetch = sn({ event: _3, options: t3, manifest: r4, state: n3, get_cookie_header: b5, set_internal: p4 }), n3.emulator?.platform && (_3.platform = await n3.emulator.platform({ config: {}, prerender: !!n3.prerendering?.fallback }));
  let y4 = s6.pathname;
  if (!i4) {
    const m5 = n3.prerendering?.inside_reroute;
    try {
      n3.prerendering && (n3.prerendering.inside_reroute = true), y4 = await t3.hooks.reroute({ url: new URL(s6), fetch: _3.fetch }) ?? s6.pathname;
    } catch {
      return text("Internal Server Error", { status: 500 });
    } finally {
      n3.prerendering && (n3.prerendering.inside_reroute = m5);
    }
  }
  try {
    y4 = P(y4);
  } catch {
    return text("Malformed URI", { status: 400 });
  }
  if (y4 !== s6.pathname && !n3.prerendering?.fallback && vt(r4, y4)) {
    const m5 = new URL(e3.url);
    m5.pathname = o5 ? De2(y4) : a4 ? Et3(y4) : y4;
    const g3 = await fetch(m5, e3), w3 = new Headers(g3.headers);
    return w3.has("content-encoding") && (w3.delete("content-encoding"), w3.delete("content-length")), new Response(g3.body, { headers: w3, status: g3.status, statusText: g3.statusText });
  }
  let $4 = null;
  if (e && !n3.prerendering?.fallback) {
    if (!y4.startsWith(e)) return text("Not found", { status: 404 });
    y4 = y4.slice(e.length) || "/";
  }
  if (a4) return Wr(y4, new URL(e3.url), r4);
  if (y4 === `/${i}/env.js`) return on2(e3);
  if (!i4 && y4.startsWith(`/${i}`)) {
    const m5 = new Headers();
    return m5.set("cache-control", "public, max-age=0, must-revalidate"), text("Not found", { status: 404, headers: m5 });
  }
  if (!n3.prerendering?.fallback) {
    const m5 = await r4._.matchers();
    for (const g3 of r4._.routes) {
      const w3 = g3.pattern.exec(y4);
      if (!w3) continue;
      const k2 = It3(w3, g3.params, m5);
      if (k2) {
        $4 = g3, _3.route = { id: $4.id }, _3.params = x(k2);
        break;
      }
    }
  }
  let j3 = { transformPageChunk: it2, filterSerializedResponseHeaders: ct3, preload: lt3 }, v4 = "never";
  try {
    const m5 = $4?.page ? new Ge2(await un2($4.page, r4)) : void 0;
    if ($4 && !i4) {
      if (s6.pathname === e || s6.pathname === e + "/" ? v4 = "always" : m5 ? v4 = m5.trailing_slash() : $4.endpoint && (v4 = (await $4.endpoint()).trailingSlash ?? "never"), !o5) {
        const w3 = $(s6.pathname, v4);
        if (w3 !== s6.pathname && !n3.prerendering?.fallback) return new Response(void 0, { status: 308, headers: { "x-sveltekit-normalize": "1", location: (w3.startsWith("//") ? s6.origin + w3 : w3) + (s6.search === "?" ? "" : s6.search) } });
      }
      if (n3.before_handle || n3.emulator?.platform) {
        let w3 = {}, k2 = false;
        if ($4.endpoint) {
          const E6 = await $4.endpoint();
          w3 = E6.config ?? w3, k2 = E6.prerender ?? k2;
        } else m5 && (w3 = m5.get_config() ?? w3, k2 = m5.prerender());
        n3.before_handle && n3.before_handle(_3, w3, k2), n3.emulator?.platform && (_3.platform = await n3.emulator.platform({ config: w3, prerender: k2 }));
      }
    }
    f5(v4), n3.prerendering && !n3.prerendering.fallback && !n3.prerendering.inside_reroute && j(s6);
    const g3 = await ee2({ name: "sveltekit.handle.root", attributes: { "http.route": _3.route.id || "unknown", "http.method": _3.request.method, "http.url": _3.url.href, "sveltekit.is_data_request": o5, "sveltekit.is_sub_request": _3.isSubRequest }, fn: async (w3) => {
      const k2 = { ..._3, tracing: { enabled: false, root: w3, current: w3 } };
      return await with_request_store({ event: k2, state: u6 }, () => t3.hooks.handle({ event: k2, resolve: (E6, R6) => ee2({ name: "sveltekit.resolve", attributes: { "http.route": E6.route.id || "unknown" }, fn: (T4) => with_request_store(null, () => x5(merge_tracing(E6, T4), m5, R6).then((P6) => {
        for (const M6 in d2) {
          const F3 = d2[M6];
          P6.headers.set(M6, F3);
        }
        return st2(P6.headers, h3.values()), n3.prerendering && E6.route.id !== null && P6.headers.set("x-sveltekit-routeid", encodeURI(E6.route.id)), T4.setAttributes({ "http.response.status_code": P6.status, "http.response.body.size": P6.headers.get("content-length") || "unknown" }), P6;
      })) }) }));
    } });
    if (g3.status === 200 && g3.headers.has("etag")) {
      let w3 = e3.headers.get("if-none-match");
      w3?.startsWith('W/"') && (w3 = w3.substring(2));
      const k2 = g3.headers.get("etag");
      if (w3 === k2) {
        const E6 = new Headers({ etag: k2 });
        for (const R6 of ["cache-control", "content-location", "date", "expires", "vary", "set-cookie"]) {
          const T4 = g3.headers.get(R6);
          T4 && E6.set(R6, T4);
        }
        return new Response(void 0, { status: 304, headers: E6 });
      }
    }
    if (o5 && g3.status >= 300 && g3.status <= 308) {
      const w3 = g3.headers.get("location");
      if (w3) return Ce2(new Redirect(g3.status, w3));
    }
    return g3;
  } catch (m5) {
    if (m5 instanceof Redirect) {
      const g3 = o5 || i4 ? Ce2(m5) : $4?.page && Rt2(_3) ? jt3(m5) : ge2(m5.status, m5.location);
      return st2(g3.headers, h3.values()), g3;
    }
    return await et3(_3, u6, t3, m5);
  }
  async function x5(m5, g3, w3) {
    try {
      if (w3 && (j3 = { transformPageChunk: w3.transformPageChunk || it2, filterSerializedResponseHeaders: w3.filterSerializedResponseHeaders || ct3, preload: w3.preload || lt3 }), t3.hash_routing || n3.prerendering?.fallback) return await ue2({ event: m5, event_state: u6, options: t3, manifest: r4, state: n3, page_config: { ssr: false, csr: true }, status: 200, error: null, branch: [], fetched: [], resolve_opts: j3, data_serializer: de2(m5, u6, t3) });
      if (i4) return await Gr(m5, u6, t3, r4, i4);
      if ($4) {
        const E6 = m5.request.method;
        let R6;
        if (o5) R6 = await en2(m5, u6, $4, t3, r4, n3, c6, v4);
        else if ($4.endpoint && (!$4.page || wr(m5))) R6 = await gr(m5, u6, await $4.endpoint(), n3);
        else if ($4.page) if (g3) if (cn2.has(E6)) R6 = await Qr(m5, u6, $4.page, t3, r4, n3, g3, j3);
        else {
          const T4 = new Set(ln2);
          if ((await r4._.nodes[$4.page.leaf]())?.server?.actions && T4.add("POST"), E6 === "OPTIONS") R6 = new Response(null, { status: 204, headers: { allow: Array.from(T4.values()).join(", ") } });
          else {
            const M6 = [...T4].reduce((F3, X4) => (F3[X4] = true, F3), {});
            R6 = wt2(M6, E6);
          }
        }
        else throw new Error("page_nodes not found. This should never happen");
        else throw new Error("Route is neither page nor endpoint. This should never happen");
        if (e3.method === "GET" && $4.page && $4.endpoint) {
          const T4 = R6.headers.get("vary")?.split(",")?.map((P6) => P6.trim().toLowerCase());
          T4?.includes("accept") || T4?.includes("*") || (R6 = new Response(R6.body, { status: R6.status, statusText: R6.statusText, headers: new Headers(R6.headers) }), R6.headers.append("Vary", "Accept"));
        }
        return R6;
      }
      if (n3.error && m5.isSubRequest) {
        const E6 = new Headers(e3.headers);
        return E6.set("x-sveltekit-error", "true"), await fetch(e3, { headers: E6 });
      }
      if (n3.error) return text("Internal Server Error", { status: 500 });
      if (n3.depth === 0) return s && m5.url.pathname, await Mt3({ event: m5, event_state: u6, options: t3, manifest: r4, state: n3, status: 404, error: new SvelteKitError(404, "Not Found", `Not found: ${m5.url.pathname}`), resolve_opts: j3 });
      if (n3.prerendering) return text("not found", { status: 404 });
      const k2 = await fetch(e3);
      return new Response(k2.body, k2);
    } catch (k2) {
      return await et3(m5, u6, t3, k2);
    } finally {
      m5.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      }, m5.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
}
function un2(e3, t3) {
  return Promise.all([...e3.layouts.map((r4) => r4 == null ? r4 : t3._.nodes[r4]()), t3._.nodes[e3.leaf]()]);
}
function fn2(e3) {
  return async (t3, ...r4) => e3(t3, ...r4);
}
function dt3(e3, t3, r4) {
  return Object.fromEntries(Object.entries(e3).filter(([n3]) => n3.startsWith(t3) && (r4 === "" || !n3.startsWith(r4))));
}
var pn2;
var ut3 = null;
var Sn2 = class {
  #e;
  #t;
  constructor(t3) {
    if (this.#e = Zt2, this.#t = t3, cr) {
      const r4 = this.respond.bind(this);
      this.respond = async (...n3) => {
        const { promise: s6, resolve: a4 } = ht2(), o5 = ut3;
        return ut3 = s6, await o5, r4(...n3).finally(a4);
      };
    }
  }
  async init({ env: t3, read: r4 }) {
    const { env_public_prefix: n3, env_private_prefix: s6 } = this.#e;
    Jt2(dt3(t3, s6, n3)), Kt2(dt3(t3, n3, s6)), r4 && Qt2((o5) => {
      const i4 = r4(o5);
      return i4 instanceof ReadableStream ? i4 : new ReadableStream({ async start(c6) {
        try {
          const d2 = await Promise.resolve(i4);
          if (!d2) {
            c6.close();
            return;
          }
          const l5 = d2.getReader();
          for (; ; ) {
            const { done: h3, value: b5 } = await l5.read();
            if (h3) break;
            c6.enqueue(b5);
          }
          c6.close();
        } catch (d2) {
          c6.error(d2);
        }
      } });
    }), await (pn2 ??= (async () => {
      try {
        const a4 = await $t2();
        this.#e.hooks = { handle: a4.handle || (({ event: o5, resolve: i4 }) => i4(o5)), handleError: a4.handleError || (({ status: o5, error: i4, event: c6 }) => {
          const d2 = yr(o5, i4, c6);
          console.error(d2);
        }), handleFetch: a4.handleFetch || (({ request: o5, fetch: i4 }) => i4(o5)), handleValidationError: a4.handleValidationError || (({ issues: o5 }) => (console.error("Remote function schema validation failed:", o5), { message: "Bad Request" })), reroute: a4.reroute || (() => {
        }), transport: a4.transport || {} }, a4.transport && Object.fromEntries(Object.entries(a4.transport).map(([o5, i4]) => [o5, i4.decode])), a4.init && await a4.init();
      } catch (a4) {
        throw a4;
      }
    })());
  }
  async respond(t3, r4) {
    return ze2(t3, this.#e, this.#t, { ...r4, error: false, depth: 0 });
  }
};

// .svelte-kit/cloudflare-tmp/manifest.js
var manifest = (() => {
  function __memo(fn3) {
    let value;
    return () => value ??= value = fn3();
  }
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["favicon.ico", "favicon.png", "robots.txt", "sw.js"]),
    mimeTypes: { ".png": "image/png", ".txt": "text/plain", ".js": "text/javascript" },
    _: {
      client: { start: "_app/immutable/entry/start.B0hSCXJY.js", app: "_app/immutable/entry/app.BdjEnwbO.js", imports: ["_app/immutable/entry/start.B0hSCXJY.js", "_app/immutable/chunks/DPtGKd3c.js", "_app/immutable/chunks/6ds4e1Hj.js", "_app/immutable/chunks/obLiwMeQ.js", "_app/immutable/chunks/ilhcaF4n.js", "_app/immutable/entry/app.BdjEnwbO.js", "_app/immutable/chunks/obLiwMeQ.js", "_app/immutable/chunks/6ds4e1Hj.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/uRYNcqzp.js", "_app/immutable/chunks/CeIZ_WK-.js", "_app/immutable/chunks/ilhcaF4n.js"], stylesheets: [], fonts: [], uses_env_dynamic_public: false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5)))
      ],
      remotes: {},
      routes: [
        {
          id: "/",
          pattern: /^\/$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 2 },
          endpoint: null
        },
        {
          id: "/temp-viewer",
          pattern: /^\/temp-viewer\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 3 },
          endpoint: null
        },
        {
          id: "/trip",
          pattern: /^\/trip\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 4 },
          endpoint: null
        }
      ],
      prerendered_routes: /* @__PURE__ */ new Set([]),
      matchers: async () => {
        return {};
      },
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var base_path = "";

// .svelte-kit/cloudflare-tmp/_worker.js
async function e2(e3, t22) {
  let n22 = "string" != typeof t22 && "HEAD" === t22.method;
  n22 && (t22 = new Request(t22, { method: "GET" }));
  let r32 = await e3.match(t22);
  return n22 && r32 && (r32 = new Response(null, r32)), r32;
}
function t2(e3, t22, n22, o22) {
  return ("string" == typeof t22 || "GET" === t22.method) && r3(n22) && (n22.headers.has("Set-Cookie") && (n22 = new Response(n22.body, n22)).headers.append("Cache-Control", "private=Set-Cookie"), o22.waitUntil(e3.put(t22, n22.clone()))), n22;
}
var n2 = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r3(e3) {
  if (!n2.has(e3.status)) return false;
  if (~(e3.headers.get("Vary") || "").indexOf("*")) return false;
  let t22 = e3.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t22);
}
function o4(n22) {
  return async function(r32, o22) {
    let a4 = await e2(n22, r32);
    if (a4) return a4;
    o22.defer((e3) => {
      t2(n22, r32, e3, o22);
    });
  };
}
var s5 = caches.default;
var c5 = t2.bind(0, s5);
var r22 = e2.bind(0, s5);
var e22 = o4.bind(0, s5);
var server = new Sn2(manifest);
var app_path = `/${manifest.appPath}`;
var immutable = `${app_path}/immutable/`;
var version_file = `${app_path}/version.json`;
var worker = {
  async fetch(req, env, context) {
    await server.init({ env });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r22(req);
    if (res) return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.slice(base_path.length + 1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
    }
    let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env.ASSETS.fetch(req);
    } else if (location && prerendered.has(location)) {
      if (search) location += search;
      res = new Response("", {
        status: 308,
        headers: {
          location
        }
      });
    } else {
      res = await server.respond(req, {
        // @ts-ignore
        platform: { env, context, caches, cf: req.cf },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c5(req, res, context) : res;
  }
};
var worker_default = worker;
export {
  worker_default as default
};
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=_worker.js.map
