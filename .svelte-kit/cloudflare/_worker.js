var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn4, res) => function __init() {
  return fn4 && (res = (0, fn4[__getOwnPropNames(fn4)[0]])(fn4 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// .svelte-kit/output/server/chunks/false.js
var s;
var init_false = __esm({
  ".svelte-kit/output/server/chunks/false.js"() {
    s = false;
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/remote-functions.js
var init_remote_functions = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/remote-functions.js"() {
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/index.js
var HttpError, Redirect, SvelteKitError, ActionFailure;
var init_internal = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/index.js"() {
    init_remote_functions();
    HttpError = class {
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body) {
        this.status = status;
        if (typeof body === "string") {
          this.body = { message: body };
        } else if (body) {
          this.body = body;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location) {
        this.status = status;
        this.location = location;
      }
    };
    SvelteKitError = class extends Error {
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text2, message) {
        super(message);
        this.status = status;
        this.text = text2;
      }
    };
    ActionFailure = class {
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
  }
});

// node_modules/esm-env/true.js
var true_default;
var init_true = __esm({
  "node_modules/esm-env/true.js"() {
    true_default = true;
  }
});

// node_modules/esm-env/dev-fallback.js
var node_env, dev_fallback_default;
var init_dev_fallback = __esm({
  "node_modules/esm-env/dev-fallback.js"() {
    node_env = globalThis.process?.env?.NODE_ENV;
    dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");
  }
});

// node_modules/esm-env/false.js
var init_false2 = __esm({
  "node_modules/esm-env/false.js"() {
  }
});

// node_modules/esm-env/index.js
var init_esm_env = __esm({
  "node_modules/esm-env/index.js"() {
    init_true();
    init_dev_fallback();
    init_false2();
  }
});

// node_modules/@sveltejs/kit/src/runtime/pathname.js
var init_pathname = __esm({
  "node_modules/@sveltejs/kit/src/runtime/pathname.js"() {
  }
});

// node_modules/@sveltejs/kit/src/runtime/utils.js
var text_encoder, text_decoder;
var init_utils = __esm({
  "node_modules/@sveltejs/kit/src/runtime/utils.js"() {
    init_esm_env();
    text_encoder = new TextEncoder();
    text_decoder = new TextDecoder();
  }
});

// node_modules/@sveltejs/kit/src/version.js
var init_version = __esm({
  "node_modules/@sveltejs/kit/src/version.js"() {
  }
});

// node_modules/@sveltejs/kit/src/exports/index.js
function error(status, body) {
  if ((!true_default || dev_fallback_default) && (isNaN(status) || status < 400 || status > 599)) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  throw new HttpError(status, body);
}
function redirect(status, location) {
  if ((!true_default || dev_fallback_default) && (isNaN(status) || status < 300 || status > 308)) {
    throw new Error("Invalid status code");
  }
  throw new Redirect(
    // @ts-ignore
    status,
    location.toString()
  );
}
function json(data, init35) {
  const body = JSON.stringify(data);
  const headers = new Headers(init35?.headers);
  if (!headers.has("content-length")) {
    headers.set("content-length", text_encoder.encode(body).byteLength.toString());
  }
  if (!headers.has("content-type")) {
    headers.set("content-type", "application/json");
  }
  return new Response(body, {
    ...init35,
    headers
  });
}
function text(body, init35) {
  const headers = new Headers(init35?.headers);
  if (!headers.has("content-length")) {
    const encoded = text_encoder.encode(body);
    headers.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init35,
      headers
    });
  }
  return new Response(body, {
    ...init35,
    headers
  });
}
var init_exports = __esm({
  "node_modules/@sveltejs/kit/src/exports/index.js"() {
    init_internal();
    init_esm_env();
    init_pathname();
    init_utils();
    init_version();
  }
});

// node_modules/@sveltejs/kit/src/runtime/server/constants.js
var IN_WEBCONTAINER;
var init_constants = __esm({
  "node_modules/@sveltejs/kit/src/runtime/server/constants.js"() {
    IN_WEBCONTAINER = !!globalThis.process?.versions?.webcontainer;
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/event.js
function with_request_store(store, fn4) {
  try {
    sync_store = store;
    return als ? als.run(store, fn4) : fn4();
  } finally {
    if (!IN_WEBCONTAINER) {
      sync_store = null;
    }
  }
}
var sync_store, als;
var init_event = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/event.js"() {
    init_constants();
    sync_store = null;
    import("node:async_hooks").then((hooks) => als = new hooks.AsyncLocalStorage()).catch(() => {
    });
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/server.js
function merge_tracing(event_like, current2) {
  return {
    ...event_like,
    tracing: {
      ...event_like.tracing,
      current: current2
    }
  };
}
var init_server = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/server.js"() {
    init_event();
  }
});

// .svelte-kit/output/server/chunks/exports.js
function b(e3, r5) {
  if (r5[0] === "/" && r5[1] === "/") return r5;
  let n6 = new URL(e3, p);
  return n6 = new URL(r5, n6), n6.protocol === p.protocol ? n6.pathname + n6.search + n6.hash : n6.href;
}
function $(e3, r5) {
  return e3 === "/" || r5 === "ignore" ? e3 : r5 === "never" ? e3.endsWith("/") ? e3.slice(0, -1) : e3 : r5 === "always" && !e3.endsWith("/") ? e3 + "/" : e3;
}
function P(e3) {
  return e3.split("%25").map(decodeURI).join("%25");
}
function x(e3) {
  for (const r5 in e3) e3[r5] = decodeURIComponent(e3[r5]);
  return e3;
}
function y(e3, r5, n6, o5 = false) {
  const t4 = new URL(e3);
  Object.defineProperty(t4, "searchParams", { value: new Proxy(t4.searchParams, { get(s5, a5) {
    if (a5 === "get" || a5 === "getAll" || a5 === "has") return (d2) => (n6(d2), s5[a5](d2));
    r5();
    const i7 = Reflect.get(s5, a5);
    return typeof i7 == "function" ? i7.bind(s5) : i7;
  } }), enumerable: true, configurable: true });
  const u8 = ["href", "pathname", "search", "toString", "toJSON"];
  o5 && u8.push("hash");
  for (const s5 of u8) Object.defineProperty(t4, s5, { get() {
    return r5(), e3[s5];
  }, enumerable: true, configurable: true });
  return t4[Symbol.for("nodejs.util.inspect.custom")] = (s5, a5, i7) => i7(e3, a5), t4.searchParams[Symbol.for("nodejs.util.inspect.custom")] = (s5, a5, i7) => i7(e3.searchParams, a5), o5 || w(t4), t4;
}
function w(e3) {
  h(e3), Object.defineProperty(e3, "hash", { get() {
    throw new Error("Cannot access event.url.hash. Consider using `page.url.hash` inside a component instead");
  } });
}
function j(e3) {
  h(e3);
  for (const r5 of ["search", "searchParams"]) Object.defineProperty(e3, r5, { get() {
    throw new Error(`Cannot access url.${r5} on a page with prerendering enabled`);
  } });
}
function h(e3) {
  e3[Symbol.for("nodejs.util.inspect.custom")] = (r5, n6, o5) => o5(new URL(e3), n6);
}
function c2(e3) {
  function r5(n6, o5) {
    if (n6) for (const t4 in n6) {
      if (t4[0] === "_" || e3.has(t4)) continue;
      const u8 = [...e3.values()], s5 = m(t4, o5?.slice(o5.lastIndexOf("."))) ?? `valid exports are ${u8.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${t4}'${o5 ? ` in ${o5}` : ""} (${s5})`);
    }
  }
  return r5;
}
function m(e3, r5 = ".js") {
  const n6 = [];
  if (l.has(e3) && n6.push(`+layout${r5}`), _.has(e3) && n6.push(`+page${r5}`), f.has(e3) && n6.push(`+layout.server${r5}`), v.has(e3) && n6.push(`+page.server${r5}`), g.has(e3) && n6.push(`+server${r5}`), n6.length > 0) return `'${e3}' is a valid export in ${n6.slice(0, -1).join(", ")}${n6.length > 1 ? " or " : ""}${n6.at(-1)}`;
}
var p, l, _, f, v, g, E, O, R, U, C;
var init_exports2 = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    p = new URL("sveltekit-internal://");
    l = /* @__PURE__ */ new Set(["load", "prerender", "csr", "ssr", "trailingSlash", "config"]);
    _ = /* @__PURE__ */ new Set([...l, "entries"]);
    f = /* @__PURE__ */ new Set([...l]);
    v = /* @__PURE__ */ new Set([...f, "actions", "entries"]);
    g = /* @__PURE__ */ new Set(["GET", "POST", "PATCH", "PUT", "DELETE", "OPTIONS", "HEAD", "fallback", "prerender", "trailingSlash", "config", "entries"]);
    E = c2(l);
    O = c2(_);
    R = c2(f);
    U = c2(v);
    C = c2(g);
  }
});

// .svelte-kit/output/server/chunks/utils.js
function s2(r5, n6) {
  const t4 = r5.split(/[/\\]/), e3 = n6.split(/[/\\]/);
  for (t4.pop(); t4[0] === e3[0]; ) t4.shift(), e3.shift();
  let o5 = t4.length;
  for (; o5--; ) t4[o5] = "..";
  return t4.concat(e3).join("/");
}
function f2(r5) {
  if (globalThis.Buffer) return globalThis.Buffer.from(r5).toString("base64");
  let n6 = "";
  for (let t4 = 0; t4 < r5.length; t4++) n6 += String.fromCharCode(r5[t4]);
  return btoa(n6);
}
function l2(r5) {
  if (globalThis.Buffer) {
    const e3 = globalThis.Buffer.from(r5, "base64");
    return new Uint8Array(e3);
  }
  const n6 = atob(r5), t4 = new Uint8Array(n6.length);
  for (let e3 = 0; e3 < n6.length; e3++) t4[e3] = n6.charCodeAt(e3);
  return t4;
}
var a2, i2;
var init_utils2 = __esm({
  ".svelte-kit/output/server/chunks/utils.js"() {
    a2 = new TextEncoder();
    i2 = new TextDecoder();
  }
});

// .svelte-kit/output/server/chunks/context.js
function E2(t4) {
  for (var e3 = 0; e3 < t4.length; e3++) t4[e3]();
}
function A() {
  var t4, e3, n6 = new Promise((o5, s5) => {
    t4 = o5, e3 = s5;
  });
  return { promise: n6, resolve: t4, reject: e3 };
}
function q(t4, e3, n6 = false) {
  return t4 === void 0 ? n6 ? e3() : e3 : t4;
}
function P2(t4) {
  return t4 === this.v;
}
function p2(t4, e3) {
  return t4 != t4 ? e3 == e3 : t4 !== e3 || t4 !== null && typeof t4 == "object" || typeof t4 == "function";
}
function T(t4) {
  return !p2(t4, this.v);
}
function l3(t4) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function C2(t4, e3) {
  const n6 = String(t4 ?? ""), o5 = e3 ? f3 : _2;
  o5.lastIndex = 0;
  let s5 = "", a5 = 0;
  for (; o5.test(n6); ) {
    const c7 = o5.lastIndex - 1, u8 = n6[c7];
    s5 += n6.substring(a5, c7) + (u8 === "&" ? "&amp;" : u8 === '"' ? "&quot;" : "&lt;"), a5 = c7 + 1;
  }
  return s5 + n6.substring(a5);
}
function R2(t4) {
  r2 = t4;
}
function G(t4) {
  return i3().get(t4);
}
function I(t4, e3) {
  return i3().set(t4, e3), e3;
}
function i3(t4) {
  return r2 === null && l3(), r2.c ??= new Map(y2(r2) || void 0);
}
function N(t4) {
  r2 = { p: r2, c: null, r: null };
}
function X() {
  r2 = r2.p;
}
function y2(t4) {
  let e3 = t4.p;
  for (; e3 !== null; ) {
    const n6 = e3.c;
    if (n6 !== null) return n6;
    e3 = e3.p;
  }
  return null;
}
var v2, d, g2, m2, x2, h2, b2, j2, O2, w2, f3, _2, r2;
var init_context = __esm({
  ".svelte-kit/output/server/chunks/context.js"() {
    v2 = Array.isArray;
    d = Array.prototype.indexOf;
    g2 = Array.from;
    m2 = Object.defineProperty;
    x2 = Object.getOwnPropertyDescriptor;
    h2 = Object.prototype;
    b2 = Array.prototype;
    j2 = Object.getPrototypeOf;
    O2 = Object.isExtensible;
    w2 = () => {
    };
    f3 = /[&"<]/g;
    _2 = /[&<]/g;
    r2 = null;
  }
});

// node_modules/clsx/dist/clsx.mjs
function r3(e3) {
  var t4, f8, n6 = "";
  if ("string" == typeof e3 || "number" == typeof e3) n6 += e3;
  else if ("object" == typeof e3) if (Array.isArray(e3)) {
    var o5 = e3.length;
    for (t4 = 0; t4 < o5; t4++) e3[t4] && (f8 = r3(e3[t4])) && (n6 && (n6 += " "), n6 += f8);
  } else for (f8 in e3) e3[f8] && (n6 && (n6 += " "), n6 += f8);
  return n6;
}
function clsx() {
  for (var e3, t4, f8 = 0, n6 = "", o5 = arguments.length; f8 < o5; f8++) (e3 = arguments[f8]) && (t4 = r3(e3)) && (n6 && (n6 += " "), n6 += t4);
  return n6;
}
var init_clsx = __esm({
  "node_modules/clsx/dist/clsx.mjs"() {
  }
});

// .svelte-kit/output/server/chunks/index.js
function g3(e3, o5) {
  return { subscribe: a3(e3, o5).subscribe };
}
function a3(e3, o5 = w2) {
  let r5 = null;
  const i7 = /* @__PURE__ */ new Set();
  function u8(t4) {
    if (p2(e3, t4) && (e3 = t4, r5)) {
      const c7 = !n.length;
      for (const s5 of i7) s5[1](), n.push(s5, e3);
      if (c7) {
        for (let s5 = 0; s5 < n.length; s5 += 2) n[s5][0](n[s5 + 1]);
        n.length = 0;
      }
    }
  }
  function f8(t4) {
    u8(t4(e3));
  }
  function l7(t4, c7 = w2) {
    const s5 = [t4, c7];
    return i7.add(s5), i7.size === 1 && (r5 = o5(u8, f8) || w2), t4(e3), () => {
      i7.delete(s5), i7.size === 0 && r5 && (r5(), r5 = null);
    };
  }
  return { set: u8, update: f8, subscribe: l7 };
}
var n;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    init_context();
    init_clsx();
    n = [];
  }
});

// .svelte-kit/output/server/chunks/index2.js
function Be() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function On() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function Ye() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function je() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Ue() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function Cn() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
function Mt(t4) {
  U2 = t4;
}
function In(t4, e3 = false, n6) {
  U2 = { p: U2, i: false, c: null, e: null, s: t4, x: null, l: null };
}
function Pn(t4) {
  var e3 = U2, n6 = e3.e;
  if (n6 !== null) {
    e3.e = null;
    for (var s5 of n6) rn(s5);
  }
  return e3.i = true, U2 = e3.p, {};
}
function te() {
  return true;
}
function ee() {
  var t4 = B;
  B = [], E2(t4);
}
function Xe(t4) {
  if (B.length === 0 && !et) {
    var e3 = B;
    queueMicrotask(() => {
      e3 === B && ee();
    });
  }
  B.push(t4);
}
function Ze() {
  for (; B.length > 0; ) ee();
}
function Je(t4) {
  var e3 = F;
  if (e3 === null) return _3.f |= ht, t4;
  if ((e3.f & Jt) === 0) {
    if ((e3.f & At) === 0) throw t4;
    e3.b.error(t4);
  } else ne(t4, e3);
}
function ne(t4, e3) {
  for (; e3 !== null; ) {
    if ((e3.f & At) !== 0) try {
      e3.b.error(t4);
      return;
    } catch (n6) {
      t4 = n6;
    }
    e3 = e3.parent;
  }
  throw t4;
}
function $n(t4) {
  var e3 = et;
  et = true;
  try {
    for (var n6; ; ) {
      if (Ze(), N2.length === 0 && (y3?.flush(), N2.length === 0)) return dt = null, n6;
      se();
    }
  } finally {
    et = e3;
  }
}
function se() {
  var t4 = W;
  gt = true;
  try {
    var e3 = 0;
    for (Yt(true); N2.length > 0; ) {
      var n6 = X2.ensure();
      if (e3++ > 1e3) {
        var s5, r5;
        Qe();
      }
      n6.process(N2), L.clear();
    }
  } finally {
    gt = false, Yt(t4), dt = null;
  }
}
function Qe() {
  try {
    Be();
  } catch (t4) {
    ne(t4, dt);
  }
}
function qt(t4) {
  var e3 = t4.length;
  if (e3 !== 0) {
    for (var n6 = 0; n6 < e3; ) {
      var s5 = t4[n6++];
      if ((s5.f & (Y | M)) === 0 && lt(s5) && (O3 = /* @__PURE__ */ new Set(), st(s5), s5.deps === null && s5.first === null && s5.nodes_start === null && (s5.teardown === null && s5.ac === null ? Fe(s5) : s5.fn = null), O3?.size > 0)) {
        L.clear();
        for (const r5 of O3) {
          if ((r5.f & (Y | M)) !== 0) continue;
          const l7 = [r5];
          let i7 = r5.parent;
          for (; i7 !== null; ) O3.has(i7) && (O3.delete(i7), l7.push(i7)), i7 = i7.parent;
          for (let u8 = l7.length - 1; u8 >= 0; u8--) {
            const f8 = l7[u8];
            (f8.f & (Y | M)) === 0 && st(f8);
          }
        }
        O3.clear();
      }
    }
    O3 = null;
  }
}
function re(t4, e3, n6, s5) {
  if (!n6.has(t4) && (n6.add(t4), t4.reactions !== null)) for (const r5 of t4.reactions) {
    const l7 = r5.f;
    (l7 & m3) !== 0 ? re(r5, e3, n6, s5) : (l7 & (Qt | R3)) !== 0 && (l7 & S) === 0 && ie(r5, e3, s5) && (g4(r5, S), Z(r5));
  }
}
function ie(t4, e3, n6) {
  const s5 = n6.get(t4);
  if (s5 !== void 0) return s5;
  if (t4.deps !== null) for (const r5 of t4.deps) {
    if (e3.includes(r5)) return true;
    if ((r5.f & m3) !== 0 && ie(r5, e3, n6)) return n6.set(r5, true), true;
  }
  return n6.set(t4, false), false;
}
function Z(t4) {
  for (var e3 = dt = t4; e3.parent !== null; ) {
    e3 = e3.parent;
    var n6 = e3.f;
    if (gt && e3 === F && (n6 & R3) !== 0) return;
    if ((n6 & (V | K)) !== 0) {
      if ((n6 & b3) === 0) return;
      e3.f ^= b3;
    }
  }
  N2.push(e3);
}
function le(t4) {
  var e3 = t4.effects;
  if (e3 !== null) {
    t4.effects = null;
    for (var n6 = 0; n6 < e3.length; n6 += 1) H(e3[n6]);
  }
}
function tn(t4) {
  for (var e3 = t4.parent; e3 !== null; ) {
    if ((e3.f & m3) === 0) return e3;
    e3 = e3.parent;
  }
  return null;
}
function Ot(t4) {
  var e3, n6 = F;
  _t(tn(t4));
  try {
    t4.f &= ~ct, le(t4), e3 = ge(t4);
  } finally {
    _t(n6);
  }
  return e3;
}
function fe(t4) {
  var e3 = Ot(t4);
  if (t4.equals(e3) || (t4.v = e3, t4.wv = ye()), !it) if (A2 !== null) A2.set(t4, t4.v);
  else {
    var n6 = ($2 || (t4.f & C3) !== 0) && t4.deps !== null ? I2 : b3;
    g4(t4, n6);
  }
}
function oe(t4, e3) {
  var n6 = { f: 0, v: t4, reactions: null, equals: P2, rv: 0, wv: 0 };
  return n6;
}
function P3(t4, e3) {
  const n6 = oe(t4);
  return an(n6), n6;
}
function Mn(t4, e3 = false, n6 = true) {
  const s5 = oe(t4);
  return e3 || (s5.equals = T), s5;
}
function q2(t4, e3, n6 = false) {
  _3 !== null && (!k || (_3.f & $t) !== 0) && te() && (_3.f & (m3 | R3 | Qt | $t)) !== 0 && !D?.includes(t4) && Ue();
  let s5 = n6 ? Q(e3) : e3;
  return en(t4, s5);
}
function en(t4, e3) {
  if (!t4.equals(e3)) {
    var n6 = t4.v;
    it ? L.set(t4, e3) : L.set(t4, n6), t4.v = e3;
    var s5 = X2.ensure();
    s5.capture(t4, n6), (t4.f & m3) !== 0 && ((t4.f & S) !== 0 && Ot(t4), g4(t4, (t4.f & C3) === 0 ? b3 : I2)), t4.wv = ye(), ae(t4, S), F !== null && (F.f & b3) !== 0 && (F.f & (K | V)) === 0 && (x3 === null ? cn([t4]) : x3.push(t4)), !s5.is_fork && mt.size > 0 && !ue && nn();
  }
  return e3;
}
function nn() {
  ue = false;
  const t4 = Array.from(mt);
  for (const e3 of t4) (e3.f & b3) !== 0 && g4(e3, I2), lt(e3) && st(e3);
  mt.clear();
}
function Et(t4) {
  q2(t4, t4.v + 1);
}
function ae(t4, e3) {
  var n6 = t4.reactions;
  if (n6 !== null) for (var s5 = n6.length, r5 = 0; r5 < s5; r5++) {
    var l7 = n6[r5], i7 = l7.f, u8 = (i7 & S) === 0;
    u8 && g4(l7, e3), (i7 & m3) !== 0 ? (i7 & ct) === 0 && (l7.f |= ct, ae(l7, I2)) : u8 && ((i7 & R3) !== 0 && O3 !== null && O3.add(l7), Z(l7));
  }
}
function Q(t4) {
  if (typeof t4 != "object" || t4 === null || Ft in t4) return t4;
  const e3 = j2(t4);
  if (e3 !== h2 && e3 !== b2) return t4;
  var n6 = /* @__PURE__ */ new Map(), s5 = v2(t4), r5 = P3(0), l7 = j3, i7 = (u8) => {
    if (j3 === l7) return u8();
    var f8 = _3, o5 = j3;
    J(null), Ut(l7);
    var a5 = u8();
    return J(f8), Ut(o5), a5;
  };
  return s5 && n6.set("length", P3(t4.length)), new Proxy(t4, { defineProperty(u8, f8, o5) {
    (!("value" in o5) || o5.configurable === false || o5.enumerable === false || o5.writable === false) && Ye();
    var a5 = n6.get(f8);
    return a5 === void 0 ? a5 = i7(() => {
      var c7 = P3(o5.value);
      return n6.set(f8, c7), c7;
    }) : q2(a5, o5.value, true), true;
  }, deleteProperty(u8, f8) {
    var o5 = n6.get(f8);
    if (o5 === void 0) {
      if (f8 in u8) {
        const a5 = i7(() => P3(w3));
        n6.set(f8, a5), Et(r5);
      }
    } else q2(o5, w3), Et(r5);
    return true;
  }, get(u8, f8, o5) {
    if (f8 === Ft) return t4;
    var a5 = n6.get(f8), c7 = f8 in u8;
    if (a5 === void 0 && (!c7 || x2(u8, f8)?.writable) && (a5 = i7(() => {
      var v5 = Q(c7 ? u8[f8] : w3), d2 = P3(v5);
      return d2;
    }), n6.set(f8, a5)), a5 !== void 0) {
      var h5 = ot(a5);
      return h5 === w3 ? void 0 : h5;
    }
    return Reflect.get(u8, f8, o5);
  }, getOwnPropertyDescriptor(u8, f8) {
    var o5 = Reflect.getOwnPropertyDescriptor(u8, f8);
    if (o5 && "value" in o5) {
      var a5 = n6.get(f8);
      a5 && (o5.value = ot(a5));
    } else if (o5 === void 0) {
      var c7 = n6.get(f8), h5 = c7?.v;
      if (c7 !== void 0 && h5 !== w3) return { enumerable: true, configurable: true, value: h5, writable: true };
    }
    return o5;
  }, has(u8, f8) {
    if (f8 === Ft) return true;
    var o5 = n6.get(f8), a5 = o5 !== void 0 && o5.v !== w3 || Reflect.has(u8, f8);
    if (o5 !== void 0 || F !== null && (!a5 || x2(u8, f8)?.writable)) {
      o5 === void 0 && (o5 = i7(() => {
        var h5 = a5 ? Q(u8[f8]) : w3, v5 = P3(h5);
        return v5;
      }), n6.set(f8, o5));
      var c7 = ot(o5);
      if (c7 === w3) return false;
    }
    return a5;
  }, set(u8, f8, o5, a5) {
    var c7 = n6.get(f8), h5 = f8 in u8;
    if (s5 && f8 === "length") for (var v5 = o5; v5 < c7.v; v5 += 1) {
      var d2 = n6.get(v5 + "");
      d2 !== void 0 ? q2(d2, w3) : v5 in u8 && (d2 = i7(() => P3(w3)), n6.set(v5 + "", d2));
    }
    if (c7 === void 0) (!h5 || x2(u8, f8)?.writable) && (c7 = i7(() => P3(void 0)), q2(c7, Q(o5)), n6.set(f8, c7));
    else {
      h5 = c7.v !== w3;
      var z3 = i7(() => Q(o5));
      q2(c7, z3);
    }
    var Ct3 = Reflect.getOwnPropertyDescriptor(u8, f8);
    if (Ct3?.set && Ct3.set.call(a5, o5), !h5) {
      if (s5 && typeof f8 == "string") {
        var Dt3 = n6.get("length"), pt2 = Number(f8);
        Number.isInteger(pt2) && pt2 >= Dt3.v && q2(Dt3, pt2 + 1);
      }
      Et(r5);
    }
    return true;
  }, ownKeys(u8) {
    ot(r5);
    var f8 = Reflect.ownKeys(u8).filter((c7) => {
      var h5 = n6.get(c7);
      return h5 === void 0 || h5.v !== w3;
    });
    for (var [o5, a5] of n6) a5.v !== w3 && !(o5 in u8) && f8.push(o5);
    return f8;
  }, setPrototypeOf() {
    je();
  } });
}
function Ln() {
  if (Bt === void 0) {
    Bt = window;
    var t4 = Element.prototype, e3 = Node.prototype, n6 = Text.prototype;
    ce = x2(e3, "firstChild").get, he = x2(e3, "nextSibling").get, O2(t4) && (t4.__click = void 0, t4.__className = void 0, t4.__attributes = null, t4.__style = void 0, t4.__e = void 0), O2(n6) && (n6.__t = void 0);
  }
}
function qn(t4 = "") {
  return document.createTextNode(t4);
}
function Bn(t4) {
  return ce.call(t4);
}
function _e(t4) {
  return he.call(t4);
}
function Yn(t4) {
  t4.textContent = "";
}
function ve(t4) {
  var e3 = _3, n6 = F;
  J(null), _t(null);
  try {
    return t4();
  } finally {
    J(e3), _t(n6);
  }
}
function sn(t4, e3) {
  var n6 = e3.last;
  n6 === null ? e3.last = e3.first = t4 : (n6.next = t4, t4.prev = n6, e3.last = t4);
}
function rt(t4, e3, n6, s5 = true) {
  var r5 = F;
  r5 !== null && (r5.f & M) !== 0 && (t4 |= M);
  var l7 = { ctx: U2, deps: null, nodes_start: null, nodes_end: null, f: t4 | S, first: null, fn: e3, last: null, next: null, parent: r5, b: r5 && r5.b, prev: null, teardown: null, transitions: null, wv: 0, ac: null };
  if (n6) try {
    st(l7), l7.f |= Jt;
  } catch (f8) {
    throw H(l7), f8;
  }
  else e3 !== null && Z(l7);
  if (s5) {
    var i7 = l7;
    if (n6 && i7.deps === null && i7.teardown === null && i7.nodes_start === null && i7.first === i7.last && (i7.f & kt) === 0 && (i7 = i7.first, (t4 & R3) !== 0 && (t4 & yt) !== 0 && i7 !== null && (i7.f |= yt)), i7 !== null && (i7.parent = r5, r5 !== null && sn(i7, r5), _3 !== null && (_3.f & m3) !== 0 && (t4 & V) === 0)) {
      var u8 = _3;
      (u8.effects ??= []).push(i7);
    }
  }
  return l7;
}
function jn() {
  return _3 !== null && !k;
}
function rn(t4) {
  return rt(Zt | qe, t4, false);
}
function Un(t4) {
  X2.ensure();
  const e3 = rt(V | kt, t4, true);
  return (n6 = {}) => new Promise((s5) => {
    n6.outro ? un(e3, () => {
      H(e3), s5(void 0);
    }) : (H(e3), s5(void 0));
  });
}
function Hn(t4, e3 = 0) {
  return rt(Me | e3, t4, true);
}
function Kn(t4, e3 = 0) {
  var n6 = rt(R3 | e3, t4, true);
  return n6;
}
function Vn(t4, e3 = true) {
  return rt(K | kt, t4, true, e3);
}
function de(t4) {
  var e3 = t4.teardown;
  if (e3 !== null) {
    const n6 = it, s5 = _3;
    jt(true), J(null);
    try {
      e3.call(null);
    } finally {
      jt(n6), J(s5);
    }
  }
}
function pe(t4, e3 = false) {
  var n6 = t4.first;
  for (t4.first = t4.last = null; n6 !== null; ) {
    const r5 = n6.ac;
    r5 !== null && ve(() => {
      r5.abort(Nt);
    });
    var s5 = n6.next;
    (n6.f & V) !== 0 ? n6.parent = null : H(n6, e3), n6 = s5;
  }
}
function ln(t4) {
  for (var e3 = t4.first; e3 !== null; ) {
    var n6 = e3.next;
    (e3.f & K) === 0 && H(e3), e3 = n6;
  }
}
function H(t4, e3 = true) {
  var n6 = false;
  (e3 || (t4.f & Le) !== 0) && t4.nodes_start !== null && t4.nodes_end !== null && (fn(t4.nodes_start, t4.nodes_end), n6 = true), pe(t4, e3 && !n6), vt(t4, 0), g4(t4, Y);
  var s5 = t4.transitions;
  if (s5 !== null) for (const l7 of s5) l7.stop();
  de(t4);
  var r5 = t4.parent;
  r5 !== null && r5.first !== null && Fe(t4), t4.next = t4.prev = t4.teardown = t4.ctx = t4.deps = t4.fn = t4.nodes_start = t4.nodes_end = t4.ac = null;
}
function fn(t4, e3) {
  for (; t4 !== null; ) {
    var n6 = t4 === e3 ? null : _e(t4);
    t4.remove(), t4 = n6;
  }
}
function Fe(t4) {
  var e3 = t4.parent, n6 = t4.prev, s5 = t4.next;
  n6 !== null && (n6.next = s5), s5 !== null && (s5.prev = n6), e3 !== null && (e3.first === t4 && (e3.first = s5), e3.last === t4 && (e3.last = n6));
}
function un(t4, e3, n6 = true) {
  var s5 = [];
  Ee(t4, s5, true), on(s5, () => {
    n6 && H(t4), e3 && e3();
  });
}
function on(t4, e3) {
  var n6 = t4.length;
  if (n6 > 0) {
    var s5 = () => --n6 || e3();
    for (var r5 of t4) r5.out(s5);
  } else e3();
}
function Ee(t4, e3, n6) {
  if ((t4.f & M) === 0) {
    if (t4.f ^= M, t4.transitions !== null) for (const i7 of t4.transitions) (i7.is_global || n6) && e3.push(i7);
    for (var s5 = t4.first; s5 !== null; ) {
      var r5 = s5.next, l7 = (s5.f & yt) !== 0 || (s5.f & K) !== 0 && (t4.f & R3) !== 0;
      Ee(s5, e3, l7 ? n6 : false), s5 = r5;
    }
  }
}
function zn(t4, e3) {
  for (var n6 = t4.nodes_start, s5 = t4.nodes_end; n6 !== null; ) {
    var r5 = n6 === s5 ? null : _e(n6);
    e3.append(n6), n6 = r5;
  }
}
function Yt(t4) {
  W = t4;
}
function jt(t4) {
  it = t4;
}
function J(t4) {
  _3 = t4;
}
function _t(t4) {
  F = t4;
}
function an(t4) {
  _3 !== null && (D === null ? D = [t4] : D.push(t4));
}
function cn(t4) {
  x3 = t4;
}
function Ut(t4) {
  j3 = t4;
}
function ye() {
  return ++we;
}
function lt(t4) {
  var e3 = t4.f;
  if ((e3 & S) !== 0) return true;
  if ((e3 & I2) !== 0) {
    var n6 = t4.deps, s5 = (e3 & C3) !== 0;
    if (e3 & m3 && (t4.f &= ~ct), n6 !== null) {
      var r5, l7, i7 = (e3 & at) !== 0, u8 = s5 && F !== null && !$2, f8 = n6.length;
      if ((i7 || u8) && (F === null || (F.f & Y) === 0)) {
        var o5 = t4, a5 = o5.parent;
        for (r5 = 0; r5 < f8; r5++) l7 = n6[r5], (i7 || !l7?.reactions?.includes(o5)) && (l7.reactions ??= []).push(o5);
        i7 && (o5.f ^= at), u8 && a5 !== null && (a5.f & C3) === 0 && (o5.f ^= C3);
      }
      for (r5 = 0; r5 < f8; r5++) if (l7 = n6[r5], lt(l7) && fe(l7), l7.wv > t4.wv) return true;
    }
    (!s5 || F !== null && !$2) && g4(t4, b3);
  }
  return false;
}
function be(t4, e3, n6 = true) {
  var s5 = t4.reactions;
  if (s5 !== null && !D?.includes(t4)) for (var r5 = 0; r5 < s5.length; r5++) {
    var l7 = s5[r5];
    (l7.f & m3) !== 0 ? be(l7, e3, false) : e3 === l7 && (n6 ? g4(l7, S) : (l7.f & b3) !== 0 && g4(l7, I2), Z(l7));
  }
}
function ge(t4) {
  var e3 = E3, n6 = T2, s5 = x3, r5 = _3, l7 = $2, i7 = D, u8 = U2, f8 = k, o5 = j3, a5 = t4.f;
  E3 = null, T2 = 0, x3 = null, $2 = (a5 & C3) !== 0 && (k || !W || _3 === null), _3 = (a5 & (K | V)) === 0 ? t4 : null, D = null, Mt(t4.ctx), k = false, j3 = ++nt, t4.ac !== null && (ve(() => {
    t4.ac.abort(Nt);
  }), t4.ac = null);
  try {
    t4.f |= bt;
    var c7 = t4.fn, h5 = c7(), v5 = t4.deps;
    if (E3 !== null) {
      var d2;
      if (vt(t4, T2), v5 !== null && T2 > 0) for (v5.length = T2 + E3.length, d2 = 0; d2 < E3.length; d2++) v5[T2 + d2] = E3[d2];
      else t4.deps = v5 = E3;
      if (!$2 || (a5 & m3) !== 0 && t4.reactions !== null) for (d2 = T2; d2 < v5.length; d2++) (v5[d2].reactions ??= []).push(t4);
    } else v5 !== null && T2 < v5.length && (vt(t4, T2), v5.length = T2);
    if (te() && x3 !== null && !k && v5 !== null && (t4.f & (m3 | I2 | S)) === 0) for (d2 = 0; d2 < x3.length; d2++) be(x3[d2], t4);
    return r5 !== null && r5 !== t4 && (nt++, x3 !== null && (s5 === null ? s5 = x3 : s5.push(...x3))), (t4.f & ht) !== 0 && (t4.f ^= ht), h5;
  } catch (z3) {
    return Je(z3);
  } finally {
    t4.f ^= bt, E3 = e3, T2 = n6, x3 = s5, _3 = r5, $2 = l7, D = i7, Mt(u8), k = f8, j3 = o5;
  }
}
function hn(t4, e3) {
  let n6 = e3.reactions;
  if (n6 !== null) {
    var s5 = d.call(n6, t4);
    if (s5 !== -1) {
      var r5 = n6.length - 1;
      r5 === 0 ? n6 = e3.reactions = null : (n6[s5] = n6[r5], n6.pop());
    }
  }
  n6 === null && (e3.f & m3) !== 0 && (E3 === null || !E3.includes(e3)) && (g4(e3, I2), (e3.f & (C3 | at)) === 0 && (e3.f ^= at), le(e3), vt(e3, 0));
}
function vt(t4, e3) {
  var n6 = t4.deps;
  if (n6 !== null) for (var s5 = e3; s5 < n6.length; s5++) hn(t4, n6[s5]);
}
function st(t4) {
  var e3 = t4.f;
  if ((e3 & Y) === 0) {
    g4(t4, b3);
    var n6 = F, s5 = W;
    F = t4, W = true;
    try {
      (e3 & R3) !== 0 ? ln(t4) : pe(t4), de(t4);
      var r5 = ge(t4);
      t4.teardown = typeof r5 == "function" ? r5 : null, t4.wv = we;
      var l7;
      s && We && (t4.f & S) !== 0 && t4.deps;
    } finally {
      W = s5, F = n6;
    }
  }
}
function ot(t4) {
  var e3 = t4.f, n6 = (e3 & m3) !== 0;
  if (_3 !== null && !k) {
    var s5 = F !== null && (F.f & Y) !== 0;
    if (!s5 && !D?.includes(t4)) {
      var r5 = _3.deps;
      if ((_3.f & bt) !== 0) t4.rv < nt && (t4.rv = nt, E3 === null && r5 !== null && r5[T2] === t4 ? T2++ : E3 === null ? E3 = [t4] : (!$2 || !E3.includes(t4)) && E3.push(t4));
      else {
        (_3.deps ??= []).push(t4);
        var l7 = t4.reactions;
        l7 === null ? t4.reactions = [_3] : l7.includes(_3) || l7.push(_3);
      }
    }
  } else if (n6 && t4.deps === null && t4.effects === null) {
    var i7 = t4, u8 = i7.parent;
    u8 !== null && (u8.f & C3) === 0 && (i7.f ^= C3);
  }
  if (it) {
    if (L.has(t4)) return L.get(t4);
    if (n6) {
      i7 = t4;
      var f8 = i7.v;
      return ((i7.f & b3) === 0 && i7.reactions !== null || me(i7)) && (f8 = Ot(i7)), L.set(i7, f8), f8;
    }
  } else if (n6) {
    if (i7 = t4, A2?.has(i7)) return A2.get(i7);
    lt(i7) && fe(i7);
  }
  if (A2?.has(t4)) return A2.get(t4);
  if ((t4.f & ht) !== 0) throw t4.v;
  return t4.v;
}
function me(t4) {
  if (t4.v === w3) return true;
  if (t4.deps === null) return false;
  for (const e3 of t4.deps) if (L.has(e3) || (e3.f & m3) !== 0 && me(e3)) return true;
  return false;
}
function _n(t4) {
  var e3 = k;
  try {
    return k = true, t4();
  } finally {
    k = e3;
  }
}
function g4(t4, e3) {
  t4.f = t4.f & vn | e3;
}
function pn(t4) {
  return dn.includes(t4);
}
function Gn(t4) {
  return Fn.includes(t4);
}
function En(t4, e3, n6 = false) {
  if (t4 === "hidden" && e3 !== "until-found" && (n6 = true), e3 == null || !e3 && n6) return "";
  const s5 = t4 in Ht && Ht[t4].get(e3) || e3, r5 = n6 ? "" : `="${C2(s5, true)}"`;
  return ` ${t4}${r5}`;
}
function wn(t4) {
  return typeof t4 == "object" ? clsx(t4) : t4 ?? "";
}
function Te(t4, e3, n6) {
  var s5 = t4 == null ? "" : "" + t4;
  if (e3 && (s5 = s5 ? s5 + " " + e3 : e3), n6) {
    for (var r5 in n6) if (n6[r5]) s5 = s5 ? s5 + " " + r5 : r5;
    else if (s5.length) for (var l7 = r5.length, i7 = 0; (i7 = s5.indexOf(r5, i7)) >= 0; ) {
      var u8 = i7 + l7;
      (i7 === 0 || Kt.includes(s5[i7 - 1])) && (u8 === s5.length || Kt.includes(s5[u8])) ? s5 = (i7 === 0 ? "" : s5.substring(0, i7)) + s5.substring(u8 + 1) : i7 = u8;
    }
  }
  return s5 === "" ? null : s5;
}
function Vt(t4, e3 = false) {
  var n6 = e3 ? " !important;" : ";", s5 = "";
  for (var r5 in t4) {
    var l7 = t4[r5];
    l7 != null && l7 !== "" && (s5 += " " + r5 + ": " + l7 + n6);
  }
  return s5;
}
function wt(t4) {
  return t4[0] !== "-" || t4[1] !== "-" ? t4.toLowerCase() : t4;
}
function xe(t4, e3) {
  if (e3) {
    var n6 = "", s5, r5;
    if (Array.isArray(e3) ? (s5 = e3[0], r5 = e3[1]) : s5 = e3, t4) {
      t4 = String(t4).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var l7 = false, i7 = 0, u8 = false, f8 = [];
      s5 && f8.push(...Object.keys(s5).map(wt)), r5 && f8.push(...Object.keys(r5).map(wt));
      var o5 = 0, a5 = -1;
      const z3 = t4.length;
      for (var c7 = 0; c7 < z3; c7++) {
        var h5 = t4[c7];
        if (u8 ? h5 === "/" && t4[c7 - 1] === "*" && (u8 = false) : l7 ? l7 === h5 && (l7 = false) : h5 === "/" && t4[c7 + 1] === "*" ? u8 = true : h5 === '"' || h5 === "'" ? l7 = h5 : h5 === "(" ? i7++ : h5 === ")" && i7--, !u8 && l7 === false && i7 === 0) {
          if (h5 === ":" && a5 === -1) a5 = c7;
          else if (h5 === ";" || c7 === z3 - 1) {
            if (a5 !== -1) {
              var v5 = wt(t4.substring(o5, a5).trim());
              if (!f8.includes(v5)) {
                h5 !== ";" && c7++;
                var d2 = t4.substring(o5, c7).trim();
                n6 += " " + d2 + ";";
              }
            }
            o5 = c7 + 1, a5 = -1;
          }
        }
      }
    }
    return s5 && (n6 += Vt(s5)), r5 && (n6 += Vt(r5, true)), n6 = n6.trim(), n6 === "" ? null : n6;
  }
  return t4 == null ? null : String(t4);
}
function yn(t4, e3, n6) {
  if (t4 == null) return e3(void 0), w2;
  const s5 = _n(() => t4.subscribe(e3, n6));
  return s5.unsubscribe ? () => s5.unsubscribe() : s5;
}
function Gt() {
  zt?.abort(Nt), zt = null;
}
function bn() {
  const t4 = new Error(`await_invalid
Encountered asynchronous work while rendering synchronously.
https://svelte.dev/e/await_invalid`);
  throw t4.name = "Svelte error", t4;
}
function Wn(t4, e3 = {}) {
  return p3.render(t4, e3);
}
function Xn(t4, e3) {
  t4.head((n6) => {
    n6.push(Tt), n6.child(e3), n6.push(xt);
  });
}
function Wt(t4, e3, n6, s5, r5 = 0) {
  s5 && (t4.style = xe(t4.style, s5)), t4.class && (t4.class = wn(t4.class)), (e3 || n6) && (t4.class = Te(t4.class, e3, n6));
  let l7 = "", i7;
  const u8 = (r5 & Ve) === 0, f8 = (r5 & ze) === 0, o5 = (r5 & Ge) !== 0;
  for (i7 in t4) if (typeof t4[i7] != "function" && !(i7[0] === "$" && i7[1] === "$") && !mn.test(i7)) {
    var a5 = t4[i7];
    f8 && (i7 = i7.toLowerCase()), !(o5 && (i7 === "defaultvalue" || i7 === "defaultchecked") && (i7 = i7 === "defaultvalue" ? "value" : "checked", t4[i7])) && (l7 += En(i7, a5, u8 && pn(i7)));
  }
  return l7;
}
function Zn(t4) {
  return typeof t4 == "string" ? t4 : t4 == null ? "" : t4 + "";
}
function Jn(t4, e3, n6) {
  var s5 = Te(t4, e3, n6);
  return s5 ? ` class="${C2(s5, true)}"` : "";
}
function Qn(t4, e3) {
  var n6 = xe(t4, e3);
  return n6 ? ` style="${C2(n6, true)}"` : "";
}
function ts(t4, e3, n6) {
  if (e3 in t4 && t4[e3][0] === n6) return t4[e3][2];
  t4[e3]?.[1](), t4[e3] = [n6, null, void 0];
  const s5 = yn(n6, (r5) => t4[e3][2] = r5);
  return t4[e3][1] = s5, t4[e3][2];
}
function es(t4) {
  for (const e3 in t4) t4[e3][1]();
}
function ns(t4, e3, n6, s5, r5) {
  var l7 = e3.$$slots?.[n6];
  l7 === true && (l7 = e3[n6 === "default" ? "children" : n6]), l7 !== void 0 && l7(t4, s5);
}
function ss(t4, e3) {
  for (const n6 in e3) {
    const s5 = t4[n6], r5 = e3[n6];
    s5 === void 0 && r5 !== void 0 && Object.getOwnPropertyDescriptor(t4, n6)?.set && (t4[n6] = r5);
  }
}
function rs(t4) {
  return t4 ? t4.length !== void 0 ? t4 : Array.from(t4) : [];
}
var m3, Zt, Me, R3, K, V, At, b3, S, I2, M, Y, Jt, yt, $t, Le, kt, qe, C3, at, ct, bt, Qt, ht, Ft, An, Nt, Nn, He, Dn, Ke, Rn, Ve, ze, Ge, w3, We, U2, B, ut, y3, A2, Lt, N2, dt, gt, et, X2, O3, mt, L, ue, Bt, ce, he, W, it, _3, k, F, D, E3, T2, x3, we, nt, j3, $2, vn, dn, Fn, Ht, Kt, Tt, xt, zt, p3, gn, mn;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    init_context();
    init_clsx();
    init_false();
    m3 = 2;
    Zt = 4;
    Me = 8;
    R3 = 16;
    K = 32;
    V = 64;
    At = 128;
    b3 = 1024;
    S = 2048;
    I2 = 4096;
    M = 8192;
    Y = 16384;
    Jt = 32768;
    yt = 65536;
    $t = 1 << 17;
    Le = 1 << 18;
    kt = 1 << 19;
    qe = 1 << 20;
    C3 = 256;
    at = 512;
    ct = 32768;
    bt = 1 << 21;
    Qt = 1 << 22;
    ht = 1 << 23;
    Ft = Symbol("$state");
    An = Symbol("legacy props");
    Nt = new class extends Error {
      name = "StaleReactionError";
      message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
    }();
    Nn = 8;
    He = "[";
    Dn = "[!";
    Ke = "]";
    Rn = {};
    Ve = 1;
    ze = 2;
    Ge = 4;
    w3 = Symbol();
    We = false;
    U2 = null;
    B = [];
    ut = /* @__PURE__ */ new Set();
    y3 = null;
    A2 = null;
    Lt = /* @__PURE__ */ new Set();
    N2 = [];
    dt = null;
    gt = false;
    et = false;
    X2 = class _X {
      committed = false;
      current = /* @__PURE__ */ new Map();
      previous = /* @__PURE__ */ new Map();
      #t = /* @__PURE__ */ new Set();
      #s = /* @__PURE__ */ new Set();
      #n = 0;
      #e = 0;
      #a = null;
      #l = [];
      #f = [];
      skipped_effects = /* @__PURE__ */ new Set();
      is_fork = false;
      process(e3) {
        N2 = [], this.apply();
        var n6 = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] };
        for (const s5 of e3) this.#r(s5, n6);
        this.is_fork || this.#u(), this.#e > 0 || this.is_fork ? (this.#i(n6.effects), this.#i(n6.render_effects), this.#i(n6.block_effects)) : (y3 = null, qt(n6.render_effects), qt(n6.effects)), A2 = null;
      }
      #r(e3, n6) {
        e3.f ^= b3;
        for (var s5 = e3.first; s5 !== null; ) {
          var r5 = s5.f, l7 = (r5 & (K | V)) !== 0, i7 = l7 && (r5 & b3) !== 0, u8 = i7 || (r5 & M) !== 0 || this.skipped_effects.has(s5);
          if ((s5.f & At) !== 0 && s5.b?.is_pending() && (n6 = { parent: n6, effect: s5, effects: [], render_effects: [], block_effects: [] }), !u8 && s5.fn !== null) {
            l7 ? s5.f ^= b3 : (r5 & Zt) !== 0 ? n6.effects.push(s5) : lt(s5) && ((s5.f & R3) !== 0 && n6.block_effects.push(s5), st(s5));
            var f8 = s5.first;
            if (f8 !== null) {
              s5 = f8;
              continue;
            }
          }
          var o5 = s5.parent;
          for (s5 = s5.next; s5 === null && o5 !== null; ) o5 === n6.effect && (this.#i(n6.effects), this.#i(n6.render_effects), this.#i(n6.block_effects), n6 = n6.parent), s5 = o5.next, o5 = o5.parent;
        }
      }
      #i(e3) {
        for (const n6 of e3) ((n6.f & S) !== 0 ? this.#l : this.#f).push(n6), g4(n6, b3);
      }
      capture(e3, n6) {
        this.previous.has(e3) || this.previous.set(e3, n6), this.current.set(e3, e3.v), A2?.set(e3, e3.v);
      }
      activate() {
        y3 = this;
      }
      deactivate() {
        y3 = null, A2 = null;
      }
      flush() {
        if (this.activate(), N2.length > 0) {
          if (se(), y3 !== null && y3 !== this) return;
        } else this.#n === 0 && this.process([]);
        this.deactivate();
        for (const e3 of Lt) if (Lt.delete(e3), e3(), y3 !== null) break;
      }
      discard() {
        for (const e3 of this.#s) e3(this);
        this.#s.clear();
      }
      #u() {
        if (this.#e === 0) {
          for (const e3 of this.#t) e3();
          this.#t.clear();
        }
        this.#n === 0 && this.#o();
      }
      #o() {
        if (ut.size > 1) {
          this.previous.clear();
          var e3 = A2, n6 = true, s5 = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] };
          for (const r5 of ut) {
            if (r5 === this) {
              n6 = false;
              continue;
            }
            const l7 = [];
            for (const [u8, f8] of this.current) {
              if (r5.current.has(u8)) if (n6 && f8 !== r5.current.get(u8)) r5.current.set(u8, f8);
              else continue;
              l7.push(u8);
            }
            if (l7.length === 0) continue;
            const i7 = [...r5.current.keys()].filter((u8) => !this.current.has(u8));
            if (i7.length > 0) {
              const u8 = /* @__PURE__ */ new Set(), f8 = /* @__PURE__ */ new Map();
              for (const o5 of l7) re(o5, i7, u8, f8);
              if (N2.length > 0) {
                y3 = r5, r5.apply();
                for (const o5 of N2) r5.#r(o5, s5);
                N2 = [], r5.deactivate();
              }
            }
          }
          y3 = null, A2 = e3;
        }
        this.committed = true, ut.delete(this), this.#a?.resolve();
      }
      increment(e3) {
        this.#n += 1, e3 && (this.#e += 1);
      }
      decrement(e3) {
        this.#n -= 1, e3 && (this.#e -= 1), this.revive();
      }
      revive() {
        for (const e3 of this.#l) g4(e3, S), Z(e3);
        for (const e3 of this.#f) g4(e3, I2), Z(e3);
        this.#l = [], this.#f = [], this.flush();
      }
      oncommit(e3) {
        this.#t.add(e3);
      }
      ondiscard(e3) {
        this.#s.add(e3);
      }
      settled() {
        return (this.#a ??= A()).promise;
      }
      static ensure() {
        if (y3 === null) {
          const e3 = y3 = new _X();
          ut.add(y3), et || _X.enqueue(() => {
            y3 === e3 && e3.flush();
          });
        }
        return y3;
      }
      static enqueue(e3) {
        Xe(e3);
      }
      apply() {
      }
    };
    O3 = null;
    mt = /* @__PURE__ */ new Set();
    L = /* @__PURE__ */ new Map();
    ue = false;
    W = false;
    it = false;
    _3 = null;
    k = false;
    F = null;
    D = null;
    E3 = null;
    T2 = 0;
    x3 = null;
    we = 1;
    nt = 0;
    j3 = nt;
    $2 = false;
    vn = -7169;
    dn = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "indeterminate", "inert", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected", "webkitdirectory", "defer", "disablepictureinpicture", "disableremoteplayback"];
    Fn = ["touchstart", "touchmove"];
    Ht = { translate: /* @__PURE__ */ new Map([[true, "yes"], [false, "no"]]) };
    Kt = [...` 	
\r\f\xA0\v\uFEFF`];
    Tt = `<!--${He}-->`;
    xt = `<!--${Ke}-->`;
    zt = null;
    p3 = class _p {
      #t = [];
      #s = void 0;
      #n = false;
      type;
      #e;
      promise = void 0;
      global;
      local;
      constructor(e3, n6) {
        this.#e = n6, this.global = e3, this.local = n6 ? { ...n6.local } : { select_value: void 0 }, this.type = n6 ? n6.type : "body";
      }
      head(e3) {
        const n6 = new _p(this.global, this);
        n6.type = "head", this.#t.push(n6), n6.child(e3);
      }
      async(e3) {
        this.#t.push(Tt), this.child(e3), this.#t.push(xt);
      }
      child(e3) {
        const n6 = new _p(this.global, this);
        this.#t.push(n6);
        const s5 = r2;
        R2({ ...r2, p: s5, c: null, r: n6 });
        const r5 = e3(n6);
        return R2(s5), r5 instanceof Promise && (n6.global.mode === "sync" && bn(), r5.catch(() => {
        }), n6.promise = r5), n6;
      }
      component(e3, n6) {
        N();
        const s5 = this.child(e3);
        s5.#n = true, X();
      }
      select(e3, n6, s5, r5, l7, i7) {
        const { value: u8, ...f8 } = e3;
        this.push(`<select${Wt(f8, s5, r5, l7, i7)}>`), this.child((o5) => {
          o5.local.select_value = u8, n6(o5);
        }), this.push("</select>");
      }
      option(e3, n6, s5, r5, l7, i7) {
        this.#t.push(`<option${Wt(e3, s5, r5, l7, i7)}`);
        const u8 = (f8, o5, { head: a5, body: c7 }) => {
          "value" in e3 && (o5 = e3.value), o5 === this.local.select_value && f8.#t.push(" selected"), f8.#t.push(`>${c7}</option>`), a5 && f8.head((h5) => h5.push(a5));
        };
        typeof n6 == "function" ? this.child((f8) => {
          const o5 = new _p(this.global, this);
          if (n6(o5), this.global.mode === "async") return o5.#o().then((a5) => {
            u8(f8, a5.body.replaceAll("<!---->", ""), a5);
          });
          {
            const a5 = o5.#u();
            u8(f8, a5.body.replaceAll("<!---->", ""), a5);
          }
        }) : u8(this, n6, { body: n6 });
      }
      title(e3) {
        const n6 = this.get_path(), s5 = (r5) => {
          this.global.set_title(r5, n6);
        };
        this.child((r5) => {
          const l7 = new _p(r5.global, r5);
          if (e3(l7), r5.global.mode === "async") return l7.#o().then((i7) => {
            s5(i7.head);
          });
          {
            const i7 = l7.#u();
            s5(i7.head);
          }
        });
      }
      push(e3) {
        typeof e3 == "function" ? this.child(async (n6) => n6.push(await e3())) : this.#t.push(e3);
      }
      on_destroy(e3) {
        (this.#s ??= []).push(e3);
      }
      get_path() {
        return this.#e ? [...this.#e.get_path(), this.#e.#t.indexOf(this)] : [];
      }
      copy() {
        const e3 = new _p(this.global, this.#e);
        return e3.#t = this.#t.map((n6) => n6 instanceof _p ? n6.copy() : n6), e3.promise = this.promise, e3;
      }
      subsume(e3) {
        if (this.global.mode !== e3.global.mode) throw new Error("invariant: A renderer cannot switch modes. If you're seeing this, there's a compiler bug. File an issue!");
        this.local = e3.local, this.#t = e3.#t.map((n6) => (n6 instanceof _p && n6.subsume(n6), n6)), this.promise = e3.promise, this.type = e3.type;
      }
      get length() {
        return this.#t.length;
      }
      static render(e3, n6 = {}) {
        let s5;
        const r5 = {};
        return Object.defineProperties(r5, { html: { get: () => (s5 ??= _p.#r(e3, n6)).body }, head: { get: () => (s5 ??= _p.#r(e3, n6)).head }, body: { get: () => (s5 ??= _p.#r(e3, n6)).body }, then: { value: (l7, i7) => {
          {
            const u8 = s5 ??= _p.#r(e3, n6), f8 = l7({ head: u8.head, body: u8.body, html: u8.body });
            return Promise.resolve(f8);
          }
        } } }), r5;
      }
      *#a() {
        for (const e3 of this.#l()) yield* e3.#f();
      }
      *#l() {
        for (const e3 of this.#t) typeof e3 != "string" && (yield* e3.#l());
        this.#n && (yield this);
      }
      *#f() {
        if (this.#s) for (const e3 of this.#s) yield e3;
        for (const e3 of this.#t) e3 instanceof _p && !e3.#n && (yield* e3.#f());
      }
      static #r(e3, n6) {
        var s5 = r2;
        try {
          const r5 = _p.#c("sync", e3, n6), l7 = r5.#u();
          return _p.#h(l7, r5);
        } finally {
          Gt(), R2(s5);
        }
      }
      static async #i(e3, n6) {
        var s5 = r2;
        try {
          const r5 = _p.#c("async", e3, n6), l7 = await r5.#o();
          return _p.#h(l7, r5);
        } finally {
          Gt(), R2(s5);
        }
      }
      #u(e3 = { head: "", body: "" }) {
        for (const n6 of this.#t) typeof n6 == "string" ? e3[this.type] += n6 : n6 instanceof _p && n6.#u(e3);
        return e3;
      }
      async #o(e3 = { head: "", body: "" }) {
        await this.promise;
        for (const n6 of this.#t) typeof n6 == "string" ? e3[this.type] += n6 : n6 instanceof _p && await n6.#o(e3);
        return e3;
      }
      static #c(e3, n6, s5) {
        const r5 = new _p(new gn(e3, s5.idPrefix ? s5.idPrefix + "-" : ""));
        return r5.push(Tt), s5.context && (N(), r2.c = s5.context, r2.r = r5), n6(r5, s5.props ?? {}), s5.context && X(), r5.push(xt), r5;
      }
      static #h(e3, n6) {
        for (const l7 of n6.#a()) l7();
        let s5 = e3.head + n6.global.get_title(), r5 = e3.body;
        for (const { hash: l7, code: i7 } of n6.global.css) s5 += `<style id="${l7}">${i7}</style>`;
        return { head: s5, body: r5 };
      }
    };
    gn = class {
      mode;
      uid;
      css = /* @__PURE__ */ new Set();
      #t = { path: [], value: "" };
      constructor(e3, n6 = "") {
        this.mode = e3;
        let s5 = 1;
        this.uid = () => `${n6}s${s5++}`;
      }
      get_title() {
        return this.#t.value;
      }
      set_title(e3, n6) {
        const s5 = this.#t.path;
        let r5 = 0, l7 = Math.min(n6.length, s5.length);
        for (; r5 < l7 && n6[r5] === s5[r5]; ) r5 += 1;
        n6[r5] !== void 0 && (s5[r5] === void 0 || n6[r5] > s5[r5]) && (this.#t.path = n6, this.#t.value = e3);
      }
    };
    mn = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
  }
});

// node_modules/tslib/tslib.es6.mjs
function __rest(s5, e3) {
  var t4 = {};
  for (var p6 in s5) if (Object.prototype.hasOwnProperty.call(s5, p6) && e3.indexOf(p6) < 0)
    t4[p6] = s5[p6];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i7 = 0, p6 = Object.getOwnPropertySymbols(s5); i7 < p6.length; i7++) {
      if (e3.indexOf(p6[i7]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p6[i7]))
        t4[p6[i7]] = s5[p6[i7]];
    }
  return t4;
}
function __awaiter(thisArg, _arguments, P8, generator) {
  function adopt(value) {
    return value instanceof P8 ? value : new P8(function(resolve) {
      resolve(value);
    });
  }
  return new (P8 || (P8 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
  }
});

// node_modules/@supabase/functions-js/dist/module/helper.js
var resolveFetch;
var init_helper = __esm({
  "node_modules/@supabase/functions-js/dist/module/helper.js"() {
    resolveFetch = (customFetch) => {
      if (customFetch) {
        return (...args) => customFetch(...args);
      }
      return (...args) => fetch(...args);
    };
  }
});

// node_modules/@supabase/functions-js/dist/module/types.js
var FunctionsError, FunctionsFetchError, FunctionsRelayError, FunctionsHttpError, FunctionRegion;
var init_types = __esm({
  "node_modules/@supabase/functions-js/dist/module/types.js"() {
    FunctionsError = class extends Error {
      constructor(message, name = "FunctionsError", context) {
        super(message);
        this.name = name;
        this.context = context;
      }
    };
    FunctionsFetchError = class extends FunctionsError {
      constructor(context) {
        super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
      }
    };
    FunctionsRelayError = class extends FunctionsError {
      constructor(context) {
        super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
      }
    };
    FunctionsHttpError = class extends FunctionsError {
      constructor(context) {
        super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
      }
    };
    (function(FunctionRegion2) {
      FunctionRegion2["Any"] = "any";
      FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
      FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
      FunctionRegion2["ApSouth1"] = "ap-south-1";
      FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
      FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
      FunctionRegion2["CaCentral1"] = "ca-central-1";
      FunctionRegion2["EuCentral1"] = "eu-central-1";
      FunctionRegion2["EuWest1"] = "eu-west-1";
      FunctionRegion2["EuWest2"] = "eu-west-2";
      FunctionRegion2["EuWest3"] = "eu-west-3";
      FunctionRegion2["SaEast1"] = "sa-east-1";
      FunctionRegion2["UsEast1"] = "us-east-1";
      FunctionRegion2["UsWest1"] = "us-west-1";
      FunctionRegion2["UsWest2"] = "us-west-2";
    })(FunctionRegion || (FunctionRegion = {}));
  }
});

// node_modules/@supabase/functions-js/dist/module/FunctionsClient.js
var FunctionsClient;
var init_FunctionsClient = __esm({
  "node_modules/@supabase/functions-js/dist/module/FunctionsClient.js"() {
    init_tslib_es6();
    init_helper();
    init_types();
    FunctionsClient = class {
      /**
       * Creates a new Functions client bound to an Edge Functions URL.
       *
       * @example
       * ```ts
       * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'
       *
       * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {
       *   headers: { apikey: 'public-anon-key' },
       *   region: FunctionRegion.UsEast1,
       * })
       * ```
       */
      constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any } = {}) {
        this.url = url;
        this.headers = headers;
        this.region = region;
        this.fetch = resolveFetch(customFetch);
      }
      /**
       * Updates the authorization header
       * @param token - the new jwt token sent in the authorisation header
       * @example
       * ```ts
       * functions.setAuth(session.access_token)
       * ```
       */
      setAuth(token) {
        this.headers.Authorization = `Bearer ${token}`;
      }
      /**
       * Invokes a function
       * @param functionName - The name of the Function to invoke.
       * @param options - Options for invoking the Function.
       * @example
       * ```ts
       * const { data, error } = await functions.invoke('hello-world', {
       *   body: { name: 'Ada' },
       * })
       * ```
       */
      invoke(functionName_1) {
        return __awaiter(this, arguments, void 0, function* (functionName, options = {}) {
          var _a;
          let timeoutId;
          let timeoutController;
          try {
            const { headers, method, body: functionArgs, signal, timeout } = options;
            let _headers = {};
            let { region } = options;
            if (!region) {
              region = this.region;
            }
            const url = new URL(`${this.url}/${functionName}`);
            if (region && region !== "any") {
              _headers["x-region"] = region;
              url.searchParams.set("forceFunctionRegion", region);
            }
            let body;
            if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
              if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
                _headers["Content-Type"] = "application/octet-stream";
                body = functionArgs;
              } else if (typeof functionArgs === "string") {
                _headers["Content-Type"] = "text/plain";
                body = functionArgs;
              } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
                body = functionArgs;
              } else {
                _headers["Content-Type"] = "application/json";
                body = JSON.stringify(functionArgs);
              }
            } else {
              if (functionArgs && typeof functionArgs !== "string" && !(typeof Blob !== "undefined" && functionArgs instanceof Blob) && !(functionArgs instanceof ArrayBuffer) && !(typeof FormData !== "undefined" && functionArgs instanceof FormData)) {
                body = JSON.stringify(functionArgs);
              } else {
                body = functionArgs;
              }
            }
            let effectiveSignal = signal;
            if (timeout) {
              timeoutController = new AbortController();
              timeoutId = setTimeout(() => timeoutController.abort(), timeout);
              if (signal) {
                effectiveSignal = timeoutController.signal;
                signal.addEventListener("abort", () => timeoutController.abort());
              } else {
                effectiveSignal = timeoutController.signal;
              }
            }
            const response = yield this.fetch(url.toString(), {
              method: method || "POST",
              // headers priority is (high to low):
              // 1. invoke-level headers
              // 2. client-level headers
              // 3. default Content-Type header
              headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
              body,
              signal: effectiveSignal
            }).catch((fetchError) => {
              throw new FunctionsFetchError(fetchError);
            });
            const isRelayError = response.headers.get("x-relay-error");
            if (isRelayError && isRelayError === "true") {
              throw new FunctionsRelayError(response);
            }
            if (!response.ok) {
              throw new FunctionsHttpError(response);
            }
            let responseType = ((_a = response.headers.get("Content-Type")) !== null && _a !== void 0 ? _a : "text/plain").split(";")[0].trim();
            let data;
            if (responseType === "application/json") {
              data = yield response.json();
            } else if (responseType === "application/octet-stream" || responseType === "application/pdf") {
              data = yield response.blob();
            } else if (responseType === "text/event-stream") {
              data = response;
            } else if (responseType === "multipart/form-data") {
              data = yield response.formData();
            } else {
              data = yield response.text();
            }
            return { data, error: null, response };
          } catch (error2) {
            return {
              data: null,
              error: error2,
              response: error2 instanceof FunctionsHttpError || error2 instanceof FunctionsRelayError ? error2.context : void 0
            };
          } finally {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
          }
        });
      }
    };
  }
});

// node_modules/@supabase/functions-js/dist/module/index.js
var init_module = __esm({
  "node_modules/@supabase/functions-js/dist/module/index.js"() {
    init_FunctionsClient();
  }
});

// node_modules/@supabase/postgrest-js/dist/index.mjs
function _typeof(o5) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
    return typeof o$1;
  } : function(o$1) {
    return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
  }, _typeof(o5);
}
function toPrimitive(t4, r5) {
  if ("object" != _typeof(t4) || !t4) return t4;
  var e3 = t4[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i7 = e3.call(t4, r5 || "default");
    if ("object" != _typeof(i7)) return i7;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r5 ? String : Number)(t4);
}
function toPropertyKey(t4) {
  var i7 = toPrimitive(t4, "string");
  return "symbol" == _typeof(i7) ? i7 : i7 + "";
}
function _defineProperty(e3, r5, t4) {
  return (r5 = toPropertyKey(r5)) in e3 ? Object.defineProperty(e3, r5, {
    value: t4,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r5] = t4, e3;
}
function ownKeys(e3, r5) {
  var t4 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o5 = Object.getOwnPropertySymbols(e3);
    r5 && (o5 = o5.filter(function(r$1) {
      return Object.getOwnPropertyDescriptor(e3, r$1).enumerable;
    })), t4.push.apply(t4, o5);
  }
  return t4;
}
function _objectSpread2(e3) {
  for (var r5 = 1; r5 < arguments.length; r5++) {
    var t4 = null != arguments[r5] ? arguments[r5] : {};
    r5 % 2 ? ownKeys(Object(t4), true).forEach(function(r$1) {
      _defineProperty(e3, r$1, t4[r$1]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t4)) : ownKeys(Object(t4)).forEach(function(r$1) {
      Object.defineProperty(e3, r$1, Object.getOwnPropertyDescriptor(t4, r$1));
    });
  }
  return e3;
}
var PostgrestError, PostgrestBuilder, PostgrestTransformBuilder, PostgrestReservedCharsRegexp, PostgrestFilterBuilder, PostgrestQueryBuilder, PostgrestClient;
var init_dist = __esm({
  "node_modules/@supabase/postgrest-js/dist/index.mjs"() {
    PostgrestError = class extends Error {
      /**
      * @example
      * ```ts
      * import PostgrestError from '@supabase/postgrest-js'
      *
      * throw new PostgrestError({
      *   message: 'Row level security prevented the request',
      *   details: 'RLS denied the insert',
      *   hint: 'Check your policies',
      *   code: 'PGRST301',
      * })
      * ```
      */
      constructor(context) {
        super(context.message);
        this.name = "PostgrestError";
        this.details = context.details;
        this.hint = context.hint;
        this.code = context.code;
      }
    };
    PostgrestBuilder = class {
      /**
      * Creates a builder configured for a specific PostgREST request.
      *
      * @example
      * ```ts
      * import PostgrestQueryBuilder from '@supabase/postgrest-js'
      *
      * const builder = new PostgrestQueryBuilder(
      *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
      *   { headers: new Headers({ apikey: 'public-anon-key' }) }
      * )
      * ```
      */
      constructor(builder) {
        var _builder$shouldThrowO, _builder$isMaybeSingl, _builder$urlLengthLim;
        this.shouldThrowOnError = false;
        this.method = builder.method;
        this.url = builder.url;
        this.headers = new Headers(builder.headers);
        this.schema = builder.schema;
        this.body = builder.body;
        this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;
        this.signal = builder.signal;
        this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;
        this.urlLengthLimit = (_builder$urlLengthLim = builder.urlLengthLimit) !== null && _builder$urlLengthLim !== void 0 ? _builder$urlLengthLim : 8e3;
        if (builder.fetch) this.fetch = builder.fetch;
        else this.fetch = fetch;
      }
      /**
      * If there's an error with the query, throwOnError will reject the promise by
      * throwing the error instead of returning it as part of a successful response.
      *
      * {@link https://github.com/supabase/supabase-js/issues/92}
      */
      throwOnError() {
        this.shouldThrowOnError = true;
        return this;
      }
      /**
      * Set an HTTP header for the request.
      */
      setHeader(name, value) {
        this.headers = new Headers(this.headers);
        this.headers.set(name, value);
        return this;
      }
      then(onfulfilled, onrejected) {
        var _this = this;
        if (this.schema === void 0) {
        } else if (["GET", "HEAD"].includes(this.method)) this.headers.set("Accept-Profile", this.schema);
        else this.headers.set("Content-Profile", this.schema);
        if (this.method !== "GET" && this.method !== "HEAD") this.headers.set("Content-Type", "application/json");
        const _fetch = this.fetch;
        let res = _fetch(this.url.toString(), {
          method: this.method,
          headers: this.headers,
          body: JSON.stringify(this.body),
          signal: this.signal
        }).then(async (res$1) => {
          let error2 = null;
          let data = null;
          let count = null;
          let status = res$1.status;
          let statusText = res$1.statusText;
          if (res$1.ok) {
            var _this$headers$get2, _res$headers$get;
            if (_this.method !== "HEAD") {
              var _this$headers$get;
              const body = await res$1.text();
              if (body === "") {
              } else if (_this.headers.get("Accept") === "text/csv") data = body;
              else if (_this.headers.get("Accept") && ((_this$headers$get = _this.headers.get("Accept")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes("application/vnd.pgrst.plan+text"))) data = body;
              else data = JSON.parse(body);
            }
            const countHeader = (_this$headers$get2 = _this.headers.get("Prefer")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);
            const contentRange = (_res$headers$get = res$1.headers.get("content-range")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split("/");
            if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);
            if (_this.isMaybeSingle && _this.method === "GET" && Array.isArray(data)) if (data.length > 1) {
              error2 = {
                code: "PGRST116",
                details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                hint: null,
                message: "JSON object requested, multiple (or no) rows returned"
              };
              data = null;
              count = null;
              status = 406;
              statusText = "Not Acceptable";
            } else if (data.length === 1) data = data[0];
            else data = null;
          } else {
            var _error$details;
            const body = await res$1.text();
            try {
              error2 = JSON.parse(body);
              if (Array.isArray(error2) && res$1.status === 404) {
                data = [];
                error2 = null;
                status = 200;
                statusText = "OK";
              }
            } catch (_unused) {
              if (res$1.status === 404 && body === "") {
                status = 204;
                statusText = "No Content";
              } else error2 = { message: body };
            }
            if (error2 && _this.isMaybeSingle && (error2 === null || error2 === void 0 || (_error$details = error2.details) === null || _error$details === void 0 ? void 0 : _error$details.includes("0 rows"))) {
              error2 = null;
              status = 200;
              statusText = "OK";
            }
            if (error2 && _this.shouldThrowOnError) throw new PostgrestError(error2);
          }
          return {
            error: error2,
            data,
            count,
            status,
            statusText
          };
        });
        if (!this.shouldThrowOnError) res = res.catch((fetchError) => {
          var _fetchError$name2;
          let errorDetails = "";
          let hint = "";
          let code = "";
          const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;
          if (cause) {
            var _cause$message, _cause$code, _fetchError$name, _cause$name;
            const causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : "";
            const causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : "";
            errorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;
            errorDetails += `

Caused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : "Error"}: ${causeMessage}`;
            if (causeCode) errorDetails += ` (${causeCode})`;
            if (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += `
${cause.stack}`;
          } else {
            var _fetchError$stack;
            errorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : "";
          }
          const urlLength = this.url.toString().length;
          if ((fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) === "AbortError" || (fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) === "ABORT_ERR") {
            code = "";
            hint = "Request was aborted (timeout or manual cancellation)";
            if (urlLength > this.urlLengthLimit) hint += `. Note: Your request URL is ${urlLength} characters, which may exceed server limits. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [many IDs])), consider using an RPC function to pass values server-side.`;
          } else if ((cause === null || cause === void 0 ? void 0 : cause.name) === "HeadersOverflowError" || (cause === null || cause === void 0 ? void 0 : cause.code) === "UND_ERR_HEADERS_OVERFLOW") {
            code = "";
            hint = "HTTP headers exceeded server limits (typically 16KB)";
            if (urlLength > this.urlLengthLimit) hint += `. Your request URL is ${urlLength} characters. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [200+ IDs])), consider using an RPC function instead.`;
          }
          return {
            error: {
              message: `${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
              details: errorDetails,
              hint,
              code
            },
            data: null,
            count: null,
            status: 0,
            statusText: ""
          };
        });
        return res.then(onfulfilled, onrejected);
      }
      /**
      * Override the type of the returned `data`.
      *
      * @typeParam NewResult - The new result type to override with
      * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
      */
      returns() {
        return this;
      }
      /**
      * Override the type of the returned `data` field in the response.
      *
      * @typeParam NewResult - The new type to cast the response data to
      * @typeParam Options - Optional type configuration (defaults to { merge: true })
      * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
      * @example
      * ```typescript
      * // Merge with existing types (default behavior)
      * const query = supabase
      *   .from('users')
      *   .select()
      *   .overrideTypes<{ custom_field: string }>()
      *
      * // Replace existing types completely
      * const replaceQuery = supabase
      *   .from('users')
      *   .select()
      *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
      * ```
      * @returns A PostgrestBuilder instance with the new type
      */
      overrideTypes() {
        return this;
      }
    };
    PostgrestTransformBuilder = class extends PostgrestBuilder {
      /**
      * Perform a SELECT on the query result.
      *
      * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
      * return modified rows. By calling this method, modified rows are returned in
      * `data`.
      *
      * @param columns - The columns to retrieve, separated by commas
      */
      select(columns) {
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c7) => {
          if (/\s/.test(c7) && !quoted) return "";
          if (c7 === '"') quoted = !quoted;
          return c7;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        this.headers.append("Prefer", "return=representation");
        return this;
      }
      /**
      * Order the query result by `column`.
      *
      * You can call this method multiple times to order by multiple columns.
      *
      * You can order referenced tables, but it only affects the ordering of the
      * parent table if you use `!inner` in the query.
      *
      * @param column - The column to order by
      * @param options - Named parameters
      * @param options.ascending - If `true`, the result will be in ascending order
      * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
      * `null`s appear last.
      * @param options.referencedTable - Set this to order a referenced table by
      * its columns
      * @param options.foreignTable - Deprecated, use `options.referencedTable`
      * instead
      */
      order(column, { ascending: ascending2 = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.order` : "order";
        const existingOrder = this.url.searchParams.get(key);
        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending2 ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
        return this;
      }
      /**
      * Limit the query result by `count`.
      *
      * @param count - The maximum number of rows to return
      * @param options - Named parameters
      * @param options.referencedTable - Set this to limit rows of referenced
      * tables instead of the parent table
      * @param options.foreignTable - Deprecated, use `options.referencedTable`
      * instead
      */
      limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(key, `${count}`);
        return this;
      }
      /**
      * Limit the query result by starting at an offset `from` and ending at the offset `to`.
      * Only records within this range are returned.
      * This respects the query order and if there is no order clause the range could behave unexpectedly.
      * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
      * and fourth rows of the query.
      *
      * @param from - The starting index from which to limit the result
      * @param to - The last index to which to limit the result
      * @param options - Named parameters
      * @param options.referencedTable - Set this to limit rows of referenced
      * tables instead of the parent table
      * @param options.foreignTable - Deprecated, use `options.referencedTable`
      * instead
      */
      range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
        const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
        const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
      }
      /**
      * Set the AbortSignal for the fetch request.
      *
      * @param signal - The AbortSignal to use for the fetch request
      */
      abortSignal(signal) {
        this.signal = signal;
        return this;
      }
      /**
      * Return `data` as a single object instead of an array of objects.
      *
      * Query result must be one row (e.g. using `.limit(1)`), otherwise this
      * returns an error.
      */
      single() {
        this.headers.set("Accept", "application/vnd.pgrst.object+json");
        return this;
      }
      /**
      * Return `data` as a single object instead of an array of objects.
      *
      * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
      * this returns an error.
      */
      maybeSingle() {
        if (this.method === "GET") this.headers.set("Accept", "application/json");
        else this.headers.set("Accept", "application/vnd.pgrst.object+json");
        this.isMaybeSingle = true;
        return this;
      }
      /**
      * Return `data` as a string in CSV format.
      */
      csv() {
        this.headers.set("Accept", "text/csv");
        return this;
      }
      /**
      * Return `data` as an object in [GeoJSON](https://geojson.org) format.
      */
      geojson() {
        this.headers.set("Accept", "application/geo+json");
        return this;
      }
      /**
      * Return `data` as the EXPLAIN plan for the query.
      *
      * You need to enable the
      * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
      * setting before using this method.
      *
      * @param options - Named parameters
      *
      * @param options.analyze - If `true`, the query will be executed and the
      * actual run time will be returned
      *
      * @param options.verbose - If `true`, the query identifier will be returned
      * and `data` will include the output columns of the query
      *
      * @param options.settings - If `true`, include information on configuration
      * parameters that affect query planning
      *
      * @param options.buffers - If `true`, include information on buffer usage
      *
      * @param options.wal - If `true`, include information on WAL record generation
      *
      * @param options.format - The format of the output, can be `"text"` (default)
      * or `"json"`
      */
      explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
        var _this$headers$get;
        const options = [
          analyze ? "analyze" : null,
          verbose ? "verbose" : null,
          settings ? "settings" : null,
          buffers ? "buffers" : null,
          wal ? "wal" : null
        ].filter(Boolean).join("|");
        const forMediatype = (_this$headers$get = this.headers.get("Accept")) !== null && _this$headers$get !== void 0 ? _this$headers$get : "application/json";
        this.headers.set("Accept", `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`);
        if (format === "json") return this;
        else return this;
      }
      /**
      * Rollback the query.
      *
      * `data` will still be returned, but the query is not committed.
      */
      rollback() {
        this.headers.append("Prefer", "tx=rollback");
        return this;
      }
      /**
      * Override the type of the returned `data`.
      *
      * @typeParam NewResult - The new result type to override with
      * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
      */
      returns() {
        return this;
      }
      /**
      * Set the maximum number of rows that can be affected by the query.
      * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.
      *
      * @param value - The maximum number of rows that can be affected
      */
      maxAffected(value) {
        this.headers.append("Prefer", "handling=strict");
        this.headers.append("Prefer", `max-affected=${value}`);
        return this;
      }
    };
    PostgrestReservedCharsRegexp = /* @__PURE__ */ new RegExp("[,()]");
    PostgrestFilterBuilder = class extends PostgrestTransformBuilder {
      /**
      * Match only rows where `column` is equal to `value`.
      *
      * To check if the value of `column` is NULL, you should use `.is()` instead.
      *
      * @param column - The column to filter on
      * @param value - The value to filter with
      */
      eq(column, value) {
        this.url.searchParams.append(column, `eq.${value}`);
        return this;
      }
      /**
      * Match only rows where `column` is not equal to `value`.
      *
      * @param column - The column to filter on
      * @param value - The value to filter with
      */
      neq(column, value) {
        this.url.searchParams.append(column, `neq.${value}`);
        return this;
      }
      /**
      * Match only rows where `column` is greater than `value`.
      *
      * @param column - The column to filter on
      * @param value - The value to filter with
      */
      gt(column, value) {
        this.url.searchParams.append(column, `gt.${value}`);
        return this;
      }
      /**
      * Match only rows where `column` is greater than or equal to `value`.
      *
      * @param column - The column to filter on
      * @param value - The value to filter with
      */
      gte(column, value) {
        this.url.searchParams.append(column, `gte.${value}`);
        return this;
      }
      /**
      * Match only rows where `column` is less than `value`.
      *
      * @param column - The column to filter on
      * @param value - The value to filter with
      */
      lt(column, value) {
        this.url.searchParams.append(column, `lt.${value}`);
        return this;
      }
      /**
      * Match only rows where `column` is less than or equal to `value`.
      *
      * @param column - The column to filter on
      * @param value - The value to filter with
      */
      lte(column, value) {
        this.url.searchParams.append(column, `lte.${value}`);
        return this;
      }
      /**
      * Match only rows where `column` matches `pattern` case-sensitively.
      *
      * @param column - The column to filter on
      * @param pattern - The pattern to match with
      */
      like(column, pattern) {
        this.url.searchParams.append(column, `like.${pattern}`);
        return this;
      }
      /**
      * Match only rows where `column` matches all of `patterns` case-sensitively.
      *
      * @param column - The column to filter on
      * @param patterns - The patterns to match with
      */
      likeAllOf(column, patterns) {
        this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
      * Match only rows where `column` matches any of `patterns` case-sensitively.
      *
      * @param column - The column to filter on
      * @param patterns - The patterns to match with
      */
      likeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
      * Match only rows where `column` matches `pattern` case-insensitively.
      *
      * @param column - The column to filter on
      * @param pattern - The pattern to match with
      */
      ilike(column, pattern) {
        this.url.searchParams.append(column, `ilike.${pattern}`);
        return this;
      }
      /**
      * Match only rows where `column` matches all of `patterns` case-insensitively.
      *
      * @param column - The column to filter on
      * @param patterns - The patterns to match with
      */
      ilikeAllOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
      * Match only rows where `column` matches any of `patterns` case-insensitively.
      *
      * @param column - The column to filter on
      * @param patterns - The patterns to match with
      */
      ilikeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
      * Match only rows where `column` matches the PostgreSQL regex `pattern`
      * case-sensitively (using the `~` operator).
      *
      * @param column - The column to filter on
      * @param pattern - The PostgreSQL regular expression pattern to match with
      */
      regexMatch(column, pattern) {
        this.url.searchParams.append(column, `match.${pattern}`);
        return this;
      }
      /**
      * Match only rows where `column` matches the PostgreSQL regex `pattern`
      * case-insensitively (using the `~*` operator).
      *
      * @param column - The column to filter on
      * @param pattern - The PostgreSQL regular expression pattern to match with
      */
      regexIMatch(column, pattern) {
        this.url.searchParams.append(column, `imatch.${pattern}`);
        return this;
      }
      /**
      * Match only rows where `column` IS `value`.
      *
      * For non-boolean columns, this is only relevant for checking if the value of
      * `column` is NULL by setting `value` to `null`.
      *
      * For boolean columns, you can also set `value` to `true` or `false` and it
      * will behave the same way as `.eq()`.
      *
      * @param column - The column to filter on
      * @param value - The value to filter with
      */
      is(column, value) {
        this.url.searchParams.append(column, `is.${value}`);
        return this;
      }
      /**
      * Match only rows where `column` IS DISTINCT FROM `value`.
      *
      * Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values
      * are considered equal (not distinct), and comparing `NULL` with any non-NULL
      * value returns true (distinct).
      *
      * @param column - The column to filter on
      * @param value - The value to filter with
      */
      isDistinct(column, value) {
        this.url.searchParams.append(column, `isdistinct.${value}`);
        return this;
      }
      /**
      * Match only rows where `column` is included in the `values` array.
      *
      * @param column - The column to filter on
      * @param values - The values array to filter with
      */
      in(column, values) {
        const cleanedValues = Array.from(new Set(values)).map((s5) => {
          if (typeof s5 === "string" && PostgrestReservedCharsRegexp.test(s5)) return `"${s5}"`;
          else return `${s5}`;
        }).join(",");
        this.url.searchParams.append(column, `in.(${cleanedValues})`);
        return this;
      }
      /**
      * Match only rows where `column` is NOT included in the `values` array.
      *
      * @param column - The column to filter on
      * @param values - The values array to filter with
      */
      notIn(column, values) {
        const cleanedValues = Array.from(new Set(values)).map((s5) => {
          if (typeof s5 === "string" && PostgrestReservedCharsRegexp.test(s5)) return `"${s5}"`;
          else return `${s5}`;
        }).join(",");
        this.url.searchParams.append(column, `not.in.(${cleanedValues})`);
        return this;
      }
      /**
      * Only relevant for jsonb, array, and range columns. Match only rows where
      * `column` contains every element appearing in `value`.
      *
      * @param column - The jsonb, array, or range column to filter on
      * @param value - The jsonb, array, or range value to filter with
      */
      contains(column, value) {
        if (typeof value === "string") this.url.searchParams.append(column, `cs.${value}`);
        else if (Array.isArray(value)) this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
        else this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
        return this;
      }
      /**
      * Only relevant for jsonb, array, and range columns. Match only rows where
      * every element appearing in `column` is contained by `value`.
      *
      * @param column - The jsonb, array, or range column to filter on
      * @param value - The jsonb, array, or range value to filter with
      */
      containedBy(column, value) {
        if (typeof value === "string") this.url.searchParams.append(column, `cd.${value}`);
        else if (Array.isArray(value)) this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
        else this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
        return this;
      }
      /**
      * Only relevant for range columns. Match only rows where every element in
      * `column` is greater than any element in `range`.
      *
      * @param column - The range column to filter on
      * @param range - The range to filter with
      */
      rangeGt(column, range) {
        this.url.searchParams.append(column, `sr.${range}`);
        return this;
      }
      /**
      * Only relevant for range columns. Match only rows where every element in
      * `column` is either contained in `range` or greater than any element in
      * `range`.
      *
      * @param column - The range column to filter on
      * @param range - The range to filter with
      */
      rangeGte(column, range) {
        this.url.searchParams.append(column, `nxl.${range}`);
        return this;
      }
      /**
      * Only relevant for range columns. Match only rows where every element in
      * `column` is less than any element in `range`.
      *
      * @param column - The range column to filter on
      * @param range - The range to filter with
      */
      rangeLt(column, range) {
        this.url.searchParams.append(column, `sl.${range}`);
        return this;
      }
      /**
      * Only relevant for range columns. Match only rows where every element in
      * `column` is either contained in `range` or less than any element in
      * `range`.
      *
      * @param column - The range column to filter on
      * @param range - The range to filter with
      */
      rangeLte(column, range) {
        this.url.searchParams.append(column, `nxr.${range}`);
        return this;
      }
      /**
      * Only relevant for range columns. Match only rows where `column` is
      * mutually exclusive to `range` and there can be no element between the two
      * ranges.
      *
      * @param column - The range column to filter on
      * @param range - The range to filter with
      */
      rangeAdjacent(column, range) {
        this.url.searchParams.append(column, `adj.${range}`);
        return this;
      }
      /**
      * Only relevant for array and range columns. Match only rows where
      * `column` and `value` have an element in common.
      *
      * @param column - The array or range column to filter on
      * @param value - The array or range value to filter with
      */
      overlaps(column, value) {
        if (typeof value === "string") this.url.searchParams.append(column, `ov.${value}`);
        else this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
        return this;
      }
      /**
      * Only relevant for text and tsvector columns. Match only rows where
      * `column` matches the query string in `query`.
      *
      * @param column - The text or tsvector column to filter on
      * @param query - The query text to match with
      * @param options - Named parameters
      * @param options.config - The text search configuration to use
      * @param options.type - Change how the `query` text is interpreted
      */
      textSearch(column, query, { config, type } = {}) {
        let typePart = "";
        if (type === "plain") typePart = "pl";
        else if (type === "phrase") typePart = "ph";
        else if (type === "websearch") typePart = "w";
        const configPart = config === void 0 ? "" : `(${config})`;
        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
        return this;
      }
      /**
      * Match only rows where each column in `query` keys is equal to its
      * associated value. Shorthand for multiple `.eq()`s.
      *
      * @param query - The object to filter with, with column names as keys mapped
      * to their filter values
      */
      match(query) {
        Object.entries(query).forEach(([column, value]) => {
          this.url.searchParams.append(column, `eq.${value}`);
        });
        return this;
      }
      /**
      * Match only rows which doesn't satisfy the filter.
      *
      * Unlike most filters, `opearator` and `value` are used as-is and need to
      * follow [PostgREST
      * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
      * to make sure they are properly sanitized.
      *
      * @param column - The column to filter on
      * @param operator - The operator to be negated to filter with, following
      * PostgREST syntax
      * @param value - The value to filter with, following PostgREST syntax
      */
      not(column, operator, value) {
        this.url.searchParams.append(column, `not.${operator}.${value}`);
        return this;
      }
      /**
      * Match only rows which satisfy at least one of the filters.
      *
      * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
      * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
      * to make sure it's properly sanitized.
      *
      * It's currently not possible to do an `.or()` filter across multiple tables.
      *
      * @param filters - The filters to use, following PostgREST syntax
      * @param options - Named parameters
      * @param options.referencedTable - Set this to filter on referenced tables
      * instead of the parent table
      * @param options.foreignTable - Deprecated, use `referencedTable` instead
      */
      or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.or` : "or";
        this.url.searchParams.append(key, `(${filters})`);
        return this;
      }
      /**
      * Match only rows which satisfy the filter. This is an escape hatch - you
      * should use the specific filter methods wherever possible.
      *
      * Unlike most filters, `opearator` and `value` are used as-is and need to
      * follow [PostgREST
      * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
      * to make sure they are properly sanitized.
      *
      * @param column - The column to filter on
      * @param operator - The operator to filter with, following PostgREST syntax
      * @param value - The value to filter with, following PostgREST syntax
      */
      filter(column, operator, value) {
        this.url.searchParams.append(column, `${operator}.${value}`);
        return this;
      }
    };
    PostgrestQueryBuilder = class {
      /**
      * Creates a query builder scoped to a Postgres table or view.
      *
      * @example
      * ```ts
      * import PostgrestQueryBuilder from '@supabase/postgrest-js'
      *
      * const query = new PostgrestQueryBuilder(
      *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
      *   { headers: { apikey: 'public-anon-key' } }
      * )
      * ```
      */
      constructor(url, { headers = {}, schema, fetch: fetch$1, urlLengthLimit = 8e3 }) {
        this.url = url;
        this.headers = new Headers(headers);
        this.schema = schema;
        this.fetch = fetch$1;
        this.urlLengthLimit = urlLengthLimit;
      }
      /**
      * Clone URL and headers to prevent shared state between operations.
      */
      cloneRequestState() {
        return {
          url: new URL(this.url.toString()),
          headers: new Headers(this.headers)
        };
      }
      /**
      * Perform a SELECT query on the table or view.
      *
      * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
      *
      * @param options - Named parameters
      *
      * @param options.head - When set to `true`, `data` will not be returned.
      * Useful if you only need the count.
      *
      * @param options.count - Count algorithm to use to count rows in the table or view.
      *
      * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
      * hood.
      *
      * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
      * statistics under the hood.
      *
      * `"estimated"`: Uses exact count for low numbers and planned count for high
      * numbers.
      *
      * @remarks
      * When using `count` with `.range()` or `.limit()`, the returned `count` is the total number of rows
      * that match your filters, not the number of rows in the current page. Use this to build pagination UI.
      */
      select(columns, options) {
        const { head: head2 = false, count } = options !== null && options !== void 0 ? options : {};
        const method = head2 ? "HEAD" : "GET";
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c7) => {
          if (/\s/.test(c7) && !quoted) return "";
          if (c7 === '"') quoted = !quoted;
          return c7;
        }).join("");
        const { url, headers } = this.cloneRequestState();
        url.searchParams.set("select", cleanedColumns);
        if (count) headers.append("Prefer", `count=${count}`);
        return new PostgrestFilterBuilder({
          method,
          url,
          headers,
          schema: this.schema,
          fetch: this.fetch,
          urlLengthLimit: this.urlLengthLimit
        });
      }
      /**
      * Perform an INSERT into the table or view.
      *
      * By default, inserted rows are not returned. To return it, chain the call
      * with `.select()`.
      *
      * @param values - The values to insert. Pass an object to insert a single row
      * or an array to insert multiple rows.
      *
      * @param options - Named parameters
      *
      * @param options.count - Count algorithm to use to count inserted rows.
      *
      * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
      * hood.
      *
      * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
      * statistics under the hood.
      *
      * `"estimated"`: Uses exact count for low numbers and planned count for high
      * numbers.
      *
      * @param options.defaultToNull - Make missing fields default to `null`.
      * Otherwise, use the default value for the column. Only applies for bulk
      * inserts.
      */
      insert(values, { count, defaultToNull = true } = {}) {
        var _this$fetch;
        const method = "POST";
        const { url, headers } = this.cloneRequestState();
        if (count) headers.append("Prefer", `count=${count}`);
        if (!defaultToNull) headers.append("Prefer", `missing=default`);
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x4) => acc.concat(Object.keys(x4)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder({
          method,
          url,
          headers,
          schema: this.schema,
          body: values,
          fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,
          urlLengthLimit: this.urlLengthLimit
        });
      }
      /**
      * Perform an UPSERT on the table or view. Depending on the column(s) passed
      * to `onConflict`, `.upsert()` allows you to perform the equivalent of
      * `.insert()` if a row with the corresponding `onConflict` columns doesn't
      * exist, or if it does exist, perform an alternative action depending on
      * `ignoreDuplicates`.
      *
      * By default, upserted rows are not returned. To return it, chain the call
      * with `.select()`.
      *
      * @param values - The values to upsert with. Pass an object to upsert a
      * single row or an array to upsert multiple rows.
      *
      * @param options - Named parameters
      *
      * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
      * duplicate rows are determined. Two rows are duplicates if all the
      * `onConflict` columns are equal.
      *
      * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
      * `false`, duplicate rows are merged with existing rows.
      *
      * @param options.count - Count algorithm to use to count upserted rows.
      *
      * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
      * hood.
      *
      * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
      * statistics under the hood.
      *
      * `"estimated"`: Uses exact count for low numbers and planned count for high
      * numbers.
      *
      * @param options.defaultToNull - Make missing fields default to `null`.
      * Otherwise, use the default value for the column. This only applies when
      * inserting new rows, not when merging with existing rows under
      * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
      *
      * @example Upsert a single row using a unique key
      * ```ts
      * // Upserting a single row, overwriting based on the 'username' unique column
      * const { data, error } = await supabase
      *   .from('users')
      *   .upsert({ username: 'supabot' }, { onConflict: 'username' })
      *
      * // Example response:
      * // {
      * //   data: [
      * //     { id: 4, message: 'bar', username: 'supabot' }
      * //   ],
      * //   error: null
      * // }
      * ```
      *
      * @example Upsert with conflict resolution and exact row counting
      * ```ts
      * // Upserting and returning exact count
      * const { data, error, count } = await supabase
      *   .from('users')
      *   .upsert(
      *     {
      *       id: 3,
      *       message: 'foo',
      *       username: 'supabot'
      *     },
      *     {
      *       onConflict: 'username',
      *       count: 'exact'
      *     }
      *   )
      *
      * // Example response:
      * // {
      * //   data: [
      * //     {
      * //       id: 42,
      * //       handle: "saoirse",
      * //       display_name: "Saoirse"
      * //     }
      * //   ],
      * //   count: 1,
      * //   error: null
      * // }
      * ```
      */
      upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
        var _this$fetch2;
        const method = "POST";
        const { url, headers } = this.cloneRequestState();
        headers.append("Prefer", `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`);
        if (onConflict !== void 0) url.searchParams.set("on_conflict", onConflict);
        if (count) headers.append("Prefer", `count=${count}`);
        if (!defaultToNull) headers.append("Prefer", "missing=default");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x4) => acc.concat(Object.keys(x4)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder({
          method,
          url,
          headers,
          schema: this.schema,
          body: values,
          fetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch,
          urlLengthLimit: this.urlLengthLimit
        });
      }
      /**
      * Perform an UPDATE on the table or view.
      *
      * By default, updated rows are not returned. To return it, chain the call
      * with `.select()` after filters.
      *
      * @param values - The values to update with
      *
      * @param options - Named parameters
      *
      * @param options.count - Count algorithm to use to count updated rows.
      *
      * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
      * hood.
      *
      * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
      * statistics under the hood.
      *
      * `"estimated"`: Uses exact count for low numbers and planned count for high
      * numbers.
      */
      update(values, { count } = {}) {
        var _this$fetch3;
        const method = "PATCH";
        const { url, headers } = this.cloneRequestState();
        if (count) headers.append("Prefer", `count=${count}`);
        return new PostgrestFilterBuilder({
          method,
          url,
          headers,
          schema: this.schema,
          body: values,
          fetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch,
          urlLengthLimit: this.urlLengthLimit
        });
      }
      /**
      * Perform a DELETE on the table or view.
      *
      * By default, deleted rows are not returned. To return it, chain the call
      * with `.select()` after filters.
      *
      * @param options - Named parameters
      *
      * @param options.count - Count algorithm to use to count deleted rows.
      *
      * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
      * hood.
      *
      * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
      * statistics under the hood.
      *
      * `"estimated"`: Uses exact count for low numbers and planned count for high
      * numbers.
      */
      delete({ count } = {}) {
        var _this$fetch4;
        const method = "DELETE";
        const { url, headers } = this.cloneRequestState();
        if (count) headers.append("Prefer", `count=${count}`);
        return new PostgrestFilterBuilder({
          method,
          url,
          headers,
          schema: this.schema,
          fetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch,
          urlLengthLimit: this.urlLengthLimit
        });
      }
    };
    PostgrestClient = class PostgrestClient2 {
      /**
      * Creates a PostgREST client.
      *
      * @param url - URL of the PostgREST endpoint
      * @param options - Named parameters
      * @param options.headers - Custom headers
      * @param options.schema - Postgres schema to switch to
      * @param options.fetch - Custom fetch
      * @param options.timeout - Optional timeout in milliseconds for all requests. When set, requests will automatically abort after this duration to prevent indefinite hangs.
      * @param options.urlLengthLimit - Maximum URL length in characters before warnings/errors are triggered. Defaults to 8000.
      * @example
      * ```ts
      * import PostgrestClient from '@supabase/postgrest-js'
      *
      * const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {
      *   headers: { apikey: 'public-anon-key' },
      *   schema: 'public',
      *   timeout: 30000, // 30 second timeout
      * })
      * ```
      */
      constructor(url, { headers = {}, schema, fetch: fetch$1, timeout, urlLengthLimit = 8e3 } = {}) {
        this.url = url;
        this.headers = new Headers(headers);
        this.schemaName = schema;
        this.urlLengthLimit = urlLengthLimit;
        const originalFetch = fetch$1 !== null && fetch$1 !== void 0 ? fetch$1 : globalThis.fetch;
        if (timeout !== void 0 && timeout > 0) this.fetch = (input, init35) => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          const existingSignal = init35 === null || init35 === void 0 ? void 0 : init35.signal;
          if (existingSignal) {
            if (existingSignal.aborted) {
              clearTimeout(timeoutId);
              return originalFetch(input, init35);
            }
            const abortHandler = () => {
              clearTimeout(timeoutId);
              controller.abort();
            };
            existingSignal.addEventListener("abort", abortHandler, { once: true });
            return originalFetch(input, _objectSpread2(_objectSpread2({}, init35), {}, { signal: controller.signal })).finally(() => {
              clearTimeout(timeoutId);
              existingSignal.removeEventListener("abort", abortHandler);
            });
          }
          return originalFetch(input, _objectSpread2(_objectSpread2({}, init35), {}, { signal: controller.signal })).finally(() => clearTimeout(timeoutId));
        };
        else this.fetch = originalFetch;
      }
      /**
      * Perform a query on a table or a view.
      *
      * @param relation - The table or view name to query
      */
      from(relation) {
        if (!relation || typeof relation !== "string" || relation.trim() === "") throw new Error("Invalid relation name: relation must be a non-empty string.");
        return new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {
          headers: new Headers(this.headers),
          schema: this.schemaName,
          fetch: this.fetch,
          urlLengthLimit: this.urlLengthLimit
        });
      }
      /**
      * Select a schema to query or perform an function (rpc) call.
      *
      * The schema needs to be on the list of exposed schemas inside Supabase.
      *
      * @param schema - The schema to query
      */
      schema(schema) {
        return new PostgrestClient2(this.url, {
          headers: this.headers,
          schema,
          fetch: this.fetch,
          urlLengthLimit: this.urlLengthLimit
        });
      }
      /**
      * Perform a function call.
      *
      * @param fn - The function name to call
      * @param args - The arguments to pass to the function call
      * @param options - Named parameters
      * @param options.head - When set to `true`, `data` will not be returned.
      * Useful if you only need the count.
      * @param options.get - When set to `true`, the function will be called with
      * read-only access mode.
      * @param options.count - Count algorithm to use to count rows returned by the
      * function. Only applicable for [set-returning
      * functions](https://www.postgresql.org/docs/current/functions-srf.html).
      *
      * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
      * hood.
      *
      * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
      * statistics under the hood.
      *
      * `"estimated"`: Uses exact count for low numbers and planned count for high
      * numbers.
      *
      * @example
      * ```ts
      * // For cross-schema functions where type inference fails, use overrideTypes:
      * const { data } = await supabase
      *   .schema('schema_b')
      *   .rpc('function_a', {})
      *   .overrideTypes<{ id: string; user_id: string }[]>()
      * ```
      */
      rpc(fn4, args = {}, { head: head2 = false, get: get7 = false, count } = {}) {
        var _this$fetch;
        let method;
        const url = new URL(`${this.url}/rpc/${fn4}`);
        let body;
        const _isObject = (v5) => v5 !== null && typeof v5 === "object" && (!Array.isArray(v5) || v5.some(_isObject));
        const _hasObjectArg = head2 && Object.values(args).some(_isObject);
        if (_hasObjectArg) {
          method = "POST";
          body = args;
        } else if (head2 || get7) {
          method = head2 ? "HEAD" : "GET";
          Object.entries(args).filter(([_5, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
            url.searchParams.append(name, value);
          });
        } else {
          method = "POST";
          body = args;
        }
        const headers = new Headers(this.headers);
        if (_hasObjectArg) headers.set("Prefer", count ? `count=${count},return=minimal` : "return=minimal");
        else if (count) headers.set("Prefer", `count=${count}`);
        return new PostgrestFilterBuilder({
          method,
          url,
          headers,
          schema: this.schemaName,
          body,
          fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,
          urlLengthLimit: this.urlLengthLimit
        });
      }
    };
  }
});

// node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js
var WebSocketFactory, websocket_factory_default;
var init_websocket_factory = __esm({
  "node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js"() {
    WebSocketFactory = class {
      /**
       * Static-only utility  prevent instantiation.
       */
      constructor() {
      }
      static detectEnvironment() {
        var _a;
        if (typeof WebSocket !== "undefined") {
          return { type: "native", constructor: WebSocket };
        }
        if (typeof globalThis !== "undefined" && typeof globalThis.WebSocket !== "undefined") {
          return { type: "native", constructor: globalThis.WebSocket };
        }
        if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
          return { type: "native", constructor: global.WebSocket };
        }
        if (typeof globalThis !== "undefined" && typeof globalThis.WebSocketPair !== "undefined" && typeof globalThis.WebSocket === "undefined") {
          return {
            type: "cloudflare",
            error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
            workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
          };
        }
        if (typeof globalThis !== "undefined" && globalThis.EdgeRuntime || typeof navigator !== "undefined" && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes("Vercel-Edge"))) {
          return {
            type: "unsupported",
            error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
            workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
          };
        }
        const _process = globalThis["process"];
        if (_process) {
          const processVersions = _process["versions"];
          if (processVersions && processVersions["node"]) {
            const versionString = processVersions["node"];
            const nodeVersion = parseInt(versionString.replace(/^v/, "").split(".")[0]);
            if (nodeVersion >= 22) {
              if (typeof globalThis.WebSocket !== "undefined") {
                return { type: "native", constructor: globalThis.WebSocket };
              }
              return {
                type: "unsupported",
                error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,
                workaround: "Provide a WebSocket implementation via the transport option."
              };
            }
            return {
              type: "unsupported",
              error: `Node.js ${nodeVersion} detected without native WebSocket support.`,
              workaround: 'For Node.js < 22, install "ws" package and provide it via the transport option:\nimport ws from "ws"\nnew RealtimeClient(url, { transport: ws })'
            };
          }
        }
        return {
          type: "unsupported",
          error: "Unknown JavaScript runtime without WebSocket support.",
          workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
        };
      }
      /**
       * Returns the best available WebSocket constructor for the current runtime.
       *
       * @example
       * ```ts
       * const WS = WebSocketFactory.getWebSocketConstructor()
       * const socket = new WS('wss://realtime.supabase.co/socket')
       * ```
       */
      static getWebSocketConstructor() {
        const env = this.detectEnvironment();
        if (env.constructor) {
          return env.constructor;
        }
        let errorMessage = env.error || "WebSocket not supported in this environment.";
        if (env.workaround) {
          errorMessage += `

Suggested solution: ${env.workaround}`;
        }
        throw new Error(errorMessage);
      }
      /**
       * Creates a WebSocket using the detected constructor.
       *
       * @example
       * ```ts
       * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')
       * ```
       */
      static createWebSocket(url, protocols) {
        const WS = this.getWebSocketConstructor();
        return new WS(url, protocols);
      }
      /**
       * Detects whether the runtime can establish WebSocket connections.
       *
       * @example
       * ```ts
       * if (!WebSocketFactory.isWebSocketSupported()) {
       *   console.warn('Falling back to long polling')
       * }
       * ```
       */
      static isWebSocketSupported() {
        try {
          const env = this.detectEnvironment();
          return env.type === "native" || env.type === "ws";
        } catch (_a) {
          return false;
        }
      }
    };
    websocket_factory_default = WebSocketFactory;
  }
});

// node_modules/@supabase/realtime-js/dist/module/lib/version.js
var version;
var init_version2 = __esm({
  "node_modules/@supabase/realtime-js/dist/module/lib/version.js"() {
    version = "2.95.3";
  }
});

// node_modules/@supabase/realtime-js/dist/module/lib/constants.js
var DEFAULT_VERSION, VSN_1_0_0, VSN_2_0_0, DEFAULT_VSN, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, MAX_PUSH_BUFFER_SIZE, SOCKET_STATES, CHANNEL_STATES, CHANNEL_EVENTS, TRANSPORTS, CONNECTION_STATE;
var init_constants2 = __esm({
  "node_modules/@supabase/realtime-js/dist/module/lib/constants.js"() {
    init_version2();
    DEFAULT_VERSION = `realtime-js/${version}`;
    VSN_1_0_0 = "1.0.0";
    VSN_2_0_0 = "2.0.0";
    DEFAULT_VSN = VSN_2_0_0;
    DEFAULT_TIMEOUT = 1e4;
    WS_CLOSE_NORMAL = 1e3;
    MAX_PUSH_BUFFER_SIZE = 100;
    (function(SOCKET_STATES2) {
      SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
      SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
      SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
      SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
    })(SOCKET_STATES || (SOCKET_STATES = {}));
    (function(CHANNEL_STATES2) {
      CHANNEL_STATES2["closed"] = "closed";
      CHANNEL_STATES2["errored"] = "errored";
      CHANNEL_STATES2["joined"] = "joined";
      CHANNEL_STATES2["joining"] = "joining";
      CHANNEL_STATES2["leaving"] = "leaving";
    })(CHANNEL_STATES || (CHANNEL_STATES = {}));
    (function(CHANNEL_EVENTS2) {
      CHANNEL_EVENTS2["close"] = "phx_close";
      CHANNEL_EVENTS2["error"] = "phx_error";
      CHANNEL_EVENTS2["join"] = "phx_join";
      CHANNEL_EVENTS2["reply"] = "phx_reply";
      CHANNEL_EVENTS2["leave"] = "phx_leave";
      CHANNEL_EVENTS2["access_token"] = "access_token";
    })(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
    (function(TRANSPORTS2) {
      TRANSPORTS2["websocket"] = "websocket";
    })(TRANSPORTS || (TRANSPORTS = {}));
    (function(CONNECTION_STATE2) {
      CONNECTION_STATE2["Connecting"] = "connecting";
      CONNECTION_STATE2["Open"] = "open";
      CONNECTION_STATE2["Closing"] = "closing";
      CONNECTION_STATE2["Closed"] = "closed";
    })(CONNECTION_STATE || (CONNECTION_STATE = {}));
  }
});

// node_modules/@supabase/realtime-js/dist/module/lib/serializer.js
var Serializer;
var init_serializer = __esm({
  "node_modules/@supabase/realtime-js/dist/module/lib/serializer.js"() {
    Serializer = class {
      constructor(allowedMetadataKeys) {
        this.HEADER_LENGTH = 1;
        this.USER_BROADCAST_PUSH_META_LENGTH = 6;
        this.KINDS = { userBroadcastPush: 3, userBroadcast: 4 };
        this.BINARY_ENCODING = 0;
        this.JSON_ENCODING = 1;
        this.BROADCAST_EVENT = "broadcast";
        this.allowedMetadataKeys = [];
        this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];
      }
      encode(msg, callback) {
        if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === "string") {
          return callback(this._binaryEncodeUserBroadcastPush(msg));
        }
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
      }
      _binaryEncodeUserBroadcastPush(message) {
        var _a;
        if (this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload)) {
          return this._encodeBinaryUserBroadcastPush(message);
        } else {
          return this._encodeJsonUserBroadcastPush(message);
        }
      }
      _encodeBinaryUserBroadcastPush(message) {
        var _a, _b;
        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);
        return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);
      }
      _encodeJsonUserBroadcastPush(message) {
        var _a, _b;
        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};
        const encoder = new TextEncoder();
        const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;
        return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);
      }
      _encodeUserBroadcastPush(message, encodingType, encodedPayload) {
        var _a, _b;
        const topic = message.topic;
        const ref = (_a = message.ref) !== null && _a !== void 0 ? _a : "";
        const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : "";
        const userEvent = message.payload.event;
        const rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};
        const metadata = Object.keys(rest).length === 0 ? "" : JSON.stringify(rest);
        if (joinRef.length > 255) {
          throw new Error(`joinRef length ${joinRef.length} exceeds maximum of 255`);
        }
        if (ref.length > 255) {
          throw new Error(`ref length ${ref.length} exceeds maximum of 255`);
        }
        if (topic.length > 255) {
          throw new Error(`topic length ${topic.length} exceeds maximum of 255`);
        }
        if (userEvent.length > 255) {
          throw new Error(`userEvent length ${userEvent.length} exceeds maximum of 255`);
        }
        if (metadata.length > 255) {
          throw new Error(`metadata length ${metadata.length} exceeds maximum of 255`);
        }
        const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;
        const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
        let view = new DataView(header);
        let offset = 0;
        view.setUint8(offset++, this.KINDS.userBroadcastPush);
        view.setUint8(offset++, joinRef.length);
        view.setUint8(offset++, ref.length);
        view.setUint8(offset++, topic.length);
        view.setUint8(offset++, userEvent.length);
        view.setUint8(offset++, metadata.length);
        view.setUint8(offset++, encodingType);
        Array.from(joinRef, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(userEvent, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(metadata, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);
        combined.set(new Uint8Array(header), 0);
        combined.set(new Uint8Array(encodedPayload), header.byteLength);
        return combined.buffer;
      }
      decode(rawPayload, callback) {
        if (this._isArrayBuffer(rawPayload)) {
          let result = this._binaryDecode(rawPayload);
          return callback(result);
        }
        if (typeof rawPayload === "string") {
          const jsonPayload = JSON.parse(rawPayload);
          const [join_ref, ref, topic, event, payload] = jsonPayload;
          return callback({ join_ref, ref, topic, event, payload });
        }
        return callback({});
      }
      _binaryDecode(buffer2) {
        const view = new DataView(buffer2);
        const kind = view.getUint8(0);
        const decoder = new TextDecoder();
        switch (kind) {
          case this.KINDS.userBroadcast:
            return this._decodeUserBroadcast(buffer2, view, decoder);
        }
      }
      _decodeUserBroadcast(buffer2, view, decoder) {
        const topicSize = view.getUint8(1);
        const userEventSize = view.getUint8(2);
        const metadataSize = view.getUint8(3);
        const payloadEncoding = view.getUint8(4);
        let offset = this.HEADER_LENGTH + 4;
        const topic = decoder.decode(buffer2.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        const userEvent = decoder.decode(buffer2.slice(offset, offset + userEventSize));
        offset = offset + userEventSize;
        const metadata = decoder.decode(buffer2.slice(offset, offset + metadataSize));
        offset = offset + metadataSize;
        const payload = buffer2.slice(offset, buffer2.byteLength);
        const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;
        const data = {
          type: this.BROADCAST_EVENT,
          event: userEvent,
          payload: parsedPayload
        };
        if (metadataSize > 0) {
          data["meta"] = JSON.parse(metadata);
        }
        return { join_ref: null, ref: null, topic, event: this.BROADCAST_EVENT, payload: data };
      }
      _isArrayBuffer(buffer2) {
        var _a;
        return buffer2 instanceof ArrayBuffer || ((_a = buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.constructor) === null || _a === void 0 ? void 0 : _a.name) === "ArrayBuffer";
      }
      _pick(obj, keys) {
        if (!obj || typeof obj !== "object") {
          return {};
        }
        return Object.fromEntries(Object.entries(obj).filter(([key]) => keys.includes(key)));
      }
    };
  }
});

// node_modules/@supabase/realtime-js/dist/module/lib/timer.js
var Timer;
var init_timer = __esm({
  "node_modules/@supabase/realtime-js/dist/module/lib/timer.js"() {
    Timer = class {
      constructor(callback, timerCalc) {
        this.callback = callback;
        this.timerCalc = timerCalc;
        this.timer = void 0;
        this.tries = 0;
        this.callback = callback;
        this.timerCalc = timerCalc;
      }
      reset() {
        this.tries = 0;
        clearTimeout(this.timer);
        this.timer = void 0;
      }
      // Cancels any previous scheduleTimeout and schedules callback
      scheduleTimeout() {
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          this.tries = this.tries + 1;
          this.callback();
        }, this.timerCalc(this.tries + 1));
      }
    };
  }
});

// node_modules/@supabase/realtime-js/dist/module/lib/transformers.js
var PostgresTypes, convertChangeData, convertColumn, convertCell, noop, toBoolean, toNumber, toJson, toArray, toTimestampString, httpEndpointURL;
var init_transformers = __esm({
  "node_modules/@supabase/realtime-js/dist/module/lib/transformers.js"() {
    (function(PostgresTypes2) {
      PostgresTypes2["abstime"] = "abstime";
      PostgresTypes2["bool"] = "bool";
      PostgresTypes2["date"] = "date";
      PostgresTypes2["daterange"] = "daterange";
      PostgresTypes2["float4"] = "float4";
      PostgresTypes2["float8"] = "float8";
      PostgresTypes2["int2"] = "int2";
      PostgresTypes2["int4"] = "int4";
      PostgresTypes2["int4range"] = "int4range";
      PostgresTypes2["int8"] = "int8";
      PostgresTypes2["int8range"] = "int8range";
      PostgresTypes2["json"] = "json";
      PostgresTypes2["jsonb"] = "jsonb";
      PostgresTypes2["money"] = "money";
      PostgresTypes2["numeric"] = "numeric";
      PostgresTypes2["oid"] = "oid";
      PostgresTypes2["reltime"] = "reltime";
      PostgresTypes2["text"] = "text";
      PostgresTypes2["time"] = "time";
      PostgresTypes2["timestamp"] = "timestamp";
      PostgresTypes2["timestamptz"] = "timestamptz";
      PostgresTypes2["timetz"] = "timetz";
      PostgresTypes2["tsrange"] = "tsrange";
      PostgresTypes2["tstzrange"] = "tstzrange";
    })(PostgresTypes || (PostgresTypes = {}));
    convertChangeData = (columns, record, options = {}) => {
      var _a;
      const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];
      if (!record) {
        return {};
      }
      return Object.keys(record).reduce((acc, rec_key) => {
        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
        return acc;
      }, {});
    };
    convertColumn = (columnName, columns, record, skipTypes) => {
      const column = columns.find((x4) => x4.name === columnName);
      const colType = column === null || column === void 0 ? void 0 : column.type;
      const value = record[columnName];
      if (colType && !skipTypes.includes(colType)) {
        return convertCell(colType, value);
      }
      return noop(value);
    };
    convertCell = (type, value) => {
      if (type.charAt(0) === "_") {
        const dataType = type.slice(1, type.length);
        return toArray(value, dataType);
      }
      switch (type) {
        case PostgresTypes.bool:
          return toBoolean(value);
        case PostgresTypes.float4:
        case PostgresTypes.float8:
        case PostgresTypes.int2:
        case PostgresTypes.int4:
        case PostgresTypes.int8:
        case PostgresTypes.numeric:
        case PostgresTypes.oid:
          return toNumber(value);
        case PostgresTypes.json:
        case PostgresTypes.jsonb:
          return toJson(value);
        case PostgresTypes.timestamp:
          return toTimestampString(value);
        // Format to be consistent with PostgREST
        case PostgresTypes.abstime:
        // To allow users to cast it based on Timezone
        case PostgresTypes.date:
        // To allow users to cast it based on Timezone
        case PostgresTypes.daterange:
        case PostgresTypes.int4range:
        case PostgresTypes.int8range:
        case PostgresTypes.money:
        case PostgresTypes.reltime:
        // To allow users to cast it based on Timezone
        case PostgresTypes.text:
        case PostgresTypes.time:
        // To allow users to cast it based on Timezone
        case PostgresTypes.timestamptz:
        // To allow users to cast it based on Timezone
        case PostgresTypes.timetz:
        // To allow users to cast it based on Timezone
        case PostgresTypes.tsrange:
        case PostgresTypes.tstzrange:
          return noop(value);
        default:
          return noop(value);
      }
    };
    noop = (value) => {
      return value;
    };
    toBoolean = (value) => {
      switch (value) {
        case "t":
          return true;
        case "f":
          return false;
        default:
          return value;
      }
    };
    toNumber = (value) => {
      if (typeof value === "string") {
        const parsedValue = parseFloat(value);
        if (!Number.isNaN(parsedValue)) {
          return parsedValue;
        }
      }
      return value;
    };
    toJson = (value) => {
      if (typeof value === "string") {
        try {
          return JSON.parse(value);
        } catch (_a) {
          return value;
        }
      }
      return value;
    };
    toArray = (value, type) => {
      if (typeof value !== "string") {
        return value;
      }
      const lastIdx = value.length - 1;
      const closeBrace = value[lastIdx];
      const openBrace = value[0];
      if (openBrace === "{" && closeBrace === "}") {
        let arr;
        const valTrim = value.slice(1, lastIdx);
        try {
          arr = JSON.parse("[" + valTrim + "]");
        } catch (_5) {
          arr = valTrim ? valTrim.split(",") : [];
        }
        return arr.map((val) => convertCell(type, val));
      }
      return value;
    };
    toTimestampString = (value) => {
      if (typeof value === "string") {
        return value.replace(" ", "T");
      }
      return value;
    };
    httpEndpointURL = (socketUrl) => {
      const wsUrl = new URL(socketUrl);
      wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, "http");
      wsUrl.pathname = wsUrl.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, "");
      if (wsUrl.pathname === "" || wsUrl.pathname === "/") {
        wsUrl.pathname = "/api/broadcast";
      } else {
        wsUrl.pathname = wsUrl.pathname + "/api/broadcast";
      }
      return wsUrl.href;
    };
  }
});

// node_modules/@supabase/realtime-js/dist/module/lib/push.js
var Push;
var init_push = __esm({
  "node_modules/@supabase/realtime-js/dist/module/lib/push.js"() {
    init_constants2();
    Push = class {
      /**
       * Initializes the Push
       *
       * @param channel The Channel
       * @param event The event, for example `"phx_join"`
       * @param payload The payload, for example `{user_id: 123}`
       * @param timeout The push timeout in milliseconds
       */
      constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
        this.channel = channel;
        this.event = event;
        this.payload = payload;
        this.timeout = timeout;
        this.sent = false;
        this.timeoutTimer = void 0;
        this.ref = "";
        this.receivedResp = null;
        this.recHooks = [];
        this.refEvent = null;
      }
      resend(timeout) {
        this.timeout = timeout;
        this._cancelRefEvent();
        this.ref = "";
        this.refEvent = null;
        this.receivedResp = null;
        this.sent = false;
        this.send();
      }
      send() {
        if (this._hasReceived("timeout")) {
          return;
        }
        this.startTimeout();
        this.sent = true;
        this.channel.socket.push({
          topic: this.channel.topic,
          event: this.event,
          payload: this.payload,
          ref: this.ref,
          join_ref: this.channel._joinRef()
        });
      }
      updatePayload(payload) {
        this.payload = Object.assign(Object.assign({}, this.payload), payload);
      }
      receive(status, callback) {
        var _a;
        if (this._hasReceived(status)) {
          callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);
        }
        this.recHooks.push({ status, callback });
        return this;
      }
      startTimeout() {
        if (this.timeoutTimer) {
          return;
        }
        this.ref = this.channel.socket._makeRef();
        this.refEvent = this.channel._replyEventName(this.ref);
        const callback = (payload) => {
          this._cancelRefEvent();
          this._cancelTimeout();
          this.receivedResp = payload;
          this._matchReceive(payload);
        };
        this.channel._on(this.refEvent, {}, callback);
        this.timeoutTimer = setTimeout(() => {
          this.trigger("timeout", {});
        }, this.timeout);
      }
      trigger(status, response) {
        if (this.refEvent)
          this.channel._trigger(this.refEvent, { status, response });
      }
      destroy() {
        this._cancelRefEvent();
        this._cancelTimeout();
      }
      _cancelRefEvent() {
        if (!this.refEvent) {
          return;
        }
        this.channel._off(this.refEvent, {});
      }
      _cancelTimeout() {
        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = void 0;
      }
      _matchReceive({ status, response }) {
        this.recHooks.filter((h5) => h5.status === status).forEach((h5) => h5.callback(response));
      }
      _hasReceived(status) {
        return this.receivedResp && this.receivedResp.status === status;
      }
    };
  }
});

// node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js
var REALTIME_PRESENCE_LISTEN_EVENTS, RealtimePresence;
var init_RealtimePresence = __esm({
  "node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js"() {
    (function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
      REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
      REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
      REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
    })(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
    RealtimePresence = class _RealtimePresence {
      /**
       * Creates a Presence helper that keeps the local presence state in sync with the server.
       *
       * @param channel - The realtime channel to bind to.
       * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.
       *
       * @example
       * ```ts
       * const presence = new RealtimePresence(channel)
       *
       * channel.on('presence', ({ event, key }) => {
       *   console.log(`Presence ${event} on ${key}`)
       * })
       * ```
       */
      constructor(channel, opts) {
        this.channel = channel;
        this.state = {};
        this.pendingDiffs = [];
        this.joinRef = null;
        this.enabled = false;
        this.caller = {
          onJoin: () => {
          },
          onLeave: () => {
          },
          onSync: () => {
          }
        };
        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
          state: "presence_state",
          diff: "presence_diff"
        };
        this.channel._on(events.state, {}, (newState) => {
          const { onJoin, onLeave, onSync } = this.caller;
          this.joinRef = this.channel._joinRef();
          this.state = _RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
          this.pendingDiffs.forEach((diff) => {
            this.state = _RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
          });
          this.pendingDiffs = [];
          onSync();
        });
        this.channel._on(events.diff, {}, (diff) => {
          const { onJoin, onLeave, onSync } = this.caller;
          if (this.inPendingSyncState()) {
            this.pendingDiffs.push(diff);
          } else {
            this.state = _RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
            onSync();
          }
        });
        this.onJoin((key, currentPresences, newPresences) => {
          this.channel._trigger("presence", {
            event: "join",
            key,
            currentPresences,
            newPresences
          });
        });
        this.onLeave((key, currentPresences, leftPresences) => {
          this.channel._trigger("presence", {
            event: "leave",
            key,
            currentPresences,
            leftPresences
          });
        });
        this.onSync(() => {
          this.channel._trigger("presence", { event: "sync" });
        });
      }
      /**
       * Used to sync the list of presences on the server with the
       * client's state.
       *
       * An optional `onJoin` and `onLeave` callback can be provided to
       * react to changes in the client's local presences across
       * disconnects and reconnects with the server.
       *
       * @internal
       */
      static syncState(currentState, newState, onJoin, onLeave) {
        const state = this.cloneDeep(currentState);
        const transformedState = this.transformState(newState);
        const joins = {};
        const leaves = {};
        this.map(state, (key, presences) => {
          if (!transformedState[key]) {
            leaves[key] = presences;
          }
        });
        this.map(transformedState, (key, newPresences) => {
          const currentPresences = state[key];
          if (currentPresences) {
            const newPresenceRefs = newPresences.map((m8) => m8.presence_ref);
            const curPresenceRefs = currentPresences.map((m8) => m8.presence_ref);
            const joinedPresences = newPresences.filter((m8) => curPresenceRefs.indexOf(m8.presence_ref) < 0);
            const leftPresences = currentPresences.filter((m8) => newPresenceRefs.indexOf(m8.presence_ref) < 0);
            if (joinedPresences.length > 0) {
              joins[key] = joinedPresences;
            }
            if (leftPresences.length > 0) {
              leaves[key] = leftPresences;
            }
          } else {
            joins[key] = newPresences;
          }
        });
        return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
      }
      /**
       * Used to sync a diff of presence join and leave events from the
       * server, as they happen.
       *
       * Like `syncState`, `syncDiff` accepts optional `onJoin` and
       * `onLeave` callbacks to react to a user joining or leaving from a
       * device.
       *
       * @internal
       */
      static syncDiff(state, diff, onJoin, onLeave) {
        const { joins, leaves } = {
          joins: this.transformState(diff.joins),
          leaves: this.transformState(diff.leaves)
        };
        if (!onJoin) {
          onJoin = () => {
          };
        }
        if (!onLeave) {
          onLeave = () => {
          };
        }
        this.map(joins, (key, newPresences) => {
          var _a;
          const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];
          state[key] = this.cloneDeep(newPresences);
          if (currentPresences.length > 0) {
            const joinedPresenceRefs = state[key].map((m8) => m8.presence_ref);
            const curPresences = currentPresences.filter((m8) => joinedPresenceRefs.indexOf(m8.presence_ref) < 0);
            state[key].unshift(...curPresences);
          }
          onJoin(key, currentPresences, newPresences);
        });
        this.map(leaves, (key, leftPresences) => {
          let currentPresences = state[key];
          if (!currentPresences)
            return;
          const presenceRefsToRemove = leftPresences.map((m8) => m8.presence_ref);
          currentPresences = currentPresences.filter((m8) => presenceRefsToRemove.indexOf(m8.presence_ref) < 0);
          state[key] = currentPresences;
          onLeave(key, currentPresences, leftPresences);
          if (currentPresences.length === 0)
            delete state[key];
        });
        return state;
      }
      /** @internal */
      static map(obj, func) {
        return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
      }
      /**
       * Remove 'metas' key
       * Change 'phx_ref' to 'presence_ref'
       * Remove 'phx_ref' and 'phx_ref_prev'
       *
       * @example
       * // returns {
       *  abc123: [
       *    { presence_ref: '2', user_id: 1 },
       *    { presence_ref: '3', user_id: 2 }
       *  ]
       * }
       * RealtimePresence.transformState({
       *  abc123: {
       *    metas: [
       *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
       *      { phx_ref: '3', user_id: 2 }
       *    ]
       *  }
       * })
       *
       * @internal
       */
      static transformState(state) {
        state = this.cloneDeep(state);
        return Object.getOwnPropertyNames(state).reduce((newState, key) => {
          const presences = state[key];
          if ("metas" in presences) {
            newState[key] = presences.metas.map((presence) => {
              presence["presence_ref"] = presence["phx_ref"];
              delete presence["phx_ref"];
              delete presence["phx_ref_prev"];
              return presence;
            });
          } else {
            newState[key] = presences;
          }
          return newState;
        }, {});
      }
      /** @internal */
      static cloneDeep(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
      /** @internal */
      onJoin(callback) {
        this.caller.onJoin = callback;
      }
      /** @internal */
      onLeave(callback) {
        this.caller.onLeave = callback;
      }
      /** @internal */
      onSync(callback) {
        this.caller.onSync = callback;
      }
      /** @internal */
      inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel._joinRef();
      }
    };
  }
});

// node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT, REALTIME_LISTEN_TYPES, REALTIME_SUBSCRIBE_STATES, RealtimeChannel;
var init_RealtimeChannel = __esm({
  "node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js"() {
    init_constants2();
    init_push();
    init_timer();
    init_RealtimePresence();
    init_transformers();
    init_transformers();
    (function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
      REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
      REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
      REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
      REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
    })(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
    (function(REALTIME_LISTEN_TYPES2) {
      REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
      REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
      REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
      REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
    })(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
    (function(REALTIME_SUBSCRIBE_STATES2) {
      REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
      REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
      REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
      REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
    })(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
    RealtimeChannel = class _RealtimeChannel {
      /**
       * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.
       *
       * The topic determines which realtime stream you are subscribing to. Config options let you
       * enable acknowledgement for broadcasts, presence tracking, or private channels.
       *
       * @example
       * ```ts
       * import RealtimeClient from '@supabase/realtime-js'
       *
       * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
       *   params: { apikey: 'public-anon-key' },
       * })
       * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)
       * ```
       */
      constructor(topic, params2 = { config: {} }, socket) {
        var _a, _b;
        this.topic = topic;
        this.params = params2;
        this.socket = socket;
        this.bindings = {};
        this.state = CHANNEL_STATES.closed;
        this.joinedOnce = false;
        this.pushBuffer = [];
        this.subTopic = topic.replace(/^realtime:/i, "");
        this.params.config = Object.assign({
          broadcast: { ack: false, self: false },
          presence: { key: "", enabled: false },
          private: false
        }, params2.config);
        this.timeout = this.socket.timeout;
        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
        this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
        this.joinPush.receive("ok", () => {
          this.state = CHANNEL_STATES.joined;
          this.rejoinTimer.reset();
          this.pushBuffer.forEach((pushEvent) => pushEvent.send());
          this.pushBuffer = [];
        });
        this._onClose(() => {
          this.rejoinTimer.reset();
          this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
          this.state = CHANNEL_STATES.closed;
          this.socket._remove(this);
        });
        this._onError((reason) => {
          if (this._isLeaving() || this._isClosed()) {
            return;
          }
          this.socket.log("channel", `error ${this.topic}`, reason);
          this.state = CHANNEL_STATES.errored;
          this.rejoinTimer.scheduleTimeout();
        });
        this.joinPush.receive("timeout", () => {
          if (!this._isJoining()) {
            return;
          }
          this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
          this.state = CHANNEL_STATES.errored;
          this.rejoinTimer.scheduleTimeout();
        });
        this.joinPush.receive("error", (reason) => {
          if (this._isLeaving() || this._isClosed()) {
            return;
          }
          this.socket.log("channel", `error ${this.topic}`, reason);
          this.state = CHANNEL_STATES.errored;
          this.rejoinTimer.scheduleTimeout();
        });
        this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
          this._trigger(this._replyEventName(ref), payload);
        });
        this.presence = new RealtimePresence(this);
        this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);
        this.private = this.params.config.private || false;
        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {
          throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
        }
      }
      /** Subscribe registers your client with the server */
      subscribe(callback, timeout = this.timeout) {
        var _a, _b, _c;
        if (!this.socket.isConnected()) {
          this.socket.connect();
        }
        if (this.state == CHANNEL_STATES.closed) {
          const { config: { broadcast, presence, private: isPrivate } } = this.params;
          const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r5) => r5.filter)) !== null && _b !== void 0 ? _b : [];
          const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;
          const accessTokenPayload = {};
          const config = {
            broadcast,
            presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),
            postgres_changes,
            private: isPrivate
          };
          if (this.socket.accessTokenValue) {
            accessTokenPayload.access_token = this.socket.accessTokenValue;
          }
          this._onError((e3) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e3));
          this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
          this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));
          this.joinedOnce = true;
          this._rejoin(timeout);
          this.joinPush.receive("ok", async ({ postgres_changes: postgres_changes2 }) => {
            var _a2;
            if (!this.socket._isManualToken()) {
              this.socket.setAuth();
            }
            if (postgres_changes2 === void 0) {
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
              return;
            } else {
              const clientPostgresBindings = this.bindings.postgres_changes;
              const bindingsLen = (_a2 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a2 !== void 0 ? _a2 : 0;
              const newPostgresBindings = [];
              for (let i7 = 0; i7 < bindingsLen; i7++) {
                const clientPostgresBinding = clientPostgresBindings[i7];
                const { filter: { event, schema, table, filter } } = clientPostgresBinding;
                const serverPostgresFilter = postgres_changes2 && postgres_changes2[i7];
                if (serverPostgresFilter && serverPostgresFilter.event === event && _RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && _RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && _RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {
                  newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
                } else {
                  this.unsubscribe();
                  this.state = CHANNEL_STATES.errored;
                  callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                  return;
                }
              }
              this.bindings.postgres_changes = newPostgresBindings;
              callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
              return;
            }
          }).receive("error", (error2) => {
            this.state = CHANNEL_STATES.errored;
            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error2).join(", ") || "error")));
            return;
          }).receive("timeout", () => {
            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
            return;
          });
        }
        return this;
      }
      /**
       * Returns the current presence state for this channel.
       *
       * The shape is a map keyed by presence key (for example a user id) where each entry contains the
       * tracked metadata for that user.
       */
      presenceState() {
        return this.presence.state;
      }
      /**
       * Sends the supplied payload to the presence tracker so other subscribers can see that this
       * client is online. Use `untrack` to stop broadcasting presence for the same key.
       */
      async track(payload, opts = {}) {
        return await this.send({
          type: "presence",
          event: "track",
          payload
        }, opts.timeout || this.timeout);
      }
      /**
       * Removes the current presence state for this client.
       */
      async untrack(opts = {}) {
        return await this.send({
          type: "presence",
          event: "untrack"
        }, opts);
      }
      on(type, filter, callback) {
        if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {
          this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);
          this.unsubscribe().then(async () => await this.subscribe());
        }
        return this._on(type, filter, callback);
      }
      /**
       * Sends a broadcast message explicitly via REST API.
       *
       * This method always uses the REST API endpoint regardless of WebSocket connection state.
       * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.
       *
       * @param event The name of the broadcast event
       * @param payload Payload to be sent (required)
       * @param opts Options including timeout
       * @returns Promise resolving to object with success status, and error details if failed
       */
      async httpSend(event, payload, opts = {}) {
        var _a;
        if (payload === void 0 || payload === null) {
          return Promise.reject("Payload is required for httpSend()");
        }
        const headers = {
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        };
        if (this.socket.accessTokenValue) {
          headers["Authorization"] = `Bearer ${this.socket.accessTokenValue}`;
        }
        const options = {
          method: "POST",
          headers,
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event,
                payload,
                private: this.private
              }
            ]
          })
        };
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
        if (response.status === 202) {
          return { success: true };
        }
        let errorMessage = response.statusText;
        try {
          const errorBody = await response.json();
          errorMessage = errorBody.error || errorBody.message || errorMessage;
        } catch (_b) {
        }
        return Promise.reject(new Error(errorMessage));
      }
      /**
       * Sends a message into the channel.
       *
       * @param args Arguments to send to channel
       * @param args.type The type of event to send
       * @param args.event The name of the event being sent
       * @param args.payload Payload to be sent
       * @param opts Options to be used during the send process
       */
      async send(args, opts = {}) {
        var _a, _b;
        if (!this._canPush() && args.type === "broadcast") {
          console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
          const { event, payload: endpoint_payload } = args;
          const headers = {
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json"
          };
          if (this.socket.accessTokenValue) {
            headers["Authorization"] = `Bearer ${this.socket.accessTokenValue}`;
          }
          const options = {
            method: "POST",
            headers,
            body: JSON.stringify({
              messages: [
                {
                  topic: this.subTopic,
                  event,
                  payload: endpoint_payload,
                  private: this.private
                }
              ]
            })
          };
          try {
            const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
            await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
            return response.ok ? "ok" : "error";
          } catch (error2) {
            if (error2.name === "AbortError") {
              return "timed out";
            } else {
              return "error";
            }
          }
        } else {
          return new Promise((resolve) => {
            var _a2, _b2, _c;
            const push = this._push(args.type, args, opts.timeout || this.timeout);
            if (args.type === "broadcast" && !((_c = (_b2 = (_a2 = this.params) === null || _a2 === void 0 ? void 0 : _a2.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
              resolve("ok");
            }
            push.receive("ok", () => resolve("ok"));
            push.receive("error", () => resolve("error"));
            push.receive("timeout", () => resolve("timed out"));
          });
        }
      }
      /**
       * Updates the payload that will be sent the next time the channel joins (reconnects).
       * Useful for rotating access tokens or updating config without re-creating the channel.
       */
      updateJoinPayload(payload) {
        this.joinPush.updatePayload(payload);
      }
      /**
       * Leaves the channel.
       *
       * Unsubscribes from server events, and instructs channel to terminate on server.
       * Triggers onClose() hooks.
       *
       * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
       * channel.unsubscribe().receive("ok", () => alert("left!") )
       */
      unsubscribe(timeout = this.timeout) {
        this.state = CHANNEL_STATES.leaving;
        const onClose = () => {
          this.socket.log("channel", `leave ${this.topic}`);
          this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
        };
        this.joinPush.destroy();
        let leavePush = null;
        return new Promise((resolve) => {
          leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
          leavePush.receive("ok", () => {
            onClose();
            resolve("ok");
          }).receive("timeout", () => {
            onClose();
            resolve("timed out");
          }).receive("error", () => {
            resolve("error");
          });
          leavePush.send();
          if (!this._canPush()) {
            leavePush.trigger("ok", {});
          }
        }).finally(() => {
          leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();
        });
      }
      /**
       * Teardown the channel.
       *
       * Destroys and stops related timers.
       */
      teardown() {
        this.pushBuffer.forEach((push) => push.destroy());
        this.pushBuffer = [];
        this.rejoinTimer.reset();
        this.joinPush.destroy();
        this.state = CHANNEL_STATES.closed;
        this.bindings = {};
      }
      /** @internal */
      async _fetchWithTimeout(url, options, timeout) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
        clearTimeout(id);
        return response;
      }
      /** @internal */
      _push(event, payload, timeout = this.timeout) {
        if (!this.joinedOnce) {
          throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        }
        let pushEvent = new Push(this, event, payload, timeout);
        if (this._canPush()) {
          pushEvent.send();
        } else {
          this._addToPushBuffer(pushEvent);
        }
        return pushEvent;
      }
      /** @internal */
      _addToPushBuffer(pushEvent) {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
        if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {
          const removedPush = this.pushBuffer.shift();
          if (removedPush) {
            removedPush.destroy();
            this.socket.log("channel", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);
          }
        }
      }
      /**
       * Overridable message hook
       *
       * Receives all events for specialized message handling before dispatching to the channel callbacks.
       * Must return the payload, modified or unmodified.
       *
       * @internal
       */
      _onMessage(_event, payload, _ref) {
        return payload;
      }
      /** @internal */
      _isMember(topic) {
        return this.topic === topic;
      }
      /** @internal */
      _joinRef() {
        return this.joinPush.ref;
      }
      /** @internal */
      _trigger(type, payload, ref) {
        var _a, _b;
        const typeLower = type.toLocaleLowerCase();
        const { close, error: error2, leave, join } = CHANNEL_EVENTS;
        const events = [close, error2, leave, join];
        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
          return;
        }
        let handledPayload = this._onMessage(typeLower, payload, ref);
        if (payload && !handledPayload) {
          throw "channel onMessage callbacks must return the payload, modified or unmodified";
        }
        if (["insert", "update", "delete"].includes(typeLower)) {
          (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {
            var _a2, _b2, _c;
            return ((_a2 = bind.filter) === null || _a2 === void 0 ? void 0 : _a2.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
          }).map((bind) => bind.callback(handledPayload, ref));
        } else {
          (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
            var _a2, _b2, _c, _d, _e3, _f;
            if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
              if ("id" in bind) {
                const bindId = bind.id;
                const bindEvent = (_a2 = bind.filter) === null || _a2 === void 0 ? void 0 : _a2.event;
                return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
              } else {
                const bindEvent = (_e3 = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e3 === void 0 ? void 0 : _e3.toLocaleLowerCase();
                return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
              }
            } else {
              return bind.type.toLocaleLowerCase() === typeLower;
            }
          }).map((bind) => {
            if (typeof handledPayload === "object" && "ids" in handledPayload) {
              const postgresChanges = handledPayload.data;
              const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
              const enrichedPayload = {
                schema,
                table,
                commit_timestamp,
                eventType: type2,
                new: {},
                old: {},
                errors
              };
              handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
            }
            bind.callback(handledPayload, ref);
          });
        }
      }
      /** @internal */
      _isClosed() {
        return this.state === CHANNEL_STATES.closed;
      }
      /** @internal */
      _isJoined() {
        return this.state === CHANNEL_STATES.joined;
      }
      /** @internal */
      _isJoining() {
        return this.state === CHANNEL_STATES.joining;
      }
      /** @internal */
      _isLeaving() {
        return this.state === CHANNEL_STATES.leaving;
      }
      /** @internal */
      _replyEventName(ref) {
        return `chan_reply_${ref}`;
      }
      /** @internal */
      _on(type, filter, callback) {
        const typeLower = type.toLocaleLowerCase();
        const binding = {
          type: typeLower,
          filter,
          callback
        };
        if (this.bindings[typeLower]) {
          this.bindings[typeLower].push(binding);
        } else {
          this.bindings[typeLower] = [binding];
        }
        return this;
      }
      /** @internal */
      _off(type, filter) {
        const typeLower = type.toLocaleLowerCase();
        if (this.bindings[typeLower]) {
          this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
            var _a;
            return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && _RealtimeChannel.isEqual(bind.filter, filter));
          });
        }
        return this;
      }
      /** @internal */
      static isEqual(obj1, obj2) {
        if (Object.keys(obj1).length !== Object.keys(obj2).length) {
          return false;
        }
        for (const k5 in obj1) {
          if (obj1[k5] !== obj2[k5]) {
            return false;
          }
        }
        return true;
      }
      /**
       * Compares two optional filter values for equality.
       * Treats undefined, null, and empty string as equivalent empty values.
       * @internal
       */
      static isFilterValueEqual(serverValue, clientValue) {
        const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : void 0;
        const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : void 0;
        return normalizedServer === normalizedClient;
      }
      /** @internal */
      _rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout();
        if (this.socket.isConnected()) {
          this._rejoin();
        }
      }
      /**
       * Registers a callback that will be executed when the channel closes.
       *
       * @internal
       */
      _onClose(callback) {
        this._on(CHANNEL_EVENTS.close, {}, callback);
      }
      /**
       * Registers a callback that will be executed when the channel encounteres an error.
       *
       * @internal
       */
      _onError(callback) {
        this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
      }
      /**
       * Returns `true` if the socket is connected and the channel has been joined.
       *
       * @internal
       */
      _canPush() {
        return this.socket.isConnected() && this._isJoined();
      }
      /** @internal */
      _rejoin(timeout = this.timeout) {
        if (this._isLeaving()) {
          return;
        }
        this.socket._leaveOpenTopic(this.topic);
        this.state = CHANNEL_STATES.joining;
        this.joinPush.resend(timeout);
      }
      /** @internal */
      _getPayloadRecords(payload) {
        const records = {
          new: {},
          old: {}
        };
        if (payload.type === "INSERT" || payload.type === "UPDATE") {
          records.new = convertChangeData(payload.columns, payload.record);
        }
        if (payload.type === "UPDATE" || payload.type === "DELETE") {
          records.old = convertChangeData(payload.columns, payload.old_record);
        }
        return records;
      }
    };
  }
});

// node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js
var noop2, CONNECTION_TIMEOUTS, RECONNECT_INTERVALS, DEFAULT_RECONNECT_FALLBACK, WORKER_SCRIPT, RealtimeClient;
var init_RealtimeClient = __esm({
  "node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js"() {
    init_websocket_factory();
    init_constants2();
    init_serializer();
    init_timer();
    init_transformers();
    init_RealtimeChannel();
    noop2 = () => {
    };
    CONNECTION_TIMEOUTS = {
      HEARTBEAT_INTERVAL: 25e3,
      RECONNECT_DELAY: 10,
      HEARTBEAT_TIMEOUT_FALLBACK: 100
    };
    RECONNECT_INTERVALS = [1e3, 2e3, 5e3, 1e4];
    DEFAULT_RECONNECT_FALLBACK = 1e4;
    WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
    RealtimeClient = class {
      /**
       * Initializes the Socket.
       *
       * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
       * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
       * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation
       * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
       * @param options.params The optional params to pass when connecting.
       * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.
       * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
       * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.
       * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
       * @param options.logLevel Sets the log level for Realtime
       * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
       * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
       * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
       * @param options.worker Use Web Worker to set a side flow. Defaults to false.
       * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
       * @param options.vsn The protocol version to use when connecting. Supported versions are "1.0.0" and "2.0.0". Defaults to "2.0.0".
       * @example
       * ```ts
       * import RealtimeClient from '@supabase/realtime-js'
       *
       * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
       *   params: { apikey: 'public-anon-key' },
       * })
       * client.connect()
       * ```
       */
      constructor(endPoint, options) {
        var _a;
        this.accessTokenValue = null;
        this.apiKey = null;
        this._manuallySetToken = false;
        this.channels = new Array();
        this.endPoint = "";
        this.httpEndpoint = "";
        this.headers = {};
        this.params = {};
        this.timeout = DEFAULT_TIMEOUT;
        this.transport = null;
        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
        this.heartbeatTimer = void 0;
        this.pendingHeartbeatRef = null;
        this.heartbeatCallback = noop2;
        this.ref = 0;
        this.reconnectTimer = null;
        this.vsn = DEFAULT_VSN;
        this.logger = noop2;
        this.conn = null;
        this.sendBuffer = [];
        this.serializer = new Serializer();
        this.stateChangeCallbacks = {
          open: [],
          close: [],
          error: [],
          message: []
        };
        this.accessToken = null;
        this._connectionState = "disconnected";
        this._wasManualDisconnect = false;
        this._authPromise = null;
        this._heartbeatSentAt = null;
        this._resolveFetch = (customFetch) => {
          if (customFetch) {
            return (...args) => customFetch(...args);
          }
          return (...args) => fetch(...args);
        };
        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {
          throw new Error("API key is required to connect to Realtime");
        }
        this.apiKey = options.params.apikey;
        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
        this.httpEndpoint = httpEndpointURL(endPoint);
        this._initializeOptions(options);
        this._setupReconnectionTimer();
        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
      }
      /**
       * Connects the socket, unless already connected.
       */
      connect() {
        if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {
          return;
        }
        this._setConnectionState("connecting");
        if (this.accessToken && !this._authPromise) {
          this._setAuthSafely("connect");
        }
        if (this.transport) {
          this.conn = new this.transport(this.endpointURL());
        } else {
          try {
            this.conn = websocket_factory_default.createWebSocket(this.endpointURL());
          } catch (error2) {
            this._setConnectionState("disconnected");
            const errorMessage = error2.message;
            if (errorMessage.includes("Node.js")) {
              throw new Error(`${errorMessage}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`);
            }
            throw new Error(`WebSocket not available: ${errorMessage}`);
          }
        }
        this._setupConnectionHandlers();
      }
      /**
       * Returns the URL of the websocket.
       * @returns string The URL of the websocket.
       */
      endpointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }));
      }
      /**
       * Disconnects the socket.
       *
       * @param code A numeric status code to send on disconnect.
       * @param reason A custom reason for the disconnect.
       */
      disconnect(code, reason) {
        if (this.isDisconnecting()) {
          return;
        }
        this._setConnectionState("disconnecting", true);
        if (this.conn) {
          const fallbackTimer = setTimeout(() => {
            this._setConnectionState("disconnected");
          }, 100);
          this.conn.onclose = () => {
            clearTimeout(fallbackTimer);
            this._setConnectionState("disconnected");
          };
          if (typeof this.conn.close === "function") {
            if (code) {
              this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
            } else {
              this.conn.close();
            }
          }
          this._teardownConnection();
        } else {
          this._setConnectionState("disconnected");
        }
      }
      /**
       * Returns all created channels
       */
      getChannels() {
        return this.channels;
      }
      /**
       * Unsubscribes and removes a single channel
       * @param channel A RealtimeChannel instance
       */
      async removeChannel(channel) {
        const status = await channel.unsubscribe();
        if (status === "ok") {
          this._remove(channel);
        }
        if (this.channels.length === 0) {
          this.disconnect();
        }
        return status;
      }
      /**
       * Unsubscribes and removes all channels
       */
      async removeAllChannels() {
        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));
        this.channels = [];
        this.disconnect();
        return values_1;
      }
      /**
       * Logs the message.
       *
       * For customized logging, `this.logger` can be overridden.
       */
      log(kind, msg, data) {
        this.logger(kind, msg, data);
      }
      /**
       * Returns the current state of the socket.
       */
      connectionState() {
        switch (this.conn && this.conn.readyState) {
          case SOCKET_STATES.connecting:
            return CONNECTION_STATE.Connecting;
          case SOCKET_STATES.open:
            return CONNECTION_STATE.Open;
          case SOCKET_STATES.closing:
            return CONNECTION_STATE.Closing;
          default:
            return CONNECTION_STATE.Closed;
        }
      }
      /**
       * Returns `true` is the connection is open.
       */
      isConnected() {
        return this.connectionState() === CONNECTION_STATE.Open;
      }
      /**
       * Returns `true` if the connection is currently connecting.
       */
      isConnecting() {
        return this._connectionState === "connecting";
      }
      /**
       * Returns `true` if the connection is currently disconnecting.
       */
      isDisconnecting() {
        return this._connectionState === "disconnecting";
      }
      /**
       * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.
       *
       * Topics are automatically prefixed with `realtime:` to match the Realtime service.
       * If a channel with the same topic already exists it will be returned instead of creating
       * a duplicate connection.
       */
      channel(topic, params2 = { config: {} }) {
        const realtimeTopic = `realtime:${topic}`;
        const exists = this.getChannels().find((c7) => c7.topic === realtimeTopic);
        if (!exists) {
          const chan = new RealtimeChannel(`realtime:${topic}`, params2, this);
          this.channels.push(chan);
          return chan;
        } else {
          return exists;
        }
      }
      /**
       * Push out a message if the socket is connected.
       *
       * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
       */
      push(data) {
        const { topic, event, payload, ref } = data;
        const callback = () => {
          this.encode(data, (result) => {
            var _a;
            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);
          });
        };
        this.log("push", `${topic} ${event} (${ref})`, payload);
        if (this.isConnected()) {
          callback();
        } else {
          this.sendBuffer.push(callback);
        }
      }
      /**
       * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
       *
       * If param is null it will use the `accessToken` callback function or the token set on the client.
       *
       * On callback used, it will set the value of the token internal to the client.
       *
       * When a token is explicitly provided, it will be preserved across channel operations
       * (including removeChannel and resubscribe). The `accessToken` callback will not be
       * invoked until `setAuth()` is called without arguments.
       *
       * @param token A JWT string to override the token set on the client.
       *
       * @example
       * // Use a manual token (preserved across resubscribes, ignores accessToken callback)
       * client.realtime.setAuth('my-custom-jwt')
       *
       * // Switch back to using the accessToken callback
       * client.realtime.setAuth()
       */
      async setAuth(token = null) {
        this._authPromise = this._performAuth(token);
        try {
          await this._authPromise;
        } finally {
          this._authPromise = null;
        }
      }
      /**
       * Returns true if the current access token was explicitly set via setAuth(token),
       * false if it was obtained via the accessToken callback.
       * @internal
       */
      _isManualToken() {
        return this._manuallySetToken;
      }
      /**
       * Sends a heartbeat message if the socket is connected.
       */
      async sendHeartbeat() {
        var _a;
        if (!this.isConnected()) {
          try {
            this.heartbeatCallback("disconnected");
          } catch (e3) {
            this.log("error", "error in heartbeat callback", e3);
          }
          return;
        }
        if (this.pendingHeartbeatRef) {
          this.pendingHeartbeatRef = null;
          this._heartbeatSentAt = null;
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
          try {
            this.heartbeatCallback("timeout");
          } catch (e3) {
            this.log("error", "error in heartbeat callback", e3);
          }
          this._wasManualDisconnect = false;
          (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, "heartbeat timeout");
          setTimeout(() => {
            var _a2;
            if (!this.isConnected()) {
              (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.scheduleTimeout();
            }
          }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);
          return;
        }
        this._heartbeatSentAt = Date.now();
        this.pendingHeartbeatRef = this._makeRef();
        this.push({
          topic: "phoenix",
          event: "heartbeat",
          payload: {},
          ref: this.pendingHeartbeatRef
        });
        try {
          this.heartbeatCallback("sent");
        } catch (e3) {
          this.log("error", "error in heartbeat callback", e3);
        }
        this._setAuthSafely("heartbeat");
      }
      /**
       * Sets a callback that receives lifecycle events for internal heartbeat messages.
       * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).
       */
      onHeartbeat(callback) {
        this.heartbeatCallback = callback;
      }
      /**
       * Flushes send buffer
       */
      flushSendBuffer() {
        if (this.isConnected() && this.sendBuffer.length > 0) {
          this.sendBuffer.forEach((callback) => callback());
          this.sendBuffer = [];
        }
      }
      /**
       * Return the next message ref, accounting for overflows
       *
       * @internal
       */
      _makeRef() {
        let newRef = this.ref + 1;
        if (newRef === this.ref) {
          this.ref = 0;
        } else {
          this.ref = newRef;
        }
        return this.ref.toString();
      }
      /**
       * Unsubscribe from channels with the specified topic.
       *
       * @internal
       */
      _leaveOpenTopic(topic) {
        let dupChannel = this.channels.find((c7) => c7.topic === topic && (c7._isJoined() || c7._isJoining()));
        if (dupChannel) {
          this.log("transport", `leaving duplicate topic "${topic}"`);
          dupChannel.unsubscribe();
        }
      }
      /**
       * Removes a subscription from the socket.
       *
       * @param channel An open subscription.
       *
       * @internal
       */
      _remove(channel) {
        this.channels = this.channels.filter((c7) => c7.topic !== channel.topic);
      }
      /** @internal */
      _onConnMessage(rawMessage) {
        this.decode(rawMessage.data, (msg) => {
          if (msg.topic === "phoenix" && msg.event === "phx_reply" && msg.ref && msg.ref === this.pendingHeartbeatRef) {
            const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : void 0;
            try {
              this.heartbeatCallback(msg.payload.status === "ok" ? "ok" : "error", latency);
            } catch (e3) {
              this.log("error", "error in heartbeat callback", e3);
            }
            this._heartbeatSentAt = null;
            this.pendingHeartbeatRef = null;
          }
          const { topic, event, payload, ref } = msg;
          const refString = ref ? `(${ref})` : "";
          const status = payload.status || "";
          this.log("receive", `${status} ${topic} ${event} ${refString}`.trim(), payload);
          this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
          this._triggerStateCallbacks("message", msg);
        });
      }
      /**
       * Clear specific timer
       * @internal
       */
      _clearTimer(timer) {
        var _a;
        if (timer === "heartbeat" && this.heartbeatTimer) {
          clearInterval(this.heartbeatTimer);
          this.heartbeatTimer = void 0;
        } else if (timer === "reconnect") {
          (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();
        }
      }
      /**
       * Clear all timers
       * @internal
       */
      _clearAllTimers() {
        this._clearTimer("heartbeat");
        this._clearTimer("reconnect");
      }
      /**
       * Setup connection handlers for WebSocket events
       * @internal
       */
      _setupConnectionHandlers() {
        if (!this.conn)
          return;
        if ("binaryType" in this.conn) {
          ;
          this.conn.binaryType = "arraybuffer";
        }
        this.conn.onopen = () => this._onConnOpen();
        this.conn.onerror = (error2) => this._onConnError(error2);
        this.conn.onmessage = (event) => this._onConnMessage(event);
        this.conn.onclose = (event) => this._onConnClose(event);
        if (this.conn.readyState === SOCKET_STATES.open) {
          this._onConnOpen();
        }
      }
      /**
       * Teardown connection and cleanup resources
       * @internal
       */
      _teardownConnection() {
        if (this.conn) {
          if (this.conn.readyState === SOCKET_STATES.open || this.conn.readyState === SOCKET_STATES.connecting) {
            try {
              this.conn.close();
            } catch (e3) {
              this.log("error", "Error closing connection", e3);
            }
          }
          this.conn.onopen = null;
          this.conn.onerror = null;
          this.conn.onmessage = null;
          this.conn.onclose = null;
          this.conn = null;
        }
        this._clearAllTimers();
        this._terminateWorker();
        this.channels.forEach((channel) => channel.teardown());
      }
      /** @internal */
      _onConnOpen() {
        this._setConnectionState("connected");
        this.log("transport", `connected to ${this.endpointURL()}`);
        const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());
        authPromise.then(() => {
          this.flushSendBuffer();
        }).catch((e3) => {
          this.log("error", "error waiting for auth on connect", e3);
          this.flushSendBuffer();
        });
        this._clearTimer("reconnect");
        if (!this.worker) {
          this._startHeartbeat();
        } else {
          if (!this.workerRef) {
            this._startWorkerHeartbeat();
          }
        }
        this._triggerStateCallbacks("open");
      }
      /** @internal */
      _startHeartbeat() {
        this.heartbeatTimer && clearInterval(this.heartbeatTimer);
        this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
      }
      /** @internal */
      _startWorkerHeartbeat() {
        if (this.workerUrl) {
          this.log("worker", `starting worker for from ${this.workerUrl}`);
        } else {
          this.log("worker", `starting default worker`);
        }
        const objectUrl = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(objectUrl);
        this.workerRef.onerror = (error2) => {
          this.log("worker", "worker error", error2.message);
          this._terminateWorker();
        };
        this.workerRef.onmessage = (event) => {
          if (event.data.event === "keepAlive") {
            this.sendHeartbeat();
          }
        };
        this.workerRef.postMessage({
          event: "start",
          interval: this.heartbeatIntervalMs
        });
      }
      /**
       * Terminate the Web Worker and clear the reference
       * @internal
       */
      _terminateWorker() {
        if (this.workerRef) {
          this.log("worker", "terminating worker");
          this.workerRef.terminate();
          this.workerRef = void 0;
        }
      }
      /** @internal */
      _onConnClose(event) {
        var _a;
        this._setConnectionState("disconnected");
        this.log("transport", "close", event);
        this._triggerChanError();
        this._clearTimer("heartbeat");
        if (!this._wasManualDisconnect) {
          (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();
        }
        this._triggerStateCallbacks("close", event);
      }
      /** @internal */
      _onConnError(error2) {
        this._setConnectionState("disconnected");
        this.log("transport", `${error2}`);
        this._triggerChanError();
        this._triggerStateCallbacks("error", error2);
        try {
          this.heartbeatCallback("error");
        } catch (e3) {
          this.log("error", "error in heartbeat callback", e3);
        }
      }
      /** @internal */
      _triggerChanError() {
        this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
      }
      /** @internal */
      _appendParams(url, params2) {
        if (Object.keys(params2).length === 0) {
          return url;
        }
        const prefix = url.match(/\?/) ? "&" : "?";
        const query = new URLSearchParams(params2);
        return `${url}${prefix}${query}`;
      }
      _workerObjectUrl(url) {
        let result_url;
        if (url) {
          result_url = url;
        } else {
          const blob2 = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
          result_url = URL.createObjectURL(blob2);
        }
        return result_url;
      }
      /**
       * Set connection state with proper state management
       * @internal
       */
      _setConnectionState(state, manual = false) {
        this._connectionState = state;
        if (state === "connecting") {
          this._wasManualDisconnect = false;
        } else if (state === "disconnecting") {
          this._wasManualDisconnect = manual;
        }
      }
      /**
       * Perform the actual auth operation
       * @internal
       */
      async _performAuth(token = null) {
        let tokenToSend;
        let isManualToken = false;
        if (token) {
          tokenToSend = token;
          isManualToken = true;
        } else if (this.accessToken) {
          try {
            tokenToSend = await this.accessToken();
          } catch (e3) {
            this.log("error", "Error fetching access token from callback", e3);
            tokenToSend = this.accessTokenValue;
          }
        } else {
          tokenToSend = this.accessTokenValue;
        }
        if (isManualToken) {
          this._manuallySetToken = true;
        } else if (this.accessToken) {
          this._manuallySetToken = false;
        }
        if (this.accessTokenValue != tokenToSend) {
          this.accessTokenValue = tokenToSend;
          this.channels.forEach((channel) => {
            const payload = {
              access_token: tokenToSend,
              version: DEFAULT_VERSION
            };
            tokenToSend && channel.updateJoinPayload(payload);
            if (channel.joinedOnce && channel._isJoined()) {
              channel._push(CHANNEL_EVENTS.access_token, {
                access_token: tokenToSend
              });
            }
          });
        }
      }
      /**
       * Wait for any in-flight auth operations to complete
       * @internal
       */
      async _waitForAuthIfNeeded() {
        if (this._authPromise) {
          await this._authPromise;
        }
      }
      /**
       * Safely call setAuth with standardized error handling
       * @internal
       */
      _setAuthSafely(context = "general") {
        if (!this._isManualToken()) {
          this.setAuth().catch((e3) => {
            this.log("error", `Error setting auth in ${context}`, e3);
          });
        }
      }
      /**
       * Trigger state change callbacks with proper error handling
       * @internal
       */
      _triggerStateCallbacks(event, data) {
        try {
          this.stateChangeCallbacks[event].forEach((callback) => {
            try {
              callback(data);
            } catch (e3) {
              this.log("error", `error in ${event} callback`, e3);
            }
          });
        } catch (e3) {
          this.log("error", `error triggering ${event} callbacks`, e3);
        }
      }
      /**
       * Setup reconnection timer with proper configuration
       * @internal
       */
      _setupReconnectionTimer() {
        this.reconnectTimer = new Timer(async () => {
          setTimeout(async () => {
            await this._waitForAuthIfNeeded();
            if (!this.isConnected()) {
              this.connect();
            }
          }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);
        }, this.reconnectAfterMs);
      }
      /**
       * Initialize client options with defaults
       * @internal
       */
      _initializeOptions(options) {
        var _a, _b, _c, _d, _e3, _f, _g, _h, _j, _k, _l, _m;
        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;
        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;
        this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;
        this.accessToken = (_e3 = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e3 !== void 0 ? _e3 : null;
        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop2;
        this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : DEFAULT_VSN;
        if (options === null || options === void 0 ? void 0 : options.params)
          this.params = options.params;
        if (options === null || options === void 0 ? void 0 : options.logger)
          this.logger = options.logger;
        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {
          this.logLevel = options.logLevel || options.log_level;
          this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });
        }
        this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : (tries) => {
          return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;
        };
        switch (this.vsn) {
          case VSN_1_0_0:
            this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : (payload, callback) => {
              return callback(JSON.stringify(payload));
            };
            this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : (payload, callback) => {
              return callback(JSON.parse(payload));
            };
            break;
          case VSN_2_0_0:
            this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);
            this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);
            break;
          default:
            throw new Error(`Unsupported serializer version: ${this.vsn}`);
        }
        if (this.worker) {
          if (typeof window !== "undefined" && !window.Worker) {
            throw new Error("Web Worker is not supported");
          }
          this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
        }
      }
    };
  }
});

// node_modules/@supabase/realtime-js/dist/module/index.js
var init_module2 = __esm({
  "node_modules/@supabase/realtime-js/dist/module/index.js"() {
    init_RealtimeClient();
    init_RealtimeChannel();
    init_RealtimePresence();
    init_websocket_factory();
  }
});

// node_modules/iceberg-js/dist/index.mjs
function buildUrl(baseUrl, path, query) {
  const url = new URL(path, baseUrl);
  if (query) {
    for (const [key, value] of Object.entries(query)) {
      if (value !== void 0) {
        url.searchParams.set(key, value);
      }
    }
  }
  return url.toString();
}
async function buildAuthHeaders(auth) {
  if (!auth || auth.type === "none") {
    return {};
  }
  if (auth.type === "bearer") {
    return { Authorization: `Bearer ${auth.token}` };
  }
  if (auth.type === "header") {
    return { [auth.name]: auth.value };
  }
  if (auth.type === "custom") {
    return await auth.getHeaders();
  }
  return {};
}
function createFetchClient(options) {
  const fetchFn = options.fetchImpl ?? globalThis.fetch;
  return {
    async request({
      method,
      path,
      query,
      body,
      headers
    }) {
      const url = buildUrl(options.baseUrl, path, query);
      const authHeaders = await buildAuthHeaders(options.auth);
      const res = await fetchFn(url, {
        method,
        headers: {
          ...body ? { "Content-Type": "application/json" } : {},
          ...authHeaders,
          ...headers
        },
        body: body ? JSON.stringify(body) : void 0
      });
      const text2 = await res.text();
      const isJson = (res.headers.get("content-type") || "").includes("application/json");
      const data = isJson && text2 ? JSON.parse(text2) : text2;
      if (!res.ok) {
        const errBody = isJson ? data : void 0;
        const errorDetail = errBody?.error;
        throw new IcebergError(
          errorDetail?.message ?? `Request failed with status ${res.status}`,
          {
            status: res.status,
            icebergType: errorDetail?.type,
            icebergCode: errorDetail?.code,
            details: errBody
          }
        );
      }
      return { status: res.status, headers: res.headers, data };
    }
  };
}
function namespaceToPath(namespace) {
  return namespace.join("");
}
function namespaceToPath2(namespace) {
  return namespace.join("");
}
var IcebergError, NamespaceOperations, TableOperations, IcebergRestCatalog;
var init_dist2 = __esm({
  "node_modules/iceberg-js/dist/index.mjs"() {
    IcebergError = class extends Error {
      constructor(message, opts) {
        super(message);
        this.name = "IcebergError";
        this.status = opts.status;
        this.icebergType = opts.icebergType;
        this.icebergCode = opts.icebergCode;
        this.details = opts.details;
        this.isCommitStateUnknown = opts.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(opts.status) && opts.icebergType?.includes("CommitState") === true;
      }
      /**
       * Returns true if the error is a 404 Not Found error.
       */
      isNotFound() {
        return this.status === 404;
      }
      /**
       * Returns true if the error is a 409 Conflict error.
       */
      isConflict() {
        return this.status === 409;
      }
      /**
       * Returns true if the error is a 419 Authentication Timeout error.
       */
      isAuthenticationTimeout() {
        return this.status === 419;
      }
    };
    NamespaceOperations = class {
      constructor(client, prefix = "") {
        this.client = client;
        this.prefix = prefix;
      }
      async listNamespaces(parent) {
        const query = parent ? { parent: namespaceToPath(parent.namespace) } : void 0;
        const response = await this.client.request({
          method: "GET",
          path: `${this.prefix}/namespaces`,
          query
        });
        return response.data.namespaces.map((ns2) => ({ namespace: ns2 }));
      }
      async createNamespace(id, metadata) {
        const request = {
          namespace: id.namespace,
          properties: metadata?.properties
        };
        const response = await this.client.request({
          method: "POST",
          path: `${this.prefix}/namespaces`,
          body: request
        });
        return response.data;
      }
      async dropNamespace(id) {
        await this.client.request({
          method: "DELETE",
          path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
        });
      }
      async loadNamespaceMetadata(id) {
        const response = await this.client.request({
          method: "GET",
          path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
        });
        return {
          properties: response.data.properties
        };
      }
      async namespaceExists(id) {
        try {
          await this.client.request({
            method: "HEAD",
            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
          });
          return true;
        } catch (error2) {
          if (error2 instanceof IcebergError && error2.status === 404) {
            return false;
          }
          throw error2;
        }
      }
      async createNamespaceIfNotExists(id, metadata) {
        try {
          return await this.createNamespace(id, metadata);
        } catch (error2) {
          if (error2 instanceof IcebergError && error2.status === 409) {
            return;
          }
          throw error2;
        }
      }
    };
    TableOperations = class {
      constructor(client, prefix = "", accessDelegation) {
        this.client = client;
        this.prefix = prefix;
        this.accessDelegation = accessDelegation;
      }
      async listTables(namespace) {
        const response = await this.client.request({
          method: "GET",
          path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`
        });
        return response.data.identifiers;
      }
      async createTable(namespace, request) {
        const headers = {};
        if (this.accessDelegation) {
          headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
        }
        const response = await this.client.request({
          method: "POST",
          path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,
          body: request,
          headers
        });
        return response.data.metadata;
      }
      async updateTable(id, request) {
        const response = await this.client.request({
          method: "POST",
          path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
          body: request
        });
        return {
          "metadata-location": response.data["metadata-location"],
          metadata: response.data.metadata
        };
      }
      async dropTable(id, options) {
        await this.client.request({
          method: "DELETE",
          path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
          query: { purgeRequested: String(options?.purge ?? false) }
        });
      }
      async loadTable(id) {
        const headers = {};
        if (this.accessDelegation) {
          headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
        }
        const response = await this.client.request({
          method: "GET",
          path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
          headers
        });
        return response.data.metadata;
      }
      async tableExists(id) {
        const headers = {};
        if (this.accessDelegation) {
          headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
        }
        try {
          await this.client.request({
            method: "HEAD",
            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
            headers
          });
          return true;
        } catch (error2) {
          if (error2 instanceof IcebergError && error2.status === 404) {
            return false;
          }
          throw error2;
        }
      }
      async createTableIfNotExists(namespace, request) {
        try {
          return await this.createTable(namespace, request);
        } catch (error2) {
          if (error2 instanceof IcebergError && error2.status === 409) {
            return await this.loadTable({ namespace: namespace.namespace, name: request.name });
          }
          throw error2;
        }
      }
    };
    IcebergRestCatalog = class {
      /**
       * Creates a new Iceberg REST Catalog client.
       *
       * @param options - Configuration options for the catalog client
       */
      constructor(options) {
        let prefix = "v1";
        if (options.catalogName) {
          prefix += `/${options.catalogName}`;
        }
        const baseUrl = options.baseUrl.endsWith("/") ? options.baseUrl : `${options.baseUrl}/`;
        this.client = createFetchClient({
          baseUrl,
          auth: options.auth,
          fetchImpl: options.fetch
        });
        this.accessDelegation = options.accessDelegation?.join(",");
        this.namespaceOps = new NamespaceOperations(this.client, prefix);
        this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);
      }
      /**
       * Lists all namespaces in the catalog.
       *
       * @param parent - Optional parent namespace to list children under
       * @returns Array of namespace identifiers
       *
       * @example
       * ```typescript
       * // List all top-level namespaces
       * const namespaces = await catalog.listNamespaces();
       *
       * // List namespaces under a parent
       * const children = await catalog.listNamespaces({ namespace: ['analytics'] });
       * ```
       */
      async listNamespaces(parent) {
        return this.namespaceOps.listNamespaces(parent);
      }
      /**
       * Creates a new namespace in the catalog.
       *
       * @param id - Namespace identifier to create
       * @param metadata - Optional metadata properties for the namespace
       * @returns Response containing the created namespace and its properties
       *
       * @example
       * ```typescript
       * const response = await catalog.createNamespace(
       *   { namespace: ['analytics'] },
       *   { properties: { owner: 'data-team' } }
       * );
       * console.log(response.namespace); // ['analytics']
       * console.log(response.properties); // { owner: 'data-team', ... }
       * ```
       */
      async createNamespace(id, metadata) {
        return this.namespaceOps.createNamespace(id, metadata);
      }
      /**
       * Drops a namespace from the catalog.
       *
       * The namespace must be empty (contain no tables) before it can be dropped.
       *
       * @param id - Namespace identifier to drop
       *
       * @example
       * ```typescript
       * await catalog.dropNamespace({ namespace: ['analytics'] });
       * ```
       */
      async dropNamespace(id) {
        await this.namespaceOps.dropNamespace(id);
      }
      /**
       * Loads metadata for a namespace.
       *
       * @param id - Namespace identifier to load
       * @returns Namespace metadata including properties
       *
       * @example
       * ```typescript
       * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });
       * console.log(metadata.properties);
       * ```
       */
      async loadNamespaceMetadata(id) {
        return this.namespaceOps.loadNamespaceMetadata(id);
      }
      /**
       * Lists all tables in a namespace.
       *
       * @param namespace - Namespace identifier to list tables from
       * @returns Array of table identifiers
       *
       * @example
       * ```typescript
       * const tables = await catalog.listTables({ namespace: ['analytics'] });
       * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]
       * ```
       */
      async listTables(namespace) {
        return this.tableOps.listTables(namespace);
      }
      /**
       * Creates a new table in the catalog.
       *
       * @param namespace - Namespace to create the table in
       * @param request - Table creation request including name, schema, partition spec, etc.
       * @returns Table metadata for the created table
       *
       * @example
       * ```typescript
       * const metadata = await catalog.createTable(
       *   { namespace: ['analytics'] },
       *   {
       *     name: 'events',
       *     schema: {
       *       type: 'struct',
       *       fields: [
       *         { id: 1, name: 'id', type: 'long', required: true },
       *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }
       *       ],
       *       'schema-id': 0
       *     },
       *     'partition-spec': {
       *       'spec-id': 0,
       *       fields: [
       *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }
       *       ]
       *     }
       *   }
       * );
       * ```
       */
      async createTable(namespace, request) {
        return this.tableOps.createTable(namespace, request);
      }
      /**
       * Updates an existing table's metadata.
       *
       * Can update the schema, partition spec, or properties of a table.
       *
       * @param id - Table identifier to update
       * @param request - Update request with fields to modify
       * @returns Response containing the metadata location and updated table metadata
       *
       * @example
       * ```typescript
       * const response = await catalog.updateTable(
       *   { namespace: ['analytics'], name: 'events' },
       *   {
       *     properties: { 'read.split.target-size': '134217728' }
       *   }
       * );
       * console.log(response['metadata-location']); // s3://...
       * console.log(response.metadata); // TableMetadata object
       * ```
       */
      async updateTable(id, request) {
        return this.tableOps.updateTable(id, request);
      }
      /**
       * Drops a table from the catalog.
       *
       * @param id - Table identifier to drop
       *
       * @example
       * ```typescript
       * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });
       * ```
       */
      async dropTable(id, options) {
        await this.tableOps.dropTable(id, options);
      }
      /**
       * Loads metadata for a table.
       *
       * @param id - Table identifier to load
       * @returns Table metadata including schema, partition spec, location, etc.
       *
       * @example
       * ```typescript
       * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });
       * console.log(metadata.schema);
       * console.log(metadata.location);
       * ```
       */
      async loadTable(id) {
        return this.tableOps.loadTable(id);
      }
      /**
       * Checks if a namespace exists in the catalog.
       *
       * @param id - Namespace identifier to check
       * @returns True if the namespace exists, false otherwise
       *
       * @example
       * ```typescript
       * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });
       * console.log(exists); // true or false
       * ```
       */
      async namespaceExists(id) {
        return this.namespaceOps.namespaceExists(id);
      }
      /**
       * Checks if a table exists in the catalog.
       *
       * @param id - Table identifier to check
       * @returns True if the table exists, false otherwise
       *
       * @example
       * ```typescript
       * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });
       * console.log(exists); // true or false
       * ```
       */
      async tableExists(id) {
        return this.tableOps.tableExists(id);
      }
      /**
       * Creates a namespace if it does not exist.
       *
       * If the namespace already exists, returns void. If created, returns the response.
       *
       * @param id - Namespace identifier to create
       * @param metadata - Optional metadata properties for the namespace
       * @returns Response containing the created namespace and its properties, or void if it already exists
       *
       * @example
       * ```typescript
       * const response = await catalog.createNamespaceIfNotExists(
       *   { namespace: ['analytics'] },
       *   { properties: { owner: 'data-team' } }
       * );
       * if (response) {
       *   console.log('Created:', response.namespace);
       * } else {
       *   console.log('Already exists');
       * }
       * ```
       */
      async createNamespaceIfNotExists(id, metadata) {
        return this.namespaceOps.createNamespaceIfNotExists(id, metadata);
      }
      /**
       * Creates a table if it does not exist.
       *
       * If the table already exists, returns its metadata instead.
       *
       * @param namespace - Namespace to create the table in
       * @param request - Table creation request including name, schema, partition spec, etc.
       * @returns Table metadata for the created or existing table
       *
       * @example
       * ```typescript
       * const metadata = await catalog.createTableIfNotExists(
       *   { namespace: ['analytics'] },
       *   {
       *     name: 'events',
       *     schema: {
       *       type: 'struct',
       *       fields: [
       *         { id: 1, name: 'id', type: 'long', required: true },
       *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }
       *       ],
       *       'schema-id': 0
       *     }
       *   }
       * );
       * ```
       */
      async createTableIfNotExists(namespace, request) {
        return this.tableOps.createTableIfNotExists(namespace, request);
      }
    };
  }
});

// node_modules/@supabase/storage-js/dist/index.mjs
function isStorageError(error2) {
  return typeof error2 === "object" && error2 !== null && "__isStorageError" in error2;
}
function _typeof2(o5) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
    return typeof o$1;
  } : function(o$1) {
    return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
  }, _typeof2(o5);
}
function toPrimitive2(t4, r5) {
  if ("object" != _typeof2(t4) || !t4) return t4;
  var e3 = t4[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i7 = e3.call(t4, r5 || "default");
    if ("object" != _typeof2(i7)) return i7;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r5 ? String : Number)(t4);
}
function toPropertyKey2(t4) {
  var i7 = toPrimitive2(t4, "string");
  return "symbol" == _typeof2(i7) ? i7 : i7 + "";
}
function _defineProperty2(e3, r5, t4) {
  return (r5 = toPropertyKey2(r5)) in e3 ? Object.defineProperty(e3, r5, {
    value: t4,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r5] = t4, e3;
}
function ownKeys2(e3, r5) {
  var t4 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o5 = Object.getOwnPropertySymbols(e3);
    r5 && (o5 = o5.filter(function(r$1) {
      return Object.getOwnPropertyDescriptor(e3, r$1).enumerable;
    })), t4.push.apply(t4, o5);
  }
  return t4;
}
function _objectSpread22(e3) {
  for (var r5 = 1; r5 < arguments.length; r5++) {
    var t4 = null != arguments[r5] ? arguments[r5] : {};
    r5 % 2 ? ownKeys2(Object(t4), true).forEach(function(r$1) {
      _defineProperty2(e3, r$1, t4[r$1]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t4)) : ownKeys2(Object(t4)).forEach(function(r$1) {
      Object.defineProperty(e3, r$1, Object.getOwnPropertyDescriptor(t4, r$1));
    });
  }
  return e3;
}
async function _handleRequest(fetcher, method, url, options, parameters, body, namespace) {
  return new Promise((resolve, reject) => {
    fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {
      if (!result.ok) throw result;
      if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
      if (namespace === "vectors") {
        const contentType = result.headers.get("content-type");
        if (result.headers.get("content-length") === "0" || result.status === 204) return {};
        if (!contentType || !contentType.includes("application/json")) return {};
      }
      return result.json();
    }).then((data) => resolve(data)).catch((error2) => handleError(error2, reject, options, namespace));
  });
}
function createFetchApi(namespace = "storage") {
  return {
    get: async (fetcher, url, options, parameters) => {
      return _handleRequest(fetcher, "GET", url, options, parameters, void 0, namespace);
    },
    post: async (fetcher, url, body, options, parameters) => {
      return _handleRequest(fetcher, "POST", url, options, parameters, body, namespace);
    },
    put: async (fetcher, url, body, options, parameters) => {
      return _handleRequest(fetcher, "PUT", url, options, parameters, body, namespace);
    },
    head: async (fetcher, url, options, parameters) => {
      return _handleRequest(fetcher, "HEAD", url, _objectSpread22(_objectSpread22({}, options), {}, { noResolveJson: true }), parameters, void 0, namespace);
    },
    remove: async (fetcher, url, body, options, parameters) => {
      return _handleRequest(fetcher, "DELETE", url, options, parameters, body, namespace);
    }
  };
}
var StorageError, StorageApiError, StorageUnknownError, resolveFetch2, isPlainObject, recursiveToCamel, isValidBucketName, _getErrorMessage, handleError, _getRequestParams, defaultApi, get, post, put, head, remove, vectorsApi, BaseApiClient, StreamDownloadBuilder, _Symbol$toStringTag, BlobDownloadBuilder, DEFAULT_SEARCH_OPTIONS, DEFAULT_FILE_OPTIONS, StorageFileApi, version2, DEFAULT_HEADERS, StorageBucketApi, StorageAnalyticsClient, VectorIndexApi, VectorDataApi, VectorBucketApi, StorageVectorsClient, VectorBucketScope, VectorIndexScope, StorageClient;
var init_dist3 = __esm({
  "node_modules/@supabase/storage-js/dist/index.mjs"() {
    init_dist2();
    StorageError = class extends Error {
      constructor(message, namespace = "storage", status, statusCode) {
        super(message);
        this.__isStorageError = true;
        this.namespace = namespace;
        this.name = namespace === "vectors" ? "StorageVectorsError" : "StorageError";
        this.status = status;
        this.statusCode = statusCode;
      }
    };
    StorageApiError = class extends StorageError {
      constructor(message, status, statusCode, namespace = "storage") {
        super(message, namespace, status, statusCode);
        this.name = namespace === "vectors" ? "StorageVectorsApiError" : "StorageApiError";
        this.status = status;
        this.statusCode = statusCode;
      }
      toJSON() {
        return {
          name: this.name,
          message: this.message,
          status: this.status,
          statusCode: this.statusCode
        };
      }
    };
    StorageUnknownError = class extends StorageError {
      constructor(message, originalError, namespace = "storage") {
        super(message, namespace);
        this.name = namespace === "vectors" ? "StorageVectorsUnknownError" : "StorageUnknownError";
        this.originalError = originalError;
      }
    };
    resolveFetch2 = (customFetch) => {
      if (customFetch) return (...args) => customFetch(...args);
      return (...args) => fetch(...args);
    };
    isPlainObject = (value) => {
      if (typeof value !== "object" || value === null) return false;
      const prototype = Object.getPrototypeOf(value);
      return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
    };
    recursiveToCamel = (item) => {
      if (Array.isArray(item)) return item.map((el) => recursiveToCamel(el));
      else if (typeof item === "function" || item !== Object(item)) return item;
      const result = {};
      Object.entries(item).forEach(([key, value]) => {
        const newKey = key.replace(/([-_][a-z])/gi, (c7) => c7.toUpperCase().replace(/[-_]/g, ""));
        result[newKey] = recursiveToCamel(value);
      });
      return result;
    };
    isValidBucketName = (bucketName) => {
      if (!bucketName || typeof bucketName !== "string") return false;
      if (bucketName.length === 0 || bucketName.length > 100) return false;
      if (bucketName.trim() !== bucketName) return false;
      if (bucketName.includes("/") || bucketName.includes("\\")) return false;
      return /^[\w!.\*'() &$@=;:+,?-]+$/.test(bucketName);
    };
    _getErrorMessage = (err) => {
      var _err$error;
      return err.msg || err.message || err.error_description || (typeof err.error === "string" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);
    };
    handleError = async (error2, reject, options, namespace) => {
      if (error2 && typeof error2 === "object" && "status" in error2 && "ok" in error2 && typeof error2.status === "number" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
        const responseError = error2;
        const status = responseError.status || 500;
        if (typeof responseError.json === "function") responseError.json().then((err) => {
          const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + "";
          reject(new StorageApiError(_getErrorMessage(err), status, statusCode, namespace));
        }).catch(() => {
          if (namespace === "vectors") {
            const statusCode = status + "";
            reject(new StorageApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode, namespace));
          } else {
            const statusCode = status + "";
            reject(new StorageApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode, namespace));
          }
        });
        else {
          const statusCode = status + "";
          reject(new StorageApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode, namespace));
        }
      } else reject(new StorageUnknownError(_getErrorMessage(error2), error2, namespace));
    };
    _getRequestParams = (method, options, parameters, body) => {
      const params2 = {
        method,
        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
      };
      if (method === "GET" || method === "HEAD" || !body) return _objectSpread22(_objectSpread22({}, params2), parameters);
      if (isPlainObject(body)) {
        params2.headers = _objectSpread22({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
        params2.body = JSON.stringify(body);
      } else params2.body = body;
      if (options === null || options === void 0 ? void 0 : options.duplex) params2.duplex = options.duplex;
      return _objectSpread22(_objectSpread22({}, params2), parameters);
    };
    defaultApi = createFetchApi("storage");
    ({ get, post, put, head, remove } = defaultApi);
    vectorsApi = createFetchApi("vectors");
    BaseApiClient = class {
      /**
      * Creates a new BaseApiClient instance
      * @param url - Base URL for API requests
      * @param headers - Default headers for API requests
      * @param fetch - Optional custom fetch implementation
      * @param namespace - Error namespace ('storage' or 'vectors')
      */
      constructor(url, headers = {}, fetch$1, namespace = "storage") {
        this.shouldThrowOnError = false;
        this.url = url;
        this.headers = headers;
        this.fetch = resolveFetch2(fetch$1);
        this.namespace = namespace;
      }
      /**
      * Enable throwing errors instead of returning them.
      * When enabled, errors are thrown instead of returned in { data, error } format.
      *
      * @returns this - For method chaining
      */
      throwOnError() {
        this.shouldThrowOnError = true;
        return this;
      }
      /**
      * Handles API operation with standardized error handling
      * Eliminates repetitive try-catch blocks across all API methods
      *
      * This wrapper:
      * 1. Executes the operation
      * 2. Returns { data, error: null } on success
      * 3. Returns { data: null, error } on failure (if shouldThrowOnError is false)
      * 4. Throws error on failure (if shouldThrowOnError is true)
      *
      * @typeParam T - The expected data type from the operation
      * @param operation - Async function that performs the API call
      * @returns Promise with { data, error } tuple
      *
      * @example
      * ```typescript
      * async listBuckets() {
      *   return this.handleOperation(async () => {
      *     return await get(this.fetch, `${this.url}/bucket`, {
      *       headers: this.headers,
      *     })
      *   })
      * }
      * ```
      */
      async handleOperation(operation) {
        var _this = this;
        try {
          return {
            data: await operation(),
            error: null
          };
        } catch (error2) {
          if (_this.shouldThrowOnError) throw error2;
          if (isStorageError(error2)) return {
            data: null,
            error: error2
          };
          throw error2;
        }
      }
    };
    StreamDownloadBuilder = class {
      constructor(downloadFn, shouldThrowOnError) {
        this.downloadFn = downloadFn;
        this.shouldThrowOnError = shouldThrowOnError;
      }
      then(onfulfilled, onrejected) {
        return this.execute().then(onfulfilled, onrejected);
      }
      async execute() {
        var _this = this;
        try {
          return {
            data: (await _this.downloadFn()).body,
            error: null
          };
        } catch (error2) {
          if (_this.shouldThrowOnError) throw error2;
          if (isStorageError(error2)) return {
            data: null,
            error: error2
          };
          throw error2;
        }
      }
    };
    _Symbol$toStringTag = Symbol.toStringTag;
    BlobDownloadBuilder = class {
      constructor(downloadFn, shouldThrowOnError) {
        this.downloadFn = downloadFn;
        this.shouldThrowOnError = shouldThrowOnError;
        this[_Symbol$toStringTag] = "BlobDownloadBuilder";
        this.promise = null;
      }
      asStream() {
        return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);
      }
      then(onfulfilled, onrejected) {
        return this.getPromise().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.getPromise().catch(onrejected);
      }
      finally(onfinally) {
        return this.getPromise().finally(onfinally);
      }
      getPromise() {
        if (!this.promise) this.promise = this.execute();
        return this.promise;
      }
      async execute() {
        var _this = this;
        try {
          return {
            data: await (await _this.downloadFn()).blob(),
            error: null
          };
        } catch (error2) {
          if (_this.shouldThrowOnError) throw error2;
          if (isStorageError(error2)) return {
            data: null,
            error: error2
          };
          throw error2;
        }
      }
    };
    DEFAULT_SEARCH_OPTIONS = {
      limit: 100,
      offset: 0,
      sortBy: {
        column: "name",
        order: "asc"
      }
    };
    DEFAULT_FILE_OPTIONS = {
      cacheControl: "3600",
      contentType: "text/plain;charset=UTF-8",
      upsert: false
    };
    StorageFileApi = class extends BaseApiClient {
      constructor(url, headers = {}, bucketId, fetch$1) {
        super(url, headers, fetch$1, "storage");
        this.bucketId = bucketId;
      }
      /**
      * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
      *
      * @param method HTTP method.
      * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
      * @param fileBody The body of the file to be stored in the bucket.
      */
      async uploadOrUpdate(method, path, fileBody, fileOptions) {
        var _this = this;
        return _this.handleOperation(async () => {
          let body;
          const options = _objectSpread22(_objectSpread22({}, DEFAULT_FILE_OPTIONS), fileOptions);
          let headers = _objectSpread22(_objectSpread22({}, _this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
          const metadata = options.metadata;
          if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
            body = new FormData();
            body.append("cacheControl", options.cacheControl);
            if (metadata) body.append("metadata", _this.encodeMetadata(metadata));
            body.append("", fileBody);
          } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
            body = fileBody;
            if (!body.has("cacheControl")) body.append("cacheControl", options.cacheControl);
            if (metadata && !body.has("metadata")) body.append("metadata", _this.encodeMetadata(metadata));
          } else {
            body = fileBody;
            headers["cache-control"] = `max-age=${options.cacheControl}`;
            headers["content-type"] = options.contentType;
            if (metadata) headers["x-metadata"] = _this.toBase64(_this.encodeMetadata(metadata));
            if ((typeof ReadableStream !== "undefined" && body instanceof ReadableStream || body && typeof body === "object" && "pipe" in body && typeof body.pipe === "function") && !options.duplex) options.duplex = "half";
          }
          if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread22(_objectSpread22({}, headers), fileOptions.headers);
          const cleanPath = _this._removeEmptyFolders(path);
          const _path = _this._getFinalPath(cleanPath);
          const data = await (method == "PUT" ? put : post)(_this.fetch, `${_this.url}/object/${_path}`, body, _objectSpread22({ headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
          return {
            path: cleanPath,
            id: data.Id,
            fullPath: data.Key
          };
        });
      }
      /**
      * Uploads a file to an existing bucket.
      *
      * @category File Buckets
      * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
      * @param fileBody The body of the file to be stored in the bucket.
      * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
      * @returns Promise with response containing file path, id, and fullPath or error
      *
      * @example Upload file
      * ```js
      * const avatarFile = event.target.files[0]
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .upload('public/avatar1.png', avatarFile, {
      *     cacheControl: '3600',
      *     upsert: false
      *   })
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "path": "public/avatar1.png",
      *     "fullPath": "avatars/public/avatar1.png"
      *   },
      *   "error": null
      * }
      * ```
      *
      * @example Upload file using `ArrayBuffer` from base64 file data
      * ```js
      * import { decode } from 'base64-arraybuffer'
      *
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .upload('public/avatar1.png', decode('base64FileData'), {
      *     contentType: 'image/png'
      *   })
      * ```
      */
      async upload(path, fileBody, fileOptions) {
        return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
      }
      /**
      * Upload a file with a token generated from `createSignedUploadUrl`.
      *
      * @category File Buckets
      * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
      * @param token The token generated from `createSignedUploadUrl`
      * @param fileBody The body of the file to be stored in the bucket.
      * @param fileOptions HTTP headers (cacheControl, contentType, etc.).
      * **Note:** The `upsert` option has no effect here. To enable upsert behavior,
      * pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.
      * @returns Promise with response containing file path and fullPath or error
      *
      * @example Upload to a signed URL
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "path": "folder/cat.jpg",
      *     "fullPath": "avatars/folder/cat.jpg"
      *   },
      *   "error": null
      * }
      * ```
      */
      async uploadToSignedUrl(path, token, fileBody, fileOptions) {
        var _this3 = this;
        const cleanPath = _this3._removeEmptyFolders(path);
        const _path = _this3._getFinalPath(cleanPath);
        const url = new URL(_this3.url + `/object/upload/sign/${_path}`);
        url.searchParams.set("token", token);
        return _this3.handleOperation(async () => {
          let body;
          const options = _objectSpread22({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
          const headers = _objectSpread22(_objectSpread22({}, _this3.headers), { "x-upsert": String(options.upsert) });
          if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
            body = new FormData();
            body.append("cacheControl", options.cacheControl);
            body.append("", fileBody);
          } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
            body = fileBody;
            body.append("cacheControl", options.cacheControl);
          } else {
            body = fileBody;
            headers["cache-control"] = `max-age=${options.cacheControl}`;
            headers["content-type"] = options.contentType;
          }
          return {
            path: cleanPath,
            fullPath: (await put(_this3.fetch, url.toString(), body, { headers })).Key
          };
        });
      }
      /**
      * Creates a signed upload URL.
      * Signed upload URLs can be used to upload files to the bucket without further authentication.
      * They are valid for 2 hours.
      *
      * @category File Buckets
      * @param path The file path, including the current file name. For example `folder/image.png`.
      * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
      * @returns Promise with response containing signed upload URL, token, and path or error
      *
      * @example Create Signed Upload URL
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .createSignedUploadUrl('folder/cat.jpg')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "signedUrl": "https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>",
      *     "path": "folder/cat.jpg",
      *     "token": "<TOKEN>"
      *   },
      *   "error": null
      * }
      * ```
      */
      async createSignedUploadUrl(path, options) {
        var _this4 = this;
        return _this4.handleOperation(async () => {
          let _path = _this4._getFinalPath(path);
          const headers = _objectSpread22({}, _this4.headers);
          if (options === null || options === void 0 ? void 0 : options.upsert) headers["x-upsert"] = "true";
          const data = await post(_this4.fetch, `${_this4.url}/object/upload/sign/${_path}`, {}, { headers });
          const url = new URL(_this4.url + data.url);
          const token = url.searchParams.get("token");
          if (!token) throw new StorageError("No token returned by API");
          return {
            signedUrl: url.toString(),
            path,
            token
          };
        });
      }
      /**
      * Replaces an existing file at the specified path with a new one.
      *
      * @category File Buckets
      * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
      * @param fileBody The body of the file to be stored in the bucket.
      * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
      * @returns Promise with response containing file path, id, and fullPath or error
      *
      * @example Update file
      * ```js
      * const avatarFile = event.target.files[0]
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .update('public/avatar1.png', avatarFile, {
      *     cacheControl: '3600',
      *     upsert: true
      *   })
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "path": "public/avatar1.png",
      *     "fullPath": "avatars/public/avatar1.png"
      *   },
      *   "error": null
      * }
      * ```
      *
      * @example Update file using `ArrayBuffer` from base64 file data
      * ```js
      * import {decode} from 'base64-arraybuffer'
      *
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .update('public/avatar1.png', decode('base64FileData'), {
      *     contentType: 'image/png'
      *   })
      * ```
      */
      async update(path, fileBody, fileOptions) {
        return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
      }
      /**
      * Moves an existing file to a new path in the same bucket.
      *
      * @category File Buckets
      * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
      * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
      * @param options The destination options.
      * @returns Promise with response containing success message or error
      *
      * @example Move file
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .move('public/avatar1.png', 'private/avatar2.png')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "message": "Successfully moved"
      *   },
      *   "error": null
      * }
      * ```
      */
      async move(fromPath, toPath, options) {
        var _this6 = this;
        return _this6.handleOperation(async () => {
          return await post(_this6.fetch, `${_this6.url}/object/move`, {
            bucketId: _this6.bucketId,
            sourceKey: fromPath,
            destinationKey: toPath,
            destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
          }, { headers: _this6.headers });
        });
      }
      /**
      * Copies an existing file to a new path in the same bucket.
      *
      * @category File Buckets
      * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
      * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
      * @param options The destination options.
      * @returns Promise with response containing copied file path or error
      *
      * @example Copy file
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .copy('public/avatar1.png', 'private/avatar2.png')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "path": "avatars/private/avatar2.png"
      *   },
      *   "error": null
      * }
      * ```
      */
      async copy(fromPath, toPath, options) {
        var _this7 = this;
        return _this7.handleOperation(async () => {
          return { path: (await post(_this7.fetch, `${_this7.url}/object/copy`, {
            bucketId: _this7.bucketId,
            sourceKey: fromPath,
            destinationKey: toPath,
            destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
          }, { headers: _this7.headers })).Key };
        });
      }
      /**
      * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
      *
      * @category File Buckets
      * @param path The file path, including the current file name. For example `folder/image.png`.
      * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
      * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
      * @param options.transform Transform the asset before serving it to the client.
      * @returns Promise with response containing signed URL or error
      *
      * @example Create Signed URL
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .createSignedUrl('folder/avatar1.png', 60)
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
      *   },
      *   "error": null
      * }
      * ```
      *
      * @example Create a signed URL for an asset with transformations
      * ```js
      * const { data } = await supabase
      *   .storage
      *   .from('avatars')
      *   .createSignedUrl('folder/avatar1.png', 60, {
      *     transform: {
      *       width: 100,
      *       height: 100,
      *     }
      *   })
      * ```
      *
      * @example Create a signed URL which triggers the download of the asset
      * ```js
      * const { data } = await supabase
      *   .storage
      *   .from('avatars')
      *   .createSignedUrl('folder/avatar1.png', 60, {
      *     download: true,
      *   })
      * ```
      */
      async createSignedUrl(path, expiresIn, options) {
        var _this8 = this;
        return _this8.handleOperation(async () => {
          let _path = _this8._getFinalPath(path);
          let data = await post(_this8.fetch, `${_this8.url}/object/sign/${_path}`, _objectSpread22({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: _this8.headers });
          const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
          return { signedUrl: encodeURI(`${_this8.url}${data.signedURL}${downloadQueryParam}`) };
        });
      }
      /**
      * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
      *
      * @category File Buckets
      * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
      * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
      * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
      * @returns Promise with response containing array of objects with signedUrl, path, and error or error
      *
      * @example Create Signed URLs
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": [
      *     {
      *       "error": null,
      *       "path": "folder/avatar1.png",
      *       "signedURL": "/object/sign/avatars/folder/avatar1.png?token=<TOKEN>",
      *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
      *     },
      *     {
      *       "error": null,
      *       "path": "folder/avatar2.png",
      *       "signedURL": "/object/sign/avatars/folder/avatar2.png?token=<TOKEN>",
      *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>"
      *     }
      *   ],
      *   "error": null
      * }
      * ```
      */
      async createSignedUrls(paths, expiresIn, options) {
        var _this9 = this;
        return _this9.handleOperation(async () => {
          const data = await post(_this9.fetch, `${_this9.url}/object/sign/${_this9.bucketId}`, {
            expiresIn,
            paths
          }, { headers: _this9.headers });
          const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
          return data.map((datum2) => _objectSpread22(_objectSpread22({}, datum2), {}, { signedUrl: datum2.signedURL ? encodeURI(`${_this9.url}${datum2.signedURL}${downloadQueryParam}`) : null }));
        });
      }
      /**
      * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
      *
      * @category File Buckets
      * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
      * @param options.transform Transform the asset before serving it to the client.
      * @param parameters Additional fetch parameters like signal for cancellation. Supports standard fetch options including cache control.
      * @returns BlobDownloadBuilder instance for downloading the file
      *
      * @example Download file
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .download('folder/avatar1.png')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": <BLOB>,
      *   "error": null
      * }
      * ```
      *
      * @example Download file with transformations
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .download('folder/avatar1.png', {
      *     transform: {
      *       width: 100,
      *       height: 100,
      *       quality: 80
      *     }
      *   })
      * ```
      *
      * @example Download with cache control (useful in Edge Functions)
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .download('folder/avatar1.png', {}, { cache: 'no-store' })
      * ```
      *
      * @example Download with abort signal
      * ```js
      * const controller = new AbortController()
      * setTimeout(() => controller.abort(), 5000)
      *
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .download('folder/avatar1.png', {}, { signal: controller.signal })
      * ```
      */
      download(path, options, parameters) {
        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined" ? "render/image/authenticated" : "object";
        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
        const queryString = transformationQuery ? `?${transformationQuery}` : "";
        const _path = this._getFinalPath(path);
        const downloadFn = () => get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
          headers: this.headers,
          noResolveJson: true
        }, parameters);
        return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);
      }
      /**
      * Retrieves the details of an existing file.
      *
      * @category File Buckets
      * @param path The file path, including the file name. For example `folder/image.png`.
      * @returns Promise with response containing file metadata or error
      *
      * @example Get file info
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .info('folder/avatar1.png')
      * ```
      */
      async info(path) {
        var _this10 = this;
        const _path = _this10._getFinalPath(path);
        return _this10.handleOperation(async () => {
          return recursiveToCamel(await get(_this10.fetch, `${_this10.url}/object/info/${_path}`, { headers: _this10.headers }));
        });
      }
      /**
      * Checks the existence of a file.
      *
      * @category File Buckets
      * @param path The file path, including the file name. For example `folder/image.png`.
      * @returns Promise with response containing boolean indicating file existence or error
      *
      * @example Check file existence
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .exists('folder/avatar1.png')
      * ```
      */
      async exists(path) {
        var _this11 = this;
        const _path = _this11._getFinalPath(path);
        try {
          await head(_this11.fetch, `${_this11.url}/object/${_path}`, { headers: _this11.headers });
          return {
            data: true,
            error: null
          };
        } catch (error2) {
          if (_this11.shouldThrowOnError) throw error2;
          if (isStorageError(error2) && error2 instanceof StorageUnknownError) {
            const originalError = error2.originalError;
            if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) return {
              data: false,
              error: error2
            };
          }
          throw error2;
        }
      }
      /**
      * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
      * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
      *
      * @category File Buckets
      * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
      * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
      * @param options.transform Transform the asset before serving it to the client.
      * @returns Object with public URL
      *
      * @example Returns the URL for an asset in a public bucket
      * ```js
      * const { data } = supabase
      *   .storage
      *   .from('public-bucket')
      *   .getPublicUrl('folder/avatar1.png')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "publicUrl": "https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png"
      *   }
      * }
      * ```
      *
      * @example Returns the URL for an asset in a public bucket with transformations
      * ```js
      * const { data } = supabase
      *   .storage
      *   .from('public-bucket')
      *   .getPublicUrl('folder/avatar1.png', {
      *     transform: {
      *       width: 100,
      *       height: 100,
      *     }
      *   })
      * ```
      *
      * @example Returns the URL which triggers the download of an asset in a public bucket
      * ```js
      * const { data } = supabase
      *   .storage
      *   .from('public-bucket')
      *   .getPublicUrl('folder/avatar1.png', {
      *     download: true,
      *   })
      * ```
      */
      getPublicUrl(path, options) {
        const _path = this._getFinalPath(path);
        const _queryString = [];
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
        if (downloadQueryParam !== "") _queryString.push(downloadQueryParam);
        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined" ? "render/image" : "object";
        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
        if (transformationQuery !== "") _queryString.push(transformationQuery);
        let queryString = _queryString.join("&");
        if (queryString !== "") queryString = `?${queryString}`;
        return { data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) } };
      }
      /**
      * Deletes files within the same bucket
      *
      * @category File Buckets
      * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
      * @returns Promise with response containing array of deleted file objects or error
      *
      * @example Delete file
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .remove(['folder/avatar1.png'])
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": [],
      *   "error": null
      * }
      * ```
      */
      async remove(paths) {
        var _this12 = this;
        return _this12.handleOperation(async () => {
          return await remove(_this12.fetch, `${_this12.url}/object/${_this12.bucketId}`, { prefixes: paths }, { headers: _this12.headers });
        });
      }
      /**
      * Get file metadata
      * @param id the file id to retrieve metadata
      */
      /**
      * Update file metadata
      * @param id the file id to update metadata
      * @param meta the new file metadata
      */
      /**
      * Lists all the files and folders within a path of the bucket.
      *
      * @category File Buckets
      * @param path The folder path.
      * @param options Search options including limit (defaults to 100), offset, sortBy, and search
      * @param parameters Optional fetch parameters including signal for cancellation
      * @returns Promise with response containing array of files or error
      *
      * @example List files in a bucket
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .list('folder', {
      *     limit: 100,
      *     offset: 0,
      *     sortBy: { column: 'name', order: 'asc' },
      *   })
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": [
      *     {
      *       "name": "avatar1.png",
      *       "id": "e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2",
      *       "updated_at": "2024-05-22T23:06:05.580Z",
      *       "created_at": "2024-05-22T23:04:34.443Z",
      *       "last_accessed_at": "2024-05-22T23:04:34.443Z",
      *       "metadata": {
      *         "eTag": "\"c5e8c553235d9af30ef4f6e280790b92\"",
      *         "size": 32175,
      *         "mimetype": "image/png",
      *         "cacheControl": "max-age=3600",
      *         "lastModified": "2024-05-22T23:06:05.574Z",
      *         "contentLength": 32175,
      *         "httpStatusCode": 200
      *       }
      *     }
      *   ],
      *   "error": null
      * }
      * ```
      *
      * @example Search files in a bucket
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .from('avatars')
      *   .list('folder', {
      *     limit: 100,
      *     offset: 0,
      *     sortBy: { column: 'name', order: 'asc' },
      *     search: 'jon'
      *   })
      * ```
      */
      async list(path, options, parameters) {
        var _this13 = this;
        return _this13.handleOperation(async () => {
          const body = _objectSpread22(_objectSpread22(_objectSpread22({}, DEFAULT_SEARCH_OPTIONS), options), {}, { prefix: path || "" });
          return await post(_this13.fetch, `${_this13.url}/object/list/${_this13.bucketId}`, body, { headers: _this13.headers }, parameters);
        });
      }
      /**
      * @experimental this method signature might change in the future
      *
      * @category File Buckets
      * @param options search options
      * @param parameters
      */
      async listV2(options, parameters) {
        var _this14 = this;
        return _this14.handleOperation(async () => {
          const body = _objectSpread22({}, options);
          return await post(_this14.fetch, `${_this14.url}/object/list-v2/${_this14.bucketId}`, body, { headers: _this14.headers }, parameters);
        });
      }
      encodeMetadata(metadata) {
        return JSON.stringify(metadata);
      }
      toBase64(data) {
        if (typeof Buffer !== "undefined") return Buffer.from(data).toString("base64");
        return btoa(data);
      }
      _getFinalPath(path) {
        return `${this.bucketId}/${path.replace(/^\/+/, "")}`;
      }
      _removeEmptyFolders(path) {
        return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
      }
      transformOptsToQueryString(transform3) {
        const params2 = [];
        if (transform3.width) params2.push(`width=${transform3.width}`);
        if (transform3.height) params2.push(`height=${transform3.height}`);
        if (transform3.resize) params2.push(`resize=${transform3.resize}`);
        if (transform3.format) params2.push(`format=${transform3.format}`);
        if (transform3.quality) params2.push(`quality=${transform3.quality}`);
        return params2.join("&");
      }
    };
    version2 = "2.95.3";
    DEFAULT_HEADERS = { "X-Client-Info": `storage-js/${version2}` };
    StorageBucketApi = class extends BaseApiClient {
      constructor(url, headers = {}, fetch$1, opts) {
        const baseUrl = new URL(url);
        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {
          if (/supabase\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes("storage.supabase.")) baseUrl.hostname = baseUrl.hostname.replace("supabase.", "storage.supabase.");
        }
        const finalUrl = baseUrl.href.replace(/\/$/, "");
        const finalHeaders = _objectSpread22(_objectSpread22({}, DEFAULT_HEADERS), headers);
        super(finalUrl, finalHeaders, fetch$1, "storage");
      }
      /**
      * Retrieves the details of all Storage buckets within an existing project.
      *
      * @category File Buckets
      * @param options Query parameters for listing buckets
      * @param options.limit Maximum number of buckets to return
      * @param options.offset Number of buckets to skip
      * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')
      * @param options.sortOrder Sort order ('asc' or 'desc')
      * @param options.search Search term to filter bucket names
      * @returns Promise with response containing array of buckets or error
      *
      * @example List buckets
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .listBuckets()
      * ```
      *
      * @example List buckets with options
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .listBuckets({
      *     limit: 10,
      *     offset: 0,
      *     sortColumn: 'created_at',
      *     sortOrder: 'desc',
      *     search: 'prod'
      *   })
      * ```
      */
      async listBuckets(options) {
        var _this = this;
        return _this.handleOperation(async () => {
          const queryString = _this.listBucketOptionsToQueryString(options);
          return await get(_this.fetch, `${_this.url}/bucket${queryString}`, { headers: _this.headers });
        });
      }
      /**
      * Retrieves the details of an existing Storage bucket.
      *
      * @category File Buckets
      * @param id The unique identifier of the bucket you would like to retrieve.
      * @returns Promise with response containing bucket details or error
      *
      * @example Get bucket
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .getBucket('avatars')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "id": "avatars",
      *     "name": "avatars",
      *     "owner": "",
      *     "public": false,
      *     "file_size_limit": 1024,
      *     "allowed_mime_types": [
      *       "image/png"
      *     ],
      *     "created_at": "2024-05-22T22:26:05.100Z",
      *     "updated_at": "2024-05-22T22:26:05.100Z"
      *   },
      *   "error": null
      * }
      * ```
      */
      async getBucket(id) {
        var _this2 = this;
        return _this2.handleOperation(async () => {
          return await get(_this2.fetch, `${_this2.url}/bucket/${id}`, { headers: _this2.headers });
        });
      }
      /**
      * Creates a new Storage bucket
      *
      * @category File Buckets
      * @param id A unique identifier for the bucket you are creating.
      * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
      * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
      * The global file size limit takes precedence over this value.
      * The default value is null, which doesn't set a per bucket file size limit.
      * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
      * The default value is null, which allows files with all mime types to be uploaded.
      * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
      * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.
      *   - default bucket type is `STANDARD`
      * @returns Promise with response containing newly created bucket name or error
      *
      * @example Create bucket
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .createBucket('avatars', {
      *     public: false,
      *     allowedMimeTypes: ['image/png'],
      *     fileSizeLimit: 1024
      *   })
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "name": "avatars"
      *   },
      *   "error": null
      * }
      * ```
      */
      async createBucket(id, options = { public: false }) {
        var _this3 = this;
        return _this3.handleOperation(async () => {
          return await post(_this3.fetch, `${_this3.url}/bucket`, {
            id,
            name: id,
            type: options.type,
            public: options.public,
            file_size_limit: options.fileSizeLimit,
            allowed_mime_types: options.allowedMimeTypes
          }, { headers: _this3.headers });
        });
      }
      /**
      * Updates a Storage bucket
      *
      * @category File Buckets
      * @param id A unique identifier for the bucket you are updating.
      * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
      * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
      * The global file size limit takes precedence over this value.
      * The default value is null, which doesn't set a per bucket file size limit.
      * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
      * The default value is null, which allows files with all mime types to be uploaded.
      * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
      * @returns Promise with response containing success message or error
      *
      * @example Update bucket
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .updateBucket('avatars', {
      *     public: false,
      *     allowedMimeTypes: ['image/png'],
      *     fileSizeLimit: 1024
      *   })
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "message": "Successfully updated"
      *   },
      *   "error": null
      * }
      * ```
      */
      async updateBucket(id, options) {
        var _this4 = this;
        return _this4.handleOperation(async () => {
          return await put(_this4.fetch, `${_this4.url}/bucket/${id}`, {
            id,
            name: id,
            public: options.public,
            file_size_limit: options.fileSizeLimit,
            allowed_mime_types: options.allowedMimeTypes
          }, { headers: _this4.headers });
        });
      }
      /**
      * Removes all objects inside a single bucket.
      *
      * @category File Buckets
      * @param id The unique identifier of the bucket you would like to empty.
      * @returns Promise with success message or error
      *
      * @example Empty bucket
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .emptyBucket('avatars')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "message": "Successfully emptied"
      *   },
      *   "error": null
      * }
      * ```
      */
      async emptyBucket(id) {
        var _this5 = this;
        return _this5.handleOperation(async () => {
          return await post(_this5.fetch, `${_this5.url}/bucket/${id}/empty`, {}, { headers: _this5.headers });
        });
      }
      /**
      * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
      * You must first `empty()` the bucket.
      *
      * @category File Buckets
      * @param id The unique identifier of the bucket you would like to delete.
      * @returns Promise with success message or error
      *
      * @example Delete bucket
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .deleteBucket('avatars')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "message": "Successfully deleted"
      *   },
      *   "error": null
      * }
      * ```
      */
      async deleteBucket(id) {
        var _this6 = this;
        return _this6.handleOperation(async () => {
          return await remove(_this6.fetch, `${_this6.url}/bucket/${id}`, {}, { headers: _this6.headers });
        });
      }
      listBucketOptionsToQueryString(options) {
        const params2 = {};
        if (options) {
          if ("limit" in options) params2.limit = String(options.limit);
          if ("offset" in options) params2.offset = String(options.offset);
          if (options.search) params2.search = options.search;
          if (options.sortColumn) params2.sortColumn = options.sortColumn;
          if (options.sortOrder) params2.sortOrder = options.sortOrder;
        }
        return Object.keys(params2).length > 0 ? "?" + new URLSearchParams(params2).toString() : "";
      }
    };
    StorageAnalyticsClient = class extends BaseApiClient {
      /**
      * @alpha
      *
      * Creates a new StorageAnalyticsClient instance
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Analytics Buckets
      * @param url - The base URL for the storage API
      * @param headers - HTTP headers to include in requests
      * @param fetch - Optional custom fetch implementation
      *
      * @example
      * ```typescript
      * const client = new StorageAnalyticsClient(url, headers)
      * ```
      */
      constructor(url, headers = {}, fetch$1) {
        const finalUrl = url.replace(/\/$/, "");
        const finalHeaders = _objectSpread22(_objectSpread22({}, DEFAULT_HEADERS), headers);
        super(finalUrl, finalHeaders, fetch$1, "storage");
      }
      /**
      * @alpha
      *
      * Creates a new analytics bucket using Iceberg tables
      * Analytics buckets are optimized for analytical queries and data processing
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Analytics Buckets
      * @param name A unique name for the bucket you are creating
      * @returns Promise with response containing newly created analytics bucket or error
      *
      * @example Create analytics bucket
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .analytics
      *   .createBucket('analytics-data')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "name": "analytics-data",
      *     "type": "ANALYTICS",
      *     "format": "iceberg",
      *     "created_at": "2024-05-22T22:26:05.100Z",
      *     "updated_at": "2024-05-22T22:26:05.100Z"
      *   },
      *   "error": null
      * }
      * ```
      */
      async createBucket(name) {
        var _this = this;
        return _this.handleOperation(async () => {
          return await post(_this.fetch, `${_this.url}/bucket`, { name }, { headers: _this.headers });
        });
      }
      /**
      * @alpha
      *
      * Retrieves the details of all Analytics Storage buckets within an existing project
      * Only returns buckets of type 'ANALYTICS'
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Analytics Buckets
      * @param options Query parameters for listing buckets
      * @param options.limit Maximum number of buckets to return
      * @param options.offset Number of buckets to skip
      * @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')
      * @param options.sortOrder Sort order ('asc' or 'desc')
      * @param options.search Search term to filter bucket names
      * @returns Promise with response containing array of analytics buckets or error
      *
      * @example List analytics buckets
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .analytics
      *   .listBuckets({
      *     limit: 10,
      *     offset: 0,
      *     sortColumn: 'created_at',
      *     sortOrder: 'desc'
      *   })
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": [
      *     {
      *       "name": "analytics-data",
      *       "type": "ANALYTICS",
      *       "format": "iceberg",
      *       "created_at": "2024-05-22T22:26:05.100Z",
      *       "updated_at": "2024-05-22T22:26:05.100Z"
      *     }
      *   ],
      *   "error": null
      * }
      * ```
      */
      async listBuckets(options) {
        var _this2 = this;
        return _this2.handleOperation(async () => {
          const queryParams = new URLSearchParams();
          if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set("limit", options.limit.toString());
          if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set("offset", options.offset.toString());
          if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set("sortColumn", options.sortColumn);
          if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set("sortOrder", options.sortOrder);
          if (options === null || options === void 0 ? void 0 : options.search) queryParams.set("search", options.search);
          const queryString = queryParams.toString();
          const url = queryString ? `${_this2.url}/bucket?${queryString}` : `${_this2.url}/bucket`;
          return await get(_this2.fetch, url, { headers: _this2.headers });
        });
      }
      /**
      * @alpha
      *
      * Deletes an existing analytics bucket
      * A bucket can't be deleted with existing objects inside it
      * You must first empty the bucket before deletion
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Analytics Buckets
      * @param bucketName The unique identifier of the bucket you would like to delete
      * @returns Promise with response containing success message or error
      *
      * @example Delete analytics bucket
      * ```js
      * const { data, error } = await supabase
      *   .storage
      *   .analytics
      *   .deleteBucket('analytics-data')
      * ```
      *
      * Response:
      * ```json
      * {
      *   "data": {
      *     "message": "Successfully deleted"
      *   },
      *   "error": null
      * }
      * ```
      */
      async deleteBucket(bucketName) {
        var _this3 = this;
        return _this3.handleOperation(async () => {
          return await remove(_this3.fetch, `${_this3.url}/bucket/${bucketName}`, {}, { headers: _this3.headers });
        });
      }
      /**
      * @alpha
      *
      * Get an Iceberg REST Catalog client configured for a specific analytics bucket
      * Use this to perform advanced table and namespace operations within the bucket
      * The returned client provides full access to the Apache Iceberg REST Catalog API
      * with the Supabase `{ data, error }` pattern for consistent error handling on all operations.
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Analytics Buckets
      * @param bucketName - The name of the analytics bucket (warehouse) to connect to
      * @returns The wrapped Iceberg catalog client
      * @throws {StorageError} If the bucket name is invalid
      *
      * @example Get catalog and create table
      * ```js
      * // First, create an analytics bucket
      * const { data: bucket, error: bucketError } = await supabase
      *   .storage
      *   .analytics
      *   .createBucket('analytics-data')
      *
      * // Get the Iceberg catalog for that bucket
      * const catalog = supabase.storage.analytics.from('analytics-data')
      *
      * // Create a namespace
      * const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })
      *
      * // Create a table with schema
      * const { data: tableMetadata, error: tableError } = await catalog.createTable(
      *   { namespace: ['default'] },
      *   {
      *     name: 'events',
      *     schema: {
      *       type: 'struct',
      *       fields: [
      *         { id: 1, name: 'id', type: 'long', required: true },
      *         { id: 2, name: 'timestamp', type: 'timestamp', required: true },
      *         { id: 3, name: 'user_id', type: 'string', required: false }
      *       ],
      *       'schema-id': 0,
      *       'identifier-field-ids': [1]
      *     },
      *     'partition-spec': {
      *       'spec-id': 0,
      *       fields: []
      *     },
      *     'write-order': {
      *       'order-id': 0,
      *       fields: []
      *     },
      *     properties: {
      *       'write.format.default': 'parquet'
      *     }
      *   }
      * )
      * ```
      *
      * @example List tables in namespace
      * ```js
      * const catalog = supabase.storage.analytics.from('analytics-data')
      *
      * // List all tables in the default namespace
      * const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })
      * if (listError) {
      *   if (listError.isNotFound()) {
      *     console.log('Namespace not found')
      *   }
      *   return
      * }
      * console.log(tables) // [{ namespace: ['default'], name: 'events' }]
      * ```
      *
      * @example Working with namespaces
      * ```js
      * const catalog = supabase.storage.analytics.from('analytics-data')
      *
      * // List all namespaces
      * const { data: namespaces } = await catalog.listNamespaces()
      *
      * // Create namespace with properties
      * await catalog.createNamespace(
      *   { namespace: ['production'] },
      *   { properties: { owner: 'data-team', env: 'prod' } }
      * )
      * ```
      *
      * @example Cleanup operations
      * ```js
      * const catalog = supabase.storage.analytics.from('analytics-data')
      *
      * // Drop table with purge option (removes all data)
      * const { error: dropError } = await catalog.dropTable(
      *   { namespace: ['default'], name: 'events' },
      *   { purge: true }
      * )
      *
      * if (dropError?.isNotFound()) {
      *   console.log('Table does not exist')
      * }
      *
      * // Drop namespace (must be empty)
      * await catalog.dropNamespace({ namespace: ['default'] })
      * ```
      *
      * @remarks
      * This method provides a bridge between Supabase's bucket management and the standard
      * Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.
      * All authentication and configuration is handled automatically using your Supabase credentials.
      *
      * **Error Handling**: Invalid bucket names throw immediately. All catalog
      * operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.
      * Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.
      * Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.
      *
      * **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently
      * deletes all table data. Without it, the table is marked as deleted but data remains.
      *
      * **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.
      * For complete API documentation and advanced usage, refer to the
      * [iceberg-js documentation](https://supabase.github.io/iceberg-js/).
      */
      from(bucketName) {
        var _this4 = this;
        if (!isValidBucketName(bucketName)) throw new StorageError("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");
        const catalog = new IcebergRestCatalog({
          baseUrl: this.url,
          catalogName: bucketName,
          auth: {
            type: "custom",
            getHeaders: async () => _this4.headers
          },
          fetch: this.fetch
        });
        const shouldThrowOnError = this.shouldThrowOnError;
        return new Proxy(catalog, { get(target, prop) {
          const value = target[prop];
          if (typeof value !== "function") return value;
          return async (...args) => {
            try {
              return {
                data: await value.apply(target, args),
                error: null
              };
            } catch (error2) {
              if (shouldThrowOnError) throw error2;
              return {
                data: null,
                error: error2
              };
            }
          };
        } });
      }
    };
    VectorIndexApi = class extends BaseApiClient {
      /** Creates a new VectorIndexApi instance */
      constructor(url, headers = {}, fetch$1) {
        const finalUrl = url.replace(/\/$/, "");
        const finalHeaders = _objectSpread22(_objectSpread22({}, DEFAULT_HEADERS), {}, { "Content-Type": "application/json" }, headers);
        super(finalUrl, finalHeaders, fetch$1, "vectors");
      }
      /** Creates a new vector index within a bucket */
      async createIndex(options) {
        var _this = this;
        return _this.handleOperation(async () => {
          return await vectorsApi.post(_this.fetch, `${_this.url}/CreateIndex`, options, { headers: _this.headers }) || {};
        });
      }
      /** Retrieves metadata for a specific vector index */
      async getIndex(vectorBucketName, indexName) {
        var _this2 = this;
        return _this2.handleOperation(async () => {
          return await vectorsApi.post(_this2.fetch, `${_this2.url}/GetIndex`, {
            vectorBucketName,
            indexName
          }, { headers: _this2.headers });
        });
      }
      /** Lists vector indexes within a bucket with optional filtering and pagination */
      async listIndexes(options) {
        var _this3 = this;
        return _this3.handleOperation(async () => {
          return await vectorsApi.post(_this3.fetch, `${_this3.url}/ListIndexes`, options, { headers: _this3.headers });
        });
      }
      /** Deletes a vector index and all its data */
      async deleteIndex(vectorBucketName, indexName) {
        var _this4 = this;
        return _this4.handleOperation(async () => {
          return await vectorsApi.post(_this4.fetch, `${_this4.url}/DeleteIndex`, {
            vectorBucketName,
            indexName
          }, { headers: _this4.headers }) || {};
        });
      }
    };
    VectorDataApi = class extends BaseApiClient {
      /** Creates a new VectorDataApi instance */
      constructor(url, headers = {}, fetch$1) {
        const finalUrl = url.replace(/\/$/, "");
        const finalHeaders = _objectSpread22(_objectSpread22({}, DEFAULT_HEADERS), {}, { "Content-Type": "application/json" }, headers);
        super(finalUrl, finalHeaders, fetch$1, "vectors");
      }
      /** Inserts or updates vectors in batch (1-500 per request) */
      async putVectors(options) {
        var _this = this;
        if (options.vectors.length < 1 || options.vectors.length > 500) throw new Error("Vector batch size must be between 1 and 500 items");
        return _this.handleOperation(async () => {
          return await vectorsApi.post(_this.fetch, `${_this.url}/PutVectors`, options, { headers: _this.headers }) || {};
        });
      }
      /** Retrieves vectors by their keys in batch */
      async getVectors(options) {
        var _this2 = this;
        return _this2.handleOperation(async () => {
          return await vectorsApi.post(_this2.fetch, `${_this2.url}/GetVectors`, options, { headers: _this2.headers });
        });
      }
      /** Lists vectors in an index with pagination */
      async listVectors(options) {
        var _this3 = this;
        if (options.segmentCount !== void 0) {
          if (options.segmentCount < 1 || options.segmentCount > 16) throw new Error("segmentCount must be between 1 and 16");
          if (options.segmentIndex !== void 0) {
            if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);
          }
        }
        return _this3.handleOperation(async () => {
          return await vectorsApi.post(_this3.fetch, `${_this3.url}/ListVectors`, options, { headers: _this3.headers });
        });
      }
      /** Queries for similar vectors using approximate nearest neighbor search */
      async queryVectors(options) {
        var _this4 = this;
        return _this4.handleOperation(async () => {
          return await vectorsApi.post(_this4.fetch, `${_this4.url}/QueryVectors`, options, { headers: _this4.headers });
        });
      }
      /** Deletes vectors by their keys in batch (1-500 per request) */
      async deleteVectors(options) {
        var _this5 = this;
        if (options.keys.length < 1 || options.keys.length > 500) throw new Error("Keys batch size must be between 1 and 500 items");
        return _this5.handleOperation(async () => {
          return await vectorsApi.post(_this5.fetch, `${_this5.url}/DeleteVectors`, options, { headers: _this5.headers }) || {};
        });
      }
    };
    VectorBucketApi = class extends BaseApiClient {
      /** Creates a new VectorBucketApi instance */
      constructor(url, headers = {}, fetch$1) {
        const finalUrl = url.replace(/\/$/, "");
        const finalHeaders = _objectSpread22(_objectSpread22({}, DEFAULT_HEADERS), {}, { "Content-Type": "application/json" }, headers);
        super(finalUrl, finalHeaders, fetch$1, "vectors");
      }
      /** Creates a new vector bucket */
      async createBucket(vectorBucketName) {
        var _this = this;
        return _this.handleOperation(async () => {
          return await vectorsApi.post(_this.fetch, `${_this.url}/CreateVectorBucket`, { vectorBucketName }, { headers: _this.headers }) || {};
        });
      }
      /** Retrieves metadata for a specific vector bucket */
      async getBucket(vectorBucketName) {
        var _this2 = this;
        return _this2.handleOperation(async () => {
          return await vectorsApi.post(_this2.fetch, `${_this2.url}/GetVectorBucket`, { vectorBucketName }, { headers: _this2.headers });
        });
      }
      /** Lists vector buckets with optional filtering and pagination */
      async listBuckets(options = {}) {
        var _this3 = this;
        return _this3.handleOperation(async () => {
          return await vectorsApi.post(_this3.fetch, `${_this3.url}/ListVectorBuckets`, options, { headers: _this3.headers });
        });
      }
      /** Deletes a vector bucket (must be empty first) */
      async deleteBucket(vectorBucketName) {
        var _this4 = this;
        return _this4.handleOperation(async () => {
          return await vectorsApi.post(_this4.fetch, `${_this4.url}/DeleteVectorBucket`, { vectorBucketName }, { headers: _this4.headers }) || {};
        });
      }
    };
    StorageVectorsClient = class extends VectorBucketApi {
      /**
      * @alpha
      *
      * Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param url - Base URL of the Storage Vectors REST API.
      * @param options.headers - Optional headers (for example `Authorization`) applied to every request.
      * @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.
      *
      * @example
      * ```typescript
      * const client = new StorageVectorsClient(url, options)
      * ```
      */
      constructor(url, options = {}) {
        super(url, options.headers || {}, options.fetch);
      }
      /**
      *
      * @alpha
      *
      * Access operations for a specific vector bucket
      * Returns a scoped client for index and vector operations within the bucket
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param vectorBucketName - Name of the vector bucket
      * @returns Bucket-scoped client with index and vector operations
      *
      * @example
      * ```typescript
      * const bucket = supabase.storage.vectors.from('embeddings-prod')
      * ```
      */
      from(vectorBucketName) {
        return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);
      }
      /**
      *
      * @alpha
      *
      * Creates a new vector bucket
      * Vector buckets are containers for vector indexes and their data
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param vectorBucketName - Unique name for the vector bucket
      * @returns Promise with empty response on success or error
      *
      * @example
      * ```typescript
      * const { data, error } = await supabase
      *   .storage
      *   .vectors
      *   .createBucket('embeddings-prod')
      * ```
      */
      async createBucket(vectorBucketName) {
        var _superprop_getCreateBucket = () => super.createBucket, _this = this;
        return _superprop_getCreateBucket().call(_this, vectorBucketName);
      }
      /**
      *
      * @alpha
      *
      * Retrieves metadata for a specific vector bucket
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param vectorBucketName - Name of the vector bucket
      * @returns Promise with bucket metadata or error
      *
      * @example
      * ```typescript
      * const { data, error } = await supabase
      *   .storage
      *   .vectors
      *   .getBucket('embeddings-prod')
      *
      * console.log('Bucket created:', data?.vectorBucket.creationTime)
      * ```
      */
      async getBucket(vectorBucketName) {
        var _superprop_getGetBucket = () => super.getBucket, _this2 = this;
        return _superprop_getGetBucket().call(_this2, vectorBucketName);
      }
      /**
      *
      * @alpha
      *
      * Lists all vector buckets with optional filtering and pagination
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param options - Optional filters (prefix, maxResults, nextToken)
      * @returns Promise with list of buckets or error
      *
      * @example
      * ```typescript
      * const { data, error } = await supabase
      *   .storage
      *   .vectors
      *   .listBuckets({ prefix: 'embeddings-' })
      *
      * data?.vectorBuckets.forEach(bucket => {
      *   console.log(bucket.vectorBucketName)
      * })
      * ```
      */
      async listBuckets(options = {}) {
        var _superprop_getListBuckets = () => super.listBuckets, _this3 = this;
        return _superprop_getListBuckets().call(_this3, options);
      }
      /**
      *
      * @alpha
      *
      * Deletes a vector bucket (bucket must be empty)
      * All indexes must be deleted before deleting the bucket
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param vectorBucketName - Name of the vector bucket to delete
      * @returns Promise with empty response on success or error
      *
      * @example
      * ```typescript
      * const { data, error } = await supabase
      *   .storage
      *   .vectors
      *   .deleteBucket('embeddings-old')
      * ```
      */
      async deleteBucket(vectorBucketName) {
        var _superprop_getDeleteBucket = () => super.deleteBucket, _this4 = this;
        return _superprop_getDeleteBucket().call(_this4, vectorBucketName);
      }
    };
    VectorBucketScope = class extends VectorIndexApi {
      /**
      * @alpha
      *
      * Creates a helper that automatically scopes all index operations to the provided bucket.
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @example
      * ```typescript
      * const bucket = supabase.storage.vectors.from('embeddings-prod')
      * ```
      */
      constructor(url, headers, vectorBucketName, fetch$1) {
        super(url, headers, fetch$1);
        this.vectorBucketName = vectorBucketName;
      }
      /**
      *
      * @alpha
      *
      * Creates a new vector index in this bucket
      * Convenience method that automatically includes the bucket name
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param options - Index configuration (vectorBucketName is automatically set)
      * @returns Promise with empty response on success or error
      *
      * @example
      * ```typescript
      * const bucket = supabase.storage.vectors.from('embeddings-prod')
      * await bucket.createIndex({
      *   indexName: 'documents-openai',
      *   dataType: 'float32',
      *   dimension: 1536,
      *   distanceMetric: 'cosine',
      *   metadataConfiguration: {
      *     nonFilterableMetadataKeys: ['raw_text']
      *   }
      * })
      * ```
      */
      async createIndex(options) {
        var _superprop_getCreateIndex = () => super.createIndex, _this5 = this;
        return _superprop_getCreateIndex().call(_this5, _objectSpread22(_objectSpread22({}, options), {}, { vectorBucketName: _this5.vectorBucketName }));
      }
      /**
      *
      * @alpha
      *
      * Lists indexes in this bucket
      * Convenience method that automatically includes the bucket name
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param options - Listing options (vectorBucketName is automatically set)
      * @returns Promise with response containing indexes array and pagination token or error
      *
      * @example
      * ```typescript
      * const bucket = supabase.storage.vectors.from('embeddings-prod')
      * const { data } = await bucket.listIndexes({ prefix: 'documents-' })
      * ```
      */
      async listIndexes(options = {}) {
        var _superprop_getListIndexes = () => super.listIndexes, _this6 = this;
        return _superprop_getListIndexes().call(_this6, _objectSpread22(_objectSpread22({}, options), {}, { vectorBucketName: _this6.vectorBucketName }));
      }
      /**
      *
      * @alpha
      *
      * Retrieves metadata for a specific index in this bucket
      * Convenience method that automatically includes the bucket name
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param indexName - Name of the index to retrieve
      * @returns Promise with index metadata or error
      *
      * @example
      * ```typescript
      * const bucket = supabase.storage.vectors.from('embeddings-prod')
      * const { data } = await bucket.getIndex('documents-openai')
      * console.log('Dimension:', data?.index.dimension)
      * ```
      */
      async getIndex(indexName) {
        var _superprop_getGetIndex = () => super.getIndex, _this7 = this;
        return _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName);
      }
      /**
      *
      * @alpha
      *
      * Deletes an index from this bucket
      * Convenience method that automatically includes the bucket name
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param indexName - Name of the index to delete
      * @returns Promise with empty response on success or error
      *
      * @example
      * ```typescript
      * const bucket = supabase.storage.vectors.from('embeddings-prod')
      * await bucket.deleteIndex('old-index')
      * ```
      */
      async deleteIndex(indexName) {
        var _superprop_getDeleteIndex = () => super.deleteIndex, _this8 = this;
        return _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName);
      }
      /**
      *
      * @alpha
      *
      * Access operations for a specific index within this bucket
      * Returns a scoped client for vector data operations
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param indexName - Name of the index
      * @returns Index-scoped client with vector data operations
      *
      * @example
      * ```typescript
      * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
      *
      * // Insert vectors
      * await index.putVectors({
      *   vectors: [
      *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }
      *   ]
      * })
      *
      * // Query similar vectors
      * const { data } = await index.queryVectors({
      *   queryVector: { float32: [...] },
      *   topK: 5
      * })
      * ```
      */
      index(indexName) {
        return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);
      }
    };
    VectorIndexScope = class extends VectorDataApi {
      /**
      *
      * @alpha
      *
      * Creates a helper that automatically scopes all vector operations to the provided bucket/index names.
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @example
      * ```typescript
      * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
      * ```
      */
      constructor(url, headers, vectorBucketName, indexName, fetch$1) {
        super(url, headers, fetch$1);
        this.vectorBucketName = vectorBucketName;
        this.indexName = indexName;
      }
      /**
      *
      * @alpha
      *
      * Inserts or updates vectors in this index
      * Convenience method that automatically includes bucket and index names
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param options - Vector insertion options (bucket and index names automatically set)
      * @returns Promise with empty response on success or error
      *
      * @example
      * ```typescript
      * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
      * await index.putVectors({
      *   vectors: [
      *     {
      *       key: 'doc-1',
      *       data: { float32: [0.1, 0.2, ...] },
      *       metadata: { title: 'Introduction', page: 1 }
      *     }
      *   ]
      * })
      * ```
      */
      async putVectors(options) {
        var _superprop_getPutVectors = () => super.putVectors, _this9 = this;
        return _superprop_getPutVectors().call(_this9, _objectSpread22(_objectSpread22({}, options), {}, {
          vectorBucketName: _this9.vectorBucketName,
          indexName: _this9.indexName
        }));
      }
      /**
      *
      * @alpha
      *
      * Retrieves vectors by keys from this index
      * Convenience method that automatically includes bucket and index names
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param options - Vector retrieval options (bucket and index names automatically set)
      * @returns Promise with response containing vectors array or error
      *
      * @example
      * ```typescript
      * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
      * const { data } = await index.getVectors({
      *   keys: ['doc-1', 'doc-2'],
      *   returnMetadata: true
      * })
      * ```
      */
      async getVectors(options) {
        var _superprop_getGetVectors = () => super.getVectors, _this10 = this;
        return _superprop_getGetVectors().call(_this10, _objectSpread22(_objectSpread22({}, options), {}, {
          vectorBucketName: _this10.vectorBucketName,
          indexName: _this10.indexName
        }));
      }
      /**
      *
      * @alpha
      *
      * Lists vectors in this index with pagination
      * Convenience method that automatically includes bucket and index names
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param options - Listing options (bucket and index names automatically set)
      * @returns Promise with response containing vectors array and pagination token or error
      *
      * @example
      * ```typescript
      * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
      * const { data } = await index.listVectors({
      *   maxResults: 500,
      *   returnMetadata: true
      * })
      * ```
      */
      async listVectors(options = {}) {
        var _superprop_getListVectors = () => super.listVectors, _this11 = this;
        return _superprop_getListVectors().call(_this11, _objectSpread22(_objectSpread22({}, options), {}, {
          vectorBucketName: _this11.vectorBucketName,
          indexName: _this11.indexName
        }));
      }
      /**
      *
      * @alpha
      *
      * Queries for similar vectors in this index
      * Convenience method that automatically includes bucket and index names
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param options - Query options (bucket and index names automatically set)
      * @returns Promise with response containing matches array of similar vectors ordered by distance or error
      *
      * @example
      * ```typescript
      * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
      * const { data } = await index.queryVectors({
      *   queryVector: { float32: [0.1, 0.2, ...] },
      *   topK: 5,
      *   filter: { category: 'technical' },
      *   returnDistance: true,
      *   returnMetadata: true
      * })
      * ```
      */
      async queryVectors(options) {
        var _superprop_getQueryVectors = () => super.queryVectors, _this12 = this;
        return _superprop_getQueryVectors().call(_this12, _objectSpread22(_objectSpread22({}, options), {}, {
          vectorBucketName: _this12.vectorBucketName,
          indexName: _this12.indexName
        }));
      }
      /**
      *
      * @alpha
      *
      * Deletes vectors by keys from this index
      * Convenience method that automatically includes bucket and index names
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @param options - Deletion options (bucket and index names automatically set)
      * @returns Promise with empty response on success or error
      *
      * @example
      * ```typescript
      * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
      * await index.deleteVectors({
      *   keys: ['doc-1', 'doc-2', 'doc-3']
      * })
      * ```
      */
      async deleteVectors(options) {
        var _superprop_getDeleteVectors = () => super.deleteVectors, _this13 = this;
        return _superprop_getDeleteVectors().call(_this13, _objectSpread22(_objectSpread22({}, options), {}, {
          vectorBucketName: _this13.vectorBucketName,
          indexName: _this13.indexName
        }));
      }
    };
    StorageClient = class extends StorageBucketApi {
      /**
      * Creates a client for Storage buckets, files, analytics, and vectors.
      *
      * @category File Buckets
      * @example
      * ```ts
      * import { StorageClient } from '@supabase/storage-js'
      *
      * const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {
      *   apikey: 'public-anon-key',
      * })
      * const avatars = storage.from('avatars')
      * ```
      */
      constructor(url, headers = {}, fetch$1, opts) {
        super(url, headers, fetch$1, opts);
      }
      /**
      * Perform file operation in a bucket.
      *
      * @category File Buckets
      * @param id The bucket id to operate on.
      *
      * @example
      * ```typescript
      * const avatars = supabase.storage.from('avatars')
      * ```
      */
      from(id) {
        return new StorageFileApi(this.url, this.headers, id, this.fetch);
      }
      /**
      *
      * @alpha
      *
      * Access vector storage operations.
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Vector Buckets
      * @returns A StorageVectorsClient instance configured with the current storage settings.
      */
      get vectors() {
        return new StorageVectorsClient(this.url + "/vector", {
          headers: this.headers,
          fetch: this.fetch
        });
      }
      /**
      *
      * @alpha
      *
      * Access analytics storage operations using Iceberg tables.
      *
      * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
      *
      * @category Analytics Buckets
      * @returns A StorageAnalyticsClient instance configured with the current storage settings.
      */
      get analytics() {
        return new StorageAnalyticsClient(this.url + "/iceberg", this.headers, this.fetch);
      }
    };
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/version.js
var version3;
var init_version3 = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/version.js"() {
    version3 = "2.95.3";
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/constants.js
var AUTO_REFRESH_TICK_DURATION_MS, AUTO_REFRESH_TICK_THRESHOLD, EXPIRY_MARGIN_MS, GOTRUE_URL, STORAGE_KEY, DEFAULT_HEADERS2, API_VERSION_HEADER_NAME, API_VERSIONS, BASE64URL_REGEX, JWKS_TTL;
var init_constants3 = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/constants.js"() {
    init_version3();
    AUTO_REFRESH_TICK_DURATION_MS = 30 * 1e3;
    AUTO_REFRESH_TICK_THRESHOLD = 3;
    EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;
    GOTRUE_URL = "http://localhost:9999";
    STORAGE_KEY = "supabase.auth.token";
    DEFAULT_HEADERS2 = { "X-Client-Info": `gotrue-js/${version3}` };
    API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
    API_VERSIONS = {
      "2024-01-01": {
        timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
        name: "2024-01-01"
      }
    };
    BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
    JWKS_TTL = 10 * 60 * 1e3;
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/errors.js
function isAuthError(error2) {
  return typeof error2 === "object" && error2 !== null && "__isAuthError" in error2;
}
function isAuthApiError(error2) {
  return isAuthError(error2) && error2.name === "AuthApiError";
}
function isAuthSessionMissingError(error2) {
  return isAuthError(error2) && error2.name === "AuthSessionMissingError";
}
function isAuthImplicitGrantRedirectError(error2) {
  return isAuthError(error2) && error2.name === "AuthImplicitGrantRedirectError";
}
function isAuthRetryableFetchError(error2) {
  return isAuthError(error2) && error2.name === "AuthRetryableFetchError";
}
var AuthError, AuthApiError, AuthUnknownError, CustomAuthError, AuthSessionMissingError, AuthInvalidTokenResponseError, AuthInvalidCredentialsError, AuthImplicitGrantRedirectError, AuthPKCEGrantCodeExchangeError, AuthPKCECodeVerifierMissingError, AuthRetryableFetchError, AuthWeakPasswordError, AuthInvalidJwtError;
var init_errors = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/errors.js"() {
    AuthError = class extends Error {
      constructor(message, status, code) {
        super(message);
        this.__isAuthError = true;
        this.name = "AuthError";
        this.status = status;
        this.code = code;
      }
    };
    AuthApiError = class extends AuthError {
      constructor(message, status, code) {
        super(message, status, code);
        this.name = "AuthApiError";
        this.status = status;
        this.code = code;
      }
    };
    AuthUnknownError = class extends AuthError {
      constructor(message, originalError) {
        super(message);
        this.name = "AuthUnknownError";
        this.originalError = originalError;
      }
    };
    CustomAuthError = class extends AuthError {
      constructor(message, name, status, code) {
        super(message, status, code);
        this.name = name;
        this.status = status;
      }
    };
    AuthSessionMissingError = class extends CustomAuthError {
      constructor() {
        super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
      }
    };
    AuthInvalidTokenResponseError = class extends CustomAuthError {
      constructor() {
        super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
      }
    };
    AuthInvalidCredentialsError = class extends CustomAuthError {
      constructor(message) {
        super(message, "AuthInvalidCredentialsError", 400, void 0);
      }
    };
    AuthImplicitGrantRedirectError = class extends CustomAuthError {
      constructor(message, details = null) {
        super(message, "AuthImplicitGrantRedirectError", 500, void 0);
        this.details = null;
        this.details = details;
      }
      toJSON() {
        return {
          name: this.name,
          message: this.message,
          status: this.status,
          details: this.details
        };
      }
    };
    AuthPKCEGrantCodeExchangeError = class extends CustomAuthError {
      constructor(message, details = null) {
        super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
        this.details = null;
        this.details = details;
      }
      toJSON() {
        return {
          name: this.name,
          message: this.message,
          status: this.status,
          details: this.details
        };
      }
    };
    AuthPKCECodeVerifierMissingError = class extends CustomAuthError {
      constructor() {
        super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.", "AuthPKCECodeVerifierMissingError", 400, "pkce_code_verifier_not_found");
      }
    };
    AuthRetryableFetchError = class extends CustomAuthError {
      constructor(message, status) {
        super(message, "AuthRetryableFetchError", status, void 0);
      }
    };
    AuthWeakPasswordError = class extends CustomAuthError {
      constructor(message, status, reasons) {
        super(message, "AuthWeakPasswordError", status, "weak_password");
        this.reasons = reasons;
      }
    };
    AuthInvalidJwtError = class extends CustomAuthError {
      constructor(message) {
        super(message, "AuthInvalidJwtError", 400, "invalid_jwt");
      }
    };
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/base64url.js
function byteToBase64URL(byte, state, emit) {
  if (byte !== null) {
    state.queue = state.queue << 8 | byte;
    state.queuedBits += 8;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  } else if (state.queuedBits > 0) {
    state.queue = state.queue << 6 - state.queuedBits;
    state.queuedBits = 6;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  }
}
function byteFromBase64URL(charCode, state, emit) {
  const bits = FROM_BASE64URL[charCode];
  if (bits > -1) {
    state.queue = state.queue << 6 | bits;
    state.queuedBits += 6;
    while (state.queuedBits >= 8) {
      emit(state.queue >> state.queuedBits - 8 & 255);
      state.queuedBits -= 8;
    }
  } else if (bits === -2) {
    return;
  } else {
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
  }
}
function stringFromBase64URL(str) {
  const conv = [];
  const utf8Emit = (codepoint) => {
    conv.push(String.fromCodePoint(codepoint));
  };
  const utf8State = {
    utf8seq: 0,
    codepoint: 0
  };
  const b64State = { queue: 0, queuedBits: 0 };
  const byteEmit = (byte) => {
    stringFromUTF8(byte, utf8State, utf8Emit);
  };
  for (let i7 = 0; i7 < str.length; i7 += 1) {
    byteFromBase64URL(str.charCodeAt(i7), b64State, byteEmit);
  }
  return conv.join("");
}
function codepointToUTF8(codepoint, emit) {
  if (codepoint <= 127) {
    emit(codepoint);
    return;
  } else if (codepoint <= 2047) {
    emit(192 | codepoint >> 6);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 65535) {
    emit(224 | codepoint >> 12);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 1114111) {
    emit(240 | codepoint >> 18);
    emit(128 | codepoint >> 12 & 63);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
}
function stringToUTF8(str, emit) {
  for (let i7 = 0; i7 < str.length; i7 += 1) {
    let codepoint = str.charCodeAt(i7);
    if (codepoint > 55295 && codepoint <= 56319) {
      const highSurrogate = (codepoint - 55296) * 1024 & 65535;
      const lowSurrogate = str.charCodeAt(i7 + 1) - 56320 & 65535;
      codepoint = (lowSurrogate | highSurrogate) + 65536;
      i7 += 1;
    }
    codepointToUTF8(codepoint, emit);
  }
}
function stringFromUTF8(byte, state, emit) {
  if (state.utf8seq === 0) {
    if (byte <= 127) {
      emit(byte);
      return;
    }
    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {
      if ((byte >> 7 - leadingBit & 1) === 0) {
        state.utf8seq = leadingBit;
        break;
      }
    }
    if (state.utf8seq === 2) {
      state.codepoint = byte & 31;
    } else if (state.utf8seq === 3) {
      state.codepoint = byte & 15;
    } else if (state.utf8seq === 4) {
      state.codepoint = byte & 7;
    } else {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.utf8seq -= 1;
  } else if (state.utf8seq > 0) {
    if (byte <= 127) {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.codepoint = state.codepoint << 6 | byte & 63;
    state.utf8seq -= 1;
    if (state.utf8seq === 0) {
      emit(state.codepoint);
    }
  }
}
function base64UrlToUint8Array(str) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onByte = (byte) => {
    result.push(byte);
  };
  for (let i7 = 0; i7 < str.length; i7 += 1) {
    byteFromBase64URL(str.charCodeAt(i7), state, onByte);
  }
  return new Uint8Array(result);
}
function stringToUint8Array(str) {
  const result = [];
  stringToUTF8(str, (byte) => result.push(byte));
  return new Uint8Array(result);
}
function bytesToBase64URL(bytes) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onChar = (char) => {
    result.push(char);
  };
  bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));
  byteToBase64URL(null, state, onChar);
  return result.join("");
}
var TO_BASE64URL, IGNORE_BASE64URL, FROM_BASE64URL;
var init_base64url = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/base64url.js"() {
    TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("");
    IGNORE_BASE64URL = " 	\n\r=".split("");
    FROM_BASE64URL = (() => {
      const charMap = new Array(128);
      for (let i7 = 0; i7 < charMap.length; i7 += 1) {
        charMap[i7] = -1;
      }
      for (let i7 = 0; i7 < IGNORE_BASE64URL.length; i7 += 1) {
        charMap[IGNORE_BASE64URL[i7].charCodeAt(0)] = -2;
      }
      for (let i7 = 0; i7 < TO_BASE64URL.length; i7 += 1) {
        charMap[TO_BASE64URL[i7].charCodeAt(0)] = i7;
      }
      return charMap;
    })();
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/helpers.js
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function generateCallbackId() {
  return Symbol("auth-callback");
}
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e3) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
function decodeJWT(token) {
  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new AuthInvalidJwtError("Invalid JWT structure");
  }
  for (let i7 = 0; i7 < parts.length; i7++) {
    if (!BASE64URL_REGEX.test(parts[i7])) {
      throw new AuthInvalidJwtError("JWT not in base64url format");
    }
  }
  const data = {
    // using base64url lib
    header: JSON.parse(stringFromBase64URL(parts[0])),
    payload: JSON.parse(stringFromBase64URL(parts[1])),
    signature: base64UrlToUint8Array(parts[2]),
    raw: {
      header: parts[0],
      payload: parts[1]
    }
  };
  return data;
}
async function sleep(time) {
  return await new Promise((accept) => {
    setTimeout(() => accept(null), time);
  });
}
function retryable(fn4, isRetryable) {
  const promise = new Promise((accept, reject) => {
    ;
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn4(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e3) {
          if (!isRetryable(attempt, e3)) {
            reject(e3);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i7 = 0; i7 < verifierLength; i7++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join("");
}
async function sha256(randomString) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString);
  const hash = await crypto.subtle.digest("SHA-256", encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map((c7) => String.fromCharCode(c7)).join("");
}
async function generatePKCEChallenge(verifier) {
  const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
  if (!hasCryptoSupport) {
    console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
    return verifier;
  }
  const hashed = await sha256(verifier);
  return btoa(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  const codeVerifier = generatePKCEVerifier();
  let storedCodeVerifier = codeVerifier;
  if (isPasswordRecovery) {
    storedCodeVerifier += "/PASSWORD_RECOVERY";
  }
  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
  const codeChallenge = await generatePKCEChallenge(codeVerifier);
  const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
  return [codeChallenge, codeChallengeMethod];
}
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date = /* @__PURE__ */ new Date(`${apiVersion}T00:00:00.0Z`);
    return date;
  } catch (e3) {
    return null;
  }
}
function validateExp(exp) {
  if (!exp) {
    throw new Error("Missing exp claim");
  }
  const timeNow = Math.floor(Date.now() / 1e3);
  if (exp <= timeNow) {
    throw new Error("JWT has expired");
  }
}
function getAlgorithm(alg) {
  switch (alg) {
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      };
    case "ES256":
      return {
        name: "ECDSA",
        namedCurve: "P-256",
        hash: { name: "SHA-256" }
      };
    default:
      throw new Error("Invalid alg claim");
  }
}
function validateUUID(str) {
  if (!UUID_REGEX.test(str)) {
    throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not");
  }
}
function userNotAvailableProxy() {
  const proxyTarget = {};
  return new Proxy(proxyTarget, {
    get: (target, prop) => {
      if (prop === "__isUserNotAvailableProxy") {
        return true;
      }
      if (typeof prop === "symbol") {
        const sProp = prop.toString();
        if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)") {
          return void 0;
        }
      }
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`);
    },
    set: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    },
    deleteProperty: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    }
  });
}
function insecureUserWarningProxy(user, suppressWarningRef) {
  return new Proxy(user, {
    get: (target, prop, receiver) => {
      if (prop === "__isInsecureUserWarningProxy") {
        return true;
      }
      if (typeof prop === "symbol") {
        const sProp = prop.toString();
        if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)" || sProp === "Symbol(nodejs.util.inspect.custom)") {
          return Reflect.get(target, prop, receiver);
        }
      }
      if (!suppressWarningRef.value && typeof prop === "string") {
        console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
        suppressWarningRef.value = true;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var isBrowser, localStorageWriteTests, supportsLocalStorage, resolveFetch3, looksLikeFetchResponse, setItemAsync, getItemAsync, removeItemAsync, Deferred, API_VERSION_REGEX, UUID_REGEX;
var init_helpers = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/helpers.js"() {
    init_constants3();
    init_errors();
    init_base64url();
    isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
    localStorageWriteTests = {
      tested: false,
      writable: false
    };
    supportsLocalStorage = () => {
      if (!isBrowser()) {
        return false;
      }
      try {
        if (typeof globalThis.localStorage !== "object") {
          return false;
        }
      } catch (e3) {
        return false;
      }
      if (localStorageWriteTests.tested) {
        return localStorageWriteTests.writable;
      }
      const randomKey = `lswt-${Math.random()}${Math.random()}`;
      try {
        globalThis.localStorage.setItem(randomKey, randomKey);
        globalThis.localStorage.removeItem(randomKey);
        localStorageWriteTests.tested = true;
        localStorageWriteTests.writable = true;
      } catch (e3) {
        localStorageWriteTests.tested = true;
        localStorageWriteTests.writable = false;
      }
      return localStorageWriteTests.writable;
    };
    resolveFetch3 = (customFetch) => {
      if (customFetch) {
        return (...args) => customFetch(...args);
      }
      return (...args) => fetch(...args);
    };
    looksLikeFetchResponse = (maybeResponse) => {
      return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
    };
    setItemAsync = async (storage, key, data) => {
      await storage.setItem(key, JSON.stringify(data));
    };
    getItemAsync = async (storage, key) => {
      const value = await storage.getItem(key);
      if (!value) {
        return null;
      }
      try {
        return JSON.parse(value);
      } catch (_a) {
        return value;
      }
    };
    removeItemAsync = async (storage, key) => {
      await storage.removeItem(key);
    };
    Deferred = class _Deferred {
      constructor() {
        ;
        this.promise = new _Deferred.promiseConstructor((res, rej) => {
          ;
          this.resolve = res;
          this.reject = rej;
        });
      }
    };
    Deferred.promiseConstructor = Promise;
    API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
    UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/fetch.js
async function handleError2(error2) {
  var _a;
  if (!looksLikeFetchResponse(error2)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error2), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error2.status)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error2), error2.status);
  }
  let data;
  try {
    data = await error2.json();
  } catch (e3) {
    throw new AuthUnknownError(_getErrorMessage2(e3), e3);
  }
  let errorCode = void 0;
  const responseAPIVersion = parseResponseAPIVersion(error2);
  if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
    errorCode = data.code;
  } else if (typeof data === "object" && data && typeof data.error_code === "string") {
    errorCode = data.error_code;
  }
  if (!errorCode) {
    if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a5, i7) => a5 && typeof i7 === "string", true)) {
      throw new AuthWeakPasswordError(_getErrorMessage2(data), error2.status, data.weak_password.reasons);
    }
  } else if (errorCode === "weak_password") {
    throw new AuthWeakPasswordError(_getErrorMessage2(data), error2.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);
  } else if (errorCode === "session_not_found") {
    throw new AuthSessionMissingError();
  }
  throw new AuthApiError(_getErrorMessage2(data), error2.status || 500, errorCode);
}
async function _request(fetcher, method, url, options) {
  var _a;
  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (!headers[API_VERSION_HEADER_NAME]) {
    headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
  }
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers["Authorization"] = `Bearer ${options.jwt}`;
  }
  const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs["redirect_to"] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
  const data = await _handleRequest2(fetcher, method, url + queryString, {
    headers,
    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
  }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
}
async function _handleRequest2(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams2(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, Object.assign({}, requestParams));
  } catch (e3) {
    console.error(e3);
    throw new AuthRetryableFetchError(_getErrorMessage2(e3), 0);
  }
  if (!result.ok) {
    await handleError2(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e3) {
    await handleError2(e3);
  }
}
function _sessionResponse(data) {
  var _a;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = expiresAt(data.expires_in);
    }
  }
  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return { data: { session, user }, error: null };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a5, i7) => a5 && typeof i7 === "string", true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a;
  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}
var _getErrorMessage2, NETWORK_ERROR_CODES, _getRequestParams2;
var init_fetch = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/fetch.js"() {
    init_tslib_es6();
    init_constants3();
    init_helpers();
    init_errors();
    _getErrorMessage2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
    NETWORK_ERROR_CODES = [502, 503, 504];
    _getRequestParams2 = (method, options, parameters, body) => {
      const params2 = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
      if (method === "GET") {
        return params2;
      }
      params2.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
      params2.body = JSON.stringify(body);
      return Object.assign(Object.assign({}, params2), parameters);
    };
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/types.js
var SIGN_OUT_SCOPES;
var init_types2 = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/types.js"() {
    SIGN_OUT_SCOPES = ["global", "local", "others"];
  }
});

// node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js
var GoTrueAdminApi;
var init_GoTrueAdminApi = __esm({
  "node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js"() {
    init_tslib_es6();
    init_fetch();
    init_helpers();
    init_types2();
    init_errors();
    GoTrueAdminApi = class {
      /**
       * Creates an admin API client that can be used to manage users and OAuth clients.
       *
       * @example
       * ```ts
       * import { GoTrueAdminApi } from '@supabase/auth-js'
       *
       * const admin = new GoTrueAdminApi({
       *   url: 'https://xyzcompany.supabase.co/auth/v1',
       *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },
       * })
       * ```
       */
      constructor({ url = "", headers = {}, fetch: fetch2 }) {
        this.url = url;
        this.headers = headers;
        this.fetch = resolveFetch3(fetch2);
        this.mfa = {
          listFactors: this._listFactors.bind(this),
          deleteFactor: this._deleteFactor.bind(this)
        };
        this.oauth = {
          listClients: this._listOAuthClients.bind(this),
          createClient: this._createOAuthClient.bind(this),
          getClient: this._getOAuthClient.bind(this),
          updateClient: this._updateOAuthClient.bind(this),
          deleteClient: this._deleteOAuthClient.bind(this),
          regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
        };
      }
      /**
       * Removes a logged-in session.
       * @param jwt A valid, logged-in JWT.
       * @param scope The logout sope.
       */
      async signOut(jwt, scope = SIGN_OUT_SCOPES[0]) {
        if (SIGN_OUT_SCOPES.indexOf(scope) < 0) {
          throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES.join(", ")}`);
        }
        try {
          await _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
            headers: this.headers,
            jwt,
            noResolveJson: true
          });
          return { data: null, error: null };
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Sends an invite link to an email address.
       * @param email The email address of the user.
       * @param options Additional options to be included when inviting.
       */
      async inviteUserByEmail(email, options = {}) {
        try {
          return await _request(this.fetch, "POST", `${this.url}/invite`, {
            body: { email, data: options.data },
            headers: this.headers,
            redirectTo: options.redirectTo,
            xform: _userResponse
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: { user: null }, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Generates email links and OTPs to be sent via a custom email provider.
       * @param email The user's email.
       * @param options.password User password. For signup only.
       * @param options.data Optional user metadata. For signup only.
       * @param options.redirectTo The redirect url which should be appended to the generated link
       */
      async generateLink(params2) {
        try {
          const { options } = params2, rest = __rest(params2, ["options"]);
          const body = Object.assign(Object.assign({}, rest), options);
          if ("newEmail" in rest) {
            body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
            delete body["newEmail"];
          }
          return await _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
            body,
            headers: this.headers,
            xform: _generateLinkResponse,
            redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return {
              data: {
                properties: null,
                user: null
              },
              error: error2
            };
          }
          throw error2;
        }
      }
      // User Admin API
      /**
       * Creates a new user.
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async createUser(attributes) {
        try {
          return await _request(this.fetch, "POST", `${this.url}/admin/users`, {
            body: attributes,
            headers: this.headers,
            xform: _userResponse
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: { user: null }, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Get a list of users.
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
       */
      async listUsers(params2) {
        var _a, _b, _c, _d, _e3, _f, _g;
        try {
          const pagination = { nextPage: null, lastPage: 0, total: 0 };
          const response = await _request(this.fetch, "GET", `${this.url}/admin/users`, {
            headers: this.headers,
            noResolveJson: true,
            query: {
              page: (_b = (_a = params2 === null || params2 === void 0 ? void 0 : params2.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "",
              per_page: (_d = (_c = params2 === null || params2 === void 0 ? void 0 : params2.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
            },
            xform: _noResolveJsonResponse
          });
          if (response.error)
            throw response.error;
          const users = await response.json();
          const total = (_e3 = response.headers.get("x-total-count")) !== null && _e3 !== void 0 ? _e3 : 0;
          const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
          if (links.length > 0) {
            links.forEach((link) => {
              const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
              const rel = JSON.parse(link.split(";")[1].split("=")[1]);
              pagination[`${rel}Page`] = page;
            });
            pagination.total = parseInt(total);
          }
          return { data: Object.assign(Object.assign({}, users), pagination), error: null };
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: { users: [] }, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Get user by id.
       *
       * @param uid The user's unique identifier
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async getUserById(uid) {
        validateUUID(uid);
        try {
          return await _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
            headers: this.headers,
            xform: _userResponse
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: { user: null }, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Updates the user data. Changes are applied directly without confirmation flows.
       *
       * @param attributes The data you want to update.
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async updateUserById(uid, attributes) {
        validateUUID(uid);
        try {
          return await _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
            body: attributes,
            headers: this.headers,
            xform: _userResponse
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: { user: null }, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Delete a user. Requires a `service_role` key.
       *
       * @param id The user id you want to remove.
       * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
       * Defaults to false for backward compatibility.
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async deleteUser(id, shouldSoftDelete = false) {
        validateUUID(id);
        try {
          return await _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
            headers: this.headers,
            body: {
              should_soft_delete: shouldSoftDelete
            },
            xform: _userResponse
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: { user: null }, error: error2 };
          }
          throw error2;
        }
      }
      async _listFactors(params2) {
        validateUUID(params2.userId);
        try {
          const { data, error: error2 } = await _request(this.fetch, "GET", `${this.url}/admin/users/${params2.userId}/factors`, {
            headers: this.headers,
            xform: (factors) => {
              return { data: { factors }, error: null };
            }
          });
          return { data, error: error2 };
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }
      async _deleteFactor(params2) {
        validateUUID(params2.userId);
        validateUUID(params2.id);
        try {
          const data = await _request(this.fetch, "DELETE", `${this.url}/admin/users/${params2.userId}/factors/${params2.id}`, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Lists all OAuth clients with optional pagination.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async _listOAuthClients(params2) {
        var _a, _b, _c, _d, _e3, _f, _g;
        try {
          const pagination = { nextPage: null, lastPage: 0, total: 0 };
          const response = await _request(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
            headers: this.headers,
            noResolveJson: true,
            query: {
              page: (_b = (_a = params2 === null || params2 === void 0 ? void 0 : params2.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "",
              per_page: (_d = (_c = params2 === null || params2 === void 0 ? void 0 : params2.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
            },
            xform: _noResolveJsonResponse
          });
          if (response.error)
            throw response.error;
          const clients = await response.json();
          const total = (_e3 = response.headers.get("x-total-count")) !== null && _e3 !== void 0 ? _e3 : 0;
          const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
          if (links.length > 0) {
            links.forEach((link) => {
              const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
              const rel = JSON.parse(link.split(";")[1].split("=")[1]);
              pagination[`${rel}Page`] = page;
            });
            pagination.total = parseInt(total);
          }
          return { data: Object.assign(Object.assign({}, clients), pagination), error: null };
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: { clients: [] }, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Creates a new OAuth client.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async _createOAuthClient(params2) {
        try {
          return await _request(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
            body: params2,
            headers: this.headers,
            xform: (client) => {
              return { data: client, error: null };
            }
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Gets details of a specific OAuth client.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async _getOAuthClient(clientId) {
        try {
          return await _request(this.fetch, "GET", `${this.url}/admin/oauth/clients/${clientId}`, {
            headers: this.headers,
            xform: (client) => {
              return { data: client, error: null };
            }
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Updates an existing OAuth client.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async _updateOAuthClient(clientId, params2) {
        try {
          return await _request(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${clientId}`, {
            body: params2,
            headers: this.headers,
            xform: (client) => {
              return { data: client, error: null };
            }
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Deletes an OAuth client.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async _deleteOAuthClient(clientId) {
        try {
          await _request(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${clientId}`, {
            headers: this.headers,
            noResolveJson: true
          });
          return { data: null, error: null };
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }
      /**
       * Regenerates the secret for an OAuth client.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       *
       * This function should only be called on a server. Never expose your `service_role` key in the browser.
       */
      async _regenerateOAuthClientSecret(clientId) {
        try {
          return await _request(this.fetch, "POST", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {
            headers: this.headers,
            xform: (client) => {
              return { data: client, error: null };
            }
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }
    };
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/local-storage.js
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: (key) => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
}
var init_local_storage = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/local-storage.js"() {
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/locks.js
async function navigatorLock(name, acquireTimeout, fn4) {
  if (internals.debug) {
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
  }
  const abortController = new globalThis.AbortController();
  if (acquireTimeout > 0) {
    setTimeout(() => {
      abortController.abort();
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
      }
    }, acquireTimeout);
  }
  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
    mode: "exclusive",
    ifAvailable: true
  } : {
    mode: "exclusive",
    signal: abortController.signal
  }, async (lock) => {
    if (lock) {
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
      }
      try {
        return await fn4();
      } finally {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
        }
      }
    } else {
      if (acquireTimeout === 0) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
        }
        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
      } else {
        if (internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
          } catch (e3) {
            console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e3);
          }
        }
        console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
        return await fn4();
      }
    }
  }));
}
var internals, LockAcquireTimeoutError, NavigatorLockAcquireTimeoutError;
var init_locks = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/locks.js"() {
    init_helpers();
    internals = {
      /**
       * @experimental
       */
      debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
    };
    LockAcquireTimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.isAcquireTimeout = true;
      }
    };
    NavigatorLockAcquireTimeoutError = class extends LockAcquireTimeoutError {
    };
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/polyfills.js
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e3) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}
var init_polyfills = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/polyfills.js"() {
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js
function getAddress(address) {
  if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
    throw new Error(`@supabase/auth-js: Address "${address}" is invalid.`);
  }
  return address.toLowerCase();
}
function fromHex(hex) {
  return parseInt(hex, 16);
}
function toHex(value) {
  const bytes = new TextEncoder().encode(value);
  const hex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
  return "0x" + hex;
}
function createSiweMessage(parameters) {
  var _a;
  const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version5 } = parameters;
  {
    if (!Number.isInteger(chainId))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);
    if (!domain)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.`);
    if (nonce && nonce.length < 8)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${nonce}`);
    if (!uri)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.`);
    if (version5 !== "1")
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${version5}`);
    if ((_a = parameters.statement) === null || _a === void 0 ? void 0 : _a.includes("\n"))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${parameters.statement}`);
  }
  const address = getAddress(parameters.address);
  const origin = scheme ? `${scheme}://${domain}` : domain;
  const statement = parameters.statement ? `${parameters.statement}
` : "";
  const prefix = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version5}
Chain ID: ${chainId}${nonce ? `
Nonce: ${nonce}` : ""}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!resource || typeof resource !== "string")
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${resource}`);
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix}
${suffix}`;
}
var init_ethereum = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js"() {
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js
function identifyRegistrationError({ error: error2, options }) {
  var _a, _b, _c;
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error2.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error2
      });
    }
  } else if (error2.name === "ConstraintError") {
    if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {
      return new WebAuthnError({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: error2
      });
    } else if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === "required"
    ) {
      return new WebAuthnError({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: error2
      });
    } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === "required") {
      return new WebAuthnError({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: error2
      });
    }
  } else if (error2.name === "InvalidStateError") {
    return new WebAuthnError({
      message: "The authenticator was previously registered",
      code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
      cause: error2
    });
  } else if (error2.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error2.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error2
    });
  } else if (error2.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: error2
      });
    }
    return new WebAuthnError({
      message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
      code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
      cause: error2
    });
  } else if (error2.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error2
      });
    } else if (publicKey.rp.id !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error2
      });
    }
  } else if (error2.name === "TypeError") {
    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
      return new WebAuthnError({
        message: "User ID was not between 1 and 64 characters",
        code: "ERROR_INVALID_USER_ID_LENGTH",
        cause: error2
      });
    }
  } else if (error2.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new credential",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error2
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error2
  });
}
function identifyAuthenticationError({ error: error2, options }) {
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error2.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error2
      });
    }
  } else if (error2.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error2.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error2
    });
  } else if (error2.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error2
      });
    } else if (publicKey.rpId !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error2
      });
    }
  } else if (error2.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error2
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error2
  });
}
var WebAuthnError, WebAuthnUnknownError;
var init_webauthn_errors = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js"() {
    init_webauthn();
    WebAuthnError = class extends Error {
      constructor({ message, code, cause, name }) {
        var _a;
        super(message, { cause });
        this.__isWebAuthnError = true;
        this.name = (_a = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : void 0) !== null && _a !== void 0 ? _a : "Unknown Error";
        this.code = code;
      }
    };
    WebAuthnUnknownError = class extends WebAuthnError {
      constructor(message, originalError) {
        super({
          code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
          cause: originalError,
          message
        });
        this.name = "WebAuthnUnknownError";
        this.originalError = originalError;
      }
    };
  }
});

// node_modules/@supabase/auth-js/dist/module/lib/webauthn.js
function deserializeCredentialCreationOptions(options) {
  if (!options) {
    throw new Error("Credential creation options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === "function") {
    return PublicKeyCredential.parseCreationOptionsFromJSON(
      /** we assert the options here as typescript still doesn't know about future webauthn types */
      options
    );
  }
  const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "user", "excludeCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const user = Object.assign(Object.assign({}, userOpts), { id: base64UrlToUint8Array(userOpts.id).buffer });
  const result = Object.assign(Object.assign({}, restOptions), {
    challenge,
    user
  });
  if (excludeCredentials && excludeCredentials.length > 0) {
    result.excludeCredentials = new Array(excludeCredentials.length);
    for (let i7 = 0; i7 < excludeCredentials.length; i7++) {
      const cred = excludeCredentials[i7];
      result.excludeCredentials[i7] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function deserializeCredentialRequestOptions(options) {
  if (!options) {
    throw new Error("Credential request options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === "function") {
    return PublicKeyCredential.parseRequestOptionsFromJSON(options);
  }
  const { challenge: challengeStr, allowCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "allowCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const result = Object.assign(Object.assign({}, restOptions), { challenge });
  if (allowCredentials && allowCredentials.length > 0) {
    result.allowCredentials = new Array(allowCredentials.length);
    for (let i7 = 0; i7 < allowCredentials.length; i7++) {
      const cred = allowCredentials[i7];
      result.allowCredentials[i7] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function serializeCredentialCreationResponse(credential) {
  var _a;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  return {
    id: credential.id,
    rawId: credential.id,
    response: {
      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))
    },
    type: "public-key",
    clientExtensionResults: credential.getClientExtensionResults(),
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : void 0
  };
}
function serializeCredentialRequestResponse(credential) {
  var _a;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  const clientExtensionResults = credential.getClientExtensionResults();
  const assertionResponse = credential.response;
  return {
    id: credential.id,
    rawId: credential.id,
    // W3C spec expects rawId to match id for JSON format
    response: {
      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),
      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),
      userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : void 0
    },
    type: "public-key",
    clientExtensionResults,
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : void 0
  };
}
function isValidDomain(hostname) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
  );
}
function browserSupportsWebAuthn() {
  var _a, _b;
  return !!(isBrowser() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === "function" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === "function");
}
async function createCredential(options) {
  try {
    const response = await navigator.credentials.create(
      /** we assert the type here until typescript types are updated */
      options
    );
    if (!response) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Empty credential response", response)
      };
    }
    if (!(response instanceof PublicKeyCredential)) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
      };
    }
    return { data: response, error: null };
  } catch (err) {
    return {
      data: null,
      error: identifyRegistrationError({
        error: err,
        options
      })
    };
  }
}
async function getCredential(options) {
  try {
    const response = await navigator.credentials.get(
      /** we assert the type here until typescript types are updated */
      options
    );
    if (!response) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Empty credential response", response)
      };
    }
    if (!(response instanceof PublicKeyCredential)) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
      };
    }
    return { data: response, error: null };
  } catch (err) {
    return {
      data: null,
      error: identifyAuthenticationError({
        error: err,
        options
      })
    };
  }
}
function deepMerge(...sources) {
  const isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);
  const result = {};
  for (const source of sources) {
    if (!source)
      continue;
    for (const key in source) {
      const value = source[key];
      if (value === void 0)
        continue;
      if (Array.isArray(value)) {
        result[key] = value;
      } else if (isArrayBufferLike(value)) {
        result[key] = value;
      } else if (isObject(value)) {
        const existing = result[key];
        if (isObject(existing)) {
          result[key] = deepMerge(existing, value);
        } else {
          result[key] = deepMerge(value);
        }
      } else {
        result[key] = value;
      }
    }
  }
  return result;
}
function mergeCredentialCreationOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});
}
function mergeCredentialRequestOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});
}
var WebAuthnAbortService, webAuthnAbortService, DEFAULT_CREATION_OPTIONS, DEFAULT_REQUEST_OPTIONS, WebAuthnApi;
var init_webauthn = __esm({
  "node_modules/@supabase/auth-js/dist/module/lib/webauthn.js"() {
    init_tslib_es6();
    init_base64url();
    init_errors();
    init_helpers();
    init_webauthn_errors();
    WebAuthnAbortService = class {
      /**
       * Create an abort signal for a new WebAuthn operation.
       * Automatically cancels any existing operation.
       *
       * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}
       */
      createNewAbortSignal() {
        if (this.controller) {
          const abortError = new Error("Cancelling existing WebAuthn API call for new one");
          abortError.name = "AbortError";
          this.controller.abort(abortError);
        }
        const newController = new AbortController();
        this.controller = newController;
        return newController.signal;
      }
      /**
       * Manually cancel the current WebAuthn operation.
       * Useful for cleaning up when user cancels or navigates away.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}
       */
      cancelCeremony() {
        if (this.controller) {
          const abortError = new Error("Manually cancelling existing WebAuthn API call");
          abortError.name = "AbortError";
          this.controller.abort(abortError);
          this.controller = void 0;
        }
      }
    };
    webAuthnAbortService = new WebAuthnAbortService();
    DEFAULT_CREATION_OPTIONS = {
      hints: ["security-key"],
      authenticatorSelection: {
        authenticatorAttachment: "cross-platform",
        requireResidentKey: false,
        /** set to preferred because older yubikeys don't have PIN/Biometric */
        userVerification: "preferred",
        residentKey: "discouraged"
      },
      attestation: "direct"
    };
    DEFAULT_REQUEST_OPTIONS = {
      /** set to preferred because older yubikeys don't have PIN/Biometric */
      userVerification: "preferred",
      hints: ["security-key"],
      attestation: "direct"
    };
    WebAuthnApi = class {
      constructor(client) {
        this.client = client;
        this.enroll = this._enroll.bind(this);
        this.challenge = this._challenge.bind(this);
        this.verify = this._verify.bind(this);
        this.authenticate = this._authenticate.bind(this);
        this.register = this._register.bind(this);
      }
      /**
       * Enroll a new WebAuthn factor.
       * Creates an unverified WebAuthn factor that must be verified with a credential.
       *
       * @experimental This method is experimental and may change in future releases
       * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)
       * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error
       * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}
       */
      async _enroll(params2) {
        return this.client.mfa.enroll(Object.assign(Object.assign({}, params2), { factorType: "webauthn" }));
      }
      /**
       * Challenge for WebAuthn credential creation or authentication.
       * Combines server challenge with browser credential operations.
       * Handles both registration (create) and authentication (request) flows.
       *
       * @experimental This method is experimental and may change in future releases
       * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId
       * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials
       * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation
       * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request
       * @returns {Promise<RequestResult>} Challenge response with credential or error
       * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}
       * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}
       */
      async _challenge({ factorId, webauthn, friendlyName, signal }, overrides) {
        var _a;
        try {
          const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({
            factorId,
            webauthn
          });
          if (!challengeResponse) {
            return { data: null, error: challengeError };
          }
          const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();
          if (challengeResponse.webauthn.type === "create") {
            const { user } = challengeResponse.webauthn.credential_options.publicKey;
            if (!user.name) {
              const nameToUse = friendlyName;
              if (!nameToUse) {
                const currentUser = await this.client.getUser();
                const userData = currentUser.data.user;
                const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || "User";
                user.name = `${user.id}:${fallbackName}`;
              } else {
                user.name = `${user.id}:${nameToUse}`;
              }
            }
            if (!user.displayName) {
              user.displayName = user.name;
            }
          }
          switch (challengeResponse.webauthn.type) {
            case "create": {
              const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);
              const { data, error: error2 } = await createCredential({
                publicKey: options,
                signal: abortSignal
              });
              if (data) {
                return {
                  data: {
                    factorId,
                    challengeId: challengeResponse.id,
                    webauthn: {
                      type: challengeResponse.webauthn.type,
                      credential_response: data
                    }
                  },
                  error: null
                };
              }
              return { data: null, error: error2 };
            }
            case "request": {
              const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);
              const { data, error: error2 } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));
              if (data) {
                return {
                  data: {
                    factorId,
                    challengeId: challengeResponse.id,
                    webauthn: {
                      type: challengeResponse.webauthn.type,
                      credential_response: data
                    }
                  },
                  error: null
                };
              }
              return { data: null, error: error2 };
            }
          }
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          return {
            data: null,
            error: new AuthUnknownError("Unexpected error in challenge", error2)
          };
        }
      }
      /**
       * Verify a WebAuthn credential with the server.
       * Completes the WebAuthn ceremony by sending the credential to the server for verification.
       *
       * @experimental This method is experimental and may change in future releases
       * @param {Object} params - Verification parameters
       * @param {string} params.challengeId - ID of the challenge being verified
       * @param {string} params.factorId - ID of the WebAuthn factor
       * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response
       * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error
       * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}
       * */
      async _verify({ challengeId, factorId, webauthn }) {
        return this.client.mfa.verify({
          factorId,
          challengeId,
          webauthn
        });
      }
      /**
       * Complete WebAuthn authentication flow.
       * Performs challenge and verification in a single operation for existing credentials.
       *
       * @experimental This method is experimental and may change in future releases
       * @param {Object} params - Authentication parameters
       * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with
       * @param {Object} params.webauthn - WebAuthn configuration
       * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)
       * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)
       * @param {AbortSignal} params.webauthn.signal - Optional abort signal
       * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get
       * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result
       * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}
       */
      async _authenticate({ factorId, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } = {} }, overrides) {
        if (!rpId) {
          return {
            data: null,
            error: new AuthError("rpId is required for WebAuthn authentication")
          };
        }
        try {
          if (!browserSupportsWebAuthn()) {
            return {
              data: null,
              error: new AuthUnknownError("Browser does not support WebAuthn", null)
            };
          }
          const { data: challengeResponse, error: challengeError } = await this.challenge({
            factorId,
            webauthn: { rpId, rpOrigins },
            signal
          }, { request: overrides });
          if (!challengeResponse) {
            return { data: null, error: challengeError };
          }
          const { webauthn } = challengeResponse;
          return this._verify({
            factorId,
            challengeId: challengeResponse.challengeId,
            webauthn: {
              type: webauthn.type,
              rpId,
              rpOrigins,
              credential_response: webauthn.credential_response
            }
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          return {
            data: null,
            error: new AuthUnknownError("Unexpected error in authenticate", error2)
          };
        }
      }
      /**
       * Complete WebAuthn registration flow.
       * Performs enrollment, challenge, and verification in a single operation for new credentials.
       *
       * @experimental This method is experimental and may change in future releases
       * @param {Object} params - Registration parameters
       * @param {string} params.friendlyName - User-friendly name for the credential
       * @param {string} params.rpId - Relying Party ID (defaults to current hostname)
       * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)
       * @param {AbortSignal} params.signal - Optional abort signal
       * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create
       * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result
       * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}
       */
      async _register({ friendlyName, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } = {} }, overrides) {
        if (!rpId) {
          return {
            data: null,
            error: new AuthError("rpId is required for WebAuthn registration")
          };
        }
        try {
          if (!browserSupportsWebAuthn()) {
            return {
              data: null,
              error: new AuthUnknownError("Browser does not support WebAuthn", null)
            };
          }
          const { data: factor, error: enrollError } = await this._enroll({
            friendlyName
          });
          if (!factor) {
            await this.client.mfa.listFactors().then((factors) => {
              var _a;
              return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v5) => v5.factor_type === "webauthn" && v5.friendly_name === friendlyName && v5.status !== "unverified");
            }).then((factor2) => factor2 ? this.client.mfa.unenroll({ factorId: factor2 === null || factor2 === void 0 ? void 0 : factor2.id }) : void 0);
            return { data: null, error: enrollError };
          }
          const { data: challengeResponse, error: challengeError } = await this._challenge({
            factorId: factor.id,
            friendlyName: factor.friendly_name,
            webauthn: { rpId, rpOrigins },
            signal
          }, {
            create: overrides
          });
          if (!challengeResponse) {
            return { data: null, error: challengeError };
          }
          return this._verify({
            factorId: factor.id,
            challengeId: challengeResponse.challengeId,
            webauthn: {
              rpId,
              rpOrigins,
              type: challengeResponse.webauthn.type,
              credential_response: challengeResponse.webauthn.credential_response
            }
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          return {
            data: null,
            error: new AuthUnknownError("Unexpected error in register", error2)
          };
        }
      }
    };
  }
});

// node_modules/@supabase/auth-js/dist/module/GoTrueClient.js
async function lockNoOp(name, acquireTimeout, fn4) {
  return await fn4();
}
var DEFAULT_OPTIONS, GLOBAL_JWKS, GoTrueClient, GoTrueClient_default;
var init_GoTrueClient = __esm({
  "node_modules/@supabase/auth-js/dist/module/GoTrueClient.js"() {
    init_GoTrueAdminApi();
    init_constants3();
    init_errors();
    init_fetch();
    init_helpers();
    init_local_storage();
    init_locks();
    init_polyfills();
    init_version3();
    init_base64url();
    init_ethereum();
    init_webauthn();
    polyfillGlobalThis();
    DEFAULT_OPTIONS = {
      url: GOTRUE_URL,
      storageKey: STORAGE_KEY,
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      headers: DEFAULT_HEADERS2,
      flowType: "implicit",
      debug: false,
      hasCustomAuthorizationHeader: false,
      throwOnError: false,
      lockAcquireTimeout: 1e4
      // 10 seconds
    };
    GLOBAL_JWKS = {};
    GoTrueClient = class _GoTrueClient {
      /**
       * The JWKS used for verifying asymmetric JWTs
       */
      get jwks() {
        var _a, _b;
        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : { keys: [] };
      }
      set jwks(value) {
        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { jwks: value });
      }
      get jwks_cached_at() {
        var _a, _b;
        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
      }
      set jwks_cached_at(value) {
        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { cachedAt: value });
      }
      /**
       * Create a new client for use in the browser.
       *
       * @example
       * ```ts
       * import { GoTrueClient } from '@supabase/auth-js'
       *
       * const auth = new GoTrueClient({
       *   url: 'https://xyzcompany.supabase.co/auth/v1',
       *   headers: { apikey: 'public-anon-key' },
       *   storageKey: 'supabase-auth',
       * })
       * ```
       */
      constructor(options) {
        var _a, _b, _c;
        this.userStorage = null;
        this.memoryStorage = null;
        this.stateChangeEmitters = /* @__PURE__ */ new Map();
        this.autoRefreshTicker = null;
        this.autoRefreshTickTimeout = null;
        this.visibilityChangedCallback = null;
        this.refreshingDeferred = null;
        this.initializePromise = null;
        this.detectSessionInUrl = true;
        this.hasCustomAuthorizationHeader = false;
        this.suppressGetSessionWarning = false;
        this.lockAcquired = false;
        this.pendingInLock = [];
        this.broadcastChannel = null;
        this.logger = console.log;
        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.storageKey = settings.storageKey;
        this.instanceID = (_a = _GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a !== void 0 ? _a : 0;
        _GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;
        this.logDebugMessages = !!settings.debug;
        if (typeof settings.debug === "function") {
          this.logger = settings.debug;
        }
        if (this.instanceID > 0 && isBrowser()) {
          const message = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
          console.warn(message);
          if (this.logDebugMessages) {
            console.trace(message);
          }
        }
        this.persistSession = settings.persistSession;
        this.autoRefreshToken = settings.autoRefreshToken;
        this.admin = new GoTrueAdminApi({
          url: settings.url,
          headers: settings.headers,
          fetch: settings.fetch
        });
        this.url = settings.url;
        this.headers = settings.headers;
        this.fetch = resolveFetch3(settings.fetch);
        this.lock = settings.lock || lockNoOp;
        this.detectSessionInUrl = settings.detectSessionInUrl;
        this.flowType = settings.flowType;
        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
        this.throwOnError = settings.throwOnError;
        this.lockAcquireTimeout = settings.lockAcquireTimeout;
        if (settings.lock) {
          this.lock = settings.lock;
        } else if (this.persistSession && isBrowser() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.locks)) {
          this.lock = navigatorLock;
        } else {
          this.lock = lockNoOp;
        }
        if (!this.jwks) {
          this.jwks = { keys: [] };
          this.jwks_cached_at = Number.MIN_SAFE_INTEGER;
        }
        this.mfa = {
          verify: this._verify.bind(this),
          enroll: this._enroll.bind(this),
          unenroll: this._unenroll.bind(this),
          challenge: this._challenge.bind(this),
          listFactors: this._listFactors.bind(this),
          challengeAndVerify: this._challengeAndVerify.bind(this),
          getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
          webauthn: new WebAuthnApi(this)
        };
        this.oauth = {
          getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
          approveAuthorization: this._approveAuthorization.bind(this),
          denyAuthorization: this._denyAuthorization.bind(this),
          listGrants: this._listOAuthGrants.bind(this),
          revokeGrant: this._revokeOAuthGrant.bind(this)
        };
        if (this.persistSession) {
          if (settings.storage) {
            this.storage = settings.storage;
          } else {
            if (supportsLocalStorage()) {
              this.storage = globalThis.localStorage;
            } else {
              this.memoryStorage = {};
              this.storage = memoryLocalStorageAdapter(this.memoryStorage);
            }
          }
          if (settings.userStorage) {
            this.userStorage = settings.userStorage;
          }
        } else {
          this.memoryStorage = {};
          this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
        if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
          try {
            this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
          } catch (e3) {
            console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e3);
          }
          (_c = this.broadcastChannel) === null || _c === void 0 ? void 0 : _c.addEventListener("message", async (event) => {
            this._debug("received broadcast notification from other tab or client", event);
            try {
              await this._notifyAllSubscribers(event.data.event, event.data.session, false);
            } catch (error2) {
              this._debug("#broadcastChannel", "error", error2);
            }
          });
        }
        this.initialize().catch((error2) => {
          this._debug("#initialize()", "error", error2);
        });
      }
      /**
       * Returns whether error throwing mode is enabled for this client.
       */
      isThrowOnErrorEnabled() {
        return this.throwOnError;
      }
      /**
       * Centralizes return handling with optional error throwing. When `throwOnError` is enabled
       * and the provided result contains a non-nullish error, the error is thrown instead of
       * being returned. This ensures consistent behavior across all public API methods.
       */
      _returnResult(result) {
        if (this.throwOnError && result && result.error) {
          throw result.error;
        }
        return result;
      }
      _logPrefix() {
        return `GoTrueClient@${this.storageKey}:${this.instanceID} (${version3}) ${(/* @__PURE__ */ new Date()).toISOString()}`;
      }
      _debug(...args) {
        if (this.logDebugMessages) {
          this.logger(this._logPrefix(), ...args);
        }
        return this;
      }
      /**
       * Initializes the client session either from the url or from storage.
       * This method is automatically called when instantiating the client, but should also be called
       * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
       */
      async initialize() {
        if (this.initializePromise) {
          return await this.initializePromise;
        }
        this.initializePromise = (async () => {
          return await this._acquireLock(this.lockAcquireTimeout, async () => {
            return await this._initialize();
          });
        })();
        return await this.initializePromise;
      }
      /**
       * IMPORTANT:
       * 1. Never throw in this method, as it is called from the constructor
       * 2. Never return a session from this method as it would be cached over
       *    the whole lifetime of the client
       */
      async _initialize() {
        var _a;
        try {
          let params2 = {};
          let callbackUrlType = "none";
          if (isBrowser()) {
            params2 = parseParametersFromURL(window.location.href);
            if (this._isImplicitGrantCallback(params2)) {
              callbackUrlType = "implicit";
            } else if (await this._isPKCECallback(params2)) {
              callbackUrlType = "pkce";
            }
          }
          if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== "none") {
            const { data, error: error2 } = await this._getSessionFromURL(params2, callbackUrlType);
            if (error2) {
              this._debug("#_initialize()", "error detecting session from URL", error2);
              if (isAuthImplicitGrantRedirectError(error2)) {
                const errorCode = (_a = error2.details) === null || _a === void 0 ? void 0 : _a.code;
                if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
                  return { error: error2 };
                }
              }
              return { error: error2 };
            }
            const { session, redirectType } = data;
            this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
            await this._saveSession(session);
            setTimeout(async () => {
              if (redirectType === "recovery") {
                await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
              } else {
                await this._notifyAllSubscribers("SIGNED_IN", session);
              }
            }, 0);
            return { error: null };
          }
          await this._recoverAndRefresh();
          return { error: null };
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ error: error2 });
          }
          return this._returnResult({
            error: new AuthUnknownError("Unexpected error during initialization", error2)
          });
        } finally {
          await this._handleVisibilityChange();
          this._debug("#_initialize()", "end");
        }
      }
      /**
       * Creates a new anonymous user.
       *
       * @returns A session where the is_anonymous claim in the access token JWT set to true
       */
      async signInAnonymously(credentials) {
        var _a, _b, _c;
        try {
          const res = await _request(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            body: {
              data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},
              gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
            },
            xform: _sessionResponse
          });
          const { data, error: error2 } = res;
          if (error2 || !data) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          const session = data.session;
          const user = data.user;
          if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
          return this._returnResult({ data: { user, session }, error: null });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Creates a new user.
       *
       * Be aware that if a user account exists in the system you may get back an
       * error message that attempts to hide this information from the user.
       * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
       *
       * @returns A logged-in session if the server has "autoconfirm" ON
       * @returns A user if the server has "autoconfirm" OFF
       */
      async signUp(credentials) {
        var _a, _b, _c;
        try {
          let res;
          if ("email" in credentials) {
            const { email, password, options } = credentials;
            let codeChallenge = null;
            let codeChallengeMethod = null;
            if (this.flowType === "pkce") {
              ;
              [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
            }
            res = await _request(this.fetch, "POST", `${this.url}/signup`, {
              headers: this.headers,
              redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
              body: {
                email,
                password,
                data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
                gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
                code_challenge: codeChallenge,
                code_challenge_method: codeChallengeMethod
              },
              xform: _sessionResponse
            });
          } else if ("phone" in credentials) {
            const { phone, password, options } = credentials;
            res = await _request(this.fetch, "POST", `${this.url}/signup`, {
              headers: this.headers,
              body: {
                phone,
                password,
                data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
                channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
                gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
              },
              xform: _sessionResponse
            });
          } else {
            throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
          }
          const { data, error: error2 } = res;
          if (error2 || !data) {
            await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          const session = data.session;
          const user = data.user;
          if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
          return this._returnResult({ data: { user, session }, error: null });
        } catch (error2) {
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Log in an existing user with an email and password or phone and password.
       *
       * Be aware that you may get back an error message that will not distinguish
       * between the cases where the account does not exist or that the
       * email/phone and password combination is wrong or that the account can only
       * be accessed via social login.
       */
      async signInWithPassword(credentials) {
        try {
          let res;
          if ("email" in credentials) {
            const { email, password, options } = credentials;
            res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
              headers: this.headers,
              body: {
                email,
                password,
                gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
              },
              xform: _sessionResponsePassword
            });
          } else if ("phone" in credentials) {
            const { phone, password, options } = credentials;
            res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
              headers: this.headers,
              body: {
                phone,
                password,
                gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
              },
              xform: _sessionResponsePassword
            });
          } else {
            throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
          }
          const { data, error: error2 } = res;
          if (error2) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          } else if (!data || !data.session || !data.user) {
            const invalidTokenError = new AuthInvalidTokenResponseError();
            return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
          }
          if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("SIGNED_IN", data.session);
          }
          return this._returnResult({
            data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
            error: error2
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Log in an existing user via a third-party provider.
       * This method supports the PKCE flow.
       */
      async signInWithOAuth(credentials) {
        var _a, _b, _c, _d;
        return await this._handleProviderSignIn(credentials.provider, {
          redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
          scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
          queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
          skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
        });
      }
      /**
       * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
       */
      async exchangeCodeForSession(authCode) {
        await this.initializePromise;
        return this._acquireLock(this.lockAcquireTimeout, async () => {
          return this._exchangeCodeForSession(authCode);
        });
      }
      /**
       * Signs in a user by verifying a message signed by the user's private key.
       * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,
       * both of which derive from the EIP-4361 standard
       * With slight variation on Solana's side.
       * @reference https://eips.ethereum.org/EIPS/eip-4361
       */
      async signInWithWeb3(credentials) {
        const { chain } = credentials;
        switch (chain) {
          case "ethereum":
            return await this.signInWithEthereum(credentials);
          case "solana":
            return await this.signInWithSolana(credentials);
          default:
            throw new Error(`@supabase/auth-js: Unsupported chain "${chain}"`);
        }
      }
      async signInWithEthereum(credentials) {
        var _a, _b, _c, _d, _e3, _f, _g, _h, _j, _k, _l;
        let message;
        let signature;
        if ("message" in credentials) {
          message = credentials.message;
          signature = credentials.signature;
        } else {
          const { chain, wallet, statement, options } = credentials;
          let resolvedWallet;
          if (!isBrowser()) {
            if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
              throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
            }
            resolvedWallet = wallet;
          } else if (typeof wallet === "object") {
            resolvedWallet = wallet;
          } else {
            const windowAny = window;
            if ("ethereum" in windowAny && typeof windowAny.ethereum === "object" && "request" in windowAny.ethereum && typeof windowAny.ethereum.request === "function") {
              resolvedWallet = windowAny.ethereum;
            } else {
              throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);
            }
          }
          const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);
          const accounts = await resolvedWallet.request({
            method: "eth_requestAccounts"
          }).then((accs) => accs).catch(() => {
            throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);
          });
          if (!accounts || accounts.length === 0) {
            throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);
          }
          const address = getAddress(accounts[0]);
          let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;
          if (!chainId) {
            const chainIdHex = await resolvedWallet.request({
              method: "eth_chainId"
            });
            chainId = fromHex(chainIdHex);
          }
          const siweMessage = {
            domain: url.host,
            address,
            statement,
            uri: url.href,
            version: "1",
            chainId,
            nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,
            issuedAt: (_e3 = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e3 !== void 0 ? _e3 : /* @__PURE__ */ new Date(),
            expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,
            notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,
            requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,
            resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources
          };
          message = createSiweMessage(siweMessage);
          signature = await resolvedWallet.request({
            method: "personal_sign",
            params: [toHex(message), address]
          });
        }
        try {
          const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
            headers: this.headers,
            body: Object.assign({
              chain: "ethereum",
              message,
              signature
            }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? { gotrue_meta_security: { captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken } } : null),
            xform: _sessionResponse
          });
          if (error2) {
            throw error2;
          }
          if (!data || !data.session || !data.user) {
            const invalidTokenError = new AuthInvalidTokenResponseError();
            return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
          }
          if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("SIGNED_IN", data.session);
          }
          return this._returnResult({ data: Object.assign({}, data), error: error2 });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      async signInWithSolana(credentials) {
        var _a, _b, _c, _d, _e3, _f, _g, _h, _j, _k, _l, _m;
        let message;
        let signature;
        if ("message" in credentials) {
          message = credentials.message;
          signature = credentials.signature;
        } else {
          const { chain, wallet, statement, options } = credentials;
          let resolvedWallet;
          if (!isBrowser()) {
            if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
              throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
            }
            resolvedWallet = wallet;
          } else if (typeof wallet === "object") {
            resolvedWallet = wallet;
          } else {
            const windowAny = window;
            if ("solana" in windowAny && typeof windowAny.solana === "object" && ("signIn" in windowAny.solana && typeof windowAny.solana.signIn === "function" || "signMessage" in windowAny.solana && typeof windowAny.solana.signMessage === "function")) {
              resolvedWallet = windowAny.solana;
            } else {
              throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);
            }
          }
          const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);
          if ("signIn" in resolvedWallet && resolvedWallet.signIn) {
            const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: (/* @__PURE__ */ new Date()).toISOString() }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {
              // non-overridable properties
              version: "1",
              domain: url.host,
              uri: url.href
            }), statement ? { statement } : null));
            let outputToProcess;
            if (Array.isArray(output) && output[0] && typeof output[0] === "object") {
              outputToProcess = output[0];
            } else if (output && typeof output === "object" && "signedMessage" in output && "signature" in output) {
              outputToProcess = output;
            } else {
              throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
            }
            if ("signedMessage" in outputToProcess && "signature" in outputToProcess && (typeof outputToProcess.signedMessage === "string" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {
              message = typeof outputToProcess.signedMessage === "string" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);
              signature = outputToProcess.signature;
            } else {
              throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
            }
          } else {
            if (!("signMessage" in resolvedWallet) || typeof resolvedWallet.signMessage !== "function" || !("publicKey" in resolvedWallet) || typeof resolvedWallet !== "object" || !resolvedWallet.publicKey || !("toBase58" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== "function") {
              throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
            }
            message = [
              `${url.host} wants you to sign in with your Solana account:`,
              resolvedWallet.publicKey.toBase58(),
              ...statement ? ["", statement, ""] : [""],
              "Version: 1",
              `URI: ${url.href}`,
              `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : (/* @__PURE__ */ new Date()).toISOString()}`,
              ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [`Not Before: ${options.signInWithSolana.notBefore}`] : [],
              ...((_e3 = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e3 === void 0 ? void 0 : _e3.expirationTime) ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`] : [],
              ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [`Chain ID: ${options.signInWithSolana.chainId}`] : [],
              ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [`Nonce: ${options.signInWithSolana.nonce}`] : [],
              ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [`Request ID: ${options.signInWithSolana.requestId}`] : [],
              ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [
                "Resources",
                ...options.signInWithSolana.resources.map((resource) => `- ${resource}`)
              ] : []
            ].join("\n");
            const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), "utf8");
            if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {
              throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
            }
            signature = maybeSignature;
          }
        }
        try {
          const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
            headers: this.headers,
            body: Object.assign({ chain: "solana", message, signature: bytesToBase64URL(signature) }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? { gotrue_meta_security: { captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken } } : null),
            xform: _sessionResponse
          });
          if (error2) {
            throw error2;
          }
          if (!data || !data.session || !data.user) {
            const invalidTokenError = new AuthInvalidTokenResponseError();
            return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
          }
          if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("SIGNED_IN", data.session);
          }
          return this._returnResult({ data: Object.assign({}, data), error: error2 });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      async _exchangeCodeForSession(authCode) {
        const storageItem = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
        try {
          if (!codeVerifier && this.flowType === "pkce") {
            throw new AuthPKCECodeVerifierMissingError();
          }
          const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
            headers: this.headers,
            body: {
              auth_code: authCode,
              code_verifier: codeVerifier
            },
            xform: _sessionResponse
          });
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          if (error2) {
            throw error2;
          }
          if (!data || !data.session || !data.user) {
            const invalidTokenError = new AuthInvalidTokenResponseError();
            return this._returnResult({
              data: { user: null, session: null, redirectType: null },
              error: invalidTokenError
            });
          }
          if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("SIGNED_IN", data.session);
          }
          return this._returnResult({ data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error: error2 });
        } catch (error2) {
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          if (isAuthError(error2)) {
            return this._returnResult({
              data: { user: null, session: null, redirectType: null },
              error: error2
            });
          }
          throw error2;
        }
      }
      /**
       * Allows signing in with an OIDC ID token. The authentication provider used
       * should be enabled and configured.
       */
      async signInWithIdToken(credentials) {
        try {
          const { options, provider, token, access_token, nonce } = credentials;
          const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
            headers: this.headers,
            body: {
              provider,
              id_token: token,
              access_token,
              nonce,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponse
          });
          const { data, error: error2 } = res;
          if (error2) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          } else if (!data || !data.session || !data.user) {
            const invalidTokenError = new AuthInvalidTokenResponseError();
            return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
          }
          if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("SIGNED_IN", data.session);
          }
          return this._returnResult({ data, error: error2 });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Log in a user using magiclink or a one-time password (OTP).
       *
       * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
       * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
       * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
       *
       * Be aware that you may get back an error message that will not distinguish
       * between the cases where the account does not exist or, that the account
       * can only be accessed via social login.
       *
       * Do note that you will need to configure a Whatsapp sender on Twilio
       * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
       * channel is not supported on other providers
       * at this time.
       * This method supports PKCE when an email is passed.
       */
      async signInWithOtp(credentials) {
        var _a, _b, _c, _d, _e3;
        try {
          if ("email" in credentials) {
            const { email, options } = credentials;
            let codeChallenge = null;
            let codeChallengeMethod = null;
            if (this.flowType === "pkce") {
              ;
              [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
            }
            const { error: error2 } = await _request(this.fetch, "POST", `${this.url}/otp`, {
              headers: this.headers,
              body: {
                email,
                data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
                create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
                gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
                code_challenge: codeChallenge,
                code_challenge_method: codeChallengeMethod
              },
              redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
            });
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          if ("phone" in credentials) {
            const { phone, options } = credentials;
            const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/otp`, {
              headers: this.headers,
              body: {
                phone,
                data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
                create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
                gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
                channel: (_e3 = options === null || options === void 0 ? void 0 : options.channel) !== null && _e3 !== void 0 ? _e3 : "sms"
              }
            });
            return this._returnResult({
              data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id },
              error: error2
            });
          }
          throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
        } catch (error2) {
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
       */
      async verifyOtp(params2) {
        var _a, _b;
        try {
          let redirectTo = void 0;
          let captchaToken = void 0;
          if ("options" in params2) {
            redirectTo = (_a = params2.options) === null || _a === void 0 ? void 0 : _a.redirectTo;
            captchaToken = (_b = params2.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
          }
          const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/verify`, {
            headers: this.headers,
            body: Object.assign(Object.assign({}, params2), { gotrue_meta_security: { captcha_token: captchaToken } }),
            redirectTo,
            xform: _sessionResponse
          });
          if (error2) {
            throw error2;
          }
          if (!data) {
            const tokenVerificationError = new Error("An error occurred on token verification.");
            throw tokenVerificationError;
          }
          const session = data.session;
          const user = data.user;
          if (session === null || session === void 0 ? void 0 : session.access_token) {
            await this._saveSession(session);
            await this._notifyAllSubscribers(params2.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
          }
          return this._returnResult({ data: { user, session }, error: null });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Attempts a single-sign on using an enterprise Identity Provider. A
       * successful SSO attempt will redirect the current page to the identity
       * provider authorization page. The redirect URL is implementation and SSO
       * protocol specific.
       *
       * You can use it by providing a SSO domain. Typically you can extract this
       * domain by asking users for their email address. If this domain is
       * registered on the Auth instance the redirect will use that organization's
       * currently active SSO Identity Provider for the login.
       *
       * If you have built an organization-specific login page, you can use the
       * organization's SSO Identity Provider UUID directly instead.
       */
      async signInWithSSO(params2) {
        var _a, _b, _c, _d, _e3;
        try {
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce") {
            ;
            [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          const result = await _request(this.fetch, "POST", `${this.url}/sso`, {
            body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params2 ? { provider_id: params2.providerId } : null), "domain" in params2 ? { domain: params2.domain } : null), { redirect_to: (_b = (_a = params2.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params2 === null || params2 === void 0 ? void 0 : params2.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params2.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
            headers: this.headers,
            xform: _ssoResponse
          });
          if (((_d = result.data) === null || _d === void 0 ? void 0 : _d.url) && isBrowser() && !((_e3 = params2.options) === null || _e3 === void 0 ? void 0 : _e3.skipBrowserRedirect)) {
            window.location.assign(result.data.url);
          }
          return this._returnResult(result);
        } catch (error2) {
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Sends a reauthentication OTP to the user's email or phone number.
       * Requires the user to be signed-in.
       */
      async reauthenticate() {
        await this.initializePromise;
        return await this._acquireLock(this.lockAcquireTimeout, async () => {
          return await this._reauthenticate();
        });
      }
      async _reauthenticate() {
        try {
          return await this._useSession(async (result) => {
            const { data: { session }, error: sessionError } = result;
            if (sessionError)
              throw sessionError;
            if (!session)
              throw new AuthSessionMissingError();
            const { error: error2 } = await _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
              headers: this.headers,
              jwt: session.access_token
            });
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
       */
      async resend(credentials) {
        try {
          const endpoint = `${this.url}/resend`;
          if ("email" in credentials) {
            const { email, type, options } = credentials;
            const { error: error2 } = await _request(this.fetch, "POST", endpoint, {
              headers: this.headers,
              body: {
                email,
                type,
                gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
              },
              redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
            });
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          } else if ("phone" in credentials) {
            const { phone, type, options } = credentials;
            const { data, error: error2 } = await _request(this.fetch, "POST", endpoint, {
              headers: this.headers,
              body: {
                phone,
                type,
                gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
              }
            });
            return this._returnResult({
              data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id },
              error: error2
            });
          }
          throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Returns the session, refreshing it if necessary.
       *
       * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
       *
       * **IMPORTANT:** This method loads values directly from the storage attached
       * to the client. If that storage is based on request cookies for example,
       * the values in it may not be authentic and therefore it's strongly advised
       * against using this method and its results in such circumstances. A warning
       * will be emitted if this is detected. Use {@link #getUser()} instead.
       */
      async getSession() {
        await this.initializePromise;
        const result = await this._acquireLock(this.lockAcquireTimeout, async () => {
          return this._useSession(async (result2) => {
            return result2;
          });
        });
        return result;
      }
      /**
       * Acquires a global lock based on the storage key.
       */
      async _acquireLock(acquireTimeout, fn4) {
        this._debug("#_acquireLock", "begin", acquireTimeout);
        try {
          if (this.lockAcquired) {
            const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
            const result = (async () => {
              await last;
              return await fn4();
            })();
            this.pendingInLock.push((async () => {
              try {
                await result;
              } catch (e3) {
              }
            })());
            return result;
          }
          return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
            this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
            try {
              this.lockAcquired = true;
              const result = fn4();
              this.pendingInLock.push((async () => {
                try {
                  await result;
                } catch (e3) {
                }
              })());
              await result;
              while (this.pendingInLock.length) {
                const waitOn = [...this.pendingInLock];
                await Promise.all(waitOn);
                this.pendingInLock.splice(0, waitOn.length);
              }
              return await result;
            } finally {
              this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
              this.lockAcquired = false;
            }
          });
        } finally {
          this._debug("#_acquireLock", "end");
        }
      }
      /**
       * Use instead of {@link #getSession} inside the library. It is
       * semantically usually what you want, as getting a session involves some
       * processing afterwards that requires only one client operating on the
       * session at once across multiple tabs or processes.
       */
      async _useSession(fn4) {
        this._debug("#_useSession", "begin");
        try {
          const result = await this.__loadSession();
          return await fn4(result);
        } finally {
          this._debug("#_useSession", "end");
        }
      }
      /**
       * NEVER USE DIRECTLY!
       *
       * Always use {@link #_useSession}.
       */
      async __loadSession() {
        this._debug("#__loadSession()", "begin");
        if (!this.lockAcquired) {
          this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
        }
        try {
          let currentSession = null;
          const maybeSession = await getItemAsync(this.storage, this.storageKey);
          this._debug("#getSession()", "session from storage", maybeSession);
          if (maybeSession !== null) {
            if (this._isValidSession(maybeSession)) {
              currentSession = maybeSession;
            } else {
              this._debug("#getSession()", "session from storage is not valid");
              await this._removeSession();
            }
          }
          if (!currentSession) {
            return { data: { session: null }, error: null };
          }
          const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1e3 - Date.now() < EXPIRY_MARGIN_MS : false;
          this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
          if (!hasExpired) {
            if (this.userStorage) {
              const maybeUser = await getItemAsync(this.userStorage, this.storageKey + "-user");
              if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {
                currentSession.user = maybeUser.user;
              } else {
                currentSession.user = userNotAvailableProxy();
              }
            }
            if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {
              const suppressWarningRef = { value: this.suppressGetSessionWarning };
              currentSession.user = insecureUserWarningProxy(currentSession.user, suppressWarningRef);
              if (suppressWarningRef.value) {
                this.suppressGetSessionWarning = true;
              }
            }
            return { data: { session: currentSession }, error: null };
          }
          const { data: session, error: error2 } = await this._callRefreshToken(currentSession.refresh_token);
          if (error2) {
            return this._returnResult({ data: { session: null }, error: error2 });
          }
          return this._returnResult({ data: { session }, error: null });
        } finally {
          this._debug("#__loadSession()", "end");
        }
      }
      /**
       * Gets the current user details if there is an existing session. This method
       * performs a network request to the Supabase Auth server, so the returned
       * value is authentic and can be used to base authorization rules on.
       *
       * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
       */
      async getUser(jwt) {
        if (jwt) {
          return await this._getUser(jwt);
        }
        await this.initializePromise;
        const result = await this._acquireLock(this.lockAcquireTimeout, async () => {
          return await this._getUser();
        });
        if (result.data.user) {
          this.suppressGetSessionWarning = true;
        }
        return result;
      }
      async _getUser(jwt) {
        try {
          if (jwt) {
            return await _request(this.fetch, "GET", `${this.url}/user`, {
              headers: this.headers,
              jwt,
              xform: _userResponse
            });
          }
          return await this._useSession(async (result) => {
            var _a, _b, _c;
            const { data, error: error2 } = result;
            if (error2) {
              throw error2;
            }
            if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {
              return { data: { user: null }, error: new AuthSessionMissingError() };
            }
            return await _request(this.fetch, "GET", `${this.url}/user`, {
              headers: this.headers,
              jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
              xform: _userResponse
            });
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            if (isAuthSessionMissingError(error2)) {
              await this._removeSession();
              await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
            }
            return this._returnResult({ data: { user: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Updates user data for a logged in user.
       */
      async updateUser(attributes, options = {}) {
        await this.initializePromise;
        return await this._acquireLock(this.lockAcquireTimeout, async () => {
          return await this._updateUser(attributes, options);
        });
      }
      async _updateUser(attributes, options = {}) {
        try {
          return await this._useSession(async (result) => {
            const { data: sessionData, error: sessionError } = result;
            if (sessionError) {
              throw sessionError;
            }
            if (!sessionData.session) {
              throw new AuthSessionMissingError();
            }
            const session = sessionData.session;
            let codeChallenge = null;
            let codeChallengeMethod = null;
            if (this.flowType === "pkce" && attributes.email != null) {
              ;
              [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
            }
            const { data, error: userError } = await _request(this.fetch, "PUT", `${this.url}/user`, {
              headers: this.headers,
              redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
              body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
              jwt: session.access_token,
              xform: _userResponse
            });
            if (userError) {
              throw userError;
            }
            session.user = data.user;
            await this._saveSession(session);
            await this._notifyAllSubscribers("USER_UPDATED", session);
            return this._returnResult({ data: { user: session.user }, error: null });
          });
        } catch (error2) {
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
       * If the refresh token or access token in the current session is invalid, an error will be thrown.
       * @param currentSession The current session that minimally contains an access token and refresh token.
       */
      async setSession(currentSession) {
        await this.initializePromise;
        return await this._acquireLock(this.lockAcquireTimeout, async () => {
          return await this._setSession(currentSession);
        });
      }
      async _setSession(currentSession) {
        try {
          if (!currentSession.access_token || !currentSession.refresh_token) {
            throw new AuthSessionMissingError();
          }
          const timeNow = Date.now() / 1e3;
          let expiresAt2 = timeNow;
          let hasExpired = true;
          let session = null;
          const { payload } = decodeJWT(currentSession.access_token);
          if (payload.exp) {
            expiresAt2 = payload.exp;
            hasExpired = expiresAt2 <= timeNow;
          }
          if (hasExpired) {
            const { data: refreshedSession, error: error2 } = await this._callRefreshToken(currentSession.refresh_token);
            if (error2) {
              return this._returnResult({ data: { user: null, session: null }, error: error2 });
            }
            if (!refreshedSession) {
              return { data: { user: null, session: null }, error: null };
            }
            session = refreshedSession;
          } else {
            const { data, error: error2 } = await this._getUser(currentSession.access_token);
            if (error2) {
              return this._returnResult({ data: { user: null, session: null }, error: error2 });
            }
            session = {
              access_token: currentSession.access_token,
              refresh_token: currentSession.refresh_token,
              user: data.user,
              token_type: "bearer",
              expires_in: expiresAt2 - timeNow,
              expires_at: expiresAt2
            };
            await this._saveSession(session);
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
          return this._returnResult({ data: { user: session.user, session }, error: null });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { session: null, user: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Returns a new session, regardless of expiry status.
       * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
       * If the current session's refresh token is invalid, an error will be thrown.
       * @param currentSession The current session. If passed in, it must contain a refresh token.
       */
      async refreshSession(currentSession) {
        await this.initializePromise;
        return await this._acquireLock(this.lockAcquireTimeout, async () => {
          return await this._refreshSession(currentSession);
        });
      }
      async _refreshSession(currentSession) {
        try {
          return await this._useSession(async (result) => {
            var _a;
            if (!currentSession) {
              const { data, error: error3 } = result;
              if (error3) {
                throw error3;
              }
              currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : void 0;
            }
            if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
              throw new AuthSessionMissingError();
            }
            const { data: session, error: error2 } = await this._callRefreshToken(currentSession.refresh_token);
            if (error2) {
              return this._returnResult({ data: { user: null, session: null }, error: error2 });
            }
            if (!session) {
              return this._returnResult({ data: { user: null, session: null }, error: null });
            }
            return this._returnResult({ data: { user: session.user, session }, error: null });
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { user: null, session: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Gets the session data from a URL string
       */
      async _getSessionFromURL(params2, callbackUrlType) {
        try {
          if (!isBrowser())
            throw new AuthImplicitGrantRedirectError("No browser detected.");
          if (params2.error || params2.error_description || params2.error_code) {
            throw new AuthImplicitGrantRedirectError(params2.error_description || "Error in URL with unspecified error_description", {
              error: params2.error || "unspecified_error",
              code: params2.error_code || "unspecified_code"
            });
          }
          switch (callbackUrlType) {
            case "implicit":
              if (this.flowType === "pkce") {
                throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
              }
              break;
            case "pkce":
              if (this.flowType === "implicit") {
                throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
              }
              break;
            default:
          }
          if (callbackUrlType === "pkce") {
            this._debug("#_initialize()", "begin", "is PKCE flow", true);
            if (!params2.code)
              throw new AuthPKCEGrantCodeExchangeError("No code detected.");
            const { data: data2, error: error3 } = await this._exchangeCodeForSession(params2.code);
            if (error3)
              throw error3;
            const url = new URL(window.location.href);
            url.searchParams.delete("code");
            window.history.replaceState(window.history.state, "", url.toString());
            return { data: { session: data2.session, redirectType: null }, error: null };
          }
          const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params2;
          if (!access_token || !expires_in || !refresh_token || !token_type) {
            throw new AuthImplicitGrantRedirectError("No session defined in URL");
          }
          const timeNow = Math.round(Date.now() / 1e3);
          const expiresIn = parseInt(expires_in);
          let expiresAt2 = timeNow + expiresIn;
          if (expires_at) {
            expiresAt2 = parseInt(expires_at);
          }
          const actuallyExpiresIn = expiresAt2 - timeNow;
          if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION_MS) {
            console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
          }
          const issuedAt = expiresAt2 - expiresIn;
          if (timeNow - issuedAt >= 120) {
            console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
          } else if (timeNow - issuedAt < 0) {
            console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
          }
          const { data, error: error2 } = await this._getUser(access_token);
          if (error2)
            throw error2;
          const session = {
            provider_token,
            provider_refresh_token,
            access_token,
            expires_in: expiresIn,
            expires_at: expiresAt2,
            refresh_token,
            token_type,
            user: data.user
          };
          window.location.hash = "";
          this._debug("#_getSessionFromURL()", "clearing window.location.hash");
          return this._returnResult({ data: { session, redirectType: params2.type }, error: null });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { session: null, redirectType: null }, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
       *
       * If `detectSessionInUrl` is a function, it will be called with the URL and params to determine
       * if the URL should be processed as a Supabase auth callback. This allows users to exclude
       * URLs from other OAuth providers (e.g., Facebook Login) that also return access_token in the fragment.
       */
      _isImplicitGrantCallback(params2) {
        if (typeof this.detectSessionInUrl === "function") {
          return this.detectSessionInUrl(new URL(window.location.href), params2);
        }
        return Boolean(params2.access_token || params2.error_description);
      }
      /**
       * Checks if the current URL and backing storage contain parameters given by a PKCE flow
       */
      async _isPKCECallback(params2) {
        const currentStorageContent = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        return !!(params2.code && currentStorageContent);
      }
      /**
       * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
       *
       * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
       * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
       *
       * If using `others` scope, no `SIGNED_OUT` event is fired!
       */
      async signOut(options = { scope: "global" }) {
        await this.initializePromise;
        return await this._acquireLock(this.lockAcquireTimeout, async () => {
          return await this._signOut(options);
        });
      }
      async _signOut({ scope } = { scope: "global" }) {
        return await this._useSession(async (result) => {
          var _a;
          const { data, error: sessionError } = result;
          if (sessionError && !isAuthSessionMissingError(sessionError)) {
            return this._returnResult({ error: sessionError });
          }
          const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;
          if (accessToken) {
            const { error: error2 } = await this.admin.signOut(accessToken, scope);
            if (error2) {
              if (!(isAuthApiError(error2) && (error2.status === 404 || error2.status === 401 || error2.status === 403) || isAuthSessionMissingError(error2))) {
                return this._returnResult({ error: error2 });
              }
            }
          }
          if (scope !== "others") {
            await this._removeSession();
            await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          }
          return this._returnResult({ error: null });
        });
      }
      onAuthStateChange(callback) {
        const id = generateCallbackId();
        const subscription = {
          id,
          callback,
          unsubscribe: () => {
            this._debug("#unsubscribe()", "state change callback with id removed", id);
            this.stateChangeEmitters.delete(id);
          }
        };
        this._debug("#onAuthStateChange()", "registered callback with id", id);
        this.stateChangeEmitters.set(id, subscription);
        (async () => {
          await this.initializePromise;
          await this._acquireLock(this.lockAcquireTimeout, async () => {
            this._emitInitialSession(id);
          });
        })();
        return { data: { subscription } };
      }
      async _emitInitialSession(id) {
        return await this._useSession(async (result) => {
          var _a, _b;
          try {
            const { data: { session }, error: error2 } = result;
            if (error2)
              throw error2;
            await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback("INITIAL_SESSION", session));
            this._debug("INITIAL_SESSION", "callback id", id, "session", session);
          } catch (err) {
            await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null));
            this._debug("INITIAL_SESSION", "callback id", id, "error", err);
            console.error(err);
          }
        });
      }
      /**
       * Sends a password reset request to an email address. This method supports the PKCE flow.
       *
       * @param email The email address of the user.
       * @param options.redirectTo The URL to send the user to after they click the password reset link.
       * @param options.captchaToken Verification token received when the user completes the captcha on the site.
       */
      async resetPasswordForEmail(email, options = {}) {
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(
            this.storage,
            this.storageKey,
            true
            // isPasswordRecovery
          );
        }
        try {
          return await _request(this.fetch, "POST", `${this.url}/recover`, {
            body: {
              email,
              code_challenge: codeChallenge,
              code_challenge_method: codeChallengeMethod,
              gotrue_meta_security: { captcha_token: options.captchaToken }
            },
            headers: this.headers,
            redirectTo: options.redirectTo
          });
        } catch (error2) {
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Gets all the identities linked to a user.
       */
      async getUserIdentities() {
        var _a;
        try {
          const { data, error: error2 } = await this.getUser();
          if (error2)
            throw error2;
          return this._returnResult({ data: { identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : [] }, error: null });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      async linkIdentity(credentials) {
        if ("token" in credentials) {
          return this.linkIdentityIdToken(credentials);
        }
        return this.linkIdentityOAuth(credentials);
      }
      async linkIdentityOAuth(credentials) {
        var _a;
        try {
          const { data, error: error2 } = await this._useSession(async (result) => {
            var _a2, _b, _c, _d, _e3;
            const { data: data2, error: error3 } = result;
            if (error3)
              throw error3;
            const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
              redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
              scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
              queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
              skipBrowserRedirect: true
            });
            return await _request(this.fetch, "GET", url, {
              headers: this.headers,
              jwt: (_e3 = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e3 !== void 0 ? _e3 : void 0
            });
          });
          if (error2)
            throw error2;
          if (isBrowser() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {
            window.location.assign(data === null || data === void 0 ? void 0 : data.url);
          }
          return this._returnResult({
            data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url },
            error: null
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: { provider: credentials.provider, url: null }, error: error2 });
          }
          throw error2;
        }
      }
      async linkIdentityIdToken(credentials) {
        return await this._useSession(async (result) => {
          var _a;
          try {
            const { error: sessionError, data: { session } } = result;
            if (sessionError)
              throw sessionError;
            const { options, provider, token, access_token, nonce } = credentials;
            const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
              headers: this.headers,
              jwt: (_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : void 0,
              body: {
                provider,
                id_token: token,
                access_token,
                nonce,
                link_identity: true,
                gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
              },
              xform: _sessionResponse
            });
            const { data, error: error2 } = res;
            if (error2) {
              return this._returnResult({ data: { user: null, session: null }, error: error2 });
            } else if (!data || !data.session || !data.user) {
              return this._returnResult({
                data: { user: null, session: null },
                error: new AuthInvalidTokenResponseError()
              });
            }
            if (data.session) {
              await this._saveSession(data.session);
              await this._notifyAllSubscribers("USER_UPDATED", data.session);
            }
            return this._returnResult({ data, error: error2 });
          } catch (error2) {
            await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
            if (isAuthError(error2)) {
              return this._returnResult({ data: { user: null, session: null }, error: error2 });
            }
            throw error2;
          }
        });
      }
      /**
       * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
       */
      async unlinkIdentity(identity2) {
        try {
          return await this._useSession(async (result) => {
            var _a, _b;
            const { data, error: error2 } = result;
            if (error2) {
              throw error2;
            }
            return await _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity2.identity_id}`, {
              headers: this.headers,
              jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : void 0
            });
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Generates a new JWT.
       * @param refreshToken A valid refresh token that was returned on login.
       */
      async _refreshAccessToken(refreshToken) {
        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
        this._debug(debugName, "begin");
        try {
          const startedAt = Date.now();
          return await retryable(async (attempt) => {
            if (attempt > 0) {
              await sleep(200 * Math.pow(2, attempt - 1));
            }
            this._debug(debugName, "refreshing attempt", attempt);
            return await _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
              body: { refresh_token: refreshToken },
              headers: this.headers,
              xform: _sessionResponse
            });
          }, (attempt, error2) => {
            const nextBackOffInterval = 200 * Math.pow(2, attempt);
            return error2 && isAuthRetryableFetchError(error2) && // retryable only if the request can be sent before the backoff overflows the tick duration
            Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION_MS;
          });
        } catch (error2) {
          this._debug(debugName, "error", error2);
          if (isAuthError(error2)) {
            return this._returnResult({ data: { session: null, user: null }, error: error2 });
          }
          throw error2;
        } finally {
          this._debug(debugName, "end");
        }
      }
      _isValidSession(maybeSession) {
        const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
        return isValidSession;
      }
      async _handleProviderSignIn(provider, options) {
        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
          redirectTo: options.redirectTo,
          scopes: options.scopes,
          queryParams: options.queryParams
        });
        this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
        if (isBrowser() && !options.skipBrowserRedirect) {
          window.location.assign(url);
        }
        return { data: { provider, url }, error: null };
      }
      /**
       * Recovers the session from LocalStorage and refreshes the token
       * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
       */
      async _recoverAndRefresh() {
        var _a, _b;
        const debugName = "#_recoverAndRefresh()";
        this._debug(debugName, "begin");
        try {
          const currentSession = await getItemAsync(this.storage, this.storageKey);
          if (currentSession && this.userStorage) {
            let maybeUser = await getItemAsync(this.userStorage, this.storageKey + "-user");
            if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {
              maybeUser = { user: currentSession.user };
              await setItemAsync(this.userStorage, this.storageKey + "-user", maybeUser);
            }
            currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : userNotAvailableProxy();
          } else if (currentSession && !currentSession.user) {
            if (!currentSession.user) {
              const separateUser = await getItemAsync(this.storage, this.storageKey + "-user");
              if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {
                currentSession.user = separateUser.user;
                await removeItemAsync(this.storage, this.storageKey + "-user");
                await setItemAsync(this.storage, this.storageKey, currentSession);
              } else {
                currentSession.user = userNotAvailableProxy();
              }
            }
          }
          this._debug(debugName, "session from storage", currentSession);
          if (!this._isValidSession(currentSession)) {
            this._debug(debugName, "session is not valid");
            if (currentSession !== null) {
              await this._removeSession();
            }
            return;
          }
          const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1e3 - Date.now() < EXPIRY_MARGIN_MS;
          this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN_MS}s`);
          if (expiresWithMargin) {
            if (this.autoRefreshToken && currentSession.refresh_token) {
              const { error: error2 } = await this._callRefreshToken(currentSession.refresh_token);
              if (error2) {
                console.error(error2);
                if (!isAuthRetryableFetchError(error2)) {
                  this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error2);
                  await this._removeSession();
                }
              }
            }
          } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {
            try {
              const { data, error: userError } = await this._getUser(currentSession.access_token);
              if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {
                currentSession.user = data.user;
                await this._saveSession(currentSession);
                await this._notifyAllSubscribers("SIGNED_IN", currentSession);
              } else {
                this._debug(debugName, "could not get user data, skipping SIGNED_IN notification");
              }
            } catch (getUserError) {
              console.error("Error getting user data:", getUserError);
              this._debug(debugName, "error getting user data, skipping SIGNED_IN notification", getUserError);
            }
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", currentSession);
          }
        } catch (err) {
          this._debug(debugName, "error", err);
          console.error(err);
          return;
        } finally {
          this._debug(debugName, "end");
        }
      }
      async _callRefreshToken(refreshToken) {
        var _a, _b;
        if (!refreshToken) {
          throw new AuthSessionMissingError();
        }
        if (this.refreshingDeferred) {
          return this.refreshingDeferred.promise;
        }
        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
        this._debug(debugName, "begin");
        try {
          this.refreshingDeferred = new Deferred();
          const { data, error: error2 } = await this._refreshAccessToken(refreshToken);
          if (error2)
            throw error2;
          if (!data.session)
            throw new AuthSessionMissingError();
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
          const result = { data: data.session, error: null };
          this.refreshingDeferred.resolve(result);
          return result;
        } catch (error2) {
          this._debug(debugName, "error", error2);
          if (isAuthError(error2)) {
            const result = { data: null, error: error2 };
            if (!isAuthRetryableFetchError(error2)) {
              await this._removeSession();
            }
            (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);
            return result;
          }
          (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error2);
          throw error2;
        } finally {
          this.refreshingDeferred = null;
          this._debug(debugName, "end");
        }
      }
      async _notifyAllSubscribers(event, session, broadcast = true) {
        const debugName = `#_notifyAllSubscribers(${event})`;
        this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
        try {
          if (this.broadcastChannel && broadcast) {
            this.broadcastChannel.postMessage({ event, session });
          }
          const errors = [];
          const promises = Array.from(this.stateChangeEmitters.values()).map(async (x4) => {
            try {
              await x4.callback(event, session);
            } catch (e3) {
              errors.push(e3);
            }
          });
          await Promise.all(promises);
          if (errors.length > 0) {
            for (let i7 = 0; i7 < errors.length; i7 += 1) {
              console.error(errors[i7]);
            }
            throw errors[0];
          }
        } finally {
          this._debug(debugName, "end");
        }
      }
      /**
       * set currentSession and currentUser
       * process to _startAutoRefreshToken if possible
       */
      async _saveSession(session) {
        this._debug("#_saveSession()", session);
        this.suppressGetSessionWarning = true;
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        const sessionToProcess = Object.assign({}, session);
        const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;
        if (this.userStorage) {
          if (!userIsProxy && sessionToProcess.user) {
            await setItemAsync(this.userStorage, this.storageKey + "-user", {
              user: sessionToProcess.user
            });
          } else if (userIsProxy) {
          }
          const mainSessionData = Object.assign({}, sessionToProcess);
          delete mainSessionData.user;
          const clonedMainSessionData = deepClone(mainSessionData);
          await setItemAsync(this.storage, this.storageKey, clonedMainSessionData);
        } else {
          const clonedSession = deepClone(sessionToProcess);
          await setItemAsync(this.storage, this.storageKey, clonedSession);
        }
      }
      async _removeSession() {
        this._debug("#_removeSession()");
        this.suppressGetSessionWarning = false;
        await removeItemAsync(this.storage, this.storageKey);
        await removeItemAsync(this.storage, this.storageKey + "-code-verifier");
        await removeItemAsync(this.storage, this.storageKey + "-user");
        if (this.userStorage) {
          await removeItemAsync(this.userStorage, this.storageKey + "-user");
        }
        await this._notifyAllSubscribers("SIGNED_OUT", null);
      }
      /**
       * Removes any registered visibilitychange callback.
       *
       * {@see #startAutoRefresh}
       * {@see #stopAutoRefresh}
       */
      _removeVisibilityChangedCallback() {
        this._debug("#_removeVisibilityChangedCallback()");
        const callback = this.visibilityChangedCallback;
        this.visibilityChangedCallback = null;
        try {
          if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
            window.removeEventListener("visibilitychange", callback);
          }
        } catch (e3) {
          console.error("removing visibilitychange callback failed", e3);
        }
      }
      /**
       * This is the private implementation of {@link #startAutoRefresh}. Use this
       * within the library.
       */
      async _startAutoRefresh() {
        await this._stopAutoRefresh();
        this._debug("#_startAutoRefresh()");
        const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION_MS);
        this.autoRefreshTicker = ticker;
        if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
          ticker.unref();
        } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
          Deno.unrefTimer(ticker);
        }
        const timeout = setTimeout(async () => {
          await this.initializePromise;
          await this._autoRefreshTokenTick();
        }, 0);
        this.autoRefreshTickTimeout = timeout;
        if (timeout && typeof timeout === "object" && typeof timeout.unref === "function") {
          timeout.unref();
        } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
          Deno.unrefTimer(timeout);
        }
      }
      /**
       * This is the private implementation of {@link #stopAutoRefresh}. Use this
       * within the library.
       */
      async _stopAutoRefresh() {
        this._debug("#_stopAutoRefresh()");
        const ticker = this.autoRefreshTicker;
        this.autoRefreshTicker = null;
        if (ticker) {
          clearInterval(ticker);
        }
        const timeout = this.autoRefreshTickTimeout;
        this.autoRefreshTickTimeout = null;
        if (timeout) {
          clearTimeout(timeout);
        }
      }
      /**
       * Starts an auto-refresh process in the background. The session is checked
       * every few seconds. Close to the time of expiration a process is started to
       * refresh the session. If refreshing fails it will be retried for as long as
       * necessary.
       *
       * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
       * to call this function, it will be called for you.
       *
       * On browsers the refresh process works only when the tab/window is in the
       * foreground to conserve resources as well as prevent race conditions and
       * flooding auth with requests. If you call this method any managed
       * visibility change callback will be removed and you must manage visibility
       * changes on your own.
       *
       * On non-browser platforms the refresh process works *continuously* in the
       * background, which may not be desirable. You should hook into your
       * platform's foreground indication mechanism and call these methods
       * appropriately to conserve resources.
       *
       * {@see #stopAutoRefresh}
       */
      async startAutoRefresh() {
        this._removeVisibilityChangedCallback();
        await this._startAutoRefresh();
      }
      /**
       * Stops an active auto refresh process running in the background (if any).
       *
       * If you call this method any managed visibility change callback will be
       * removed and you must manage visibility changes on your own.
       *
       * See {@link #startAutoRefresh} for more details.
       */
      async stopAutoRefresh() {
        this._removeVisibilityChangedCallback();
        await this._stopAutoRefresh();
      }
      /**
       * Runs the auto refresh token tick.
       */
      async _autoRefreshTokenTick() {
        this._debug("#_autoRefreshTokenTick()", "begin");
        try {
          await this._acquireLock(0, async () => {
            try {
              const now = Date.now();
              try {
                return await this._useSession(async (result) => {
                  const { data: { session } } = result;
                  if (!session || !session.refresh_token || !session.expires_at) {
                    this._debug("#_autoRefreshTokenTick()", "no session");
                    return;
                  }
                  const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION_MS);
                  this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
                  if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                    await this._callRefreshToken(session.refresh_token);
                  }
                });
              } catch (e3) {
                console.error("Auto refresh tick failed with error. This is likely a transient error.", e3);
              }
            } finally {
              this._debug("#_autoRefreshTokenTick()", "end");
            }
          });
        } catch (e3) {
          if (e3.isAcquireTimeout || e3 instanceof LockAcquireTimeoutError) {
            this._debug("auto refresh token tick lock not available");
          } else {
            throw e3;
          }
        }
      }
      /**
       * Registers callbacks on the browser / platform, which in-turn run
       * algorithms when the browser window/tab are in foreground. On non-browser
       * platforms it assumes always foreground.
       */
      async _handleVisibilityChange() {
        this._debug("#_handleVisibilityChange()");
        if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
          if (this.autoRefreshToken) {
            this.startAutoRefresh();
          }
          return false;
        }
        try {
          this.visibilityChangedCallback = async () => {
            try {
              await this._onVisibilityChanged(false);
            } catch (error2) {
              this._debug("#visibilityChangedCallback", "error", error2);
            }
          };
          window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
          await this._onVisibilityChanged(true);
        } catch (error2) {
          console.error("_handleVisibilityChange", error2);
        }
      }
      /**
       * Callback registered with `window.addEventListener('visibilitychange')`.
       */
      async _onVisibilityChanged(calledFromInitialize) {
        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
        this._debug(methodName, "visibilityState", document.visibilityState);
        if (document.visibilityState === "visible") {
          if (this.autoRefreshToken) {
            this._startAutoRefresh();
          }
          if (!calledFromInitialize) {
            await this.initializePromise;
            await this._acquireLock(this.lockAcquireTimeout, async () => {
              if (document.visibilityState !== "visible") {
                this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
                return;
              }
              await this._recoverAndRefresh();
            });
          }
        } else if (document.visibilityState === "hidden") {
          if (this.autoRefreshToken) {
            this._stopAutoRefresh();
          }
        }
      }
      /**
       * Generates the relevant login URL for a third-party provider.
       * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
       * @param options.scopes A space-separated list of scopes granted to the OAuth application.
       * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
       */
      async _getUrlForProvider(url, provider, options) {
        const urlParams = [`provider=${encodeURIComponent(provider)}`];
        if (options === null || options === void 0 ? void 0 : options.redirectTo) {
          urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
        }
        if (options === null || options === void 0 ? void 0 : options.scopes) {
          urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
        }
        if (this.flowType === "pkce") {
          const [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
          const flowParams = new URLSearchParams({
            code_challenge: `${encodeURIComponent(codeChallenge)}`,
            code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
          });
          urlParams.push(flowParams.toString());
        }
        if (options === null || options === void 0 ? void 0 : options.queryParams) {
          const query = new URLSearchParams(options.queryParams);
          urlParams.push(query.toString());
        }
        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
          urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
        }
        return `${url}?${urlParams.join("&")}`;
      }
      async _unenroll(params2) {
        try {
          return await this._useSession(async (result) => {
            var _a;
            const { data: sessionData, error: sessionError } = result;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            return await _request(this.fetch, "DELETE", `${this.url}/factors/${params2.factorId}`, {
              headers: this.headers,
              jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
            });
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      async _enroll(params2) {
        try {
          return await this._useSession(async (result) => {
            var _a, _b;
            const { data: sessionData, error: sessionError } = result;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            const body = Object.assign({ friendly_name: params2.friendlyName, factor_type: params2.factorType }, params2.factorType === "phone" ? { phone: params2.phone } : params2.factorType === "totp" ? { issuer: params2.issuer } : {});
            const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/factors`, {
              body,
              headers: this.headers,
              jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
            });
            if (error2) {
              return this._returnResult({ data: null, error: error2 });
            }
            if (params2.factorType === "totp" && data.type === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
              data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
            }
            return this._returnResult({ data, error: null });
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      async _verify(params2) {
        return this._acquireLock(this.lockAcquireTimeout, async () => {
          try {
            return await this._useSession(async (result) => {
              var _a;
              const { data: sessionData, error: sessionError } = result;
              if (sessionError) {
                return this._returnResult({ data: null, error: sessionError });
              }
              const body = Object.assign({ challenge_id: params2.challengeId }, "webauthn" in params2 ? {
                webauthn: Object.assign(Object.assign({}, params2.webauthn), { credential_response: params2.webauthn.type === "create" ? serializeCredentialCreationResponse(params2.webauthn.credential_response) : serializeCredentialRequestResponse(params2.webauthn.credential_response) })
              } : { code: params2.code });
              const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/factors/${params2.factorId}/verify`, {
                body,
                headers: this.headers,
                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
              });
              if (error2) {
                return this._returnResult({ data: null, error: error2 });
              }
              await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
              await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
              return this._returnResult({ data, error: error2 });
            });
          } catch (error2) {
            if (isAuthError(error2)) {
              return this._returnResult({ data: null, error: error2 });
            }
            throw error2;
          }
        });
      }
      async _challenge(params2) {
        return this._acquireLock(this.lockAcquireTimeout, async () => {
          try {
            return await this._useSession(async (result) => {
              var _a;
              const { data: sessionData, error: sessionError } = result;
              if (sessionError) {
                return this._returnResult({ data: null, error: sessionError });
              }
              const response = await _request(this.fetch, "POST", `${this.url}/factors/${params2.factorId}/challenge`, {
                body: params2,
                headers: this.headers,
                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
              });
              if (response.error) {
                return response;
              }
              const { data } = response;
              if (data.type !== "webauthn") {
                return { data, error: null };
              }
              switch (data.webauthn.type) {
                case "create":
                  return {
                    data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialCreationOptions(data.webauthn.credential_options.publicKey) }) }) }),
                    error: null
                  };
                case "request":
                  return {
                    data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialRequestOptions(data.webauthn.credential_options.publicKey) }) }) }),
                    error: null
                  };
              }
            });
          } catch (error2) {
            if (isAuthError(error2)) {
              return this._returnResult({ data: null, error: error2 });
            }
            throw error2;
          }
        });
      }
      /**
       * {@see GoTrueMFAApi#challengeAndVerify}
       */
      async _challengeAndVerify(params2) {
        const { data: challengeData, error: challengeError } = await this._challenge({
          factorId: params2.factorId
        });
        if (challengeError) {
          return this._returnResult({ data: null, error: challengeError });
        }
        return await this._verify({
          factorId: params2.factorId,
          challengeId: challengeData.id,
          code: params2.code
        });
      }
      /**
       * {@see GoTrueMFAApi#listFactors}
       */
      async _listFactors() {
        var _a;
        const { data: { user }, error: userError } = await this.getUser();
        if (userError) {
          return { data: null, error: userError };
        }
        const data = {
          all: [],
          phone: [],
          totp: [],
          webauthn: []
        };
        for (const factor of (_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []) {
          data.all.push(factor);
          if (factor.status === "verified") {
            ;
            data[factor.factor_type].push(factor);
          }
        }
        return {
          data,
          error: null
        };
      }
      /**
       * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
       */
      async _getAuthenticatorAssuranceLevel(jwt) {
        var _a, _b, _c, _d;
        if (jwt) {
          try {
            const { payload: payload2 } = decodeJWT(jwt);
            let currentLevel2 = null;
            if (payload2.aal) {
              currentLevel2 = payload2.aal;
            }
            let nextLevel2 = currentLevel2;
            const { data: { user }, error: userError } = await this.getUser(jwt);
            if (userError) {
              return this._returnResult({ data: null, error: userError });
            }
            const verifiedFactors2 = (_b = (_a = user === null || user === void 0 ? void 0 : user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
            if (verifiedFactors2.length > 0) {
              nextLevel2 = "aal2";
            }
            const currentAuthenticationMethods2 = payload2.amr || [];
            return { data: { currentLevel: currentLevel2, nextLevel: nextLevel2, currentAuthenticationMethods: currentAuthenticationMethods2 }, error: null };
          } catch (error2) {
            if (isAuthError(error2)) {
              return this._returnResult({ data: null, error: error2 });
            }
            throw error2;
          }
        }
        const { data: { session }, error: sessionError } = await this.getSession();
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return {
            data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
            error: null
          };
        }
        const { payload } = decodeJWT(session.access_token);
        let currentLevel = null;
        if (payload.aal) {
          currentLevel = payload.aal;
        }
        let nextLevel = currentLevel;
        const verifiedFactors = (_d = (_c = session.user.factors) === null || _c === void 0 ? void 0 : _c.filter((factor) => factor.status === "verified")) !== null && _d !== void 0 ? _d : [];
        if (verifiedFactors.length > 0) {
          nextLevel = "aal2";
        }
        const currentAuthenticationMethods = payload.amr || [];
        return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
      }
      /**
       * Retrieves details about an OAuth authorization request.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       *
       * Returns authorization details including client info, scopes, and user information.
       * If the response includes only a redirect_url field, it means consent was already given - the caller
       * should handle the redirect manually if needed.
       */
      async _getAuthorizationDetails(authorizationId) {
        try {
          return await this._useSession(async (result) => {
            const { data: { session }, error: sessionError } = result;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            if (!session) {
              return this._returnResult({ data: null, error: new AuthSessionMissingError() });
            }
            return await _request(this.fetch, "GET", `${this.url}/oauth/authorizations/${authorizationId}`, {
              headers: this.headers,
              jwt: session.access_token,
              xform: (data) => ({ data, error: null })
            });
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Approves an OAuth authorization request.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       */
      async _approveAuthorization(authorizationId, options) {
        try {
          return await this._useSession(async (result) => {
            const { data: { session }, error: sessionError } = result;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            if (!session) {
              return this._returnResult({ data: null, error: new AuthSessionMissingError() });
            }
            const response = await _request(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
              headers: this.headers,
              jwt: session.access_token,
              body: { action: "approve" },
              xform: (data) => ({ data, error: null })
            });
            if (response.data && response.data.redirect_url) {
              if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
                window.location.assign(response.data.redirect_url);
              }
            }
            return response;
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Denies an OAuth authorization request.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       */
      async _denyAuthorization(authorizationId, options) {
        try {
          return await this._useSession(async (result) => {
            const { data: { session }, error: sessionError } = result;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            if (!session) {
              return this._returnResult({ data: null, error: new AuthSessionMissingError() });
            }
            const response = await _request(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
              headers: this.headers,
              jwt: session.access_token,
              body: { action: "deny" },
              xform: (data) => ({ data, error: null })
            });
            if (response.data && response.data.redirect_url) {
              if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
                window.location.assign(response.data.redirect_url);
              }
            }
            return response;
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Lists all OAuth grants that the authenticated user has authorized.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       */
      async _listOAuthGrants() {
        try {
          return await this._useSession(async (result) => {
            const { data: { session }, error: sessionError } = result;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            if (!session) {
              return this._returnResult({ data: null, error: new AuthSessionMissingError() });
            }
            return await _request(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
              headers: this.headers,
              jwt: session.access_token,
              xform: (data) => ({ data, error: null })
            });
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      /**
       * Revokes a user's OAuth grant for a specific client.
       * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
       */
      async _revokeOAuthGrant(options) {
        try {
          return await this._useSession(async (result) => {
            const { data: { session }, error: sessionError } = result;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            if (!session) {
              return this._returnResult({ data: null, error: new AuthSessionMissingError() });
            }
            await _request(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
              headers: this.headers,
              jwt: session.access_token,
              query: { client_id: options.clientId },
              noResolveJson: true
            });
            return { data: {}, error: null };
          });
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
      async fetchJwk(kid, jwks = { keys: [] }) {
        let jwk = jwks.keys.find((key) => key.kid === kid);
        if (jwk) {
          return jwk;
        }
        const now = Date.now();
        jwk = this.jwks.keys.find((key) => key.kid === kid);
        if (jwk && this.jwks_cached_at + JWKS_TTL > now) {
          return jwk;
        }
        const { data, error: error2 } = await _request(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
          headers: this.headers
        });
        if (error2) {
          throw error2;
        }
        if (!data.keys || data.keys.length === 0) {
          return null;
        }
        this.jwks = data;
        this.jwks_cached_at = now;
        jwk = data.keys.find((key) => key.kid === kid);
        if (!jwk) {
          return null;
        }
        return jwk;
      }
      /**
       * Extracts the JWT claims present in the access token by first verifying the
       * JWT against the server's JSON Web Key Set endpoint
       * `/.well-known/jwks.json` which is often cached, resulting in significantly
       * faster responses. Prefer this method over {@link #getUser} which always
       * sends a request to the Auth server for each JWT.
       *
       * If the project is not using an asymmetric JWT signing key (like ECC or
       * RSA) it always sends a request to the Auth server (similar to {@link
       * #getUser}) to verify the JWT.
       *
       * @param jwt An optional specific JWT you wish to verify, not the one you
       *            can obtain from {@link #getSession}.
       * @param options Various additional options that allow you to customize the
       *                behavior of this method.
       */
      async getClaims(jwt, options = {}) {
        try {
          let token = jwt;
          if (!token) {
            const { data, error: error2 } = await this.getSession();
            if (error2 || !data.session) {
              return this._returnResult({ data: null, error: error2 });
            }
            token = data.session.access_token;
          }
          const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = decodeJWT(token);
          if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {
            validateExp(payload.exp);
          }
          const signingKey = !header.alg || header.alg.startsWith("HS") || !header.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? { keys: options.keys } : options === null || options === void 0 ? void 0 : options.jwks);
          if (!signingKey) {
            const { error: error2 } = await this.getUser(token);
            if (error2) {
              throw error2;
            }
            return {
              data: {
                claims: payload,
                header,
                signature
              },
              error: null
            };
          }
          const algorithm = getAlgorithm(header.alg);
          const publicKey = await crypto.subtle.importKey("jwk", signingKey, algorithm, true, [
            "verify"
          ]);
          const isValid2 = await crypto.subtle.verify(algorithm, publicKey, signature, stringToUint8Array(`${rawHeader}.${rawPayload}`));
          if (!isValid2) {
            throw new AuthInvalidJwtError("Invalid JWT signature");
          }
          return {
            data: {
              claims: payload,
              header,
              signature
            },
            error: null
          };
        } catch (error2) {
          if (isAuthError(error2)) {
            return this._returnResult({ data: null, error: error2 });
          }
          throw error2;
        }
      }
    };
    GoTrueClient.nextInstanceID = {};
    GoTrueClient_default = GoTrueClient;
  }
});

// node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js
var init_AuthAdminApi = __esm({
  "node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js"() {
    init_GoTrueAdminApi();
  }
});

// node_modules/@supabase/auth-js/dist/module/AuthClient.js
var AuthClient, AuthClient_default;
var init_AuthClient = __esm({
  "node_modules/@supabase/auth-js/dist/module/AuthClient.js"() {
    init_GoTrueClient();
    AuthClient = GoTrueClient_default;
    AuthClient_default = AuthClient;
  }
});

// node_modules/@supabase/auth-js/dist/module/index.js
var init_module3 = __esm({
  "node_modules/@supabase/auth-js/dist/module/index.js"() {
    init_GoTrueAdminApi();
    init_GoTrueClient();
    init_AuthAdminApi();
    init_AuthClient();
    init_types2();
    init_errors();
    init_locks();
  }
});

// node_modules/@supabase/supabase-js/dist/index.mjs
function _typeof3(o5) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
    return typeof o$1;
  } : function(o$1) {
    return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
  }, _typeof3(o5);
}
function toPrimitive3(t4, r5) {
  if ("object" != _typeof3(t4) || !t4) return t4;
  var e3 = t4[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i7 = e3.call(t4, r5 || "default");
    if ("object" != _typeof3(i7)) return i7;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r5 ? String : Number)(t4);
}
function toPropertyKey3(t4) {
  var i7 = toPrimitive3(t4, "string");
  return "symbol" == _typeof3(i7) ? i7 : i7 + "";
}
function _defineProperty3(e3, r5, t4) {
  return (r5 = toPropertyKey3(r5)) in e3 ? Object.defineProperty(e3, r5, {
    value: t4,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r5] = t4, e3;
}
function ownKeys3(e3, r5) {
  var t4 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o5 = Object.getOwnPropertySymbols(e3);
    r5 && (o5 = o5.filter(function(r$1) {
      return Object.getOwnPropertyDescriptor(e3, r$1).enumerable;
    })), t4.push.apply(t4, o5);
  }
  return t4;
}
function _objectSpread23(e3) {
  for (var r5 = 1; r5 < arguments.length; r5++) {
    var t4 = null != arguments[r5] ? arguments[r5] : {};
    r5 % 2 ? ownKeys3(Object(t4), true).forEach(function(r$1) {
      _defineProperty3(e3, r$1, t4[r$1]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t4)) : ownKeys3(Object(t4)).forEach(function(r$1) {
      Object.defineProperty(e3, r$1, Object.getOwnPropertyDescriptor(t4, r$1));
    });
  }
  return e3;
}
function ensureTrailingSlash(url) {
  return url.endsWith("/") ? url : url + "/";
}
function applySettingDefaults(options, defaults) {
  var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;
  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
  const { db: DEFAULT_DB_OPTIONS$1, auth: DEFAULT_AUTH_OPTIONS$1, realtime: DEFAULT_REALTIME_OPTIONS$1, global: DEFAULT_GLOBAL_OPTIONS$1 } = defaults;
  const result = {
    db: _objectSpread23(_objectSpread23({}, DEFAULT_DB_OPTIONS$1), dbOptions),
    auth: _objectSpread23(_objectSpread23({}, DEFAULT_AUTH_OPTIONS$1), authOptions),
    realtime: _objectSpread23(_objectSpread23({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions),
    storage: {},
    global: _objectSpread23(_objectSpread23(_objectSpread23({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, { headers: _objectSpread23(_objectSpread23({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {}) }),
    accessToken: async () => ""
  };
  if (options.accessToken) result.accessToken = options.accessToken;
  else delete result.accessToken;
  return result;
}
function validateSupabaseUrl(supabaseUrl) {
  const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();
  if (!trimmedUrl) throw new Error("supabaseUrl is required.");
  if (!trimmedUrl.match(/^https?:\/\//i)) throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
  try {
    return new URL(ensureTrailingSlash(trimmedUrl));
  } catch (_unused) {
    throw Error("Invalid supabaseUrl: Provided URL is malformed.");
  }
}
function shouldShowDeprecationWarning() {
  if (typeof window !== "undefined") return false;
  const _process = globalThis["process"];
  if (!_process) return false;
  const processVersion = _process["version"];
  if (processVersion === void 0 || processVersion === null) return false;
  const versionMatch = processVersion.match(/^v(\d+)\./);
  if (!versionMatch) return false;
  return parseInt(versionMatch[1], 10) <= 18;
}
var version4, JS_ENV, DEFAULT_HEADERS3, DEFAULT_GLOBAL_OPTIONS, DEFAULT_DB_OPTIONS, DEFAULT_AUTH_OPTIONS, DEFAULT_REALTIME_OPTIONS, resolveFetch4, resolveHeadersConstructor, fetchWithAuth, SupabaseAuthClient, SupabaseClient, createClient;
var init_dist4 = __esm({
  "node_modules/@supabase/supabase-js/dist/index.mjs"() {
    init_module();
    init_dist();
    init_module2();
    init_dist3();
    init_module3();
    init_module2();
    init_module3();
    version4 = "2.95.3";
    JS_ENV = "";
    if (typeof Deno !== "undefined") JS_ENV = "deno";
    else if (typeof document !== "undefined") JS_ENV = "web";
    else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") JS_ENV = "react-native";
    else JS_ENV = "node";
    DEFAULT_HEADERS3 = { "X-Client-Info": `supabase-js-${JS_ENV}/${version4}` };
    DEFAULT_GLOBAL_OPTIONS = { headers: DEFAULT_HEADERS3 };
    DEFAULT_DB_OPTIONS = { schema: "public" };
    DEFAULT_AUTH_OPTIONS = {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      flowType: "implicit"
    };
    DEFAULT_REALTIME_OPTIONS = {};
    resolveFetch4 = (customFetch) => {
      if (customFetch) return (...args) => customFetch(...args);
      return (...args) => fetch(...args);
    };
    resolveHeadersConstructor = () => {
      return Headers;
    };
    fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
      const fetch$1 = resolveFetch4(customFetch);
      const HeadersConstructor = resolveHeadersConstructor();
      return async (input, init35) => {
        var _await$getAccessToken;
        const accessToken = (_await$getAccessToken = await getAccessToken()) !== null && _await$getAccessToken !== void 0 ? _await$getAccessToken : supabaseKey;
        let headers = new HeadersConstructor(init35 === null || init35 === void 0 ? void 0 : init35.headers);
        if (!headers.has("apikey")) headers.set("apikey", supabaseKey);
        if (!headers.has("Authorization")) headers.set("Authorization", `Bearer ${accessToken}`);
        return fetch$1(input, _objectSpread23(_objectSpread23({}, init35), {}, { headers }));
      };
    };
    SupabaseAuthClient = class extends AuthClient_default {
      constructor(options) {
        super(options);
      }
    };
    SupabaseClient = class {
      /**
      * Create a new client for use in the browser.
      * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
      * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
      * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
      * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
      * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
      * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
      * @param options.realtime Options passed along to realtime-js constructor.
      * @param options.storage Options passed along to the storage-js constructor.
      * @param options.global.fetch A custom fetch implementation.
      * @param options.global.headers Any additional headers to send with each network request.
      * @example
      * ```ts
      * import { createClient } from '@supabase/supabase-js'
      *
      * const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
      * const { data } = await supabase.from('profiles').select('*')
      * ```
      */
      constructor(supabaseUrl, supabaseKey, options) {
        var _settings$auth$storag, _settings$global$head;
        this.supabaseUrl = supabaseUrl;
        this.supabaseKey = supabaseKey;
        const baseUrl = validateSupabaseUrl(supabaseUrl);
        if (!supabaseKey) throw new Error("supabaseKey is required.");
        this.realtimeUrl = new URL("realtime/v1", baseUrl);
        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
        this.authUrl = new URL("auth/v1", baseUrl);
        this.storageUrl = new URL("storage/v1", baseUrl);
        this.functionsUrl = new URL("functions/v1", baseUrl);
        const defaultStorageKey = `sb-${baseUrl.hostname.split(".")[0]}-auth-token`;
        const DEFAULTS = {
          db: DEFAULT_DB_OPTIONS,
          realtime: DEFAULT_REALTIME_OPTIONS,
          auth: _objectSpread23(_objectSpread23({}, DEFAULT_AUTH_OPTIONS), {}, { storageKey: defaultStorageKey }),
          global: DEFAULT_GLOBAL_OPTIONS
        };
        const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
        this.storageKey = (_settings$auth$storag = settings.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : "";
        this.headers = (_settings$global$head = settings.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};
        if (!settings.accessToken) {
          var _settings$auth;
          this.auth = this._initSupabaseAuthClient((_settings$auth = settings.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, settings.global.fetch);
        } else {
          this.accessToken = settings.accessToken;
          this.auth = new Proxy({}, { get: (_5, prop) => {
            throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
          } });
        }
        this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
        this.realtime = this._initRealtimeClient(_objectSpread23({
          headers: this.headers,
          accessToken: this._getAccessToken.bind(this)
        }, settings.realtime));
        if (this.accessToken) Promise.resolve(this.accessToken()).then((token) => this.realtime.setAuth(token)).catch((e3) => console.warn("Failed to set initial Realtime auth token:", e3));
        this.rest = new PostgrestClient(new URL("rest/v1", baseUrl).href, {
          headers: this.headers,
          schema: settings.db.schema,
          fetch: this.fetch,
          timeout: settings.db.timeout,
          urlLengthLimit: settings.db.urlLengthLimit
        });
        this.storage = new StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
        if (!settings.accessToken) this._listenForAuthEvents();
      }
      /**
      * Supabase Functions allows you to deploy and invoke edge functions.
      */
      get functions() {
        return new FunctionsClient(this.functionsUrl.href, {
          headers: this.headers,
          customFetch: this.fetch
        });
      }
      /**
      * Perform a query on a table or a view.
      *
      * @param relation - The table or view name to query
      */
      from(relation) {
        return this.rest.from(relation);
      }
      /**
      * Select a schema to query or perform an function (rpc) call.
      *
      * The schema needs to be on the list of exposed schemas inside Supabase.
      *
      * @param schema - The schema to query
      */
      schema(schema) {
        return this.rest.schema(schema);
      }
      /**
      * Perform a function call.
      *
      * @param fn - The function name to call
      * @param args - The arguments to pass to the function call
      * @param options - Named parameters
      * @param options.head - When set to `true`, `data` will not be returned.
      * Useful if you only need the count.
      * @param options.get - When set to `true`, the function will be called with
      * read-only access mode.
      * @param options.count - Count algorithm to use to count rows returned by the
      * function. Only applicable for [set-returning
      * functions](https://www.postgresql.org/docs/current/functions-srf.html).
      *
      * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
      * hood.
      *
      * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
      * statistics under the hood.
      *
      * `"estimated"`: Uses exact count for low numbers and planned count for high
      * numbers.
      */
      rpc(fn4, args = {}, options = {
        head: false,
        get: false,
        count: void 0
      }) {
        return this.rest.rpc(fn4, args, options);
      }
      /**
      * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
      *
      * @param {string} name - The name of the Realtime channel.
      * @param {Object} opts - The options to pass to the Realtime channel.
      *
      */
      channel(name, opts = { config: {} }) {
        return this.realtime.channel(name, opts);
      }
      /**
      * Returns all Realtime channels.
      */
      getChannels() {
        return this.realtime.getChannels();
      }
      /**
      * Unsubscribes and removes Realtime channel from Realtime client.
      *
      * @param {RealtimeChannel} channel - The name of the Realtime channel.
      *
      */
      removeChannel(channel) {
        return this.realtime.removeChannel(channel);
      }
      /**
      * Unsubscribes and removes all Realtime channels from Realtime client.
      */
      removeAllChannels() {
        return this.realtime.removeAllChannels();
      }
      async _getAccessToken() {
        var _this = this;
        var _data$session$access_, _data$session;
        if (_this.accessToken) return await _this.accessToken();
        const { data } = await _this.auth.getSession();
        return (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : _this.supabaseKey;
      }
      _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch$1) {
        const authHeaders = {
          Authorization: `Bearer ${this.supabaseKey}`,
          apikey: `${this.supabaseKey}`
        };
        return new SupabaseAuthClient({
          url: this.authUrl.href,
          headers: _objectSpread23(_objectSpread23({}, authHeaders), headers),
          storageKey,
          autoRefreshToken,
          persistSession,
          detectSessionInUrl,
          storage,
          userStorage,
          flowType,
          lock,
          debug,
          throwOnError,
          fetch: fetch$1,
          hasCustomAuthorizationHeader: Object.keys(this.headers).some((key) => key.toLowerCase() === "authorization")
        });
      }
      _initRealtimeClient(options) {
        return new RealtimeClient(this.realtimeUrl.href, _objectSpread23(_objectSpread23({}, options), {}, { params: _objectSpread23(_objectSpread23({}, { apikey: this.supabaseKey }), options === null || options === void 0 ? void 0 : options.params) }));
      }
      _listenForAuthEvents() {
        return this.auth.onAuthStateChange((event, session) => {
          this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
        });
      }
      _handleTokenChanged(event, source, token) {
        if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
          this.changedAccessToken = token;
          this.realtime.setAuth(token);
        } else if (event === "SIGNED_OUT") {
          this.realtime.setAuth();
          if (source == "STORAGE") this.auth.signOut();
          this.changedAccessToken = void 0;
        }
      }
    };
    createClient = (supabaseUrl, supabaseKey, options) => {
      return new SupabaseClient(supabaseUrl, supabaseKey, options);
    };
    if (shouldShowDeprecationWarning()) console.warn("\u26A0\uFE0F  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
  }
});

// node_modules/@supabase/ssr/dist/module/version.js
var VERSION2;
var init_version4 = __esm({
  "node_modules/@supabase/ssr/dist/module/version.js"() {
    VERSION2 = "0.8.0";
  }
});

// node_modules/@supabase/ssr/node_modules/cookie/dist/index.js
var require_dist = __commonJS({
  "node_modules/@supabase/ssr/node_modules/cookie/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCookie = parseCookie;
    exports.parse = parseCookie;
    exports.stringifyCookie = stringifyCookie;
    exports.stringifySetCookie = stringifySetCookie;
    exports.serialize = stringifySetCookie;
    exports.parseSetCookie = parseSetCookie;
    exports.stringifySetCookie = stringifySetCookie;
    exports.serialize = stringifySetCookie;
    var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
    var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    var maxAgeRegExp = /^-?\d+$/;
    var __toString = Object.prototype.toString;
    var NullObject = /* @__PURE__ */ (() => {
      const C6 = function() {
      };
      C6.prototype = /* @__PURE__ */ Object.create(null);
      return C6;
    })();
    function parseCookie(str, options) {
      const obj = new NullObject();
      const len = str.length;
      if (len < 2)
        return obj;
      const dec = options?.decode || decode2;
      let index13 = 0;
      do {
        const eqIdx = eqIndex(str, index13, len);
        if (eqIdx === -1)
          break;
        const endIdx = endIndex(str, index13, len);
        if (eqIdx > endIdx) {
          index13 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const key = valueSlice(str, index13, eqIdx);
        if (obj[key] === void 0) {
          obj[key] = dec(valueSlice(str, eqIdx + 1, endIdx));
        }
        index13 = endIdx + 1;
      } while (index13 < len);
      return obj;
    }
    function stringifyCookie(cookie, options) {
      const enc = options?.encode || encodeURIComponent;
      const cookieStrings = [];
      for (const name of Object.keys(cookie)) {
        const val = cookie[name];
        if (val === void 0)
          continue;
        if (!cookieNameRegExp.test(name)) {
          throw new TypeError(`cookie name is invalid: ${name}`);
        }
        const value = enc(val);
        if (!cookieValueRegExp.test(value)) {
          throw new TypeError(`cookie val is invalid: ${val}`);
        }
        cookieStrings.push(`${name}=${value}`);
      }
      return cookieStrings.join("; ");
    }
    function stringifySetCookie(_name, _val, _opts) {
      const cookie = typeof _name === "object" ? _name : { ..._opts, name: _name, value: String(_val) };
      const options = typeof _val === "object" ? _val : _opts;
      const enc = options?.encode || encodeURIComponent;
      if (!cookieNameRegExp.test(cookie.name)) {
        throw new TypeError(`argument name is invalid: ${cookie.name}`);
      }
      const value = cookie.value ? enc(cookie.value) : "";
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${cookie.value}`);
      }
      let str = cookie.name + "=" + value;
      if (cookie.maxAge !== void 0) {
        if (!Number.isInteger(cookie.maxAge)) {
          throw new TypeError(`option maxAge is invalid: ${cookie.maxAge}`);
        }
        str += "; Max-Age=" + cookie.maxAge;
      }
      if (cookie.domain) {
        if (!domainValueRegExp.test(cookie.domain)) {
          throw new TypeError(`option domain is invalid: ${cookie.domain}`);
        }
        str += "; Domain=" + cookie.domain;
      }
      if (cookie.path) {
        if (!pathValueRegExp.test(cookie.path)) {
          throw new TypeError(`option path is invalid: ${cookie.path}`);
        }
        str += "; Path=" + cookie.path;
      }
      if (cookie.expires) {
        if (!isDate(cookie.expires) || !Number.isFinite(cookie.expires.valueOf())) {
          throw new TypeError(`option expires is invalid: ${cookie.expires}`);
        }
        str += "; Expires=" + cookie.expires.toUTCString();
      }
      if (cookie.httpOnly) {
        str += "; HttpOnly";
      }
      if (cookie.secure) {
        str += "; Secure";
      }
      if (cookie.partitioned) {
        str += "; Partitioned";
      }
      if (cookie.priority) {
        const priority = typeof cookie.priority === "string" ? cookie.priority.toLowerCase() : void 0;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError(`option priority is invalid: ${cookie.priority}`);
        }
      }
      if (cookie.sameSite) {
        const sameSite = typeof cookie.sameSite === "string" ? cookie.sameSite.toLowerCase() : cookie.sameSite;
        switch (sameSite) {
          case true:
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError(`option sameSite is invalid: ${cookie.sameSite}`);
        }
      }
      return str;
    }
    function parseSetCookie(str, options) {
      const dec = options?.decode || decode2;
      const len = str.length;
      const endIdx = endIndex(str, 0, len);
      const eqIdx = eqIndex(str, 0, endIdx);
      const setCookie = eqIdx === -1 ? { name: "", value: dec(valueSlice(str, 0, endIdx)) } : {
        name: valueSlice(str, 0, eqIdx),
        value: dec(valueSlice(str, eqIdx + 1, endIdx))
      };
      let index13 = endIdx + 1;
      while (index13 < len) {
        const endIdx2 = endIndex(str, index13, len);
        const eqIdx2 = eqIndex(str, index13, endIdx2);
        const attr = eqIdx2 === -1 ? valueSlice(str, index13, endIdx2) : valueSlice(str, index13, eqIdx2);
        const val = eqIdx2 === -1 ? void 0 : valueSlice(str, eqIdx2 + 1, endIdx2);
        switch (attr.toLowerCase()) {
          case "httponly":
            setCookie.httpOnly = true;
            break;
          case "secure":
            setCookie.secure = true;
            break;
          case "partitioned":
            setCookie.partitioned = true;
            break;
          case "domain":
            setCookie.domain = val;
            break;
          case "path":
            setCookie.path = val;
            break;
          case "max-age":
            if (val && maxAgeRegExp.test(val))
              setCookie.maxAge = Number(val);
            break;
          case "expires":
            if (!val)
              break;
            const date = new Date(val);
            if (Number.isFinite(date.valueOf()))
              setCookie.expires = date;
            break;
          case "priority":
            if (!val)
              break;
            const priority = val.toLowerCase();
            if (priority === "low" || priority === "medium" || priority === "high") {
              setCookie.priority = priority;
            }
            break;
          case "samesite":
            if (!val)
              break;
            const sameSite = val.toLowerCase();
            if (sameSite === "lax" || sameSite === "strict" || sameSite === "none") {
              setCookie.sameSite = sameSite;
            }
            break;
        }
        index13 = endIdx2 + 1;
      }
      return setCookie;
    }
    function endIndex(str, min, len) {
      const index13 = str.indexOf(";", min);
      return index13 === -1 ? len : index13;
    }
    function eqIndex(str, min, max) {
      const index13 = str.indexOf("=", min);
      return index13 < max ? index13 : -1;
    }
    function valueSlice(str, min, max) {
      let start2 = min;
      let end = max;
      do {
        const code = str.charCodeAt(start2);
        if (code !== 32 && code !== 9)
          break;
      } while (++start2 < end);
      while (end > start2) {
        const code = str.charCodeAt(end - 1);
        if (code !== 32 && code !== 9)
          break;
        end--;
      }
      return str.slice(start2, end);
    }
    function decode2(str) {
      if (str.indexOf("%") === -1)
        return str;
      try {
        return decodeURIComponent(str);
      } catch (e3) {
        return str;
      }
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]";
    }
  }
});

// node_modules/@supabase/ssr/dist/module/utils/helpers.js
function isBrowser2() {
  return typeof window !== "undefined" && typeof window.document !== "undefined";
}
function memoryLocalStorageAdapter2(store = {}) {
  return {
    getItem: (key) => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
}
var init_helpers2 = __esm({
  "node_modules/@supabase/ssr/dist/module/utils/helpers.js"() {
  }
});

// node_modules/@supabase/ssr/dist/module/utils/constants.js
var DEFAULT_COOKIE_OPTIONS;
var init_constants4 = __esm({
  "node_modules/@supabase/ssr/dist/module/utils/constants.js"() {
    DEFAULT_COOKIE_OPTIONS = {
      path: "/",
      sameSite: "lax",
      httpOnly: false,
      // https://developer.chrome.com/blog/cookie-max-age-expires
      // https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#name-cookie-lifetime-limits
      maxAge: 400 * 24 * 60 * 60
    };
  }
});

// node_modules/@supabase/ssr/dist/module/utils/chunker.js
function isChunkLike(cookieName, key) {
  if (cookieName === key) {
    return true;
  }
  const chunkLike = cookieName.match(CHUNK_LIKE_REGEX);
  if (chunkLike && chunkLike[1] === key) {
    return true;
  }
  return false;
}
function createChunks(key, value, chunkSize) {
  const resolvedChunkSize = chunkSize ?? MAX_CHUNK_SIZE;
  let encodedValue = encodeURIComponent(value);
  if (encodedValue.length <= resolvedChunkSize) {
    return [{ name: key, value }];
  }
  const chunks = [];
  while (encodedValue.length > 0) {
    let encodedChunkHead = encodedValue.slice(0, resolvedChunkSize);
    const lastEscapePos = encodedChunkHead.lastIndexOf("%");
    if (lastEscapePos > resolvedChunkSize - 3) {
      encodedChunkHead = encodedChunkHead.slice(0, lastEscapePos);
    }
    let valueHead = "";
    while (encodedChunkHead.length > 0) {
      try {
        valueHead = decodeURIComponent(encodedChunkHead);
        break;
      } catch (error2) {
        if (error2 instanceof URIError && encodedChunkHead.at(-3) === "%" && encodedChunkHead.length > 3) {
          encodedChunkHead = encodedChunkHead.slice(0, encodedChunkHead.length - 3);
        } else {
          throw error2;
        }
      }
    }
    chunks.push(valueHead);
    encodedValue = encodedValue.slice(encodedChunkHead.length);
  }
  return chunks.map((value2, i7) => ({ name: `${key}.${i7}`, value: value2 }));
}
async function combineChunks(key, retrieveChunk) {
  const value = await retrieveChunk(key);
  if (value) {
    return value;
  }
  let values = [];
  for (let i7 = 0; ; i7++) {
    const chunkName = `${key}.${i7}`;
    const chunk = await retrieveChunk(chunkName);
    if (!chunk) {
      break;
    }
    values.push(chunk);
  }
  if (values.length > 0) {
    return values.join("");
  }
  return null;
}
var MAX_CHUNK_SIZE, CHUNK_LIKE_REGEX;
var init_chunker = __esm({
  "node_modules/@supabase/ssr/dist/module/utils/chunker.js"() {
    MAX_CHUNK_SIZE = 3180;
    CHUNK_LIKE_REGEX = /^(.*)[.](0|[1-9][0-9]*)$/;
  }
});

// node_modules/@supabase/ssr/dist/module/utils/base64url.js
function stringToBase64URL(str) {
  const base64 = [];
  let queue = 0;
  let queuedBits = 0;
  const emitter = (byte) => {
    queue = queue << 8 | byte;
    queuedBits += 8;
    while (queuedBits >= 6) {
      const pos = queue >> queuedBits - 6 & 63;
      base64.push(TO_BASE64URL2[pos]);
      queuedBits -= 6;
    }
  };
  stringToUTF82(str, emitter);
  if (queuedBits > 0) {
    queue = queue << 6 - queuedBits;
    queuedBits = 6;
    while (queuedBits >= 6) {
      const pos = queue >> queuedBits - 6 & 63;
      base64.push(TO_BASE64URL2[pos]);
      queuedBits -= 6;
    }
  }
  return base64.join("");
}
function stringFromBase64URL2(str) {
  const conv = [];
  const emit = (codepoint) => {
    conv.push(String.fromCodePoint(codepoint));
  };
  const state = {
    utf8seq: 0,
    codepoint: 0
  };
  let queue = 0;
  let queuedBits = 0;
  for (let i7 = 0; i7 < str.length; i7 += 1) {
    const codepoint = str.charCodeAt(i7);
    const bits = FROM_BASE64URL2[codepoint];
    if (bits > -1) {
      queue = queue << 6 | bits;
      queuedBits += 6;
      while (queuedBits >= 8) {
        stringFromUTF82(queue >> queuedBits - 8 & 255, state, emit);
        queuedBits -= 8;
      }
    } else if (bits === -2) {
      continue;
    } else {
      throw new Error(`Invalid Base64-URL character "${str.at(i7)}" at position ${i7}`);
    }
  }
  return conv.join("");
}
function codepointToUTF82(codepoint, emit) {
  if (codepoint <= 127) {
    emit(codepoint);
    return;
  } else if (codepoint <= 2047) {
    emit(192 | codepoint >> 6);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 65535) {
    emit(224 | codepoint >> 12);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 1114111) {
    emit(240 | codepoint >> 18);
    emit(128 | codepoint >> 12 & 63);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
}
function stringToUTF82(str, emit) {
  for (let i7 = 0; i7 < str.length; i7 += 1) {
    let codepoint = str.charCodeAt(i7);
    if (codepoint > 55295 && codepoint <= 56319) {
      const highSurrogate = (codepoint - 55296) * 1024 & 65535;
      const lowSurrogate = str.charCodeAt(i7 + 1) - 56320 & 65535;
      codepoint = (lowSurrogate | highSurrogate) + 65536;
      i7 += 1;
    }
    codepointToUTF82(codepoint, emit);
  }
}
function stringFromUTF82(byte, state, emit) {
  if (state.utf8seq === 0) {
    if (byte <= 127) {
      emit(byte);
      return;
    }
    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {
      if ((byte >> 7 - leadingBit & 1) === 0) {
        state.utf8seq = leadingBit;
        break;
      }
    }
    if (state.utf8seq === 2) {
      state.codepoint = byte & 31;
    } else if (state.utf8seq === 3) {
      state.codepoint = byte & 15;
    } else if (state.utf8seq === 4) {
      state.codepoint = byte & 7;
    } else {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.utf8seq -= 1;
  } else if (state.utf8seq > 0) {
    if (byte <= 127) {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.codepoint = state.codepoint << 6 | byte & 63;
    state.utf8seq -= 1;
    if (state.utf8seq === 0) {
      emit(state.codepoint);
    }
  }
}
var TO_BASE64URL2, IGNORE_BASE64URL2, FROM_BASE64URL2;
var init_base64url2 = __esm({
  "node_modules/@supabase/ssr/dist/module/utils/base64url.js"() {
    TO_BASE64URL2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("");
    IGNORE_BASE64URL2 = " 	\n\r=".split("");
    FROM_BASE64URL2 = (() => {
      const charMap = new Array(128);
      for (let i7 = 0; i7 < charMap.length; i7 += 1) {
        charMap[i7] = -1;
      }
      for (let i7 = 0; i7 < IGNORE_BASE64URL2.length; i7 += 1) {
        charMap[IGNORE_BASE64URL2[i7].charCodeAt(0)] = -2;
      }
      for (let i7 = 0; i7 < TO_BASE64URL2.length; i7 += 1) {
        charMap[TO_BASE64URL2[i7].charCodeAt(0)] = i7;
      }
      return charMap;
    })();
  }
});

// node_modules/@supabase/ssr/dist/module/utils/index.js
var init_utils3 = __esm({
  "node_modules/@supabase/ssr/dist/module/utils/index.js"() {
    init_helpers2();
    init_constants4();
    init_chunker();
    init_base64url2();
  }
});

// node_modules/@supabase/ssr/dist/module/cookies.js
function createStorageFromOptions(options, isServerClient) {
  const cookies = options.cookies ?? null;
  const cookieEncoding = options.cookieEncoding;
  const setItems = {};
  const removedItems = {};
  let getAll;
  let setAll;
  if (cookies) {
    if ("get" in cookies) {
      const getWithHints = async (keyHints) => {
        const chunkNames = keyHints.flatMap((keyHint) => [
          keyHint,
          ...Array.from({ length: 5 }).map((_5, i7) => `${keyHint}.${i7}`)
        ]);
        const chunks = [];
        for (let i7 = 0; i7 < chunkNames.length; i7 += 1) {
          const value = await cookies.get(chunkNames[i7]);
          if (!value && typeof value !== "string") {
            continue;
          }
          chunks.push({ name: chunkNames[i7], value });
        }
        return chunks;
      };
      getAll = async (keyHints) => await getWithHints(keyHints);
      if ("set" in cookies && "remove" in cookies) {
        setAll = async (setCookies) => {
          for (let i7 = 0; i7 < setCookies.length; i7 += 1) {
            const { name, value, options: options2 } = setCookies[i7];
            if (value) {
              await cookies.set(name, value, options2);
            } else {
              await cookies.remove(name, options2);
            }
          }
        };
      } else if (isServerClient) {
        setAll = async () => {
          console.warn("@supabase/ssr: createServerClient was configured without set and remove cookie methods, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness. Consider switching to the getAll and setAll cookie methods instead of get, set and remove which are deprecated and can be difficult to use correctly.");
        };
      } else {
        throw new Error("@supabase/ssr: createBrowserClient requires configuring a getAll and setAll cookie method (deprecated: alternatively both get, set and remove can be used)");
      }
    } else if ("getAll" in cookies) {
      getAll = async () => await cookies.getAll();
      if ("setAll" in cookies) {
        setAll = cookies.setAll;
      } else if (isServerClient) {
        setAll = async () => {
          console.warn("@supabase/ssr: createServerClient was configured without the setAll cookie method, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness.");
        };
      } else {
        throw new Error("@supabase/ssr: createBrowserClient requires configuring both getAll and setAll cookie methods (deprecated: alternatively both get, set and remove can be used)");
      }
    } else {
      throw new Error(`@supabase/ssr: ${isServerClient ? "createServerClient" : "createBrowserClient"} requires configuring getAll and setAll cookie methods (deprecated: alternatively use get, set and remove).${isBrowser2() ? " As this is called in a browser runtime, consider removing the cookies option object to use the document.cookie API automatically." : ""}`);
    }
  } else if (!isServerClient && isBrowser2()) {
    const noHintGetAll = () => {
      const parsed = (0, import_cookie.parse)(document.cookie);
      return Object.keys(parsed).map((name) => ({
        name,
        value: parsed[name] ?? ""
      }));
    };
    getAll = () => noHintGetAll();
    setAll = (setCookies) => {
      setCookies.forEach(({ name, value, options: options2 }) => {
        document.cookie = (0, import_cookie.serialize)(name, value, options2);
      });
    };
  } else if (isServerClient) {
    throw new Error("@supabase/ssr: createServerClient must be initialized with cookie options that specify getAll and setAll functions (deprecated, not recommended: alternatively use get, set and remove)");
  } else {
    getAll = () => {
      return [];
    };
    setAll = () => {
      throw new Error("@supabase/ssr: createBrowserClient in non-browser runtimes (including Next.js pre-rendering mode) was not initialized cookie options that specify getAll and setAll functions (deprecated: alternatively use get, set and remove), but they were needed");
    };
  }
  if (!isServerClient) {
    return {
      getAll,
      // for type consistency
      setAll,
      // for type consistency
      setItems,
      // for type consistency
      removedItems,
      // for type consistency
      storage: {
        isServer: false,
        getItem: async (key) => {
          const allCookies = await getAll([key]);
          const chunkedCookie = await combineChunks(key, async (chunkName) => {
            const cookie = allCookies?.find(({ name }) => name === chunkName) || null;
            if (!cookie) {
              return null;
            }
            return cookie.value;
          });
          if (!chunkedCookie) {
            return null;
          }
          let decoded = chunkedCookie;
          if (chunkedCookie.startsWith(BASE64_PREFIX)) {
            decoded = stringFromBase64URL2(chunkedCookie.substring(BASE64_PREFIX.length));
          }
          return decoded;
        },
        setItem: async (key, value) => {
          const allCookies = await getAll([key]);
          const cookieNames = allCookies?.map(({ name }) => name) || [];
          const removeCookies = new Set(cookieNames.filter((name) => isChunkLike(name, key)));
          let encoded = value;
          if (cookieEncoding === "base64url") {
            encoded = BASE64_PREFIX + stringToBase64URL(value);
          }
          const setCookies = createChunks(key, encoded);
          setCookies.forEach(({ name }) => {
            removeCookies.delete(name);
          });
          const removeCookieOptions = {
            ...DEFAULT_COOKIE_OPTIONS,
            ...options?.cookieOptions,
            maxAge: 0
          };
          const setCookieOptions = {
            ...DEFAULT_COOKIE_OPTIONS,
            ...options?.cookieOptions,
            maxAge: DEFAULT_COOKIE_OPTIONS.maxAge
          };
          delete removeCookieOptions.name;
          delete setCookieOptions.name;
          const allToSet = [
            ...[...removeCookies].map((name) => ({
              name,
              value: "",
              options: removeCookieOptions
            })),
            ...setCookies.map(({ name, value: value2 }) => ({
              name,
              value: value2,
              options: setCookieOptions
            }))
          ];
          if (allToSet.length > 0) {
            await setAll(allToSet);
          }
        },
        removeItem: async (key) => {
          const allCookies = await getAll([key]);
          const cookieNames = allCookies?.map(({ name }) => name) || [];
          const removeCookies = cookieNames.filter((name) => isChunkLike(name, key));
          const removeCookieOptions = {
            ...DEFAULT_COOKIE_OPTIONS,
            ...options?.cookieOptions,
            maxAge: 0
          };
          delete removeCookieOptions.name;
          if (removeCookies.length > 0) {
            await setAll(removeCookies.map((name) => ({
              name,
              value: "",
              options: removeCookieOptions
            })));
          }
        }
      }
    };
  }
  return {
    getAll,
    setAll,
    setItems,
    removedItems,
    storage: {
      // to signal to the libraries that these cookies are
      // coming from a server environment and their value
      // should not be trusted
      isServer: true,
      getItem: async (key) => {
        if (typeof setItems[key] === "string") {
          return setItems[key];
        }
        if (removedItems[key]) {
          return null;
        }
        const allCookies = await getAll([key]);
        const chunkedCookie = await combineChunks(key, async (chunkName) => {
          const cookie = allCookies?.find(({ name }) => name === chunkName) || null;
          if (!cookie) {
            return null;
          }
          return cookie.value;
        });
        if (!chunkedCookie) {
          return null;
        }
        let decoded = chunkedCookie;
        if (typeof chunkedCookie === "string" && chunkedCookie.startsWith(BASE64_PREFIX)) {
          decoded = stringFromBase64URL2(chunkedCookie.substring(BASE64_PREFIX.length));
        }
        return decoded;
      },
      setItem: async (key, value) => {
        if (key.endsWith("-code-verifier")) {
          await applyServerStorage({
            getAll,
            setAll,
            // pretend only that the code verifier was set
            setItems: { [key]: value },
            // pretend that nothing was removed
            removedItems: {}
          }, {
            cookieOptions: options?.cookieOptions ?? null,
            cookieEncoding
          });
        }
        setItems[key] = value;
        delete removedItems[key];
      },
      removeItem: async (key) => {
        delete setItems[key];
        removedItems[key] = true;
      }
    }
  };
}
async function applyServerStorage({ getAll, setAll, setItems, removedItems }, options) {
  const cookieEncoding = options.cookieEncoding;
  const cookieOptions = options.cookieOptions ?? null;
  const allCookies = await getAll([
    ...setItems ? Object.keys(setItems) : [],
    ...removedItems ? Object.keys(removedItems) : []
  ]);
  const cookieNames = allCookies?.map(({ name }) => name) || [];
  const removeCookies = Object.keys(removedItems).flatMap((itemName) => {
    return cookieNames.filter((name) => isChunkLike(name, itemName));
  });
  const setCookies = Object.keys(setItems).flatMap((itemName) => {
    const removeExistingCookiesForItem = new Set(cookieNames.filter((name) => isChunkLike(name, itemName)));
    let encoded = setItems[itemName];
    if (cookieEncoding === "base64url") {
      encoded = BASE64_PREFIX + stringToBase64URL(encoded);
    }
    const chunks = createChunks(itemName, encoded);
    chunks.forEach((chunk) => {
      removeExistingCookiesForItem.delete(chunk.name);
    });
    removeCookies.push(...removeExistingCookiesForItem);
    return chunks;
  });
  const removeCookieOptions = {
    ...DEFAULT_COOKIE_OPTIONS,
    ...cookieOptions,
    maxAge: 0
  };
  const setCookieOptions = {
    ...DEFAULT_COOKIE_OPTIONS,
    ...cookieOptions,
    maxAge: DEFAULT_COOKIE_OPTIONS.maxAge
  };
  delete removeCookieOptions.name;
  delete setCookieOptions.name;
  await setAll([
    ...removeCookies.map((name) => ({
      name,
      value: "",
      options: removeCookieOptions
    })),
    ...setCookies.map(({ name, value }) => ({
      name,
      value,
      options: setCookieOptions
    }))
  ]);
}
var import_cookie, BASE64_PREFIX;
var init_cookies = __esm({
  "node_modules/@supabase/ssr/dist/module/cookies.js"() {
    import_cookie = __toESM(require_dist());
    init_utils3();
    BASE64_PREFIX = "base64-";
  }
});

// node_modules/@supabase/ssr/dist/module/createBrowserClient.js
function createBrowserClient(supabaseUrl, supabaseKey, options) {
  const shouldUseSingleton = options?.isSingleton === true || (!options || !("isSingleton" in options)) && isBrowser2();
  if (shouldUseSingleton && cachedBrowserClient) {
    return cachedBrowserClient;
  }
  if (!supabaseUrl || !supabaseKey) {
    throw new Error(`@supabase/ssr: Your project's URL and API key are required to create a Supabase client!

Check your Supabase project's API settings to find these values

https://supabase.com/dashboard/project/_/settings/api`);
  }
  const { storage } = createStorageFromOptions({
    ...options,
    cookieEncoding: options?.cookieEncoding ?? "base64url"
  }, false);
  const client = createClient(supabaseUrl, supabaseKey, {
    // TODO: resolve type error
    ...options,
    global: {
      ...options?.global,
      headers: {
        ...options?.global?.headers,
        "X-Client-Info": `supabase-ssr/${VERSION2} createBrowserClient`
      }
    },
    auth: {
      ...options?.auth,
      ...options?.cookieOptions?.name ? { storageKey: options.cookieOptions.name } : null,
      flowType: "pkce",
      autoRefreshToken: isBrowser2(),
      detectSessionInUrl: isBrowser2(),
      persistSession: true,
      storage,
      ...options?.cookies && "encode" in options.cookies && options.cookies.encode === "tokens-only" ? {
        userStorage: options?.auth?.userStorage ?? window.localStorage
      } : null
    }
  });
  if (shouldUseSingleton) {
    cachedBrowserClient = client;
  }
  return client;
}
var cachedBrowserClient;
var init_createBrowserClient = __esm({
  "node_modules/@supabase/ssr/dist/module/createBrowserClient.js"() {
    init_dist4();
    init_version4();
    init_utils3();
    init_cookies();
  }
});

// node_modules/@supabase/ssr/dist/module/createServerClient.js
function createServerClient(supabaseUrl, supabaseKey, options) {
  if (!supabaseUrl || !supabaseKey) {
    throw new Error(`Your project's URL and Key are required to create a Supabase client!

Check your Supabase project's API settings to find these values

https://supabase.com/dashboard/project/_/settings/api`);
  }
  const { storage, getAll, setAll, setItems, removedItems } = createStorageFromOptions({
    ...options,
    cookieEncoding: options?.cookieEncoding ?? "base64url"
  }, true);
  const client = createClient(supabaseUrl, supabaseKey, {
    // TODO: resolve type error
    ...options,
    global: {
      ...options?.global,
      headers: {
        ...options?.global?.headers,
        "X-Client-Info": `supabase-ssr/${VERSION2} createServerClient`
      }
    },
    auth: {
      ...options?.cookieOptions?.name ? { storageKey: options.cookieOptions.name } : null,
      ...options?.auth,
      flowType: "pkce",
      autoRefreshToken: false,
      detectSessionInUrl: false,
      persistSession: true,
      storage,
      ...options?.cookies && "encode" in options.cookies && options.cookies.encode === "tokens-only" ? {
        userStorage: options?.auth?.userStorage ?? memoryLocalStorageAdapter2()
      } : null
    }
  });
  client.auth.onAuthStateChange(async (event) => {
    const hasStorageChanges = Object.keys(setItems).length > 0 || Object.keys(removedItems).length > 0;
    if (hasStorageChanges && (event === "SIGNED_IN" || event === "TOKEN_REFRESHED" || event === "USER_UPDATED" || event === "PASSWORD_RECOVERY" || event === "SIGNED_OUT" || event === "MFA_CHALLENGE_VERIFIED")) {
      await applyServerStorage({ getAll, setAll, setItems, removedItems }, {
        cookieOptions: options?.cookieOptions ?? null,
        cookieEncoding: options?.cookieEncoding ?? "base64url"
      });
    }
  });
  return client;
}
var init_createServerClient = __esm({
  "node_modules/@supabase/ssr/dist/module/createServerClient.js"() {
    init_dist4();
    init_version4();
    init_cookies();
    init_helpers2();
  }
});

// node_modules/@supabase/ssr/dist/module/types.js
var init_types3 = __esm({
  "node_modules/@supabase/ssr/dist/module/types.js"() {
  }
});

// node_modules/@supabase/ssr/dist/module/index.js
var init_module4 = __esm({
  "node_modules/@supabase/ssr/dist/module/index.js"() {
    init_createBrowserClient();
    init_createServerClient();
    init_types3();
    init_utils3();
    if (typeof process !== "undefined" && process.env?.npm_package_name) {
      const packageName = process.env.npm_package_name;
      const deprecatedPackages = [
        "@supabase/auth-helpers-nextjs",
        "@supabase/auth-helpers-react",
        "@supabase/auth-helpers-remix",
        "@supabase/auth-helpers-sveltekit"
      ];
      if (deprecatedPackages.includes(packageName)) {
        console.warn(`
\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557
\u2551 \u26A0\uFE0F  IMPORTANT: Package Consolidation Notice                                \u2551
\u2551                                                                            \u2551
\u2551 The ${packageName.padEnd(35)} package name is deprecated.  \u2551
\u2551                                                                            \u2551
\u2551 You are now using @supabase/ssr - a unified solution for all frameworks.  \u2551
\u2551                                                                            \u2551
\u2551 The auth-helpers packages have been consolidated into @supabase/ssr       \u2551
\u2551 to provide better maintenance and consistent APIs across frameworks.      \u2551
\u2551                                                                            \u2551
\u2551 Please update your package.json to use @supabase/ssr directly:            \u2551
\u2551   npm uninstall ${packageName.padEnd(42)} \u2551
\u2551   npm install @supabase/ssr                                               \u2551
\u2551                                                                            \u2551
\u2551 For more information, visit:                                              \u2551
\u2551 https://supabase.com/docs/guides/auth/server-side                         \u2551
\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D
    `);
      }
    }
  }
});

// .svelte-kit/output/server/chunks/public.js
var I3, i4;
var init_public = __esm({
  ".svelte-kit/output/server/chunks/public.js"() {
    I3 = "https://trioykjhhwrruwjsklfo.supabase.co";
    i4 = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRyaW95a2poaHdycnV3anNrbGZvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0OTQwNzMsImV4cCI6MjA4NjA3MDA3M30.iGYrRXPlkHmeBhJa4T41tOteyTBtJ5x-B2_96Dpg3cE";
  }
});

// .svelte-kit/output/server/chunks/hooks.server.js
var hooks_server_exports = {};
__export(hooks_server_exports, {
  handle: () => A3
});
var A3;
var init_hooks_server = __esm({
  ".svelte-kit/output/server/chunks/hooks.server.js"() {
    init_module4();
    init_public();
    A3 = async ({ event: s5, resolve: l7 }) => {
      let o5 = false;
      s5.locals.supabase = createServerClient(I3, i4, { cookies: { getAll: () => s5.cookies.getAll(), setAll: (e3) => {
        o5 || e3.forEach(({ name: a5, value: r5, options: n6 }) => {
          s5.cookies.set(a5, r5, { ...n6, path: "/" });
        });
      } } }), s5.locals.safeGetSession = async () => {
        const { data: { session: e3 } } = await s5.locals.supabase.auth.getSession();
        if (!e3) return { session: null, user: null };
        const { data: { user: a5 }, error: r5 } = await s5.locals.supabase.auth.getUser();
        return r5 ? { session: null, user: null } : { session: e3, user: a5 };
      };
      const t4 = await l7(s5, { filterSerializedResponseHeaders(e3) {
        return e3 === "content-range" || e3 === "x-supabase-api-version";
      } });
      return o5 = true, t4;
    };
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse6;
    exports.serialize = serialize3;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse6(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode2;
      var index13 = 0;
      while (index13 < str.length) {
        var eqIdx = str.indexOf("=", index13);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index13);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index13 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index13, eqIdx).trim();
        if (void 0 === obj[key]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index13 = endIdx + 1;
      }
      return obj;
    }
    function serialize3(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode2;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.partitioned) {
        str += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode2(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode2(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode3) {
      try {
        return decode3(str);
      } catch (e3) {
        return str;
      }
    }
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString3(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e3) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e3
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else if (key === "partitioned") {
          cookie.partitioned = true;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse6(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString3(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString3(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start2;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start2 = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start2, lastComma));
              start2 = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start2, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse6;
    module.exports.parse = parse6;
    module.exports.parseString = parseString3;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// .svelte-kit/output/server/entries/pages/_layout.server.ts.js
var layout_server_ts_exports = {};
__export(layout_server_ts_exports, {
  load: () => n2
});
var n2;
var init_layout_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.server.ts.js"() {
    n2 = async ({ locals: s5 }) => {
      const { session: e3 } = await s5.safeGetSession();
      return { session: e3 };
    };
  }
});

// .svelte-kit/output/server/chunks/state.svelte.js
var o2;
var init_state_svelte = __esm({
  ".svelte-kit/output/server/chunks/state.svelte.js"() {
    init_clsx();
    init_context();
    init_server();
    o2 = w2.toString().includes("$$") || /function \w+\(\) \{\}/.test(w2.toString());
    o2 && new URL("https://example.com");
  }
});

// .svelte-kit/output/server/chunks/context2.js
function a4(e3) {
  I(t2, e3);
}
function u3() {
  return G(t2);
}
var t2;
var init_context2 = __esm({
  ".svelte-kit/output/server/chunks/context2.js"() {
    init_context();
    t2 = "supabase-context";
  }
});

// .svelte-kit/output/server/entries/pages/_layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => S2
});
function m6() {
  return createBrowserClient(I3, i4);
}
function S2(t4, i7) {
  t4.component((e3) => {
    let { data: o5, children: s5 } = i7;
    const r5 = m6();
    o5.session, a4({ supabase: r5, session: o5.session }), Xn(e3, (c7) => {
      c7.push(`<link rel="icon"${En("href", h3)}/>`);
    }), s5?.(e3), e3.push("<!---->");
  });
}
var h3;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_index2();
    init_internal();
    init_exports2();
    init_utils2();
    init_server();
    init_state_svelte();
    init_module4();
    init_public();
    init_context2();
    h3 = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3cdefs%3e%3clinearGradient%20id='goldGradient'%20x1='0%25'%20y1='0%25'%20x2='100%25'%20y2='100%25'%3e%3cstop%20offset='0%25'%20style='stop-color:%23f4e8d8;stop-opacity:1'%20/%3e%3cstop%20offset='100%25'%20style='stop-color:%23d4af37;stop-opacity:1'%20/%3e%3c/linearGradient%3e%3cfilter%20id='shadow'%20x='-20%25'%20y='-20%25'%20width='140%25'%20height='140%25'%3e%3cfeDropShadow%20dx='0'%20dy='4'%20stdDeviation='4'%20flood-color='%23000'%20flood-opacity='0.25'/%3e%3c/filter%3e%3c/defs%3e%3c!--%20Background%20Circle%20--%3e%3ccircle%20cx='256'%20cy='256'%20r='240'%20fill='%232b2520'%20/%3e%3c!--%20Map%20Folded%20Shape%20--%3e%3cpath%20d='M120%20140%20L200%20100%20L312%20140%20L392%20100%20V340%20L312%20380%20L200%20340%20L120%20380%20Z'%20fill='url(%23goldGradient)'%20stroke='%23d4af37'%20stroke-width='12'%20stroke-linejoin='round'/%3e%3c!--%20Fold%20Lines%20--%3e%3cpath%20d='M200%20100%20V340%20M312%20140%20V380'%20stroke='%232b2520'%20stroke-width='8'%20stroke-opacity='0.3'/%3e%3c!--%20Location%20Pin%20--%3e%3cpath%20d='M256%20180%20C230%20180%20210%20200%20210%20226%20C210%20260%20256%20310%20256%20310%20C256%20310%20302%20260%20302%20226%20C302%20200%20282%20180%20256%20180%20Z'%20fill='%23c0392b'%20filter='url(%23shadow)'%20stroke='%23fff'%20stroke-width='4'/%3e%3c!--%20Pin%20Hole%20--%3e%3ccircle%20cx='256'%20cy='226'%20r='12'%20fill='%23fff'/%3e%3c/svg%3e";
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  server: () => layout_server_ts_exports,
  server_id: () => server_id,
  stylesheets: () => stylesheets
});
var index, component_cache, component, server_id, imports, stylesheets, fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_layout_server_ts();
    index = 0;
    component = async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default;
    server_id = "src/routes/+layout.server.ts";
    imports = ["_app/immutable/nodes/0.Du6-DW3V.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/DB88mmUq.js", "_app/immutable/chunks/DezgiKfJ.js"];
    stylesheets = ["_app/immutable/assets/0.BvEVajSC.css"];
    fonts = [];
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => b4
});
function n3() {
  const { set: t4, subscribe: e3 } = a3(false);
  return { subscribe: e3, check: async () => false };
}
function o3() {
  return G("__request__");
}
function b4(t4, e3) {
  t4.component((p6) => {
    p6.push(`<h1>${C2(s3.status)}</h1> <p>${C2(s3.error?.message)}</p>`);
  });
}
var u4, i5, s3;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_context();
    init_clsx();
    init_state_svelte();
    init_internal();
    init_exports2();
    init_utils2();
    init_chunks();
    init_server();
    u4 = { updated: n3() };
    u4.updated.check;
    i5 = { get error() {
      return o3().page.error;
    }, get status() {
      return o3().page.status;
    } };
    s3 = i5;
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2, component_cache2, component2, imports2, stylesheets2, fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default;
    imports2 = ["_app/immutable/nodes/1.Brb-6l-L.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DAqcWgJQ.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/DB88mmUq.js", "_app/immutable/chunks/DezgiKfJ.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});

// .svelte-kit/output/server/entries/pages/_page.svelte.js
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => C4
});
function C4(v5, y5) {
  v5.component((a5) => {
    let l7;
    const { supabase: w5, session: u8 } = u3();
    let r5 = false, i7 = [], g5 = [], o5 = "all", p6 = [], c7 = "featured";
    if (Array.from(new Set(i7.map((e3) => e3.type).filter(Boolean))).sort(), l7 = Array.from(new Set(g5.map((e3) => e3.type).filter(Boolean))).sort(), i7.filter((e3) => p6.includes(e3.id)), Xn(a5, (e3) => {
      e3.title((t4) => {
        t4.push("<title>Vietnam Map Archive \u2014 Make Old Maps Fun Again</title>");
      }), e3.push('<meta name="description" content="Explore georeferenced historical maps of Vietnam. Overlay vintage cartography on modern basemaps, track your location through history." class="svelte-1uha8ag"/> <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&amp;family=Outfit:wght@400;600;800&amp;family=Be+Vietnam+Pro:wght@400;600;800&amp;display=swap" rel="stylesheet" class="svelte-1uha8ag"/>');
    }), a5.push(`<div${Jn("page svelte-1uha8ag", void 0, { mounted: r5 })}><header class="hero svelte-1uha8ag"><div class="auth-bar svelte-1uha8ag"><button class="pill-btn lang-btn svelte-1uha8ag">${C2("\u{1F1FB}\u{1F1F3} VN")}</button> `), u8 ? (a5.push("<!--[-->"), a5.push('<button class="pill-btn signout-btn svelte-1uha8ag">Sign Out</button>')) : (a5.push("<!--[!-->"), a5.push('<button class="pill-btn google-btn svelte-1uha8ag"><svg class="google-icon svelte-1uha8ag" viewBox="0 0 24 24" width="18" height="18"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z" fill="#4285F4" class="svelte-1uha8ag"></path><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853" class="svelte-1uha8ag"></path><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05" class="svelte-1uha8ag"></path><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335" class="svelte-1uha8ag"></path></svg> Sign in</button>')), a5.push(`<!--]--></div> <div id="google_translate_element" style="display:none" class="svelte-1uha8ag"></div> <div class="hero-content svelte-1uha8ag"><div class="tagline-badge svelte-1uha8ag"><span class="sparkle svelte-1uha8ag">\u2728</span> Make old maps fun again.</div> <h1 class="hero-title svelte-1uha8ag">Vietnam<br class="svelte-1uha8ag"/><span class="text-highlight svelte-1uha8ag">Map Archive</span></h1> <p class="hero-subtitle svelte-1uha8ag">Explore vintage cartography overlaid on the modern world.
				Time-travel from your browser! \u{1F680}</p></div></header> <main class="main svelte-1uha8ag"><section class="mode-section svelte-1uha8ag" id="view-mode"><div class="feature-card mega-card svelte-1uha8ag"><div class="feature-header-split svelte-1uha8ag"><div class="icon-blob color-blue svelte-1uha8ag">\u{1F4CD}</div> <div class="feature-content-full svelte-1uha8ag"><h2 class="feature-title svelte-1uha8ag">Explore &amp; View</h2> <p class="feature-description svelte-1uha8ag">Compare the past and present. Track your GPS on
							vintage maps and browse our colorful archive of
							history.</p></div></div> <div class="embedded-maps-area svelte-1uha8ag"><div class="controls-row svelte-1uha8ag"><div class="collection-tabs svelte-1uha8ag"><button${Jn("chunky-tab svelte-1uha8ag", void 0, { active: c7 === "featured" })}>\u{1F31F} Featured</button> <button${Jn("chunky-tab svelte-1uha8ag", void 0, { active: c7 === "favorites" })}>\u2764\uFE0F Favorites</button></div> `), l7.length > 1) {
      a5.push("<!--[-->"), a5.push(`<div class="city-filters svelte-1uha8ag"><button${Jn("filter-pill svelte-1uha8ag", void 0, { active: o5 === "all" })}>All Cities</button> <!--[-->`);
      const e3 = rs(l7);
      for (let t4 = 0, d2 = e3.length; t4 < d2; t4++) {
        let h5 = e3[t4];
        a5.push(`<button${Jn("filter-pill svelte-1uha8ag", void 0, { active: o5 === h5 })}>${C2(h5)}</button>`);
      }
      a5.push("<!--]--></div>");
    } else a5.push("<!--[!-->");
    a5.push("<!--]--></div> "), a5.push("<!--[-->"), a5.push('<div class="maps-loading svelte-1uha8ag"><div class="spinner svelte-1uha8ag">\u{1F30E}</div> <span class="svelte-1uha8ag">Loading the archive...</span></div>'), a5.push(`<!--]--> <div class="action-footer svelte-1uha8ag"><a href="/catalog" class="text-link svelte-1uha8ag">See all maps \u2192</a> <a href="/view" class="action-btn primary-btn svelte-1uha8ag">Enter Viewer \u{1F680}</a></div></div></div></section> <div class="split-sections svelte-1uha8ag"><section class="mode-section svelte-1uha8ag" id="annotate-mode"><div class="feature-card hover-lift svelte-1uha8ag"><div class="icon-blob color-orange svelte-1uha8ag">\u{1F5BC}\uFE0F</div> <div class="feature-content svelte-1uha8ag"><h2 class="feature-title svelte-1uha8ag">Tools <span class="fun-badge svelte-1uha8ag">Beta</span></h2> <p class="feature-description svelte-1uha8ag">Get your hands dirty! Draw points, lines, and
							regions on historical maps to create searchable
							records.</p> <a href="/annotate" class="action-btn secondary-btn svelte-1uha8ag">Open Annotator \u270F\uFE0F</a> <div class="micro-links svelte-1uha8ag"><span class="micro-label svelte-1uha8ag">Help the community:</span> <a href="/contribute/georef" class="micro-link svelte-1uha8ag">Georeference Maps \u2192</a> <a href="/contribute/label" class="micro-link svelte-1uha8ag">Label Studio \u2192</a></div></div></div></section> <section class="mode-section svelte-1uha8ag" id="create-mode"><div class="feature-card hover-lift svelte-1uha8ag"><div class="icon-blob color-green svelte-1uha8ag">\u2728</div> <div class="feature-content svelte-1uha8ag"><h2 class="feature-title svelte-1uha8ag">Create Stories <span class="fun-badge svelte-1uha8ag">Beta</span></h2> <p class="feature-description svelte-1uha8ag">Design interactive scrollytelling experiences.
							Combine narrative with historical maps to publish
							your own stories.</p> <a href="/create" class="action-btn secondary-btn mt-auto svelte-1uha8ag">Design a Story \u{1F3A8}</a></div></div></section></div> <section class="about-card svelte-1uha8ag"><div class="about-header svelte-1uha8ag"><div class="icon-blob color-yellow svelte-1uha8ag">\u2726</div> <h2 class="feature-title svelte-1uha8ag">About the Project</h2></div> <p class="feature-description svelte-1uha8ag">Vietnam Map Archive brings historical cartography to life by
				georeferencing vintage maps and overlaying them on modern
				satellite imagery. Powered by the open-source <a href="https://allmaps.org" target="_blank" rel="noopener" class="svelte-1uha8ag">Allmaps</a> platform, we're turning static images into interactive time machines.</p></section></main> <footer class="footer svelte-1uha8ag"><div class="footer-content svelte-1uha8ag"><p class="footer-text svelte-1uha8ag">Built playfully with <a href="https://allmaps.org" target="_blank" class="svelte-1uha8ag">Allmaps</a>, <a href="https://openlayers.org" target="_blank" class="svelte-1uha8ag">OpenLayers</a>,
				&amp; <a href="https://svelte.dev" target="_blank" class="svelte-1uha8ag">SvelteKit</a>.</p> <p class="footer-contact svelte-1uha8ag">Say hi! \u{1F44B} <a href="mailto:vietnamma.project@gmail.com" class="svelte-1uha8ag">vietnamma.project@gmail.com</a></p></div></footer></div>`);
  });
}
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_page.svelte.js"() {
    init_index2();
    init_context2();
    init_context();
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  stylesheets: () => stylesheets3,
  universal: () => universal,
  universal_id: () => universal_id
});
var index3, component_cache3, component3, universal, universal_id, imports3, stylesheets3, fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    index3 = 2;
    component3 = async () => component_cache3 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default;
    universal = {
      "ssr": false
    };
    universal_id = "src/routes/+page.ts";
    imports3 = ["_app/immutable/nodes/2.CK7_ifFV.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DAqcWgJQ.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/BWsF3rHZ.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/DxkUhP4x.js", "_app/immutable/chunks/BqlTOgs2.js", "_app/immutable/chunks/CvFblwoI.js"];
    stylesheets3 = ["_app/immutable/assets/2.DtX0AVXN.css"];
    fonts3 = [];
  }
});

// .svelte-kit/output/server/entries/pages/admin/_page.svelte.js
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => c3
});
function c3(a5, m8) {
  a5.component((s5) => {
    const { supabase: h5, session: f8 } = u3();
    let i7 = false;
    Xn(s5, (t4) => {
      t4.title((e3) => {
        e3.push("<title>Admin Dashboard \u2014 Vietnam Map Archive</title>");
      }), t4.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
    }), s5.push(`<div${Jn("page svelte-1jef3w8", void 0, { mounted: i7 })}>`), s5.push("<!--[-->"), s5.push('<div class="gate-message svelte-1jef3w8">Verifying admin access...</div>'), s5.push("<!--]--></div>");
  });
}
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/admin/_page.svelte.js"() {
    init_index2();
    init_context2();
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  stylesheets: () => stylesheets4,
  universal: () => universal2,
  universal_id: () => universal_id2
});
var index4, component_cache4, component4, universal2, universal_id2, imports4, stylesheets4, fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    index4 = 3;
    component4 = async () => component_cache4 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default;
    universal2 = {
      "ssr": false
    };
    universal_id2 = "src/routes/admin/+page.ts";
    imports4 = ["_app/immutable/nodes/3.CLe-9Jlh.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DAqcWgJQ.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/BWsF3rHZ.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/CzAFXcu7.js", "_app/immutable/chunks/Cg4Xvy-O.js", "_app/immutable/chunks/nobbrJXm.js", "_app/immutable/chunks/DezgiKfJ.js"];
    stylesheets4 = ["_app/immutable/assets/3.Cn2XENui.css"];
    fonts4 = [];
  }
});

// node_modules/ol/console.js
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}
var levels, level;
var init_console = __esm({
  "node_modules/ol/console.js"() {
    levels = {
      info: 1,
      warn: 2,
      error: 3,
      none: 4
    };
    level = levels.info;
  }
});

// node_modules/ol/extent/Relationship.js
var Relationship_default;
var init_Relationship = __esm({
  "node_modules/ol/extent/Relationship.js"() {
    Relationship_default = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16
    };
  }
});

// node_modules/ol/extent.js
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i7 = 0, ii = coordinates2.length; i7 < ii; ++i7) {
    extendCoordinate(extent, coordinates2[i7]);
  }
  return extent;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [
    extent[0] - value,
    extent[1] - value,
    extent[2] + value,
    extent[3] + value
  ];
}
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}
function closestSquaredDistanceXY(extent, x4, y5) {
  let dx, dy;
  if (x4 < extent[0]) {
    dx = extent[0] - x4;
  } else if (extent[2] < x4) {
    dx = x4 - extent[2];
  } else {
    dx = 0;
  }
  if (y5 < extent[1]) {
    dy = extent[1] - y5;
  } else if (extent[3] < y5) {
    dy = y5 - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x4, y5) {
  return extent[0] <= x4 && x4 <= extent[2] && extent[1] <= y5 && y5 <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x4 = coordinate[0];
  const y5 = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x4 < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x4 > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y5 < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y5 > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x4 = coordinate[0];
  const y5 = coordinate[1];
  return createOrUpdate(x4, y5, x4, y5, dest);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}
function extendXY(extent, x4, y5) {
  extent[0] = Math.min(extent[0], x4);
  extent[1] = Math.min(extent[1], y5);
  extent[2] = Math.max(extent[2], x4);
  extent[3] = Math.max(extent[3], y5);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x22, y22, x32, y32] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x22, x32),
    Math.min(y0, y1, y22, y32),
    Math.max(x0, x1, x22, x32),
    Math.max(y0, y1, y22, y32),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x4 = center[0];
  const y5 = center[1];
  return [
    x4 - xCos + ySin,
    y5 - xSin - yCos,
    x4 - xCos - ySin,
    y5 - xSin + yCos,
    x4 + xCos - ySin,
    y5 + xSin + yCos,
    x4 + xCos + ySin,
    y5 + xSin - yCos,
    x4 - xCos + ySin,
    y5 - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function intersectsSegment(extent, start2, end) {
  let intersects3 = false;
  const startRel = coordinateRelationship(extent, start2);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects3 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start2[0];
    const startY = start2[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x4, y5;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x4 = endX - (endY - maxY) / slope;
      intersects3 = x4 >= minX && x4 <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y5 = endY - (endX - maxX) * slope;
      intersects3 = y5 >= minY && y5 <= maxY;
    }
    if (!intersects3 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x4 = endX - (endY - minY) / slope;
      intersects3 = x4 >= minX && x4 <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y5 = endY - (endX - minX) * slope;
      intersects3 = y5 >= minY && y5 <= maxY;
    }
  }
  return intersects3;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i7 = 0; i7 < stops; ++i7) {
      coordinates2.push(
        extent[0] + width * i7 / stops,
        extent[1],
        extent[2],
        extent[1] + height * i7 / stops,
        extent[2] - width * i7 / stops,
        extent[3],
        extent[0],
        extent[3] - height * i7 / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i7 = 0, l7 = coordinates2.length; i7 < l7; i7 += 2) {
    xs.push(coordinates2[i7]);
    ys.push(coordinates2[i7 + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}
function wrapAndSliceX(extent, projection, multiWorld) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth && !multiWorld) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}
var init_extent = __esm({
  "node_modules/ol/extent.js"() {
    init_Relationship();
  }
});

// node_modules/ol/math.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x4, y5, x1, y1, x22, y22) {
  const dx = x22 - x1;
  const dy = y22 - y1;
  if (dx !== 0 || dy !== 0) {
    const t4 = ((x4 - x1) * dx + (y5 - y1) * dy) / (dx * dx + dy * dy);
    if (t4 > 1) {
      x1 = x22;
      y1 = y22;
    } else if (t4 > 0) {
      x1 += dx * t4;
      y1 += dy * t4;
    }
  }
  return squaredDistance(x4, y5, x1, y1);
}
function squaredDistance(x1, y1, x22, y22) {
  const dx = x22 - x1;
  const dy = y22 - y1;
  return dx * dx + dy * dy;
}
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a5, b8) {
  const r5 = a5 % b8;
  return r5 * b8 < 0 ? r5 + b8 : r5;
}
function lerp(a5, b8, x4) {
  return a5 + x4 * (b8 - a5);
}
function toFixed(n6, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n6 * factor) / factor;
}
function wrap(n6, min, max) {
  if (n6 >= min && n6 < max) {
    return n6;
  }
  const range = max - min;
  return ((n6 - min) % range + range) % range + min;
}
var init_math = __esm({
  "node_modules/ol/math.js"() {
  }
});

// node_modules/ol/coordinate.js
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function equals2(coordinate1, coordinate2) {
  let equals4 = true;
  for (let i7 = coordinate1.length - 1; i7 >= 0; --i7) {
    if (coordinate1[i7] != coordinate2[i7]) {
      equals4 = false;
      break;
    }
  }
  return equals4;
}
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x4 = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y5 = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x4;
  coordinate[1] = y5;
  return coordinate;
}
function squaredDistance2(coord1, coord2) {
  const dx = coord1[0] - coord2[0];
  const dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance2(coord1, coord2));
}
function wrapX2(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = getWidth(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}
var init_coordinate = __esm({
  "node_modules/ol/coordinate.js"() {
    init_extent();
  }
});

// node_modules/ol/proj/Units.js
var METERS_PER_UNIT;
var init_Units = __esm({
  "node_modules/ol/proj/Units.js"() {
    METERS_PER_UNIT = {
      // use the radius of the Normal sphere
      "radians": 6370997 / (2 * Math.PI),
      "degrees": 2 * Math.PI * 6370997 / 360,
      "ft": 0.3048,
      "m": 1,
      "us-ft": 1200 / 3937
    };
  }
});

// node_modules/ol/proj/Projection.js
var Projection, Projection_default;
var init_Projection = __esm({
  "node_modules/ol/proj/Projection.js"() {
    init_Units();
    Projection = class {
      /**
       * @param {Options} options Projection options.
       */
      constructor(options) {
        this.code_ = options.code;
        this.units_ = /** @type {import("./Units.js").Units} */
        options.units;
        this.extent_ = options.extent !== void 0 ? options.extent : null;
        this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
        this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
        this.global_ = options.global !== void 0 ? options.global : false;
        this.canWrapX_ = !!(this.global_ && this.extent_);
        this.getPointResolutionFunc_ = options.getPointResolution;
        this.defaultTileGrid_ = null;
        this.metersPerUnit_ = options.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      canWrapX() {
        return this.canWrapX_;
      }
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      getCode() {
        return this.code_;
      }
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        return this.extent_;
      }
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").Units} Units.
       * @api
       */
      getUnits() {
        return this.units_;
      }
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      getMetersPerUnit() {
        return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
      }
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getWorldExtent() {
        return this.worldExtent_;
      }
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      getAxisOrientation() {
        return this.axisOrientation_;
      }
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      isGlobal() {
        return this.global_;
      }
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      setGlobal(global2) {
        this.global_ = global2;
        this.canWrapX_ = !!(global2 && this.extent_);
      }
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      getDefaultTileGrid() {
        return this.defaultTileGrid_;
      }
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
      }
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
      }
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
      }
      /**
       * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
      }
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {GetPointResolution|undefined} The custom point
       * resolution function (if set).
       */
      getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
      }
    };
    Projection_default = Projection;
  }
});

// node_modules/ol/proj/epsg3857.js
function fromEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i7 = 0; i7 < length; i7 += stride) {
    output[i7] = HALF_SIZE * input[i7] / 180;
    let y5 = RADIUS * Math.log(Math.tan(Math.PI * (+input[i7 + 1] + 90) / 360));
    if (y5 > MAX_SAFE_Y) {
      y5 = MAX_SAFE_Y;
    } else if (y5 < -MAX_SAFE_Y) {
      y5 = -MAX_SAFE_Y;
    }
    output[i7 + 1] = y5;
  }
  return output;
}
function toEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i7 = 0; i7 < length; i7 += stride) {
    output[i7] = 180 * input[i7] / HALF_SIZE;
    output[i7 + 1] = 360 * Math.atan(Math.exp(input[i7 + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}
var RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, MAX_SAFE_Y, EPSG3857Projection, PROJECTIONS;
var init_epsg3857 = __esm({
  "node_modules/ol/proj/epsg3857.js"() {
    init_Projection();
    RADIUS = 6378137;
    HALF_SIZE = Math.PI * RADIUS;
    EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
    WORLD_EXTENT = [-180, -85, 180, 85];
    MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
    EPSG3857Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       */
      constructor(code) {
        super({
          code,
          units: "m",
          extent: EXTENT,
          global: true,
          worldExtent: WORLD_EXTENT,
          getPointResolution: function(resolution, point) {
            return resolution / Math.cosh(point[1] / RADIUS);
          }
        });
      }
    };
    PROJECTIONS = [
      new EPSG3857Projection("EPSG:3857"),
      new EPSG3857Projection("EPSG:102100"),
      new EPSG3857Projection("EPSG:102113"),
      new EPSG3857Projection("EPSG:900913"),
      new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
      new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
    ];
  }
});

// node_modules/ol/proj/epsg4326.js
var RADIUS2, EXTENT2, METERS_PER_UNIT2, EPSG4326Projection, PROJECTIONS2;
var init_epsg4326 = __esm({
  "node_modules/ol/proj/epsg4326.js"() {
    init_Projection();
    RADIUS2 = 6378137;
    EXTENT2 = [-180, -90, 180, 90];
    METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
    EPSG4326Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       * @param {string} [axisOrientation] Axis orientation.
       */
      constructor(code, axisOrientation) {
        super({
          code,
          units: "degrees",
          extent: EXTENT2,
          axisOrientation,
          global: true,
          metersPerUnit: METERS_PER_UNIT2,
          worldExtent: EXTENT2
        });
      }
    };
    PROJECTIONS2 = [
      new EPSG4326Projection("CRS:84"),
      new EPSG4326Projection("EPSG:4326", "neu"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
      new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
    ];
  }
});

// node_modules/ol/proj/projections.js
function get2(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add2(code, projection) {
  cache[code] = projection;
}
var cache;
var init_projections = __esm({
  "node_modules/ol/proj/projections.js"() {
    cache = {};
  }
});

// node_modules/ol/obj.js
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty2(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}
var init_obj = __esm({
  "node_modules/ol/obj.js"() {
  }
});

// node_modules/ol/proj/transforms.js
function add3(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get3(sourceCode, destinationCode) {
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    return transforms[sourceCode][destinationCode];
  }
  return null;
}
var transforms;
var init_transforms = __esm({
  "node_modules/ol/proj/transforms.js"() {
    transforms = {};
  }
});

// node_modules/ol/proj/utm.js
function toLonLat(easting, northing, zone) {
  const x4 = easting - 5e5;
  const y5 = zone.north ? northing : northing - 1e7;
  const m8 = y5 / K0;
  const mu = m8 / (R5 * M1);
  const pRad = mu + P22 * Math.sin(2 * mu) + P32 * Math.sin(4 * mu) + P4 * Math.sin(6 * mu) + P5 * Math.sin(8 * mu);
  const pSin = Math.sin(pRad);
  const pSin2 = pSin * pSin;
  const pCos = Math.cos(pRad);
  const pTan = pSin / pCos;
  const pTan2 = pTan * pTan;
  const pTan4 = pTan2 * pTan2;
  const epSin = 1 - E4 * pSin2;
  const epSinSqrt = Math.sqrt(1 - E4 * pSin2);
  const n6 = R5 / epSinSqrt;
  const r5 = (1 - E4) / epSin;
  const c7 = E_P2 * pCos ** 2;
  const c22 = c7 * c7;
  const d2 = x4 / (n6 * K0);
  const d22 = d2 * d2;
  const d3 = d22 * d2;
  const d4 = d3 * d2;
  const d5 = d4 * d2;
  const d6 = d5 * d2;
  const latitude = pRad - pTan / r5 * (d22 / 2 - d4 / 24 * (5 + 3 * pTan2 + 10 * c7 - 4 * c22 - 9 * E_P2)) + d6 / 720 * (61 + 90 * pTan2 + 298 * c7 + 45 * pTan4 - 252 * E_P2 - 3 * c22);
  let longitude = (d2 - d3 / 6 * (1 + 2 * pTan2 + c7) + d5 / 120 * (5 - 2 * c7 + 28 * pTan2 - 3 * c22 + 8 * E_P2 + 24 * pTan4)) / pCos;
  longitude = wrap(
    longitude + toRadians(zoneToCentralLongitude(zone.number)),
    -Math.PI,
    Math.PI
  );
  return [toDegrees(longitude), toDegrees(latitude)];
}
function fromLonLat(longitude, latitude, zone) {
  longitude = wrap(longitude, MIN_LONGITUDE, MAX_LONGITUDE);
  if (latitude < MIN_LATITUDE) {
    latitude = MIN_LATITUDE;
  } else if (latitude > MAX_LATITUDE) {
    latitude = MAX_LATITUDE;
  }
  const latRad = toRadians(latitude);
  const latSin = Math.sin(latRad);
  const latCos = Math.cos(latRad);
  const latTan = latSin / latCos;
  const latTan2 = latTan * latTan;
  const latTan4 = latTan2 * latTan2;
  const lonRad = toRadians(longitude);
  const centralLon = zoneToCentralLongitude(zone.number);
  const centralLonRad = toRadians(centralLon);
  const n6 = R5 / Math.sqrt(1 - E4 * latSin ** 2);
  const c7 = E_P2 * latCos ** 2;
  const a5 = latCos * wrap(lonRad - centralLonRad, -Math.PI, Math.PI);
  const a23 = a5 * a5;
  const a32 = a23 * a5;
  const a42 = a32 * a5;
  const a52 = a42 * a5;
  const a6 = a52 * a5;
  const m8 = R5 * (M1 * latRad - M2 * Math.sin(2 * latRad) + M3 * Math.sin(4 * latRad) - M4 * Math.sin(6 * latRad));
  const easting = K0 * n6 * (a5 + a32 / 6 * (1 - latTan2 + c7) + a52 / 120 * (5 - 18 * latTan2 + latTan4 + 72 * c7 - 58 * E_P2)) + 5e5;
  let northing = K0 * (m8 + n6 * latTan * (a23 / 2 + a42 / 24 * (5 - latTan2 + 9 * c7 + 4 * c7 ** 2) + a6 / 720 * (61 - 58 * latTan2 + latTan4 + 600 * c7 - 330 * E_P2)));
  if (!zone.north) {
    northing += 1e7;
  }
  return [easting, northing];
}
function zoneToCentralLongitude(zone) {
  return (zone - 1) * 6 - 180 + 3;
}
function zoneFromCode(code) {
  let epsgId = 0;
  for (const re2 of epsgRegExes) {
    const match2 = code.match(re2);
    if (match2) {
      epsgId = parseInt(match2[1]);
      break;
    }
  }
  if (!epsgId) {
    return null;
  }
  let number = 0;
  let north = false;
  if (epsgId > 32700 && epsgId < 32761) {
    number = epsgId - 32700;
  } else if (epsgId > 32600 && epsgId < 32661) {
    north = true;
    number = epsgId - 32600;
  }
  if (!number) {
    return null;
  }
  return { number, north };
}
function makeTransformFunction(transformer2, zone) {
  return function(input, output, dimension, stride) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    stride = stride ?? dimension;
    if (!output) {
      if (dimension > 2) {
        output = input.slice();
      } else {
        output = new Array(length);
      }
    }
    for (let i7 = 0; i7 < length; i7 += stride) {
      const x4 = input[i7];
      const y5 = input[i7 + 1];
      const coord = transformer2(x4, y5, zone);
      output[i7] = coord[0];
      output[i7 + 1] = coord[1];
    }
    return output;
  };
}
function makeProjection(code) {
  const zone = zoneFromCode(code);
  if (!zone) {
    return null;
  }
  return new Projection_default({ code, units: "m" });
}
function makeTransforms(projection) {
  const zone = zoneFromCode(projection.getCode());
  if (!zone) {
    return null;
  }
  return {
    forward: makeTransformFunction(fromLonLat, zone),
    inverse: makeTransformFunction(toLonLat, zone)
  };
}
var K0, E4, E22, E32, E_P2, SQRT_E, _E, _E2, _E3, _E4, _E5, M1, M2, M3, M4, P22, P32, P4, P5, R5, MIN_LATITUDE, MAX_LATITUDE, MIN_LONGITUDE, MAX_LONGITUDE, epsgRegExes;
var init_utm = __esm({
  "node_modules/ol/proj/utm.js"() {
    init_math();
    init_Projection();
    K0 = 0.9996;
    E4 = 669438e-8;
    E22 = E4 * E4;
    E32 = E22 * E4;
    E_P2 = E4 / (1 - E4);
    SQRT_E = Math.sqrt(1 - E4);
    _E = (1 - SQRT_E) / (1 + SQRT_E);
    _E2 = _E * _E;
    _E3 = _E2 * _E;
    _E4 = _E3 * _E;
    _E5 = _E4 * _E;
    M1 = 1 - E4 / 4 - 3 * E22 / 64 - 5 * E32 / 256;
    M2 = 3 * E4 / 8 + 3 * E22 / 32 + 45 * E32 / 1024;
    M3 = 15 * E22 / 256 + 45 * E32 / 1024;
    M4 = 35 * E32 / 3072;
    P22 = 3 / 2 * _E - 27 / 32 * _E3 + 269 / 512 * _E5;
    P32 = 21 / 16 * _E2 - 55 / 32 * _E4;
    P4 = 151 / 96 * _E3 - 417 / 128 * _E5;
    P5 = 1097 / 512 * _E4;
    R5 = 6378137;
    MIN_LATITUDE = -80;
    MAX_LATITUDE = 84;
    MIN_LONGITUDE = -180;
    MAX_LONGITUDE = 180;
    epsgRegExes = [
      /^EPSG:(\d+)$/,
      /^urn:ogc:def:crs:EPSG::(\d+)$/,
      /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
    ];
  }
});

// node_modules/ol/proj.js
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i7 = 0, ii = input.length; i7 < ii; ++i7) {
      output[i7] = input[i7];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function addProjection(projection) {
  add2(projection.getCode(), projection);
  add3(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get4(projectionLike) {
  if (!(typeof projectionLike === "string")) {
    return projectionLike;
  }
  const projection = get2(projectionLike);
  if (projection) {
    return projection;
  }
  for (const makeProjection2 of projectionFactories) {
    const projection2 = makeProjection2(projectionLike);
    if (projection2) {
      return projection2;
    }
  }
  return null;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        add3(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add3(projection1, projection2, forwardTransform);
      add3(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get4(defaultCode);
  }
  if (typeof projection === "string") {
    return get4(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function fromLonLat2(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    "EPSG:4326",
    projection !== void 0 ? projection : "EPSG:3857"
  );
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(source, destination) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  let transformFunc = get3(sourceCode, destinationCode);
  if (transformFunc) {
    return transformFunc;
  }
  let sourceTransforms = null;
  let destinationTransforms = null;
  for (const makeTransforms2 of transformFactories) {
    if (!sourceTransforms) {
      sourceTransforms = makeTransforms2(source);
    }
    if (!destinationTransforms) {
      destinationTransforms = makeTransforms2(destination);
    }
  }
  if (!sourceTransforms && !destinationTransforms) {
    return null;
  }
  const intermediateCode = "EPSG:4326";
  if (!destinationTransforms) {
    const toDestination = get3(intermediateCode, destinationCode);
    if (toDestination) {
      transformFunc = composeTransformFuncs(
        sourceTransforms.inverse,
        toDestination
      );
    }
  } else if (!sourceTransforms) {
    const fromSource = get3(sourceCode, intermediateCode);
    if (fromSource) {
      transformFunc = composeTransformFuncs(
        fromSource,
        destinationTransforms.forward
      );
    }
  } else {
    transformFunc = composeTransformFuncs(
      sourceTransforms.inverse,
      destinationTransforms.forward
    );
  }
  if (transformFunc) {
    addProjection(source);
    addProjection(destination);
    add3(source, destination, transformFunc);
  }
  return transformFunc;
}
function composeTransformFuncs(t1, t22) {
  return function(input, output, dimensions, stride) {
    output = t1(input, output, dimensions, stride);
    return t22(output, output, dimensions, stride);
  };
}
function getTransform(source, destination) {
  const sourceProjection = get4(source);
  const destinationProjection = get4(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  if (!transformFunc) {
    const sourceCode = get4(source).getCode();
    const destinationCode = get4(destination).getCode();
    throw new Error(
      `No transform available between ${sourceCode} and ${destinationCode}`
    );
  }
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return applyTransform(extent, transformFunc, void 0, stops);
}
function getUserProjection() {
  return userProjection;
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals2(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceMetersPerUnit = get4(sourceProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
var transformFactories, projectionFactories, showCoordinateWarning, userProjection;
var init_proj = __esm({
  "node_modules/ol/proj.js"() {
    init_console();
    init_coordinate();
    init_extent();
    init_Units();
    init_epsg3857();
    init_epsg4326();
    init_projections();
    init_transforms();
    init_utm();
    transformFactories = [makeTransforms];
    projectionFactories = [makeProjection];
    showCoordinateWarning = true;
    userProjection = null;
    addCommon();
  }
});

// .svelte-kit/output/server/chunks/MapSearchBar.svelte_svelte_type_style_lang.js
function M5(a5) {
  r2.r.on_destroy(a5);
}
function b5(a5) {
  const { subscribe: s5, update: o5, set: r5 } = a3({ ...i6, ...a5 });
  return { subscribe: s5, setView(t4) {
    o5((e3) => ({ ...e3, ...t4 }));
  }, setActiveMap(t4) {
    o5((e3) => ({ ...e3, activeMapId: t4 }));
  }, setAll(t4) {
    o5((e3) => ({ ...e3, ...t4 }));
  }, reset() {
    r5({ ...i6 });
  } };
}
function f5(a5) {
  const { subscribe: s5, update: o5, set: r5 } = a3({ ...c4, ...a5 });
  return { subscribe: s5, setBasemap(t4) {
    o5((e3) => ({ ...e3, basemap: t4 }));
  }, setOverlayOpacity(t4) {
    const e3 = Math.max(0, Math.min(1, t4));
    o5((n6) => ({ ...n6, overlayOpacity: e3 }));
  }, setOverlayVisible(t4) {
    o5((e3) => ({ ...e3, overlayVisible: t4 }));
  }, setViewMode(t4) {
    o5((e3) => ({ ...e3, viewMode: t4 }));
  }, setSideRatio(t4) {
    const e3 = Math.max(0.01, Math.min(0.99, t4));
    o5((n6) => ({ ...n6, sideRatio: e3 }));
  }, setLensRadius(t4) {
    const e3 = Math.max(20, t4);
    o5((n6) => ({ ...n6, lensRadius: e3 }));
  }, setAll(t4) {
    o5((e3) => ({ ...e3, ...t4 }));
  }, reset() {
    r5({ ...c4 });
  } };
}
function D3(a5 = "id") {
  if (typeof crypto < "u" && typeof crypto.randomUUID == "function") return `${a5}-${crypto.randomUUID()}`;
  const s5 = Math.random().toString(36).slice(2, 8);
  return `${a5}-${Date.now().toString(36)}-${s5}`;
}
var i6, c4, v3, A4;
var init_MapSearchBar_svelte_svelte_type_style_lang = __esm({
  ".svelte-kit/output/server/chunks/MapSearchBar.svelte_svelte_type_style_lang.js"() {
    init_context();
    init_chunks();
    init_proj();
    i6 = { lng: 106.70098, lat: 10.77653, zoom: 14, rotation: 0, activeMapId: null };
    c4 = { basemap: "g-streets", overlayOpacity: 0.8, overlayVisible: true, viewMode: "overlay", sideRatio: 0.5, lensRadius: 150 };
    v3 = "#2563eb";
    A4 = { point: "Point", line: "LineString", polygon: "Polygon" };
    fromLonLat2([106.70098, 10.77653]);
  }
});

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default;
var init_ObjectEventType = __esm({
  "node_modules/ol/ObjectEventType.js"() {
    ObjectEventType_default = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: "propertychange"
    };
  }
});

// node_modules/ol/events/EventType.js
var EventType_default;
var init_EventType = __esm({
  "node_modules/ol/events/EventType.js"() {
    EventType_default = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: "change",
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: "error",
      BLUR: "blur",
      CLEAR: "clear",
      CONTEXTMENU: "contextmenu",
      CLICK: "click",
      DBLCLICK: "dblclick",
      DRAGENTER: "dragenter",
      DRAGOVER: "dragover",
      DROP: "drop",
      FOCUS: "focus",
      KEYDOWN: "keydown",
      KEYPRESS: "keypress",
      LOAD: "load",
      RESIZE: "resize",
      TOUCHMOVE: "touchmove",
      WHEEL: "wheel"
    };
  }
});

// node_modules/ol/Disposable.js
var Disposable, Disposable_default;
var init_Disposable = __esm({
  "node_modules/ol/Disposable.js"() {
    Disposable = class {
      constructor() {
        this.disposed = false;
      }
      /**
       * Clean up.
       */
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.disposeInternal();
        }
      }
      /**
       * Extension point for disposable objects.
       * @protected
       */
      disposeInternal() {
      }
    };
    Disposable_default = Disposable;
  }
});

// node_modules/ol/array.js
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function ascending(a5, b8) {
  return a5 > b8 ? 1 : a5 < b8 ? -1 : 0;
}
function descending(a5, b8) {
  return a5 < b8 ? 1 : a5 > b8 ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n6 = arr.length;
  if (target <= arr[n6 - 1]) {
    return n6 - 1;
  }
  if (typeof direction === "function") {
    for (let i7 = 1; i7 < n6; ++i7) {
      const candidate = arr[i7];
      if (candidate === target) {
        return i7;
      }
      if (candidate < target) {
        if (direction(target, arr[i7 - 1], candidate) > 0) {
          return i7 - 1;
        }
        return i7;
      }
    }
    return n6 - 1;
  }
  if (direction > 0) {
    for (let i7 = 1; i7 < n6; ++i7) {
      if (arr[i7] < target) {
        return i7 - 1;
      }
    }
    return n6 - 1;
  }
  if (direction < 0) {
    for (let i7 = 1; i7 < n6; ++i7) {
      if (arr[i7] <= target) {
        return i7;
      }
    }
    return n6 - 1;
  }
  for (let i7 = 1; i7 < n6; ++i7) {
    if (arr[i7] == target) {
      return i7;
    }
    if (arr[i7] < target) {
      if (arr[i7 - 1] - target < target - arr[i7]) {
        return i7 - 1;
      }
      return i7;
    }
  }
  return n6 - 1;
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
function extend2(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i7 = 0; i7 < length; i7++) {
    arr[arr.length] = extension[i7];
  }
}
function equals3(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i7 = 0; i7 < len1; i7++) {
    if (arr1[i7] !== arr2[i7]) {
      return false;
    }
  }
  return true;
}
var init_array = __esm({
  "node_modules/ol/array.js"() {
  }
});

// node_modules/ol/functions.js
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn4) {
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!lastArgs || this !== lastThis || !equals3(nextArgs, lastArgs)) {
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn4.apply(this, arguments);
    }
    return lastResult;
  };
}
var init_functions = __esm({
  "node_modules/ol/functions.js"() {
    init_array();
  }
});

// node_modules/ol/events/Event.js
var BaseEvent, Event_default;
var init_Event = __esm({
  "node_modules/ol/events/Event.js"() {
    BaseEvent = class {
      /**
       * @param {string} type Type.
       */
      constructor(type) {
        this.propagationStopped;
        this.defaultPrevented;
        this.type = type;
        this.target = null;
      }
      /**
       * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
       * will be fired.
       * @api
       */
      preventDefault() {
        this.defaultPrevented = true;
      }
      /**
       * Stop event propagation.
       * @api
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
    Event_default = BaseEvent;
  }
});

// node_modules/ol/events/Target.js
var Target, Target_default;
var init_Target = __esm({
  "node_modules/ol/events/Target.js"() {
    init_Disposable();
    init_functions();
    init_obj();
    init_Event();
    Target = class extends Disposable_default {
      /**
       * @param {*} [target] Default event target for dispatched events.
       */
      constructor(target) {
        super();
        this.eventTarget_ = target;
        this.pendingRemovals_ = null;
        this.dispatching_ = null;
        this.listeners_ = null;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      addEventListener(type, listener) {
        if (!type || !listener) {
          return;
        }
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) {
          listenersForType.push(listener);
        }
      }
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      dispatchEvent(event) {
        const isString = typeof event === "string";
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
          return;
        }
        const evt = isString ? new Event_default(event) : (
          /** @type {Event} */
          event
        );
        if (!evt.target) {
          evt.target = this.eventTarget_ || this;
        }
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
          dispatching[type] = 0;
          pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for (let i7 = 0, ii = listeners.length; i7 < ii; ++i7) {
          if ("handleEvent" in listeners[i7]) {
            propagate = /** @type {import("../events.js").ListenerObject} */
            listeners[i7].handleEvent(evt);
          } else {
            propagate = /** @type {import("../events.js").ListenerFunction} */
            listeners[i7].call(this, evt);
          }
          if (propagate === false || evt.propagationStopped) {
            propagate = false;
            break;
          }
        }
        if (--dispatching[type] === 0) {
          let pr2 = pendingRemovals[type];
          delete pendingRemovals[type];
          while (pr2--) {
            this.removeEventListener(type, VOID);
          }
          delete dispatching[type];
        }
        return propagate;
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        this.listeners_ && clear(this.listeners_);
      }
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      getListeners(type) {
        return this.listeners_ && this.listeners_[type] || void 0;
      }
      /**
       * @param {string} [type] Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      hasListener(type) {
        if (!this.listeners_) {
          return false;
        }
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      removeEventListener(type, listener) {
        if (!this.listeners_) {
          return;
        }
        const listeners = this.listeners_[type];
        if (!listeners) {
          return;
        }
        const index13 = listeners.indexOf(listener);
        if (index13 !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            listeners[index13] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index13, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    };
    Target_default = Target;
  }
});

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (once) {
    const originalListener = listener;
    listener = function(event) {
      target.removeEventListener(type, listener);
      return originalListener.call(thisArg ?? this, event);
    };
  } else if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}
var init_events = __esm({
  "node_modules/ol/events.js"() {
    init_obj();
  }
});

// node_modules/ol/Observable.js
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i7 = 0, ii = key.length; i7 < ii; ++i7) {
      unlistenByKey(key[i7]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
var Observable, Observable_default;
var init_Observable = __esm({
  "node_modules/ol/Observable.js"() {
    init_EventType();
    init_Target();
    init_events();
    Observable = class extends Target_default {
      constructor() {
        super();
        this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onInternal;
        this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onceInternal;
        this.un = /** @type {ObservableOnSignature<void>} */
        this.unInternal;
        this.revision_ = 0;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      changed() {
        ++this.revision_;
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      getRevision() {
        return this.revision_;
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onInternal(type, listener) {
        if (Array.isArray(type)) {
          const len = type.length;
          const keys = new Array(len);
          for (let i7 = 0; i7 < len; ++i7) {
            keys[i7] = listen(this, type[i7], listener);
          }
          return keys;
        }
        return listen(
          this,
          /** @type {string} */
          type,
          listener
        );
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
          const len = type.length;
          key = new Array(len);
          for (let i7 = 0; i7 < len; ++i7) {
            key[i7] = listenOnce(this, type[i7], listener);
          }
        } else {
          key = listenOnce(
            this,
            /** @type {string} */
            type,
            listener
          );
        }
        listener.ol_key = key;
        return key;
      }
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @protected
       */
      unInternal(type, listener) {
        const key = (
          /** @type {Object} */
          listener.ol_key
        );
        if (key) {
          unByKey(key);
        } else if (Array.isArray(type)) {
          for (let i7 = 0, ii = type.length; i7 < ii; ++i7) {
            this.removeEventListener(type[i7], listener);
          }
        } else {
          this.removeEventListener(type, listener);
        }
      }
    };
    Observable.prototype.on;
    Observable.prototype.once;
    Observable.prototype.un;
    Observable_default = Observable;
  }
});

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var uidCounter_;
var init_util = __esm({
  "node_modules/ol/util.js"() {
    uidCounter_ = 0;
  }
});

// node_modules/ol/Object.js
var ObjectEvent, BaseObject, Object_default;
var init_Object = __esm({
  "node_modules/ol/Object.js"() {
    init_ObjectEventType();
    init_Observable();
    init_Event();
    init_obj();
    init_util();
    ObjectEvent = class extends Event_default {
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      constructor(type, key, oldValue) {
        super(type);
        this.key = key;
        this.oldValue = oldValue;
      }
    };
    BaseObject = class extends Observable_default {
      /**
       * @param {Object<string, *>} [values] An object with key-value pairs.
       */
      constructor(values) {
        super();
        this.on;
        this.once;
        this.un;
        getUid(this);
        this.values_ = null;
        if (values !== void 0) {
          this.setProperties(values);
        }
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) {
          value = this.values_[key];
        }
        return value;
      }
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.values_;
      }
      /**
       * @return {boolean} The object has properties.
       */
      hasProperties() {
        return !!this.values_;
      }
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
        eventType = ObjectEventType_default.PROPERTYCHANGE;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
      }
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) {
          values[key] = value;
        } else {
          const oldValue = values[key];
          values[key] = value;
          if (oldValue !== value) {
            this.notify(key, oldValue);
          }
        }
      }
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      setProperties(values, silent) {
        for (const key in values) {
          this.set(key, values[key], silent);
        }
      }
      /**
       * Apply any properties from another object without triggering events.
       * @param {BaseObject} source The source object.
       * @protected
       */
      applyProperties(source) {
        if (!source.values_) {
          return;
        }
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
      }
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean} [silent] Unset without triggering an event.
       * @api
       */
      unset(key, silent) {
        if (this.values_ && key in this.values_) {
          const oldValue = this.values_[key];
          delete this.values_[key];
          if (isEmpty2(this.values_)) {
            this.values_ = null;
          }
          if (!silent) {
            this.notify(key, oldValue);
          }
        }
      }
    };
    Object_default = BaseObject;
  }
});

// node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
var init_asserts = __esm({
  "node_modules/ol/asserts.js"() {
  }
});

// node_modules/ol/Feature.js
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(
      typeof /** @type {?} */
      obj.getZIndex === "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    );
    const style = (
      /** @type {import("./style/Style.js").default} */
      obj
    );
    styles = [style];
  }
  return function() {
    return styles;
  };
}
var Feature, Feature_default;
var init_Feature = __esm({
  "node_modules/ol/Feature.js"() {
    init_Object();
    init_asserts();
    init_EventType();
    init_events();
    Feature = class _Feature extends Object_default {
      /**
       * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
       *     You may pass a Geometry object directly, or an object literal containing
       *     properties. If you pass an object literal, you may include a Geometry
       *     associated with a `geometry` key.
       */
      constructor(geometryOrProperties) {
        super();
        this.on;
        this.once;
        this.un;
        this.id_ = void 0;
        this.geometryName_ = "geometry";
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
          if (typeof /** @type {?} */
          geometryOrProperties.getSimplifiedGeometry === "function") {
            const geometry = (
              /** @type {Geometry} */
              geometryOrProperties
            );
            this.setGeometry(geometry);
          } else {
            const properties = geometryOrProperties;
            this.setProperties(properties);
          }
        }
      }
      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {Feature<Geometry>} The clone.
       * @api
       */
      clone() {
        const clone2 = (
          /** @type {Feature<Geometry>} */
          new _Feature(this.hasProperties() ? this.getProperties() : null)
        );
        clone2.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) {
          clone2.setGeometry(
            /** @type {Geometry} */
            geometry.clone()
          );
        }
        const style = this.getStyle();
        if (style) {
          clone2.setStyle(style);
        }
        return clone2;
      }
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      getGeometry() {
        return (
          /** @type {Geometry|undefined} */
          this.get(this.geometryName_)
        );
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      getGeometryName() {
        return this.geometryName_;
      }
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @private
       */
      handleGeometryChange_() {
        this.changed();
      }
      /**
       * @private
       */
      handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
          unlistenByKey(this.geometryChangeKey_);
          this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) {
          this.geometryChangeKey_ = listen(
            geometry,
            EventType_default.CHANGE,
            this.handleGeometryChange_,
            this
          );
        }
        this.changed();
      }
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
      }
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
        this.changed();
      }
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setId(id) {
        this.id_ = id;
        this.changed();
      }
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
      }
    };
    Feature_default = Feature;
  }
});

// node_modules/ol/transform.js
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function setFromArray(transform1, transform22) {
  transform1[0] = transform22[0];
  transform1[1] = transform22[1];
  transform1[2] = transform22[2];
  transform1[3] = transform22[3];
  transform1[4] = transform22[4];
  transform1[5] = transform22[5];
  return transform1;
}
function apply(transform3, coordinate) {
  const x4 = coordinate[0];
  const y5 = coordinate[1];
  coordinate[0] = transform3[0] * x4 + transform3[2] * y5 + transform3[4];
  coordinate[1] = transform3[1] * x4 + transform3[3] * y5 + transform3[5];
  return coordinate;
}
function compose(transform3, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform3[0] = sx * cos;
  transform3[1] = sy * sin;
  transform3[2] = -sx * sin;
  transform3[3] = sy * cos;
  transform3[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform3[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform3;
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, "Transformation matrix cannot be inverted");
  const a5 = source[0];
  const b8 = source[1];
  const c7 = source[2];
  const d2 = source[3];
  const e3 = source[4];
  const f8 = source[5];
  target[0] = d2 / det;
  target[1] = -b8 / det;
  target[2] = -c7 / det;
  target[3] = a5 / det;
  target[4] = (c7 * f8 - d2 * e3) / det;
  target[5] = -(a5 * f8 - b8 * e3) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
function toString(mat) {
  const transformString = "matrix(" + mat.join(", ") + ")";
  return transformString;
}
function fromString(cssTransform) {
  const values = cssTransform.substring(7, cssTransform.length - 1).split(",");
  return values.map(parseFloat);
}
function equivalent2(cssTransform1, cssTransform2) {
  const mat1 = fromString(cssTransform1);
  const mat2 = fromString(cssTransform2);
  for (let i7 = 0; i7 < 6; ++i7) {
    if (Math.round((mat1[i7] - mat2[i7]) * matrixPrecision[i7]) !== 0) {
      return false;
    }
  }
  return true;
}
var tmp_, matrixPrecision;
var init_transform = __esm({
  "node_modules/ol/transform.js"() {
    init_asserts();
    tmp_ = new Array(6);
    matrixPrecision = [1e5, 1e5, 1e5, 1e5, 2, 2];
  }
});

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset, end, stride, transform3, dest, destinationStride) {
  dest = dest ? dest : [];
  destinationStride = destinationStride ? destinationStride : 2;
  let i7 = 0;
  for (let j6 = offset; j6 < end; j6 += stride) {
    const x4 = flatCoordinates[j6];
    const y5 = flatCoordinates[j6 + 1];
    dest[i7++] = transform3[0] * x4 + transform3[2] * y5 + transform3[4];
    dest[i7++] = transform3[1] * x4 + transform3[3] * y5 + transform3[5];
    for (let k5 = 2; k5 < destinationStride; k5++) {
      dest[i7++] = flatCoordinates[j6 + k5];
    }
  }
  if (dest && dest.length != i7) {
    dest.length = i7;
  }
  return dest;
}
function rotate2(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i7 = 0;
  for (let j6 = offset; j6 < end; j6 += stride) {
    const deltaX = flatCoordinates[j6] - anchorX;
    const deltaY = flatCoordinates[j6 + 1] - anchorY;
    dest[i7++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i7++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k5 = j6 + 2; k5 < j6 + stride; ++k5) {
      dest[i7++] = flatCoordinates[k5];
    }
  }
  if (dest && dest.length != i7) {
    dest.length = i7;
  }
  return dest;
}
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i7 = 0;
  for (let j6 = offset; j6 < end; j6 += stride) {
    const deltaX = flatCoordinates[j6] - anchorX;
    const deltaY = flatCoordinates[j6 + 1] - anchorY;
    dest[i7++] = anchorX + sx * deltaX;
    dest[i7++] = anchorY + sy * deltaY;
    for (let k5 = j6 + 2; k5 < j6 + stride; ++k5) {
      dest[i7++] = flatCoordinates[k5];
    }
  }
  if (dest && dest.length != i7) {
    dest.length = i7;
  }
  return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i7 = 0;
  for (let j6 = offset; j6 < end; j6 += stride) {
    dest[i7++] = flatCoordinates[j6] + deltaX;
    dest[i7++] = flatCoordinates[j6 + 1] + deltaY;
    for (let k5 = j6 + 2; k5 < j6 + stride; ++k5) {
      dest[i7++] = flatCoordinates[k5];
    }
  }
  if (dest && dest.length != i7) {
    dest.length = i7;
  }
  return dest;
}
var init_transform2 = __esm({
  "node_modules/ol/geom/flat/transform.js"() {
  }
});

// node_modules/ol/geom/Geometry.js
var tmpTransform, tmpPoint, Geometry, Geometry_default;
var init_Geometry = __esm({
  "node_modules/ol/geom/Geometry.js"() {
    init_Object();
    init_extent();
    init_functions();
    init_proj();
    init_transform();
    init_util();
    init_transform2();
    tmpTransform = create();
    tmpPoint = [NaN, NaN];
    Geometry = class extends Object_default {
      constructor() {
        super();
        this.extent_ = createEmpty();
        this.extentRevision_ = -1;
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = 0;
        this.simplifyTransformedInternal = memoizeOne(
          (revision, squaredTolerance, transform3) => {
            if (!transform3) {
              return this.getSimplifiedGeometry(squaredTolerance);
            }
            const clone2 = this.clone();
            clone2.applyTransform(transform3);
            return clone2.getSimplifiedGeometry(squaredTolerance);
          }
        );
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform3) {
        return this.simplifyTransformedInternal(
          this.getRevision(),
          squaredTolerance,
          transform3
        );
      }
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */
      clone() {
        return abstract();
      }
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        return abstract();
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x4, y5) {
        return this.closestPointXY(x4, y5, tmpPoint, Number.MIN_VALUE) === 0;
      }
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */
      getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [NaN, NaN];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
      }
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
      }
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return abstract();
      }
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */
      getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
          const extent2 = this.computeExtent(this.extent_);
          if (isNaN(extent2[0]) || isNaN(extent2[1])) {
            createOrUpdateEmpty(extent2);
          }
          this.extentRevision_ = this.getRevision();
        }
        return returnOrUpdate(this.extent_, extent);
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        abstract();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      scale(sx, sy, anchor) {
        abstract();
      }
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */
      simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return abstract();
      }
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {Type} Geometry type.
       */
      getType() {
        return abstract();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */
      applyTransform(transformFn) {
        abstract();
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      intersectsExtent(extent) {
        return abstract();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      translate(deltaX, deltaY) {
        abstract();
      }
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {this} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      transform(source, destination) {
        const sourceProj = get4(source);
        const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
          const pixelExtent = sourceProj.getExtent();
          const projectedExtent = sourceProj.getWorldExtent();
          const scale3 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform,
            projectedExtent[0],
            projectedExtent[3],
            scale3,
            -scale3,
            0,
            0,
            0
          );
          const transformed = transform2D(
            inCoordinates,
            0,
            inCoordinates.length,
            stride,
            tmpTransform,
            outCoordinates
          );
          const projTransform = getTransform(sourceProj, destination);
          if (projTransform) {
            return projTransform(transformed, transformed, stride);
          }
          return transformed;
        } : getTransform(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
      }
    };
    Geometry_default = Geometry;
  }
});

// node_modules/ol/geom/SimpleGeometry.js
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
function transformGeom2D(simpleGeometry, transform3, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return transform2D(
    flatCoordinates,
    0,
    flatCoordinates.length,
    stride,
    transform3,
    dest
  );
}
var SimpleGeometry, SimpleGeometry_default;
var init_SimpleGeometry = __esm({
  "node_modules/ol/geom/SimpleGeometry.js"() {
    init_extent();
    init_util();
    init_Geometry();
    init_transform2();
    SimpleGeometry = class extends Geometry_default {
      constructor() {
        super();
        this.layout = "XY";
        this.stride = 2;
        this.flatCoordinates;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        return createOrUpdateFromFlatCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent
        );
      }
      /**
       * @abstract
       * @return {Array<*> | null} Coordinates.
       */
      getCoordinates() {
        return abstract();
      }
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */
      getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getFlatCoordinates() {
        return this.flatCoordinates;
      }
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */
      getLastCoordinate() {
        return this.flatCoordinates.slice(
          this.flatCoordinates.length - this.stride
        );
      }
      /**
       * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
       * @return {import("./Geometry.js").GeometryLayout} Layout.
       * @api
       */
      getLayout() {
        return this.layout;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @override
       */
      getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }
        const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
          return simplifiedGeometry;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride;
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */
      setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
      }
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      setCoordinates(coordinates2, layout) {
        abstract();
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      setLayout(layout, coordinates2, nesting) {
        let stride;
        if (layout) {
          stride = getStrideForLayout(layout);
        } else {
          for (let i7 = 0; i7 < nesting; ++i7) {
            if (coordinates2.length === 0) {
              this.layout = "XY";
              this.stride = 2;
              return;
            }
            coordinates2 = /** @type {Array<unknown>} */
            coordinates2[0];
          }
          stride = coordinates2.length;
          layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       * @override
       */
      applyTransform(transformFn) {
        if (this.flatCoordinates) {
          transformFn(
            this.flatCoordinates,
            this.flatCoordinates,
            this.layout.startsWith("XYZ") ? 3 : 2,
            this.stride
          );
          this.changed();
        }
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       * @override
       */
      rotate(angle, anchor) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          rotate2(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            angle,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       * @override
       */
      scale(sx, sy, anchor) {
        if (sy === void 0) {
          sy = sx;
        }
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          scale(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            sx,
            sy,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       * @override
       */
      translate(deltaX, deltaY) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          translate(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            deltaX,
            deltaY,
            flatCoordinates
          );
          this.changed();
        }
      }
    };
    SimpleGeometry_default = SimpleGeometry;
  }
});

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i7 = 0, ii = coordinate.length; i7 < ii; ++i7) {
    flatCoordinates[offset++] = coordinate[i7];
  }
  return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates2, stride) {
  for (let i7 = 0, ii = coordinates2.length; i7 < ii; ++i7) {
    const coordinate = coordinates2[i7];
    for (let j6 = 0; j6 < stride; ++j6) {
      flatCoordinates[offset++] = coordinate[j6];
    }
  }
  return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i7 = 0;
  for (let j6 = 0, jj = coordinatess.length; j6 < jj; ++j6) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j6],
      stride
    );
    ends[i7++] = end;
    offset = end;
  }
  ends.length = i7;
  return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, endss) {
  endss = endss ? endss : [];
  let i7 = 0;
  for (let j6 = 0, jj = coordinatesss.length; j6 < jj; ++j6) {
    const ends = deflateCoordinatesArray(
      flatCoordinates,
      offset,
      coordinatesss[j6],
      stride,
      endss[i7]
    );
    if (ends.length === 0) {
      ends[0] = offset;
    }
    endss[i7++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i7;
  return endss;
}
var init_deflate = __esm({
  "node_modules/ol/geom/flat/deflate.js"() {
  }
});

// node_modules/ol/geom/flat/center.js
function linearRingss(flatCoordinates, offset, endss, stride) {
  const flatCenters = [];
  let extent = createEmpty();
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    const ends = endss[i7];
    extent = createOrUpdateFromFlatCoordinates(
      flatCoordinates,
      offset,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}
var init_center = __esm({
  "node_modules/ol/geom/flat/center.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x4, y5) {
  let wn2 = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x22 = flatCoordinates[offset];
    const y22 = flatCoordinates[offset + 1];
    if (y1 <= y5) {
      if (y22 > y5 && (x22 - x1) * (y5 - y1) - (x4 - x1) * (y22 - y1) > 0) {
        wn2++;
      }
    } else if (y22 <= y5 && (x22 - x1) * (y5 - y1) - (x4 - x1) * (y22 - y1) < 0) {
      wn2--;
    }
    x1 = x22;
    y1 = y22;
  }
  return wn2 !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x4, y5) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x4, y5)) {
    return false;
  }
  for (let i7 = 1, ii = ends.length; i7 < ii; ++i7) {
    if (linearRingContainsXY(flatCoordinates, ends[i7 - 1], ends[i7], stride, x4, y5)) {
      return false;
    }
  }
  return true;
}
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x4, y5) {
  if (endss.length === 0) {
    return false;
  }
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    const ends = endss[i7];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x4, y5)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}
var init_contains = __esm({
  "node_modules/ol/geom/flat/contains.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i7, ii, x4, x1, x22, y1, y22;
  const y5 = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r5 = 0, rr = ends.length; r5 < rr; ++r5) {
    const end = ends[r5];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i7 = offset; i7 < end; i7 += stride) {
      x22 = flatCoordinates[i7];
      y22 = flatCoordinates[i7 + 1];
      if (y5 <= y1 && y22 <= y5 || y1 <= y5 && y5 <= y22) {
        x4 = (y5 - y1) / (y22 - y1) * (x22 - x1) + x1;
        intersections.push(x4);
      }
      x1 = x22;
      y1 = y22;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i7 = 1, ii = intersections.length; i7 < ii; ++i7) {
    x22 = intersections[i7];
    const segmentLength = Math.abs(x22 - x1);
    if (segmentLength > maxSegmentLength) {
      x4 = (x1 + x22) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x4, y5)) {
        pointX = x4;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x22;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y5, maxSegmentLength);
    return dest;
  }
  return [pointX, y5, maxSegmentLength];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  let interiorPoints = [];
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    const ends = endss[i7];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      flatCenters,
      2 * i7,
      interiorPoints
    );
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}
var init_interiorpoint = __esm({
  "node_modules/ol/geom/flat/interiorpoint.js"() {
    init_array();
    init_contains();
  }
});

// node_modules/ol/geom/flat/interpolate.js
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
  let o5, t4;
  const n6 = (end - offset) / stride;
  if (n6 === 1) {
    o5 = offset;
  } else if (n6 === 2) {
    o5 = offset;
    t4 = fraction;
  } else if (n6 !== 0) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i7 = offset + stride; i7 < end; i7 += stride) {
      const x22 = flatCoordinates[i7];
      const y22 = flatCoordinates[i7 + 1];
      length += Math.sqrt((x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1));
      cumulativeLengths.push(length);
      x1 = x22;
      y1 = y22;
    }
    const target = fraction * length;
    const index13 = binarySearch(cumulativeLengths, target);
    if (index13 < 0) {
      t4 = (target - cumulativeLengths[-index13 - 2]) / (cumulativeLengths[-index13 - 1] - cumulativeLengths[-index13 - 2]);
      o5 = offset + (-index13 - 2) * stride;
    } else {
      o5 = offset + index13 * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i7 = 0; i7 < dimension; ++i7) {
    dest[i7] = o5 === void 0 ? NaN : t4 === void 0 ? flatCoordinates[o5 + i7] : lerp(flatCoordinates[o5 + i7], flatCoordinates[o5 + stride + i7], t4);
  }
  return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m8, extrapolate) {
  if (end == offset) {
    return null;
  }
  let coordinate;
  if (m8 < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m8;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[end - 1] < m8) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m8;
      return coordinate;
    }
    return null;
  }
  if (m8 == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  let lo = offset / stride;
  let hi = end / stride;
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (m8 < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  const m0 = flatCoordinates[lo * stride - 1];
  if (m8 == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  const m1 = flatCoordinates[(lo + 1) * stride - 1];
  const t4 = (m8 - m0) / (m1 - m0);
  coordinate = [];
  for (let i7 = 0; i7 < stride - 1; ++i7) {
    coordinate.push(
      lerp(
        flatCoordinates[(lo - 1) * stride + i7],
        flatCoordinates[lo * stride + i7],
        t4
      )
    );
  }
  coordinate.push(m8);
  return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m8, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates,
      offset,
      ends[ends.length - 1],
      stride,
      m8,
      extrapolate
    );
  }
  let coordinate;
  if (m8 < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m8;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m8) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m8;
      return coordinate;
    }
    return null;
  }
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    const end = ends[i7];
    if (offset == end) {
      continue;
    }
    if (m8 < flatCoordinates[offset + stride - 1]) {
      return null;
    }
    if (m8 <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates,
        offset,
        end,
        stride,
        m8,
        false
      );
    }
    offset = end;
  }
  return null;
}
var init_interpolate = __esm({
  "node_modules/ol/geom/flat/interpolate.js"() {
    init_array();
    init_math();
  }
});

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i7 = 0; i7 < stride; ++i7) {
      const tmp = flatCoordinates[offset + i7];
      flatCoordinates[offset + i7] = flatCoordinates[end - stride + i7];
      flatCoordinates[end - stride + i7] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}
var init_reverse = __esm({
  "node_modules/ol/geom/flat/reverse.js"() {
  }
});

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x22 = flatCoordinates[offset];
    const y22 = flatCoordinates[offset + 1];
    edge += (x22 - x1) * (y22 + y1);
    x1 = x22;
    y1 = y22;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    const end = ends[i7];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i7 === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}
function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    const ends = endss[i7];
    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    const end = ends[i7];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse = i7 === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    offset = orientLinearRings(
      flatCoordinates,
      offset,
      endss[i7],
      stride,
      right
    );
  }
  return offset;
}
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset = 0;
  let prevEndIndex = 0;
  let startOrientation;
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    const end = ends[i7];
    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
    if (startOrientation === void 0) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i7 + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i7 + 1;
    offset = end;
  }
  return endss;
}
var init_orient = __esm({
  "node_modules/ol/geom/flat/orient.js"() {
    init_reverse();
  }
});

// node_modules/ol/geom/flat/simplify.js
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n6 = (end - offset) / stride;
  if (n6 < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n6);
  markers[0] = 1;
  markers[n6 - 1] = 1;
  const stack = [offset, end - stride];
  let index13 = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x22 = flatCoordinates[last];
    const y22 = flatCoordinates[last + 1];
    for (let i7 = first + stride; i7 < last; i7 += stride) {
      const x4 = flatCoordinates[i7];
      const y5 = flatCoordinates[i7 + 1];
      const squaredDistance4 = squaredSegmentDistance(x4, y5, x1, y1, x22, y22);
      if (squaredDistance4 > maxSquaredDistance) {
        index13 = i7;
        maxSquaredDistance = squaredDistance4;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index13 - offset) / stride] = 1;
      if (first + stride < index13) {
        stack.push(first, index13);
      }
      if (index13 + stride < last) {
        stack.push(index13, last);
      }
    }
  }
  for (let i7 = 0; i7 < n6; ++i7) {
    if (markers[i7]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i7 * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i7 * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    const end = ends[i7];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x22, y22;
  do {
    x22 = snap(flatCoordinates[offset], tolerance);
    y22 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x22;
      simplifiedFlatCoordinates[simplifiedOffset++] = y22;
      return simplifiedOffset;
    }
  } while (x22 == x1 && y22 == y1);
  while (offset < end) {
    const x32 = snap(flatCoordinates[offset], tolerance);
    const y32 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (x32 == x22 && y32 == y22) {
      continue;
    }
    const dx1 = x22 - x1;
    const dy1 = y22 - y1;
    const dx2 = x32 - x1;
    const dy2 = y32 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x22 = x32;
      y22 = y32;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x22;
    simplifiedFlatCoordinates[simplifiedOffset++] = y22;
    x1 = x22;
    y1 = y22;
    x22 = x32;
    y22 = y32;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x22;
  simplifiedFlatCoordinates[simplifiedOffset++] = y22;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    const end = ends[i7];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    const ends = endss[i7];
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
var init_simplify = __esm({
  "node_modules/ol/geom/flat/simplify.js"() {
    init_math();
  }
});

// node_modules/ol/geom/Circle.js
var Circle, Circle_default;
var init_Circle = __esm({
  "node_modules/ol/geom/Circle.js"() {
    init_extent();
    init_SimpleGeometry();
    init_deflate();
    init_transform2();
    Circle = class _Circle extends SimpleGeometry_default {
      /**
       * @param {!import("../coordinate.js").Coordinate} center Center.
       *     For internal use, flat coordinates in combination with `layout` and no
       *     `radius` are also accepted.
       * @param {number} [radius] Radius in units of the projection.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(center, radius, layout) {
        super();
        if (layout !== void 0 && radius === void 0) {
          this.setFlatCoordinates(layout, center);
        } else {
          radius = radius ? radius : 0;
          this.setCenterAndRadius(center, radius, layout);
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Circle} Clone.
       * @api
       * @override
       */
      clone() {
        const circle = new _Circle(
          this.flatCoordinates.slice(),
          void 0,
          this.layout
        );
        circle.applyProperties(this);
        return circle;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x4 - flatCoordinates[0];
        const dy = y5 - flatCoordinates[1];
        const squaredDistance4 = dx * dx + dy * dy;
        if (squaredDistance4 < minSquaredDistance) {
          if (squaredDistance4 === 0) {
            for (let i7 = 0; i7 < this.stride; ++i7) {
              closestPoint[i7] = flatCoordinates[i7];
            }
          } else {
            const delta = this.getRadius() / Math.sqrt(squaredDistance4);
            closestPoint[0] = flatCoordinates[0] + delta * dx;
            closestPoint[1] = flatCoordinates[1] + delta * dy;
            for (let i7 = 2; i7 < this.stride; ++i7) {
              closestPoint[i7] = flatCoordinates[i7];
            }
          }
          closestPoint.length = this.stride;
          return squaredDistance4;
        }
        return minSquaredDistance;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x4, y5) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x4 - flatCoordinates[0];
        const dy = y5 - flatCoordinates[1];
        return dx * dx + dy * dy <= this.getRadiusSquared_();
      }
      /**
       * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @return {import("../coordinate.js").Coordinate} Center.
       * @api
       */
      getCenter() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const radius = flatCoordinates[this.stride] - flatCoordinates[0];
        return createOrUpdate(
          flatCoordinates[0] - radius,
          flatCoordinates[1] - radius,
          flatCoordinates[0] + radius,
          flatCoordinates[1] + radius,
          extent
        );
      }
      /**
       * Return the radius of the circle.
       * @return {number} Radius.
       * @api
       */
      getRadius() {
        return Math.sqrt(this.getRadiusSquared_());
      }
      /**
       * @private
       * @return {number} Radius squared.
       */
      getRadiusSquared_() {
        const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
        const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return dx * dx + dy * dy;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "Circle";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        const circleExtent = this.getExtent();
        if (intersects(extent, circleExtent)) {
          const center = this.getCenter();
          if (extent[0] <= center[0] && extent[2] >= center[0]) {
            return true;
          }
          if (extent[1] <= center[1] && extent[3] >= center[1]) {
            return true;
          }
          return forEachCorner(extent, this.intersectsCoordinate.bind(this));
        }
        return false;
      }
      /**
       * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} center Center.
       * @api
       */
      setCenter(center) {
        const stride = this.stride;
        const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
        const flatCoordinates = center.slice();
        flatCoordinates[stride] = flatCoordinates[0] + radius;
        for (let i7 = 1; i7 < stride; ++i7) {
          flatCoordinates[stride + i7] = center[i7];
        }
        this.setFlatCoordinates(this.layout, flatCoordinates);
        this.changed();
      }
      /**
       * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
       * number) of the circle.
       * @param {!import("../coordinate.js").Coordinate} center Center.
       * @param {number} radius Radius.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCenterAndRadius(center, radius, layout) {
        this.setLayout(layout, center, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const flatCoordinates = this.flatCoordinates;
        let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);
        flatCoordinates[offset++] = flatCoordinates[0] + radius;
        for (let i7 = 1, ii = this.stride; i7 < ii; ++i7) {
          flatCoordinates[offset++] = flatCoordinates[i7];
        }
        flatCoordinates.length = offset;
        this.changed();
      }
      /**
       * @override
       */
      getCoordinates() {
        return null;
      }
      /**
       * @override
       */
      setCoordinates(coordinates2, layout) {
      }
      /**
       * Set the radius of the circle. The radius is in the units of the projection.
       * @param {number} radius Radius.
       * @api
       */
      setRadius(radius) {
        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
        this.changed();
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       * @override
       */
      rotate(angle, anchor) {
        const center = this.getCenter();
        const stride = this.getStride();
        this.setCenter(
          rotate2(center, 0, center.length, stride, angle, anchor, center)
        );
        this.changed();
      }
    };
    Circle.prototype.transform;
    Circle_default = Circle;
  }
});

// node_modules/ol/geom/GeometryCollection.js
function cloneGeometries(geometries) {
  return geometries.map((geometry) => geometry.clone());
}
var GeometryCollection, GeometryCollection_default;
var init_GeometryCollection = __esm({
  "node_modules/ol/geom/GeometryCollection.js"() {
    init_EventType();
    init_events();
    init_extent();
    init_Geometry();
    GeometryCollection = class _GeometryCollection extends Geometry_default {
      /**
       * @param {Array<Geometry>} geometries Geometries.
       */
      constructor(geometries) {
        super();
        this.geometries_ = geometries;
        this.changeEventsKeys_ = [];
        this.listenGeometriesChange_();
      }
      /**
       * @private
       */
      unlistenGeometriesChange_() {
        this.changeEventsKeys_.forEach(unlistenByKey);
        this.changeEventsKeys_.length = 0;
      }
      /**
       * @private
       */
      listenGeometriesChange_() {
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          this.changeEventsKeys_.push(
            listen(geometries[i7], EventType_default.CHANGE, this.changed, this)
          );
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!GeometryCollection} Clone.
       * @api
       * @override
       */
      clone() {
        const geometryCollection = new _GeometryCollection(
          cloneGeometries(this.geometries_)
        );
        geometryCollection.applyProperties(this);
        return geometryCollection;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x4, y5)) {
          return minSquaredDistance;
        }
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          minSquaredDistance = geometries[i7].closestPointXY(
            x4,
            y5,
            closestPoint,
            minSquaredDistance
          );
        }
        return minSquaredDistance;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x4, y5) {
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          if (geometries[i7].containsXY(x4, y5)) {
            return true;
          }
        }
        return false;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        createOrUpdateEmpty(extent);
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          extend(extent, geometries[i7].getExtent());
        }
        return extent;
      }
      /**
       * Return the geometries that make up this geometry collection.
       * @return {Array<Geometry>} Geometries.
       * @api
       */
      getGeometries() {
        return cloneGeometries(this.geometries_);
      }
      /**
       * @return {Array<Geometry>} Geometries.
       */
      getGeometriesArray() {
        return this.geometries_;
      }
      /**
       * @return {Array<Geometry>} Geometries.
       */
      getGeometriesArrayRecursive() {
        let geometriesArray = [];
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          if (geometries[i7].getType() === this.getType()) {
            geometriesArray = geometriesArray.concat(
              /** @type {GeometryCollection} */
              geometries[i7].getGeometriesArrayRecursive()
            );
          } else {
            geometriesArray.push(geometries[i7]);
          }
        }
        return geometriesArray;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {GeometryCollection} Simplified GeometryCollection.
       * @override
       */
      getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }
        const simplifiedGeometries = [];
        const geometries = this.geometries_;
        let simplified = false;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          const geometry = geometries[i7];
          const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
          simplifiedGeometries.push(simplifiedGeometry);
          if (simplifiedGeometry !== geometry) {
            simplified = true;
          }
        }
        if (simplified) {
          const simplifiedGeometryCollection = new _GeometryCollection(
            simplifiedGeometries
          );
          return simplifiedGeometryCollection;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "GeometryCollection";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          if (geometries[i7].intersectsExtent(extent)) {
            return true;
          }
        }
        return false;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return this.geometries_.length === 0;
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       * @override
       */
      rotate(angle, anchor) {
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          geometries[i7].rotate(angle, anchor);
        }
        this.changed();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       * @override
       */
      scale(sx, sy, anchor) {
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          geometries[i7].scale(sx, sy, anchor);
        }
        this.changed();
      }
      /**
       * Set the geometries that make up this geometry collection.
       * @param {Array<Geometry>} geometries Geometries.
       * @api
       */
      setGeometries(geometries) {
        this.setGeometriesArray(cloneGeometries(geometries));
      }
      /**
       * @param {Array<Geometry>} geometries Geometries.
       */
      setGeometriesArray(geometries) {
        this.unlistenGeometriesChange_();
        this.geometries_ = geometries;
        this.listenGeometriesChange_();
        this.changed();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       * @override
       */
      applyTransform(transformFn) {
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          geometries[i7].applyTransform(transformFn);
        }
        this.changed();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       * @override
       */
      translate(deltaX, deltaY) {
        const geometries = this.geometries_;
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          geometries[i7].translate(deltaX, deltaY);
        }
        this.changed();
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        this.unlistenGeometriesChange_();
        super.disposeInternal();
      }
    };
    GeometryCollection_default = GeometryCollection;
  }
});

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  const x0 = flatCoordinates[end - stride];
  const y0 = flatCoordinates[end - stride + 1];
  let dx1 = 0;
  let dy1 = 0;
  for (; offset < end; offset += stride) {
    const dx2 = flatCoordinates[offset] - x0;
    const dy2 = flatCoordinates[offset + 1] - y0;
    twiceArea += dy1 * dx2 - dx1 * dy2;
    dx1 = dx2;
    dy1 = dy2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    const end = ends[i7];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}
function linearRingss2(flatCoordinates, offset, endss, stride) {
  let area = 0;
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    const ends = endss[i7];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}
var init_area = __esm({
  "node_modules/ol/geom/flat/area.js"() {
  }
});

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x4, y5, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t4 = ((x4 - x1) * dx + (y5 - y1) * dy) / (dx * dx + dy * dy);
    if (t4 > 1) {
      offset = offset2;
    } else if (t4 > 0) {
      for (let i7 = 0; i7 < stride; ++i7) {
        closestPoint[i7] = lerp(
          flatCoordinates[offset1 + i7],
          flatCoordinates[offset2 + i7],
          t4
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i7 = 0; i7 < stride; ++i7) {
    closestPoint[i7] = flatCoordinates[offset + i7];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x22 = flatCoordinates[offset];
    const y22 = flatCoordinates[offset + 1];
    const squaredDelta = squaredDistance(x1, y1, x22, y22);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x22;
    y1 = y22;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    const end = ends[i7];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    const ends = endss[i7];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing2, x4, y5, closestPoint, minSquaredDistance, tmpPoint2) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i7, squaredDistance4;
  if (maxDelta === 0) {
    squaredDistance4 = squaredDistance(
      x4,
      y5,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance4 < minSquaredDistance) {
      for (i7 = 0; i7 < stride; ++i7) {
        closestPoint[i7] = flatCoordinates[offset + i7];
      }
      closestPoint.length = stride;
      return squaredDistance4;
    }
    return minSquaredDistance;
  }
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  let index13 = offset + stride;
  while (index13 < end) {
    assignClosest(
      flatCoordinates,
      index13 - stride,
      index13,
      stride,
      x4,
      y5,
      tmpPoint2
    );
    squaredDistance4 = squaredDistance(x4, y5, tmpPoint2[0], tmpPoint2[1]);
    if (squaredDistance4 < minSquaredDistance) {
      minSquaredDistance = squaredDistance4;
      for (i7 = 0; i7 < stride; ++i7) {
        closestPoint[i7] = tmpPoint2[i7];
      }
      closestPoint.length = stride;
      index13 += stride;
    } else {
      index13 += stride * Math.max(
        (Math.sqrt(squaredDistance4) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing2) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x4,
      y5,
      tmpPoint2
    );
    squaredDistance4 = squaredDistance(x4, y5, tmpPoint2[0], tmpPoint2[1]);
    if (squaredDistance4 < minSquaredDistance) {
      minSquaredDistance = squaredDistance4;
      for (i7 = 0; i7 < stride; ++i7) {
        closestPoint[i7] = tmpPoint2[i7];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing2, x4, y5, closestPoint, minSquaredDistance, tmpPoint2) {
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    const end = ends[i7];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing2,
      x4,
      y5,
      closestPoint,
      minSquaredDistance,
      tmpPoint2
    );
    offset = end;
  }
  return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing2, x4, y5, closestPoint, minSquaredDistance, tmpPoint2) {
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    const ends = endss[i7];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates,
      offset,
      ends,
      stride,
      maxDelta,
      isRing2,
      x4,
      y5,
      closestPoint,
      minSquaredDistance,
      tmpPoint2
    );
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}
var init_closest = __esm({
  "node_modules/ol/geom/flat/closest.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i7 = 0;
  for (let j6 = offset; j6 < end; j6 += stride) {
    coordinates2[i7++] = flatCoordinates.slice(j6, j6 + stride);
  }
  coordinates2.length = i7;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i7 = 0;
  for (let j6 = 0, jj = ends.length; j6 < jj; ++j6) {
    const end = ends[j6];
    coordinatess[i7++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i7]
    );
    offset = end;
  }
  coordinatess.length = i7;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i7 = 0;
  for (let j6 = 0, jj = endss.length; j6 < jj; ++j6) {
    const ends = endss[j6];
    coordinatesss[i7++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      coordinatesss[i7]
    );
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i7;
  return coordinatesss;
}
var init_inflate = __esm({
  "node_modules/ol/geom/flat/inflate.js"() {
  }
});

// node_modules/ol/geom/LinearRing.js
var LinearRing, LinearRing_default;
var init_LinearRing = __esm({
  "node_modules/ol/geom/LinearRing.js"() {
    init_extent();
    init_SimpleGeometry();
    init_area();
    init_closest();
    init_deflate();
    init_inflate();
    init_simplify();
    LinearRing = class _LinearRing extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LinearRing} Clone.
       * @api
       * @override
       */
      clone() {
        return new _LinearRing(this.flatCoordinates.slice(), this.layout);
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x4, y5)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          true,
          x4,
          y5,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRing(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LinearRing(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "LinearRing";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return false;
      }
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LinearRing_default = LinearRing;
  }
});

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}
var init_segments = __esm({
  "node_modules/ol/geom/flat/segments.js"() {
  }
});

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset, end, stride, extent, coordinatesExtent) {
  coordinatesExtent = coordinatesExtent ?? extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2] || coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
    if (intersectsLineString(flatCoordinates, offset, ends[i7], stride, extent)) {
      return true;
    }
    offset = ends[i7];
  }
  return false;
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i7 = 1, ii = ends.length; i7 < ii; ++i7) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i7 - 1],
      ends[i7],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i7 - 1],
        ends[i7],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
    const ends = endss[i7];
    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}
var init_intersectsextent = __esm({
  "node_modules/ol/geom/flat/intersectsextent.js"() {
    init_extent();
    init_contains();
    init_segments();
  }
});

// node_modules/ol/geom/flat/length.js
function lineStringLength(flatCoordinates, offset, end, stride) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  let length = 0;
  for (let i7 = offset + stride; i7 < end; i7 += stride) {
    const x22 = flatCoordinates[i7];
    const y22 = flatCoordinates[i7 + 1];
    length += Math.sqrt((x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1));
    x1 = x22;
    y1 = y22;
  }
  return length;
}
var init_length = __esm({
  "node_modules/ol/geom/flat/length.js"() {
  }
});

// node_modules/ol/geom/LineString.js
var LineString, LineString_default;
var init_LineString = __esm({
  "node_modules/ol/geom/LineString.js"() {
    init_array();
    init_extent();
    init_SimpleGeometry();
    init_closest();
    init_deflate();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    init_length();
    init_segments();
    init_simplify();
    LineString = class _LineString extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.flatMidpoint_ = null;
        this.flatMidpointRevision_ = -1;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed coordinate to the coordinates of the linestring.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @api
       */
      appendCoordinate(coordinate) {
        extend2(this.flatCoordinates, coordinate);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LineString} Clone.
       * @api
       * @override
       */
      clone() {
        const lineString = new _LineString(
          this.flatCoordinates.slice(),
          this.layout
        );
        lineString.applyProperties(this);
        return lineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x4, y5)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          false,
          x4,
          y5,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
       *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */
      forEachSegment(callback) {
        return forEach(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          callback
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m8, extrapolate) {
        if (this.layout != "XYM" && this.layout != "XYZM") {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        return lineStringCoordinateAtM(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          m8,
          extrapolate
        );
      }
      /**
       * Return the coordinates of the linestring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
       * @api
       */
      getCoordinateAt(fraction, dest) {
        return interpolatePoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          fraction,
          dest,
          this.stride
        );
      }
      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */
      getLength() {
        return lineStringLength(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
          this.flatMidpoint_ = this.getCoordinateAt(
            0.5,
            this.flatMidpoint_ ?? void 0
          );
          this.flatMidpointRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatMidpoint_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LineString} Simplified LineString.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LineString(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "LineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLineString(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent,
          this.getExtent()
        );
      }
      /**
       * Set the coordinates of the linestring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LineString_default = LineString;
  }
});

// node_modules/ol/geom/MultiLineString.js
var MultiLineString, MultiLineString_default;
var init_MultiLineString = __esm({
  "node_modules/ol/geom/MultiLineString.js"() {
    init_array();
    init_extent();
    init_LineString();
    init_SimpleGeometry();
    init_closest();
    init_deflate();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    init_length();
    init_simplify();
    MultiLineString = class _MultiLineString extends SimpleGeometry_default {
      /**
       * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
       *     Coordinates or LineString geometries. (For internal use, flat coordinates in
       *     combination with `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Flat coordinate ends for internal use.
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates2[0])) {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        } else if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          const lineStrings = (
            /** @type {Array<LineString>} */
            coordinates2
          );
          const flatCoordinates = [];
          const ends2 = [];
          for (let i7 = 0, ii = lineStrings.length; i7 < ii; ++i7) {
            const lineString = lineStrings[i7];
            extend2(flatCoordinates, lineString.getFlatCoordinates());
            ends2.push(flatCoordinates.length);
          }
          const layout2 = lineStrings.length === 0 ? this.getLayout() : lineStrings[0].getLayout();
          this.setFlatCoordinates(layout2, flatCoordinates);
          this.ends_ = ends2;
        }
      }
      /**
       * Append the passed linestring to the multilinestring.
       * @param {LineString} lineString LineString.
       * @api
       */
      appendLineString(lineString) {
        extend2(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiLineString} Clone.
       * @api
       * @override
       */
      clone() {
        const multiLineString = new _MultiLineString(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        multiLineString.applyProperties(this);
        return multiLineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x4, y5)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          false,
          x4,
          y5,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @param {boolean} [interpolate] Interpolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m8, extrapolate, interpolate) {
        if (this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0) {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        interpolate = interpolate !== void 0 ? interpolate : false;
        return lineStringsCoordinateAtM(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          m8,
          extrapolate,
          interpolate
        );
      }
      /**
       * Return the coordinates of the multilinestring.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinatesArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {LineString} LineString.
       * @api
       */
      getLineString(index13) {
        if (index13 < 0 || this.ends_.length <= index13) {
          return null;
        }
        return new LineString_default(
          this.flatCoordinates.slice(
            index13 === 0 ? 0 : this.ends_[index13 - 1],
            this.ends_[index13]
          ),
          this.layout
        );
      }
      /**
       * Return the linestrings of this multilinestring.
       * @return {Array<LineString>} LineStrings.
       * @api
       */
      getLineStrings() {
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const layout = this.layout;
        const lineStrings = [];
        let offset = 0;
        for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
          const end = ends[i7];
          const lineString = new LineString_default(
            flatCoordinates.slice(offset, end),
            layout
          );
          lineStrings.push(lineString);
          offset = end;
        }
        return lineStrings;
      }
      /**
       * Return the sum of all line string lengths
       * @return {number} Length (on projected plane).
       * @api
       */
      getLength() {
        const ends = this.ends_;
        let start2 = 0;
        let length = 0;
        for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
          length += lineStringLength(
            this.flatCoordinates,
            start2,
            ends[i7],
            this.stride
          );
          start2 = ends[i7];
        }
        return length;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        const midpoints = [];
        const flatCoordinates = this.flatCoordinates;
        let offset = 0;
        const ends = this.ends_;
        const stride = this.stride;
        for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
          const end = ends[i7];
          const midpoint = interpolatePoint(
            flatCoordinates,
            offset,
            end,
            stride,
            0.5
          );
          extend2(midpoints, midpoint);
          offset = end;
        }
        return midpoints;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiLineString} Simplified MultiLineString.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = douglasPeuckerArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _MultiLineString(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "MultiLineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLineStringArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    MultiLineString_default = MultiLineString;
  }
});

// node_modules/ol/geom/Point.js
var Point, Point_default;
var init_Point = __esm({
  "node_modules/ol/geom/Point.js"() {
    init_extent();
    init_math();
    init_SimpleGeometry();
    init_deflate();
    Point = class _Point extends SimpleGeometry_default {
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.setCoordinates(coordinates2, layout);
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Point} Clone.
       * @api
       * @override
       */
      clone() {
        const point = new _Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const squaredDistance4 = squaredDistance(
          x4,
          y5,
          flatCoordinates[0],
          flatCoordinates[1]
        );
        if (squaredDistance4 < minSquaredDistance) {
          const stride = this.stride;
          for (let i7 = 0; i7 < stride; ++i7) {
            closestPoint[i7] = flatCoordinates[i7];
          }
          closestPoint.length = stride;
          return squaredDistance4;
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return this.flatCoordinates.slice();
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "Point";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      }
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinate(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    Point_default = Point;
  }
});

// node_modules/ol/geom/MultiPoint.js
var MultiPoint, MultiPoint_default;
var init_MultiPoint = __esm({
  "node_modules/ol/geom/MultiPoint.js"() {
    init_array();
    init_extent();
    init_math();
    init_Point();
    init_SimpleGeometry();
    init_deflate();
    init_inflate();
    MultiPoint = class _MultiPoint extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        if (layout && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed point to this multipoint.
       * @param {Point} point Point.
       * @api
       */
      appendPoint(point) {
        extend2(this.flatCoordinates, point.getFlatCoordinates());
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPoint} Clone.
       * @api
       * @override
       */
      clone() {
        const multiPoint = new _MultiPoint(
          this.flatCoordinates.slice(),
          this.layout
        );
        multiPoint.applyProperties(this);
        return multiPoint;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x4, y5)) {
          return minSquaredDistance;
        }
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i7 = 0, ii = flatCoordinates.length; i7 < ii; i7 += stride) {
          const squaredDistance4 = squaredDistance(
            x4,
            y5,
            flatCoordinates[i7],
            flatCoordinates[i7 + 1]
          );
          if (squaredDistance4 < minSquaredDistance) {
            minSquaredDistance = squaredDistance4;
            for (let j6 = 0; j6 < stride; ++j6) {
              closestPoint[j6] = flatCoordinates[i7 + j6];
            }
            closestPoint.length = stride;
          }
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinates of the multipoint.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {Point} Point.
       * @api
       */
      getPoint(index13) {
        const n6 = this.flatCoordinates.length / this.stride;
        if (index13 < 0 || n6 <= index13) {
          return null;
        }
        return new Point_default(
          this.flatCoordinates.slice(
            index13 * this.stride,
            (index13 + 1) * this.stride
          ),
          this.layout
        );
      }
      /**
       * Return the points of this multipoint.
       * @return {Array<Point>} Points.
       * @api
       */
      getPoints() {
        const flatCoordinates = this.flatCoordinates;
        const layout = this.layout;
        const stride = this.stride;
        const points = [];
        for (let i7 = 0, ii = flatCoordinates.length; i7 < ii; i7 += stride) {
          const point = new Point_default(flatCoordinates.slice(i7, i7 + stride), layout);
          points.push(point);
        }
        return points;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "MultiPoint";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i7 = 0, ii = flatCoordinates.length; i7 < ii; i7 += stride) {
          const x4 = flatCoordinates[i7];
          const y5 = flatCoordinates[i7 + 1];
          if (containsXY(extent, x4, y5)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Set the coordinates of the multipoint.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    MultiPoint_default = MultiPoint;
  }
});

// node_modules/ol/geom/Polygon.js
function fromExtent(extent) {
  if (isEmpty(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}
var Polygon, Polygon_default;
var init_Polygon = __esm({
  "node_modules/ol/geom/Polygon.js"() {
    init_array();
    init_extent();
    init_LinearRing();
    init_Point();
    init_SimpleGeometry();
    init_area();
    init_closest();
    init_contains();
    init_deflate();
    init_inflate();
    init_interiorpoint();
    init_intersectsextent();
    init_orient();
    init_simplify();
    Polygon = class _Polygon extends SimpleGeometry_default {
      /**
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
       *     Array of linear rings that define the polygon. The first linear ring of the
       *     array defines the outer-boundary or surface of the polygon. Each subsequent
       *     linear ring defines a hole in the surface of the polygon. A linear ring is
       *     an array of vertices' coordinates where the first coordinate and the last are
       *     equivalent. (For internal use, flat coordinates in combination with
       *     `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.flatInteriorPointRevision_ = -1;
        this.flatInteriorPoint_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed linear ring to this polygon.
       * @param {LinearRing} linearRing Linear ring.
       * @api
       */
      appendLinearRing(linearRing2) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
        } else {
          extend2(this.flatCoordinates, linearRing2.getFlatCoordinates());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       * @override
       */
      clone() {
        const polygon = new _Polygon(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        polygon.applyProperties(this);
        return polygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x4, y5)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          true,
          x4,
          y5,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x4, y5) {
        return linearRingsContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          x4,
          y5
        );
      }
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRings(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       * @override
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * @return {Array<number>} Interior point.
       */
      getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoint_ = getInteriorPointOfArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.ends_,
            this.stride,
            flatCenter,
            0
          );
          this.flatInteriorPointRevision_ = this.getRevision();
        }
        return (
          /** @type {import("../coordinate.js").Coordinate} */
          this.flatInteriorPoint_
        );
      }
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoint() {
        return new Point_default(this.getFlatInteriorPoint(), "XYM");
      }
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      getLinearRingCount() {
        return this.ends_.length;
      }
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing|null} Linear ring.
       * @api
       */
      getLinearRing(index13) {
        if (index13 < 0 || this.ends_.length <= index13) {
          return null;
        }
        return new LinearRing_default(
          this.flatCoordinates.slice(
            index13 === 0 ? 0 : this.ends_[index13 - 1],
            this.ends_[index13]
          ),
          this.layout
        );
      }
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */
      getLinearRings() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const linearRings2 = [];
        let offset = 0;
        for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
          const end = ends[i7];
          const linearRing2 = new LinearRing_default(
            flatCoordinates.slice(offset, end),
            layout
          );
          linearRings2.push(linearRing2);
          offset = end;
        }
        return linearRings2;
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRings(
              this.orientedFlatCoordinates_,
              0,
              this.ends_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = quantizeArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "Polygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLinearRingArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    Polygon_default = Polygon;
  }
});

// node_modules/ol/geom/MultiPolygon.js
var MultiPolygon, MultiPolygon_default;
var init_MultiPolygon = __esm({
  "node_modules/ol/geom/MultiPolygon.js"() {
    init_array();
    init_extent();
    init_MultiPoint();
    init_Polygon();
    init_SimpleGeometry();
    init_area();
    init_center();
    init_closest();
    init_contains();
    init_deflate();
    init_inflate();
    init_interiorpoint();
    init_intersectsextent();
    init_orient();
    init_simplify();
    MultiPolygon = class _MultiPolygon extends SimpleGeometry_default {
      /**
       * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
       */
      constructor(coordinates2, layout, endss) {
        super();
        this.endss_ = [];
        this.flatInteriorPointsRevision_ = -1;
        this.flatInteriorPoints_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (!endss && !Array.isArray(coordinates2[0])) {
          const polygons = (
            /** @type {Array<Polygon>} */
            coordinates2
          );
          const flatCoordinates = [];
          const thisEndss = [];
          for (let i7 = 0, ii = polygons.length; i7 < ii; ++i7) {
            const polygon = polygons[i7];
            const offset = flatCoordinates.length;
            const ends = polygon.getEnds();
            for (let j6 = 0, jj = ends.length; j6 < jj; ++j6) {
              ends[j6] += offset;
            }
            extend2(flatCoordinates, polygon.getFlatCoordinates());
            thisEndss.push(ends);
          }
          layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();
          coordinates2 = flatCoordinates;
          endss = thisEndss;
        }
        if (layout !== void 0 && endss) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.endss_ = endss;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed polygon to this multipolygon.
       * @param {Polygon} polygon Polygon.
       * @api
       */
      appendPolygon(polygon) {
        let ends;
        if (!this.flatCoordinates) {
          this.flatCoordinates = polygon.getFlatCoordinates().slice();
          ends = polygon.getEnds().slice();
          this.endss_.push();
        } else {
          const offset = this.flatCoordinates.length;
          extend2(this.flatCoordinates, polygon.getFlatCoordinates());
          ends = polygon.getEnds().slice();
          for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
            ends[i7] += offset;
          }
        }
        this.endss_.push(ends);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPolygon} Clone.
       * @api
       * @override
       */
      clone() {
        const len = this.endss_.length;
        const newEndss = new Array(len);
        for (let i7 = 0; i7 < len; ++i7) {
          newEndss[i7] = this.endss_[i7].slice();
        }
        const multiPolygon = new _MultiPolygon(
          this.flatCoordinates.slice(),
          this.layout,
          newEndss
        );
        multiPolygon.applyProperties(this);
        return multiPolygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x4, y5, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x4, y5)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            multiArrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.endss_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestMultiArrayPoint(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          this.maxDelta_,
          true,
          x4,
          y5,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x4, y5) {
        return linearRingssContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          x4,
          y5
        );
      }
      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRingss2(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
       * @api
       * @override
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRingsArray(
            flatCoordinates,
            0,
            this.endss_,
            this.stride,
            right
          );
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateMultiCoordinatesArray(
          flatCoordinates,
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * @return {Array<Array<number>>} Endss.
       */
      getEndss() {
        return this.endss_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
          const flatCenters = linearRingss(
            this.flatCoordinates,
            0,
            this.endss_,
            this.stride
          );
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.endss_,
            this.stride,
            flatCenters
          );
          this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatInteriorPoints_
        );
      }
      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
       * @return {MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoints() {
        return new MultiPoint_default(this.getFlatInteriorPoints().slice(), "XYM");
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRingsArray(
              this.orientedFlatCoordinates_,
              0,
              this.endss_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiPolygon} Simplified MultiPolygon.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEndss = [];
        simplifiedFlatCoordinates.length = quantizeMultiArray(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEndss
        );
        return new _MultiPolygon(simplifiedFlatCoordinates, "XY", simplifiedEndss);
      }
      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {Polygon} Polygon.
       * @api
       */
      getPolygon(index13) {
        if (index13 < 0 || this.endss_.length <= index13) {
          return null;
        }
        let offset;
        if (index13 === 0) {
          offset = 0;
        } else {
          const prevEnds = this.endss_[index13 - 1];
          offset = prevEnds[prevEnds.length - 1];
        }
        const ends = this.endss_[index13].slice();
        const end = ends[ends.length - 1];
        if (offset !== 0) {
          for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
            ends[i7] -= offset;
          }
        }
        return new Polygon_default(
          this.flatCoordinates.slice(offset, end),
          this.layout,
          ends
        );
      }
      /**
       * Return the polygons of this multipolygon.
       * @return {Array<Polygon>} Polygons.
       * @api
       */
      getPolygons() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const endss = this.endss_;
        const polygons = [];
        let offset = 0;
        for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
          const ends = endss[i7].slice();
          const end = ends[ends.length - 1];
          if (offset !== 0) {
            for (let j6 = 0, jj = ends.length; j6 < jj; ++j6) {
              ends[j6] -= offset;
            }
          }
          const polygon = new Polygon_default(
            flatCoordinates.slice(offset, end),
            layout,
            ends
          );
          polygons.push(polygon);
          offset = end;
        }
        return polygons;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "MultiPolygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLinearRingMultiArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 3);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const endss = deflateMultiCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.endss_
        );
        if (endss.length === 0) {
          this.flatCoordinates.length = 0;
        } else {
          const lastEnds = endss[endss.length - 1];
          this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
      }
    };
    MultiPolygon_default = MultiPolygon;
  }
});

// node_modules/ol/geom.js
var init_geom = __esm({
  "node_modules/ol/geom.js"() {
    init_GeometryCollection();
    init_LineString();
    init_MultiLineString();
    init_MultiPoint();
    init_MultiPolygon();
    init_Point();
    init_Polygon();
  }
});

// node_modules/ol/render/Feature.js
var tmpTransform2, RenderFeature, Feature_default2;
var init_Feature2 = __esm({
  "node_modules/ol/render/Feature.js"() {
    init_array();
    init_extent();
    init_functions();
    init_center();
    init_interiorpoint();
    init_interpolate();
    init_orient();
    init_simplify();
    init_transform2();
    init_proj();
    init_transform();
    tmpTransform2 = create();
    RenderFeature = class _RenderFeature {
      /**
       * @param {Type} type Geometry type.
       * @param {Array<number>} flatCoordinates Flat coordinates. These always need
       *     to be right-handed for polygons.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Object<string, *>} properties Properties.
       * @param {number|string|undefined} id Feature id.
       */
      constructor(type, flatCoordinates, ends, stride, properties, id) {
        this.styleFunction;
        this.extent_;
        this.id_ = id;
        this.type_ = type;
        this.flatCoordinates_ = flatCoordinates;
        this.flatInteriorPoints_ = null;
        this.flatMidpoints_ = null;
        this.ends_ = ends || null;
        this.properties_ = properties;
        this.squaredTolerance_;
        this.stride_ = stride;
        this.simplifiedGeometry_;
      }
      /**
       * Get a feature property by its key.
       * @param {string} key Key
       * @return {*} Value for the requested key.
       * @api
       */
      get(key) {
        return this.properties_[key];
      }
      /**
       * Get the extent of this feature's geometry.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        if (!this.extent_) {
          this.extent_ = this.type_ === "Point" ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2
          );
        }
        return this.extent_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoints_ = getInteriorPointOfArray(
            this.flatCoordinates_,
            0,
            this.ends_,
            2,
            flatCenter,
            0
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
          const ends = inflateEnds(this.flatCoordinates_, this.ends_);
          const flatCenters = linearRingss(this.flatCoordinates_, 0, ends, 2);
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.flatCoordinates_,
            0,
            ends,
            2,
            flatCenters
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = interpolatePoint(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            0.5
          );
        }
        return this.flatMidpoints_;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = [];
          const flatCoordinates = this.flatCoordinates_;
          let offset = 0;
          const ends = (
            /** @type {Array<number>} */
            this.ends_
          );
          for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
            const end = ends[i7];
            const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);
            extend2(this.flatMidpoints_, midpoint);
            offset = end;
          }
        }
        return this.flatMidpoints_;
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is set when reading data from a remote source.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
      }
      /**
       * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
       * determining the geometry type in style function (see {@link #getType}).
       * @return {RenderFeature} Feature.
       * @api
       */
      getGeometry() {
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {RenderFeature} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return this;
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {RenderFeature} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform3) {
        return this;
      }
      /**
       * Get the feature properties.
       * @return {Object<string, *>} Feature properties.
       * @api
       */
      getProperties() {
        return this.properties_;
      }
      /**
       * Get an object of all property names and values.  This has the same behavior as getProperties,
       * but is here to conform with the {@link module:ol/Feature~Feature} interface.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.properties_;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride_;
      }
      /**
       * @return {import('../style/Style.js').StyleFunction|undefined} Style
       */
      getStyleFunction() {
        return this.styleFunction;
      }
      /**
       * Get the type of this feature's geometry.
       * @return {Type} Geometry type.
       * @api
       */
      getType() {
        return this.type_;
      }
      /**
       * Transform geometry coordinates from tile pixel space to projected.
       *
       * @param {import("../proj.js").ProjectionLike} projection The data projection
       */
      transform(projection) {
        projection = get4(projection);
        const pixelExtent = projection.getExtent();
        const projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
          const scale3 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform2,
            projectedExtent[0],
            projectedExtent[3],
            scale3,
            -scale3,
            0,
            0,
            0
          );
          transform2D(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            tmpTransform2,
            this.flatCoordinates_
          );
        }
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       */
      applyTransform(transformFn) {
        transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
      }
      /**
       * @return {RenderFeature} A cloned render feature.
       */
      clone() {
        return new _RenderFeature(
          this.type_,
          this.flatCoordinates_.slice(),
          this.ends_?.slice(),
          this.stride_,
          Object.assign({}, this.properties_),
          this.id_
        );
      }
      /**
       * @return {Array<number>|null} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Add transform and resolution based geometry simplification to this instance.
       * @return {RenderFeature} This render feature.
       */
      enableSimplifyTransformed() {
        this.simplifyTransformed = memoizeOne((squaredTolerance, transform3) => {
          if (squaredTolerance === this.squaredTolerance_) {
            return this.simplifiedGeometry_;
          }
          this.simplifiedGeometry_ = this.clone();
          if (transform3) {
            this.simplifiedGeometry_.applyTransform(transform3);
          }
          const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();
          let simplifiedEnds;
          switch (this.type_) {
            case "LineString":
              simplifiedFlatCoordinates.length = douglasPeucker(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.flatCoordinates_.length,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0
              );
              simplifiedEnds = [simplifiedFlatCoordinates.length];
              break;
            case "MultiLineString":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = douglasPeuckerArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            case "Polygon":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = quantizeArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                Math.sqrt(squaredTolerance),
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            default:
          }
          if (simplifiedEnds) {
            this.simplifiedGeometry_ = new _RenderFeature(
              this.type_,
              simplifiedFlatCoordinates,
              simplifiedEnds,
              2,
              this.properties_,
              this.id_
            );
          }
          this.squaredTolerance_ = squaredTolerance;
          return this.simplifiedGeometry_;
        });
        return this;
      }
    };
    RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
    Feature_default2 = RenderFeature;
  }
});

// node_modules/ol/format/Feature.js
function transformGeometryWithOptions(geometry, write, options) {
  const featureProjection = options ? get4(options.featureProjection) : null;
  const dataProjection = options ? get4(options.dataProjection) : null;
  let transformed = geometry;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    if (write) {
      transformed = /** @type {T} */
      geometry.clone();
    }
    const fromProjection = write ? featureProjection : dataProjection;
    const toProjection = write ? dataProjection : featureProjection;
    if (fromProjection.getUnits() === "tile-pixels") {
      transformed.transform(fromProjection, toProjection);
    } else {
      transformed.applyTransform(getTransform(fromProjection, toProjection));
    }
  }
  if (write && options && /** @type {WriteOptions} */
  options.decimals !== void 0) {
    const power = Math.pow(
      10,
      /** @type {WriteOptions} */
      options.decimals
    );
    const transform3 = function(coordinates2) {
      for (let i7 = 0, ii = coordinates2.length; i7 < ii; ++i7) {
        coordinates2[i7] = Math.round(coordinates2[i7] * power) / power;
      }
      return coordinates2;
    };
    if (transformed === geometry) {
      transformed = /** @type {T} */
      geometry.clone();
    }
    transformed.applyTransform(transform3);
  }
  return transformed;
}
function orientFlatCoordinates(flatCoordinates, ends, stride) {
  if (Array.isArray(ends[0])) {
    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {
      flatCoordinates = flatCoordinates.slice();
      orientLinearRingsArray(flatCoordinates, 0, ends, stride);
    }
    return flatCoordinates;
  }
  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {
    flatCoordinates = flatCoordinates.slice();
    orientLinearRings(flatCoordinates, 0, ends, stride);
  }
  return flatCoordinates;
}
function createRenderFeature(object, options) {
  const geometry = object.geometry;
  if (!geometry) {
    return [];
  }
  if (Array.isArray(geometry)) {
    return geometry.map((geometry2) => createRenderFeature({ ...object, geometry: geometry2 })).flat();
  }
  const geometryType = geometry.type === "MultiPolygon" ? "Polygon" : geometry.type;
  if (geometryType === "GeometryCollection" || geometryType === "Circle") {
    throw new Error("Unsupported geometry type: " + geometryType);
  }
  const stride = geometry.layout.length;
  return transformGeometryWithOptions(
    new Feature_default2(
      geometryType,
      geometryType === "Polygon" ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride) : geometry.flatCoordinates,
      geometry.ends?.flat(),
      stride,
      object.properties || {},
      object.id
    ).enableSimplifyTransformed(),
    false,
    options
  );
}
function createGeometry(object, options) {
  if (!object) {
    return null;
  }
  if (Array.isArray(object)) {
    const geometries = object.map(
      (geometry) => createGeometry(geometry, options)
    );
    return new GeometryCollection_default(geometries);
  }
  const Geometry2 = GeometryConstructor[object.type];
  return transformGeometryWithOptions(
    new Geometry2(object.flatCoordinates, object.layout || "XY", object.ends),
    false,
    options
  );
}
var FeatureFormat, Feature_default3, GeometryConstructor;
var init_Feature3 = __esm({
  "node_modules/ol/format/Feature.js"() {
    init_Feature();
    init_orient();
    init_geom();
    init_proj();
    init_Feature2();
    init_util();
    FeatureFormat = class {
      constructor() {
        this.dataProjection = void 0;
        this.defaultFeatureProjection = void 0;
        this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */
        Feature_default;
        this.supportedMediaTypes = null;
      }
      /**
       * Adds the data projection to the read options.
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Options.
       * @return {ReadOptions|undefined} Options.
       * @protected
       */
      getReadOptions(source, options) {
        if (options) {
          let dataProjection = options.dataProjection ? get4(options.dataProjection) : this.readProjection(source);
          if (options.extent && dataProjection && dataProjection.getUnits() === "tile-pixels") {
            dataProjection = get4(dataProjection);
            dataProjection.setWorldExtent(options.extent);
          }
          options = {
            dataProjection,
            featureProjection: options.featureProjection
          };
        }
        return this.adaptOptions(options);
      }
      /**
       * Sets the `dataProjection` on the options, if no `dataProjection`
       * is set.
       * @param {WriteOptions|ReadOptions|undefined} options
       *     Options.
       * @protected
       * @return {WriteOptions|ReadOptions|undefined}
       *     Updated options.
       */
      adaptOptions(options) {
        return Object.assign(
          {
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection,
            featureClass: this.featureClass
          },
          options
        );
      }
      /**
       * @abstract
       * @return {Type} The format type.
       */
      getType() {
        return abstract();
      }
      /**
       * Read a single feature from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {FeatureType|Array<FeatureType>} Feature.
       */
      readFeature(source, options) {
        return abstract();
      }
      /**
       * Read all features from a source.
       *
       * @abstract
       * @param {Document|Element|ArrayBuffer|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {Array<FeatureType>} Features.
       */
      readFeatures(source, options) {
        return abstract();
      }
      /**
       * Read a single geometry from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      readGeometry(source, options) {
        return abstract();
      }
      /**
       * Read the projection from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default|undefined} Projection.
       */
      readProjection(source) {
        return abstract();
      }
      /**
       * Encode a feature in this format.
       *
       * @abstract
       * @param {Feature} feature Feature.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */
      writeFeature(feature, options) {
        return abstract();
      }
      /**
       * Encode an array of features in this format.
       *
       * @abstract
       * @param {Array<Feature>} features Features.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */
      writeFeatures(features, options) {
        return abstract();
      }
      /**
       * Write a single geometry in this format.
       *
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */
      writeGeometry(geometry, options) {
        return abstract();
      }
    };
    Feature_default3 = FeatureFormat;
    GeometryConstructor = {
      Point: Point_default,
      LineString: LineString_default,
      Polygon: Polygon_default,
      MultiPoint: MultiPoint_default,
      MultiLineString: MultiLineString_default,
      MultiPolygon: MultiPolygon_default
    };
  }
});

// node_modules/ol/format/JSONFeature.js
function getObject(source) {
  if (typeof source === "string") {
    const object = JSON.parse(source);
    return object ? (
      /** @type {Object} */
      object
    ) : null;
  }
  if (source !== null) {
    return source;
  }
  return null;
}
var JSONFeature, JSONFeature_default;
var init_JSONFeature = __esm({
  "node_modules/ol/format/JSONFeature.js"() {
    init_util();
    init_Feature3();
    JSONFeature = class extends Feature_default3 {
      constructor() {
        super();
      }
      /**
       * @return {import("./Feature.js").Type} Format.
       * @override
       */
      getType() {
        return "json";
      }
      /**
       * Read a feature.  Only works for a single feature. Use `readFeatures` to
       * read a feature collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {FeatureType|Array<FeatureType>} Feature.
       * @api
       * @override
       */
      readFeature(source, options) {
        return this.readFeatureFromObject(
          getObject(source),
          this.getReadOptions(source, options)
        );
      }
      /**
       * Read all features.  Works with both a single feature and a feature
       * collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {Array<FeatureType>} Features.
       * @api
       * @override
       */
      readFeatures(source, options) {
        return this.readFeaturesFromObject(
          getObject(source),
          this.getReadOptions(source, options)
        );
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {FeatureType|Array<FeatureType>} Feature.
       */
      readFeatureFromObject(object, options) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {Array<FeatureType>} Features.
       */
      readFeaturesFromObject(object, options) {
        return abstract();
      }
      /**
       * Read a geometry.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       * @api
       * @override
       */
      readGeometry(source, options) {
        return this.readGeometryFromObject(
          getObject(source),
          this.getReadOptions(source, options)
        );
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      readGeometryFromObject(object, options) {
        return abstract();
      }
      /**
       * Read the projection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default} Projection.
       * @api
       * @override
       */
      readProjection(source) {
        return this.readProjectionFromObject(getObject(source));
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       */
      readProjectionFromObject(object) {
        return abstract();
      }
      /**
       * Encode a feature as string.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded feature.
       * @api
       * @override
       */
      writeFeature(feature, options) {
        return JSON.stringify(this.writeFeatureObject(feature, options));
      }
      /**
       * @abstract
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */
      writeFeatureObject(feature, options) {
        return abstract();
      }
      /**
       * Encode an array of features as string.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded features.
       * @api
       * @override
       */
      writeFeatures(features, options) {
        return JSON.stringify(this.writeFeaturesObject(features, options));
      }
      /**
       * @abstract
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */
      writeFeaturesObject(features, options) {
        return abstract();
      }
      /**
       * Encode a geometry as string.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded geometry.
       * @api
       * @override
       */
      writeGeometry(geometry, options) {
        return JSON.stringify(this.writeGeometryObject(geometry, options));
      }
      /**
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */
      writeGeometryObject(geometry, options) {
        return abstract();
      }
    };
    JSONFeature_default = JSONFeature;
  }
});

// node_modules/ol/format/GeoJSON.js
function readGeometryInternal(object, options) {
  if (!object) {
    return null;
  }
  let geometry;
  switch (object["type"]) {
    case "Point": {
      geometry = readPointGeometry(
        /** @type {GeoJSONPoint} */
        object
      );
      break;
    }
    case "LineString": {
      geometry = readLineStringGeometry(
        /** @type {GeoJSONLineString} */
        object
      );
      break;
    }
    case "Polygon": {
      geometry = readPolygonGeometry(
        /** @type {GeoJSONPolygon} */
        object
      );
      break;
    }
    case "MultiPoint": {
      geometry = readMultiPointGeometry(
        /** @type {GeoJSONMultiPoint} */
        object
      );
      break;
    }
    case "MultiLineString": {
      geometry = readMultiLineStringGeometry(
        /** @type {GeoJSONMultiLineString} */
        object
      );
      break;
    }
    case "MultiPolygon": {
      geometry = readMultiPolygonGeometry(
        /** @type {GeoJSONMultiPolygon} */
        object
      );
      break;
    }
    case "GeometryCollection": {
      geometry = readGeometryCollectionGeometry(
        /** @type {GeoJSONGeometryCollection} */
        object
      );
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object["type"]);
    }
  }
  return geometry;
}
function readGeometry(object, options) {
  const geometryObject = readGeometryInternal(object, options);
  return createGeometry(geometryObject, options);
}
function readGeometryCollectionGeometry(object, options) {
  const geometries = object["geometries"].map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */
    function(geometry) {
      return readGeometryInternal(geometry, options);
    }
  );
  return geometries;
}
function readPointGeometry(object) {
  const flatCoordinates = object["coordinates"];
  return {
    type: "Point",
    flatCoordinates,
    layout: getLayoutForStride(flatCoordinates.length)
  };
}
function readLineStringGeometry(object) {
  const coordinates2 = object["coordinates"];
  const flatCoordinates = coordinates2.flat();
  return {
    type: "LineString",
    flatCoordinates,
    ends: [flatCoordinates.length],
    layout: getLayoutForStride(coordinates2[0]?.length || 2)
  };
}
function readMultiLineStringGeometry(object) {
  const coordinates2 = object["coordinates"];
  const stride = coordinates2[0]?.[0]?.length || 2;
  const flatCoordinates = [];
  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates2, stride);
  return {
    type: "MultiLineString",
    flatCoordinates,
    ends,
    layout: getLayoutForStride(stride)
  };
}
function readMultiPointGeometry(object) {
  const coordinates2 = object["coordinates"];
  return {
    type: "MultiPoint",
    flatCoordinates: coordinates2.flat(),
    layout: getLayoutForStride(coordinates2[0]?.length || 2)
  };
}
function readMultiPolygonGeometry(object) {
  const coordinates2 = object["coordinates"];
  const flatCoordinates = [];
  const stride = coordinates2[0]?.[0]?.[0].length || 2;
  const endss = deflateMultiCoordinatesArray(
    flatCoordinates,
    0,
    coordinates2,
    stride
  );
  return {
    type: "MultiPolygon",
    flatCoordinates,
    ends: endss,
    layout: getLayoutForStride(stride)
  };
}
function readPolygonGeometry(object) {
  const coordinates2 = object["coordinates"];
  const flatCoordinates = [];
  const stride = coordinates2[0]?.[0]?.length;
  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates2, stride);
  return {
    type: "Polygon",
    flatCoordinates,
    ends,
    layout: getLayoutForStride(stride)
  };
}
function writeGeometry(geometry, options) {
  geometry = transformGeometryWithOptions(geometry, true, options);
  const type = geometry.getType();
  let geoJSON;
  switch (type) {
    case "Point": {
      geoJSON = writePointGeometry(
        /** @type {import("../geom/Point.js").default} */
        geometry,
        options
      );
      break;
    }
    case "LineString": {
      geoJSON = writeLineStringGeometry(
        /** @type {import("../geom/LineString.js").default} */
        geometry,
        options
      );
      break;
    }
    case "Polygon": {
      geoJSON = writePolygonGeometry(
        /** @type {import("../geom/Polygon.js").default} */
        geometry,
        options
      );
      break;
    }
    case "MultiPoint": {
      geoJSON = writeMultiPointGeometry(
        /** @type {import("../geom/MultiPoint.js").default} */
        geometry,
        options
      );
      break;
    }
    case "MultiLineString": {
      geoJSON = writeMultiLineStringGeometry(
        /** @type {import("../geom/MultiLineString.js").default} */
        geometry,
        options
      );
      break;
    }
    case "MultiPolygon": {
      geoJSON = writeMultiPolygonGeometry(
        /** @type {import("../geom/MultiPolygon.js").default} */
        geometry,
        options
      );
      break;
    }
    case "GeometryCollection": {
      geoJSON = writeGeometryCollectionGeometry(
        /** @type {import("../geom/GeometryCollection.js").default} */
        geometry,
        options
      );
      break;
    }
    case "Circle": {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, options) {
  options = Object.assign({}, options);
  delete options.featureProjection;
  const geometries = geometry.getGeometriesArray().map(function(geometry2) {
    return writeGeometry(geometry2, options);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry(geometry, options) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry(geometry, options) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry(geometry, options) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry(geometry, options) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
var GeoJSON, GeoJSON_default;
var init_GeoJSON = __esm({
  "node_modules/ol/format/GeoJSON.js"() {
    init_Feature();
    init_SimpleGeometry();
    init_deflate();
    init_obj();
    init_proj();
    init_Feature2();
    init_Feature3();
    init_JSONFeature();
    GeoJSON = class extends JSONFeature_default {
      /**
       * @param {Options<FeatureType>} [options] Options.
       */
      constructor(options) {
        options = options ? options : {};
        super();
        this.dataProjection = get4(
          options.dataProjection ? options.dataProjection : "EPSG:4326"
        );
        if (options.featureProjection) {
          this.defaultFeatureProjection = get4(options.featureProjection);
        }
        if (options.featureClass) {
          this.featureClass = options.featureClass;
        }
        this.geometryName_ = options.geometryName;
        this.extractGeometryName_ = options.extractGeometryName;
        this.supportedMediaTypes = [
          "application/geo+json",
          "application/vnd.geo+json"
        ];
      }
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {FeatureType|Array<FeatureType>} Feature.
       * @override
       */
      readFeatureFromObject(object, options) {
        let geoJSONFeature = null;
        if (object["type"] === "Feature") {
          geoJSONFeature = /** @type {GeoJSONFeature} */
          object;
        } else {
          geoJSONFeature = {
            "type": "Feature",
            "geometry": (
              /** @type {GeoJSONGeometry} */
              object
            ),
            "properties": null
          };
        }
        const geometry = readGeometryInternal(geoJSONFeature["geometry"], options);
        if (this.featureClass === Feature_default2) {
          return (
            /** @type {FeatureType|Array<FeatureType>} */
            createRenderFeature(
              {
                geometry,
                id: geoJSONFeature["id"],
                properties: geoJSONFeature["properties"]
              },
              options
            )
          );
        }
        const feature = new Feature_default();
        if (this.geometryName_) {
          feature.setGeometryName(this.geometryName_);
        } else if (this.extractGeometryName_ && geoJSONFeature["geometry_name"]) {
          feature.setGeometryName(geoJSONFeature["geometry_name"]);
        }
        feature.setGeometry(createGeometry(geometry, options));
        if ("id" in geoJSONFeature) {
          feature.setId(geoJSONFeature["id"]);
        }
        if (geoJSONFeature["properties"]) {
          feature.setProperties(geoJSONFeature["properties"], true);
        }
        return (
          /** @type {FeatureType|Array<FeatureType>} */
          feature
        );
      }
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {Array<FeatureType>} Features.
       * @override
       */
      readFeaturesFromObject(object, options) {
        const geoJSONObject = (
          /** @type {GeoJSONObject} */
          object
        );
        let features = null;
        if (geoJSONObject["type"] === "FeatureCollection") {
          const geoJSONFeatureCollection = (
            /** @type {GeoJSONFeatureCollection} */
            object
          );
          features = [];
          const geoJSONFeatures = geoJSONFeatureCollection["features"];
          for (let i7 = 0, ii = geoJSONFeatures.length; i7 < ii; ++i7) {
            const featureObject = this.readFeatureFromObject(
              geoJSONFeatures[i7],
              options
            );
            if (!featureObject) {
              continue;
            }
            features.push(featureObject);
          }
        } else {
          features = [this.readFeatureFromObject(object, options)];
        }
        return (
          /** @type {Array<FeatureType>} */
          features.flat()
        );
      }
      /**
       * @param {GeoJSONGeometry} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       * @override
       */
      readGeometryFromObject(object, options) {
        return readGeometry(object, options);
      }
      /**
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       * @override
       */
      readProjectionFromObject(object) {
        const crs = object["crs"];
        let projection;
        if (crs) {
          if (crs["type"] == "name") {
            projection = get4(crs["properties"]["name"]);
          } else if (crs["type"] === "EPSG") {
            projection = get4("EPSG:" + crs["properties"]["code"]);
          } else {
            throw new Error("Unknown SRS type");
          }
        } else {
          projection = this.dataProjection;
        }
        return (
          /** @type {import("../proj/Projection.js").default} */
          projection
        );
      }
      /**
       * Encode a feature as a GeoJSON Feature object.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONFeature} Object.
       * @api
       * @override
       */
      writeFeatureObject(feature, options) {
        options = this.adaptOptions(options);
        const object = {
          "type": "Feature",
          geometry: null,
          properties: null
        };
        const id = feature.getId();
        if (id !== void 0) {
          object.id = id;
        }
        if (!feature.hasProperties()) {
          return object;
        }
        const properties = feature.getProperties();
        const geometry = feature.getGeometry();
        if (geometry) {
          object.geometry = writeGeometry(geometry, options);
          delete properties[feature.getGeometryName()];
        }
        if (!isEmpty2(properties)) {
          object.properties = properties;
        }
        return object;
      }
      /**
       * Encode an array of features as a GeoJSON object.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONFeatureCollection} GeoJSON Object.
       * @api
       * @override
       */
      writeFeaturesObject(features, options) {
        options = this.adaptOptions(options);
        const objects = [];
        for (let i7 = 0, ii = features.length; i7 < ii; ++i7) {
          objects.push(this.writeFeatureObject(features[i7], options));
        }
        return {
          type: "FeatureCollection",
          features: objects
        };
      }
      /**
       * Encode a geometry as a GeoJSON object.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
       * @api
       * @override
       */
      writeGeometryObject(geometry, options) {
        return writeGeometry(geometry, this.adaptOptions(options));
      }
    };
    GeoJSON_default = GeoJSON;
  }
});

// node_modules/ol/MapEvent.js
var MapEvent, MapEvent_default;
var init_MapEvent = __esm({
  "node_modules/ol/MapEvent.js"() {
    init_Event();
    MapEvent = class extends Event_default {
      /**
       * @param {string} type Event type.
       * @param {import("./Map.js").default} map Map.
       * @param {?import("./Map.js").FrameState} [frameState] Frame state.
       */
      constructor(type, map, frameState) {
        super(type);
        this.map = map;
        this.frameState = frameState !== void 0 ? frameState : null;
      }
    };
    MapEvent_default = MapEvent;
  }
});

// node_modules/ol/MapBrowserEvent.js
var MapBrowserEvent, MapBrowserEvent_default;
var init_MapBrowserEvent = __esm({
  "node_modules/ol/MapBrowserEvent.js"() {
    init_MapEvent();
    MapBrowserEvent = class extends MapEvent_default {
      /**
       * @param {string} type Event type.
       * @param {import("./Map.js").default} map Map.
       * @param {EVENT} originalEvent Original event.
       * @param {boolean} [dragging] Is the map currently being dragged?
       * @param {import("./Map.js").FrameState} [frameState] Frame state.
       * @param {Array<PointerEvent>} [activePointers] Active pointers.
       */
      constructor(type, map, originalEvent, dragging, frameState, activePointers) {
        super(type, map, frameState);
        this.originalEvent = originalEvent;
        this.pixel_ = null;
        this.coordinate_ = null;
        this.dragging = dragging !== void 0 ? dragging : false;
        this.activePointers = activePointers;
      }
      /**
       * The map pixel relative to the viewport corresponding to the original event.
       * @type {import("./pixel.js").Pixel}
       * @api
       */
      get pixel() {
        if (!this.pixel_) {
          this.pixel_ = this.map.getEventPixel(this.originalEvent);
        }
        return this.pixel_;
      }
      set pixel(pixel) {
        this.pixel_ = pixel;
      }
      /**
       * The coordinate corresponding to the original browser event.  This will be in the user
       * projection if one is set.  Otherwise it will be in the view projection.
       * @type {import("./coordinate.js").Coordinate}
       * @api
       */
      get coordinate() {
        if (!this.coordinate_) {
          this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
        }
        return this.coordinate_;
      }
      set coordinate(coordinate) {
        this.coordinate_ = coordinate;
      }
      /**
       * Prevents the default browser action.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
       * @api
       * @override
       */
      preventDefault() {
        super.preventDefault();
        if ("preventDefault" in this.originalEvent) {
          this.originalEvent.preventDefault();
        }
      }
      /**
       * Prevents further propagation of the current event.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
       * @api
       * @override
       */
      stopPropagation() {
        super.stopPropagation();
        if ("stopPropagation" in this.originalEvent) {
          this.originalEvent.stopPropagation();
        }
      }
    };
    MapBrowserEvent_default = MapBrowserEvent;
  }
});

// node_modules/ol/MapBrowserEventType.js
var MapBrowserEventType_default;
var init_MapBrowserEventType = __esm({
  "node_modules/ol/MapBrowserEventType.js"() {
    init_EventType();
    MapBrowserEventType_default = {
      /**
       * A true single click with no dragging and no double click. Note that this
       * event is delayed by 250 ms to ensure that it is not a double click.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
       * @api
       */
      SINGLECLICK: "singleclick",
      /**
       * A click with no dragging. A double click will fire two of this.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
       * @api
       */
      CLICK: EventType_default.CLICK,
      /**
       * A true double click, with no dragging.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
       * @api
       */
      DBLCLICK: EventType_default.DBLCLICK,
      /**
       * Triggered when a pointer is dragged.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
       * @api
       */
      POINTERDRAG: "pointerdrag",
      /**
       * Triggered when a pointer is moved. Note that on touch devices this is
       * triggered when the map is panned, so is not the same as mousemove.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
       * @api
       */
      POINTERMOVE: "pointermove",
      POINTERDOWN: "pointerdown",
      POINTERUP: "pointerup",
      POINTEROVER: "pointerover",
      POINTEROUT: "pointerout",
      POINTERENTER: "pointerenter",
      POINTERLEAVE: "pointerleave",
      POINTERCANCEL: "pointercancel"
    };
  }
});

// node_modules/ol/has.js
var ua, SAFARI, SAFARI_BUG_237906, WEBKIT, MAC, WORKER_OFFSCREEN_CANVAS, IMAGE_DECODE, PASSIVE_EVENT_LISTENERS;
var init_has = __esm({
  "node_modules/ol/has.js"() {
    ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
    SAFARI = ua.includes("safari") && !ua.includes("chrom");
    SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
    WEBKIT = ua.includes("webkit") && !ua.includes("edge");
    MAC = ua.includes("macintosh");
    WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
    IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
    PASSIVE_EVENT_LISTENERS = function() {
      let passive = false;
      try {
        const options = Object.defineProperty({}, "passive", {
          get: function() {
            passive = true;
          }
        });
        window.addEventListener("_", null, options);
        window.removeEventListener("_", null, options);
      } catch {
      }
      return passive;
    }();
  }
});

// node_modules/ol/events/condition.js
var always, never, noModifierKeys, shiftKeyOnly;
var init_condition = __esm({
  "node_modules/ol/events/condition.js"() {
    init_functions();
    always = TRUE;
    never = FALSE;
    noModifierKeys = function(mapBrowserEvent) {
      const originalEvent = (
        /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
        mapBrowserEvent.originalEvent
      );
      return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
    };
    shiftKeyOnly = function(mapBrowserEvent) {
      const originalEvent = mapBrowserEvent.originalEvent;
      return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
    };
  }
});

// node_modules/ol/ViewHint.js
var ViewHint_default;
var init_ViewHint = __esm({
  "node_modules/ol/ViewHint.js"() {
    ViewHint_default = {
      ANIMATING: 0,
      INTERACTING: 1
    };
  }
});

// node_modules/ol/dom.js
function createCanvasContext2D(width, height, canvasPool2, settings) {
  let canvas;
  if (canvasPool2 && canvasPool2.length) {
    canvas = /** @type {HTMLCanvasElement} */
    canvasPool2.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", settings)
  );
}
function getSharedCanvasContext2D() {
  if (!sharedCanvasContext) {
    sharedCanvasContext = createCanvasContext2D(1, 1);
  }
  return sharedCanvasContext;
}
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
var sharedCanvasContext;
var init_dom = __esm({
  "node_modules/ol/dom.js"() {
    init_has();
  }
});

// node_modules/ol/render/EventType.js
var EventType_default2;
var init_EventType2 = __esm({
  "node_modules/ol/render/EventType.js"() {
    EventType_default2 = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: "prerender",
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered before layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: "precompose",
      /**
       * Triggered after layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: "postcompose",
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: "rendercomplete"
    };
  }
});

// node_modules/ol/ImageState.js
var ImageState_default;
var init_ImageState = __esm({
  "node_modules/ol/ImageState.js"() {
    ImageState_default = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4
    };
  }
});

// node_modules/ol/color.js
function getColorParseContext() {
  if (!colorParseContext) {
    colorParseContext = createCanvasContext2D(1, 1, void 0, {
      willReadFrequently: true,
      desynchronized: true
    });
  }
  return colorParseContext;
}
function toColorComponent(s5, divider) {
  return s5.endsWith("%") ? Number(s5.substring(0, s5.length - 1)) / divider : Number(s5);
}
function throwInvalidColor(color) {
  throw new Error('failed to parse "' + color + '" as color');
}
function parseRgba(color) {
  if (color.toLowerCase().startsWith("rgb")) {
    const rgb = color.match(rgbLegacyAbsoluteRegEx) || color.match(rgbModernRegEx) || color.match(rgbLegacyPercentageRegEx);
    if (rgb) {
      const alpha = rgb[4];
      const rgbDivider = 100 / 255;
      return [
        clamp(toColorComponent(rgb[1], rgbDivider) + 0.5 | 0, 0, 255),
        clamp(toColorComponent(rgb[2], rgbDivider) + 0.5 | 0, 0, 255),
        clamp(toColorComponent(rgb[3], rgbDivider) + 0.5 | 0, 0, 255),
        alpha !== void 0 ? clamp(toColorComponent(alpha, 100), 0, 1) : 1
      ];
    }
    throwInvalidColor(color);
  }
  if (color.startsWith("#")) {
    if (hexRegEx.test(color)) {
      const hex = color.substring(1);
      const step = hex.length <= 4 ? 1 : 2;
      const colorFromHex = [0, 0, 0, 255];
      for (let i7 = 0, ii = hex.length; i7 < ii; i7 += step) {
        let colorComponent = parseInt(hex.substring(i7, i7 + step), 16);
        if (step === 1) {
          colorComponent += colorComponent << 4;
        }
        colorFromHex[i7 / step] = colorComponent;
      }
      colorFromHex[3] = colorFromHex[3] / 255;
      return colorFromHex;
    }
    throwInvalidColor(color);
  }
  const context = getColorParseContext();
  context.fillStyle = "#abcdef";
  let invalidCheckFillStyle = context.fillStyle;
  context.fillStyle = color;
  if (context.fillStyle === invalidCheckFillStyle) {
    context.fillStyle = "#fedcba";
    invalidCheckFillStyle = context.fillStyle;
    context.fillStyle = color;
    if (context.fillStyle === invalidCheckFillStyle) {
      throwInvalidColor(color);
    }
  }
  const colorString = context.fillStyle;
  if (colorString.startsWith("#") || colorString.startsWith("rgba")) {
    return parseRgba(colorString);
  }
  context.clearRect(0, 0, 1, 1);
  context.fillRect(0, 0, 1, 1);
  const colorFromImage = Array.from(context.getImageData(0, 0, 1, 1).data);
  colorFromImage[3] = toFixed(colorFromImage[3] / 255, 3);
  return colorFromImage;
}
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString2(color);
}
function withAlpha(color) {
  if (color.length === 4) {
    return color;
  }
  const output = color.slice();
  output[3] = 1;
  return output;
}
function b1(v5) {
  return v5 > 31308e-7 ? Math.pow(v5, 1 / 2.4) * 269.025 - 14.025 : v5 * 3294.6;
}
function b22(v5) {
  return v5 > 0.2068965 ? Math.pow(v5, 3) : (v5 - 4 / 29) * (108 / 841);
}
function a1(v5) {
  return v5 > 10.314724 ? Math.pow((v5 + 14.025) / 269.025, 2.4) : v5 / 3294.6;
}
function a22(v5) {
  return v5 > 88564e-7 ? Math.pow(v5, 1 / 3) : v5 / (108 / 841) + 4 / 29;
}
function rgbaToLcha(color) {
  const r5 = a1(color[0]);
  const g5 = a1(color[1]);
  const b8 = a1(color[2]);
  const y5 = a22(r5 * 0.222488403 + g5 * 0.716873169 + b8 * 0.06060791);
  const l7 = 500 * (a22(r5 * 0.452247074 + g5 * 0.399439023 + b8 * 0.148375274) - y5);
  const q5 = 200 * (y5 - a22(r5 * 0.016863605 + g5 * 0.117638439 + b8 * 0.865350722));
  const h5 = Math.atan2(q5, l7) * (180 / Math.PI);
  return [
    116 * y5 - 16,
    Math.sqrt(l7 * l7 + q5 * q5),
    h5 < 0 ? h5 + 360 : h5,
    color[3]
  ];
}
function lchaToRgba(color) {
  const l7 = (color[0] + 16) / 116;
  const c7 = color[1];
  const h5 = color[2] * Math.PI / 180;
  const y5 = b22(l7);
  const x4 = b22(l7 + c7 / 500 * Math.cos(h5));
  const z3 = b22(l7 - c7 / 200 * Math.sin(h5));
  const r5 = b1(x4 * 3.021973625 - y5 * 1.617392459 - z3 * 0.404875592);
  const g5 = b1(x4 * -0.943766287 + y5 * 1.916279586 + z3 * 0.027607165);
  const b8 = b1(x4 * 0.069407491 - y5 * 0.22898585 + z3 * 1.159737864);
  return [
    clamp(r5 + 0.5 | 0, 0, 255),
    clamp(g5 + 0.5 | 0, 0, 255),
    clamp(b8 + 0.5 | 0, 0, 255),
    color[3]
  ];
}
function fromString2(s5) {
  if (s5 === "none") {
    return NO_COLOR;
  }
  if (cache2.hasOwnProperty(s5)) {
    return cache2[s5];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i7 = 0;
    for (const key in cache2) {
      if ((i7++ & 3) === 0) {
        delete cache2[key];
        --cacheSize;
      }
    }
  }
  const color = parseRgba(s5);
  if (color.length !== 4) {
    throwInvalidColor(s5);
  }
  for (const c7 of color) {
    if (isNaN(c7)) {
      throwInvalidColor(s5);
    }
  }
  cache2[s5] = color;
  ++cacheSize;
  return color;
}
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString2(color);
}
function toString2(color) {
  let r5 = color[0];
  if (r5 != (r5 | 0)) {
    r5 = r5 + 0.5 | 0;
  }
  let g5 = color[1];
  if (g5 != (g5 | 0)) {
    g5 = g5 + 0.5 | 0;
  }
  let b8 = color[2];
  if (b8 != (b8 | 0)) {
    b8 = b8 + 0.5 | 0;
  }
  const a5 = color[3] === void 0 ? 1 : Math.round(color[3] * 1e3) / 1e3;
  return "rgba(" + r5 + "," + g5 + "," + b8 + "," + a5 + ")";
}
var NO_COLOR, colorParseContext, rgbModernRegEx, rgbLegacyAbsoluteRegEx, rgbLegacyPercentageRegEx, hexRegEx, MAX_CACHE_SIZE, cache2, cacheSize;
var init_color = __esm({
  "node_modules/ol/color.js"() {
    init_dom();
    init_math();
    NO_COLOR = [NaN, NaN, NaN, 0];
    rgbModernRegEx = /^rgba?\(\s*(\d+%?)\s+(\d+%?)\s+(\d+%?)(?:\s*\/\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
    rgbLegacyAbsoluteRegEx = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
    rgbLegacyPercentageRegEx = /^rgba?\(\s*(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
    hexRegEx = /^#([\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;
    MAX_CACHE_SIZE = 1024;
    cache2 = {};
    cacheSize = 0;
  }
});

// node_modules/ol/Image.js
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError3() {
      unlisten();
      reject(new Error("Image load error"));
    }
    function unlisten() {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError3);
    }
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError3);
    if (src) {
      image.src = src;
    }
  });
}
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE ? new Promise(
    (resolve, reject) => image.decode().then(() => resolve(image)).catch(
      (e3) => image.complete && image.width ? resolve(image) : reject(e3)
    )
  ) : load(image);
}
var init_Image = __esm({
  "node_modules/ol/Image.js"() {
    init_has();
  }
});

// node_modules/ol/style/IconImageCache.js
function getCacheKey(src, crossOrigin, color) {
  const colorString = color ? asArray(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var IconImageCache, shared;
var init_IconImageCache = __esm({
  "node_modules/ol/style/IconImageCache.js"() {
    init_ImageState();
    init_color();
    init_dom();
    IconImageCache = class {
      constructor() {
        this.cache_ = {};
        this.patternCache_ = {};
        this.cacheSize_ = 0;
        this.maxCacheSize_ = 1024;
      }
      /**
       * FIXME empty description for jsdoc
       */
      clear() {
        this.cache_ = {};
        this.patternCache_ = {};
        this.cacheSize_ = 0;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
      }
      /**
       * FIXME empty description for jsdoc
       */
      expire() {
        if (this.canExpireCache()) {
          let i7 = 0;
          for (const key in this.cache_) {
            const iconImage = this.cache_[key];
            if ((i7++ & 3) === 0 && !iconImage.hasListener()) {
              delete this.cache_[key];
              delete this.patternCache_[key];
              --this.cacheSize_;
            }
          }
        }
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */
      get(src, crossOrigin, color) {
        const key = getCacheKey(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @return {CanvasPattern} Icon image.
       */
      getPattern(src, crossOrigin, color) {
        const key = getCacheKey(src, crossOrigin, color);
        return key in this.patternCache_ ? this.patternCache_[key] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @param {import("./IconImage.js").default|null} iconImage Icon image.
       * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
       */
      set(src, crossOrigin, color, iconImage, pattern) {
        const key = getCacheKey(src, crossOrigin, color);
        const update = key in this.cache_;
        this.cache_[key] = iconImage;
        if (pattern) {
          if (iconImage.getImageState() === ImageState_default.IDLE) {
            iconImage.load();
          }
          if (iconImage.getImageState() === ImageState_default.LOADING) {
            iconImage.ready().then(() => {
              this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
                iconImage.getImage(1),
                "repeat"
              );
            });
          } else {
            this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
              iconImage.getImage(1),
              "repeat"
            );
          }
        }
        if (!update) {
          ++this.cacheSize_;
        }
      }
      /**
       * Set the cache size of the icon cache. Default is `1024`. Change this value when
       * your map uses more than 1024 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */
      setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
      }
    };
    shared = new IconImageCache();
  }
});

// node_modules/ol/style/IconImage.js
function get5(image, cacheKey, crossOrigin, imageState, color, pattern) {
  let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image && "src" in image ? image.src || void 0 : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  if (pattern && iconImage && !shared.getPattern(cacheKey, crossOrigin, color)) {
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  return iconImage;
}
var taintedTestContext, IconImage, IconImage_default;
var init_IconImage = __esm({
  "node_modules/ol/style/IconImage.js"() {
    init_Image();
    init_ImageState();
    init_color();
    init_dom();
    init_EventType();
    init_Target();
    init_IconImageCache();
    taintedTestContext = null;
    IconImage = class extends Target_default {
      /**
       * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
       * @param {string|undefined} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../ImageState.js").default|undefined} imageState Image state.
       * @param {import("../color.js").Color|string|null} color Color.
       */
      constructor(image, src, crossOrigin, imageState, color) {
        super();
        this.hitDetectionImage_ = null;
        this.image_ = image;
        this.crossOrigin_ = crossOrigin;
        this.canvas_ = {};
        this.color_ = color;
        this.imageState_ = imageState === void 0 ? ImageState_default.IDLE : imageState;
        this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
        this.src_ = src;
        this.tainted_;
        this.ready_ = null;
      }
      /**
       * @private
       */
      initializeImage_() {
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) {
          this.image_.crossOrigin = this.crossOrigin_;
        }
      }
      /**
       * @private
       * @return {boolean} The image canvas is tainted.
       */
      isTainted_() {
        if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
          if (!taintedTestContext) {
            taintedTestContext = createCanvasContext2D(1, 1, void 0, {
              willReadFrequently: true
            });
          }
          taintedTestContext.drawImage(this.image_, 0, 0);
          try {
            taintedTestContext.getImageData(0, 0, 1, 1);
            this.tainted_ = false;
          } catch {
            taintedTestContext = null;
            this.tainted_ = true;
          }
        }
        return this.tainted_ === true;
      }
      /**
       * @private
       */
      dispatchChangeEvent_() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * @private
       */
      handleImageError_() {
        this.imageState_ = ImageState_default.ERROR;
        this.dispatchChangeEvent_();
      }
      /**
       * @private
       */
      handleImageLoad_() {
        this.imageState_ = ImageState_default.LOADED;
        this.size_ = [this.image_.width, this.image_.height];
        this.dispatchChangeEvent_();
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
       */
      getImage(pixelRatio) {
        if (!this.image_) {
          this.initializeImage_();
        }
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Image or Canvas element.
       */
      getPixelRatio(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       */
      getHitDetectionImage() {
        if (!this.image_) {
          this.initializeImage_();
        }
        if (!this.hitDetectionImage_) {
          if (this.isTainted_()) {
            const width = this.size_[0];
            const height = this.size_[1];
            const context = createCanvasContext2D(width, height);
            context.fillRect(0, 0, width, height);
            this.hitDetectionImage_ = context.canvas;
          } else {
            this.hitDetectionImage_ = this.image_;
          }
        }
        return this.hitDetectionImage_;
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       */
      getSize() {
        return this.size_;
      }
      /**
       * @return {string|undefined} Image src.
       */
      getSrc() {
        return this.src_;
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
        if (this.imageState_ !== ImageState_default.IDLE) {
          return;
        }
        if (!this.image_) {
          this.initializeImage_();
        }
        this.imageState_ = ImageState_default.LOADING;
        try {
          if (this.src_ !== void 0) {
            this.image_.src = this.src_;
          }
        } catch {
          this.handleImageError_();
        }
        if (this.image_ instanceof HTMLImageElement) {
          decodeFallback(this.image_, this.src_).then((image) => {
            this.image_ = image;
            this.handleImageLoad_();
          }).catch(this.handleImageError_.bind(this));
        }
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @private
       */
      replaceColor_(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
          return;
        }
        const image = this.image_;
        const ctx = createCanvasContext2D(
          Math.ceil(image.width * pixelRatio),
          Math.ceil(image.height * pixelRatio)
        );
        const canvas = ctx.canvas;
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(image, 0, 0);
        ctx.globalCompositeOperation = "multiply";
        ctx.fillStyle = asString(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(image, 0, 0);
        this.canvas_[pixelRatio] = canvas;
      }
      /**
       * @return {Promise<void>} Promise that resolves when the image is loaded.
       */
      ready() {
        if (!this.ready_) {
          this.ready_ = new Promise((resolve) => {
            if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
              resolve();
            } else {
              const onChange = () => {
                if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
                  this.removeEventListener(EventType_default.CHANGE, onChange);
                  resolve();
                }
              };
              this.addEventListener(EventType_default.CHANGE, onChange);
            }
          });
        }
        return this.ready_;
      }
    };
    IconImage_default = IconImage;
  }
});

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (!color) {
    return null;
  }
  if (Array.isArray(color)) {
    return toString2(color);
  }
  if (typeof color === "object" && "src" in color) {
    return asCanvasPattern(color);
  }
  return color;
}
function asCanvasPattern(pattern) {
  if (!pattern.offset || !pattern.size) {
    return shared.getPattern(pattern.src, "anonymous", pattern.color);
  }
  const cacheKey = pattern.src + ":" + pattern.offset;
  const canvasPattern = shared.getPattern(
    cacheKey,
    void 0,
    pattern.color
  );
  if (canvasPattern) {
    return canvasPattern;
  }
  const iconImage = shared.get(pattern.src, "anonymous", null);
  if (iconImage.getImageState() !== ImageState_default.LOADED) {
    return null;
  }
  const patternCanvasContext = createCanvasContext2D(
    pattern.size[0],
    pattern.size[1]
  );
  patternCanvasContext.drawImage(
    iconImage.getImage(1),
    pattern.offset[0],
    pattern.offset[1],
    pattern.size[0],
    pattern.size[1],
    0,
    0,
    pattern.size[0],
    pattern.size[1]
  );
  get5(
    patternCanvasContext.canvas,
    cacheKey,
    void 0,
    ImageState_default.LOADED,
    pattern.color,
    true
  );
  return shared.getPattern(cacheKey, void 0, pattern.color);
}
var init_colorlike = __esm({
  "node_modules/ol/colorlike.js"() {
    init_ImageState();
    init_color();
    init_dom();
    init_IconImage();
    init_IconImageCache();
  }
});

// node_modules/ol/render/VectorContext.js
var VectorContext, VectorContext_default;
var init_VectorContext = __esm({
  "node_modules/ol/render/VectorContext.js"() {
    VectorContext = class {
      /**
       * Render a geometry with a custom renderer.
       *
       * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       * @param {Function} hitDetectionRenderer Renderer.
       * @param {number} [index] Render order index.
       */
      drawCustom(geometry, feature, renderer, hitDetectionRenderer, index13) {
      }
      /**
       * Render a geometry.
       *
       * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
       */
      drawGeometry(geometry) {
      }
      /**
       * Set the rendering style.
       *
       * @param {import("../style/Style.js").default} style The rendering style.
       */
      setStyle(style) {
      }
      /**
       * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../Feature.js").default} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawCircle(circleGeometry, feature, index13) {
      }
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("../style/Style.js").default} style Style.
       * @param {number} [index] Render order index.
       */
      drawFeature(feature, style, index13) {
      }
      /**
       * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
       * @param {import("../Feature.js").default} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawGeometryCollection(geometryCollectionGeometry, feature, index13) {
      }
      /**
       * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawLineString(lineStringGeometry, feature, index13) {
      }
      /**
       * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawMultiLineString(multiLineStringGeometry, feature, index13) {
      }
      /**
       * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawMultiPoint(multiPointGeometry, feature, index13) {
      }
      /**
       * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawMultiPolygon(multiPolygonGeometry, feature, index13) {
      }
      /**
       * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawPoint(pointGeometry, feature, index13) {
      }
      /**
       * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawPolygon(polygonGeometry, feature, index13) {
      }
      /**
       * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawText(geometry, feature, index13) {
      }
      /**
       * @param {import("../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
      }
      /**
       * @param {import("../style/Image.js").default} imageStyle Image style.
       * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
       */
      setImageStyle(imageStyle, declutterImageWithText) {
      }
      /**
       * @param {import("../style/Text.js").default} textStyle Text style.
       * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
       */
      setTextStyle(textStyle, declutterImageWithText) {
      }
    };
    VectorContext_default = VectorContext;
  }
});

// node_modules/ol/css.js
var fontRegEx, fontRegExMatchIndex, fontWeights, getFontParameters;
var init_css = __esm({
  "node_modules/ol/css.js"() {
    fontRegEx = new RegExp(
      [
        "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
        "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
        "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
        "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
        `?\\s*([-,\\"\\'\\sa-z0-9]+?)\\s*$`
      ].join(""),
      "i"
    );
    fontRegExMatchIndex = [
      "style",
      "variant",
      "weight",
      "size",
      "lineHeight",
      "family"
    ];
    fontWeights = {
      normal: 400,
      bold: 700
    };
    getFontParameters = function(fontSpec) {
      const match2 = fontSpec.match(fontRegEx);
      if (!match2) {
        return null;
      }
      const style = (
        /** @type {FontParameters} */
        {
          lineHeight: "normal",
          size: "1.2em",
          style: "normal",
          weight: "400",
          variant: "normal"
        }
      );
      for (let i7 = 0, ii = fontRegExMatchIndex.length; i7 < ii; ++i7) {
        const value = match2[i7 + 1];
        if (value !== void 0) {
          style[fontRegExMatchIndex[i7]] = typeof value === "string" ? value.trim() : value;
        }
      }
      if (isNaN(Number(style.weight)) && style.weight in fontWeights) {
        style.weight = fontWeights[style.weight];
      }
      style.families = style.family.split(/,\s?/).map((f8) => f8.trim().replace(/^['"]|['"]$/g, ""));
      return style;
    };
  }
});

// node_modules/ol/render/canvas.js
function getFontKey(style, weight, family) {
  return `${style} ${weight} 16px "${family}"`;
}
function measureText(font, text2) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text2);
}
function measureTextWidth(font, text2) {
  return measureText(font, text2).width;
}
function measureAndCacheTextWidth(font, text2, cache3) {
  if (text2 in cache3) {
    return cache3[text2];
  }
  const width = text2.split("\n").reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
  cache3[text2] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  const widths = [];
  const heights = [];
  const lineWidths = [];
  let width = 0;
  let lineWidth = 0;
  let height = 0;
  let lineHeight = 0;
  for (let i7 = 0, ii = chunks.length; i7 <= ii; i7 += 2) {
    const text2 = chunks[i7];
    if (text2 === "\n" || i7 === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      lineHeight = 0;
      continue;
    }
    const font = chunks[i7 + 1] || baseStyle.font;
    const currentWidth = measureTextWidth(font, text2);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    const currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function drawImageOrLabel(context, transform3, opacity, labelOrImage, originX, originY, w5, h5, x4, y5, scale3) {
  context.save();
  if (opacity !== 1) {
    if (context.globalAlpha === void 0) {
      context.globalAlpha = (context2) => context2.globalAlpha *= opacity;
    } else {
      context.globalAlpha *= opacity;
    }
  }
  if (transform3) {
    context.transform.apply(context, transform3);
  }
  if (
    /** @type {*} */
    labelOrImage.contextInstructions
  ) {
    context.translate(x4, y5);
    context.scale(scale3[0], scale3[1]);
    executeLabelInstructions(
      /** @type {Label} */
      labelOrImage,
      context
    );
  } else if (scale3[0] < 0 || scale3[1] < 0) {
    context.translate(x4, y5);
    context.scale(scale3[0], scale3[1]);
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w5,
      h5,
      0,
      0,
      w5,
      h5
    );
  } else {
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w5,
      h5,
      x4,
      y5,
      w5 * scale3[0],
      h5 * scale3[1]
    );
  }
  context.restore();
}
function executeLabelInstructions(label, context) {
  const contextInstructions = label.contextInstructions;
  for (let i7 = 0, ii = contextInstructions.length; i7 < ii; i7 += 2) {
    if (Array.isArray(contextInstructions[i7 + 1])) {
      context[contextInstructions[i7]].apply(
        context,
        contextInstructions[i7 + 1]
      );
    } else {
      context[contextInstructions[i7]] = contextInstructions[i7 + 1];
    }
  }
}
var defaultFont, defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, defaultPadding, defaultLineWidth, checkedFonts, measureContext, measureFont, textHeights, genericFontFamilies, registerFont, measureTextHeight;
var init_canvas = __esm({
  "node_modules/ol/render/canvas.js"() {
    init_Object();
    init_css();
    init_dom();
    init_has();
    init_obj();
    defaultFont = "10px sans-serif";
    defaultFillStyle = "#000";
    defaultLineCap = "round";
    defaultLineDash = [];
    defaultLineDashOffset = 0;
    defaultLineJoin = "round";
    defaultMiterLimit = 10;
    defaultStrokeStyle = "#000";
    defaultTextAlign = "center";
    defaultTextBaseline = "middle";
    defaultPadding = [0, 0, 0, 0];
    defaultLineWidth = 1;
    checkedFonts = new Object_default();
    measureContext = null;
    textHeights = {};
    genericFontFamilies = /* @__PURE__ */ new Set([
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui",
      "ui-serif",
      "ui-sans-serif",
      "ui-monospace",
      "ui-rounded",
      "emoji",
      "math",
      "fangsong"
    ]);
    registerFont = /* @__PURE__ */ function() {
      const retries = 100;
      let timeout, fontFaceSet;
      async function isAvailable(fontSpec) {
        await fontFaceSet.ready;
        const fontFaces = await fontFaceSet.load(fontSpec);
        if (fontFaces.length === 0) {
          return false;
        }
        const font = getFontParameters(fontSpec);
        const checkFamily = font.families[0].toLowerCase();
        const checkWeight = font.weight;
        return fontFaces.some(
          /**
           * @param {import('../css.js').FontParameters} f Font.
           * @return {boolean} Font matches.
           */
          (f8) => {
            const family = f8.family.replace(/^['"]|['"]$/g, "").toLowerCase();
            const weight = fontWeights[f8.weight] || f8.weight;
            return family === checkFamily && f8.style === font.style && weight == checkWeight;
          }
        );
      }
      async function check() {
        await fontFaceSet.ready;
        let done = true;
        const checkedFontsProperties = checkedFonts.getProperties();
        const fonts13 = Object.keys(checkedFontsProperties).filter(
          (key) => checkedFontsProperties[key] < retries
        );
        for (let i7 = fonts13.length - 1; i7 >= 0; --i7) {
          const font = fonts13[i7];
          let currentRetries = checkedFontsProperties[font];
          if (currentRetries < retries) {
            if (await isAvailable(font)) {
              clear(textHeights);
              checkedFonts.set(font, retries);
            } else {
              currentRetries += 10;
              checkedFonts.set(font, currentRetries, true);
              if (currentRetries < retries) {
                done = false;
              }
            }
          }
        }
        timeout = void 0;
        if (!done) {
          timeout = setTimeout(check, 100);
        }
      }
      return async function(fontSpec) {
        if (!fontFaceSet) {
          fontFaceSet = WORKER_OFFSCREEN_CANVAS ? self.fonts : document.fonts;
        }
        const font = getFontParameters(fontSpec);
        if (!font) {
          return;
        }
        const families = font.families;
        let needCheck = false;
        for (const family of families) {
          if (genericFontFamilies.has(family)) {
            continue;
          }
          const key = getFontKey(font.style, font.weight, family);
          if (checkedFonts.get(key) !== void 0) {
            continue;
          }
          checkedFonts.set(key, 0, true);
          needCheck = true;
        }
        if (needCheck) {
          clearTimeout(timeout);
          timeout = setTimeout(check, 100);
        }
      };
    }();
    measureTextHeight = /* @__PURE__ */ function() {
      let measureElement;
      return function(fontSpec) {
        let height = textHeights[fontSpec];
        if (height == void 0) {
          if (WORKER_OFFSCREEN_CANVAS) {
            const font = getFontParameters(fontSpec);
            const metrics = measureText(fontSpec, "\u017Dg");
            const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
            height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
          } else {
            if (!measureElement) {
              measureElement = document.createElement("div");
              measureElement.innerHTML = "M";
              measureElement.style.minHeight = "0";
              measureElement.style.maxHeight = "none";
              measureElement.style.height = "auto";
              measureElement.style.padding = "0";
              measureElement.style.border = "none";
              measureElement.style.position = "absolute";
              measureElement.style.display = "block";
              measureElement.style.left = "-99999px";
            }
            measureElement.style.font = fontSpec;
            document.body.appendChild(measureElement);
            height = measureElement.offsetHeight;
            document.body.removeChild(measureElement);
          }
          textHeights[fontSpec] = height;
        }
        return height;
      };
    }();
  }
});

// node_modules/ol/render/canvas/Instruction.js
var Instruction, fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction, Instruction_default;
var init_Instruction = __esm({
  "node_modules/ol/render/canvas/Instruction.js"() {
    Instruction = {
      BEGIN_GEOMETRY: 0,
      BEGIN_PATH: 1,
      CIRCLE: 2,
      CLOSE_PATH: 3,
      CUSTOM: 4,
      DRAW_CHARS: 5,
      DRAW_IMAGE: 6,
      END_GEOMETRY: 7,
      FILL: 8,
      MOVE_TO_LINE_TO: 9,
      SET_FILL_STYLE: 10,
      SET_STROKE_STYLE: 11,
      STROKE: 12
    };
    fillInstruction = [Instruction.FILL];
    strokeInstruction = [Instruction.STROKE];
    beginPathInstruction = [Instruction.BEGIN_PATH];
    closePathInstruction = [Instruction.CLOSE_PATH];
    Instruction_default = Instruction;
  }
});

// node_modules/ol/render/canvas/Builder.js
var CanvasBuilder, Builder_default;
var init_Builder = __esm({
  "node_modules/ol/render/canvas/Builder.js"() {
    init_array();
    init_colorlike();
    init_Relationship();
    init_extent();
    init_inflate();
    init_VectorContext();
    init_canvas();
    init_Instruction();
    CanvasBuilder = class extends VectorContext_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super();
        this.tolerance = tolerance;
        this.maxExtent = maxExtent;
        this.pixelRatio = pixelRatio;
        this.maxLineWidth = 0;
        this.resolution = resolution;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_ = null;
        this.bufferedMaxExtent_ = null;
        this.instructions = [];
        this.coordinates = [];
        this.tmpCoordinate_ = [];
        this.hitDetectionInstructions = [];
        this.state = /** @type {import("../canvas.js").FillStrokeState} */
        {};
      }
      /**
       * @protected
       * @param {Array<number>} dashArray Dash array.
       * @return {Array<number>} Dash array with pixel ratio applied
       */
      applyPixelRatio(dashArray) {
        const pixelRatio = this.pixelRatio;
        return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
          return dash * pixelRatio;
        });
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} stride Stride.
       * @protected
       * @return {number} My end
       */
      appendFlatPointCoordinates(flatCoordinates, stride) {
        const extent = this.getBufferedMaxExtent();
        const tmpCoord = this.tmpCoordinate_;
        const coordinates2 = this.coordinates;
        let myEnd = coordinates2.length;
        for (let i7 = 0, ii = flatCoordinates.length; i7 < ii; i7 += stride) {
          tmpCoord[0] = flatCoordinates[i7];
          tmpCoord[1] = flatCoordinates[i7 + 1];
          if (containsCoordinate(extent, tmpCoord)) {
            coordinates2[myEnd++] = tmpCoord[0];
            coordinates2[myEnd++] = tmpCoord[1];
          }
        }
        return myEnd;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} closed Last input coordinate equals first.
       * @param {boolean} skipFirst Skip first coordinate.
       * @protected
       * @return {number} My end.
       */
      appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
        const coordinates2 = this.coordinates;
        let myEnd = coordinates2.length;
        const extent = this.getBufferedMaxExtent();
        if (skipFirst) {
          offset += stride;
        }
        let lastXCoord = flatCoordinates[offset];
        let lastYCoord = flatCoordinates[offset + 1];
        const nextCoord = this.tmpCoordinate_;
        let skipped = true;
        let i7, lastRel, nextRel;
        for (i7 = offset + stride; i7 < end; i7 += stride) {
          nextCoord[0] = flatCoordinates[i7];
          nextCoord[1] = flatCoordinates[i7 + 1];
          nextRel = coordinateRelationship(extent, nextCoord);
          if (nextRel !== lastRel) {
            if (skipped) {
              coordinates2[myEnd++] = lastXCoord;
              coordinates2[myEnd++] = lastYCoord;
              skipped = false;
            }
            coordinates2[myEnd++] = nextCoord[0];
            coordinates2[myEnd++] = nextCoord[1];
          } else if (nextRel === Relationship_default.INTERSECTING) {
            coordinates2[myEnd++] = nextCoord[0];
            coordinates2[myEnd++] = nextCoord[1];
            skipped = false;
          } else {
            skipped = true;
          }
          lastXCoord = nextCoord[0];
          lastYCoord = nextCoord[1];
          lastRel = nextRel;
        }
        if (closed && skipped || i7 === offset + stride) {
          coordinates2[myEnd++] = lastXCoord;
          coordinates2[myEnd++] = lastYCoord;
        }
        return myEnd;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Array<number>} builderEnds Builder ends.
       * @return {number} Offset.
       */
      drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
        for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
          const end = ends[i7];
          const builderEnd = this.appendFlatLineCoordinates(
            flatCoordinates,
            offset,
            end,
            stride,
            false,
            false
          );
          builderEnds.push(builderEnd);
          offset = end;
        }
        return offset;
      }
      /**
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       * @param {Function} hitDetectionRenderer Renderer.
       * @param {number} [index] Render order index.
       * @override
       */
      drawCustom(geometry, feature, renderer, hitDetectionRenderer, index13) {
        this.beginGeometry(geometry, feature, index13);
        const type = geometry.getType();
        const stride = geometry.getStride();
        const builderBegin = this.coordinates.length;
        let flatCoordinates, builderEnd, builderEnds, builderEndss;
        let offset;
        switch (type) {
          case "MultiPolygon":
            flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getOrientedFlatCoordinates();
            builderEndss = [];
            const endss = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getEndss()
            );
            offset = 0;
            for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
              const myEnds = [];
              offset = this.drawCustomCoordinates_(
                flatCoordinates,
                offset,
                endss[i7],
                stride,
                myEnds
              );
              builderEndss.push(myEnds);
            }
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEndss,
              geometry,
              renderer,
              inflateMultiCoordinatesArray,
              index13
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEndss,
              geometry,
              hitDetectionRenderer || renderer,
              inflateMultiCoordinatesArray,
              index13
            ]);
            break;
          case "Polygon":
          case "MultiLineString":
            builderEnds = [];
            flatCoordinates = type == "Polygon" ? (
              /** @type {import("../../geom/Polygon.js").default} */
              geometry.getOrientedFlatCoordinates()
            ) : geometry.getFlatCoordinates();
            offset = this.drawCustomCoordinates_(
              flatCoordinates,
              0,
              /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
              geometry.getEnds(),
              stride,
              builderEnds
            );
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnds,
              geometry,
              renderer,
              inflateCoordinatesArray,
              index13
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnds,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinatesArray,
              index13
            ]);
            break;
          case "LineString":
          case "Circle":
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatLineCoordinates(
              flatCoordinates,
              0,
              flatCoordinates.length,
              stride,
              false,
              false
            );
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer,
              inflateCoordinates,
              index13
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinates,
              index13
            ]);
            break;
          case "MultiPoint":
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (builderEnd > builderBegin) {
              this.instructions.push([
                Instruction_default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                renderer,
                inflateCoordinates,
                index13
              ]);
              this.hitDetectionInstructions.push([
                Instruction_default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                hitDetectionRenderer || renderer,
                inflateCoordinates,
                index13
              ]);
            }
            break;
          case "Point":
            flatCoordinates = geometry.getFlatCoordinates();
            this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
            builderEnd = this.coordinates.length;
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer,
              void 0,
              index13
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer,
              void 0,
              index13
            ]);
            break;
          default:
        }
        this.endGeometry(feature);
      }
      /**
       * @protected
       * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} index Render order index
       */
      beginGeometry(geometry, feature, index13) {
        this.beginGeometryInstruction1_ = [
          Instruction_default.BEGIN_GEOMETRY,
          feature,
          0,
          geometry,
          index13
        ];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [
          Instruction_default.BEGIN_GEOMETRY,
          feature,
          0,
          geometry,
          index13
        ];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        return {
          instructions: this.instructions,
          hitDetectionInstructions: this.hitDetectionInstructions,
          coordinates: this.coordinates
        };
      }
      /**
       * Reverse the hit detection instructions.
       */
      reverseHitDetectionInstructions() {
        const hitDetectionInstructions = this.hitDetectionInstructions;
        hitDetectionInstructions.reverse();
        let i7;
        const n6 = hitDetectionInstructions.length;
        let instruction;
        let type;
        let begin = -1;
        for (i7 = 0; i7 < n6; ++i7) {
          instruction = hitDetectionInstructions[i7];
          type = /** @type {import("./Instruction.js").default} */
          instruction[0];
          if (type == Instruction_default.END_GEOMETRY) {
            begin = i7;
          } else if (type == Instruction_default.BEGIN_GEOMETRY) {
            instruction[2] = i7;
            reverseSubArray(this.hitDetectionInstructions, begin, i7);
            begin = -1;
          }
        }
      }
      /**
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import('../canvas.js').FillStrokeState} [state] State.
       * @return {import('../canvas.js').FillStrokeState} State.
       */
      fillStyleToState(fillStyle, state = (
        /** @type {import('../canvas.js').FillStrokeState} */
        {}
      )) {
        if (fillStyle) {
          const fillStyleColor = fillStyle.getColor();
          state.fillPatternScale = fillStyleColor && typeof fillStyleColor === "object" && "src" in fillStyleColor ? this.pixelRatio : 1;
          state.fillStyle = asColorLike(
            fillStyleColor ? fillStyleColor : defaultFillStyle
          );
        } else {
          state.fillStyle = void 0;
        }
        return state;
      }
      /**
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {import("../canvas.js").FillStrokeState} State.
       */
      strokeStyleToState(strokeStyle, state = (
        /** @type {import('../canvas.js').FillStrokeState} */
        {}
      )) {
        if (strokeStyle) {
          const strokeStyleColor = strokeStyle.getColor();
          state.strokeStyle = asColorLike(
            strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
          );
          const strokeStyleLineCap = strokeStyle.getLineCap();
          state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
          const strokeStyleLineDash = strokeStyle.getLineDash();
          state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
          const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
          const strokeStyleLineJoin = strokeStyle.getLineJoin();
          state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
          const strokeStyleWidth = strokeStyle.getWidth();
          state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
          const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
          if (state.lineWidth > this.maxLineWidth) {
            this.maxLineWidth = state.lineWidth;
            this.bufferedMaxExtent_ = null;
          }
        } else {
          state.strokeStyle = void 0;
          state.lineCap = void 0;
          state.lineDash = null;
          state.lineDashOffset = void 0;
          state.lineJoin = void 0;
          state.lineWidth = void 0;
          state.miterLimit = void 0;
        }
        return state;
      }
      /**
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       * @override
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
        const state = this.state;
        this.fillStyleToState(fillStyle, state);
        this.strokeStyleToState(strokeStyle, state);
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Fill instruction.
       */
      createFill(state) {
        const fillStyle = state.fillStyle;
        const fillInstruction2 = [Instruction_default.SET_FILL_STYLE, fillStyle];
        if (typeof fillStyle !== "string") {
          fillInstruction2.push(state.fillPatternScale);
        }
        return fillInstruction2;
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      applyStroke(state) {
        this.instructions.push(this.createStroke(state));
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Stroke instruction.
       */
      createStroke(state) {
        return [
          Instruction_default.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth * this.pixelRatio,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          state.lineDash ? this.applyPixelRatio(state.lineDash) : null,
          state.lineDashOffset * this.pixelRatio
        ];
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
       */
      updateFillStyle(state, createFill) {
        const fillStyle = state.fillStyle;
        if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
          this.instructions.push(createFill.call(this, state));
          state.currentFillStyle = fillStyle;
        }
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
       */
      updateStrokeStyle(state, applyStroke) {
        const strokeStyle = state.strokeStyle;
        const lineCap = state.lineCap;
        const lineDash = state.lineDash;
        const lineDashOffset = state.lineDashOffset;
        const lineJoin = state.lineJoin;
        const lineWidth = state.lineWidth;
        const miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals3(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
          applyStroke.call(this, state);
          state.currentStrokeStyle = strokeStyle;
          state.currentLineCap = lineCap;
          state.currentLineDash = lineDash;
          state.currentLineDashOffset = lineDashOffset;
          state.currentLineJoin = lineJoin;
          state.currentLineWidth = lineWidth;
          state.currentMiterLimit = miterLimit;
        }
      }
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      endGeometry(feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        const endGeometryInstruction = [Instruction_default.END_GEOMETRY, feature];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
      }
      /**
       * Get the buffered rendering extent.  Rendering will be clipped to the extent
       * provided to the constructor.  To account for symbolizers that may intersect
       * this extent, we calculate a buffered extent (e.g. based on stroke width).
       * @return {import("../../extent.js").Extent} The buffered rendering extent.
       * @protected
       */
      getBufferedMaxExtent() {
        if (!this.bufferedMaxExtent_) {
          this.bufferedMaxExtent_ = clone(this.maxExtent);
          if (this.maxLineWidth > 0) {
            const width = this.resolution * (this.maxLineWidth + 1) / 2;
            buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
          }
        }
        return this.bufferedMaxExtent_;
      }
    };
    Builder_default = CanvasBuilder;
  }
});

// node_modules/ol/render/canvas/ImageBuilder.js
var CanvasImageBuilder, ImageBuilder_default;
var init_ImageBuilder = __esm({
  "node_modules/ol/render/canvas/ImageBuilder.js"() {
    init_extent();
    init_Builder();
    init_Instruction();
    CanvasImageBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = void 0;
        this.anchorX_ = void 0;
        this.anchorY_ = void 0;
        this.height_ = void 0;
        this.opacity_ = void 0;
        this.originX_ = void 0;
        this.originY_ = void 0;
        this.rotateWithView_ = void 0;
        this.rotation_ = void 0;
        this.scale_ = void 0;
        this.width_ = void 0;
        this.declutterMode_ = void 0;
        this.declutterImageWithText_ = void 0;
      }
      /**
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       * @override
       */
      drawPoint(pointGeometry, feature, index13) {
        if (!this.image_ || this.maxExtent && !containsCoordinate(this.maxExtent, pointGeometry.getFlatCoordinates())) {
          return;
        }
        this.beginGeometry(pointGeometry, feature, index13);
        const flatCoordinates = pointGeometry.getFlatCoordinates();
        const stride = pointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_ * this.imagePixelRatio_,
          this.anchorY_ * this.imagePixelRatio_,
          Math.ceil(this.height_ * this.imagePixelRatio_),
          this.opacity_,
          this.originX_ * this.imagePixelRatio_,
          this.originY_ * this.imagePixelRatio_,
          this.rotateWithView_,
          this.rotation_,
          [
            this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
            this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
          ],
          Math.ceil(this.width_ * this.imagePixelRatio_),
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       * @override
       */
      drawMultiPoint(multiPointGeometry, feature, index13) {
        if (!this.image_) {
          return;
        }
        this.beginGeometry(multiPointGeometry, feature, index13);
        const flatCoordinates = multiPointGeometry.getFlatCoordinates();
        const filteredFlatCoordinates = [];
        for (let i7 = 0, ii = flatCoordinates.length; i7 < ii; i7 += multiPointGeometry.getStride()) {
          if (!this.maxExtent || containsCoordinate(this.maxExtent, flatCoordinates.slice(i7, i7 + 2))) {
            filteredFlatCoordinates.push(
              flatCoordinates[i7],
              flatCoordinates[i7 + 1]
            );
          }
        }
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(filteredFlatCoordinates, 2);
        this.instructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_ * this.imagePixelRatio_,
          this.anchorY_ * this.imagePixelRatio_,
          Math.ceil(this.height_ * this.imagePixelRatio_),
          this.opacity_,
          this.originX_ * this.imagePixelRatio_,
          this.originY_ * this.imagePixelRatio_,
          this.rotateWithView_,
          this.rotation_,
          [
            this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
            this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
          ],
          Math.ceil(this.width_ * this.imagePixelRatio_),
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       * @override
       */
      finish() {
        this.reverseHitDetectionInstructions();
        this.anchorX_ = void 0;
        this.anchorY_ = void 0;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = void 0;
        this.height_ = void 0;
        this.scale_ = void 0;
        this.opacity_ = void 0;
        this.originX_ = void 0;
        this.originY_ = void 0;
        this.rotateWithView_ = void 0;
        this.rotation_ = void 0;
        this.width_ = void 0;
        return super.finish();
      }
      /**
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       * @param {Object} [sharedData] Shared data.
       * @override
       */
      setImageStyle(imageStyle, sharedData) {
        const anchor = imageStyle.getAnchor();
        const size = imageStyle.getSize();
        const origin = imageStyle.getOrigin();
        this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
        this.image_ = imageStyle.getImage(this.pixelRatio);
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0];
        this.originY_ = origin[1];
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScaleArray();
        this.width_ = size[0];
        this.declutterMode_ = imageStyle.getDeclutterMode();
        this.declutterImageWithText_ = sharedData;
      }
    };
    ImageBuilder_default = CanvasImageBuilder;
  }
});

// node_modules/ol/render/canvas/LineStringBuilder.js
var CanvasLineStringBuilder, LineStringBuilder_default;
var init_LineStringBuilder = __esm({
  "node_modules/ol/render/canvas/LineStringBuilder.js"() {
    init_canvas();
    init_Builder();
    init_Instruction();
    CanvasLineStringBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} end.
       */
      drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          offset,
          end,
          stride,
          false,
          false
        );
        const moveToLineToInstruction = [
          Instruction_default.MOVE_TO_LINE_TO,
          myBegin,
          myEnd
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
      }
      /**
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       * @override
       */
      drawLineString(lineStringGeometry, feature, index13) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === void 0 || lineWidth === void 0) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature, index13);
        this.hitDetectionInstructions.push(
          [
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ],
          beginPathInstruction
        );
        const flatCoordinates = lineStringGeometry.getFlatCoordinates();
        const stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride
        );
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       * @override
       */
      drawMultiLineString(multiLineStringGeometry, feature, index13) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === void 0 || lineWidth === void 0) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature, index13);
        this.hitDetectionInstructions.push(
          [
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ],
          beginPathInstruction
        );
        const ends = multiLineStringGeometry.getEnds();
        const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        const stride = multiLineStringGeometry.getStride();
        let offset = 0;
        for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
          offset = this.drawFlatCoordinates_(
            flatCoordinates,
            offset,
            /** @type {number} */
            ends[i7],
            stride
          );
        }
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       * @override
       */
      finish() {
        const state = this.state;
        if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
        }
        this.reverseHitDetectionInstructions();
        this.state = null;
        return super.finish();
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @override
       */
      applyStroke(state) {
        if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
          state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        super.applyStroke(state);
        this.instructions.push(beginPathInstruction);
      }
    };
    LineStringBuilder_default = CanvasLineStringBuilder;
  }
});

// node_modules/ol/render/canvas/PolygonBuilder.js
var CanvasPolygonBuilder, PolygonBuilder_default;
var init_PolygonBuilder = __esm({
  "node_modules/ol/render/canvas/PolygonBuilder.js"() {
    init_simplify();
    init_canvas();
    init_Builder();
    init_Instruction();
    CanvasPolygonBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
        const state = this.state;
        const fill = state.fillStyle !== void 0;
        const stroke = state.strokeStyle !== void 0;
        const numEnds = ends.length;
        this.instructions.push(beginPathInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction);
        for (let i7 = 0; i7 < numEnds; ++i7) {
          const end = ends[i7];
          const myBegin = this.coordinates.length;
          const myEnd = this.appendFlatLineCoordinates(
            flatCoordinates,
            offset,
            end,
            stride,
            true,
            !stroke
          );
          const moveToLineToInstruction = [
            Instruction_default.MOVE_TO_LINE_TO,
            myBegin,
            myEnd
          ];
          this.instructions.push(moveToLineToInstruction);
          this.hitDetectionInstructions.push(moveToLineToInstruction);
          if (stroke) {
            this.instructions.push(closePathInstruction);
            this.hitDetectionInstructions.push(closePathInstruction);
          }
          offset = end;
        }
        if (fill) {
          this.instructions.push(fillInstruction);
          this.hitDetectionInstructions.push(fillInstruction);
        }
        if (stroke) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        return offset;
      }
      /**
       * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} [index] Render order index.
       * @override
       */
      drawCircle(circleGeometry, feature, index13) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature, index13);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const flatCoordinates = circleGeometry.getFlatCoordinates();
        const stride = circleGeometry.getStride();
        const myBegin = this.coordinates.length;
        this.appendFlatLineCoordinates(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          false,
          false
        );
        const circleInstruction = [Instruction_default.CIRCLE, myBegin];
        this.instructions.push(beginPathInstruction, circleInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
        if (state.fillStyle !== void 0) {
          this.instructions.push(fillInstruction);
          this.hitDetectionInstructions.push(fillInstruction);
        }
        if (state.strokeStyle !== void 0) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       * @override
       */
      drawPolygon(polygonGeometry, feature, index13) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature, index13);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const ends = polygonGeometry.getEnds();
        const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        const stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(
          flatCoordinates,
          0,
          /** @type {Array<number>} */
          ends,
          stride
        );
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       * @override
       */
      drawMultiPolygon(multiPolygonGeometry, feature, index13) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature, index13);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const endss = multiPolygonGeometry.getEndss();
        const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        const stride = multiPolygonGeometry.getStride();
        let offset = 0;
        for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
          offset = this.drawFlatCoordinatess_(
            flatCoordinates,
            offset,
            endss[i7],
            stride
          );
        }
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       * @override
       */
      finish() {
        this.reverseHitDetectionInstructions();
        this.state = null;
        const tolerance = this.tolerance;
        if (tolerance !== 0) {
          const coordinates2 = this.coordinates;
          for (let i7 = 0, ii = coordinates2.length; i7 < ii; ++i7) {
            coordinates2[i7] = snap(coordinates2[i7], tolerance);
          }
        }
        return super.finish();
      }
      /**
       * @private
       */
      setFillStrokeStyles_() {
        const state = this.state;
        this.updateFillStyle(state, this.createFill);
        this.updateStrokeStyle(state, this.applyStroke);
      }
    };
    PolygonBuilder_default = CanvasPolygonBuilder;
  }
});

// node_modules/ol/geom/flat/linechunk.js
function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {
  const chunks = [];
  let cursor = offset;
  let chunkM = 0;
  let currentChunk = flatCoordinates.slice(offset, 2);
  while (chunkM < chunkLength && cursor + stride < end) {
    const [x1, y1] = currentChunk.slice(-2);
    const x22 = flatCoordinates[cursor + stride];
    const y22 = flatCoordinates[cursor + stride + 1];
    const segmentLength = Math.sqrt(
      (x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1)
    );
    chunkM += segmentLength;
    if (chunkM >= chunkLength) {
      const m8 = (chunkLength - chunkM + segmentLength) / segmentLength;
      const x4 = lerp(x1, x22, m8);
      const y5 = lerp(y1, y22, m8);
      currentChunk.push(x4, y5);
      chunks.push(currentChunk);
      currentChunk = [x4, y5];
      if (chunkM == chunkLength) {
        cursor += stride;
      }
      chunkM = 0;
    } else if (chunkM < chunkLength) {
      currentChunk.push(
        flatCoordinates[cursor + stride],
        flatCoordinates[cursor + stride + 1]
      );
      cursor += stride;
    } else {
      const missing = segmentLength - chunkM;
      const x4 = lerp(x1, x22, missing / segmentLength);
      const y5 = lerp(y1, y22, missing / segmentLength);
      currentChunk.push(x4, y5);
      chunks.push(currentChunk);
      currentChunk = [x4, y5];
      chunkM = 0;
      cursor += stride;
    }
  }
  if (chunkM > 0) {
    chunks.push(currentChunk);
  }
  return chunks;
}
var init_linechunk = __esm({
  "node_modules/ol/geom/flat/linechunk.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/straightchunk.js
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  let chunkStart = offset;
  let chunkEnd = offset;
  let chunkM = 0;
  let m8 = 0;
  let start2 = offset;
  let acos, i7, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i7 = offset; i7 < end; i7 += stride) {
    const x22 = flatCoordinates[i7];
    const y22 = flatCoordinates[i7 + 1];
    if (x1 !== void 0) {
      x23 = x22 - x1;
      y23 = y22 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== void 0) {
        m8 += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m8 > chunkM) {
            chunkM = m8;
            chunkStart = start2;
            chunkEnd = i7;
          }
          m8 = 0;
          start2 = i7 - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x22;
    y1 = y22;
  }
  m8 += m23;
  return m8 > chunkM ? [start2, i7] : [chunkStart, chunkEnd];
}
var init_straightchunk = __esm({
  "node_modules/ol/geom/flat/straightchunk.js"() {
  }
});

// node_modules/ol/render/canvas/TextBuilder.js
var TEXT_ALIGN, CanvasTextBuilder, TextBuilder_default;
var init_TextBuilder = __esm({
  "node_modules/ol/render/canvas/TextBuilder.js"() {
    init_colorlike();
    init_extent();
    init_linechunk();
    init_straightchunk();
    init_util();
    init_canvas();
    init_Builder();
    init_Instruction();
    TEXT_ALIGN = {
      "left": 0,
      "center": 0.5,
      "right": 1,
      "top": 0,
      "middle": 0.5,
      "hanging": 0.2,
      "alphabetic": 0.8,
      "ideographic": 0.8,
      "bottom": 1
    };
    CanvasTextBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
        this.labels_ = null;
        this.text_ = "";
        this.textOffsetX_ = 0;
        this.textOffsetY_ = 0;
        this.textRotateWithView_ = void 0;
        this.textKeepUpright_ = void 0;
        this.textRotation_ = 0;
        this.textFillState_ = null;
        this.fillStates = {};
        this.fillStates[defaultFillStyle] = { fillStyle: defaultFillStyle };
        this.textStrokeState_ = null;
        this.strokeStates = {};
        this.textState_ = /** @type {import("../canvas.js").TextState} */
        {};
        this.textStates = {};
        this.textKey_ = "";
        this.fillKey_ = "";
        this.strokeKey_ = "";
        this.declutterMode_ = void 0;
        this.declutterImageWithText_ = void 0;
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       * @override
       */
      finish() {
        const instructions = super.finish();
        instructions.textStates = this.textStates;
        instructions.fillStates = this.fillStates;
        instructions.strokeStates = this.strokeStates;
        return instructions;
      }
      /**
       * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       * @override
       */
      drawText(geometry, feature, index13) {
        const fillState = this.textFillState_;
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        if (this.text_ === "" || !textState || !fillState && !strokeState) {
          return;
        }
        const coordinates2 = this.coordinates;
        let begin = coordinates2.length;
        const geometryType = geometry.getType();
        let flatCoordinates = null;
        let stride = geometry.getStride();
        if (textState.placement === "line" && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
          if (!intersects(this.maxExtent, geometry.getExtent())) {
            return;
          }
          let ends;
          flatCoordinates = geometry.getFlatCoordinates();
          if (geometryType == "LineString") {
            ends = [flatCoordinates.length];
          } else if (geometryType == "MultiLineString") {
            ends = /** @type {import("../../geom/MultiLineString.js").default} */
            geometry.getEnds();
          } else if (geometryType == "Polygon") {
            ends = /** @type {import("../../geom/Polygon.js").default} */
            geometry.getEnds().slice(0, 1);
          } else if (geometryType == "MultiPolygon") {
            const endss = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getEndss()
            );
            ends = [];
            for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
              ends.push(endss[i7][0]);
            }
          }
          this.beginGeometry(geometry, feature, index13);
          const repeat = textState.repeat;
          const textAlign = repeat ? void 0 : textState.textAlign;
          let flatOffset = 0;
          for (let o5 = 0, oo = ends.length; o5 < oo; ++o5) {
            let chunks;
            if (repeat) {
              chunks = lineChunk(
                repeat * this.resolution,
                flatCoordinates,
                flatOffset,
                ends[o5],
                stride
              );
            } else {
              chunks = [flatCoordinates.slice(flatOffset, ends[o5])];
            }
            for (let c7 = 0, cc2 = chunks.length; c7 < cc2; ++c7) {
              const chunk = chunks[c7];
              let chunkBegin = 0;
              let chunkEnd = chunk.length;
              if (textAlign == void 0) {
                const range = matchingChunk(
                  textState.maxAngle,
                  chunk,
                  0,
                  chunk.length,
                  2
                );
                chunkBegin = range[0];
                chunkEnd = range[1];
              }
              for (let i7 = chunkBegin; i7 < chunkEnd; i7 += stride) {
                coordinates2.push(chunk[i7], chunk[i7 + 1]);
              }
              const end = coordinates2.length;
              flatOffset = ends[o5];
              this.drawChars_(begin, end);
              begin = end;
            }
          }
          this.endGeometry(feature);
        } else {
          let geometryWidths = textState.overflow ? null : [];
          switch (geometryType) {
            case "Point":
            case "MultiPoint":
              flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */
              geometry.getFlatCoordinates();
              break;
            case "LineString":
              flatCoordinates = /** @type {import("../../geom/LineString.js").default} */
              geometry.getFlatMidpoint();
              break;
            case "Circle":
              flatCoordinates = /** @type {import("../../geom/Circle.js").default} */
              geometry.getCenter();
              break;
            case "MultiLineString":
              flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */
              geometry.getFlatMidpoints();
              stride = 2;
              break;
            case "Polygon":
              flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */
              geometry.getFlatInteriorPoint();
              if (!textState.overflow) {
                geometryWidths.push(flatCoordinates[2] / this.resolution);
              }
              stride = 3;
              break;
            case "MultiPolygon":
              const interiorPoints = (
                /** @type {import("../../geom/MultiPolygon.js").default} */
                geometry.getFlatInteriorPoints()
              );
              flatCoordinates = [];
              for (let i7 = 0, ii = interiorPoints.length; i7 < ii; i7 += 3) {
                if (!textState.overflow) {
                  geometryWidths.push(interiorPoints[i7 + 2] / this.resolution);
                }
                flatCoordinates.push(interiorPoints[i7], interiorPoints[i7 + 1]);
              }
              if (flatCoordinates.length === 0) {
                return;
              }
              stride = 2;
              break;
            default:
          }
          const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
          if (end === begin) {
            return;
          }
          if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
            let beg = begin / 2;
            geometryWidths = geometryWidths.filter((w5, i7) => {
              const keep = coordinates2[(beg + i7) * 2] === flatCoordinates[i7 * stride] && coordinates2[(beg + i7) * 2 + 1] === flatCoordinates[i7 * stride + 1];
              if (!keep) {
                --beg;
              }
              return keep;
            });
          }
          this.saveTextStates_();
          const backgroundFill = textState.backgroundFill ? this.createFill(this.fillStyleToState(textState.backgroundFill)) : null;
          const backgroundStroke = textState.backgroundStroke ? this.createStroke(this.strokeStyleToState(textState.backgroundStroke)) : null;
          this.beginGeometry(geometry, feature, index13);
          let padding = textState.padding;
          if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
            let p0 = textState.padding[0];
            let p12 = textState.padding[1];
            let p23 = textState.padding[2];
            let p33 = textState.padding[3];
            if (textState.scale[0] < 0) {
              p12 = -p12;
              p33 = -p33;
            }
            if (textState.scale[1] < 0) {
              p0 = -p0;
              p23 = -p23;
            }
            padding = [p0, p12, p23, p33];
          }
          const pixelRatio = this.pixelRatio;
          this.instructions.push([
            Instruction_default.DRAW_IMAGE,
            begin,
            end,
            null,
            NaN,
            NaN,
            NaN,
            1,
            0,
            0,
            this.textRotateWithView_,
            this.textRotation_,
            [1, 1],
            NaN,
            this.declutterMode_,
            this.declutterImageWithText_,
            padding == defaultPadding ? defaultPadding : padding.map(function(p6) {
              return p6 * pixelRatio;
            }),
            backgroundFill,
            backgroundStroke,
            this.text_,
            this.textKey_,
            this.strokeKey_,
            this.fillKey_,
            this.textOffsetX_,
            this.textOffsetY_,
            geometryWidths
          ]);
          const scale3 = 1 / pixelRatio;
          const hitDetectionBackgroundFill = backgroundFill ? backgroundFill.slice(0) : null;
          if (hitDetectionBackgroundFill) {
            hitDetectionBackgroundFill[1] = defaultFillStyle;
          }
          this.hitDetectionInstructions.push([
            Instruction_default.DRAW_IMAGE,
            begin,
            end,
            null,
            NaN,
            NaN,
            NaN,
            1,
            0,
            0,
            this.textRotateWithView_,
            this.textRotation_,
            [scale3, scale3],
            NaN,
            this.declutterMode_,
            this.declutterImageWithText_,
            padding,
            hitDetectionBackgroundFill,
            backgroundStroke,
            this.text_,
            this.textKey_,
            this.strokeKey_,
            this.fillKey_ ? defaultFillStyle : this.fillKey_,
            this.textOffsetX_,
            this.textOffsetY_,
            geometryWidths
          ]);
          this.endGeometry(feature);
        }
      }
      /**
       * @private
       */
      saveTextStates_() {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const fillState = this.textFillState_;
        const strokeKey = this.strokeKey_;
        if (strokeState) {
          if (!(strokeKey in this.strokeStates)) {
            this.strokeStates[strokeKey] = {
              strokeStyle: strokeState.strokeStyle,
              lineCap: strokeState.lineCap,
              lineDashOffset: strokeState.lineDashOffset,
              lineWidth: strokeState.lineWidth,
              lineJoin: strokeState.lineJoin,
              miterLimit: strokeState.miterLimit,
              lineDash: strokeState.lineDash
            };
          }
        }
        const textKey = this.textKey_;
        if (!(textKey in this.textStates)) {
          this.textStates[textKey] = {
            font: textState.font,
            textAlign: textState.textAlign || defaultTextAlign,
            justify: textState.justify,
            textBaseline: textState.textBaseline || defaultTextBaseline,
            scale: textState.scale
          };
        }
        const fillKey = this.fillKey_;
        if (fillState) {
          if (!(fillKey in this.fillStates)) {
            this.fillStates[fillKey] = {
              fillStyle: fillState.fillStyle
            };
          }
        }
      }
      /**
       * @private
       * @param {number} begin Begin.
       * @param {number} end End.
       */
      drawChars_(begin, end) {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const strokeKey = this.strokeKey_;
        const textKey = this.textKey_;
        const fillKey = this.fillKey_;
        this.saveTextStates_();
        const pixelRatio = this.pixelRatio;
        const baseline = TEXT_ALIGN[textState.textBaseline];
        const offsetY = this.textOffsetY_ * pixelRatio;
        const text2 = this.text_;
        const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
        this.instructions.push([
          Instruction_default.DRAW_CHARS,
          begin,
          end,
          baseline,
          textState.overflow,
          fillKey,
          textState.maxAngle,
          pixelRatio,
          offsetY,
          strokeKey,
          strokeWidth * pixelRatio,
          text2,
          textKey,
          1,
          this.declutterMode_,
          this.textKeepUpright_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_CHARS,
          begin,
          end,
          baseline,
          textState.overflow,
          fillKey ? defaultFillStyle : fillKey,
          textState.maxAngle,
          pixelRatio,
          offsetY,
          strokeKey,
          strokeWidth * pixelRatio,
          text2,
          textKey,
          1 / pixelRatio,
          this.declutterMode_,
          this.textKeepUpright_
        ]);
      }
      /**
       * @param {import("../../style/Text.js").default} textStyle Text style.
       * @param {Object} [sharedData] Shared data.
       * @override
       */
      setTextStyle(textStyle, sharedData) {
        let textState, fillState, strokeState;
        if (!textStyle) {
          this.text_ = "";
        } else {
          const textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            fillState = null;
            this.textFillState_ = fillState;
          } else {
            fillState = this.textFillState_;
            if (!fillState) {
              fillState = /** @type {import("../canvas.js").FillState} */
              {};
              this.textFillState_ = fillState;
            }
            fillState.fillStyle = asColorLike(
              textFillStyle.getColor() || defaultFillStyle
            );
          }
          const textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            strokeState = null;
            this.textStrokeState_ = strokeState;
          } else {
            strokeState = this.textStrokeState_;
            if (!strokeState) {
              strokeState = /** @type {import("../canvas.js").StrokeState} */
              {};
              this.textStrokeState_ = strokeState;
            }
            const lineDash = textStrokeStyle.getLineDash();
            const lineDashOffset = textStrokeStyle.getLineDashOffset();
            const lineWidth = textStrokeStyle.getWidth();
            const miterLimit = textStrokeStyle.getMiterLimit();
            strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
            strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
            strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
            strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
            strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
            strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
            strokeState.strokeStyle = asColorLike(
              textStrokeStyle.getColor() || defaultStrokeStyle
            );
          }
          textState = this.textState_;
          const font = textStyle.getFont() || defaultFont;
          registerFont(font);
          const textScale = textStyle.getScaleArray();
          textState.overflow = textStyle.getOverflow();
          textState.font = font;
          textState.maxAngle = textStyle.getMaxAngle();
          textState.placement = textStyle.getPlacement();
          textState.textAlign = textStyle.getTextAlign();
          textState.repeat = textStyle.getRepeat();
          textState.justify = textStyle.getJustify();
          textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
          textState.backgroundFill = textStyle.getBackgroundFill();
          textState.backgroundStroke = textStyle.getBackgroundStroke();
          textState.padding = textStyle.getPadding() || defaultPadding;
          textState.scale = textScale === void 0 ? [1, 1] : textScale;
          const textOffsetX = textStyle.getOffsetX();
          const textOffsetY = textStyle.getOffsetY();
          const textRotateWithView = textStyle.getRotateWithView();
          const textKeepUpright = textStyle.getKeepUpright();
          const textRotation = textStyle.getRotation();
          this.text_ = textStyle.getText() || "";
          this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
          this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
          this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
          this.textKeepUpright_ = textKeepUpright === void 0 ? true : textKeepUpright;
          this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
          this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
          this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.repeat || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
          this.fillKey_ = fillState && fillState.fillStyle ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
        }
        this.declutterMode_ = textStyle.getDeclutterMode();
        this.declutterImageWithText_ = sharedData;
      }
    };
    TextBuilder_default = CanvasTextBuilder;
  }
});

// node_modules/ol/render/canvas/BuilderGroup.js
var BATCH_CONSTRUCTORS, BuilderGroup, BuilderGroup_default;
var init_BuilderGroup = __esm({
  "node_modules/ol/render/canvas/BuilderGroup.js"() {
    init_Builder();
    init_ImageBuilder();
    init_LineStringBuilder();
    init_PolygonBuilder();
    init_TextBuilder();
    BATCH_CONSTRUCTORS = {
      "Circle": PolygonBuilder_default,
      "Default": Builder_default,
      "Image": ImageBuilder_default,
      "LineString": LineStringBuilder_default,
      "Polygon": PolygonBuilder_default,
      "Text": TextBuilder_default
    };
    BuilderGroup = class {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Max extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        this.tolerance_ = tolerance;
        this.maxExtent_ = maxExtent;
        this.pixelRatio_ = pixelRatio;
        this.resolution_ = resolution;
        this.buildersByZIndex_ = {};
      }
      /**
       * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
       */
      finish() {
        const builderInstructions = {};
        for (const zKey in this.buildersByZIndex_) {
          builderInstructions[zKey] = builderInstructions[zKey] || {};
          const builders = this.buildersByZIndex_[zKey];
          for (const builderKey in builders) {
            const builderInstruction = builders[builderKey].finish();
            builderInstructions[zKey][builderKey] = builderInstruction;
          }
        }
        return builderInstructions;
      }
      /**
       * @param {number|undefined} zIndex Z index.
       * @param {import("../canvas.js").BuilderType} builderType Replay type.
       * @return {import("../VectorContext.js").default} Replay.
       */
      getBuilder(zIndex, builderType) {
        const zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
        let replays = this.buildersByZIndex_[zIndexKey];
        if (replays === void 0) {
          replays = {};
          this.buildersByZIndex_[zIndexKey] = replays;
        }
        let replay = replays[builderType];
        if (replay === void 0) {
          const Constructor = BATCH_CONSTRUCTORS[builderType];
          replay = new Constructor(
            this.tolerance_,
            this.maxExtent_,
            this.resolution_,
            this.pixelRatio_
          );
          replays[builderType] = replay;
        }
        return replay;
      }
    };
    BuilderGroup_default = BuilderGroup;
  }
});

// node_modules/ol/geom/flat/textpath.js
function drawTextOnPath(flatCoordinates, offset, end, stride, text2, startM, maxAngle, scale3, measureAndCacheTextWidth2, font, cache3, rotation, keepUpright = true) {
  let x22 = flatCoordinates[offset];
  let y22 = flatCoordinates[offset + 1];
  let x1 = 0;
  let y1 = 0;
  let segmentLength = 0;
  let segmentM = 0;
  function advance() {
    x1 = x22;
    y1 = y22;
    offset += stride;
    x22 = flatCoordinates[offset];
    y22 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1));
  }
  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);
  let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  const beginX = lerp(x1, x22, interpolate);
  const beginY = lerp(y1, y22, interpolate);
  const startOffset = offset - stride;
  const startLength = segmentM;
  const endM = startM + scale3 * measureAndCacheTextWidth2(font, text2, cache3);
  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  const endX = lerp(x1, x22, interpolate);
  const endY = lerp(y1, y22, interpolate);
  let reverse = false;
  if (keepUpright) {
    if (rotation) {
      const flat = [beginX, beginY, endX, endY];
      rotate2(flat, 0, 4, 2, rotation, flat, flat);
      reverse = flat[0] > flat[2];
    } else {
      reverse = beginX > endX;
    }
  }
  const PI = Math.PI;
  const result = [];
  const singleSegment = startOffset + stride === offset;
  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x22 = flatCoordinates[offset];
  y22 = flatCoordinates[offset + 1];
  let previousAngle;
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y22 - y1, x22 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    const x4 = (endX + beginX) / 2;
    const y5 = (endY + beginY) / 2;
    result[0] = [x4, y5, (endM - startM) / 2, previousAngle, text2];
    return result;
  }
  text2 = text2.replace(/\n/g, " ");
  for (let i7 = 0, ii = text2.length; i7 < ii; ) {
    advance();
    let angle = Math.atan2(y22 - y1, x22 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== void 0) {
      let delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;
    const iStart = i7;
    let charLength = 0;
    for (; i7 < ii; ++i7) {
      const index13 = reverse ? ii - i7 - 1 : i7;
      const len = scale3 * measureAndCacheTextWidth2(font, text2[index13], cache3);
      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i7 === iStart) {
      continue;
    }
    const chars2 = reverse ? text2.substring(ii - iStart, ii - i7) : text2.substring(iStart, i7);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    const x4 = lerp(x1, x22, interpolate);
    const y5 = lerp(y1, y22, interpolate);
    result.push([x4, y5, charLength / 2, angle, chars2]);
    startM += charLength;
  }
  return result;
}
var init_textpath = __esm({
  "node_modules/ol/geom/flat/textpath.js"() {
    init_math();
    init_transform2();
  }
});

// node_modules/ol/render/canvas/ZIndexContext.js
var ZIndexContext, ZIndexContext_default;
var init_ZIndexContext = __esm({
  "node_modules/ol/render/canvas/ZIndexContext.js"() {
    init_dom();
    ZIndexContext = class {
      constructor() {
        this.instructions_ = [];
        this.zIndex = 0;
        this.offset_ = 0;
        this.context_ = /** @type {ZIndexContextProxy} */
        new Proxy(getSharedCanvasContext2D(), {
          get: (target, property) => {
            if (typeof /** @type {*} */
            getSharedCanvasContext2D()[property] !== "function") {
              return void 0;
            }
            this.push_(property);
            return this.pushMethodArgs_;
          },
          set: (target, property, value) => {
            this.push_(property, value);
            return true;
          }
        });
      }
      /**
       * @param {...*} args Arguments to push to the instructions array.
       * @private
       */
      push_(...args) {
        const instructions = this.instructions_;
        const index13 = this.zIndex + this.offset_;
        if (!instructions[index13]) {
          instructions[index13] = [];
        }
        instructions[index13].push(...args);
      }
      /**
       * @private
       * @param {...*} args Args.
       * @return {ZIndexContext} This.
       */
      pushMethodArgs_ = (...args) => {
        this.push_(args);
        return this;
      };
      /**
       * Push a function that renders to the context directly.
       * @param {function(CanvasRenderingContext2D): void} render Function.
       */
      pushFunction(render) {
        this.push_(render);
      }
      /**
       * Get a proxy for CanvasRenderingContext2D which does not support getting state
       * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
       * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
       * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
       * @return {ZIndexContextProxy} Context.
       */
      getContext() {
        return this.context_;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       */
      draw(context) {
        this.instructions_.forEach((instructionsAtIndex) => {
          for (let i7 = 0, ii = instructionsAtIndex.length; i7 < ii; ++i7) {
            const property = instructionsAtIndex[i7];
            if (typeof property === "function") {
              property(context);
              continue;
            }
            const instructionAtIndex = instructionsAtIndex[++i7];
            if (typeof /** @type {*} */
            context[property] === "function") {
              context[property](...instructionAtIndex);
            } else {
              if (typeof instructionAtIndex === "function") {
                context[property] = instructionAtIndex(context);
                continue;
              }
              context[property] = instructionAtIndex;
            }
          }
        });
      }
      clear() {
        this.instructions_.length = 0;
        this.zIndex = 0;
        this.offset_ = 0;
      }
      /**
       * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
       * avoid conflicting context.clip() or context.save()/restore() calls.
       */
      offset() {
        this.offset_ = this.instructions_.length;
        this.zIndex = 0;
      }
    };
    ZIndexContext_default = ZIndexContext;
  }
});

// node_modules/ol/render/canvas/Executor.js
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
function horizontalTextAlign(text2, align) {
  if (align === "start") {
    align = rtlRegEx.test(text2) ? "right" : "left";
  } else if (align === "end") {
    align = rtlRegEx.test(text2) ? "left" : "right";
  }
  return TEXT_ALIGN[align];
}
function createTextChunks(acc, line, i7) {
  if (i7 > 0) {
    acc.push("\n", "");
  }
  acc.push(line, "");
  return acc;
}
function richTextToPlainText(result, part, index13) {
  if (index13 % 2 === 0) {
    result += part;
  }
  return result;
}
var tmpExtent, p1, p22, p32, p42, rtlRegEx, Executor, Executor_default;
var init_Executor = __esm({
  "node_modules/ol/render/canvas/Executor.js"() {
    init_array();
    init_extent();
    init_length();
    init_textpath();
    init_transform2();
    init_transform();
    init_ZIndexContext();
    init_canvas();
    init_Instruction();
    init_TextBuilder();
    tmpExtent = createEmpty();
    p1 = [];
    p22 = [];
    p32 = [];
    p42 = [];
    rtlRegEx = new RegExp(
      /* eslint-disable prettier/prettier */
      "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
      /* eslint-enable prettier/prettier */
    );
    Executor = class {
      /**
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The replay can have overlapping geometries.
       * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
       * @param {boolean} [deferredRendering] Enable deferred rendering.
       */
      constructor(resolution, pixelRatio, overlaps, instructions, deferredRendering) {
        this.overlaps = overlaps;
        this.pixelRatio = pixelRatio;
        this.resolution = resolution;
        this.alignAndScaleFill_;
        this.instructions = instructions.instructions;
        this.coordinates = instructions.coordinates;
        this.coordinateCache_ = {};
        this.renderedTransform_ = create();
        this.hitDetectionInstructions = instructions.hitDetectionInstructions;
        this.pixelCoordinates_ = null;
        this.viewRotation_ = 0;
        this.fillStates = instructions.fillStates || {};
        this.strokeStates = instructions.strokeStates || {};
        this.textStates = instructions.textStates || {};
        this.widths_ = {};
        this.labels_ = {};
        this.zIndexContext_ = deferredRendering ? new ZIndexContext_default() : null;
      }
      /**
       * @return {ZIndexContext} ZIndex context.
       */
      getZIndexContext() {
        return this.zIndexContext_;
      }
      /**
       * @param {string|Array<string>} text Text.
       * @param {string} textKey Text style key.
       * @param {string} fillKey Fill style key.
       * @param {string} strokeKey Stroke style key.
       * @return {import("../canvas.js").Label} Label.
       */
      createLabel(text2, textKey, fillKey, strokeKey) {
        const key = text2 + textKey + fillKey + strokeKey;
        if (this.labels_[key]) {
          return this.labels_[key];
        }
        const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
        const fillState = fillKey ? this.fillStates[fillKey] : null;
        const textState = this.textStates[textKey];
        const pixelRatio = this.pixelRatio;
        const scale3 = [
          textState.scale[0] * pixelRatio,
          textState.scale[1] * pixelRatio
        ];
        const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(
          Array.isArray(text2) ? text2[0] : text2,
          textState.textAlign || defaultTextAlign
        );
        const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const chunks = Array.isArray(text2) ? text2 : String(text2).split("\n").reduce(createTextChunks, []);
        const { width, height, widths, heights, lineWidths } = getTextDimensions(
          textState,
          chunks
        );
        const renderWidth = width + strokeWidth;
        const contextInstructions = [];
        const w5 = (renderWidth + 2) * scale3[0];
        const h5 = (height + strokeWidth) * scale3[1];
        const label = {
          width: w5 < 0 ? Math.floor(w5) : Math.ceil(w5),
          height: h5 < 0 ? Math.floor(h5) : Math.ceil(h5),
          contextInstructions
        };
        if (scale3[0] != 1 || scale3[1] != 1) {
          contextInstructions.push("scale", scale3);
        }
        if (strokeKey) {
          contextInstructions.push("strokeStyle", strokeState.strokeStyle);
          contextInstructions.push("lineWidth", strokeWidth);
          contextInstructions.push("lineCap", strokeState.lineCap);
          contextInstructions.push("lineJoin", strokeState.lineJoin);
          contextInstructions.push("miterLimit", strokeState.miterLimit);
          contextInstructions.push("setLineDash", [strokeState.lineDash]);
          contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
        }
        if (fillKey) {
          contextInstructions.push("fillStyle", fillState.fillStyle);
        }
        contextInstructions.push("textBaseline", "middle");
        contextInstructions.push("textAlign", "center");
        const leftRight = 0.5 - align;
        let x4 = align * renderWidth + leftRight * strokeWidth;
        const strokeInstructions = [];
        const fillInstructions = [];
        let lineHeight = 0;
        let lineOffset = 0;
        let widthHeightIndex = 0;
        let lineWidthIndex = 0;
        let previousFont;
        for (let i7 = 0, ii = chunks.length; i7 < ii; i7 += 2) {
          const text3 = chunks[i7];
          if (text3 === "\n") {
            lineOffset += lineHeight;
            lineHeight = 0;
            x4 = align * renderWidth + leftRight * strokeWidth;
            ++lineWidthIndex;
            continue;
          }
          const font = chunks[i7 + 1] || textState.font;
          if (font !== previousFont) {
            if (strokeKey) {
              strokeInstructions.push("font", font);
            }
            if (fillKey) {
              fillInstructions.push("font", font);
            }
            previousFont = font;
          }
          lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
          const fillStrokeArgs = [
            text3,
            x4 + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
            0.5 * (strokeWidth + lineHeight) + lineOffset
          ];
          x4 += widths[widthHeightIndex];
          if (strokeKey) {
            strokeInstructions.push("strokeText", fillStrokeArgs);
          }
          if (fillKey) {
            fillInstructions.push("fillText", fillStrokeArgs);
          }
          ++widthHeightIndex;
        }
        Array.prototype.push.apply(contextInstructions, strokeInstructions);
        Array.prototype.push.apply(contextInstructions, fillInstructions);
        this.labels_[key] = label;
        return label;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       */
      replayTextBackground_(context, p12, p23, p33, p43, fillInstruction2, strokeInstruction2) {
        context.beginPath();
        context.moveTo.apply(context, p12);
        context.lineTo.apply(context, p23);
        context.lineTo.apply(context, p33);
        context.lineTo.apply(context, p43);
        context.lineTo.apply(context, p12);
        if (fillInstruction2) {
          this.alignAndScaleFill_ = /** @type {number} */
          fillInstruction2[2];
          context.fillStyle = /** @type {string} */
          fillInstruction2[1];
          this.fill_(context);
        }
        if (strokeInstruction2) {
          this.setStrokeStyle_(
            context,
            /** @type {Array<*>} */
            strokeInstruction2
          );
          context.stroke();
        }
      }
      /**
       * @private
       * @param {number} sheetWidth Width of the sprite sheet.
       * @param {number} sheetHeight Height of the sprite sheet.
       * @param {number} centerX X.
       * @param {number} centerY Y.
       * @param {number} width Width.
       * @param {number} height Height.
       * @param {number} anchorX Anchor X.
       * @param {number} anchorY Anchor Y.
       * @param {number} originX Origin X.
       * @param {number} originY Origin Y.
       * @param {number} rotation Rotation.
       * @param {import("../../size.js").Size} scale Scale.
       * @param {boolean} snapToPixel Snap to pixel.
       * @param {Array<number>} padding Padding.
       * @param {boolean} fillStroke Background fill or stroke.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
       */
      calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale3, snapToPixel, padding, fillStroke, feature) {
        anchorX *= scale3[0];
        anchorY *= scale3[1];
        let x4 = centerX - anchorX;
        let y5 = centerY - anchorY;
        const w5 = width + originX > sheetWidth ? sheetWidth - originX : width;
        const h5 = height + originY > sheetHeight ? sheetHeight - originY : height;
        const boxW = padding[3] + w5 * scale3[0] + padding[1];
        const boxH = padding[0] + h5 * scale3[1] + padding[2];
        const boxX = x4 - padding[3];
        const boxY = y5 - padding[0];
        if (fillStroke || rotation !== 0) {
          p1[0] = boxX;
          p42[0] = boxX;
          p1[1] = boxY;
          p22[1] = boxY;
          p22[0] = boxX + boxW;
          p32[0] = p22[0];
          p32[1] = boxY + boxH;
          p42[1] = p32[1];
        }
        let transform3;
        if (rotation !== 0) {
          transform3 = compose(
            create(),
            centerX,
            centerY,
            1,
            1,
            rotation,
            -centerX,
            -centerY
          );
          apply(transform3, p1);
          apply(transform3, p22);
          apply(transform3, p32);
          apply(transform3, p42);
          createOrUpdate(
            Math.min(p1[0], p22[0], p32[0], p42[0]),
            Math.min(p1[1], p22[1], p32[1], p42[1]),
            Math.max(p1[0], p22[0], p32[0], p42[0]),
            Math.max(p1[1], p22[1], p32[1], p42[1]),
            tmpExtent
          );
        } else {
          createOrUpdate(
            Math.min(boxX, boxX + boxW),
            Math.min(boxY, boxY + boxH),
            Math.max(boxX, boxX + boxW),
            Math.max(boxY, boxY + boxH),
            tmpExtent
          );
        }
        if (snapToPixel) {
          x4 = Math.round(x4);
          y5 = Math.round(y5);
        }
        return {
          drawImageX: x4,
          drawImageY: y5,
          drawImageW: w5,
          drawImageH: h5,
          originX,
          originY,
          declutterBox: {
            minX: tmpExtent[0],
            minY: tmpExtent[1],
            maxX: tmpExtent[2],
            maxY: tmpExtent[3],
            value: feature
          },
          canvasTransform: transform3,
          scale: scale3
        };
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
       * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
       * @param {ImageOrLabelDimensions} dimensions Dimensions.
       * @param {number} opacity Opacity.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @return {boolean} The image or label was rendered.
       */
      replayImageOrLabel_(context, scaledCanvasSize, imageOrLabel, dimensions, opacity, fillInstruction2, strokeInstruction2) {
        const fillStroke = !!(fillInstruction2 || strokeInstruction2);
        const box = dimensions.declutterBox;
        const strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
        const intersects3 = box.minX - strokePadding <= scaledCanvasSize[0] && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= scaledCanvasSize[1] && box.maxY + strokePadding >= 0;
        if (intersects3) {
          if (fillStroke) {
            this.replayTextBackground_(
              context,
              p1,
              p22,
              p32,
              p42,
              /** @type {Array<*>} */
              fillInstruction2,
              /** @type {Array<*>} */
              strokeInstruction2
            );
          }
          drawImageOrLabel(
            context,
            dimensions.canvasTransform,
            opacity,
            imageOrLabel,
            dimensions.originX,
            dimensions.originY,
            dimensions.drawImageW,
            dimensions.drawImageH,
            dimensions.drawImageX,
            dimensions.drawImageY,
            dimensions.scale
          );
        }
        return true;
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       */
      fill_(context) {
        const alignAndScale = this.alignAndScaleFill_;
        if (alignAndScale) {
          const origin = apply(this.renderedTransform_, [0, 0]);
          const repeatSize = 512 * this.pixelRatio;
          context.save();
          context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
          if (alignAndScale !== 1) {
            context.scale(alignAndScale, alignAndScale);
          }
          context.rotate(this.viewRotation_);
        }
        context.fill();
        if (alignAndScale) {
          context.restore();
        }
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {Array<*>} instruction Instruction.
       */
      setStrokeStyle_(context, instruction) {
        context.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
        instruction[1];
        if (!instruction[1]) {
          return;
        }
        context.lineWidth = /** @type {number} */
        instruction[2];
        context.lineCap = /** @type {CanvasLineCap} */
        instruction[3];
        context.lineJoin = /** @type {CanvasLineJoin} */
        instruction[4];
        context.miterLimit = /** @type {number} */
        instruction[5];
        context.lineDashOffset = /** @type {number} */
        instruction[7];
        context.setLineDash(
          /** @type {Array<number>} */
          instruction[6]
        );
      }
      /**
       * @private
       * @param {string|Array<string>} text The text to draw.
       * @param {string} textKey The key of the text state.
       * @param {string} strokeKey The key for the stroke state.
       * @param {string} fillKey The key for the fill state.
       * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
       */
      drawLabelWithPointPlacement_(text2, textKey, strokeKey, fillKey) {
        const textState = this.textStates[textKey];
        const label = this.createLabel(text2, textKey, fillKey, strokeKey);
        const strokeState = this.strokeStates[strokeKey];
        const pixelRatio = this.pixelRatio;
        const align = horizontalTextAlign(
          Array.isArray(text2) ? text2[0] : text2,
          textState.textAlign || defaultTextAlign
        );
        const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
        const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const width = label.width / pixelRatio - 2 * textState.scale[0];
        const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
        const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
        return {
          label,
          anchorX,
          anchorY
        };
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {Array<*>} instructions Instructions array.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {FeatureCallback<T>} [featureCallback] Feature callback.
       * @param {import("../../extent.js").Extent} [hitExtent] Only check
       *     features that intersect this extent.
       * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
       * @return {T|undefined} Callback result.
       * @template T
       */
      execute_(context, scaledCanvasSize, transform3, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
        const zIndexContext = this.zIndexContext_;
        let pixelCoordinates;
        if (this.pixelCoordinates_ && equals3(transform3, this.renderedTransform_)) {
          pixelCoordinates = this.pixelCoordinates_;
        } else {
          if (!this.pixelCoordinates_) {
            this.pixelCoordinates_ = [];
          }
          pixelCoordinates = transform2D(
            this.coordinates,
            0,
            this.coordinates.length,
            2,
            transform3,
            this.pixelCoordinates_
          );
          setFromArray(this.renderedTransform_, transform3);
        }
        let i7 = 0;
        const ii = instructions.length;
        let d2 = 0;
        let dd;
        let anchorX, anchorY, declutterMode, prevX, prevY, roundX, roundY, image, text2, textKey, strokeKey, fillKey;
        let pendingFill = 0;
        let pendingStroke = 0;
        const coordinateCache = this.coordinateCache_;
        const viewRotation = this.viewRotation_;
        const viewRotationFromTransform = Math.round(Math.atan2(-transform3[1], transform3[0]) * 1e12) / 1e12;
        const state = (
          /** @type {import("../../render.js").State} */
          {
            context,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: viewRotation
          }
        );
        const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        let feature;
        let x4, y5, currentGeometry;
        while (i7 < ii) {
          const instruction = instructions[i7];
          const type = (
            /** @type {import("./Instruction.js").default} */
            instruction[0]
          );
          switch (type) {
            case Instruction_default.BEGIN_GEOMETRY:
              feature = /** @type {import("../../Feature.js").FeatureLike} */
              instruction[1];
              currentGeometry = instruction[3];
              if (!feature.getGeometry()) {
                i7 = /** @type {number} */
                instruction[2];
              } else if (hitExtent !== void 0 && !intersects(hitExtent, currentGeometry.getExtent())) {
                i7 = /** @type {number} */
                instruction[2] + 1;
              } else {
                ++i7;
              }
              if (zIndexContext) {
                zIndexContext.zIndex = instruction[4];
              }
              break;
            case Instruction_default.BEGIN_PATH:
              if (pendingFill > batchSize) {
                this.fill_(context);
                pendingFill = 0;
              }
              if (pendingStroke > batchSize) {
                context.stroke();
                pendingStroke = 0;
              }
              if (!pendingFill && !pendingStroke) {
                context.beginPath();
                prevX = NaN;
                prevY = NaN;
              }
              ++i7;
              break;
            case Instruction_default.CIRCLE:
              d2 = /** @type {number} */
              instruction[1];
              const x1 = pixelCoordinates[d2];
              const y1 = pixelCoordinates[d2 + 1];
              const x22 = pixelCoordinates[d2 + 2];
              const y22 = pixelCoordinates[d2 + 3];
              const dx = x22 - x1;
              const dy = y22 - y1;
              const r5 = Math.sqrt(dx * dx + dy * dy);
              context.moveTo(x1 + r5, y1);
              context.arc(x1, y1, r5, 0, 2 * Math.PI, true);
              ++i7;
              break;
            case Instruction_default.CLOSE_PATH:
              context.closePath();
              ++i7;
              break;
            case Instruction_default.CUSTOM:
              d2 = /** @type {number} */
              instruction[1];
              dd = instruction[2];
              const geometry = (
                /** @type {import("../../geom/SimpleGeometry.js").default} */
                instruction[3]
              );
              const renderer = instruction[4];
              const fn4 = instruction[5];
              state.geometry = geometry;
              state.feature = feature;
              if (!(i7 in coordinateCache)) {
                coordinateCache[i7] = [];
              }
              const coords = coordinateCache[i7];
              if (fn4) {
                fn4(pixelCoordinates, d2, dd, 2, coords);
              } else {
                coords[0] = pixelCoordinates[d2];
                coords[1] = pixelCoordinates[d2 + 1];
                coords.length = 2;
              }
              if (zIndexContext) {
                zIndexContext.zIndex = instruction[6];
              }
              renderer(coords, state);
              ++i7;
              break;
            case Instruction_default.DRAW_IMAGE:
              d2 = /** @type {number} */
              instruction[1];
              dd = /** @type {number} */
              instruction[2];
              image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
              instruction[3];
              anchorX = /** @type {number} */
              instruction[4];
              anchorY = /** @type {number} */
              instruction[5];
              let height = (
                /** @type {number} */
                instruction[6]
              );
              const opacity = (
                /** @type {number} */
                instruction[7]
              );
              const originX = (
                /** @type {number} */
                instruction[8]
              );
              const originY = (
                /** @type {number} */
                instruction[9]
              );
              const rotateWithView = (
                /** @type {boolean} */
                instruction[10]
              );
              let rotation = (
                /** @type {number} */
                instruction[11]
              );
              const scale3 = (
                /** @type {import("../../size.js").Size} */
                instruction[12]
              );
              let width = (
                /** @type {number} */
                instruction[13]
              );
              declutterMode = instruction[14] || "declutter";
              const declutterImageWithText = (
                /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
                instruction[15]
              );
              if (!image && instruction.length >= 20) {
                text2 = /** @type {string} */
                instruction[19];
                textKey = /** @type {string} */
                instruction[20];
                strokeKey = /** @type {string} */
                instruction[21];
                fillKey = /** @type {string} */
                instruction[22];
                const labelWithAnchor = this.drawLabelWithPointPlacement_(
                  text2,
                  textKey,
                  strokeKey,
                  fillKey
                );
                image = labelWithAnchor.label;
                instruction[3] = image;
                const textOffsetX = (
                  /** @type {number} */
                  instruction[23]
                );
                anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                instruction[4] = anchorX;
                const textOffsetY = (
                  /** @type {number} */
                  instruction[24]
                );
                anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                instruction[5] = anchorY;
                height = image.height;
                instruction[6] = height;
                width = image.width;
                instruction[13] = width;
              }
              let geometryWidths;
              if (instruction.length > 25) {
                geometryWidths = /** @type {number} */
                instruction[25];
              }
              let padding, backgroundFillInstruction, backgroundStrokeInstruction;
              if (instruction.length > 17) {
                padding = /** @type {Array<number>} */
                instruction[16];
                backgroundFillInstruction = /** @type {Array<*>} */
                instruction[17];
                backgroundStrokeInstruction = /** @type {Array<*>} */
                instruction[18];
              } else {
                padding = defaultPadding;
                backgroundFillInstruction = null;
                backgroundStrokeInstruction = null;
              }
              if (rotateWithView && viewRotationFromTransform) {
                rotation += viewRotation;
              } else if (!rotateWithView && !viewRotationFromTransform) {
                rotation -= viewRotation;
              }
              let widthIndex = 0;
              for (; d2 < dd; d2 += 2) {
                if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                  continue;
                }
                const dimensions = this.calculateImageOrLabelDimensions_(
                  image.width,
                  image.height,
                  pixelCoordinates[d2],
                  pixelCoordinates[d2 + 1],
                  width,
                  height,
                  anchorX,
                  anchorY,
                  originX,
                  originY,
                  rotation,
                  scale3,
                  snapToPixel,
                  padding,
                  !!backgroundFillInstruction || !!backgroundStrokeInstruction,
                  feature
                );
                const args = [
                  context,
                  scaledCanvasSize,
                  image,
                  dimensions,
                  opacity,
                  backgroundFillInstruction,
                  backgroundStrokeInstruction
                ];
                if (declutterTree) {
                  let imageArgs, imageDeclutterMode, imageDeclutterBox;
                  if (declutterImageWithText) {
                    const index13 = dd - d2;
                    if (!declutterImageWithText[index13]) {
                      declutterImageWithText[index13] = { args, declutterMode };
                      continue;
                    }
                    const imageDeclutter = declutterImageWithText[index13];
                    imageArgs = imageDeclutter.args;
                    imageDeclutterMode = imageDeclutter.declutterMode;
                    delete declutterImageWithText[index13];
                    imageDeclutterBox = getDeclutterBox(imageArgs);
                  }
                  let renderImage, renderText;
                  if (imageArgs && (imageDeclutterMode !== "declutter" || !declutterTree.collides(imageDeclutterBox))) {
                    renderImage = true;
                  }
                  if (declutterMode !== "declutter" || !declutterTree.collides(dimensions.declutterBox)) {
                    renderText = true;
                  }
                  if (imageDeclutterMode === "declutter" && declutterMode === "declutter") {
                    const render = renderImage && renderText;
                    renderImage = render;
                    renderText = render;
                  }
                  if (renderImage) {
                    if (imageDeclutterMode !== "none") {
                      declutterTree.insert(imageDeclutterBox);
                    }
                    this.replayImageOrLabel_.apply(this, imageArgs);
                  }
                  if (renderText) {
                    if (declutterMode !== "none") {
                      declutterTree.insert(dimensions.declutterBox);
                    }
                    this.replayImageOrLabel_.apply(this, args);
                  }
                } else {
                  this.replayImageOrLabel_.apply(this, args);
                }
              }
              ++i7;
              break;
            case Instruction_default.DRAW_CHARS:
              const begin = (
                /** @type {number} */
                instruction[1]
              );
              const end = (
                /** @type {number} */
                instruction[2]
              );
              const baseline = (
                /** @type {number} */
                instruction[3]
              );
              const overflow = (
                /** @type {number} */
                instruction[4]
              );
              fillKey = /** @type {string} */
              instruction[5];
              const maxAngle = (
                /** @type {number} */
                instruction[6]
              );
              const measurePixelRatio = (
                /** @type {number} */
                instruction[7]
              );
              const offsetY = (
                /** @type {number} */
                instruction[8]
              );
              strokeKey = /** @type {string} */
              instruction[9];
              const strokeWidth = (
                /** @type {number} */
                instruction[10]
              );
              text2 = /** @type {string|Array<string>} */
              instruction[11];
              if (Array.isArray(text2)) {
                text2 = text2.reduce(richTextToPlainText, "");
              }
              textKey = /** @type {string} */
              instruction[12];
              const pixelRatioScale = [
                /** @type {number} */
                instruction[13],
                /** @type {number} */
                instruction[13]
              ];
              declutterMode = instruction[14] || "declutter";
              const textKeepUpright = (
                /** @type {boolean} */
                instruction[15]
              );
              const textState = this.textStates[textKey];
              const font = textState.font;
              const textScale = [
                textState.scale[0] * measurePixelRatio,
                textState.scale[1] * measurePixelRatio
              ];
              let cachedWidths;
              if (font in this.widths_) {
                cachedWidths = this.widths_[font];
              } else {
                cachedWidths = {};
                this.widths_[font] = cachedWidths;
              }
              const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
              const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text2, cachedWidths);
              if (overflow || textLength <= pathLength) {
                const textAlign = this.textStates[textKey].textAlign;
                const startM = (pathLength - textLength) * horizontalTextAlign(text2, textAlign);
                const parts = drawTextOnPath(
                  pixelCoordinates,
                  begin,
                  end,
                  2,
                  text2,
                  startM,
                  maxAngle,
                  Math.abs(textScale[0]),
                  measureAndCacheTextWidth,
                  font,
                  cachedWidths,
                  viewRotationFromTransform ? 0 : this.viewRotation_,
                  textKeepUpright
                );
                drawChars: if (parts) {
                  const replayImageOrLabelArgs = [];
                  let c7, cc2, chars2, label, part;
                  if (strokeKey) {
                    for (c7 = 0, cc2 = parts.length; c7 < cc2; ++c7) {
                      part = parts[c7];
                      chars2 = /** @type {string} */
                      part[4];
                      label = this.createLabel(chars2, textKey, "", strokeKey);
                      anchorX = /** @type {number} */
                      part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                      anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                      const dimensions = this.calculateImageOrLabelDimensions_(
                        label.width,
                        label.height,
                        part[0],
                        part[1],
                        label.width,
                        label.height,
                        anchorX,
                        anchorY,
                        0,
                        0,
                        part[3],
                        pixelRatioScale,
                        false,
                        defaultPadding,
                        false,
                        feature
                      );
                      if (declutterTree && declutterMode === "declutter" && declutterTree.collides(dimensions.declutterBox)) {
                        break drawChars;
                      }
                      replayImageOrLabelArgs.push([
                        context,
                        scaledCanvasSize,
                        label,
                        dimensions,
                        1,
                        null,
                        null
                      ]);
                    }
                  }
                  if (fillKey) {
                    for (c7 = 0, cc2 = parts.length; c7 < cc2; ++c7) {
                      part = parts[c7];
                      chars2 = /** @type {string} */
                      part[4];
                      label = this.createLabel(chars2, textKey, fillKey, "");
                      anchorX = /** @type {number} */
                      part[2];
                      anchorY = baseline * label.height - offsetY;
                      const dimensions = this.calculateImageOrLabelDimensions_(
                        label.width,
                        label.height,
                        part[0],
                        part[1],
                        label.width,
                        label.height,
                        anchorX,
                        anchorY,
                        0,
                        0,
                        part[3],
                        pixelRatioScale,
                        false,
                        defaultPadding,
                        false,
                        feature
                      );
                      if (declutterTree && declutterMode === "declutter" && declutterTree.collides(dimensions.declutterBox)) {
                        break drawChars;
                      }
                      replayImageOrLabelArgs.push([
                        context,
                        scaledCanvasSize,
                        label,
                        dimensions,
                        1,
                        null,
                        null
                      ]);
                    }
                  }
                  if (declutterTree && declutterMode !== "none") {
                    declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                  }
                  for (let i8 = 0, ii2 = replayImageOrLabelArgs.length; i8 < ii2; ++i8) {
                    this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i8]);
                  }
                }
              }
              ++i7;
              break;
            case Instruction_default.END_GEOMETRY:
              if (featureCallback !== void 0) {
                feature = /** @type {import("../../Feature.js").FeatureLike} */
                instruction[1];
                const result = featureCallback(
                  feature,
                  currentGeometry,
                  declutterMode
                );
                if (result) {
                  return result;
                }
              }
              ++i7;
              break;
            case Instruction_default.FILL:
              if (batchSize) {
                pendingFill++;
              } else {
                this.fill_(context);
              }
              ++i7;
              break;
            case Instruction_default.MOVE_TO_LINE_TO:
              d2 = /** @type {number} */
              instruction[1];
              dd = /** @type {number} */
              instruction[2];
              x4 = pixelCoordinates[d2];
              y5 = pixelCoordinates[d2 + 1];
              context.moveTo(x4, y5);
              prevX = x4 + 0.5 | 0;
              prevY = y5 + 0.5 | 0;
              for (d2 += 2; d2 < dd; d2 += 2) {
                x4 = pixelCoordinates[d2];
                y5 = pixelCoordinates[d2 + 1];
                roundX = x4 + 0.5 | 0;
                roundY = y5 + 0.5 | 0;
                if (d2 == dd - 2 || roundX !== prevX || roundY !== prevY) {
                  context.lineTo(x4, y5);
                  prevX = roundX;
                  prevY = roundY;
                }
              }
              ++i7;
              break;
            case Instruction_default.SET_FILL_STYLE:
              this.alignAndScaleFill_ = instruction[2];
              if (pendingFill) {
                this.fill_(context);
                pendingFill = 0;
                if (pendingStroke) {
                  context.stroke();
                  pendingStroke = 0;
                }
              }
              context.fillStyle = instruction[1];
              ++i7;
              break;
            case Instruction_default.SET_STROKE_STYLE:
              if (pendingStroke) {
                context.stroke();
                pendingStroke = 0;
              }
              this.setStrokeStyle_(
                context,
                /** @type {Array<*>} */
                instruction
              );
              ++i7;
              break;
            case Instruction_default.STROKE:
              if (batchSize) {
                pendingStroke++;
              } else {
                context.stroke();
              }
              ++i7;
              break;
            default:
              ++i7;
              break;
          }
        }
        if (pendingFill) {
          this.fill_(context);
        }
        if (pendingStroke) {
          context.stroke();
        }
        return void 0;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
       */
      execute(context, scaledCanvasSize, transform3, viewRotation, snapToPixel, declutterTree) {
        this.viewRotation_ = viewRotation;
        this.execute_(
          context,
          scaledCanvasSize,
          transform3,
          this.instructions,
          snapToPixel,
          void 0,
          void 0,
          declutterTree
        );
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {FeatureCallback<T>} [featureCallback] Feature callback.
       * @param {import("../../extent.js").Extent} [hitExtent] Only check
       *     features that intersect this extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      executeHitDetection(context, transform3, viewRotation, featureCallback, hitExtent) {
        this.viewRotation_ = viewRotation;
        return this.execute_(
          context,
          [context.canvas.width, context.canvas.height],
          transform3,
          this.hitDetectionInstructions,
          true,
          featureCallback,
          hitExtent
        );
      }
    };
    Executor_default = Executor;
  }
});

// node_modules/ol/render/canvas/ExecutorGroup.js
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== void 0) {
    return circlePixelIndexArrayCache[radius];
  }
  const size = radius * 2 + 1;
  const maxDistanceSq = radius * radius;
  const distances = new Array(maxDistanceSq + 1);
  for (let i7 = 0; i7 <= radius; ++i7) {
    for (let j6 = 0; j6 <= radius; ++j6) {
      const distanceSq = i7 * i7 + j6 * j6;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      let distance3 = distances[distanceSq];
      if (!distance3) {
        distance3 = [];
        distances[distanceSq] = distance3;
      }
      distance3.push(((radius + i7) * size + (radius + j6)) * 4 + 3);
      if (i7 > 0) {
        distance3.push(((radius - i7) * size + (radius + j6)) * 4 + 3);
      }
      if (j6 > 0) {
        distance3.push(((radius + i7) * size + (radius - j6)) * 4 + 3);
        if (i7 > 0) {
          distance3.push(((radius - i7) * size + (radius - j6)) * 4 + 3);
        }
      }
    }
  }
  const pixelIndex = [];
  for (let i7 = 0, ii = distances.length; i7 < ii; ++i7) {
    if (distances[i7]) {
      pixelIndex.push(...distances[i7]);
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
var ALL, DECLUTTER, NON_DECLUTTER, ExecutorGroup, circlePixelIndexArrayCache, ExecutorGroup_default;
var init_ExecutorGroup = __esm({
  "node_modules/ol/render/canvas/ExecutorGroup.js"() {
    init_array();
    init_dom();
    init_extent();
    init_transform2();
    init_obj();
    init_transform();
    init_Executor();
    ALL = [
      "Polygon",
      "Circle",
      "LineString",
      "Image",
      "Text",
      "Default"
    ];
    DECLUTTER = ["Image", "Text"];
    NON_DECLUTTER = ALL.filter(
      (builderType) => !DECLUTTER.includes(builderType)
    );
    ExecutorGroup = class {
      /**
       * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
       * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
       * should be set here, unless the target context does not exceed that extent (which
       * can be the case when rendering to tiles).
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The executor group can have overlapping geometries.
       * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
       * The serializable instructions.
       * @param {number} [renderBuffer] Optional rendering buffer.
       * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
       */
      constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer, deferredRendering) {
        this.maxExtent_ = maxExtent;
        this.overlaps_ = overlaps;
        this.pixelRatio_ = pixelRatio;
        this.resolution_ = resolution;
        this.renderBuffer_ = renderBuffer;
        this.executorsByZIndex_ = {};
        this.hitDetectionContext_ = null;
        this.hitDetectionTransform_ = create();
        this.renderedContext_ = null;
        this.deferredZIndexContexts_ = {};
        this.createExecutors_(allInstructions, deferredRendering);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      clip(context, transform3) {
        const flatClipCoords = this.getClipCoords(transform3);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
      }
      /**
       * Create executors and populate them using the provided instructions.
       * @private
       * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
       * @param {boolean} deferredRendering Enable deferred rendering.
       */
      createExecutors_(allInstructions, deferredRendering) {
        for (const zIndex in allInstructions) {
          let executors = this.executorsByZIndex_[zIndex];
          if (executors === void 0) {
            executors = {};
            this.executorsByZIndex_[zIndex] = executors;
          }
          const instructionByZindex = allInstructions[zIndex];
          for (const builderType in instructionByZindex) {
            const instructions = instructionByZindex[builderType];
            executors[builderType] = new Executor_default(
              this.resolution_,
              this.pixelRatio_,
              this.overlaps_,
              instructions,
              deferredRendering
            );
          }
        }
      }
      /**
       * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
       * @return {boolean} Has executors of the provided types.
       */
      hasExecutors(executors) {
        for (const zIndex in this.executorsByZIndex_) {
          const candidates = this.executorsByZIndex_[zIndex];
          for (let i7 = 0, ii = executors.length; i7 < ii; ++i7) {
            if (executors[i7] in candidates) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
       * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
        hitTolerance = Math.round(hitTolerance);
        const contextSize = hitTolerance * 2 + 1;
        const transform3 = compose(
          this.hitDetectionTransform_,
          hitTolerance + 0.5,
          hitTolerance + 0.5,
          1 / resolution,
          -1 / resolution,
          -rotation,
          -coordinate[0],
          -coordinate[1]
        );
        const newContext = !this.hitDetectionContext_;
        if (newContext) {
          this.hitDetectionContext_ = createCanvasContext2D(
            contextSize,
            contextSize
          );
        }
        const context = this.hitDetectionContext_;
        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
          context.canvas.width = contextSize;
          context.canvas.height = contextSize;
        } else if (!newContext) {
          context.clearRect(0, 0, contextSize, contextSize);
        }
        let hitExtent;
        if (this.renderBuffer_ !== void 0) {
          hitExtent = createEmpty();
          extendCoordinate(hitExtent, coordinate);
          buffer(
            hitExtent,
            resolution * (this.renderBuffer_ + hitTolerance),
            hitExtent
          );
        }
        const indexes = getPixelIndexArray(hitTolerance);
        let builderType;
        function featureCallback(feature, geometry, declutterMode) {
          const imageData = context.getImageData(
            0,
            0,
            contextSize,
            contextSize
          ).data;
          for (let i8 = 0, ii = indexes.length; i8 < ii; i8++) {
            if (imageData[indexes[i8]] > 0) {
              if (!declutteredFeatures || declutterMode === "none" || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.includes(feature)) {
                const idx = (indexes[i8] - 3) / 4;
                const x4 = hitTolerance - idx % contextSize;
                const y5 = hitTolerance - (idx / contextSize | 0);
                const result2 = callback(feature, geometry, x4 * x4 + y5 * y5);
                if (result2) {
                  return result2;
                }
              }
              context.clearRect(0, 0, contextSize, contextSize);
              break;
            }
          }
          return void 0;
        }
        const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(ascending);
        let i7, j6, executors, executor, result;
        for (i7 = zs.length - 1; i7 >= 0; --i7) {
          const zIndexKey = zs[i7].toString();
          executors = this.executorsByZIndex_[zIndexKey];
          for (j6 = ALL.length - 1; j6 >= 0; --j6) {
            builderType = ALL[j6];
            executor = executors[builderType];
            if (executor !== void 0) {
              result = executor.executeHitDetection(
                context,
                transform3,
                rotation,
                featureCallback,
                hitExtent
              );
              if (result) {
                return result;
              }
            }
          }
        }
        return void 0;
      }
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       * @return {Array<number>|null} Clip coordinates.
       */
      getClipCoords(transform3) {
        const maxExtent = this.maxExtent_;
        if (!maxExtent) {
          return null;
        }
        const minX = maxExtent[0];
        const minY = maxExtent[1];
        const maxX = maxExtent[2];
        const maxY = maxExtent[3];
        const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
        transform2D(flatClipCoords, 0, 8, 2, transform3, flatClipCoords);
        return flatClipCoords;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return isEmpty2(this.executorsByZIndex_);
      }
      /**
       * @param {CanvasRenderingContext2D} targetContext Context.
       * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
       * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
       *     Default is {@link module:ol/render/replay~ALL}
       * @param {import("rbush").default<import('./Executor.js').DeclutterEntry>|null} [declutterTree] Declutter tree.
       *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
       */
      execute(targetContext, scaledCanvasSize, transform3, viewRotation, snapToPixel, builderTypes, declutterTree) {
        const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(declutterTree ? descending : ascending);
        builderTypes = builderTypes ? builderTypes : ALL;
        const maxBuilderTypes = ALL.length;
        for (let i7 = 0, ii = zs.length; i7 < ii; ++i7) {
          const zIndexKey = zs[i7].toString();
          const replays = this.executorsByZIndex_[zIndexKey];
          for (let j6 = 0, jj = builderTypes.length; j6 < jj; ++j6) {
            const builderType = builderTypes[j6];
            const replay = replays[builderType];
            if (replay !== void 0) {
              const zIndexContext = declutterTree === null ? void 0 : replay.getZIndexContext();
              const context = zIndexContext ? zIndexContext.getContext() : targetContext;
              const requireClip = this.maxExtent_ && builderType !== "Image" && builderType !== "Text";
              if (requireClip) {
                context.save();
                this.clip(context, transform3);
              }
              if (!zIndexContext || builderType === "Text" || builderType === "Image") {
                replay.execute(
                  context,
                  scaledCanvasSize,
                  transform3,
                  viewRotation,
                  snapToPixel,
                  declutterTree
                );
              } else {
                zIndexContext.pushFunction(
                  (context2) => replay.execute(
                    context2,
                    scaledCanvasSize,
                    transform3,
                    viewRotation,
                    snapToPixel,
                    declutterTree
                  )
                );
              }
              if (requireClip) {
                context.restore();
              }
              if (zIndexContext) {
                zIndexContext.offset();
                const index13 = zs[i7] * maxBuilderTypes + ALL.indexOf(builderType);
                if (!this.deferredZIndexContexts_[index13]) {
                  this.deferredZIndexContexts_[index13] = [];
                }
                this.deferredZIndexContexts_[index13].push(zIndexContext);
              }
            }
          }
        }
        this.renderedContext_ = targetContext;
      }
      getDeferredZIndexContexts() {
        return this.deferredZIndexContexts_;
      }
      getRenderedContext() {
        return this.renderedContext_;
      }
      renderDeferred() {
        const deferredZIndexContexts = this.deferredZIndexContexts_;
        const zs = Object.keys(deferredZIndexContexts).map(Number).sort(ascending);
        for (let i7 = 0, ii = zs.length; i7 < ii; ++i7) {
          deferredZIndexContexts[zs[i7]].forEach((zIndexContext) => {
            zIndexContext.draw(this.renderedContext_);
            zIndexContext.clear();
          });
          deferredZIndexContexts[zs[i7]].length = 0;
        }
      }
    };
    circlePixelIndexArrayCache = {};
    ExecutorGroup_default = ExecutorGroup;
  }
});

// node_modules/ol/size.js
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}
var init_size = __esm({
  "node_modules/ol/size.js"() {
  }
});

// node_modules/ol/style/Image.js
var ImageStyle, Image_default;
var init_Image2 = __esm({
  "node_modules/ol/style/Image.js"() {
    init_size();
    init_util();
    ImageStyle = class _ImageStyle {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        this.opacity_ = options.opacity;
        this.rotateWithView_ = options.rotateWithView;
        this.rotation_ = options.rotation;
        this.scale_ = options.scale;
        this.scaleArray_ = toSize(options.scale);
        this.displacement_ = options.displacement;
        this.declutterMode_ = options.declutterMode;
      }
      /**
       * Clones the style.
       * @return {ImageStyle} The cloned style.
       * @api
       */
      clone() {
        const scale3 = this.getScale();
        return new _ImageStyle({
          opacity: this.getOpacity(),
          scale: Array.isArray(scale3) ? scale3.slice() : scale3,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the symbolizer opacity.
       * @return {number} Opacity.
       * @api
       */
      getOpacity() {
        return this.opacity_;
      }
      /**
       * Determine whether the symbolizer rotates with the map.
       * @return {boolean} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Get the symoblizer rotation.
       * @return {number} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the symbolizer scale.
       * @return {number|import("../size.js").Size} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the displacement of the shape
       * @return {Array<number>} Shape's center displacement
       * @api
       */
      getDisplacement() {
        return this.displacement_;
      }
      /**
       * Get the declutter mode of the shape
       * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
       * @api
       */
      getDeclutterMode() {
        return this.declutterMode_;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @abstract
       * @return {Array<number>} Anchor.
       */
      getAnchor() {
        return abstract();
      }
      /**
       * Get the image element for the symbolizer.
       * @abstract
       * @param {number} pixelRatio Pixel ratio.
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getImage(pixelRatio) {
        return abstract();
      }
      /**
       * @abstract
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getHitDetectionImage() {
        return abstract();
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       */
      getPixelRatio(pixelRatio) {
        return 1;
      }
      /**
       * @abstract
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return abstract();
      }
      /**
       * @abstract
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return abstract();
      }
      /**
       * Get the origin of the symbolizer.
       * @abstract
       * @return {Array<number>} Origin.
       */
      getOrigin() {
        return abstract();
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @abstract
       * @return {import("../size.js").Size} Size.
       */
      getSize() {
        return abstract();
      }
      /**
       * Set the displacement.
       *
       * @param {Array<number>} displacement Displacement.
       * @api
       */
      setDisplacement(displacement) {
        this.displacement_ = displacement;
      }
      /**
       * Set the opacity.
       *
       * @param {number} opacity Opacity.
       * @api
       */
      setOpacity(opacity) {
        this.opacity_ = opacity;
      }
      /**
       * Set whether to rotate the style with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set the rotation.
       *
       * @param {number} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      setScale(scale3) {
        this.scale_ = scale3;
        this.scaleArray_ = toSize(scale3);
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
        abstract();
      }
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      load() {
        abstract();
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
        abstract();
      }
      /**
       * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
       */
      ready() {
        return Promise.resolve();
      }
    };
    Image_default = ImageStyle;
  }
});

// node_modules/ol/style/RegularShape.js
var RegularShape, RegularShape_default;
var init_RegularShape = __esm({
  "node_modules/ol/style/RegularShape.js"() {
    init_ImageState();
    init_color();
    init_colorlike();
    init_dom();
    init_canvas();
    init_IconImage();
    init_IconImageCache();
    init_Image2();
    RegularShape = class _RegularShape extends Image_default {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        super({
          opacity: 1,
          rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          scale: options.scale !== void 0 ? options.scale : 1,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
        this.hitDetectionCanvas_ = null;
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.origin_ = [0, 0];
        this.points_ = options.points;
        this.radius = options.radius;
        this.radius2_ = options.radius2;
        this.angle_ = options.angle !== void 0 ? options.angle : 0;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.size_;
        this.renderOptions_;
        this.imageState_ = this.fill_ && this.fill_.loading() ? ImageState_default.LOADING : ImageState_default.LOADED;
        if (this.imageState_ === ImageState_default.LOADING) {
          this.ready().then(() => this.imageState_ = ImageState_default.LOADED);
        }
        this.render();
      }
      /**
       * Clones the style.
       * @return {RegularShape} The cloned style.
       * @api
       * @override
       */
      clone() {
        const scale3 = this.getScale();
        const style = new _RegularShape({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          points: this.getPoints(),
          radius: this.getRadius(),
          radius2: this.getRadius2(),
          angle: this.getAngle(),
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(scale3) ? scale3.slice() : scale3,
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       * @override
       */
      getAnchor() {
        const size = this.size_;
        const displacement = this.getDisplacement();
        const scale3 = this.getScaleArray();
        return [
          size[0] / 2 - displacement[0] / scale3[0],
          size[1] / 2 + displacement[1] / scale3[1]
        ];
      }
      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      getAngle() {
        return this.angle_;
      }
      /**
       * Get the fill style for the shape.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
        this.render();
      }
      /**
       * @return {HTMLCanvasElement} Image element.
       * @override
       */
      getHitDetectionImage() {
        if (!this.hitDetectionCanvas_) {
          this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
            this.renderOptions_
          );
        }
        return this.hitDetectionCanvas_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement} Image or Canvas element.
       * @api
       * @override
       */
      getImage(pixelRatio) {
        const fillKey = this.fill_?.getKey();
        const cacheKey = `${pixelRatio},${this.angle_},${this.radius},${this.radius2_},${this.points_},${fillKey}` + Object.values(this.renderOptions_).join(",");
        let image = (
          /** @type {HTMLCanvasElement} */
          shared.get(cacheKey, null, null)?.getImage(1)
        );
        if (!image) {
          const renderOptions = this.renderOptions_;
          const size = Math.ceil(renderOptions.size * pixelRatio);
          const context = createCanvasContext2D(size, size);
          this.draw_(renderOptions, context, pixelRatio);
          image = context.canvas;
          shared.set(
            cacheKey,
            null,
            null,
            new IconImage_default(image, void 0, null, ImageState_default.LOADED, null)
          );
        }
        return image;
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       * @override
       */
      getPixelRatio(pixelRatio) {
        return pixelRatio;
      }
      /**
       * @return {import("../size.js").Size} Image size.
       * @override
       */
      getImageSize() {
        return this.size_;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       * @override
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       * @override
       */
      getOrigin() {
        return this.origin_;
      }
      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      getPoints() {
        return this.points_;
      }
      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      getRadius() {
        return this.radius;
      }
      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      getRadius2() {
        return this.radius2_;
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @return {import("../size.js").Size} Size.
       * @api
       * @override
       */
      getSize() {
        return this.size_;
      }
      /**
       * Get the stroke style for the shape.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
        this.render();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       * @override
       */
      listenImageChange(listener) {
      }
      /**
       * Load not yet loaded URI.
       * @override
       */
      load() {
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       * @override
       */
      unlistenImageChange(listener) {
      }
      /**
       * Calculate additional canvas size needed for the miter.
       * @param {string} lineJoin Line join
       * @param {number} strokeWidth Stroke width
       * @param {number} miterLimit Miter limit
       * @return {number} Additional canvas size needed
       * @private
       */
      calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
          return strokeWidth;
        }
        let r1 = this.radius;
        let r23 = this.radius2_ === void 0 ? r1 : this.radius2_;
        if (r1 < r23) {
          const tmp = r1;
          r1 = r23;
          r23 = tmp;
        }
        const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
        const alpha = 2 * Math.PI / points;
        const a5 = r23 * Math.sin(alpha);
        const b8 = Math.sqrt(r23 * r23 - a5 * a5);
        const d2 = r1 - b8;
        const e3 = Math.sqrt(a5 * a5 + d2 * d2);
        const miterRatio = e3 / a5;
        if (lineJoin === "miter" && miterRatio <= miterLimit) {
          return miterRatio * strokeWidth;
        }
        const k5 = strokeWidth / 2 / miterRatio;
        const l7 = strokeWidth / 2 * (d2 / e3);
        const maxr = Math.sqrt((r1 + k5) * (r1 + k5) + l7 * l7);
        const bevelAdd = maxr - r1;
        if (this.radius2_ === void 0 || lineJoin === "bevel") {
          return bevelAdd * 2;
        }
        const aa2 = r1 * Math.sin(alpha);
        const bb2 = Math.sqrt(r1 * r1 - aa2 * aa2);
        const dd = r23 - bb2;
        const ee3 = Math.sqrt(aa2 * aa2 + dd * dd);
        const innerMiterRatio = ee3 / aa2;
        if (innerMiterRatio <= miterLimit) {
          const innerLength = innerMiterRatio * strokeWidth / 2 - r23 - r1;
          return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
      }
      /**
       * @return {RenderOptions}  The render options
       * @protected
       */
      createRenderOptions() {
        let lineCap = defaultLineCap;
        let lineJoin = defaultLineJoin;
        let miterLimit = 0;
        let lineDash = null;
        let lineDashOffset = 0;
        let strokeStyle;
        let strokeWidth = 0;
        if (this.stroke_) {
          strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);
          strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;
          lineDash = this.stroke_.getLineDash();
          lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
          lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;
          lineCap = this.stroke_.getLineCap() ?? defaultLineCap;
          miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;
        }
        const add5 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        const maxRadius = Math.max(this.radius, this.radius2_ || 0);
        const size = Math.ceil(2 * maxRadius + add5);
        return {
          strokeStyle,
          strokeWidth,
          size,
          lineCap,
          lineDash,
          lineDashOffset,
          lineJoin,
          miterLimit
        };
      }
      /**
       * @protected
       */
      render() {
        this.renderOptions_ = this.createRenderOptions();
        const size = this.renderOptions_.size;
        this.hitDetectionCanvas_ = null;
        this.size_ = [size, size];
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} pixelRatio The pixel ratio.
       */
      draw_(renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
          let color = this.fill_.getColor();
          if (color === null) {
            color = defaultFillStyle;
          }
          context.fillStyle = asColorLike(color);
          context.fill();
        }
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineCap = renderOptions.lineCap;
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @return {HTMLCanvasElement} Canvas containing the icon
       */
      createHitDetectionCanvas_(renderOptions) {
        let context;
        if (this.fill_) {
          let color = this.fill_.getColor();
          let opacity = 0;
          if (typeof color === "string") {
            color = asArray(color);
          }
          if (color === null) {
            opacity = 1;
          } else if (Array.isArray(color)) {
            opacity = color.length === 4 ? color[3] : 1;
          }
          if (opacity === 0) {
            context = createCanvasContext2D(renderOptions.size, renderOptions.size);
            this.drawHitDetectionCanvas_(renderOptions, context);
          }
        }
        return context ? context.canvas : this.getImage(1);
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context The context to draw in.
       */
      createPath_(context) {
        let points = this.points_;
        const radius = this.radius;
        if (points === Infinity) {
          context.arc(0, 0, radius, 0, 2 * Math.PI);
        } else {
          const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
          if (this.radius2_ !== void 0) {
            points *= 2;
          }
          const startAngle = this.angle_ - Math.PI / 2;
          const step = 2 * Math.PI / points;
          for (let i7 = 0; i7 < points; i7++) {
            const angle0 = startAngle + i7 * step;
            const radiusC = i7 % 2 === 0 ? radius : radius2;
            context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
          }
          context.closePath();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       */
      drawHitDetectionCanvas_(renderOptions, context) {
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = defaultFillStyle;
        context.fill();
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
      /**
       * @override
       */
      ready() {
        return this.fill_ ? this.fill_.ready() : Promise.resolve();
      }
    };
    RegularShape_default = RegularShape;
  }
});

// node_modules/ol/style/Circle.js
var CircleStyle, Circle_default2;
var init_Circle2 = __esm({
  "node_modules/ol/style/Circle.js"() {
    init_RegularShape();
    CircleStyle = class _CircleStyle extends RegularShape_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options ? options : { radius: 5 };
        super({
          points: Infinity,
          fill: options.fill,
          radius: options.radius,
          stroke: options.stroke,
          scale: options.scale !== void 0 ? options.scale : 1,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
      }
      /**
       * Clones the style.
       * @return {CircleStyle} The cloned style.
       * @api
       * @override
       */
      clone() {
        const scale3 = this.getScale();
        const style = new _CircleStyle({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          radius: this.getRadius(),
          scale: Array.isArray(scale3) ? scale3.slice() : scale3,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Set the circle radius.
       *
       * @param {number} radius Circle radius.
       * @api
       */
      setRadius(radius) {
        this.radius = radius;
        this.render();
      }
    };
    Circle_default2 = CircleStyle;
  }
});

// node_modules/ol/style/Fill.js
var Fill, Fill_default;
var init_Fill = __esm({
  "node_modules/ol/style/Fill.js"() {
    init_ImageState();
    init_color();
    init_util();
    init_IconImage();
    Fill = class _Fill {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.patternImage_ = null;
        this.color_ = null;
        if (options.color !== void 0) {
          this.setColor(options.color);
        }
      }
      /**
       * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
       * @return {Fill} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Fill({
          color: Array.isArray(color) ? color.slice() : color || void 0
        });
      }
      /**
       * Get the fill color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
       * @api
       */
      setColor(color) {
        if (color !== null && typeof color === "object" && "src" in color) {
          const patternImage = get5(
            null,
            color.src,
            "anonymous",
            void 0,
            color.offset ? null : color.color ? color.color : null,
            !(color.offset && color.size)
          );
          patternImage.ready().then(() => {
            this.patternImage_ = null;
          });
          if (patternImage.getImageState() === ImageState_default.IDLE) {
            patternImage.load();
          }
          if (patternImage.getImageState() === ImageState_default.LOADING) {
            this.patternImage_ = patternImage;
          }
        }
        this.color_ = color;
      }
      /**
       * @return {string} Key of the fill for cache lookup.
       */
      getKey() {
        const fill = this.getColor();
        if (!fill) {
          return "";
        }
        return fill instanceof CanvasPattern || fill instanceof CanvasGradient ? getUid(fill) : typeof fill === "object" && "src" in fill ? fill.src + ":" + fill.offset : asArray(fill).toString();
      }
      /**
       * @return {boolean} The fill style is loading an image pattern.
       */
      loading() {
        return !!this.patternImage_;
      }
      /**
       * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
       */
      ready() {
        return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
      }
    };
    Fill_default = Fill;
  }
});

// node_modules/ol/style/Icon.js
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== void 0 && wantedHeight !== void 0) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== void 0) {
    return wantedWidth / width;
  }
  if (wantedHeight !== void 0) {
    return wantedHeight / height;
  }
  return 1;
}
var Icon, Icon_default;
var init_Icon = __esm({
  "node_modules/ol/style/Icon.js"() {
    init_ImageState();
    init_asserts();
    init_color();
    init_EventType();
    init_util();
    init_IconImage();
    init_Image2();
    Icon = class _Icon extends Image_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        const opacity = options.opacity !== void 0 ? options.opacity : 1;
        const rotation = options.rotation !== void 0 ? options.rotation : 0;
        const scale3 = options.scale !== void 0 ? options.scale : 1;
        const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
        super({
          opacity,
          rotation,
          scale: scale3,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          rotateWithView,
          declutterMode: options.declutterMode
        });
        this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
        this.normalizedAnchor_ = null;
        this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
        this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
        this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
        this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
        const image = options.img !== void 0 ? options.img : null;
        let cacheKey = options.src;
        assert(
          !(cacheKey !== void 0 && image),
          "`image` and `src` cannot be provided at the same time"
        );
        if ((cacheKey === void 0 || cacheKey.length === 0) && image) {
          cacheKey = /** @type {HTMLImageElement} */
          image.src || getUid(image);
        }
        assert(
          cacheKey !== void 0 && cacheKey.length > 0,
          "A defined and non-empty `src` or `image` must be provided"
        );
        assert(
          !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
          "`width` or `height` cannot be provided together with `scale`"
        );
        let imageState;
        if (options.src !== void 0) {
          imageState = ImageState_default.IDLE;
        } else if (image !== void 0) {
          if ("complete" in image) {
            if (image.complete) {
              imageState = image.src ? ImageState_default.LOADED : ImageState_default.IDLE;
            } else {
              imageState = ImageState_default.LOADING;
            }
          } else {
            imageState = ImageState_default.LOADED;
          }
        }
        this.color_ = options.color !== void 0 ? asArray(options.color) : null;
        this.iconImage_ = get5(
          image,
          /** @type {string} */
          cacheKey,
          this.crossOrigin_,
          imageState,
          this.color_
        );
        this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
        this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
        this.origin_ = null;
        this.size_ = options.size !== void 0 ? options.size : null;
        this.initialOptions_;
        if (options.width !== void 0 || options.height !== void 0) {
          let width, height;
          if (options.size) {
            [width, height] = options.size;
          } else {
            const image2 = this.getImage(1);
            if (image2.width && image2.height) {
              width = image2.width;
              height = image2.height;
            } else if (image2 instanceof HTMLImageElement) {
              this.initialOptions_ = options;
              const onload = () => {
                this.unlistenImageChange(onload);
                if (!this.initialOptions_) {
                  return;
                }
                const imageSize = this.iconImage_.getSize();
                this.setScale(
                  calculateScale(
                    imageSize[0],
                    imageSize[1],
                    options.width,
                    options.height
                  )
                );
              };
              this.listenImageChange(onload);
              return;
            }
          }
          if (width !== void 0) {
            this.setScale(
              calculateScale(width, height, options.width, options.height)
            );
          }
        }
      }
      /**
       * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
       * @return {Icon} The cloned style.
       * @api
       * @override
       */
      clone() {
        let scale3, width, height;
        if (this.initialOptions_) {
          width = this.initialOptions_.width;
          height = this.initialOptions_.height;
        } else {
          scale3 = this.getScale();
          scale3 = Array.isArray(scale3) ? scale3.slice() : scale3;
        }
        return new _Icon({
          anchor: this.anchor_.slice(),
          anchorOrigin: this.anchorOrigin_,
          anchorXUnits: this.anchorXUnits_,
          anchorYUnits: this.anchorYUnits_,
          color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
          crossOrigin: this.crossOrigin_,
          offset: this.offset_.slice(),
          offsetOrigin: this.offsetOrigin_,
          opacity: this.getOpacity(),
          rotateWithView: this.getRotateWithView(),
          rotation: this.getRotation(),
          scale: scale3,
          width,
          height,
          size: this.size_ !== null ? this.size_.slice() : void 0,
          src: this.getSrc(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       * @override
       */
      getAnchor() {
        let anchor = this.normalizedAnchor_;
        if (!anchor) {
          anchor = this.anchor_;
          const size = this.getSize();
          if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
            if (!size) {
              return null;
            }
            anchor = this.anchor_.slice();
            if (this.anchorXUnits_ == "fraction") {
              anchor[0] *= size[0];
            }
            if (this.anchorYUnits_ == "fraction") {
              anchor[1] *= size[1];
            }
          }
          if (this.anchorOrigin_ != "top-left") {
            if (!size) {
              return null;
            }
            if (anchor === this.anchor_) {
              anchor = this.anchor_.slice();
            }
            if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
              anchor[0] = -anchor[0] + size[0];
            }
            if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
              anchor[1] = -anchor[1] + size[1];
            }
          }
          this.normalizedAnchor_ = anchor;
        }
        const displacement = this.getDisplacement();
        const scale3 = this.getScaleArray();
        return [
          anchor[0] - displacement[0] / scale3[0],
          anchor[1] + displacement[1] / scale3[1]
        ];
      }
      /**
       * Set the anchor point. The anchor determines the center point for the
       * symbolizer.
       *
       * @param {Array<number>} anchor Anchor.
       * @api
       */
      setAnchor(anchor) {
        this.anchor_ = anchor;
        this.normalizedAnchor_ = null;
      }
      /**
       * Get the icon color.
       * @return {import("../color.js").Color} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
       * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
       * @api
       * @override
       */
      getImage(pixelRatio) {
        return this.iconImage_.getImage(pixelRatio);
      }
      /**
       * Get the pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} The pixel ratio of the image.
       * @api
       * @override
       */
      getPixelRatio(pixelRatio) {
        return this.iconImage_.getPixelRatio(pixelRatio);
      }
      /**
       * @return {import("../size.js").Size} Image size.
       * @override
       */
      getImageSize() {
        return this.iconImage_.getSize();
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       * @override
       */
      getImageState() {
        return this.iconImage_.getImageState();
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       * @override
       */
      getHitDetectionImage() {
        return this.iconImage_.getHitDetectionImage();
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       * @override
       */
      getOrigin() {
        if (this.origin_) {
          return this.origin_;
        }
        let offset = this.offset_;
        if (this.offsetOrigin_ != "top-left") {
          const size = this.getSize();
          const iconImageSize = this.iconImage_.getSize();
          if (!size || !iconImageSize) {
            return null;
          }
          offset = offset.slice();
          if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
            offset[0] = iconImageSize[0] - size[0] - offset[0];
          }
          if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
            offset[1] = iconImageSize[1] - size[1] - offset[1];
          }
        }
        this.origin_ = offset;
        return this.origin_;
      }
      /**
       * Get the image URL.
       * @return {string|undefined} Image src.
       * @api
       */
      getSrc() {
        return this.iconImage_.getSrc();
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       * @api
       * @override
       */
      getSize() {
        return !this.size_ ? this.iconImage_.getSize() : this.size_;
      }
      /**
       * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
       * @return {number} Icon width (in pixels).
       * @api
       */
      getWidth() {
        const scale3 = this.getScaleArray();
        if (this.size_) {
          return this.size_[0] * scale3[0];
        }
        if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
          return this.iconImage_.getSize()[0] * scale3[0];
        }
        return void 0;
      }
      /**
       * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
       * @return {number} Icon height (in pixels).
       * @api
       */
      getHeight() {
        const scale3 = this.getScaleArray();
        if (this.size_) {
          return this.size_[1] * scale3[1];
        }
        if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
          return this.iconImage_.getSize()[1] * scale3[1];
        }
        return void 0;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       * @override
       */
      setScale(scale3) {
        delete this.initialOptions_;
        super.setScale(scale3);
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       * @override
       */
      listenImageChange(listener) {
        this.iconImage_.addEventListener(EventType_default.CHANGE, listener);
      }
      /**
       * Load not yet loaded URI.
       * When rendering a feature with an icon style, the vector renderer will
       * automatically call this method. However, you might want to call this
       * method yourself for preloading or other purposes.
       * @api
       * @override
       */
      load() {
        this.iconImage_.load();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       * @override
       */
      unlistenImageChange(listener) {
        this.iconImage_.removeEventListener(EventType_default.CHANGE, listener);
      }
      /**
       * @override
       */
      ready() {
        return this.iconImage_.ready();
      }
    };
    Icon_default = Icon;
  }
});

// node_modules/ol/style/Stroke.js
var Stroke, Stroke_default;
var init_Stroke = __esm({
  "node_modules/ol/style/Stroke.js"() {
    Stroke = class _Stroke {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.color_ = options.color !== void 0 ? options.color : null;
        this.lineCap_ = options.lineCap;
        this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
        this.lineDashOffset_ = options.lineDashOffset;
        this.lineJoin_ = options.lineJoin;
        this.miterLimit_ = options.miterLimit;
        this.width_ = options.width;
      }
      /**
       * Clones the style.
       * @return {Stroke} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Stroke({
          color: Array.isArray(color) ? color.slice() : color || void 0,
          lineCap: this.getLineCap(),
          lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
          lineDashOffset: this.getLineDashOffset(),
          lineJoin: this.getLineJoin(),
          miterLimit: this.getMiterLimit(),
          width: this.getWidth()
        });
      }
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */
      getLineCap() {
        return this.lineCap_;
      }
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>|null} Line dash.
       * @api
       */
      getLineDash() {
        return this.lineDash_;
      }
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */
      getLineDashOffset() {
        return this.lineDashOffset_;
      }
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */
      getLineJoin() {
        return this.lineJoin_;
      }
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */
      getMiterLimit() {
        return this.miterLimit_;
      }
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */
      getWidth() {
        return this.width_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      setColor(color) {
        this.color_ = color;
      }
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */
      setLineCap(lineCap) {
        this.lineCap_ = lineCap;
      }
      /**
       * Set the line dash.
       *
       * @param {Array<number>|null} lineDash Line dash.
       * @api
       */
      setLineDash(lineDash) {
        this.lineDash_ = lineDash;
      }
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */
      setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
      }
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */
      setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
      }
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */
      setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
      }
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */
      setWidth(width) {
        this.width_ = width;
      }
    };
    Stroke_default = Stroke;
  }
});

// node_modules/ol/style/Style.js
function toFunction(obj) {
  let styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(
        typeof /** @type {?} */
        obj.getZIndex === "function",
        "Expected an `Style` or an array of `Style`"
      );
      const style = (
        /** @type {Style} */
        obj
      );
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill_default({
      color: "rgba(255,255,255,0.4)"
    });
    const stroke = new Stroke_default({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new Circle_default2({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function createEditingStyle() {
  const styles = {};
  const white2 = [255, 255, 255, 1];
  const blue2 = [0, 153, 255, 1];
  const width = 3;
  styles["Polygon"] = [
    new Style({
      fill: new Fill_default({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles["MultiPolygon"] = styles["Polygon"];
  styles["LineString"] = [
    new Style({
      stroke: new Stroke_default({
        color: white2,
        width: width + 2
      })
    }),
    new Style({
      stroke: new Stroke_default({
        color: blue2,
        width
      })
    })
  ];
  styles["MultiLineString"] = styles["LineString"];
  styles["Circle"] = styles["Polygon"].concat(styles["LineString"]);
  styles["Point"] = [
    new Style({
      image: new Circle_default2({
        radius: width * 2,
        fill: new Fill_default({
          color: blue2
        }),
        stroke: new Stroke_default({
          color: white2,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles["MultiPoint"] = styles["Point"];
  styles["GeometryCollection"] = styles["Polygon"].concat(
    styles["LineString"],
    styles["Point"]
  );
  return styles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style, defaultStyles, Style_default;
var init_Style = __esm({
  "node_modules/ol/style/Style.js"() {
    init_asserts();
    init_Circle2();
    init_Fill();
    init_Stroke();
    Style = class _Style {
      /**
       * @param {Options} [options] Style options.
       */
      constructor(options) {
        options = options || {};
        this.geometry_ = null;
        this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== void 0) {
          this.setGeometry(options.geometry);
        }
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.image_ = options.image !== void 0 ? options.image : null;
        this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
        this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.text_ = options.text !== void 0 ? options.text : null;
        this.zIndex_ = options.zIndex;
      }
      /**
       * Clones the style.
       * @return {Style} The cloned style.
       * @api
       */
      clone() {
        let geometry = this.getGeometry();
        if (geometry && typeof geometry === "object") {
          geometry = /** @type {import("../geom/Geometry.js").default} */
          geometry.clone();
        }
        return new _Style({
          geometry: geometry ?? void 0,
          fill: this.getFill() ? this.getFill().clone() : void 0,
          image: this.getImage() ? this.getImage().clone() : void 0,
          renderer: this.getRenderer() ?? void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          text: this.getText() ? this.getText().clone() : void 0,
          zIndex: this.getZIndex()
        });
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setRenderer} or the `renderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getRenderer() {
        return this.renderer_;
      }
      /**
       * Sets a custom renderer function for this style. When set, `fill`, `stroke`
       * and `image` options of the style will be ignored.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setRenderer(renderer) {
        this.renderer_ = renderer;
      }
      /**
       * Sets a custom renderer function for this style used
       * in hit detection.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setHitDetectionRenderer(renderer) {
        this.hitDetectionRenderer_ = renderer;
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
      }
      /**
       * Get the geometry to be rendered.
       * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
       * Feature property or geometry or function that returns the geometry that will
       * be rendered with this style.
       * @api
       */
      getGeometry() {
        return this.geometry_;
      }
      /**
       * Get the function used to generate a geometry for rendering.
       * @return {!GeometryFunction} Function that is called with a feature
       * and returns the geometry to render instead of the feature's geometry.
       * @api
       */
      getGeometryFunction() {
        return this.geometryFunction_;
      }
      /**
       * Get the fill style.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Get the image style.
       * @return {import("./Image.js").default|null} Image style.
       * @api
       */
      getImage() {
        return this.image_;
      }
      /**
       * Set the image style.
       * @param {import("./Image.js").default} image Image style.
       * @api
       */
      setImage(image) {
        this.image_ = image;
      }
      /**
       * Get the stroke style.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Get the text style.
       * @return {import("./Text.js").default|null} Text style.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Set the text style.
       * @param {import("./Text.js").default} text Text style.
       * @api
       */
      setText(text2) {
        this.text_ = text2;
      }
      /**
       * Get the z-index for the style.
       * @return {number|undefined} ZIndex.
       * @api
       */
      getZIndex() {
        return this.zIndex_;
      }
      /**
       * Set a geometry that is rendered instead of the feature's geometry.
       *
       * @param {string|import("../geom/Geometry.js").default|GeometryFunction|null} geometry
       *     Feature property or geometry or function returning a geometry to render
       *     for this style.
       * @api
       */
      setGeometry(geometry) {
        if (typeof geometry === "function") {
          this.geometryFunction_ = geometry;
        } else if (typeof geometry === "string") {
          this.geometryFunction_ = function(feature) {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              feature.get(geometry)
            );
          };
        } else if (!geometry) {
          this.geometryFunction_ = defaultGeometryFunction;
        } else if (geometry !== void 0) {
          this.geometryFunction_ = function() {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              geometry
            );
          };
        }
        this.geometry_ = geometry;
      }
      /**
       * Set the z-index.
       *
       * @param {number|undefined} zIndex ZIndex.
       * @api
       */
      setZIndex(zIndex) {
        this.zIndex_ = zIndex;
      }
    };
    defaultStyles = null;
    Style_default = Style;
  }
});

// node_modules/ol/style/Text.js
var DEFAULT_FILL_COLOR, Text2, Text_default;
var init_Text = __esm({
  "node_modules/ol/style/Text.js"() {
    init_size();
    init_Fill();
    DEFAULT_FILL_COLOR = "#333";
    Text2 = class _Text {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.font_ = options.font;
        this.rotation_ = options.rotation;
        this.rotateWithView_ = options.rotateWithView;
        this.keepUpright_ = options.keepUpright;
        this.scale_ = options.scale;
        this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
        this.text_ = options.text;
        this.textAlign_ = options.textAlign;
        this.justify_ = options.justify;
        this.repeat_ = options.repeat;
        this.textBaseline_ = options.textBaseline;
        this.fill_ = options.fill !== void 0 ? options.fill : new Fill_default({ color: DEFAULT_FILL_COLOR });
        this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
        this.placement_ = options.placement !== void 0 ? options.placement : "point";
        this.overflow_ = !!options.overflow;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
        this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
        this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
        this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
        this.padding_ = options.padding === void 0 ? null : options.padding;
        this.declutterMode_ = options.declutterMode;
      }
      /**
       * Clones the style.
       * @return {Text} The cloned style.
       * @api
       */
      clone() {
        const scale3 = this.getScale();
        return new _Text({
          font: this.getFont(),
          placement: this.getPlacement(),
          repeat: this.getRepeat(),
          maxAngle: this.getMaxAngle(),
          overflow: this.getOverflow(),
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          keepUpright: this.getKeepUpright(),
          scale: Array.isArray(scale3) ? scale3.slice() : scale3,
          text: this.getText(),
          textAlign: this.getTextAlign(),
          justify: this.getJustify(),
          textBaseline: this.getTextBaseline(),
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          offsetX: this.getOffsetX(),
          offsetY: this.getOffsetY(),
          backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
          backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
          padding: this.getPadding() || void 0,
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the `overflow` configuration.
       * @return {boolean} Let text overflow the length of the path they follow.
       * @api
       */
      getOverflow() {
        return this.overflow_;
      }
      /**
       * Get the font name.
       * @return {string|undefined} Font.
       * @api
       */
      getFont() {
        return this.font_;
      }
      /**
       * Get the maximum angle between adjacent characters.
       * @return {number} Angle in radians.
       * @api
       */
      getMaxAngle() {
        return this.maxAngle_;
      }
      /**
       * Get the label placement.
       * @return {TextPlacement} Text placement.
       * @api
       */
      getPlacement() {
        return this.placement_;
      }
      /**
       * Get the repeat interval of the text.
       * @return {number|undefined} Repeat interval in pixels.
       * @api
       */
      getRepeat() {
        return this.repeat_;
      }
      /**
       * Get the x-offset for the text.
       * @return {number} Horizontal text offset.
       * @api
       */
      getOffsetX() {
        return this.offsetX_;
      }
      /**
       * Get the y-offset for the text.
       * @return {number} Vertical text offset.
       * @api
       */
      getOffsetY() {
        return this.offsetY_;
      }
      /**
       * Get the fill style for the text.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Determine whether the text rotates with the map.
       * @return {boolean|undefined} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Determine whether the text can be rendered upside down.
       * @return {boolean|undefined} Keep text upright.
       * @api
       */
      getKeepUpright() {
        return this.keepUpright_;
      }
      /**
       * Get the text rotation.
       * @return {number|undefined} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the text scale.
       * @return {number|import("../size.js").Size|undefined} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the stroke style for the text.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Get the text to be rendered.
       * @return {string|Array<string>|undefined} Text.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Get the text alignment.
       * @return {CanvasTextAlign|undefined} Text align.
       * @api
       */
      getTextAlign() {
        return this.textAlign_;
      }
      /**
       * Get the justification.
       * @return {TextJustify|undefined} Justification.
       * @api
       */
      getJustify() {
        return this.justify_;
      }
      /**
       * Get the text baseline.
       * @return {CanvasTextBaseline|undefined} Text baseline.
       * @api
       */
      getTextBaseline() {
        return this.textBaseline_;
      }
      /**
       * Get the background fill style for the text.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getBackgroundFill() {
        return this.backgroundFill_;
      }
      /**
       * Get the background stroke style for the text.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getBackgroundStroke() {
        return this.backgroundStroke_;
      }
      /**
       * Get the padding for the text.
       * @return {Array<number>|null} Padding.
       * @api
       */
      getPadding() {
        return this.padding_;
      }
      /**
       * Get the declutter mode of the shape
       * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
       * @api
       */
      getDeclutterMode() {
        return this.declutterMode_;
      }
      /**
       * Set the `overflow` property.
       *
       * @param {boolean} overflow Let text overflow the path that it follows.
       * @api
       */
      setOverflow(overflow) {
        this.overflow_ = overflow;
      }
      /**
       * Set the font.
       *
       * @param {string|undefined} font Font.
       * @api
       */
      setFont(font) {
        this.font_ = font;
      }
      /**
       * Set the maximum angle between adjacent characters.
       *
       * @param {number} maxAngle Angle in radians.
       * @api
       */
      setMaxAngle(maxAngle) {
        this.maxAngle_ = maxAngle;
      }
      /**
       * Set the x offset.
       *
       * @param {number} offsetX Horizontal text offset.
       * @api
       */
      setOffsetX(offsetX) {
        this.offsetX_ = offsetX;
      }
      /**
       * Set the y offset.
       *
       * @param {number} offsetY Vertical text offset.
       * @api
       */
      setOffsetY(offsetY) {
        this.offsetY_ = offsetY;
      }
      /**
       * Set the text placement.
       *
       * @param {TextPlacement} placement Placement.
       * @api
       */
      setPlacement(placement) {
        this.placement_ = placement;
      }
      /**
       * Set the repeat interval of the text.
       * @param {number|undefined} [repeat] Repeat interval in pixels.
       * @api
       */
      setRepeat(repeat) {
        this.repeat_ = repeat;
      }
      /**
       * Set whether to rotate the text with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set whether the text can be rendered upside down.
       *
       * @param {boolean} keepUpright Keep text upright.
       * @api
       */
      setKeepUpright(keepUpright) {
        this.keepUpright_ = keepUpright;
      }
      /**
       * Set the fill.
       *
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Set the rotation.
       *
       * @param {number|undefined} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size|undefined} scale Scale.
       * @api
       */
      setScale(scale3) {
        this.scale_ = scale3;
        this.scaleArray_ = toSize(scale3 !== void 0 ? scale3 : 1);
      }
      /**
       * Set the stroke.
       *
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Set the text.
       *
       * @param {string|Array<string>|undefined} text Text.
       * @api
       */
      setText(text2) {
        this.text_ = text2;
      }
      /**
       * Set the text alignment.
       *
       * @param {CanvasTextAlign|undefined} textAlign Text align.
       * @api
       */
      setTextAlign(textAlign) {
        this.textAlign_ = textAlign;
      }
      /**
       * Set the justification.
       *
       * @param {TextJustify|undefined} justify Justification.
       * @api
       */
      setJustify(justify) {
        this.justify_ = justify;
      }
      /**
       * Set the text baseline.
       *
       * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
       * @api
       */
      setTextBaseline(textBaseline) {
        this.textBaseline_ = textBaseline;
      }
      /**
       * Set the background fill.
       *
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setBackgroundFill(fill) {
        this.backgroundFill_ = fill;
      }
      /**
       * Set the background stroke.
       *
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setBackgroundStroke(stroke) {
        this.backgroundStroke_ = stroke;
      }
      /**
       * Set the padding (`[top, right, bottom, left]`).
       *
       * @param {Array<number>|null} padding Padding.
       * @api
       */
      setPadding(padding) {
        this.padding_ = padding;
      }
    };
    Text_default = Text2;
  }
});

// node_modules/ol/style.js
var init_style = __esm({
  "node_modules/ol/style.js"() {
    init_Icon();
  }
});

// node_modules/ol/render/canvas/Immediate.js
var CanvasImmediateRenderer, Immediate_default;
var init_Immediate = __esm({
  "node_modules/ol/render/canvas/Immediate.js"() {
    init_array();
    init_colorlike();
    init_extent();
    init_SimpleGeometry();
    init_transform2();
    init_math();
    init_transform();
    init_VectorContext();
    init_canvas();
    CanvasImmediateRenderer = class extends VectorContext_default {
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
       * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
       */
      constructor(context, pixelRatio, extent, transform3, viewRotation, squaredTolerance, userTransform) {
        super();
        this.context_ = context;
        this.pixelRatio_ = pixelRatio;
        this.extent_ = extent;
        this.transform_ = transform3;
        this.transformRotation_ = transform3 ? toFixed(Math.atan2(transform3[1], transform3[0]), 10) : 0;
        this.viewRotation_ = viewRotation;
        this.squaredTolerance_ = squaredTolerance;
        this.userTransform_ = userTransform;
        this.contextFillState_ = null;
        this.contextStrokeState_ = null;
        this.contextTextState_ = null;
        this.fillState_ = null;
        this.strokeState_ = null;
        this.image_ = null;
        this.imageAnchorX_ = 0;
        this.imageAnchorY_ = 0;
        this.imageHeight_ = 0;
        this.imageOpacity_ = 0;
        this.imageOriginX_ = 0;
        this.imageOriginY_ = 0;
        this.imageRotateWithView_ = false;
        this.imageRotation_ = 0;
        this.imageScale_ = [0, 0];
        this.imageWidth_ = 0;
        this.text_ = "";
        this.textOffsetX_ = 0;
        this.textOffsetY_ = 0;
        this.textRotateWithView_ = false;
        this.textRotation_ = 0;
        this.textScale_ = [0, 0];
        this.textFillState_ = null;
        this.textStrokeState_ = null;
        this.textState_ = null;
        this.pixelCoordinates_ = [];
        this.tmpLocalTransform_ = create();
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      drawImages_(flatCoordinates, offset, end, stride) {
        if (!this.image_) {
          return;
        }
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        const context = this.context_;
        const localTransform = this.tmpLocalTransform_;
        const alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha * this.imageOpacity_;
        }
        let rotation = this.imageRotation_;
        if (this.transformRotation_ === 0) {
          rotation -= this.viewRotation_;
        }
        if (this.imageRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (let i7 = 0, ii = pixelCoordinates.length; i7 < ii; i7 += 2) {
          const x4 = pixelCoordinates[i7] - this.imageAnchorX_;
          const y5 = pixelCoordinates[i7 + 1] - this.imageAnchorY_;
          if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
            const centerX = x4 + this.imageAnchorX_;
            const centerY = y5 + this.imageAnchorY_;
            compose(
              localTransform,
              centerX,
              centerY,
              1,
              1,
              rotation,
              -centerX,
              -centerY
            );
            context.save();
            context.transform.apply(context, localTransform);
            context.translate(centerX, centerY);
            context.scale(this.imageScale_[0], this.imageScale_[1]);
            context.drawImage(
              this.image_,
              this.imageOriginX_,
              this.imageOriginY_,
              this.imageWidth_,
              this.imageHeight_,
              -this.imageAnchorX_,
              -this.imageAnchorY_,
              this.imageWidth_,
              this.imageHeight_
            );
            context.restore();
          } else {
            context.drawImage(
              this.image_,
              this.imageOriginX_,
              this.imageOriginY_,
              this.imageWidth_,
              this.imageHeight_,
              x4,
              y5,
              this.imageWidth_,
              this.imageHeight_
            );
          }
        }
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha;
        }
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      drawText_(flatCoordinates, offset, end, stride) {
        if (!this.textState_ || this.text_ === "") {
          return;
        }
        if (this.textFillState_) {
          this.setContextFillState_(this.textFillState_);
        }
        if (this.textStrokeState_) {
          this.setContextStrokeState_(this.textStrokeState_);
        }
        this.setContextTextState_(this.textState_);
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        const context = this.context_;
        let rotation = this.textRotation_;
        if (this.transformRotation_ === 0) {
          rotation -= this.viewRotation_;
        }
        if (this.textRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (; offset < end; offset += stride) {
          const x4 = pixelCoordinates[offset] + this.textOffsetX_;
          const y5 = pixelCoordinates[offset + 1] + this.textOffsetY_;
          if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
            context.save();
            context.translate(x4 - this.textOffsetX_, y5 - this.textOffsetY_);
            context.rotate(rotation);
            context.translate(this.textOffsetX_, this.textOffsetY_);
            context.scale(this.textScale_[0], this.textScale_[1]);
            if (this.textStrokeState_) {
              context.strokeText(this.text_, 0, 0);
            }
            if (this.textFillState_) {
              context.fillText(this.text_, 0, 0);
            }
            context.restore();
          } else {
            if (this.textStrokeState_) {
              context.strokeText(this.text_, x4, y5);
            }
            if (this.textFillState_) {
              context.fillText(this.text_, x4, y5);
            }
          }
        }
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} close Close.
       * @private
       * @return {number} end End.
       */
      moveToLineTo_(flatCoordinates, offset, end, stride, close) {
        const context = this.context_;
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        let length = pixelCoordinates.length;
        if (close) {
          length -= 2;
        }
        for (let i7 = 2; i7 < length; i7 += 2) {
          context.lineTo(pixelCoordinates[i7], pixelCoordinates[i7 + 1]);
        }
        if (close) {
          context.closePath();
        }
        return end;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      drawRings_(flatCoordinates, offset, ends, stride) {
        for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
          offset = this.moveToLineTo_(
            flatCoordinates,
            offset,
            ends[i7],
            stride,
            true
          );
        }
        return offset;
      }
      /**
       * Render a circle geometry into the canvas.  Rendering is immediate and uses
       * the current fill and stroke styles.
       *
       * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
       * @api
       * @override
       */
      drawCircle(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Circle.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.fillState_ || this.strokeState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const pixelCoordinates = transformGeom2D(
            geometry,
            this.transform_,
            this.pixelCoordinates_
          );
          const dx = pixelCoordinates[2] - pixelCoordinates[0];
          const dy = pixelCoordinates[3] - pixelCoordinates[1];
          const radius = Math.sqrt(dx * dx + dy * dy);
          const context = this.context_;
          context.beginPath();
          context.arc(
            pixelCoordinates[0],
            pixelCoordinates[1],
            radius,
            0,
            2 * Math.PI
          );
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          this.drawText_(geometry.getCenter(), 0, 2, 2);
        }
      }
      /**
       * Set the rendering style.  Note that since this is an immediate rendering API,
       * any `zIndex` on the provided style will be ignored.
       *
       * @param {import("../../style/Style.js").default} style The rendering style.
       * @api
       * @override
       */
      setStyle(style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
      }
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      setTransform(transform3) {
        this.transform_ = transform3;
      }
      /**
       * Render a geometry into the canvas.  Call
       * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
       *
       * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
       * @api
       * @override
       */
      drawGeometry(geometry) {
        const type = geometry.getType();
        switch (type) {
          case "Point":
            this.drawPoint(
              /** @type {import("../../geom/Point.js").default} */
              geometry
            );
            break;
          case "LineString":
            this.drawLineString(
              /** @type {import("../../geom/LineString.js").default} */
              geometry
            );
            break;
          case "Polygon":
            this.drawPolygon(
              /** @type {import("../../geom/Polygon.js").default} */
              geometry
            );
            break;
          case "MultiPoint":
            this.drawMultiPoint(
              /** @type {import("../../geom/MultiPoint.js").default} */
              geometry
            );
            break;
          case "MultiLineString":
            this.drawMultiLineString(
              /** @type {import("../../geom/MultiLineString.js").default} */
              geometry
            );
            break;
          case "MultiPolygon":
            this.drawMultiPolygon(
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry
            );
            break;
          case "GeometryCollection":
            this.drawGeometryCollection(
              /** @type {import("../../geom/GeometryCollection.js").default} */
              geometry
            );
            break;
          case "Circle":
            this.drawCircle(
              /** @type {import("../../geom/Circle.js").default} */
              geometry
            );
            break;
          default:
        }
      }
      /**
       * Render a feature into the canvas.  Note that any `zIndex` on the provided
       * style will be ignored - features are rendered immediately in the order that
       * this method is called.  If you need `zIndex` support, you should be using an
       * {@link module:ol/layer/Vector~VectorLayer} instead.
       *
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {import("../../style/Style.js").default} style Style.
       * @api
       * @override
       */
      drawFeature(feature, style) {
        const geometry = style.getGeometryFunction()(feature);
        if (!geometry) {
          return;
        }
        this.setStyle(style);
        this.drawGeometry(geometry);
      }
      /**
       * Render a GeometryCollection to the canvas.  Rendering is immediate and
       * uses the current styles appropriate for each geometry in the collection.
       *
       * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
       * @override
       */
      drawGeometryCollection(geometry) {
        const geometries = geometry.getGeometriesArray();
        for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
          this.drawGeometry(geometries[i7]);
        }
      }
      /**
       * Render a Point geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
       * @override
       */
      drawPoint(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Point.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== "") {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      }
      /**
       * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
       * uses the current style.
       *
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
       * @override
       */
      drawMultiPoint(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiPoint.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== "") {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      }
      /**
       * Render a LineString into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
       * @override
       */
      drawLineString(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/LineString.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const context = this.context_;
          const flatCoordinates = geometry.getFlatCoordinates();
          context.beginPath();
          this.moveToLineTo_(
            flatCoordinates,
            0,
            flatCoordinates.length,
            geometry.getStride(),
            false
          );
          context.stroke();
        }
        if (this.text_ !== "") {
          const flatMidpoint = geometry.getFlatMidpoint();
          this.drawText_(flatMidpoint, 0, 2, 2);
        }
      }
      /**
       * Render a MultiLineString geometry into the canvas.  Rendering is immediate
       * and uses the current style.
       *
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
       * @override
       */
      drawMultiLineString(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const geometryExtent = geometry.getExtent();
        if (!intersects(this.extent_, geometryExtent)) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const context = this.context_;
          const flatCoordinates = geometry.getFlatCoordinates();
          let offset = 0;
          const ends = (
            /** @type {Array<number>} */
            geometry.getEnds()
          );
          const stride = geometry.getStride();
          context.beginPath();
          for (let i7 = 0, ii = ends.length; i7 < ii; ++i7) {
            offset = this.moveToLineTo_(
              flatCoordinates,
              offset,
              ends[i7],
              stride,
              false
            );
          }
          context.stroke();
        }
        if (this.text_ !== "") {
          const flatMidpoints = geometry.getFlatMidpoints();
          this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
      }
      /**
       * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
       * @override
       */
      drawPolygon(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Polygon.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const context = this.context_;
          context.beginPath();
          this.drawRings_(
            geometry.getOrientedFlatCoordinates(),
            0,
            /** @type {Array<number>} */
            geometry.getEnds(),
            geometry.getStride()
          );
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          const flatInteriorPoint = geometry.getFlatInteriorPoint();
          this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
      }
      /**
       * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
       * uses the current style.
       * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
       * @override
       */
      drawMultiPolygon(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const context = this.context_;
          const flatCoordinates = geometry.getOrientedFlatCoordinates();
          let offset = 0;
          const endss = geometry.getEndss();
          const stride = geometry.getStride();
          context.beginPath();
          for (let i7 = 0, ii = endss.length; i7 < ii; ++i7) {
            const ends = endss[i7];
            offset = this.drawRings_(flatCoordinates, offset, ends, stride);
          }
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          const flatInteriorPoints = geometry.getFlatInteriorPoints();
          this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
      }
      /**
       * @param {import("../canvas.js").FillState} fillState Fill state.
       * @private
       */
      setContextFillState_(fillState) {
        const context = this.context_;
        const contextFillState = this.contextFillState_;
        if (!contextFillState) {
          context.fillStyle = fillState.fillStyle;
          this.contextFillState_ = {
            fillStyle: fillState.fillStyle
          };
        } else {
          if (contextFillState.fillStyle != fillState.fillStyle) {
            contextFillState.fillStyle = fillState.fillStyle;
            context.fillStyle = fillState.fillStyle;
          }
        }
      }
      /**
       * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
       * @private
       */
      setContextStrokeState_(strokeState) {
        const context = this.context_;
        const contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
          context.lineCap = strokeState.lineCap;
          context.setLineDash(strokeState.lineDash);
          context.lineDashOffset = strokeState.lineDashOffset;
          context.lineJoin = strokeState.lineJoin;
          context.lineWidth = strokeState.lineWidth;
          context.miterLimit = strokeState.miterLimit;
          context.strokeStyle = strokeState.strokeStyle;
          this.contextStrokeState_ = {
            lineCap: strokeState.lineCap,
            lineDash: strokeState.lineDash,
            lineDashOffset: strokeState.lineDashOffset,
            lineJoin: strokeState.lineJoin,
            lineWidth: strokeState.lineWidth,
            miterLimit: strokeState.miterLimit,
            strokeStyle: strokeState.strokeStyle
          };
        } else {
          if (contextStrokeState.lineCap != strokeState.lineCap) {
            contextStrokeState.lineCap = strokeState.lineCap;
            context.lineCap = strokeState.lineCap;
          }
          if (!equals3(contextStrokeState.lineDash, strokeState.lineDash)) {
            context.setLineDash(
              contextStrokeState.lineDash = strokeState.lineDash
            );
          }
          if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
            contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
            context.lineDashOffset = strokeState.lineDashOffset;
          }
          if (contextStrokeState.lineJoin != strokeState.lineJoin) {
            contextStrokeState.lineJoin = strokeState.lineJoin;
            context.lineJoin = strokeState.lineJoin;
          }
          if (contextStrokeState.lineWidth != strokeState.lineWidth) {
            contextStrokeState.lineWidth = strokeState.lineWidth;
            context.lineWidth = strokeState.lineWidth;
          }
          if (contextStrokeState.miterLimit != strokeState.miterLimit) {
            contextStrokeState.miterLimit = strokeState.miterLimit;
            context.miterLimit = strokeState.miterLimit;
          }
          if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
            contextStrokeState.strokeStyle = strokeState.strokeStyle;
            context.strokeStyle = strokeState.strokeStyle;
          }
        }
      }
      /**
       * @param {import("../canvas.js").TextState} textState Text state.
       * @private
       */
      setContextTextState_(textState) {
        const context = this.context_;
        const contextTextState = this.contextTextState_;
        const textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
        if (!contextTextState) {
          context.font = textState.font;
          context.textAlign = textAlign;
          context.textBaseline = textState.textBaseline;
          this.contextTextState_ = {
            font: textState.font,
            textAlign,
            textBaseline: textState.textBaseline
          };
        } else {
          if (contextTextState.font != textState.font) {
            contextTextState.font = textState.font;
            context.font = textState.font;
          }
          if (contextTextState.textAlign != textAlign) {
            contextTextState.textAlign = textAlign;
            context.textAlign = textAlign;
          }
          if (contextTextState.textBaseline != textState.textBaseline) {
            contextTextState.textBaseline = textState.textBaseline;
            context.textBaseline = textState.textBaseline;
          }
        }
      }
      /**
       * Set the fill and stroke style for subsequent draw operations.  To clear
       * either fill or stroke styles, pass null for the appropriate parameter.
       *
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       * @override
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
        if (!fillStyle) {
          this.fillState_ = null;
        } else {
          const fillStyleColor = fillStyle.getColor();
          this.fillState_ = {
            fillStyle: asColorLike(
              fillStyleColor ? fillStyleColor : defaultFillStyle
            )
          };
        }
        if (!strokeStyle) {
          this.strokeState_ = null;
        } else {
          const strokeStyleColor = strokeStyle.getColor();
          const strokeStyleLineCap = strokeStyle.getLineCap();
          const strokeStyleLineDash = strokeStyle.getLineDash();
          const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          const strokeStyleLineJoin = strokeStyle.getLineJoin();
          const strokeStyleWidth = strokeStyle.getWidth();
          const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          const lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
          this.strokeState_ = {
            lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
            lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n6) => n6 * this.pixelRatio_),
            lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
            lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
            lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
            miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
            strokeStyle: asColorLike(
              strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
            )
          };
        }
      }
      /**
       * Set the image style for subsequent draw operations.  Pass null to remove
       * the image style.
       *
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       * @override
       */
      setImageStyle(imageStyle) {
        let imageSize;
        if (!imageStyle || !(imageSize = imageStyle.getSize())) {
          this.image_ = null;
          return;
        }
        const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
        const imageAnchor = imageStyle.getAnchor();
        const imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
        this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
        this.imageHeight_ = imageSize[1] * imagePixelRatio;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        const imageScale = imageStyle.getScaleArray();
        this.imageScale_ = [
          imageScale[0] * this.pixelRatio_ / imagePixelRatio,
          imageScale[1] * this.pixelRatio_ / imagePixelRatio
        ];
        this.imageWidth_ = imageSize[0] * imagePixelRatio;
      }
      /**
       * Set the text style for subsequent draw operations.  Pass null to
       * remove the text style.
       *
       * @param {import("../../style/Text.js").default} textStyle Text style.
       * @override
       */
      setTextStyle(textStyle) {
        if (!textStyle) {
          this.text_ = "";
        } else {
          const textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            this.textFillState_ = null;
          } else {
            const textFillStyleColor = textFillStyle.getColor();
            this.textFillState_ = {
              fillStyle: asColorLike(
                textFillStyleColor ? textFillStyleColor : defaultFillStyle
              )
            };
          }
          const textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            this.textStrokeState_ = null;
          } else {
            const textStrokeStyleColor = textStrokeStyle.getColor();
            const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
            const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
            const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
            const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
            const textStrokeStyleWidth = textStrokeStyle.getWidth();
            const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
            this.textStrokeState_ = {
              lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
              lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
              lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
              lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
              lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
              miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
              strokeStyle: asColorLike(
                textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle
              )
            };
          }
          const textFont = textStyle.getFont();
          const textOffsetX = textStyle.getOffsetX();
          const textOffsetY = textStyle.getOffsetY();
          const textRotateWithView = textStyle.getRotateWithView();
          const textRotation = textStyle.getRotation();
          const textScale = textStyle.getScaleArray();
          const textText = textStyle.getText();
          const textTextAlign = textStyle.getTextAlign();
          const textTextBaseline = textStyle.getTextBaseline();
          this.textState_ = {
            font: textFont !== void 0 ? textFont : defaultFont,
            textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
            textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
          };
          this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce((acc, t4, i7) => acc += i7 % 2 ? " " : t4, "") : textText : "";
          this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
          this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
          this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
          this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
          this.textScale_ = [
            this.pixelRatio_ * textScale[0],
            this.pixelRatio_ * textScale[1]
          ];
        }
      }
    };
    Immediate_default = CanvasImmediateRenderer;
  }
});

// node_modules/ol/render/canvas/hitdetect.js
function createHitDetectionImageData(size, transforms2, features, styleFunction, extent, resolution, rotation, squaredTolerance, projection) {
  const userExtent = projection ? toUserExtent(extent, projection) : extent;
  const width = size[0] * HIT_DETECT_RESOLUTION;
  const height = size[1] * HIT_DETECT_RESOLUTION;
  const context = createCanvasContext2D(width, height);
  context.imageSmoothingEnabled = false;
  const canvas = context.canvas;
  const renderer = new Immediate_default(
    context,
    HIT_DETECT_RESOLUTION,
    extent,
    null,
    rotation,
    squaredTolerance,
    projection ? getTransformFromProjections(getUserProjection(), projection) : null
  );
  const featureCount = features.length;
  const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  const featuresByZIndex = {};
  for (let i7 = 1; i7 <= featureCount; ++i7) {
    const feature = features[i7 - 1];
    const featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!featureStyleFunction) {
      continue;
    }
    let styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    const index13 = i7 * indexFactor;
    const color = index13.toString(16).padStart(7, "#00000");
    for (let j6 = 0, jj = styles.length; j6 < jj; ++j6) {
      const originalStyle = styles[j6];
      const geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !intersects(userExtent, geometry.getExtent())) {
        continue;
      }
      const style = originalStyle.clone();
      const fill = style.getFill();
      if (fill) {
        fill.setColor(color);
      }
      const stroke = style.getStroke();
      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }
      style.setText(void 0);
      const image = originalStyle.getImage();
      if (image) {
        const imgSize = image.getImageSize();
        if (!imgSize) {
          continue;
        }
        const imgContext = createCanvasContext2D(
          imgSize[0],
          imgSize[1],
          void 0,
          { alpha: false }
        );
        const img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(
          new Icon_default({
            img,
            anchor: image.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: image.getOrigin(),
            opacity: 1,
            size: image.getSize(),
            scale: image.getScale(),
            rotation: image.getRotation(),
            rotateWithView: image.getRotateWithView()
          })
        );
      }
      const zIndex = style.getZIndex() || 0;
      let byGeometryType = featuresByZIndex[zIndex];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType["Polygon"] = [];
        byGeometryType["Circle"] = [];
        byGeometryType["LineString"] = [];
        byGeometryType["Point"] = [];
      }
      const type = geometry.getType();
      if (type === "GeometryCollection") {
        const geometries = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          geometry.getGeometriesArrayRecursive()
        );
        for (let i8 = 0, ii = geometries.length; i8 < ii; ++i8) {
          const geometry2 = geometries[i8];
          byGeometryType[geometry2.getType().replace("Multi", "")].push(
            geometry2,
            style
          );
        }
      } else {
        byGeometryType[type.replace("Multi", "")].push(geometry, style);
      }
    }
  }
  const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(ascending);
  for (let i7 = 0, ii = zIndexKeys.length; i7 < ii; ++i7) {
    const byGeometryType = featuresByZIndex[zIndexKeys[i7]];
    for (const type in byGeometryType) {
      const geomAndStyle = byGeometryType[type];
      for (let j6 = 0, jj = geomAndStyle.length; j6 < jj; j6 += 2) {
        renderer.setStyle(geomAndStyle[j6 + 1]);
        for (let k5 = 0, kk = transforms2.length; k5 < kk; ++k5) {
          renderer.setTransform(transforms2[k5]);
          renderer.drawGeometry(geomAndStyle[j6]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
  const resultFeatures = [];
  if (imageData) {
    const x4 = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    const y5 = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    const index13 = (clamp(x4, 0, imageData.width - 1) + clamp(y5, 0, imageData.height - 1) * imageData.width) * 4;
    const r5 = imageData.data[index13];
    const g5 = imageData.data[index13 + 1];
    const b8 = imageData.data[index13 + 2];
    const i7 = b8 + 256 * (g5 + 256 * r5);
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i7 && i7 % indexFactor === 0) {
      resultFeatures.push(features[i7 / indexFactor - 1]);
    }
  }
  return resultFeatures;
}
var HIT_DETECT_RESOLUTION;
var init_hitdetect = __esm({
  "node_modules/ol/render/canvas/hitdetect.js"() {
    init_array();
    init_dom();
    init_extent();
    init_math();
    init_proj();
    init_style();
    init_Immediate();
    HIT_DETECT_RESOLUTION = 0.5;
  }
});

// node_modules/ol/renderer/vector.js
function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
  const tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
function renderCircleGeometry(builderGroup, geometry, style, feature, index13) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const circleReplay = builderGroup.getBuilder(style.getZIndex(), "Circle");
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature, index13);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform3, declutter, index13) {
  const loadingPromises = [];
  const imageStyle = style.getImage();
  if (imageStyle) {
    let loading2 = true;
    const imageState = imageStyle.getImageState();
    if (imageState == ImageState_default.LOADED || imageState == ImageState_default.ERROR) {
      loading2 = false;
    } else {
      if (imageState == ImageState_default.IDLE) {
        imageStyle.load();
      }
    }
    if (loading2) {
      loadingPromises.push(imageStyle.ready());
    }
  }
  const fillStyle = style.getFill();
  if (fillStyle && fillStyle.loading()) {
    loadingPromises.push(fillStyle.ready());
  }
  const loading = loadingPromises.length > 0;
  if (loading) {
    Promise.all(loadingPromises).then(() => listener(null));
  }
  renderFeatureInternal(
    replayGroup,
    feature,
    style,
    squaredTolerance,
    transform3,
    declutter,
    index13
  );
  return loading;
}
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform3, declutter, index13) {
  const geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  const simplifiedGeometry = geometry.simplifyTransformed(
    squaredTolerance,
    transform3
  );
  const renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature, index13);
  } else {
    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(
      replayGroup,
      simplifiedGeometry,
      style,
      feature,
      index13,
      declutter
    );
  }
}
function renderGeometry(replayGroup, geometry, style, feature, index13) {
  if (geometry.getType() == "GeometryCollection") {
    const geometries = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      geometry.getGeometries()
    );
    for (let i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
      renderGeometry(replayGroup, geometries[i7], style, feature, index13);
    }
    return;
  }
  const replay = replayGroup.getBuilder(style.getZIndex(), "Default");
  replay.drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    geometry,
    feature,
    style.getRenderer(),
    style.getHitDetectionRenderer(),
    index13
  );
}
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup, index13) {
  const geometries = geometry.getGeometriesArray();
  let i7, ii;
  for (i7 = 0, ii = geometries.length; i7 < ii; ++i7) {
    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i7].getType()];
    geometryRenderer(
      replayGroup,
      geometries[i7],
      style,
      feature,
      declutterBuilderGroup,
      index13
    );
  }
}
function renderLineStringGeometry(builderGroup, geometry, style, feature, index13) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature, index13);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index13);
  }
}
function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, index13) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature, index13);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index13);
  }
}
function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, index13) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature, index13);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index13);
  }
}
function renderPointGeometry(builderGroup, geometry, style, feature, index13, declutter) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  const hasText = textStyle && textStyle.getText();
  const declutterImageWithText = declutter && imageStyle && hasText ? {} : void 0;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    const imageReplay = builderGroup.getBuilder(style.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature, index13);
  }
  if (hasText) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature, index13);
  }
}
function renderMultiPointGeometry(builderGroup, geometry, style, feature, index13, declutter) {
  const imageStyle = style.getImage();
  const hasImage = imageStyle && imageStyle.getOpacity() !== 0;
  const textStyle = style.getText();
  const hasText = textStyle && textStyle.getText();
  const declutterImageWithText = declutter && hasImage && hasText ? {} : void 0;
  if (hasImage) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    const imageReplay = builderGroup.getBuilder(style.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature, index13);
  }
  if (hasText) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature, index13);
  }
}
function renderPolygonGeometry(builderGroup, geometry, style, feature, index13) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature, index13);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index13);
  }
}
var SIMPLIFY_TOLERANCE, GEOMETRY_RENDERERS;
var init_vector = __esm({
  "node_modules/ol/renderer/vector.js"() {
    init_ImageState();
    init_util();
    SIMPLIFY_TOLERANCE = 0.5;
    GEOMETRY_RENDERERS = {
      "Point": renderPointGeometry,
      "LineString": renderLineStringGeometry,
      "Polygon": renderPolygonGeometry,
      "MultiPoint": renderMultiPointGeometry,
      "MultiLineString": renderMultiLineStringGeometry,
      "MultiPolygon": renderMultiPolygonGeometry,
      "GeometryCollection": renderGeometryCollectionGeometry,
      "Circle": renderCircleGeometry
    };
  }
});

// node_modules/ol/render/Event.js
var RenderEvent, Event_default2;
var init_Event2 = __esm({
  "node_modules/ol/render/Event.js"() {
    init_Event();
    RenderEvent = class extends Event_default {
      /**
       * @param {import("./EventType.js").default} type Type.
       * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
       *     CSS pixels to rendered pixels.
       * @param {import("../Map.js").FrameState} [frameState] Frame state.
       * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
       */
      constructor(type, inversePixelTransform, frameState, context) {
        super(type);
        this.inversePixelTransform = inversePixelTransform;
        this.frameState = frameState;
        this.context = context;
      }
    };
    Event_default2 = RenderEvent;
  }
});

// node_modules/ol/renderer/Layer.js
var maxStaleKeys, LayerRenderer, Layer_default;
var init_Layer = __esm({
  "node_modules/ol/renderer/Layer.js"() {
    init_ImageState();
    init_Observable();
    init_EventType();
    init_util();
    maxStaleKeys = 5;
    LayerRenderer = class extends Observable_default {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super();
        this.ready = true;
        this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        this.layer_ = layer;
        this.staleKeys_ = new Array();
        this.maxStaleKeys = maxStaleKeys;
      }
      /**
       * @return {Array<string>} Get the list of stale keys.
       */
      getStaleKeys() {
        return this.staleKeys_;
      }
      /**
       * @param {string} key The new stale key.
       */
      prependStaleKey(key) {
        this.staleKeys_.unshift(key);
        if (this.staleKeys_.length > this.maxStaleKeys) {
          this.staleKeys_.length = this.maxStaleKeys;
        }
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        return abstract();
      }
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        return null;
      }
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      prepareFrame(frameState) {
        return abstract();
      }
      /**
       * Render the layer.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      renderFrame(frameState, target) {
        return abstract();
      }
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return void 0;
      }
      /**
       * @return {LayerType} Layer.
       */
      getLayer() {
        return this.layer_;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */
      handleFontsChanged() {
      }
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */
      handleImageChange_(event) {
        const image = (
          /** @type {import("../Image.js").default} */
          event.target
        );
        if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
          this.renderIfReadyAndVisible();
        }
      }
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../Image.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      loadImage(image) {
        let imageState = image.getState();
        if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
          image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
        }
        if (imageState == ImageState_default.IDLE) {
          image.load();
          imageState = image.getState();
        }
        return imageState == ImageState_default.LOADED;
      }
      /**
       * @protected
       */
      renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
          layer.changed();
        }
      }
      /**
       * @param {import("../Map.js").FrameState} frameState Frame state.
       */
      renderDeferred(frameState) {
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
      }
    };
    Layer_default = LayerRenderer;
  }
});

// node_modules/ol/renderer/canvas/Layer.js
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
var canvasPool, pixelContext, CanvasLayerRenderer, Layer_default2;
var init_Layer2 = __esm({
  "node_modules/ol/renderer/canvas/Layer.js"() {
    init_array();
    init_color();
    init_dom();
    init_extent();
    init_Event2();
    init_EventType2();
    init_ZIndexContext();
    init_transform();
    init_Layer();
    canvasPool = [];
    pixelContext = null;
    CanvasLayerRenderer = class extends Layer_default {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super(layer);
        this.container = null;
        this.renderedResolution;
        this.tempTransform = create();
        this.pixelTransform = create();
        this.inversePixelTransform = create();
        this.context = null;
        this.deferredContext_ = null;
        this.containerReused = false;
        this.frameState = null;
      }
      /**
       * @param {import('../../DataTile.js').ImageLike} image Image.
       * @param {number} col The column index.
       * @param {number} row The row index.
       * @return {Uint8ClampedArray|null} The image data.
       */
      getImageData(image, col, row) {
        if (!pixelContext) {
          createPixelContext();
        }
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
          pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
          data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch {
          pixelContext = null;
          return null;
        }
        return data;
      }
      /**
       * @param {import('../../Map.js').FrameState} frameState Frame state.
       * @return {string} Background color.
       */
      getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === "function") {
          background = background(frameState.viewState.resolution);
        }
        return background || void 0;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS transform matrix.
       * @param {string} [backgroundColor] Background color.
       */
      useContainer(target, transform3, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals3(
          asArray(target.style.backgroundColor),
          asArray(backgroundColor)
        ))) {
          const canvas = target.firstElementChild;
          if (canvas instanceof HTMLCanvasElement) {
            context = canvas.getContext("2d");
          }
        }
        if (context && equivalent2(context.canvas.style.transform, transform3)) {
          this.container = target;
          this.context = context;
          this.containerReused = true;
        } else if (this.containerReused) {
          this.container = null;
          this.context = null;
          this.containerReused = false;
        } else if (this.container) {
          this.container.style.backgroundColor = null;
        }
        if (!this.container) {
          container = document.createElement("div");
          container.className = layerClassName;
          let style = container.style;
          style.position = "absolute";
          style.width = "100%";
          style.height = "100%";
          context = createCanvasContext2D();
          const canvas = context.canvas;
          container.appendChild(canvas);
          style = canvas.style;
          style.position = "absolute";
          style.left = "0";
          style.transformOrigin = "top left";
          this.container = container;
          this.context = context;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
          this.container.style.backgroundColor = backgroundColor;
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      clipUnrotated(context, frameState, extent) {
        const topLeft = getTopLeft(extent);
        const topRight = getTopRight(extent);
        const bottomRight = getBottomRight(extent);
        const bottomLeft = getBottomLeft(extent);
        apply(frameState.coordinateToPixelTransform, topLeft);
        apply(frameState.coordinateToPixelTransform, topRight);
        apply(frameState.coordinateToPixelTransform, bottomRight);
        apply(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        apply(inverted, topLeft);
        apply(inverted, topRight);
        apply(inverted, bottomRight);
        apply(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @protected
       */
      prepareContainer(frameState, target) {
        const extent = frameState.extent;
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const pixelRatio = frameState.pixelRatio;
        const width = Math.round(getWidth(extent) / resolution * pixelRatio);
        const height = Math.round(getHeight(extent) / resolution * pixelRatio);
        compose(
          this.pixelTransform,
          frameState.size[0] / 2,
          frameState.size[1] / 2,
          1 / pixelRatio,
          1 / pixelRatio,
          rotation,
          -width / 2,
          -height / 2
        );
        makeInverse(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = toString(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        if (!this.containerReused) {
          const canvas = this.context.canvas;
          if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
          } else {
            this.context.clearRect(0, 0, width, height);
          }
          if (canvasTransform !== canvas.style.transform) {
            canvas.style.transform = canvasTransform;
          }
        }
      }
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @private
       */
      dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
          const event = new Event_default2(
            type,
            this.inversePixelTransform,
            frameState,
            context
          );
          layer.dispatchEvent(event);
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      preRender(context, frameState) {
        this.frameState = frameState;
        if (frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(EventType_default2.PRERENDER, context, frameState);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      postRender(context, frameState) {
        if (frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context, frameState);
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      renderDeferredInternal(frameState) {
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
       */
      getRenderContext(frameState) {
        if (frameState.declutter && !this.deferredContext_) {
          this.deferredContext_ = new ZIndexContext_default();
        }
        return frameState.declutter ? this.deferredContext_.getContext() : this.context;
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @override
       */
      renderDeferred(frameState) {
        if (!frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(
          EventType_default2.PRERENDER,
          this.context,
          frameState
        );
        if (frameState.declutter && this.deferredContext_) {
          this.deferredContext_.draw(this.context);
          this.deferredContext_.clear();
        }
        this.renderDeferredInternal(frameState);
        this.dispatchRenderEvent_(
          EventType_default2.POSTRENDER,
          this.context,
          frameState
        );
      }
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */
      getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return compose(
          this.tempTransform,
          dx1,
          dy1,
          sx,
          sy,
          -rotation,
          dx2,
          dy2
        );
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
      }
    };
    Layer_default2 = CanvasLayerRenderer;
  }
});

// node_modules/ol/renderer/canvas/VectorLayer.js
var CanvasVectorLayerRenderer, VectorLayer_default;
var init_VectorLayer = __esm({
  "node_modules/ol/renderer/canvas/VectorLayer.js"() {
    init_ViewHint();
    init_array();
    init_coordinate();
    init_dom();
    init_extent();
    init_proj();
    init_EventType2();
    init_BuilderGroup();
    init_ExecutorGroup();
    init_hitdetect();
    init_util();
    init_vector();
    init_Layer2();
    CanvasVectorLayerRenderer = class extends Layer_default2 {
      /**
       * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
       */
      constructor(vectorLayer) {
        super(vectorLayer);
        this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
        this.animatingOrInteracting_;
        this.hitDetectionImageData_ = null;
        this.clipped_ = false;
        this.renderedFeatures_ = null;
        this.renderedRevision_ = -1;
        this.renderedResolution_ = NaN;
        this.renderedExtent_ = createEmpty();
        this.wrappedRenderedExtent_ = createEmpty();
        this.renderedRotation_;
        this.renderedCenter_ = null;
        this.renderedProjection_ = null;
        this.renderedPixelRatio_ = 1;
        this.renderedRenderOrder_ = null;
        this.renderedFrameDeclutter_;
        this.replayGroup_ = null;
        this.replayGroupChanged = true;
        this.clipping = true;
        this.targetContext_ = null;
        this.opacity_ = 1;
      }
      /**
       * @param {ExecutorGroup} executorGroup Executor group.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {boolean} [declutterable] `true` to only render declutterable items,
       *     `false` to only render non-declutterable items, `undefined` to render all.
       */
      renderWorlds(executorGroup, frameState, declutterable) {
        const extent = frameState.extent;
        const viewState = frameState.viewState;
        const center = viewState.center;
        const resolution = viewState.resolution;
        const projection = viewState.projection;
        const rotation = viewState.rotation;
        const projectionExtent = projection.getExtent();
        const vectorSource = this.getLayer().getSource();
        const declutter = this.getLayer().getDeclutter();
        const pixelRatio = frameState.pixelRatio;
        const viewHints = frameState.viewHints;
        const snapToPixel = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
        const context = this.context;
        const width = Math.round(getWidth(extent) / resolution * pixelRatio);
        const height = Math.round(getHeight(extent) / resolution * pixelRatio);
        const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        const worldWidth = multiWorld ? getWidth(projectionExtent) : null;
        const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
        let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
        do {
          let transform3 = this.getRenderTransform(
            center,
            resolution,
            0,
            pixelRatio,
            width,
            height,
            world * worldWidth
          );
          if (frameState.declutter) {
            transform3 = transform3.slice(0);
          }
          executorGroup.execute(
            context,
            [context.canvas.width, context.canvas.height],
            transform3,
            rotation,
            snapToPixel,
            declutterable === void 0 ? ALL : declutterable ? DECLUTTER : NON_DECLUTTER,
            declutterable ? declutter && frameState.declutter[declutter] : void 0
          );
        } while (++world < endWorld);
      }
      /**
       * @private
       */
      setDrawContext_() {
        if (this.opacity_ !== 1) {
          this.targetContext_ = this.context;
          this.context = createCanvasContext2D(
            this.context.canvas.width,
            this.context.canvas.height,
            canvasPool
          );
        }
      }
      /**
       * @private
       */
      resetDrawContext_() {
        if (this.opacity_ !== 1 && this.targetContext_) {
          const alpha = this.targetContext_.globalAlpha;
          this.targetContext_.globalAlpha = this.opacity_;
          this.targetContext_.drawImage(this.context.canvas, 0, 0);
          this.targetContext_.globalAlpha = alpha;
          releaseCanvas(this.context);
          canvasPool.push(this.context.canvas);
          this.context = this.targetContext_;
          this.targetContext_ = null;
        }
      }
      /**
       * Render declutter items for this layer
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      renderDeclutter(frameState) {
        if (!this.replayGroup_ || !this.getLayer().getDeclutter()) {
          return;
        }
        this.renderWorlds(this.replayGroup_, frameState, true);
      }
      /**
       * Render deferred instructions.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @override
       */
      renderDeferredInternal(frameState) {
        if (!this.replayGroup_) {
          return;
        }
        this.replayGroup_.renderDeferred();
        if (this.clipped_) {
          this.context.restore();
        }
        this.resetDrawContext_();
      }
      /**
       * Render the layer.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       * @override
       */
      renderFrame(frameState, target) {
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        this.opacity_ = layerState.opacity;
        const viewState = frameState.viewState;
        this.prepareContainer(frameState, target);
        const context = this.context;
        const replayGroup = this.replayGroup_;
        let render = replayGroup && !replayGroup.isEmpty();
        if (!render) {
          const hasRenderListeners = this.getLayer().hasListener(EventType_default2.PRERENDER) || this.getLayer().hasListener(EventType_default2.POSTRENDER);
          if (!hasRenderListeners) {
            return this.container;
          }
        }
        this.setDrawContext_();
        this.preRender(context, frameState);
        const projection = viewState.projection;
        this.clipped_ = false;
        if (render && layerState.extent && this.clipping) {
          const layerExtent = fromUserExtent(layerState.extent, projection);
          render = intersects(layerExtent, frameState.extent);
          this.clipped_ = render && !containsExtent(layerExtent, frameState.extent);
          if (this.clipped_) {
            this.clipUnrotated(context, frameState, layerExtent);
          }
        }
        if (render) {
          this.renderWorlds(
            replayGroup,
            frameState,
            this.getLayer().getDeclutter() ? false : void 0
          );
        }
        if (!frameState.declutter && this.clipped_) {
          context.restore();
        }
        this.postRender(context, frameState);
        if (this.renderedRotation_ !== viewState.rotation) {
          this.renderedRotation_ = viewState.rotation;
          this.hitDetectionImageData_ = null;
        }
        if (!frameState.declutter) {
          this.resetDrawContext_();
        }
        return this.container;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../../Feature").default>>} Promise
       * that resolves with an array of features.
       * @override
       */
      getFeatures(pixel) {
        return new Promise((resolve) => {
          if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
            const size = this.frameState.size.slice();
            const center = this.renderedCenter_;
            const resolution = this.renderedResolution_;
            const rotation = this.renderedRotation_;
            const projection = this.renderedProjection_;
            const extent = this.wrappedRenderedExtent_;
            const layer = this.getLayer();
            const transforms2 = [];
            const width = size[0] * HIT_DETECT_RESOLUTION;
            const height = size[1] * HIT_DETECT_RESOLUTION;
            transforms2.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                HIT_DETECT_RESOLUTION,
                width,
                height,
                0
              ).slice()
            );
            const source = layer.getSource();
            const projectionExtent = projection.getExtent();
            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
              let startX = extent[0];
              const worldWidth = getWidth(projectionExtent);
              let world = 0;
              let offsetX;
              while (startX < projectionExtent[0]) {
                --world;
                offsetX = worldWidth * world;
                transforms2.push(
                  this.getRenderTransform(
                    center,
                    resolution,
                    rotation,
                    HIT_DETECT_RESOLUTION,
                    width,
                    height,
                    offsetX
                  ).slice()
                );
                startX += worldWidth;
              }
              world = 0;
              startX = extent[2];
              while (startX > projectionExtent[2]) {
                ++world;
                offsetX = worldWidth * world;
                transforms2.push(
                  this.getRenderTransform(
                    center,
                    resolution,
                    rotation,
                    HIT_DETECT_RESOLUTION,
                    width,
                    height,
                    offsetX
                  ).slice()
                );
                startX -= worldWidth;
              }
            }
            const userProjection2 = getUserProjection();
            this.hitDetectionImageData_ = createHitDetectionImageData(
              size,
              transforms2,
              this.renderedFeatures_,
              layer.getStyleFunction(),
              extent,
              resolution,
              rotation,
              getSquaredTolerance(resolution, this.renderedPixelRatio_),
              userProjection2 ? projection : null
            );
          }
          resolve(
            hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)
          );
        });
      }
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       * @override
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        if (!this.replayGroup_) {
          return void 0;
        }
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const layer = this.getLayer();
        const features = {};
        const featureCallback = function(feature, geometry, distanceSq) {
          const key = getUid(feature);
          const match2 = features[key];
          if (!match2) {
            if (distanceSq === 0) {
              features[key] = true;
              return callback(feature, layer, geometry);
            }
            matches.push(
              features[key] = {
                feature,
                layer,
                geometry,
                distanceSq,
                callback
              }
            );
          } else if (match2 !== true && distanceSq < match2.distanceSq) {
            if (distanceSq === 0) {
              features[key] = true;
              matches.splice(matches.lastIndexOf(match2), 1);
              return callback(feature, layer, geometry);
            }
            match2.geometry = geometry;
            match2.distanceSq = distanceSq;
          }
          return void 0;
        };
        const declutter = this.getLayer().getDeclutter();
        return this.replayGroup_.forEachFeatureAtCoordinate(
          coordinate,
          resolution,
          rotation,
          hitTolerance,
          featureCallback,
          declutter ? frameState.declutter?.[declutter]?.all().map((item) => item.value) : null
        );
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @override
       */
      handleFontsChanged() {
        const layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) {
          layer.changed();
        }
      }
      /**
       * Handle changes in image style state.
       * @param {import("../../events/Event.js").default} event Image style change event.
       * @private
       */
      handleStyleImageChange_(event) {
        this.renderIfReadyAndVisible();
      }
      /**
       * Determine whether render should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       * @override
       */
      prepareFrame(frameState) {
        const vectorLayer = this.getLayer();
        const vectorSource = vectorLayer.getSource();
        if (!vectorSource) {
          return false;
        }
        const animating = frameState.viewHints[ViewHint_default.ANIMATING];
        const interacting = frameState.viewHints[ViewHint_default.INTERACTING];
        const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
          this.animatingOrInteracting_ = true;
          return true;
        }
        this.animatingOrInteracting_ = false;
        const frameStateExtent = frameState.extent;
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const resolution = viewState.resolution;
        const pixelRatio = frameState.pixelRatio;
        const vectorLayerRevision = vectorLayer.getRevision();
        const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === void 0) {
          vectorLayerRenderOrder = defaultOrder;
        }
        const center = viewState.center.slice();
        const extent = buffer(
          frameStateExtent,
          vectorLayerRenderBuffer * resolution
        );
        const renderedExtent = extent.slice();
        const loadExtents = [extent.slice()];
        const projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
          const worldWidth = getWidth(projectionExtent);
          const gutter = Math.max(getWidth(extent) / 2, worldWidth);
          extent[0] = projectionExtent[0] - gutter;
          extent[2] = projectionExtent[2] + gutter;
          wrapX2(center, projection);
          const loadExtent = wrapX(loadExtents[0], projection);
          if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
            loadExtents.push([
              loadExtent[0] + worldWidth,
              loadExtent[1],
              loadExtent[2] + worldWidth,
              loadExtent[3]
            ]);
          } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
            loadExtents.push([
              loadExtent[0] - worldWidth,
              loadExtent[1],
              loadExtent[2] - worldWidth,
              loadExtent[3]
            ]);
          }
        }
        if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && this.renderedFrameDeclutter_ === !!frameState.declutter && containsExtent(this.wrappedRenderedExtent_, extent)) {
          if (!equals3(this.renderedExtent_, renderedExtent)) {
            this.hitDetectionImageData_ = null;
            this.renderedExtent_ = renderedExtent;
          }
          this.renderedCenter_ = center;
          this.replayGroupChanged = false;
          return true;
        }
        this.replayGroup_ = null;
        const replayGroup = new BuilderGroup_default(
          getTolerance(resolution, pixelRatio),
          extent,
          resolution,
          pixelRatio
        );
        const userProjection2 = getUserProjection();
        let userTransform;
        if (userProjection2) {
          for (let i7 = 0, ii = loadExtents.length; i7 < ii; ++i7) {
            const extent2 = loadExtents[i7];
            const userExtent2 = toUserExtent(extent2, projection);
            vectorSource.loadFeatures(
              userExtent2,
              toUserResolution(resolution, projection),
              userProjection2
            );
          }
          userTransform = getTransformFromProjections(userProjection2, projection);
        } else {
          for (let i7 = 0, ii = loadExtents.length; i7 < ii; ++i7) {
            vectorSource.loadFeatures(loadExtents[i7], resolution, projection);
          }
        }
        const squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
        let ready = true;
        const render = (
          /**
           * @param {import("../../Feature.js").default} feature Feature.
           * @param {number} index Index.
           */
          (feature, index13) => {
            let styles;
            const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) {
              styles = styleFunction(feature, resolution);
            }
            if (styles) {
              const dirty = this.renderFeature(
                feature,
                squaredTolerance,
                styles,
                replayGroup,
                userTransform,
                this.getLayer().getDeclutter(),
                index13
              );
              ready = ready && !dirty;
            }
          }
        );
        const userExtent = toUserExtent(extent, projection);
        const features = vectorSource.getFeaturesInExtent(userExtent);
        if (vectorLayerRenderOrder) {
          features.sort(vectorLayerRenderOrder);
        }
        for (let i7 = 0, ii = features.length; i7 < ii; ++i7) {
          render(features[i7], i7);
        }
        this.renderedFeatures_ = features;
        this.ready = ready;
        const replayGroupInstructions = replayGroup.finish();
        const executorGroup = new ExecutorGroup_default(
          extent,
          resolution,
          pixelRatio,
          vectorSource.getOverlaps(),
          replayGroupInstructions,
          vectorLayer.getRenderBuffer(),
          !!frameState.declutter
        );
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedFrameDeclutter_ = !!frameState.declutter;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.renderedPixelRatio_ = pixelRatio;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
      }
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} squaredTolerance Squared render tolerance.
       * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
       * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
       * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
       * @param {boolean} [declutter] Enable decluttering.
       * @param {number} [index] Render order index.
       * @return {boolean} `true` if an image is loading.
       */
      renderFeature(feature, squaredTolerance, styles, builderGroup, transform3, declutter, index13) {
        if (!styles) {
          return false;
        }
        let loading = false;
        if (Array.isArray(styles)) {
          for (let i7 = 0, ii = styles.length; i7 < ii; ++i7) {
            loading = renderFeature(
              builderGroup,
              feature,
              styles[i7],
              squaredTolerance,
              this.boundHandleStyleImageChange_,
              transform3,
              declutter,
              index13
            ) || loading;
          }
        } else {
          loading = renderFeature(
            builderGroup,
            feature,
            styles,
            squaredTolerance,
            this.boundHandleStyleImageChange_,
            transform3,
            declutter,
            index13
          );
        }
        return loading;
      }
    };
    VectorLayer_default = CanvasVectorLayerRenderer;
  }
});

// node_modules/quickselect/index.js
function quickselect(arr, k5, left = 0, right = arr.length - 1, compare = defaultCompare) {
  while (right > left) {
    if (right - left > 600) {
      const n6 = right - left + 1;
      const m8 = k5 - left + 1;
      const z3 = Math.log(n6);
      const s5 = 0.5 * Math.exp(2 * z3 / 3);
      const sd = 0.5 * Math.sqrt(z3 * s5 * (n6 - s5) / n6) * (m8 - n6 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k5 - m8 * s5 / n6 + sd));
      const newRight = Math.min(right, Math.floor(k5 + (n6 - m8) * s5 / n6 + sd));
      quickselect(arr, k5, newLeft, newRight, compare);
    }
    const t4 = arr[k5];
    let i7 = left;
    let j6 = right;
    swap(arr, left, k5);
    if (compare(arr[right], t4) > 0) swap(arr, left, right);
    while (i7 < j6) {
      swap(arr, i7, j6);
      i7++;
      j6--;
      while (compare(arr[i7], t4) < 0) i7++;
      while (compare(arr[j6], t4) > 0) j6--;
    }
    if (compare(arr[left], t4) === 0) swap(arr, left, j6);
    else {
      j6++;
      swap(arr, j6, right);
    }
    if (j6 <= k5) left = j6 + 1;
    if (k5 <= j6) right = j6 - 1;
  }
}
function swap(arr, i7, j6) {
  const tmp = arr[i7];
  arr[i7] = arr[j6];
  arr[j6] = tmp;
}
function defaultCompare(a5, b8) {
  return a5 < b8 ? -1 : a5 > b8 ? 1 : 0;
}
var init_quickselect = __esm({
  "node_modules/quickselect/index.js"() {
  }
});

// node_modules/rbush/index.js
function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);
  for (let i7 = 0; i7 < items.length; i7++) {
    if (equalsFn(item, items[i7])) return i7;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k5, p6, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i7 = k5; i7 < p6; i7++) {
    const child = node.children[i7];
    extend3(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend3(a5, b8) {
  a5.minX = Math.min(a5.minX, b8.minX);
  a5.minY = Math.min(a5.minY, b8.minY);
  a5.maxX = Math.max(a5.maxX, b8.maxX);
  a5.maxY = Math.max(a5.maxY, b8.maxY);
  return a5;
}
function compareNodeMinX(a5, b8) {
  return a5.minX - b8.minX;
}
function compareNodeMinY(a5, b8) {
  return a5.minY - b8.minY;
}
function bboxArea(a5) {
  return (a5.maxX - a5.minX) * (a5.maxY - a5.minY);
}
function bboxMargin(a5) {
  return a5.maxX - a5.minX + (a5.maxY - a5.minY);
}
function enlargedArea(a5, b8) {
  return (Math.max(b8.maxX, a5.maxX) - Math.min(b8.minX, a5.minX)) * (Math.max(b8.maxY, a5.maxY) - Math.min(b8.minY, a5.minY));
}
function intersectionArea(a5, b8) {
  const minX = Math.max(a5.minX, b8.minX);
  const minY = Math.max(a5.minY, b8.minY);
  const maxX = Math.min(a5.maxX, b8.maxX);
  const maxY = Math.min(a5.maxY, b8.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a5, b8) {
  return a5.minX <= b8.minX && a5.minY <= b8.minY && b8.maxX <= a5.maxX && b8.maxY <= a5.maxY;
}
function intersects2(a5, b8) {
  return b8.minX <= a5.maxX && b8.minY <= a5.maxY && b8.maxX >= a5.minX && b8.maxY >= a5.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n6, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n6) continue;
    const mid = left + Math.ceil((right - left) / n6 / 2) * n6;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}
var RBush;
var init_rbush = __esm({
  "node_modules/rbush/index.js"() {
    init_quickselect();
    RBush = class {
      constructor(maxEntries = 9) {
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      }
      all() {
        return this._all(this.data, []);
      }
      search(bbox) {
        let node = this.data;
        const result = [];
        if (!intersects2(bbox, node)) return result;
        const toBBox = this.toBBox;
        const nodesToSearch = [];
        while (node) {
          for (let i7 = 0; i7 < node.children.length; i7++) {
            const child = node.children[i7];
            const childBBox = node.leaf ? toBBox(child) : child;
            if (intersects2(bbox, childBBox)) {
              if (node.leaf) result.push(child);
              else if (contains(bbox, childBBox)) this._all(child, result);
              else nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      }
      collides(bbox) {
        let node = this.data;
        if (!intersects2(bbox, node)) return false;
        const nodesToSearch = [];
        while (node) {
          for (let i7 = 0; i7 < node.children.length; i7++) {
            const child = node.children[i7];
            const childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects2(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) return true;
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      }
      load(data) {
        if (!(data && data.length)) return this;
        if (data.length < this._minEntries) {
          for (let i7 = 0; i7 < data.length; i7++) {
            this.insert(data[i7]);
          }
          return this;
        }
        let node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            const tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      }
      insert(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
      }
      clear() {
        this.data = createNode([]);
        return this;
      }
      remove(item, equalsFn) {
        if (!item) return this;
        let node = this.data;
        const bbox = this.toBBox(item);
        const path = [];
        const indexes = [];
        let i7, parent, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i7 = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            const index13 = findItem(item, node.children, equalsFn);
            if (index13 !== -1) {
              node.children.splice(index13, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path.push(node);
            indexes.push(i7);
            i7 = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i7++;
            node = parent.children[i7];
            goingUp = false;
          } else node = null;
        }
        return this;
      }
      toBBox(item) {
        return item;
      }
      compareMinX(a5, b8) {
        return a5.minX - b8.minX;
      }
      compareMinY(a5, b8) {
        return a5.minY - b8.minY;
      }
      toJSON() {
        return this.data;
      }
      fromJSON(data) {
        this.data = data;
        return this;
      }
      _all(node, result) {
        const nodesToSearch = [];
        while (node) {
          if (node.leaf) result.push(...node.children);
          else nodesToSearch.push(...node.children);
          node = nodesToSearch.pop();
        }
        return result;
      }
      _build(items, left, right, height) {
        const N5 = right - left + 1;
        let M9 = this._maxEntries;
        let node;
        if (N5 <= M9) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N5) / Math.log(M9));
          M9 = Math.ceil(N5 / Math.pow(M9, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        const N22 = Math.ceil(N5 / M9);
        const N1 = N22 * Math.ceil(Math.sqrt(M9));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (let i7 = left; i7 <= right; i7 += N1) {
          const right2 = Math.min(i7 + N1 - 1, right);
          multiSelect(items, i7, right2, N22, this.compareMinY);
          for (let j6 = i7; j6 <= right2; j6 += N22) {
            const right3 = Math.min(j6 + N22 - 1, right2);
            node.children.push(this._build(items, j6, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      }
      _chooseSubtree(bbox, node, level2, path) {
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level2) break;
          let minArea = Infinity;
          let minEnlargement = Infinity;
          let targetNode;
          for (let i7 = 0; i7 < node.children.length; i7++) {
            const child = node.children[i7];
            const area = bboxArea(child);
            const enlargement = enlargedArea(bbox, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      }
      _insert(item, level2, isNode) {
        const bbox = isNode ? item : this.toBBox(item);
        const insertPath = [];
        const node = this._chooseSubtree(bbox, this.data, level2, insertPath);
        node.children.push(item);
        extend3(node, bbox);
        while (level2 >= 0) {
          if (insertPath[level2].children.length > this._maxEntries) {
            this._split(insertPath, level2);
            level2--;
          } else break;
        }
        this._adjustParentBBoxes(bbox, insertPath, level2);
      }
      // split overflowed node into two
      _split(insertPath, level2) {
        const node = insertPath[level2];
        const M9 = node.children.length;
        const m8 = this._minEntries;
        this._chooseSplitAxis(node, m8, M9);
        const splitIndex = this._chooseSplitIndex(node, m8, M9);
        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level2) insertPath[level2 - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
      }
      _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      }
      _chooseSplitIndex(node, m8, M9) {
        let index13;
        let minOverlap = Infinity;
        let minArea = Infinity;
        for (let i7 = m8; i7 <= M9 - m8; i7++) {
          const bbox1 = distBBox(node, 0, i7, this.toBBox);
          const bbox2 = distBBox(node, i7, M9, this.toBBox);
          const overlap = intersectionArea(bbox1, bbox2);
          const area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index13 = i7;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index13 = i7;
            }
          }
        }
        return index13 || M9 - m8;
      }
      // sorts node children by the best axis for split
      _chooseSplitAxis(node, m8, M9) {
        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        const xMargin = this._allDistMargin(node, m8, M9, compareMinX);
        const yMargin = this._allDistMargin(node, m8, M9, compareMinY);
        if (xMargin < yMargin) node.children.sort(compareMinX);
      }
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin(node, m8, M9, compare) {
        node.children.sort(compare);
        const toBBox = this.toBBox;
        const leftBBox = distBBox(node, 0, m8, toBBox);
        const rightBBox = distBBox(node, M9 - m8, M9, toBBox);
        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (let i7 = m8; i7 < M9 - m8; i7++) {
          const child = node.children[i7];
          extend3(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (let i7 = M9 - m8 - 1; i7 >= m8; i7--) {
          const child = node.children[i7];
          extend3(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      }
      _adjustParentBBoxes(bbox, path, level2) {
        for (let i7 = level2; i7 >= 0; i7--) {
          extend3(path[i7], bbox);
        }
      }
      _condense(path) {
        for (let i7 = path.length - 1, siblings; i7 >= 0; i7--) {
          if (path[i7].children.length === 0) {
            if (i7 > 0) {
              siblings = path[i7 - 1].children;
              siblings.splice(siblings.indexOf(path[i7]), 1);
            } else this.clear();
          } else calcBBox(path[i7], this.toBBox);
        }
      }
    };
  }
});

// node_modules/ol/expr/expression.js
function isSpecific(type) {
  return type in typeNames;
}
function typeName(type) {
  const names36 = [];
  for (const namedType of namedTypes) {
    if (includesType(type, namedType)) {
      names36.push(typeNames[namedType]);
    }
  }
  if (names36.length === 0) {
    return "untyped";
  }
  if (names36.length < 3) {
    return names36.join(" or ");
  }
  return names36.slice(0, -1).join(", ") + ", or " + names36[names36.length - 1];
}
function includesType(broad, specific) {
  return (broad & specific) === specific;
}
function isType(type, expected) {
  return type === expected;
}
function newParsingContext() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: false,
    geometryType: false,
    mapState: false
  };
}
function parse3(encoded, expectedType, context) {
  switch (typeof encoded) {
    case "boolean": {
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded ? "true" : "false");
      }
      if (!includesType(expectedType, BooleanType)) {
        throw new Error(
          `got a boolean, but expected ${typeName(expectedType)}`
        );
      }
      return new LiteralExpression(BooleanType, encoded);
    }
    case "number": {
      if (isType(expectedType, SizeType)) {
        return new LiteralExpression(SizeType, toSize(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded.toString());
      }
      if (!includesType(expectedType, NumberType)) {
        throw new Error(`got a number, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(NumberType, encoded);
    }
    case "string": {
      if (isType(expectedType, ColorType)) {
        return new LiteralExpression(ColorType, fromString2(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (!includesType(expectedType, StringType)) {
        throw new Error(`got a string, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(StringType, encoded);
    }
    default: {
    }
  }
  if (!Array.isArray(encoded)) {
    throw new Error("expression must be an array or a primitive value");
  }
  if (encoded.length === 0) {
    throw new Error("empty expression");
  }
  if (typeof encoded[0] === "string") {
    return parseCallExpression(encoded, expectedType, context);
  }
  for (const item of encoded) {
    if (typeof item !== "number") {
      throw new Error("expected an array of numbers");
    }
  }
  if (isType(expectedType, SizeType)) {
    if (encoded.length !== 2) {
      throw new Error(
        `expected an array of two values for a size, got ${encoded.length}`
      );
    }
    return new LiteralExpression(SizeType, encoded);
  }
  if (isType(expectedType, ColorType)) {
    if (encoded.length === 3) {
      return new LiteralExpression(ColorType, [...encoded, 1]);
    }
    if (encoded.length === 4) {
      return new LiteralExpression(ColorType, encoded);
    }
    throw new Error(
      `expected an array of 3 or 4 values for a color, got ${encoded.length}`
    );
  }
  if (!includesType(expectedType, NumberArrayType)) {
    throw new Error(
      `got an array of numbers, but expected ${typeName(expectedType)}`
    );
  }
  return new LiteralExpression(NumberArrayType, encoded);
}
function withGetArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;
  const args = new Array(argsCount);
  for (let i7 = 0; i7 < argsCount; ++i7) {
    const key = encoded[i7 + 1];
    switch (typeof key) {
      case "number": {
        args[i7] = new LiteralExpression(NumberType, key);
        break;
      }
      case "string": {
        args[i7] = new LiteralExpression(StringType, key);
        break;
      }
      default: {
        throw new Error(
          `expected a string key or numeric array index for a get operation, got ${key}`
        );
      }
    }
    if (i7 === 0) {
      context.properties.add(String(key));
    }
  }
  return args;
}
function withVarArgs(encoded, returnType, context) {
  const name = encoded[1];
  if (typeof name !== "string") {
    throw new Error("expected a string argument for var operation");
  }
  context.variables.add(name);
  return [new LiteralExpression(StringType, name)];
}
function usesFeatureId(encoded, returnType, context) {
  context.featureId = true;
}
function usesGeometryType(encoded, returnType, context) {
  context.geometryType = true;
}
function usesMapState(encoded, returnType, context) {
  context.mapState = true;
}
function withNoArgs(encoded, returnType, context) {
  const operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error(`expected no arguments for ${operation} operation`);
  }
  return [];
}
function hasArgsCount(minArgs, maxArgs) {
  return function(encoded, returnType, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        const plural = minArgs === 1 ? "" : "s";
        throw new Error(
          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`
        );
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
      throw new Error(
        `expected ${range} arguments for ${operation}, got ${argCount}`
      );
    }
  };
}
function withArgsOfReturnType(encoded, returnType, context) {
  const argCount = encoded.length - 1;
  const args = new Array(argCount);
  for (let i7 = 0; i7 < argCount; ++i7) {
    const expression = parse3(encoded[i7 + 1], returnType, context);
    args[i7] = expression;
  }
  return args;
}
function withArgsOfType(argType) {
  return function(encoded, returnType, context) {
    const argCount = encoded.length - 1;
    const args = new Array(argCount);
    for (let i7 = 0; i7 < argCount; ++i7) {
      const expression = parse3(encoded[i7 + 1], argType, context);
      args[i7] = expression;
    }
    return args;
  };
}
function hasOddArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 0) {
    throw new Error(
      `expected an odd number of arguments for ${operation}, got ${argCount} instead`
    );
  }
}
function hasEvenArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 1) {
    throw new Error(
      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`
    );
  }
}
function withMatchArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;
  const inputType = StringType | NumberType | BooleanType;
  const input = parse3(encoded[1], inputType, context);
  const fallback = parse3(encoded[encoded.length - 1], returnType, context);
  const args = new Array(argsCount - 2);
  for (let i7 = 0; i7 < argsCount - 2; i7 += 2) {
    try {
      const match2 = parse3(encoded[i7 + 2], input.type, context);
      args[i7] = match2;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i7 + 1} of match expression: ${err.message}`
      );
    }
    try {
      const output = parse3(encoded[i7 + 3], fallback.type, context);
      args[i7 + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i7 + 2} of match expression: ${err.message}`
      );
    }
  }
  return [input, ...args, fallback];
}
function withInterpolateArgs(encoded, returnType, context) {
  const interpolationType = encoded[1];
  let base;
  switch (interpolationType[0]) {
    case "linear":
      base = 1;
      break;
    case "exponential":
      const b8 = interpolationType[1];
      if (typeof b8 !== "number" || b8 <= 0) {
        throw new Error(
          `expected a number base for exponential interpolation, got ${JSON.stringify(b8)} instead`
        );
      }
      base = b8;
      break;
    default:
      throw new Error(
        `invalid interpolation type: ${JSON.stringify(interpolationType)}`
      );
  }
  const interpolation = new LiteralExpression(NumberType, base);
  let input;
  try {
    input = parse3(encoded[2], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse argument 1 in interpolate expression: ${err.message}`
    );
  }
  const args = new Array(encoded.length - 3);
  for (let i7 = 0; i7 < args.length; i7 += 2) {
    try {
      const stop = parse3(encoded[i7 + 3], NumberType, context);
      args[i7] = stop;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i7 + 2} for interpolate expression: ${err.message}`
      );
    }
    try {
      const output = parse3(encoded[i7 + 4], returnType, context);
      args[i7 + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i7 + 3} for interpolate expression: ${err.message}`
      );
    }
  }
  return [interpolation, input, ...args];
}
function withCaseArgs(encoded, returnType, context) {
  const fallback = parse3(encoded[encoded.length - 1], returnType, context);
  const args = new Array(encoded.length - 1);
  for (let i7 = 0; i7 < args.length - 1; i7 += 2) {
    try {
      const condition = parse3(encoded[i7 + 1], BooleanType, context);
      args[i7] = condition;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i7} of case expression: ${err.message}`
      );
    }
    try {
      const output = parse3(encoded[i7 + 2], fallback.type, context);
      args[i7 + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i7 + 1} of case expression: ${err.message}`
      );
    }
  }
  args[args.length - 1] = fallback;
  return args;
}
function withInArgs(encoded, returnType, context) {
  let haystack = encoded[2];
  if (!Array.isArray(haystack)) {
    throw new Error(
      `the second argument for the "in" operator must be an array`
    );
  }
  let needleType;
  if (typeof haystack[0] === "string") {
    if (haystack[0] !== "literal") {
      throw new Error(
        `for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions`
      );
    }
    if (!Array.isArray(haystack[1])) {
      throw new Error(
        `failed to parse "in" expression: the literal operator must be followed by an array`
      );
    }
    haystack = haystack[1];
    needleType = StringType;
  } else {
    needleType = NumberType;
  }
  const args = new Array(haystack.length);
  for (let i7 = 0; i7 < args.length; i7++) {
    try {
      const arg = parse3(haystack[i7], needleType, context);
      args[i7] = arg;
    } catch (err) {
      throw new Error(
        `failed to parse haystack item ${i7} for "in" expression: ${err.message}`
      );
    }
  }
  const needle = parse3(encoded[1], needleType, context);
  return [needle, ...args];
}
function withPaletteArgs(encoded, returnType, context) {
  let index13;
  try {
    index13 = parse3(encoded[1], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse first argument in palette expression: ${err.message}`
    );
  }
  const colors = encoded[2];
  if (!Array.isArray(colors)) {
    throw new Error("the second argument of palette must be an array");
  }
  const parsedColors = new Array(colors.length);
  for (let i7 = 0; i7 < parsedColors.length; i7++) {
    let color;
    try {
      color = parse3(colors[i7], ColorType, context);
    } catch (err) {
      throw new Error(
        `failed to parse color at index ${i7} in palette expression: ${err.message}`
      );
    }
    if (!(color instanceof LiteralExpression)) {
      throw new Error(
        `the palette color at index ${i7} must be a literal value`
      );
    }
    parsedColors[i7] = color;
  }
  return [index13, ...parsedColors];
}
function createCallExpressionParser(...validators) {
  return function(encoded, returnType, context) {
    const operator = encoded[0];
    let args;
    for (let i7 = 0; i7 < validators.length; i7++) {
      const parsed = validators[i7](encoded, returnType, context);
      if (i7 == validators.length - 1) {
        if (!parsed) {
          throw new Error(
            "expected last argument validator to return the parsed args"
          );
        }
        args = parsed;
      }
    }
    return new CallExpression(returnType, operator, ...args);
  };
}
function parseCallExpression(encoded, returnType, context) {
  const operator = encoded[0];
  const parser = parsers[operator];
  if (!parser) {
    throw new Error(`unknown operator: ${operator}`);
  }
  return parser(encoded, returnType, context);
}
function computeGeometryType(geometry) {
  if (!geometry) {
    return "";
  }
  const type = geometry.getType();
  switch (type) {
    case "Point":
    case "LineString":
    case "Polygon":
      return type;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        type.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return computeGeometryType(
        /** @type {import("../geom/GeometryCollection.js").default} */
        geometry.getGeometries()[0]
      );
    default:
      return "";
  }
}
var numTypes, BooleanType, NumberType, StringType, ColorType, NumberArrayType, SizeType, AnyType, typeNames, namedTypes, LiteralExpression, CallExpression, Ops, parsers;
var init_expression = __esm({
  "node_modules/ol/expr/expression.js"() {
    init_array();
    init_color();
    init_size();
    numTypes = 0;
    BooleanType = 1 << numTypes++;
    NumberType = 1 << numTypes++;
    StringType = 1 << numTypes++;
    ColorType = 1 << numTypes++;
    NumberArrayType = 1 << numTypes++;
    SizeType = 1 << numTypes++;
    AnyType = Math.pow(2, numTypes) - 1;
    typeNames = {
      [BooleanType]: "boolean",
      [NumberType]: "number",
      [StringType]: "string",
      [ColorType]: "color",
      [NumberArrayType]: "number[]",
      [SizeType]: "size"
    };
    namedTypes = Object.keys(typeNames).map(Number).sort(ascending);
    LiteralExpression = class {
      /**
       * @param {number} type The value type.
       * @param {LiteralValue} value The literal value.
       */
      constructor(type, value) {
        if (!isSpecific(type)) {
          throw new Error(
            `literal expressions must have a specific type, got ${typeName(type)}`
          );
        }
        this.type = type;
        this.value = value;
      }
    };
    CallExpression = class {
      /**
       * @param {number} type The return type.
       * @param {string} operator The operator.
       * @param {...Expression} args The arguments.
       */
      constructor(type, operator, ...args) {
        this.type = type;
        this.operator = operator;
        this.args = args;
      }
    };
    Ops = {
      Get: "get",
      Var: "var",
      Concat: "concat",
      GeometryType: "geometry-type",
      LineMetric: "line-metric",
      Any: "any",
      All: "all",
      Not: "!",
      Resolution: "resolution",
      Zoom: "zoom",
      Time: "time",
      Equal: "==",
      NotEqual: "!=",
      GreaterThan: ">",
      GreaterThanOrEqualTo: ">=",
      LessThan: "<",
      LessThanOrEqualTo: "<=",
      Multiply: "*",
      Divide: "/",
      Add: "+",
      Subtract: "-",
      Clamp: "clamp",
      Mod: "%",
      Pow: "^",
      Abs: "abs",
      Floor: "floor",
      Ceil: "ceil",
      Round: "round",
      Sin: "sin",
      Cos: "cos",
      Atan: "atan",
      Sqrt: "sqrt",
      Match: "match",
      Between: "between",
      Interpolate: "interpolate",
      Coalesce: "coalesce",
      Case: "case",
      In: "in",
      Number: "number",
      String: "string",
      Array: "array",
      Color: "color",
      Id: "id",
      Band: "band",
      Palette: "palette",
      ToString: "to-string",
      Has: "has"
    };
    parsers = {
      [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
      [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),
      [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
      [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),
      [Ops.Concat]: createCallExpressionParser(
        hasArgsCount(2, Infinity),
        withArgsOfType(StringType)
      ),
      [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),
      [Ops.LineMetric]: createCallExpressionParser(withNoArgs),
      [Ops.Resolution]: createCallExpressionParser(usesMapState, withNoArgs),
      [Ops.Zoom]: createCallExpressionParser(usesMapState, withNoArgs),
      [Ops.Time]: createCallExpressionParser(usesMapState, withNoArgs),
      [Ops.Any]: createCallExpressionParser(
        hasArgsCount(2, Infinity),
        withArgsOfType(BooleanType)
      ),
      [Ops.All]: createCallExpressionParser(
        hasArgsCount(2, Infinity),
        withArgsOfType(BooleanType)
      ),
      [Ops.Not]: createCallExpressionParser(
        hasArgsCount(1, 1),
        withArgsOfType(BooleanType)
      ),
      [Ops.Equal]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(AnyType)
      ),
      [Ops.NotEqual]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(AnyType)
      ),
      [Ops.GreaterThan]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(NumberType)
      ),
      [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(NumberType)
      ),
      [Ops.LessThan]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(NumberType)
      ),
      [Ops.LessThanOrEqualTo]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(NumberType)
      ),
      [Ops.Multiply]: createCallExpressionParser(
        hasArgsCount(2, Infinity),
        withArgsOfReturnType
      ),
      [Ops.Coalesce]: createCallExpressionParser(
        hasArgsCount(2, Infinity),
        withArgsOfReturnType
      ),
      [Ops.Divide]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(NumberType)
      ),
      [Ops.Add]: createCallExpressionParser(
        hasArgsCount(2, Infinity),
        withArgsOfType(NumberType)
      ),
      [Ops.Subtract]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(NumberType)
      ),
      [Ops.Clamp]: createCallExpressionParser(
        hasArgsCount(3, 3),
        withArgsOfType(NumberType)
      ),
      [Ops.Mod]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(NumberType)
      ),
      [Ops.Pow]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withArgsOfType(NumberType)
      ),
      [Ops.Abs]: createCallExpressionParser(
        hasArgsCount(1, 1),
        withArgsOfType(NumberType)
      ),
      [Ops.Floor]: createCallExpressionParser(
        hasArgsCount(1, 1),
        withArgsOfType(NumberType)
      ),
      [Ops.Ceil]: createCallExpressionParser(
        hasArgsCount(1, 1),
        withArgsOfType(NumberType)
      ),
      [Ops.Round]: createCallExpressionParser(
        hasArgsCount(1, 1),
        withArgsOfType(NumberType)
      ),
      [Ops.Sin]: createCallExpressionParser(
        hasArgsCount(1, 1),
        withArgsOfType(NumberType)
      ),
      [Ops.Cos]: createCallExpressionParser(
        hasArgsCount(1, 1),
        withArgsOfType(NumberType)
      ),
      [Ops.Atan]: createCallExpressionParser(
        hasArgsCount(1, 2),
        withArgsOfType(NumberType)
      ),
      [Ops.Sqrt]: createCallExpressionParser(
        hasArgsCount(1, 1),
        withArgsOfType(NumberType)
      ),
      [Ops.Match]: createCallExpressionParser(
        hasArgsCount(4, Infinity),
        hasEvenArgs,
        withMatchArgs
      ),
      [Ops.Between]: createCallExpressionParser(
        hasArgsCount(3, 3),
        withArgsOfType(NumberType)
      ),
      [Ops.Interpolate]: createCallExpressionParser(
        hasArgsCount(6, Infinity),
        hasEvenArgs,
        withInterpolateArgs
      ),
      [Ops.Case]: createCallExpressionParser(
        hasArgsCount(3, Infinity),
        hasOddArgs,
        withCaseArgs
      ),
      [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),
      [Ops.Number]: createCallExpressionParser(
        hasArgsCount(1, Infinity),
        withArgsOfType(AnyType)
      ),
      [Ops.String]: createCallExpressionParser(
        hasArgsCount(1, Infinity),
        withArgsOfType(AnyType)
      ),
      [Ops.Array]: createCallExpressionParser(
        hasArgsCount(1, Infinity),
        withArgsOfType(NumberType)
      ),
      [Ops.Color]: createCallExpressionParser(
        hasArgsCount(1, 4),
        withArgsOfType(NumberType)
      ),
      [Ops.Band]: createCallExpressionParser(
        hasArgsCount(1, 3),
        withArgsOfType(NumberType)
      ),
      [Ops.Palette]: createCallExpressionParser(
        hasArgsCount(2, 2),
        withPaletteArgs
      ),
      [Ops.ToString]: createCallExpressionParser(
        hasArgsCount(1, 1),
        withArgsOfType(BooleanType | NumberType | StringType | ColorType)
      )
    };
  }
});

// node_modules/ol/expr/cpu.js
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function buildExpression(encoded, type, context) {
  const expression = parse3(encoded, type, context);
  return compileExpression(expression, context);
}
function compileExpression(expression, context) {
  if (expression instanceof LiteralExpression) {
    if (expression.type === ColorType && typeof expression.value === "string") {
      const colorValue = fromString2(expression.value);
      return function() {
        return colorValue;
      };
    }
    return function() {
      return expression.value;
    };
  }
  const operator = expression.operator;
  switch (operator) {
    case Ops.Number:
    case Ops.String:
    case Ops.Coalesce: {
      return compileAssertionExpression(expression, context);
    }
    case Ops.Get:
    case Ops.Var:
    case Ops.Has: {
      return compileAccessorExpression(expression, context);
    }
    case Ops.Id: {
      return (context2) => context2.featureId;
    }
    case Ops.GeometryType: {
      return (context2) => context2.geometryType;
    }
    case Ops.Concat: {
      const args = expression.args.map((e3) => compileExpression(e3, context));
      return (context2) => "".concat(...args.map((arg) => arg(context2).toString()));
    }
    case Ops.Resolution: {
      return (context2) => context2.resolution;
    }
    case Ops.Any:
    case Ops.All:
    case Ops.Between:
    case Ops.In:
    case Ops.Not: {
      return compileLogicalExpression(expression, context);
    }
    case Ops.Equal:
    case Ops.NotEqual:
    case Ops.LessThan:
    case Ops.LessThanOrEqualTo:
    case Ops.GreaterThan:
    case Ops.GreaterThanOrEqualTo: {
      return compileComparisonExpression(expression, context);
    }
    case Ops.Multiply:
    case Ops.Divide:
    case Ops.Add:
    case Ops.Subtract:
    case Ops.Clamp:
    case Ops.Mod:
    case Ops.Pow:
    case Ops.Abs:
    case Ops.Floor:
    case Ops.Ceil:
    case Ops.Round:
    case Ops.Sin:
    case Ops.Cos:
    case Ops.Atan:
    case Ops.Sqrt: {
      return compileNumericExpression(expression, context);
    }
    case Ops.Case: {
      return compileCaseExpression(expression, context);
    }
    case Ops.Match: {
      return compileMatchExpression(expression, context);
    }
    case Ops.Interpolate: {
      return compileInterpolateExpression(expression, context);
    }
    case Ops.ToString: {
      return compileConvertExpression(expression, context);
    }
    default: {
      throw new Error(`Unsupported operator ${operator}`);
    }
  }
}
function compileAssertionExpression(expression, context) {
  const type = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i7 = 0; i7 < length; ++i7) {
    args[i7] = compileExpression(expression.args[i7], context);
  }
  switch (type) {
    case Ops.Coalesce: {
      return (context2) => {
        for (let i7 = 0; i7 < length; ++i7) {
          const value = args[i7](context2);
          if (typeof value !== "undefined" && value !== null) {
            return value;
          }
        }
        throw new Error("Expected one of the values to be non-null");
      };
    }
    case Ops.Number:
    case Ops.String: {
      return (context2) => {
        for (let i7 = 0; i7 < length; ++i7) {
          const value = args[i7](context2);
          if (typeof value === type) {
            return value;
          }
        }
        throw new Error(`Expected one of the values to be a ${type}`);
      };
    }
    default: {
      throw new Error(`Unsupported assertion operator ${type}`);
    }
  }
}
function compileAccessorExpression(expression, context) {
  const nameExpression = (
    /** @type {LiteralExpression} */
    expression.args[0]
  );
  const name = (
    /** @type {string} */
    nameExpression.value
  );
  switch (expression.operator) {
    case Ops.Get: {
      return (context2) => {
        const args = expression.args;
        let value = context2.properties[name];
        for (let i7 = 1, ii = args.length; i7 < ii; ++i7) {
          const keyExpression = (
            /** @type {LiteralExpression} */
            args[i7]
          );
          const key = (
            /** @type {string|number} */
            keyExpression.value
          );
          value = value[key];
        }
        return value;
      };
    }
    case Ops.Var: {
      return (context2) => context2.variables[name];
    }
    case Ops.Has: {
      return (context2) => {
        const args = expression.args;
        if (!(name in context2.properties)) {
          return false;
        }
        let value = context2.properties[name];
        for (let i7 = 1, ii = args.length; i7 < ii; ++i7) {
          const keyExpression = (
            /** @type {LiteralExpression} */
            args[i7]
          );
          const key = (
            /** @type {string|number} */
            keyExpression.value
          );
          if (!value || !Object.hasOwn(value, key)) {
            return false;
          }
          value = value[key];
        }
        return true;
      };
    }
    default: {
      throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
}
function compileComparisonExpression(expression, context) {
  const op = expression.operator;
  const left = compileExpression(expression.args[0], context);
  const right = compileExpression(expression.args[1], context);
  switch (op) {
    case Ops.Equal: {
      return (context2) => left(context2) === right(context2);
    }
    case Ops.NotEqual: {
      return (context2) => left(context2) !== right(context2);
    }
    case Ops.LessThan: {
      return (context2) => left(context2) < right(context2);
    }
    case Ops.LessThanOrEqualTo: {
      return (context2) => left(context2) <= right(context2);
    }
    case Ops.GreaterThan: {
      return (context2) => left(context2) > right(context2);
    }
    case Ops.GreaterThanOrEqualTo: {
      return (context2) => left(context2) >= right(context2);
    }
    default: {
      throw new Error(`Unsupported comparison operator ${op}`);
    }
  }
}
function compileLogicalExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i7 = 0; i7 < length; ++i7) {
    args[i7] = compileExpression(expression.args[i7], context);
  }
  switch (op) {
    case Ops.Any: {
      return (context2) => {
        for (let i7 = 0; i7 < length; ++i7) {
          if (args[i7](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.All: {
      return (context2) => {
        for (let i7 = 0; i7 < length; ++i7) {
          if (!args[i7](context2)) {
            return false;
          }
        }
        return true;
      };
    }
    case Ops.Between: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        const max = args[2](context2);
        return value >= min && value <= max;
      };
    }
    case Ops.In: {
      return (context2) => {
        const value = args[0](context2);
        for (let i7 = 1; i7 < length; ++i7) {
          if (value === args[i7](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.Not: {
      return (context2) => !args[0](context2);
    }
    default: {
      throw new Error(`Unsupported logical operator ${op}`);
    }
  }
}
function compileNumericExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i7 = 0; i7 < length; ++i7) {
    args[i7] = compileExpression(expression.args[i7], context);
  }
  switch (op) {
    case Ops.Multiply: {
      return (context2) => {
        let value = 1;
        for (let i7 = 0; i7 < length; ++i7) {
          value *= args[i7](context2);
        }
        return value;
      };
    }
    case Ops.Divide: {
      return (context2) => args[0](context2) / args[1](context2);
    }
    case Ops.Add: {
      return (context2) => {
        let value = 0;
        for (let i7 = 0; i7 < length; ++i7) {
          value += args[i7](context2);
        }
        return value;
      };
    }
    case Ops.Subtract: {
      return (context2) => args[0](context2) - args[1](context2);
    }
    case Ops.Clamp: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        if (value < min) {
          return min;
        }
        const max = args[2](context2);
        if (value > max) {
          return max;
        }
        return value;
      };
    }
    case Ops.Mod: {
      return (context2) => args[0](context2) % args[1](context2);
    }
    case Ops.Pow: {
      return (context2) => Math.pow(args[0](context2), args[1](context2));
    }
    case Ops.Abs: {
      return (context2) => Math.abs(args[0](context2));
    }
    case Ops.Floor: {
      return (context2) => Math.floor(args[0](context2));
    }
    case Ops.Ceil: {
      return (context2) => Math.ceil(args[0](context2));
    }
    case Ops.Round: {
      return (context2) => Math.round(args[0](context2));
    }
    case Ops.Sin: {
      return (context2) => Math.sin(args[0](context2));
    }
    case Ops.Cos: {
      return (context2) => Math.cos(args[0](context2));
    }
    case Ops.Atan: {
      if (length === 2) {
        return (context2) => Math.atan2(args[0](context2), args[1](context2));
      }
      return (context2) => Math.atan(args[0](context2));
    }
    case Ops.Sqrt: {
      return (context2) => Math.sqrt(args[0](context2));
    }
    default: {
      throw new Error(`Unsupported numeric operator ${op}`);
    }
  }
}
function compileCaseExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i7 = 0; i7 < length; ++i7) {
    args[i7] = compileExpression(expression.args[i7], context);
  }
  return (context2) => {
    for (let i7 = 0; i7 < length - 1; i7 += 2) {
      const condition = args[i7](context2);
      if (condition) {
        return args[i7 + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileMatchExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i7 = 0; i7 < length; ++i7) {
    args[i7] = compileExpression(expression.args[i7], context);
  }
  return (context2) => {
    const value = args[0](context2);
    for (let i7 = 1; i7 < length - 1; i7 += 2) {
      if (value === args[i7](context2)) {
        return args[i7 + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileInterpolateExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i7 = 0; i7 < length; ++i7) {
    args[i7] = compileExpression(expression.args[i7], context);
  }
  return (context2) => {
    const base = args[0](context2);
    const value = args[1](context2);
    let previousInput;
    let previousOutput;
    for (let i7 = 2; i7 < length; i7 += 2) {
      const input = args[i7](context2);
      let output = args[i7 + 1](context2);
      const isColor = Array.isArray(output);
      if (isColor) {
        output = withAlpha(output);
      }
      if (input >= value) {
        if (i7 === 2) {
          return output;
        }
        if (isColor) {
          return interpolateColor(
            base,
            value,
            previousInput,
            previousOutput,
            input,
            output
          );
        }
        return interpolateNumber(
          base,
          value,
          previousInput,
          previousOutput,
          input,
          output
        );
      }
      previousInput = input;
      previousOutput = output;
    }
    return previousOutput;
  };
}
function compileConvertExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i7 = 0; i7 < length; ++i7) {
    args[i7] = compileExpression(expression.args[i7], context);
  }
  switch (op) {
    case Ops.ToString: {
      return (context2) => {
        const value = args[0](context2);
        if (expression.args[0].type === ColorType) {
          return toString2(value);
        }
        return value.toString();
      };
    }
    default: {
      throw new Error(`Unsupported convert operator ${op}`);
    }
  }
}
function interpolateNumber(base, value, input1, output1, input2, output2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return output1;
  }
  const along = value - input1;
  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
  return output1 + factor * (output2 - output1);
}
function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return rgba1;
  }
  const lcha1 = rgbaToLcha(rgba1);
  const lcha2 = rgbaToLcha(rgba2);
  let deltaHue = lcha2[2] - lcha1[2];
  if (deltaHue > 180) {
    deltaHue -= 360;
  } else if (deltaHue < -180) {
    deltaHue += 360;
  }
  const lcha = [
    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
  ];
  return lchaToRgba(lcha);
}
var init_cpu = __esm({
  "node_modules/ol/expr/cpu.js"() {
    init_color();
    init_expression();
  }
});

// node_modules/ol/render/canvas/style.js
function always2(context) {
  return true;
}
function rulesToStyleFunction(rules) {
  const parsingContext = newParsingContext();
  const evaluator = buildRuleSet(rules, parsingContext);
  const evaluationContext = newEvaluationContext();
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    if (parsingContext.geometryType) {
      evaluationContext.geometryType = computeGeometryType(
        feature.getGeometry()
      );
    }
    return evaluator(evaluationContext);
  };
}
function flatStylesToStyleFunction(flatStyles) {
  const parsingContext = newParsingContext();
  const length = flatStyles.length;
  const evaluators = new Array(length);
  for (let i7 = 0; i7 < length; ++i7) {
    evaluators[i7] = buildStyle(flatStyles[i7], parsingContext);
  }
  const evaluationContext = newEvaluationContext();
  const styles = new Array(length);
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    let nonNullCount = 0;
    for (let i7 = 0; i7 < length; ++i7) {
      const style = evaluators[i7](evaluationContext);
      if (style) {
        styles[nonNullCount] = style;
        nonNullCount += 1;
      }
    }
    styles.length = nonNullCount;
    return styles;
  };
}
function buildRuleSet(rules, context) {
  const length = rules.length;
  const compiledRules = new Array(length);
  for (let i7 = 0; i7 < length; ++i7) {
    const rule = rules[i7];
    const filter = "filter" in rule ? buildExpression(rule.filter, BooleanType, context) : always2;
    let styles;
    if (Array.isArray(rule.style)) {
      const styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (let j6 = 0; j6 < styleLength; ++j6) {
        styles[j6] = buildStyle(rule.style[j6], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }
    compiledRules[i7] = { filter, styles };
  }
  return function(context2) {
    const styles = [];
    let someMatched = false;
    for (let i7 = 0; i7 < length; ++i7) {
      const filterEvaluator = compiledRules[i7].filter;
      if (!filterEvaluator(context2)) {
        continue;
      }
      if (rules[i7].else && someMatched) {
        continue;
      }
      someMatched = true;
      for (const styleEvaluator of compiledRules[i7].styles) {
        const style = styleEvaluator(context2);
        if (!style) {
          continue;
        }
        styles.push(style);
      }
    }
    return styles;
  };
}
function buildStyle(flatStyle, context) {
  const evaluateFill = buildFill(flatStyle, "", context);
  const evaluateStroke = buildStroke(flatStyle, "", context);
  const evaluateText = buildText(flatStyle, context);
  const evaluateImage = buildImage(flatStyle, context);
  const evaluateZIndex = numberEvaluator(flatStyle, "z-index", context);
  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty2(flatStyle)) {
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(flatStyle)
    );
  }
  const style = new Style_default();
  return function(context2) {
    let empty = true;
    if (evaluateFill) {
      const fill = evaluateFill(context2);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      const stroke = evaluateStroke(context2);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      const text2 = evaluateText(context2);
      if (text2) {
        empty = false;
      }
      style.setText(text2);
    }
    if (evaluateImage) {
      const image = evaluateImage(context2);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context2));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}
function buildFill(flatStyle, prefix, context) {
  let evaluateColor;
  if (prefix + "fill-pattern-src" in flatStyle) {
    evaluateColor = patternEvaluator(flatStyle, prefix + "fill-", context);
  } else {
    if (flatStyle[prefix + "fill-color"] === "none") {
      return (context2) => null;
    }
    evaluateColor = colorLikeEvaluator(
      flatStyle,
      prefix + "fill-color",
      context
    );
  }
  if (!evaluateColor) {
    return null;
  }
  const fill = new Fill_default();
  return function(context2) {
    const color = evaluateColor(context2);
    if (color === NO_COLOR) {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}
function buildStroke(flatStyle, prefix, context) {
  const evaluateWidth = numberEvaluator(
    flatStyle,
    prefix + "stroke-width",
    context
  );
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + "stroke-color",
    context
  );
  if (!evaluateWidth && !evaluateColor) {
    return null;
  }
  const evaluateLineCap = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-cap",
    context
  );
  const evaluateLineJoin = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-join",
    context
  );
  const evaluateLineDash = numberArrayEvaluator(
    flatStyle,
    prefix + "stroke-line-dash",
    context
  );
  const evaluateLineDashOffset = numberEvaluator(
    flatStyle,
    prefix + "stroke-line-dash-offset",
    context
  );
  const evaluateMiterLimit = numberEvaluator(
    flatStyle,
    prefix + "stroke-miter-limit",
    context
  );
  const stroke = new Stroke_default();
  return function(context2) {
    if (evaluateColor) {
      const color = evaluateColor(context2);
      if (color === NO_COLOR) {
        return null;
      }
      stroke.setColor(color);
    }
    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context2));
    }
    if (evaluateLineCap) {
      const lineCap = evaluateLineCap(context2);
      if (lineCap !== "butt" && lineCap !== "round" && lineCap !== "square") {
        throw new Error("Expected butt, round, or square line cap");
      }
      stroke.setLineCap(lineCap);
    }
    if (evaluateLineJoin) {
      const lineJoin = evaluateLineJoin(context2);
      if (lineJoin !== "bevel" && lineJoin !== "round" && lineJoin !== "miter") {
        throw new Error("Expected bevel, round, or miter line join");
      }
      stroke.setLineJoin(lineJoin);
    }
    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context2));
    }
    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context2));
    }
    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context2));
    }
    return stroke;
  };
}
function buildText(flatStyle, context) {
  const prefix = "text-";
  const evaluateValue = stringEvaluator(flatStyle, prefix + "value", context);
  if (!evaluateValue) {
    return null;
  }
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateBackgroundFill = buildFill(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateBackgroundStroke = buildStroke(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateFont = stringEvaluator(flatStyle, prefix + "font", context);
  const evaluateMaxAngle = numberEvaluator(
    flatStyle,
    prefix + "max-angle",
    context
  );
  const evaluateOffsetX = numberEvaluator(
    flatStyle,
    prefix + "offset-x",
    context
  );
  const evaluateOffsetY = numberEvaluator(
    flatStyle,
    prefix + "offset-y",
    context
  );
  const evaluateOverflow = booleanEvaluator(
    flatStyle,
    prefix + "overflow",
    context
  );
  const evaluatePlacement = stringEvaluator(
    flatStyle,
    prefix + "placement",
    context
  );
  const evaluateRepeat = numberEvaluator(flatStyle, prefix + "repeat", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateAlign = stringEvaluator(flatStyle, prefix + "align", context);
  const evaluateJustify = stringEvaluator(
    flatStyle,
    prefix + "justify",
    context
  );
  const evaluateBaseline = stringEvaluator(
    flatStyle,
    prefix + "baseline",
    context
  );
  const evaluateKeepUpright = booleanEvaluator(
    flatStyle,
    prefix + "keep-upright",
    context
  );
  const evaluatePadding = numberArrayEvaluator(
    flatStyle,
    prefix + "padding",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const text2 = new Text_default({ declutterMode });
  return function(context2) {
    text2.setText(evaluateValue(context2));
    if (evaluateFill) {
      text2.setFill(evaluateFill(context2));
    }
    if (evaluateBackgroundFill) {
      text2.setBackgroundFill(evaluateBackgroundFill(context2));
    }
    if (evaluateStroke) {
      text2.setStroke(evaluateStroke(context2));
    }
    if (evaluateBackgroundStroke) {
      text2.setBackgroundStroke(evaluateBackgroundStroke(context2));
    }
    if (evaluateFont) {
      text2.setFont(evaluateFont(context2));
    }
    if (evaluateMaxAngle) {
      text2.setMaxAngle(evaluateMaxAngle(context2));
    }
    if (evaluateOffsetX) {
      text2.setOffsetX(evaluateOffsetX(context2));
    }
    if (evaluateOffsetY) {
      text2.setOffsetY(evaluateOffsetY(context2));
    }
    if (evaluateOverflow) {
      text2.setOverflow(evaluateOverflow(context2));
    }
    if (evaluatePlacement) {
      const placement = evaluatePlacement(context2);
      if (placement !== "point" && placement !== "line") {
        throw new Error("Expected point or line for text-placement");
      }
      text2.setPlacement(placement);
    }
    if (evaluateRepeat) {
      text2.setRepeat(evaluateRepeat(context2));
    }
    if (evaluateScale) {
      text2.setScale(evaluateScale(context2));
    }
    if (evaluateRotateWithView) {
      text2.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateRotation) {
      text2.setRotation(evaluateRotation(context2));
    }
    if (evaluateAlign) {
      const textAlign = evaluateAlign(context2);
      if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right" && textAlign !== "end" && textAlign !== "start") {
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      }
      text2.setTextAlign(textAlign);
    }
    if (evaluateJustify) {
      const justify = evaluateJustify(context2);
      if (justify !== "left" && justify !== "right" && justify !== "center") {
        throw new Error("Expected left, right, or center for text-justify");
      }
      text2.setJustify(justify);
    }
    if (evaluateBaseline) {
      const textBaseline = evaluateBaseline(context2);
      if (textBaseline !== "bottom" && textBaseline !== "top" && textBaseline !== "middle" && textBaseline !== "alphabetic" && textBaseline !== "hanging") {
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      }
      text2.setTextBaseline(textBaseline);
    }
    if (evaluatePadding) {
      text2.setPadding(evaluatePadding(context2));
    }
    if (evaluateKeepUpright) {
      text2.setKeepUpright(evaluateKeepUpright(context2));
    }
    return text2;
  };
}
function buildImage(flatStyle, context) {
  if ("icon-src" in flatStyle) {
    return buildIcon(flatStyle, context);
  }
  if ("shape-points" in flatStyle) {
    return buildShape(flatStyle, context);
  }
  if ("circle-radius" in flatStyle) {
    return buildCircle(flatStyle, context);
  }
  return null;
}
function buildIcon(flatStyle, context) {
  const prefix = "icon-";
  const srcName = prefix + "src";
  const src = requireString(flatStyle[srcName], srcName);
  const evaluateAnchor = coordinateEvaluator(
    flatStyle,
    prefix + "anchor",
    context
  );
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateOpacity = numberEvaluator(
    flatStyle,
    prefix + "opacity",
    context
  );
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + "anchor-origin");
  const anchorXUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-x-units"
  );
  const anchorYUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-y-units"
  );
  const color = optionalColorLike(flatStyle, prefix + "color");
  const crossOrigin = optionalString(flatStyle, prefix + "cross-origin");
  const offset = optionalNumberArray(flatStyle, prefix + "offset");
  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + "offset-origin");
  const width = optionalNumber(flatStyle, prefix + "width");
  const height = optionalNumber(flatStyle, prefix + "height");
  const size = optionalSize(flatStyle, prefix + "size");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const icon = new Icon_default({
    src,
    anchorOrigin,
    anchorXUnits,
    anchorYUnits,
    color,
    crossOrigin,
    offset,
    offsetOrigin,
    height,
    width,
    size,
    declutterMode
  });
  return function(context2) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context2));
    }
    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      icon.setScale(evaluateScale(context2));
    }
    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context2));
    }
    return icon;
  };
}
function buildShape(flatStyle, context) {
  const prefix = "shape-";
  const pointsName = prefix + "points";
  const radiusName = prefix + "radius";
  const points = requireNumber(flatStyle[pointsName], pointsName);
  const radius = requireNumber(flatStyle[radiusName], radiusName);
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const radius2 = optionalNumber(flatStyle, prefix + "radius2");
  const angle = optionalNumber(flatStyle, prefix + "angle");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const shape = new RegularShape_default({
    points,
    radius,
    radius2,
    angle,
    declutterMode
  });
  return function(context2) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context2));
    }
    return shape;
  };
}
function buildCircle(flatStyle, context) {
  const prefix = "circle-";
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateRadius = numberEvaluator(flatStyle, prefix + "radius", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const circle = new Circle_default2({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode
  });
  return function(context2) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context2));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context2));
    }
    return circle;
  };
}
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return void 0;
  }
  const evaluator = buildExpression(flatStyle[name], NumberType, context);
  return function(context2) {
    return requireNumber(evaluator(context2), name);
  };
}
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], StringType, context);
  return function(context2) {
    return requireString(evaluator(context2), name);
  };
}
function patternEvaluator(flatStyle, prefix, context) {
  const srcEvaluator = stringEvaluator(
    flatStyle,
    prefix + "pattern-src",
    context
  );
  const offsetEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-offset",
    context
  );
  const patternSizeEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-size",
    context
  );
  const colorEvaluator = colorLikeEvaluator(
    flatStyle,
    prefix + "color",
    context
  );
  return function(context2) {
    return {
      src: srcEvaluator(context2),
      offset: offsetEvaluator && offsetEvaluator(context2),
      size: patternSizeEvaluator && patternSizeEvaluator(context2),
      color: colorEvaluator && colorEvaluator(context2)
    };
  };
}
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], BooleanType, context);
  return function(context2) {
    const value = evaluator(context2);
    if (typeof value !== "boolean") {
      throw new Error(`Expected a boolean for ${name}`);
    }
    return value;
  };
}
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], ColorType, context);
  return function(context2) {
    return requireColorLike(evaluator(context2), name);
  };
}
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireNumberArray(evaluator(context2), name);
  };
}
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    const array = requireNumberArray(evaluator(context2), name);
    if (array.length !== 2) {
      throw new Error(`Expected two numbers for ${name}`);
    }
    return array;
  };
}
function sizeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireSize(evaluator(context2), name);
  };
}
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    NumberArrayType | NumberType,
    context
  );
  return function(context2) {
    return requireSizeLike(evaluator(context2), name);
  };
}
function optionalNumber(flatStyle, property) {
  const value = flatStyle[property];
  if (value === void 0) {
    return void 0;
  }
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function optionalSize(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded === "number") {
    return toSize(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  if (encoded.length !== 2 || typeof encoded[0] !== "number" || typeof encoded[1] !== "number") {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  return encoded;
}
function optionalString(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return encoded;
}
function optionalIconOrigin(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "bottom-left" && encoded !== "bottom-right" && encoded !== "top-left" && encoded !== "top-right") {
    throw new Error(
      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`
    );
  }
  return encoded;
}
function optionalIconAnchorUnits(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "pixels" && encoded !== "fraction") {
    throw new Error(`Expected pixels or fraction for ${property}`);
  }
  return encoded;
}
function optionalNumberArray(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireNumberArray(encoded, property);
}
function optionalDeclutterMode(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  if (encoded !== "declutter" && encoded !== "obstacle" && encoded !== "none") {
    throw new Error(`Expected declutter, obstacle, or none for ${property}`);
  }
  return encoded;
}
function optionalColorLike(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireColorLike(encoded, property);
}
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error(`Expected an array for ${property}`);
  }
  const length = value.length;
  for (let i7 = 0; i7 < length; ++i7) {
    if (typeof value[i7] !== "number") {
      throw new Error(`Expected an array of numbers for ${property}`);
    }
  }
  return value;
}
function requireString(value, property) {
  if (typeof value !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return value;
}
function requireNumber(value, property) {
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function requireColorLike(value, property) {
  if (typeof value === "string") {
    return value;
  }
  const array = requireNumberArray(value, property);
  const length = array.length;
  if (length < 3 || length > 4) {
    throw new Error(`Expected a color with 3 or 4 values for ${property}`);
  }
  return array;
}
function requireSize(value, property) {
  const size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error(`Expected an array of two numbers for ${property}`);
  }
  return size;
}
function requireSizeLike(value, property) {
  if (typeof value === "number") {
    return value;
  }
  return requireSize(value, property);
}
var init_style2 = __esm({
  "node_modules/ol/render/canvas/style.js"() {
    init_color();
    init_cpu();
    init_expression();
    init_obj();
    init_size();
    init_Circle2();
    init_Fill();
    init_Icon();
    init_RegularShape();
    init_Stroke();
    init_Style();
    init_Text();
  }
});

// node_modules/ol/ViewProperty.js
var ViewProperty_default;
var init_ViewProperty = __esm({
  "node_modules/ol/ViewProperty.js"() {
    ViewProperty_default = {
      CENTER: "center",
      RESOLUTION: "resolution",
      ROTATION: "rotation"
    };
  }
});

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x4 = clamp(center[0], minX, maxX);
      let y5 = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x4 += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y5 += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x4, y5];
    }
  );
}
function none(center) {
  return center;
}
var init_centerconstraint = __esm({
  "node_modules/ol/centerconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/easing.js
function easeIn(t4) {
  return Math.pow(t4, 3);
}
function easeOut(t4) {
  return 1 - easeIn(1 - t4);
}
function inAndOut(t4) {
  return 3 * t4 * t4 - 2 * t4 * t4 * t4;
}
var init_easing = __esm({
  "node_modules/ol/easing.js"() {
  }
});

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z3 = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z3] > cappedMaxRes && z3 < resolutions.length - 1) {
          return resolutions[z3 + 1];
        }
        return resolutions[z3];
      }
      return void 0;
    }
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    }
  );
}
var init_resolutionconstraint = __esm({
  "node_modules/ol/resolutionconstraint.js"() {
    init_array();
    init_extent();
    init_math();
  }
});

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n6) {
  const theta = 2 * Math.PI / n6;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    }
  );
}
function createSnapToZero(tolerance) {
  const t4 = tolerance === void 0 ? toRadians(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t4) {
        return 0;
      }
      return rotation;
    }
  );
}
var init_rotationconstraint = __esm({
  "node_modules/ol/rotationconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/tilegrid/common.js
var DEFAULT_TILE_SIZE;
var init_common = __esm({
  "node_modules/ol/tilegrid/common.js"() {
    DEFAULT_TILE_SIZE = 256;
  }
});

// node_modules/ol/View.js
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals2(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var DEFAULT_MIN_ZOOM, View, View_default;
var init_View = __esm({
  "node_modules/ol/View.js"() {
    init_Object();
    init_ViewHint();
    init_ViewProperty();
    init_array();
    init_asserts();
    init_centerconstraint();
    init_coordinate();
    init_easing();
    init_extent();
    init_functions();
    init_Polygon();
    init_math();
    init_proj();
    init_resolutionconstraint();
    init_rotationconstraint();
    init_common();
    DEFAULT_MIN_ZOOM = 0;
    View = class extends Object_default {
      /**
       * @param {ViewOptions} [options] View options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        options = Object.assign({}, options);
        this.hints_ = [0, 0];
        this.animations_ = [];
        this.updateAnimationKey_;
        this.projection_ = createProjection(options.projection, "EPSG:3857");
        this.viewportSize_ = [100, 100];
        this.targetCenter_ = null;
        this.targetResolution_;
        this.targetRotation_;
        this.nextCenter_ = null;
        this.nextResolution_;
        this.nextRotation_;
        this.cancelAnchor_ = void 0;
        if (options.projection) {
          disableCoordinateWarning();
        }
        if (options.center) {
          options.center = fromUserCoordinate(options.center, this.projection_);
        }
        if (options.extent) {
          options.extent = fromUserExtent(options.extent, this.projection_);
        }
        this.applyOptions_(options);
      }
      /**
       * Set up the view with the given options.
       * @param {ViewOptions} options View options.
       */
      applyOptions_(options) {
        const properties = Object.assign({}, options);
        for (const key in ViewProperty_default) {
          delete properties[key];
        }
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options);
        this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        this.minResolution_ = resolutionConstraintInfo.minResolution;
        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        this.resolutions_ = options.resolutions;
        this.padding_ = options.padding;
        this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options);
        this.constraints_ = {
          center: centerConstraint,
          resolution: resolutionConstraint,
          rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
        this.setCenterInternal(
          options.center !== void 0 ? options.center : null
        );
        if (options.resolution !== void 0) {
          this.setResolution(options.resolution);
        } else if (options.zoom !== void 0) {
          this.setZoom(options.zoom);
        }
      }
      /**
       * Padding (in css pixels).
       * If the map viewport is partially covered with other content (overlays) along
       * its edges, this setting allows to shift the center of the viewport away from that
       * content. The order of the values in the array is top, right, bottom, left.
       * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
       * @type {Array<number>|undefined}
       * @api
       */
      get padding() {
        return this.padding_;
      }
      set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenterInternal();
        if (center) {
          const newPadding = padding || [0, 0, 0, 0];
          oldPadding = oldPadding || [0, 0, 0, 0];
          const resolution = this.getResolution();
          const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
          const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
          this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
        }
      }
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */
      getUpdatedOptions_(newOptions) {
        const options = this.getProperties();
        if (options.resolution !== void 0) {
          options.resolution = this.getResolution();
        } else {
          options.zoom = this.getZoom();
        }
        options.center = this.getCenterInternal();
        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
      }
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      animate(var_args) {
        if (this.isDef() && !this.getAnimating()) {
          this.resolveConstraints(0);
        }
        const args = new Array(arguments.length);
        for (let i7 = 0; i7 < args.length; ++i7) {
          let options = arguments[i7];
          if (options.center) {
            options = Object.assign({}, options);
            options.center = fromUserCoordinate(
              options.center,
              this.getProjection()
            );
          }
          if (options.anchor) {
            options = Object.assign({}, options);
            options.anchor = fromUserCoordinate(
              options.anchor,
              this.getProjection()
            );
          }
          args[i7] = options;
        }
        this.animateInternal.apply(this, args);
      }
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */
      animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
          callback = arguments[animationCount - 1];
          --animationCount;
        }
        let i7 = 0;
        for (; i7 < animationCount && !this.isDef(); ++i7) {
          const state = arguments[i7];
          if (state.center) {
            this.setCenterInternal(state.center);
          }
          if (state.zoom !== void 0) {
            this.setZoom(state.zoom);
          } else if (state.resolution) {
            this.setResolution(state.resolution);
          }
          if (state.rotation !== void 0) {
            this.setRotation(state.rotation);
          }
        }
        if (i7 === animationCount) {
          if (callback) {
            animationCallback(callback, true);
          }
          return;
        }
        let start2 = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for (; i7 < animationCount; ++i7) {
          const options = (
            /** @type {AnimationOptions} */
            arguments[i7]
          );
          const animation = {
            start: start2,
            complete: false,
            anchor: options.anchor,
            duration: options.duration !== void 0 ? options.duration : 1e3,
            easing: options.easing || inAndOut,
            callback
          };
          if (options.center) {
            animation.sourceCenter = center;
            animation.targetCenter = options.center.slice();
            center = animation.targetCenter;
          }
          if (options.zoom !== void 0) {
            animation.sourceResolution = resolution;
            animation.targetResolution = this.getResolutionForZoom(options.zoom);
            resolution = animation.targetResolution;
          } else if (options.resolution) {
            animation.sourceResolution = resolution;
            animation.targetResolution = options.resolution;
            resolution = animation.targetResolution;
          }
          if (options.rotation !== void 0) {
            animation.sourceRotation = rotation;
            const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
            animation.targetRotation = rotation + delta;
            rotation = animation.targetRotation;
          }
          if (isNoopAnimation(animation)) {
            animation.complete = true;
          } else {
            start2 += animation.duration;
          }
          series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(ViewHint_default.ANIMATING, 1);
        this.updateAnimations_();
      }
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      getAnimating() {
        return this.hints_[ViewHint_default.ANIMATING] > 0;
      }
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      getInteracting() {
        return this.hints_[ViewHint_default.INTERACTING] > 0;
      }
      /**
       * Cancel any ongoing animations.
       * @api
       */
      cancelAnimations() {
        this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
        let anchor;
        for (let i7 = 0, ii = this.animations_.length; i7 < ii; ++i7) {
          const series = this.animations_[i7];
          if (series[0].callback) {
            animationCallback(series[0].callback, false);
          }
          if (!anchor) {
            for (let j6 = 0, jj = series.length; j6 < jj; ++j6) {
              const animation = series[j6];
              if (!animation.complete) {
                anchor = animation.anchor;
                break;
              }
            }
          }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
      }
      /**
       * Update all animations.
       */
      updateAnimations_() {
        if (this.updateAnimationKey_ !== void 0) {
          cancelAnimationFrame(this.updateAnimationKey_);
          this.updateAnimationKey_ = void 0;
        }
        if (!this.getAnimating()) {
          return;
        }
        const now = Date.now();
        let more = false;
        for (let i7 = this.animations_.length - 1; i7 >= 0; --i7) {
          const series = this.animations_[i7];
          let seriesComplete = true;
          for (let j6 = 0, jj = series.length; j6 < jj; ++j6) {
            const animation = series[j6];
            if (animation.complete) {
              continue;
            }
            const elapsed = now - animation.start;
            let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
            if (fraction >= 1) {
              animation.complete = true;
              fraction = 1;
            } else {
              seriesComplete = false;
            }
            const progress = animation.easing(fraction);
            if (animation.sourceCenter) {
              const x0 = animation.sourceCenter[0];
              const y0 = animation.sourceCenter[1];
              const x1 = animation.targetCenter[0];
              const y1 = animation.targetCenter[1];
              this.nextCenter_ = animation.targetCenter;
              const x4 = x0 + progress * (x1 - x0);
              const y5 = y0 + progress * (y1 - y0);
              this.targetCenter_ = [x4, y5];
            }
            if (animation.sourceResolution && animation.targetResolution) {
              const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
              if (animation.anchor) {
                const size = this.getViewportSize_(this.getRotation());
                const constrainedResolution = this.constraints_.resolution(
                  resolution,
                  0,
                  size,
                  true
                );
                this.targetCenter_ = this.calculateCenterZoom(
                  constrainedResolution,
                  animation.anchor
                );
              }
              this.nextResolution_ = animation.targetResolution;
              this.targetResolution_ = resolution;
              this.applyTargetState_(true);
            }
            if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
              const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
              if (animation.anchor) {
                const constrainedRotation = this.constraints_.rotation(
                  rotation,
                  true
                );
                this.targetCenter_ = this.calculateCenterRotate(
                  constrainedRotation,
                  animation.anchor
                );
              }
              this.nextRotation_ = animation.targetRotation;
              this.targetRotation_ = rotation;
            }
            this.applyTargetState_(true);
            more = true;
            if (!animation.complete) {
              break;
            }
          }
          if (seriesComplete) {
            this.animations_[i7] = null;
            this.setHint(ViewHint_default.ANIMATING, -1);
            this.nextCenter_ = null;
            this.nextResolution_ = NaN;
            this.nextRotation_ = NaN;
            const callback = series[0].callback;
            if (callback) {
              animationCallback(callback, true);
            }
          }
        }
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === void 0) {
          this.updateAnimationKey_ = requestAnimationFrame(
            this.updateAnimations_.bind(this)
          );
        }
      }
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */
      calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== void 0) {
          center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
          rotate(center, rotation - this.getRotation());
          add(center, anchor);
        }
        return center;
      }
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */
      calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== void 0 && currentResolution !== void 0) {
          const x4 = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
          const y5 = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
          center = [x4, y5];
        }
        return center;
      }
      /**
       * Returns the current viewport size.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
          const w5 = size[0];
          const h5 = size[1];
          return [
            Math.abs(w5 * Math.cos(rotation)) + Math.abs(h5 * Math.sin(rotation)),
            Math.abs(w5 * Math.sin(rotation)) + Math.abs(h5 * Math.cos(rotation))
          ];
        }
        return size;
      }
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
       */
      setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
        if (!this.getAnimating()) {
          this.resolveConstraints(0);
        }
      }
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      getCenter() {
        const center = this.getCenterInternal();
        if (!center) {
          return center;
        }
        return toUserCoordinate(center, this.getProjection());
      }
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */
      getCenterInternal() {
        return (
          /** @type {import("./coordinate.js").Coordinate|undefined} */
          this.get(ViewProperty_default.CENTER)
        );
      }
      /**
       * @return {Constraints} Constraints.
       */
      getConstraints() {
        return this.constraints_;
      }
      /**
       * @return {boolean} Resolution constraint is set
       */
      getConstrainResolution() {
        return this.get("constrainResolution");
      }
      /**
       * @param {Array<number>} [hints] Destination array.
       * @return {Array<number>} Hint.
       */
      getHints(hints) {
        if (hints !== void 0) {
          hints[0] = this.hints_[0];
          hints[1] = this.hints_[1];
          return hints;
        }
        return this.hints_.slice();
      }
      /**
       * Calculate the extent for the current view state and the passed box size.
       * @param {import("./size.js").Size} [size] The pixel dimensions of the box
       * into which the calculated extent should fit. Defaults to the size of the
       * map the view is associated with.
       * If no map or multiple maps are connected to the view, provide the desired
       * box size (e.g. `map.getSize()`).
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */
      calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return toUserExtent(extent, this.getProjection());
      }
      /**
       * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
       * the map's last known viewport size will be used.
       * @return {import("./extent.js").Extent} Extent.
       */
      calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = (
          /** @type {!import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        assert(center, "The view center is not defined");
        const resolution = (
          /** @type {!number} */
          this.getResolution()
        );
        assert(resolution !== void 0, "The view resolution is not defined");
        const rotation = (
          /** @type {!number} */
          this.getRotation()
        );
        assert(rotation !== void 0, "The view rotation is not defined");
        return getForViewAndSize(center, resolution, rotation, size);
      }
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      getMaxResolution() {
        return this.maxResolution_;
      }
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      getMinResolution() {
        return this.minResolution_;
      }
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.minResolution_)
        );
      }
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
      }
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.maxResolution_)
        );
      }
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
      }
      /**
       * Set whether the view should allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */
      setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
      }
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */
      getProjection() {
        return this.projection_;
      }
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      getResolution() {
        return (
          /** @type {number|undefined} */
          this.get(ViewProperty_default.RESOLUTION)
        );
      }
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */
      getResolutions() {
        return this.resolutions_;
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal(
          fromUserExtent(extent, this.getProjection()),
          size
        );
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */
      getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = getWidth(extent) / size[0];
        const yResolution = getHeight(extent) / size[1];
        return Math.max(xResolution, yResolution);
      }
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Resolution for value function.
       */
      getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
          }
        );
      }
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      getRotation() {
        return (
          /** @type {number} */
          this.get(ViewProperty_default.ROTATION)
        );
      }
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Value for resolution function.
       */
      getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
          }
        );
      }
      /**
       * Returns the size of the viewport minus padding.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size reduced by the padding.
       */
      getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) {
          size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
          ];
        }
        return size;
      }
      /**
       * @return {State} View state.
       */
      getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = (
          /** @type {import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        const padding = this.padding_;
        if (padding) {
          const reducedSize = this.getViewportSizeMinusPadding_();
          center = calculateCenterOn(
            center,
            this.getViewportSize_(),
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
        }
        return {
          center: center.slice(0),
          projection: projection !== void 0 ? projection : null,
          resolution,
          nextCenter: this.nextCenter_,
          nextResolution: this.nextResolution_,
          nextRotation: this.nextRotation_,
          rotation,
          zoom: this.getZoom()
        };
      }
      /**
       * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
       */
      getViewStateAndExtent() {
        return {
          viewState: this.getState(),
          extent: this.calculateExtent()
        };
      }
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */
      getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== void 0) {
          zoom = this.getZoomForResolution(resolution);
        }
        return zoom;
      }
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      getZoomForResolution(resolution) {
        let offset = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
          const nearest = linearFindNearest(this.resolutions_, resolution, 1);
          offset = nearest;
          max = this.resolutions_[nearest];
          if (nearest == this.resolutions_.length - 1) {
            zoomFactor = 2;
          } else {
            zoomFactor = max / this.resolutions_[nearest + 1];
          }
        } else {
          max = this.maxResolution_;
          zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
      }
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      getResolutionForZoom(zoom) {
        if (this.resolutions_?.length) {
          if (this.resolutions_.length === 1) {
            return this.resolutions_[0];
          }
          const baseLevel = clamp(
            Math.floor(zoom),
            0,
            this.resolutions_.length - 2
          );
          const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
          return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
      }
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions} [options] Options.
       * @api
       */
      fit(geometryOrExtent, options) {
        let geometry;
        assert(
          Array.isArray(geometryOrExtent) || typeof /** @type {?} */
          geometryOrExtent.getSimplifiedGeometry === "function",
          "Invalid extent or geometry provided as `geometry`"
        );
        if (Array.isArray(geometryOrExtent)) {
          assert(
            !isEmpty(geometryOrExtent),
            "Cannot fit empty extent provided as `geometry`"
          );
          const extent = fromUserExtent(geometryOrExtent, this.getProjection());
          geometry = fromExtent(extent);
        } else if (geometryOrExtent.getType() === "Circle") {
          const extent = fromUserExtent(
            geometryOrExtent.getExtent(),
            this.getProjection()
          );
          geometry = fromExtent(extent);
          geometry.rotate(this.getRotation(), getCenter(extent));
        } else {
          const userProjection2 = getUserProjection();
          if (userProjection2) {
            geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
            geometryOrExtent.clone().transform(userProjection2, this.getProjection());
          } else {
            geometry = geometryOrExtent;
          }
        }
        this.fitInternal(geometry, options);
      }
      /**
       * Calculate rotated extent
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @return {import("./extent").Extent} The rotated extent for the geometry.
       */
      rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = Infinity;
        let minRotY = Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for (let i7 = 0, ii = coords.length; i7 < ii; i7 += stride) {
          const rotX = coords[i7] * cosAngle - coords[i7 + 1] * sinAngle;
          const rotY = coords[i7] * sinAngle + coords[i7 + 1] * cosAngle;
          minRotX = Math.min(minRotX, rotX);
          minRotY = Math.min(minRotY, rotY);
          maxRotX = Math.max(maxRotX, rotX);
          maxRotY = Math.max(maxRotY, rotY);
        }
        return [minRotX, minRotY, maxRotX, maxRotY];
      }
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions} [options] Options.
       */
      fitInternal(geometry, options) {
        options = options || {};
        let size = options.size;
        if (!size) {
          size = this.getViewportSizeMinusPadding_();
        }
        const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
        const nearest = options.nearest !== void 0 ? options.nearest : false;
        let minResolution;
        if (options.minResolution !== void 0) {
          minResolution = options.minResolution;
        } else if (options.maxZoom !== void 0) {
          minResolution = this.getResolutionForZoom(options.maxZoom);
        } else {
          minResolution = 0;
        }
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
          size[0] - padding[1] - padding[3],
          size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = getCenter(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([centerX, centerY], resolution);
        const callback = options.callback ? options.callback : VOID;
        if (options.duration !== void 0) {
          this.animateInternal(
            {
              resolution,
              center,
              duration: options.duration,
              easing: options.easing
            },
            callback
          );
        } else {
          this.targetResolution_ = resolution;
          this.targetCenter_ = center;
          this.applyTargetState_(false, true);
          animationCallback(callback, true);
        }
      }
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */
      centerOn(coordinate, size, position) {
        this.centerOnInternal(
          fromUserCoordinate(coordinate, this.getProjection()),
          size,
          position
        );
      }
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */
      centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(
          calculateCenterOn(
            coordinate,
            size,
            position,
            this.getResolution(),
            this.getRotation()
          )
        );
      }
      /**
       * Calculates the shift between map and viewport center.
       * @param {import("./coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {import("./size.js").Size} size Size.
       * @return {Array<number>|undefined} Center shift.
       */
      calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
          const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
          const shiftedCenter = calculateCenterOn(
            center,
            size,
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
          centerShift = [
            center[0] - shiftedCenter[0],
            center[1] - shiftedCenter[1]
          ];
        }
        return centerShift;
      }
      /**
       * @return {boolean} Is defined.
       */
      isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== void 0;
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */
      adjustCenter(deltaCoordinates) {
        const center = toUserCoordinate(this.targetCenter_, this.getProjection());
        this.setCenter([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */
      adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustResolution(ratio, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(
          this.targetResolution_ * ratio,
          0,
          size,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        }
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
      }
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
      }
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       * @api
       */
      adjustRotation(delta, anchor) {
        if (anchor) {
          anchor = fromUserCoordinate(anchor, this.getProjection());
        }
        this.adjustRotationInternal(delta, anchor);
      }
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       */
      adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(
          this.targetRotation_ + delta,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        }
        this.targetRotation_ += delta;
        this.applyTargetState_();
      }
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      setCenter(center) {
        this.setCenterInternal(
          center ? fromUserCoordinate(center, this.getProjection()) : center
        );
      }
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */
      setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
      }
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
      }
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
      }
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
      }
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */
      setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
      }
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean} [doNotCancelAnims] Do not cancel animations.
       * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
       * @private
       */
      applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        const newRotation = this.constraints_.rotation(
          this.targetRotation_,
          isMoving
        );
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          0,
          size,
          isMoving
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          isMoving,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
          this.set(ViewProperty_default.ROTATION, newRotation);
        }
        if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
          this.set(ViewProperty_default.RESOLUTION, newResolution);
          this.set("zoom", this.getZoom(), true);
        }
        if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals2(this.get(ViewProperty_default.CENTER), newCenter)) {
          this.set(ViewProperty_default.CENTER, newCenter);
        }
        if (this.getAnimating() && !doNotCancelAnims) {
          this.cancelAnimations();
        }
        this.cancelAnchor_ = void 0;
      }
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number} [duration] The animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== void 0 ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          direction,
          size
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          false,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (duration === 0 && !this.cancelAnchor_) {
          this.targetResolution_ = newResolution;
          this.targetRotation_ = newRotation;
          this.targetCenter_ = newCenter;
          this.applyTargetState_();
          return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
        this.cancelAnchor_ = void 0;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals2(this.getCenterInternal(), newCenter)) {
          if (this.getAnimating()) {
            this.cancelAnimations();
          }
          this.animateInternal({
            rotation: newRotation,
            center: newCenter,
            resolution: newResolution,
            duration,
            easing: easeOut,
            anchor
          });
        }
      }
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */
      beginInteraction() {
        this.resolveConstraints(0);
        this.setHint(ViewHint_default.INTERACTING, 1);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      endInteractionInternal(duration, resolutionDirection, anchor) {
        if (!this.getInteracting()) {
          return;
        }
        this.setHint(ViewHint_default.INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
      }
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */
      getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(
          targetCenter,
          targetResolution || this.getResolution(),
          size
        );
      }
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number} [direction] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */
      getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(
          this.getConstrainedResolution(targetRes, direction)
        );
      }
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number} [direction] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */
      getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
      }
    };
    View_default = View;
  }
});

// node_modules/ol/layer/Property.js
var Property_default;
var init_Property = __esm({
  "node_modules/ol/layer/Property.js"() {
    Property_default = {
      OPACITY: "opacity",
      VISIBLE: "visible",
      EXTENT: "extent",
      Z_INDEX: "zIndex",
      MAX_RESOLUTION: "maxResolution",
      MIN_RESOLUTION: "minResolution",
      MAX_ZOOM: "maxZoom",
      MIN_ZOOM: "minZoom",
      SOURCE: "source",
      MAP: "map"
    };
  }
});

// node_modules/ol/layer/Base.js
var BaseLayer, Base_default;
var init_Base = __esm({
  "node_modules/ol/layer/Base.js"() {
    init_Object();
    init_asserts();
    init_math();
    init_util();
    init_Property();
    BaseLayer = class extends Object_default {
      /**
       * @param {Options} options Layer options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        this.background_ = options.background;
        const properties = Object.assign({}, options);
        if (typeof options.properties === "object") {
          delete properties.properties;
          Object.assign(properties, options.properties);
        }
        properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
        assert(
          typeof properties[Property_default.OPACITY] === "number",
          "Layer opacity must be a number"
        );
        properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
        properties[Property_default.Z_INDEX] = options.zIndex;
        properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
        properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
        properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
        properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
        this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
        delete properties.className;
        this.setProperties(properties);
        this.state_ = null;
      }
      /**
       * Get the background for this layer.
       * @return {BackgroundColor|false} Layer background.
       */
      getBackground() {
        return this.background_;
      }
      /**
       * @return {string} CSS class name.
       */
      getClassName() {
        return this.className_;
      }
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean} [managed] Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      getLayerState(managed) {
        const state = this.state_ || /** @type {?} */
        {
          layer: this,
          managed: managed === void 0 ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        return abstract();
      }
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      getExtent() {
        return (
          /** @type {import("../extent.js").Extent|undefined} */
          this.get(Property_default.EXTENT)
        );
      }
      /**
       * Return the maximum resolution of the layer. Returns Infinity if
       * the layer has no maximum resolution set.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      getMaxResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_RESOLUTION)
        );
      }
      /**
       * Return the minimum resolution of the layer. Returns 0 if
       * the layer has no minimum resolution set.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      getMinResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_RESOLUTION)
        );
      }
      /**
       * Return the minimum zoom level of the layer. Returns -Infinity if
       * the layer has no minimum zoom set.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_ZOOM)
        );
      }
      /**
       * Return the maximum zoom level of the layer. Returns Infinity if
       * the layer has no maximum zoom set.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_ZOOM)
        );
      }
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      getOpacity() {
        return (
          /** @type {number} */
          this.get(Property_default.OPACITY)
        );
      }
      /**
       * @abstract
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        return abstract();
      }
      /**
       * Return the value of this layer's `visible` property. To find out whether the layer
       * is visible on a map, use `isVisible()` instead.
       * @return {boolean} The value of the `visible` property of the layer.
       * @observable
       * @api
       */
      getVisible() {
        return (
          /** @type {boolean} */
          this.get(Property_default.VISIBLE)
        );
      }
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. Returns undefined if the layer is unmanaged.
       * @return {number|undefined} The Z-index of the layer.
       * @observable
       * @api
       */
      getZIndex() {
        return (
          /** @type {number|undefined} */
          this.get(Property_default.Z_INDEX)
        );
      }
      /**
       * Sets the background color.
       * @param {BackgroundColor} [background] Background color.
       */
      setBackground(background) {
        this.background_ = background;
        this.changed();
      }
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      setExtent(extent) {
        this.set(Property_default.EXTENT, extent);
      }
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      setMaxResolution(maxResolution) {
        this.set(Property_default.MAX_RESOLUTION, maxResolution);
      }
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      setMinResolution(minResolution) {
        this.set(Property_default.MIN_RESOLUTION, minResolution);
      }
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      setMaxZoom(maxZoom) {
        this.set(Property_default.MAX_ZOOM, maxZoom);
      }
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      setMinZoom(minZoom) {
        this.set(Property_default.MIN_ZOOM, minZoom);
      }
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      setOpacity(opacity) {
        assert(typeof opacity === "number", "Layer opacity must be a number");
        this.set(Property_default.OPACITY, opacity);
      }
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      setVisible(visible) {
        this.set(Property_default.VISIBLE, visible);
      }
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      setZIndex(zindex) {
        this.set(Property_default.Z_INDEX, zindex);
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        if (this.state_) {
          this.state_.layer = null;
          this.state_ = null;
        }
        super.disposeInternal();
      }
    };
    Base_default = BaseLayer;
  }
});

// node_modules/ol/layer/Layer.js
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer, Layer_default3;
var init_Layer3 = __esm({
  "node_modules/ol/layer/Layer.js"() {
    init_View();
    init_asserts();
    init_EventType();
    init_events();
    init_extent();
    init_EventType2();
    init_Base();
    init_Property();
    Layer = class extends Base_default {
      /**
       * @param {Options<SourceType>} options Layer options.
       */
      constructor(options) {
        const baseOptions = Object.assign({}, options);
        delete baseOptions.source;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.mapPrecomposeKey_ = null;
        this.mapRenderKey_ = null;
        this.sourceChangeKey_ = null;
        this.renderer_ = null;
        this.sourceReady_ = false;
        this.rendered = false;
        if (options.render) {
          this.render = options.render;
        }
        if (options.map) {
          this.setMap(options.map);
        }
        this.addChangeListener(
          Property_default.SOURCE,
          this.handleSourcePropertyChange_
        );
        const source = options.source ? (
          /** @type {SourceType} */
          options.source
        ) : null;
        this.setSource(source);
      }
      /**
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       * @override
       */
      getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
      }
      /**
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       * @override
       */
      getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
      }
      /**
       * Get the layer source.
       * @return {SourceType|null} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      getSource() {
        return (
          /** @type {SourceType} */
          this.get(Property_default.SOURCE) || null
        );
      }
      /**
       * @return {SourceType|null} The source being rendered.
       */
      getRenderSource() {
        return this.getSource();
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       * @override
       */
      getSourceState() {
        const source = this.getSource();
        return !source ? "undefined" : source.getState();
      }
      /**
       * @private
       */
      handleSourceChange_() {
        this.changed();
        if (this.sourceReady_ || this.getSource().getState() !== "ready") {
          return;
        }
        this.sourceReady_ = true;
        this.dispatchEvent("sourceready");
      }
      /**
       * @private
       */
      handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
          unlistenByKey(this.sourceChangeKey_);
          this.sourceChangeKey_ = null;
        }
        this.sourceReady_ = false;
        const source = this.getSource();
        if (source) {
          this.sourceChangeKey_ = listen(
            source,
            EventType_default.CHANGE,
            this.handleSourceChange_,
            this
          );
          if (source.getState() === "ready") {
            this.sourceReady_ = true;
            setTimeout(() => {
              this.dispatchEvent("sourceready");
            }, 0);
          }
        }
        this.changed();
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        if (!this.renderer_) {
          return Promise.resolve([]);
        }
        return this.renderer_.getFeatures(pixel);
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        if (!this.renderer_ || !this.rendered) {
          return null;
        }
        return this.renderer_.getData(pixel);
      }
      /**
       * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
       * extent, not set to `visible: false`, and not inside a layer group that is set
       * to `visible: false`.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {boolean} The layer is visible in the map view.
       * @api
       */
      isVisible(view) {
        let frameState;
        const map = this.getMapInternal();
        if (!view && map) {
          view = map.getView();
        }
        if (view instanceof View_default) {
          frameState = {
            viewState: view.getState(),
            extent: view.calculateExtent()
          };
        } else {
          frameState = view;
        }
        if (!frameState.layerStatesArray && map) {
          frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
        }
        let layerState;
        if (frameState.layerStatesArray) {
          layerState = frameState.layerStatesArray.find(
            (layerState2) => layerState2.layer === this
          );
          if (!layerState) {
            return false;
          }
        } else {
          layerState = this.getLayerState();
        }
        const layerExtent = this.getExtent();
        return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
      }
      /**
       * Get the attributions of the source of this layer for the given view.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {Array<string>} Attributions for this layer at the given view.
       * @api
       */
      getAttributions(view) {
        if (!this.isVisible(view)) {
          return [];
        }
        const getAttributions = this.getSource()?.getAttributions();
        if (!getAttributions) {
          return [];
        }
        const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
        let attributions = getAttributions(frameState);
        if (!Array.isArray(attributions)) {
          attributions = [attributions];
        }
        return attributions;
      }
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement|null} The rendered element.
       */
      render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
          this.rendered = true;
          return layerRenderer.renderFrame(frameState, target);
        }
        return null;
      }
      /**
       * Called when a layer is not visible during a map render.
       */
      unrender() {
        this.rendered = false;
      }
      /** @return {string} Declutter */
      getDeclutter() {
        return void 0;
      }
      /**
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {import("../layer/Layer.js").State} layerState Layer state.
       */
      renderDeclutter(frameState, layerState) {
      }
      /**
       * When the renderer follows a layout -> render approach, do the final rendering here.
       * @param {import('../Map.js').FrameState} frameState Frame state
       */
      renderDeferred(frameState) {
        const layerRenderer = this.getRenderer();
        if (!layerRenderer) {
          return;
        }
        layerRenderer.renderDeferred(frameState);
      }
      /**
       * For use inside the library only.
       * @param {import("../Map.js").default|null} map Map.
       */
      setMapInternal(map) {
        if (!map) {
          this.unrender();
        }
        this.set(Property_default.MAP, map);
      }
      /**
       * For use inside the library only.
       * @return {import("../Map.js").default|null} Map.
       */
      getMapInternal() {
        return this.get(Property_default.MAP);
      }
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map~Map#addLayer} instead.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.mapPrecomposeKey_) {
          unlistenByKey(this.mapPrecomposeKey_);
          this.mapPrecomposeKey_ = null;
        }
        if (!map) {
          this.changed();
        }
        if (this.mapRenderKey_) {
          unlistenByKey(this.mapRenderKey_);
          this.mapRenderKey_ = null;
        }
        if (map) {
          this.mapPrecomposeKey_ = listen(
            map,
            EventType_default2.PRECOMPOSE,
            this.handlePrecompose_,
            this
          );
          this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map.render, map);
          this.changed();
        }
      }
      /**
       * @param {import("../events/Event.js").default} renderEvent Render event
       * @private
       */
      handlePrecompose_(renderEvent) {
        const layerStatesArray = (
          /** @type {import("../render/Event.js").default} */
          renderEvent.frameState.layerStatesArray
        );
        const layerState = this.getLayerState(false);
        assert(
          !layerStatesArray.some(
            (arrayLayerState) => arrayLayerState.layer === layerState.layer
          ),
          "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
        );
        layerStatesArray.push(layerState);
      }
      /**
       * Set the layer source.
       * @param {SourceType|null} source The layer source.
       * @observable
       * @api
       */
      setSource(source) {
        this.set(Property_default.SOURCE, source);
      }
      /**
       * Get the renderer for this layer.
       * @return {RendererType|null} The layer renderer.
       */
      getRenderer() {
        if (!this.renderer_) {
          this.renderer_ = this.createRenderer();
        }
        return this.renderer_;
      }
      /**
       * @return {boolean} The layer has a renderer.
       */
      hasRenderer() {
        return !!this.renderer_;
      }
      /**
       * Create a renderer for this layer.
       * @return {RendererType} A layer renderer.
       * @protected
       */
      createRenderer() {
        return null;
      }
      /**
       * This will clear the renderer so that a new one can be created next time it is needed
       */
      clearRenderer() {
        if (this.renderer_) {
          this.renderer_.dispose();
          delete this.renderer_;
        }
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        this.clearRenderer();
        this.setSource(null);
        super.disposeInternal();
      }
    };
    Layer_default3 = Layer;
  }
});

// node_modules/ol/layer/BaseVector.js
function toStyleLike(style) {
  if (style === void 0) {
    return createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === "function") {
    return style;
  }
  if (style instanceof Style_default) {
    return style;
  }
  if (!Array.isArray(style)) {
    return flatStylesToStyleFunction([style]);
  }
  if (style.length === 0) {
    return [];
  }
  const length = style.length;
  const first = style[0];
  if (first instanceof Style_default) {
    const styles = new Array(length);
    for (let i7 = 0; i7 < length; ++i7) {
      const candidate = style[i7];
      if (!(candidate instanceof Style_default)) {
        throw new Error("Expected a list of style instances");
      }
      styles[i7] = candidate;
    }
    return styles;
  }
  if ("style" in first) {
    const rules = new Array(length);
    for (let i7 = 0; i7 < length; ++i7) {
      const candidate = style[i7];
      if (!("style" in candidate)) {
        throw new Error("Expected a list of rules with a style property");
      }
      rules[i7] = candidate;
    }
    return rulesToStyleFunction(rules);
  }
  const flatStyles = (
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    style
  );
  return flatStylesToStyleFunction(flatStyles);
}
var Property, BaseVectorLayer, BaseVector_default;
var init_BaseVector = __esm({
  "node_modules/ol/layer/BaseVector.js"() {
    init_rbush();
    init_style2();
    init_Style();
    init_Layer3();
    Property = {
      RENDER_ORDER: "renderOrder"
    };
    BaseVectorLayer = class extends Layer_default3 {
      /**
       * @param {Options<FeatureType, VectorSourceType>} [options] Options.
       */
      constructor(options) {
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        super(baseOptions);
        this.declutter_ = options.declutter ? String(options.declutter) : void 0;
        this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.setStyle(options.style);
        this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
        this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
      }
      /**
       * @return {string} Declutter group.
       * @override
       */
      getDeclutter() {
        return this.declutter_;
      }
      /**
       * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
       * that resolves with an array of features. The array will either contain the topmost feature
       * when a hit was detected, or it will be empty.
       *
       * The hit detection algorithm used for this method is optimized for performance, but is less
       * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
       * Text is not considered, and icons are only represented by their bounding box instead of the exact
       * image.
       *
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
       * @api
       * @override
       */
      getFeatures(pixel) {
        return super.getFeatures(pixel);
      }
      /**
       * @return {number|undefined} Render buffer.
       */
      getRenderBuffer() {
        return this.renderBuffer_;
      }
      /**
       * @return {import("../render.js").OrderFunction|null|undefined} Render order.
       */
      getRenderOrder() {
        return (
          /** @type {import("../render.js").OrderFunction|null|undefined} */
          this.get(Property.RENDER_ORDER)
        );
      }
      /**
       * Get the style for features.  This returns whatever was passed to the `style`
       * option at construction or to the `setStyle` method.
       * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the style function.
       * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     animating.
       */
      getUpdateWhileAnimating() {
        return this.updateWhileAnimating_;
      }
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     interacting.
       */
      getUpdateWhileInteracting() {
        return this.updateWhileInteracting_;
      }
      /**
       * Render declutter items for this layer
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {import("../layer/Layer.js").State} layerState Layer state.
       * @override
       */
      renderDeclutter(frameState, layerState) {
        const declutterGroup = this.getDeclutter();
        if (declutterGroup in frameState.declutter === false) {
          frameState.declutter[declutterGroup] = new RBush(9);
        }
        this.getRenderer().renderDeclutter(frameState, layerState);
      }
      /**
       * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
       *     Render order.
       */
      setRenderOrder(renderOrder) {
        this.set(Property.RENDER_ORDER, renderOrder);
      }
      /**
       * Set the style for features.  This can be a single style object, an array
       * of styles, or a function that takes a feature and resolution and returns
       * an array of styles. If set to `null`, the layer has no style (a `null` style),
       * so only features that have their own styles will be rendered in the layer. Call
       * `setStyle()` without arguments to reset to the default style. See
       * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
       *
       * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
       * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
       * ```js
       * vectorLayer.setStyle({
       *   "fill-color": "yellow",
       *   "stroke-color": "black",
       *   "stroke-width": 4
       * })
       * ```
       *
       * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
       * @api
       */
      setStyle(style) {
        this.style_ = style === void 0 ? createDefaultStyle : style;
        const styleLike = toStyleLike(style);
        this.styleFunction_ = style === null ? void 0 : toFunction(styleLike);
        this.changed();
      }
      /**
       * @param {boolean|string|number} declutter Declutter images and text.
       * @api
       */
      setDeclutter(declutter) {
        this.declutter_ = declutter ? String(declutter) : void 0;
        this.changed();
      }
    };
    BaseVector_default = BaseVectorLayer;
  }
});

// node_modules/ol/layer/Vector.js
var VectorLayer, Vector_default;
var init_Vector = __esm({
  "node_modules/ol/layer/Vector.js"() {
    init_VectorLayer();
    init_BaseVector();
    VectorLayer = class extends BaseVector_default {
      /**
       * @param {Options<VectorSourceType, FeatureType>} [options] Options.
       */
      constructor(options) {
        super(options);
      }
      /**
       * @override
       */
      createRenderer() {
        return new VectorLayer_default(this);
      }
    };
    Vector_default = VectorLayer;
  }
});

// node_modules/ol/CollectionEventType.js
var CollectionEventType_default;
var init_CollectionEventType = __esm({
  "node_modules/ol/CollectionEventType.js"() {
    CollectionEventType_default = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: "add",
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: "remove"
    };
  }
});

// node_modules/ol/Collection.js
var Property2, CollectionEvent, Collection, Collection_default;
var init_Collection = __esm({
  "node_modules/ol/Collection.js"() {
    init_CollectionEventType();
    init_Object();
    init_Event();
    Property2 = {
      LENGTH: "length"
    };
    CollectionEvent = class extends Event_default {
      /**
       * @param {import("./CollectionEventType.js").default} type Type.
       * @param {T} element Element.
       * @param {number} index The index of the added or removed element.
       */
      constructor(type, element, index13) {
        super(type);
        this.element = element;
        this.index = index13;
      }
    };
    Collection = class extends Object_default {
      /**
       * @param {Array<T>} [array] Array.
       * @param {Options} [options] Collection options.
       */
      constructor(array, options) {
        super();
        this.on;
        this.once;
        this.un;
        options = options || {};
        this.unique_ = !!options.unique;
        this.array_ = array ? array : [];
        if (this.unique_) {
          for (let i7 = 0, ii = this.array_.length; i7 < ii; ++i7) {
            this.assertUnique_(this.array_[i7], i7);
          }
        }
        this.updateLength_();
      }
      /**
       * Remove all elements from the collection.
       * @api
       */
      clear() {
        while (this.getLength() > 0) {
          this.pop();
        }
      }
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */
      extend(arr) {
        for (let i7 = 0, ii = arr.length; i7 < ii; ++i7) {
          this.push(arr[i7]);
        }
        return this;
      }
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      forEach(f8) {
        const array = this.array_;
        for (let i7 = 0, ii = array.length; i7 < ii; ++i7) {
          f8(array[i7], i7, array);
        }
      }
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */
      getArray() {
        return this.array_;
      }
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      item(index13) {
        return this.array_[index13];
      }
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      getLength() {
        return this.get(Property2.LENGTH);
      }
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      insertAt(index13, elem) {
        if (index13 < 0 || index13 > this.getLength()) {
          throw new Error("Index out of bounds: " + index13);
        }
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        this.array_.splice(index13, 0, elem);
        this.updateLength_();
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType_default.ADD, elem, index13)
        );
      }
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      pop() {
        return this.removeAt(this.getLength() - 1);
      }
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      push(elem) {
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        const n6 = this.getLength();
        this.insertAt(n6, elem);
        return this.getLength();
      }
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      remove(elem) {
        const arr = this.array_;
        for (let i7 = 0, ii = arr.length; i7 < ii; ++i7) {
          if (arr[i7] === elem) {
            return this.removeAt(i7);
          }
        }
        return void 0;
      }
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      removeAt(index13) {
        if (index13 < 0 || index13 >= this.getLength()) {
          return void 0;
        }
        const prev = this.array_[index13];
        this.array_.splice(index13, 1);
        this.updateLength_();
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index13)
        );
        return prev;
      }
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      setAt(index13, elem) {
        const n6 = this.getLength();
        if (index13 >= n6) {
          this.insertAt(index13, elem);
          return;
        }
        if (index13 < 0) {
          throw new Error("Index out of bounds: " + index13);
        }
        if (this.unique_) {
          this.assertUnique_(elem, index13);
        }
        const prev = this.array_[index13];
        this.array_[index13] = elem;
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index13)
        );
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.ADD, elem, index13)
        );
      }
      /**
       * @private
       */
      updateLength_() {
        this.set(Property2.LENGTH, this.array_.length);
      }
      /**
       * @private
       * @param {T} elem Element.
       * @param {number} [except] Optional index to ignore.
       */
      assertUnique_(elem, except) {
        for (let i7 = 0, ii = this.array_.length; i7 < ii; ++i7) {
          if (this.array_[i7] === elem && i7 !== except) {
            throw new Error("Duplicate item added to a unique collection");
          }
        }
      }
    };
    Collection_default = Collection;
  }
});

// node_modules/ol/featureloader.js
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
  const xhr2 = new XMLHttpRequest();
  xhr2.open(
    "GET",
    typeof url === "function" ? url(extent, resolution, projection) : url,
    true
  );
  if (format.getType() == "arraybuffer") {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      const type = format.getType();
      try {
        let source;
        if (type == "text" || type == "json") {
          source = xhr2.responseText;
        } else if (type == "xml") {
          source = xhr2.responseXML || xhr2.responseText;
        } else if (type == "arraybuffer") {
          source = /** @type {ArrayBuffer} */
          xhr2.response;
        }
        if (source) {
          success(
            /** @type {Array<FeatureType>} */
            format.readFeatures(source, {
              extent,
              featureProjection: projection
            }),
            format.readProjection(source)
          );
        } else {
          failure();
        }
      } catch {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr(url, format) {
  return function(extent, resolution, projection, success, failure) {
    loadFeaturesXhr(
      url,
      format,
      extent,
      resolution,
      projection,
      /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      (features, dataProjection) => {
        this.addFeatures(features);
        if (success !== void 0) {
          success(features);
        }
      },
      () => {
        this.changed();
        if (failure !== void 0) {
          failure();
        }
      }
    );
  };
}
var withCredentials;
var init_featureloader = __esm({
  "node_modules/ol/featureloader.js"() {
    withCredentials = false;
  }
});

// node_modules/ol/loadingstrategy.js
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
var init_loadingstrategy = __esm({
  "node_modules/ol/loadingstrategy.js"() {
    init_proj();
  }
});

// node_modules/ol/structs/RBush.js
var RBush2, RBush_default;
var init_RBush = __esm({
  "node_modules/ol/structs/RBush.js"() {
    init_rbush();
    init_extent();
    init_obj();
    init_util();
    RBush2 = class {
      /**
       * @param {number} [maxEntries] Max entries.
       */
      constructor(maxEntries) {
        this.rbush_ = new RBush(maxEntries);
        this.items_ = {};
      }
      /**
       * Insert a value into the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      insert(extent, value) {
        const item = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3],
          value
        };
        this.rbush_.insert(item);
        this.items_[getUid(value)] = item;
      }
      /**
       * Bulk-insert values into the RBush.
       * @param {Array<import("../extent.js").Extent>} extents Extents.
       * @param {Array<T>} values Values.
       */
      load(extents, values) {
        const items = new Array(values.length);
        for (let i7 = 0, l7 = values.length; i7 < l7; i7++) {
          const extent = extents[i7];
          const value = values[i7];
          const item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value
          };
          items[i7] = item;
          this.items_[getUid(value)] = item;
        }
        this.rbush_.load(items);
      }
      /**
       * Remove a value from the RBush.
       * @param {T} value Value.
       * @return {boolean} Removed.
       */
      remove(value) {
        const uid = getUid(value);
        const item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
      }
      /**
       * Update the extent of a value in the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      update(extent, value) {
        const item = this.items_[getUid(value)];
        const bbox = [item.minX, item.minY, item.maxX, item.maxY];
        if (!equals(bbox, extent)) {
          this.remove(value);
          this.insert(extent, value);
        }
      }
      /**
       * Return all values in the RBush.
       * @return {Array<T>} All.
       */
      getAll() {
        const items = this.rbush_.all();
        return items.map(function(item) {
          return item.value;
        });
      }
      /**
       * Return all values in the given extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {Array<T>} All in extent.
       */
      getInExtent(extent) {
        const bbox = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3]
        };
        const items = this.rbush_.search(bbox);
        return items.map(function(item) {
          return item.value;
        });
      }
      /**
       * Calls a callback function with each value in the tree.
       * If the callback returns a truthy value, this value is returned without
       * checking the rest of the tree.
       * @param {function(T): R} callback Callback.
       * @return {R|undefined} Callback return value.
       * @template R
       */
      forEach(callback) {
        return this.forEach_(this.getAll(), callback);
      }
      /**
       * Calls a callback function with each value in the provided extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(T): R} callback Callback.
       * @return {R|undefined} Callback return value.
       * @template R
       */
      forEachInExtent(extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
      }
      /**
       * @param {Array<T>} values Values.
       * @param {function(T): R} callback Callback.
       * @return {R|undefined} Callback return value.
       * @template R
       * @private
       */
      forEach_(values, callback) {
        let result;
        for (let i7 = 0, l7 = values.length; i7 < l7; i7++) {
          result = callback(values[i7]);
          if (result) {
            return result;
          }
        }
        return result;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return isEmpty2(this.items_);
      }
      /**
       * Remove all values from the RBush.
       */
      clear() {
        this.rbush_.clear();
        this.items_ = {};
      }
      /**
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} Extent.
       */
      getExtent(extent) {
        const data = this.rbush_.toJSON();
        return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);
      }
      /**
       * @param {RBush<T>} rbush R-Tree.
       */
      concat(rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for (const i7 in rbush.items_) {
          this.items_[i7] = rbush.items_[i7];
        }
      }
    };
    RBush_default = RBush2;
  }
});

// node_modules/ol/source/Source.js
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  if (!Array.isArray(attributionLike)) {
    attributionLike = [attributionLike];
  }
  return (frameState) => attributionLike;
}
var Source, Source_default;
var init_Source = __esm({
  "node_modules/ol/source/Source.js"() {
    init_Object();
    init_proj();
    Source = class extends Object_default {
      /**
       * @param {Options} options Source options.
       */
      constructor(options) {
        super();
        this.projection = get4(options.projection);
        this.attributions_ = adaptAttributions(options.attributions);
        this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;
        this.loading = false;
        this.state_ = options.state !== void 0 ? options.state : "ready";
        this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
        this.interpolate_ = !!options.interpolate;
        this.viewResolver = null;
        this.viewRejector = null;
        const self2 = this;
        this.viewPromise_ = new Promise(function(resolve, reject) {
          self2.viewResolver = resolve;
          self2.viewRejector = reject;
        });
      }
      /**
       * Get the attribution function for the source.
       * @return {?Attribution} Attribution function.
       * @api
       */
      getAttributions() {
        return this.attributions_;
      }
      /**
       * @return {boolean} Attributions are collapsible.
       * @api
       */
      getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
      }
      /**
       * Get the projection of the source.
       * @return {import("../proj/Projection.js").default|null} Projection.
       * @api
       */
      getProjection() {
        return this.projection;
      }
      /**
       * @param {import("../proj/Projection").default} [projection] Projection.
       * @return {Array<number>|null} Resolutions.
       */
      getResolutions(projection) {
        return null;
      }
      /**
       * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
       */
      getView() {
        return this.viewPromise_;
      }
      /**
       * Get the state of the source, see {@link import("./Source.js").State} for possible states.
       * @return {import("./Source.js").State} State.
       * @api
       */
      getState() {
        return this.state_;
      }
      /**
       * @return {boolean|undefined} Wrap X.
       */
      getWrapX() {
        return this.wrapX_;
      }
      /**
       * @return {boolean} Use linear interpolation when resampling.
       */
      getInterpolate() {
        return this.interpolate_;
      }
      /**
       * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
       * @api
       */
      refresh() {
        this.changed();
      }
      /**
       * Set the attributions of the source.
       * @param {AttributionLike|undefined} attributions Attributions.
       *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
       *     or `undefined`.
       * @api
       */
      setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
      }
      /**
       * Set the state of the source.
       * @param {import("./Source.js").State} state State.
       */
      setState(state) {
        this.state_ = state;
        this.changed();
      }
    };
    Source_default = Source;
  }
});

// node_modules/ol/source/VectorEventType.js
var VectorEventType_default;
var init_VectorEventType = __esm({
  "node_modules/ol/source/VectorEventType.js"() {
    VectorEventType_default = {
      /**
       * Triggered when a feature is added to the source.
       * @event module:ol/source/Vector.VectorSourceEvent#addfeature
       * @api
       */
      ADDFEATURE: "addfeature",
      /**
       * Triggered when a feature is updated.
       * @event module:ol/source/Vector.VectorSourceEvent#changefeature
       * @api
       */
      CHANGEFEATURE: "changefeature",
      /**
       * Triggered when the clear method is called on the source.
       * @event module:ol/source/Vector.VectorSourceEvent#clear
       * @api
       */
      CLEAR: "clear",
      /**
       * Triggered when a feature is removed from the source.
       * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
       * @event module:ol/source/Vector.VectorSourceEvent#removefeature
       * @api
       */
      REMOVEFEATURE: "removefeature",
      /**
       * Triggered when features starts loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
       * @api
       */
      FEATURESLOADSTART: "featuresloadstart",
      /**
       * Triggered when features finishes loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
       * @api
       */
      FEATURESLOADEND: "featuresloadend",
      /**
       * Triggered if feature loading results in an error.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
       * @api
       */
      FEATURESLOADERROR: "featuresloaderror"
    };
  }
});

// node_modules/ol/source/Vector.js
var VectorSourceEvent, VectorSource, Vector_default2;
var init_Vector2 = __esm({
  "node_modules/ol/source/Vector.js"() {
    init_Collection();
    init_CollectionEventType();
    init_ObjectEventType();
    init_array();
    init_asserts();
    init_Event();
    init_EventType();
    init_events();
    init_extent();
    init_featureloader();
    init_functions();
    init_loadingstrategy();
    init_obj();
    init_Feature2();
    init_RBush();
    init_util();
    init_Source();
    init_VectorEventType();
    VectorSourceEvent = class extends Event_default {
      /**
       * @param {string} type Type.
       * @param {FeatureType} [feature] Feature.
       * @param {Array<FeatureType>} [features] Features.
       */
      constructor(type, feature, features) {
        super(type);
        this.feature = feature;
        this.features = features;
      }
    };
    VectorSource = class extends Source_default {
      /**
       * @param {Options<FeatureType>} [options] Vector source options.
       */
      constructor(options) {
        options = options || {};
        super({
          attributions: options.attributions,
          interpolate: true,
          projection: void 0,
          state: "ready",
          wrapX: options.wrapX !== void 0 ? options.wrapX : true
        });
        this.on;
        this.once;
        this.un;
        this.loader_ = VOID;
        this.format_ = options.format || null;
        this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
        this.url_ = options.url;
        if (options.loader !== void 0) {
          this.loader_ = options.loader;
        } else if (this.url_ !== void 0) {
          assert(this.format_, "`format` must be set when `url` is set");
          this.loader_ = xhr(this.url_, this.format_);
        }
        this.strategy_ = options.strategy !== void 0 ? options.strategy : all;
        const useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
        this.featuresRtree_ = useSpatialIndex ? new RBush_default() : null;
        this.loadedExtentsRtree_ = new RBush_default();
        this.loadingExtentsCount_ = 0;
        this.nullGeometryFeatures_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
        this.featureChangeKeys_ = {};
        this.featuresCollection_ = null;
        let collection;
        let features;
        if (Array.isArray(options.features)) {
          features = options.features;
        } else if (options.features) {
          collection = options.features;
          features = collection.getArray();
        }
        if (!useSpatialIndex && collection === void 0) {
          collection = new Collection_default(features);
        }
        if (features !== void 0) {
          this.addFeaturesInternal(features);
        }
        if (collection !== void 0) {
          this.bindFeaturesCollection_(collection);
        }
      }
      /**
       * Add a single feature to the source.  If you want to add a batch of features
       * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
       * instead. A feature will not be added to the source if feature with
       * the same id is already there. The reason for this behavior is to avoid
       * feature duplication when using bbox or tile loading strategies.
       * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
       * meaning that if a feature with a duplicate id is added in the collection, it will
       * be removed from it right away.
       * @param {FeatureType} feature Feature to add.
       * @api
       */
      addFeature(feature) {
        this.addFeatureInternal(feature);
        this.changed();
      }
      /**
       * Add a feature without firing a `change` event.
       * @param {FeatureType} feature Feature.
       * @protected
       */
      addFeatureInternal(feature) {
        const featureKey = getUid(feature);
        if (!this.addToIndex_(featureKey, feature)) {
          if (this.featuresCollection_) {
            this.featuresCollection_.remove(feature);
          }
          return;
        }
        this.setupChangeEvents_(featureKey, feature);
        const geometry = feature.getGeometry();
        if (geometry) {
          const extent = geometry.getExtent();
          if (this.featuresRtree_) {
            this.featuresRtree_.insert(extent, feature);
          }
        } else {
          this.nullGeometryFeatures_[featureKey] = feature;
        }
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.ADDFEATURE, feature)
        );
      }
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {FeatureType} feature The feature.
       * @private
       */
      setupChangeEvents_(featureKey, feature) {
        if (feature instanceof Feature_default2) {
          return;
        }
        this.featureChangeKeys_[featureKey] = [
          listen(feature, EventType_default.CHANGE, this.handleFeatureChange_, this),
          listen(
            feature,
            ObjectEventType_default.PROPERTYCHANGE,
            this.handleFeatureChange_,
            this
          )
        ];
      }
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {FeatureType} feature The feature.
       * @return {boolean} The feature is "valid", in the sense that it is also a
       *     candidate for insertion into the Rtree.
       * @private
       */
      addToIndex_(featureKey, feature) {
        let valid = true;
        if (feature.getId() !== void 0) {
          const id = String(feature.getId());
          if (!(id in this.idIndex_)) {
            this.idIndex_[id] = feature;
          } else if (feature instanceof Feature_default2) {
            const indexedFeature = this.idIndex_[id];
            if (!(indexedFeature instanceof Feature_default2)) {
              valid = false;
            } else if (!Array.isArray(indexedFeature)) {
              this.idIndex_[id] = [indexedFeature, feature];
            } else {
              indexedFeature.push(feature);
            }
          } else {
            valid = false;
          }
        }
        if (valid) {
          assert(
            !(featureKey in this.uidIndex_),
            "The passed `feature` was already added to the source"
          );
          this.uidIndex_[featureKey] = feature;
        }
        return valid;
      }
      /**
       * Add a batch of features to the source.
       * @param {Array<FeatureType>} features Features to add.
       * @api
       */
      addFeatures(features) {
        this.addFeaturesInternal(features);
        this.changed();
      }
      /**
       * Add features without firing a `change` event.
       * @param {Array<FeatureType>} features Features.
       * @protected
       */
      addFeaturesInternal(features) {
        const extents = [];
        const newFeatures = [];
        const geometryFeatures = [];
        for (let i7 = 0, length = features.length; i7 < length; i7++) {
          const feature = features[i7];
          const featureKey = getUid(feature);
          if (this.addToIndex_(featureKey, feature)) {
            newFeatures.push(feature);
          }
        }
        for (let i7 = 0, length = newFeatures.length; i7 < length; i7++) {
          const feature = newFeatures[i7];
          const featureKey = getUid(feature);
          this.setupChangeEvents_(featureKey, feature);
          const geometry = feature.getGeometry();
          if (geometry) {
            const extent = geometry.getExtent();
            extents.push(extent);
            geometryFeatures.push(feature);
          } else {
            this.nullGeometryFeatures_[featureKey] = feature;
          }
        }
        if (this.featuresRtree_) {
          this.featuresRtree_.load(extents, geometryFeatures);
        }
        if (this.hasListener(VectorEventType_default.ADDFEATURE)) {
          for (let i7 = 0, length = newFeatures.length; i7 < length; i7++) {
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.ADDFEATURE, newFeatures[i7])
            );
          }
        }
      }
      /**
       * @param {!Collection<FeatureType>} collection Collection.
       * @private
       */
      bindFeaturesCollection_(collection) {
        let modifyingCollection = false;
        this.addEventListener(
          VectorEventType_default.ADDFEATURE,
          /**
           * @param {VectorSourceEvent<FeatureType>} evt The vector source event
           */
          function(evt) {
            if (!modifyingCollection) {
              modifyingCollection = true;
              collection.push(evt.feature);
              modifyingCollection = false;
            }
          }
        );
        this.addEventListener(
          VectorEventType_default.REMOVEFEATURE,
          /**
           * @param {VectorSourceEvent<FeatureType>} evt The vector source event
           */
          function(evt) {
            if (!modifyingCollection) {
              modifyingCollection = true;
              collection.remove(evt.feature);
              modifyingCollection = false;
            }
          }
        );
        collection.addEventListener(
          CollectionEventType_default.ADD,
          /**
           * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
           */
          (evt) => {
            if (!modifyingCollection) {
              modifyingCollection = true;
              this.addFeature(evt.element);
              modifyingCollection = false;
            }
          }
        );
        collection.addEventListener(
          CollectionEventType_default.REMOVE,
          /**
           * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
           */
          (evt) => {
            if (!modifyingCollection) {
              modifyingCollection = true;
              this.removeFeature(evt.element);
              modifyingCollection = false;
            }
          }
        );
        this.featuresCollection_ = collection;
      }
      /**
       * Remove all features from the source.
       * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
       * @api
       */
      clear(fast) {
        if (fast) {
          for (const featureId in this.featureChangeKeys_) {
            const keys = this.featureChangeKeys_[featureId];
            keys.forEach(unlistenByKey);
          }
          if (!this.featuresCollection_) {
            this.featureChangeKeys_ = {};
            this.idIndex_ = {};
            this.uidIndex_ = {};
          }
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.forEach((feature) => {
              this.removeFeatureInternal(feature);
            });
            for (const id in this.nullGeometryFeatures_) {
              this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
            }
          }
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.clear();
        }
        if (this.featuresRtree_) {
          this.featuresRtree_.clear();
        }
        this.nullGeometryFeatures_ = {};
        const clearEvent = new VectorSourceEvent(VectorEventType_default.CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
      }
      /**
       * Iterate through all features on the source, calling the provided callback
       * with each one.  If the callback returns any "truthy" value, iteration will
       * stop and the function will return the same value.
       * Note: this function only iterate through the feature that have a defined geometry.
       *
       * @param {function(FeatureType): T} callback Called with each feature
       *     on the source.  Return a truthy value to stop iteration.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeature(callback) {
        if (this.featuresRtree_) {
          return this.featuresRtree_.forEach(callback);
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.forEach(callback);
        }
      }
      /**
       * Iterate through all features whose geometries contain the provided
       * coordinate, calling the callback with each feature.  If the callback returns
       * a "truthy" value, iteration will stop and the function will return the same
       * value.
       *
       * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
       * called for all features.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(FeatureType): T} callback Called with each feature
       *     whose goemetry contains the provided coordinate.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       */
      forEachFeatureAtCoordinateDirect(coordinate, callback) {
        const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
        return this.forEachFeatureInExtent(extent, function(feature) {
          const geometry = feature.getGeometry();
          if (geometry instanceof Feature_default2 || geometry.intersectsCoordinate(coordinate)) {
            return callback(feature);
          }
          return void 0;
        });
      }
      /**
       * Iterate through all features whose bounding box intersects the provided
       * extent (note that the feature's geometry may not intersect the extent),
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you are interested in features whose geometry intersects an extent, call
       * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
       *
       * When `useSpatialIndex` is set to false, this method will loop through all
       * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(FeatureType): T} callback Called with each feature
       *     whose bounding box intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeatureInExtent(extent, callback) {
        if (this.featuresRtree_) {
          return this.featuresRtree_.forEachInExtent(extent, callback);
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.forEach(callback);
        }
      }
      /**
       * Iterate through all features whose geometry intersects the provided extent,
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you only want to test for bounding box intersection, call the
       * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(FeatureType): T} callback Called with each feature
       *     whose geometry intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeatureIntersectingExtent(extent, callback) {
        return this.forEachFeatureInExtent(
          extent,
          /**
           * @param {FeatureType} feature Feature.
           * @return {T|undefined} The return value from the last call to the callback.
           */
          function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof Feature_default2 || geometry.intersectsExtent(extent)) {
              const result = callback(feature);
              if (result) {
                return result;
              }
            }
          }
        );
      }
      /**
       * Get the features collection associated with this source. Will be `null`
       * unless the source was configured with `useSpatialIndex` set to `false`, or
       * with a {@link module:ol/Collection~Collection} as `features`.
       * @return {Collection<FeatureType>|null} The collection of features.
       * @api
       */
      getFeaturesCollection() {
        return this.featuresCollection_;
      }
      /**
       * Get a snapshot of the features currently on the source in random order. The returned array
       * is a copy, the features are references to the features in the source.
       * @return {Array<FeatureType>} Features.
       * @api
       */
      getFeatures() {
        let features;
        if (this.featuresCollection_) {
          features = this.featuresCollection_.getArray().slice(0);
        } else if (this.featuresRtree_) {
          features = this.featuresRtree_.getAll();
          if (!isEmpty2(this.nullGeometryFeatures_)) {
            extend2(features, Object.values(this.nullGeometryFeatures_));
          }
        }
        return features;
      }
      /**
       * Get all features whose geometry intersects the provided coordinate.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {Array<FeatureType>} Features.
       * @api
       */
      getFeaturesAtCoordinate(coordinate) {
        const features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
          features.push(feature);
        });
        return features;
      }
      /**
       * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
       * all features intersecting the given extent in random order (so it may include
       * features whose geometries do not intersect the extent).
       *
       * When `useSpatialIndex` is set to false, this method will return all
       * features.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {import("../proj/Projection.js").default} [projection] Include features
       * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
       * @return {Array<FeatureType>} Features.
       * @api
       */
      getFeaturesInExtent(extent, projection) {
        if (this.featuresRtree_) {
          const multiWorld = projection && projection.canWrapX() && this.getWrapX();
          if (!multiWorld) {
            return this.featuresRtree_.getInExtent(extent);
          }
          const extents = wrapAndSliceX(extent, projection);
          return [].concat(
            ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent))
          );
        }
        if (this.featuresCollection_) {
          return this.featuresCollection_.getArray().slice(0);
        }
        return [];
      }
      /**
       * Get the closest feature to the provided coordinate.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false` and the features in this source are of type
       * {@link module:ol/Feature~Feature}.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(FeatureType):boolean} [filter] Feature filter function.
       *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
       *     and it should return a boolean value. By default, no filtering is made.
       * @return {FeatureType|null} Closest feature (or `null` if none found).
       * @api
       */
      getClosestFeatureToCoordinate(coordinate, filter) {
        const x4 = coordinate[0];
        const y5 = coordinate[1];
        let closestFeature = null;
        const closestPoint = [NaN, NaN];
        let minSquaredDistance = Infinity;
        const extent = [-Infinity, -Infinity, Infinity, Infinity];
        filter = filter ? filter : TRUE;
        this.featuresRtree_.forEachInExtent(
          extent,
          /**
           * @param {FeatureType} feature Feature.
           */
          function(feature) {
            if (filter(feature)) {
              const geometry = feature.getGeometry();
              const previousMinSquaredDistance = minSquaredDistance;
              minSquaredDistance = geometry instanceof Feature_default2 ? 0 : geometry.closestPointXY(x4, y5, closestPoint, minSquaredDistance);
              if (minSquaredDistance < previousMinSquaredDistance) {
                closestFeature = feature;
                const minDistance = Math.sqrt(minSquaredDistance);
                extent[0] = x4 - minDistance;
                extent[1] = y5 - minDistance;
                extent[2] = x4 + minDistance;
                extent[3] = y5 + minDistance;
              }
            }
          }
        );
        return closestFeature;
      }
      /**
       * Get the extent of the features currently in the source.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false`.
       * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
       *     will be created. Instead, that extent's coordinates will be overwritten.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent(extent) {
        return this.featuresRtree_.getExtent(extent);
      }
      /**
       * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
       * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
       * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
       * `GeometryCollection` member.
       * Note that the index treats string and numeric identifiers as the same.  So
       * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
       *
       * @param {string|number} id Feature identifier.
       * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
       * @api
       */
      getFeatureById(id) {
        const feature = this.idIndex_[id.toString()];
        return feature !== void 0 ? (
          /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
          feature
        ) : null;
      }
      /**
       * Get a feature by its internal unique identifier (using `getUid`).
       *
       * @param {string} uid Feature identifier.
       * @return {FeatureType|null} The feature (or `null` if not found).
       */
      getFeatureByUid(uid) {
        const feature = this.uidIndex_[uid];
        return feature !== void 0 ? feature : null;
      }
      /**
       * Get the format associated with this source.
       *
       * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
       * @api
       */
      getFormat() {
        return this.format_;
      }
      /**
       * @return {boolean} The source can have overlapping geometries.
       */
      getOverlaps() {
        return this.overlaps_;
      }
      /**
       * Get the url associated with this source.
       *
       * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
       * @api
       */
      getUrl() {
        return this.url_;
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      handleFeatureChange_(event) {
        const feature = (
          /** @type {FeatureType} */
          event.target
        );
        const featureKey = getUid(feature);
        const geometry = feature.getGeometry();
        if (!geometry) {
          if (!(featureKey in this.nullGeometryFeatures_)) {
            if (this.featuresRtree_) {
              this.featuresRtree_.remove(feature);
            }
            this.nullGeometryFeatures_[featureKey] = feature;
          }
        } else {
          const extent = geometry.getExtent();
          if (featureKey in this.nullGeometryFeatures_) {
            delete this.nullGeometryFeatures_[featureKey];
            if (this.featuresRtree_) {
              this.featuresRtree_.insert(extent, feature);
            }
          } else {
            if (this.featuresRtree_) {
              this.featuresRtree_.update(extent, feature);
            }
          }
        }
        const id = feature.getId();
        if (id !== void 0) {
          const sid = id.toString();
          if (this.idIndex_[sid] !== feature) {
            this.removeFromIdIndex_(feature);
            this.idIndex_[sid] = feature;
          }
        } else {
          this.removeFromIdIndex_(feature);
          this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.CHANGEFEATURE, feature)
        );
      }
      /**
       * Returns true if the feature is contained within the source.
       * @param {FeatureType} feature Feature.
       * @return {boolean} Has feature.
       * @api
       */
      hasFeature(feature) {
        const id = feature.getId();
        if (id !== void 0) {
          return id in this.idIndex_;
        }
        return getUid(feature) in this.uidIndex_;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        if (this.featuresRtree_) {
          return this.featuresRtree_.isEmpty() && isEmpty2(this.nullGeometryFeatures_);
        }
        if (this.featuresCollection_) {
          return this.featuresCollection_.getLength() === 0;
        }
        return true;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      loadFeatures(extent, resolution, projection) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const extentsToLoad = this.strategy_(extent, resolution, projection);
        for (let i7 = 0, ii = extentsToLoad.length; i7 < ii; ++i7) {
          const extentToLoad = extentsToLoad[i7];
          const alreadyLoaded = loadedExtentsRtree.forEachInExtent(
            extentToLoad,
            /**
             * @param {{extent: import("../extent.js").Extent}} object Object.
             * @return {boolean} Contains.
             */
            function(object) {
              return containsExtent(object.extent, extentToLoad);
            }
          );
          if (!alreadyLoaded) {
            ++this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.FEATURESLOADSTART)
            );
            this.loader_.call(
              this,
              extentToLoad,
              resolution,
              projection,
              /**
               * @param {Array<FeatureType>} features Loaded features
               */
              (features) => {
                --this.loadingExtentsCount_;
                this.dispatchEvent(
                  new VectorSourceEvent(
                    VectorEventType_default.FEATURESLOADEND,
                    void 0,
                    features
                  )
                );
              },
              () => {
                --this.loadingExtentsCount_;
                this.dispatchEvent(
                  new VectorSourceEvent(VectorEventType_default.FEATURESLOADERROR)
                );
              }
            );
            loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
          }
        }
        this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
      }
      /**
       * @override
       */
      refresh() {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        super.refresh();
      }
      /**
       * Remove an extent from the list of loaded extents.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      removeLoadedExtent(extent) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const obj = loadedExtentsRtree.forEachInExtent(extent, function(object) {
          if (equals(object.extent, extent)) {
            return object;
          }
        });
        if (obj) {
          loadedExtentsRtree.remove(obj);
        }
      }
      /**
       * Batch remove features from the source.  If you want to remove all features
       * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
       * instead.
       * @param {Array<FeatureType>} features Features to remove.
       * @api
       */
      removeFeatures(features) {
        let removed = false;
        for (let i7 = 0, ii = features.length; i7 < ii; ++i7) {
          removed = this.removeFeatureInternal(features[i7]) || removed;
        }
        if (removed) {
          this.changed();
        }
      }
      /**
       * Remove a single feature from the source. If you want to batch remove
       * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
       * instead.
       * @param {FeatureType} feature Feature to remove.
       * @api
       */
      removeFeature(feature) {
        if (!feature) {
          return;
        }
        const removed = this.removeFeatureInternal(feature);
        if (removed) {
          this.changed();
        }
      }
      /**
       * Remove feature without firing a `change` event.
       * @param {FeatureType} feature Feature.
       * @return {boolean} True if the feature was removed, false if it was not found.
       * @protected
       */
      removeFeatureInternal(feature) {
        const featureKey = getUid(feature);
        if (!(featureKey in this.uidIndex_)) {
          return false;
        }
        if (featureKey in this.nullGeometryFeatures_) {
          delete this.nullGeometryFeatures_[featureKey];
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.remove(feature);
          }
        }
        const featureChangeKeys = this.featureChangeKeys_[featureKey];
        featureChangeKeys?.forEach(unlistenByKey);
        delete this.featureChangeKeys_[featureKey];
        const id = feature.getId();
        if (id !== void 0) {
          const idString = id.toString();
          const indexedFeature = this.idIndex_[idString];
          if (indexedFeature === feature) {
            delete this.idIndex_[idString];
          } else if (Array.isArray(indexedFeature)) {
            indexedFeature.splice(indexedFeature.indexOf(feature), 1);
            if (indexedFeature.length === 1) {
              this.idIndex_[idString] = indexedFeature[0];
            }
          }
        }
        delete this.uidIndex_[featureKey];
        if (this.hasListener(VectorEventType_default.REMOVEFEATURE)) {
          this.dispatchEvent(
            new VectorSourceEvent(VectorEventType_default.REMOVEFEATURE, feature)
          );
        }
        return true;
      }
      /**
       * Remove a feature from the id index.  Called internally when the feature id
       * may have changed.
       * @param {FeatureType} feature The feature.
       * @private
       */
      removeFromIdIndex_(feature) {
        for (const id in this.idIndex_) {
          if (this.idIndex_[id] === feature) {
            delete this.idIndex_[id];
            break;
          }
        }
      }
      /**
       * Set the new loader of the source. The next render cycle will use the
       * new loader.
       * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
       * @api
       */
      setLoader(loader) {
        this.loader_ = loader;
      }
      /**
       * Points the source to a new url. The next render cycle will use the new url.
       * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
       * @api
       */
      setUrl(url) {
        assert(this.format_, "`format` must be set when `url` is set");
        this.url_ = url;
        this.setLoader(xhr(url, this.format_));
      }
      /**
       * @param {boolean} overlaps The source can have overlapping geometries.
       */
      setOverlaps(overlaps) {
        this.overlaps_ = overlaps;
        this.changed();
      }
    };
    Vector_default2 = VectorSource;
  }
});

// node_modules/ol/interaction/Property.js
var Property_default2;
var init_Property2 = __esm({
  "node_modules/ol/interaction/Property.js"() {
    Property_default2 = {
      ACTIVE: "active"
    };
  }
});

// node_modules/ol/interaction/Interaction.js
var Interaction, Interaction_default;
var init_Interaction = __esm({
  "node_modules/ol/interaction/Interaction.js"() {
    init_Object();
    init_Property2();
    Interaction = class extends Object_default {
      /**
       * @param {InteractionOptions} [options] Options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        if (options && options.handleEvent) {
          this.handleEvent = options.handleEvent;
        }
        this.map_ = null;
        this.setActive(true);
      }
      /**
       * Return whether the interaction is currently active.
       * @return {boolean} `true` if the interaction is active, `false` otherwise.
       * @observable
       * @api
       */
      getActive() {
        return (
          /** @type {boolean} */
          this.get(Property_default2.ACTIVE)
        );
      }
      /**
       * Get the map associated with this interaction.
       * @return {import("../Map.js").default|null} Map.
       * @api
       */
      getMap() {
        return this.map_;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */
      handleEvent(mapBrowserEvent) {
        return true;
      }
      /**
       * Activate or deactivate the interaction.
       * @param {boolean} active Active.
       * @observable
       * @api
       */
      setActive(active) {
        this.set(Property_default2.ACTIVE, active);
      }
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../Map.js").default|null} map Map.
       */
      setMap(map) {
        this.map_ = map;
      }
    };
    Interaction_default = Interaction;
  }
});

// node_modules/ol/interaction/Pointer.js
var PointerInteraction, Pointer_default;
var init_Pointer = __esm({
  "node_modules/ol/interaction/Pointer.js"() {
    init_MapBrowserEventType();
    init_Interaction();
    PointerInteraction = class extends Interaction_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options ? options : {};
        super(
          /** @type {import("./Interaction.js").InteractionOptions} */
          options
        );
        if (options.handleDownEvent) {
          this.handleDownEvent = options.handleDownEvent;
        }
        if (options.handleDragEvent) {
          this.handleDragEvent = options.handleDragEvent;
        }
        if (options.handleMoveEvent) {
          this.handleMoveEvent = options.handleMoveEvent;
        }
        if (options.handleUpEvent) {
          this.handleUpEvent = options.handleUpEvent;
        }
        if (options.stopDown) {
          this.stopDown = options.stopDown;
        }
        this.handlingDownUpSequence = false;
        this.targetPointers = [];
      }
      /**
       * Returns the current number of pointers involved in the interaction,
       * e.g. `2` when two fingers are used.
       * @return {number} The number of pointers.
       * @api
       */
      getPointerCount() {
        return this.targetPointers.length;
      }
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */
      handleDownEvent(mapBrowserEvent) {
        return false;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */
      handleDragEvent(mapBrowserEvent) {
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
       * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
       * detected.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       * @override
       */
      handleEvent(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) {
          return true;
        }
        let stopEvent = false;
        this.updateTrackedPointers_(mapBrowserEvent);
        if (this.handlingDownUpSequence) {
          if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDRAG) {
            this.handleDragEvent(mapBrowserEvent);
            mapBrowserEvent.originalEvent.preventDefault();
          } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERUP) {
            const handledUp = this.handleUpEvent(mapBrowserEvent);
            this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
          }
        } else {
          if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDOWN) {
            const handled = this.handleDownEvent(mapBrowserEvent);
            this.handlingDownUpSequence = handled;
            stopEvent = this.stopDown(handled);
          } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE) {
            this.handleMoveEvent(mapBrowserEvent);
          }
        }
        return !stopEvent;
      }
      /**
       * Handle pointer move events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */
      handleMoveEvent(mapBrowserEvent) {
      }
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */
      handleUpEvent(mapBrowserEvent) {
        return false;
      }
      /**
       * This function is used to determine if "down" events should be propagated
       * to other interactions or should be stopped.
       * @param {boolean} handled Was the event handled by the interaction?
       * @return {boolean} Should the `down` event be stopped?
       */
      stopDown(handled) {
        return handled;
      }
      /**
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @private
       */
      updateTrackedPointers_(mapBrowserEvent) {
        if (mapBrowserEvent.activePointers) {
          this.targetPointers = mapBrowserEvent.activePointers;
        }
      }
    };
    Pointer_default = PointerInteraction;
  }
});

// node_modules/ol/interaction/Draw.js
function getTraceTargets(coordinate, features) {
  const targets = [];
  for (let i7 = 0; i7 < features.length; ++i7) {
    const feature = features[i7];
    const geometry = feature.getGeometry();
    appendGeometryTraceTargets(coordinate, geometry, targets);
  }
  return targets;
}
function getSquaredDistance(a5, b8) {
  return squaredDistance(a5[0], a5[1], b8[0], b8[1]);
}
function getCoordinate(coordinates2, index13) {
  const count = coordinates2.length;
  if (index13 < 0) {
    return coordinates2[index13 + count];
  }
  if (index13 >= count) {
    return coordinates2[index13 - count];
  }
  return coordinates2[index13];
}
function getCumulativeSquaredDistance(coordinates2, startIndex, endIndex) {
  let lowIndex, highIndex;
  if (startIndex < endIndex) {
    lowIndex = startIndex;
    highIndex = endIndex;
  } else {
    lowIndex = endIndex;
    highIndex = startIndex;
  }
  const lowWholeIndex = Math.ceil(lowIndex);
  const highWholeIndex = Math.floor(highIndex);
  if (lowWholeIndex > highWholeIndex) {
    const start2 = interpolateCoordinate(coordinates2, lowIndex);
    const end = interpolateCoordinate(coordinates2, highIndex);
    return getSquaredDistance(start2, end);
  }
  let sd = 0;
  if (lowIndex < lowWholeIndex) {
    const start2 = interpolateCoordinate(coordinates2, lowIndex);
    const end = getCoordinate(coordinates2, lowWholeIndex);
    sd += getSquaredDistance(start2, end);
  }
  if (highWholeIndex < highIndex) {
    const start2 = getCoordinate(coordinates2, highWholeIndex);
    const end = interpolateCoordinate(coordinates2, highIndex);
    sd += getSquaredDistance(start2, end);
  }
  for (let i7 = lowWholeIndex; i7 < highWholeIndex - 1; ++i7) {
    const start2 = getCoordinate(coordinates2, i7);
    const end = getCoordinate(coordinates2, i7 + 1);
    sd += getSquaredDistance(start2, end);
  }
  return sd;
}
function appendGeometryTraceTargets(coordinate, geometry, targets) {
  if (geometry instanceof LineString_default) {
    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);
    return;
  }
  if (geometry instanceof MultiLineString_default) {
    const coordinates2 = geometry.getCoordinates();
    for (let i7 = 0, ii = coordinates2.length; i7 < ii; ++i7) {
      appendTraceTarget(coordinate, coordinates2[i7], false, targets);
    }
    return;
  }
  if (geometry instanceof Polygon_default) {
    const coordinates2 = geometry.getCoordinates();
    for (let i7 = 0, ii = coordinates2.length; i7 < ii; ++i7) {
      appendTraceTarget(coordinate, coordinates2[i7], true, targets);
    }
    return;
  }
  if (geometry instanceof MultiPolygon_default) {
    const polys = geometry.getCoordinates();
    for (let i7 = 0, ii = polys.length; i7 < ii; ++i7) {
      const coordinates2 = polys[i7];
      for (let j6 = 0, jj = coordinates2.length; j6 < jj; ++j6) {
        appendTraceTarget(coordinate, coordinates2[j6], true, targets);
      }
    }
    return;
  }
  if (geometry instanceof GeometryCollection_default) {
    const geometries = geometry.getGeometries();
    for (let i7 = 0; i7 < geometries.length; ++i7) {
      appendGeometryTraceTargets(coordinate, geometries[i7], targets);
    }
    return;
  }
}
function getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {
  const x4 = coordinate[0];
  const y5 = coordinate[1];
  let closestTargetDistance = Infinity;
  let newTargetIndex = -1;
  let newEndIndex = NaN;
  for (let targetIndex = 0; targetIndex < traceState.targets.length; ++targetIndex) {
    const target = traceState.targets[targetIndex];
    const coordinates2 = target.coordinates;
    let minSegmentDistance = Infinity;
    let endIndex;
    for (let coordinateIndex = 0; coordinateIndex < coordinates2.length - 1; ++coordinateIndex) {
      const start2 = coordinates2[coordinateIndex];
      const end = coordinates2[coordinateIndex + 1];
      const rel = getPointSegmentRelationship(x4, y5, start2, end);
      if (rel.squaredDistance < minSegmentDistance) {
        minSegmentDistance = rel.squaredDistance;
        endIndex = coordinateIndex + rel.along;
      }
    }
    if (minSegmentDistance < closestTargetDistance) {
      closestTargetDistance = minSegmentDistance;
      if (target.ring && traceState.targetIndex === targetIndex) {
        if (target.endIndex > target.startIndex) {
          if (endIndex < target.startIndex) {
            endIndex += coordinates2.length;
          }
        } else if (target.endIndex < target.startIndex) {
          if (endIndex > target.startIndex) {
            endIndex -= coordinates2.length;
          }
        }
      }
      newEndIndex = endIndex;
      newTargetIndex = targetIndex;
    }
  }
  const newTarget = traceState.targets[newTargetIndex];
  let considerBothDirections = newTarget.ring;
  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {
    const newCoordinate = interpolateCoordinate(
      newTarget.coordinates,
      newEndIndex
    );
    const pixel = map.getPixelFromCoordinate(newCoordinate);
    if (distance(pixel, traceState.startPx) > snapTolerance) {
      considerBothDirections = false;
    }
  }
  if (considerBothDirections) {
    const coordinates2 = newTarget.coordinates;
    const count = coordinates2.length;
    const startIndex = newTarget.startIndex;
    const endIndex = newEndIndex;
    if (startIndex < endIndex) {
      const forwardDistance = getCumulativeSquaredDistance(
        coordinates2,
        startIndex,
        endIndex
      );
      const reverseDistance = getCumulativeSquaredDistance(
        coordinates2,
        startIndex,
        endIndex - count
      );
      if (reverseDistance < forwardDistance) {
        newEndIndex -= count;
      }
    } else {
      const reverseDistance = getCumulativeSquaredDistance(
        coordinates2,
        startIndex,
        endIndex
      );
      const forwardDistance = getCumulativeSquaredDistance(
        coordinates2,
        startIndex,
        endIndex + count
      );
      if (forwardDistance < reverseDistance) {
        newEndIndex += count;
      }
    }
  }
  sharedUpdateInfo.index = newTargetIndex;
  sharedUpdateInfo.endIndex = newEndIndex;
  return sharedUpdateInfo;
}
function appendTraceTarget(coordinate, coordinates2, ring, targets) {
  const x4 = coordinate[0];
  const y5 = coordinate[1];
  for (let i7 = 0, ii = coordinates2.length - 1; i7 < ii; ++i7) {
    const start2 = coordinates2[i7];
    const end = coordinates2[i7 + 1];
    const rel = getPointSegmentRelationship(x4, y5, start2, end);
    if (rel.squaredDistance === 0) {
      const index13 = i7 + rel.along;
      targets.push({
        coordinates: coordinates2,
        ring,
        startIndex: index13,
        endIndex: index13
      });
      return;
    }
  }
}
function getPointSegmentRelationship(x4, y5, start2, end) {
  const x1 = start2[0];
  const y1 = start2[1];
  const x22 = end[0];
  const y22 = end[1];
  const dx = x22 - x1;
  const dy = y22 - y1;
  let along = 0;
  let px = x1;
  let py = y1;
  if (dx !== 0 || dy !== 0) {
    along = clamp(((x4 - x1) * dx + (y5 - y1) * dy) / (dx * dx + dy * dy), 0, 1);
    px += dx * along;
    py += dy * along;
  }
  sharedRel.along = along;
  sharedRel.squaredDistance = toFixed(squaredDistance(x4, y5, px, py), 10);
  return sharedRel;
}
function interpolateCoordinate(coordinates2, index13) {
  const count = coordinates2.length;
  let startIndex = Math.floor(index13);
  const along = index13 - startIndex;
  if (startIndex >= count) {
    startIndex -= count;
  } else if (startIndex < 0) {
    startIndex += count;
  }
  let endIndex = startIndex + 1;
  if (endIndex >= count) {
    endIndex -= count;
  }
  const start2 = coordinates2[startIndex];
  const x0 = start2[0];
  const y0 = start2[1];
  const end = coordinates2[endIndex];
  const dx = end[0] - x0;
  const dy = end[1] - y0;
  return [x0 + dx * along, y0 + dy * along];
}
function getDefaultStyleFunction() {
  const styles = createEditingStyle();
  return function(feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}
function getMode(type) {
  switch (type) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + type);
  }
}
var DrawEventType, DrawEvent, sharedUpdateInfo, sharedRel, Draw, Draw_default;
var init_Draw = __esm({
  "node_modules/ol/interaction/Draw.js"() {
    init_Feature();
    init_MapBrowserEvent();
    init_MapBrowserEventType();
    init_coordinate();
    init_Event();
    init_EventType();
    init_condition();
    init_extent();
    init_functions();
    init_Circle();
    init_GeometryCollection();
    init_LineString();
    init_MultiLineString();
    init_MultiPoint();
    init_MultiPolygon();
    init_Point();
    init_Polygon();
    init_SimpleGeometry();
    init_Vector();
    init_math();
    init_proj();
    init_Vector2();
    init_Style();
    init_Pointer();
    init_Property2();
    DrawEventType = {
      /**
       * Triggered upon feature draw start
       * @event DrawEvent#drawstart
       * @api
       */
      DRAWSTART: "drawstart",
      /**
       * Triggered upon feature draw end
       * @event DrawEvent#drawend
       * @api
       */
      DRAWEND: "drawend",
      /**
       * Triggered upon feature draw abortion
       * @event DrawEvent#drawabort
       * @api
       */
      DRAWABORT: "drawabort"
    };
    DrawEvent = class extends Event_default {
      /**
       * @param {DrawEventType} type Type.
       * @param {Feature} feature The feature drawn.
       */
      constructor(type, feature) {
        super(type);
        this.feature = feature;
      }
    };
    sharedUpdateInfo = { index: -1, endIndex: NaN };
    sharedRel = { along: 0, squaredDistance: 0 };
    Draw = class extends Pointer_default {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        const pointerOptions = (
          /** @type {import("./Pointer.js").Options} */
          options
        );
        if (!pointerOptions.stopDown) {
          pointerOptions.stopDown = FALSE;
        }
        super(pointerOptions);
        this.on;
        this.once;
        this.un;
        this.shouldHandle_ = false;
        this.downPx_ = null;
        this.downTimeout_;
        this.lastDragTime_;
        this.pointerType_;
        this.freehand_ = false;
        this.source_ = options.source ? options.source : null;
        this.features_ = options.features ? options.features : null;
        this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
        this.type_ = /** @type {import("../geom/Geometry.js").Type} */
        options.type;
        this.mode_ = getMode(this.type_);
        this.stopClick_ = !!options.stopClick;
        this.minPoints_ = options.minPoints ? options.minPoints : this.mode_ === "Polygon" ? 3 : 2;
        this.maxPoints_ = this.mode_ === "Circle" ? 2 : options.maxPoints ? options.maxPoints : Infinity;
        this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;
        this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : "XY";
        let geometryFunction = options.geometryFunction;
        if (!geometryFunction) {
          const mode2 = this.mode_;
          if (mode2 === "Circle") {
            geometryFunction = (coordinates2, geometry, projection) => {
              const circle = geometry ? (
                /** @type {Circle} */
                geometry
              ) : new Circle_default([NaN, NaN]);
              const center = fromUserCoordinate(coordinates2[0], projection);
              const squaredLength = squaredDistance2(
                center,
                fromUserCoordinate(coordinates2[coordinates2.length - 1], projection)
              );
              circle.setCenterAndRadius(
                center,
                Math.sqrt(squaredLength),
                this.geometryLayout_
              );
              const userProjection2 = getUserProjection();
              if (userProjection2) {
                circle.transform(projection, userProjection2);
              }
              return circle;
            };
          } else {
            let Constructor;
            if (mode2 === "Point") {
              Constructor = Point_default;
            } else if (mode2 === "LineString") {
              Constructor = LineString_default;
            } else if (mode2 === "Polygon") {
              Constructor = Polygon_default;
            }
            geometryFunction = (coordinates2, geometry, projection) => {
              if (geometry) {
                if (mode2 === "Polygon") {
                  if (coordinates2[0].length) {
                    geometry.setCoordinates(
                      [coordinates2[0].concat([coordinates2[0][0]])],
                      this.geometryLayout_
                    );
                  } else {
                    geometry.setCoordinates([], this.geometryLayout_);
                  }
                } else {
                  geometry.setCoordinates(coordinates2, this.geometryLayout_);
                }
              } else {
                geometry = new Constructor(coordinates2, this.geometryLayout_);
              }
              return geometry;
            };
          }
        }
        this.geometryFunction_ = geometryFunction;
        this.dragVertexDelay_ = options.dragVertexDelay !== void 0 ? options.dragVertexDelay : 500;
        this.finishCoordinate_ = null;
        this.sketchFeature_ = null;
        this.sketchPoint_ = null;
        this.sketchCoords_ = null;
        this.sketchLine_ = null;
        this.sketchLineCoords_ = null;
        this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
        this.overlay_ = new Vector_default({
          source: new Vector_default2({
            useSpatialIndex: false,
            wrapX: options.wrapX ? options.wrapX : false
          }),
          style: options.style ? options.style : getDefaultStyleFunction(),
          updateWhileInteracting: true
        });
        this.geometryName_ = options.geometryName;
        this.condition_ = options.condition ? options.condition : noModifierKeys;
        this.freehandCondition_;
        if (options.freehand) {
          this.freehandCondition_ = always;
        } else {
          this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;
        }
        this.traceCondition_;
        this.setTrace(options.trace || false);
        this.traceState_ = { active: false };
        this.traceSource_ = options.traceSource || options.source || null;
        this.addChangeListener(Property_default2.ACTIVE, this.updateState_);
      }
      /**
       * Toggle tracing mode or set a tracing condition.
       *
       * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
       *     condition that will be checked when a feature is clicked to determine if tracing should be active.
       */
      setTrace(trace) {
        let condition;
        if (!trace) {
          condition = never;
        } else if (trace === true) {
          condition = always;
        } else {
          condition = trace;
        }
        this.traceCondition_ = condition;
      }
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../Map.js").default} map Map.
       * @override
       */
      setMap(map) {
        super.setMap(map);
        this.updateState_();
      }
      /**
       * Get the overlay layer that this interaction renders sketch features to.
       * @return {VectorLayer} Overlay layer.
       * @api
       */
      getOverlay() {
        return this.overlay_;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
       * @param {import("../MapBrowserEvent.js").default<PointerEvent>} event Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       * @override
       */
      handleEvent(event) {
        if (event.originalEvent.type === EventType_default.CONTEXTMENU) {
          event.originalEvent.preventDefault();
        }
        this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(event);
        let move = event.type === MapBrowserEventType_default.POINTERMOVE;
        let pass = true;
        if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType_default.POINTERDRAG) {
          const now = Date.now();
          if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
            this.downPx_ = event.pixel;
            this.shouldHandle_ = !this.freehand_;
            move = true;
          } else {
            this.lastDragTime_ = void 0;
          }
          if (this.shouldHandle_ && this.downTimeout_ !== void 0) {
            clearTimeout(this.downTimeout_);
            this.downTimeout_ = void 0;
          }
        }
        if (this.freehand_ && event.type === MapBrowserEventType_default.POINTERDRAG && this.sketchFeature_ !== null) {
          this.addToDrawing_(event.coordinate);
          pass = false;
        } else if (this.freehand_ && event.type === MapBrowserEventType_default.POINTERDOWN) {
          pass = false;
        } else if (move && this.getPointerCount() < 2) {
          pass = event.type === MapBrowserEventType_default.POINTERMOVE;
          if (pass && this.freehand_) {
            this.handlePointerMove_(event);
            if (this.shouldHandle_) {
              event.originalEvent.preventDefault();
            }
          } else if (event.originalEvent.pointerType === "mouse" || event.type === MapBrowserEventType_default.POINTERDRAG && this.downTimeout_ === void 0) {
            this.handlePointerMove_(event);
          }
        } else if (event.type === MapBrowserEventType_default.DBLCLICK) {
          pass = false;
        }
        return super.handleEvent(event) && pass;
      }
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default<PointerEvent>} event Event.
       * @return {boolean} If the event was consumed.
       * @override
       */
      handleDownEvent(event) {
        this.shouldHandle_ = !this.freehand_;
        if (this.freehand_) {
          this.downPx_ = event.pixel;
          if (!this.finishCoordinate_) {
            this.startDrawing_(event.coordinate);
          }
          return true;
        }
        if (!this.condition_(event)) {
          this.lastDragTime_ = void 0;
          return false;
        }
        this.lastDragTime_ = Date.now();
        this.downTimeout_ = setTimeout(() => {
          this.handlePointerMove_(
            new MapBrowserEvent_default(
              MapBrowserEventType_default.POINTERMOVE,
              event.map,
              event.originalEvent,
              false,
              event.frameState
            )
          );
        }, this.dragVertexDelay_);
        this.downPx_ = event.pixel;
        return true;
      }
      /**
       * @private
       */
      deactivateTrace_() {
        this.traceState_ = { active: false };
      }
      /**
       * Activate or deactivate trace state based on a browser event.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @private
       */
      toggleTraceState_(event) {
        if (!this.traceSource_ || !this.traceCondition_(event)) {
          return;
        }
        if (this.traceState_.active) {
          this.deactivateTrace_();
          return;
        }
        const map = this.getMap();
        const lowerLeft = map.getCoordinateFromPixel([
          event.pixel[0] - this.snapTolerance_,
          event.pixel[1] + this.snapTolerance_
        ]);
        const upperRight = map.getCoordinateFromPixel([
          event.pixel[0] + this.snapTolerance_,
          event.pixel[1] - this.snapTolerance_
        ]);
        const extent = boundingExtent([lowerLeft, upperRight]);
        const features = this.traceSource_.getFeaturesInExtent(extent);
        if (features.length === 0) {
          return;
        }
        const targets = getTraceTargets(event.coordinate, features);
        if (targets.length) {
          this.traceState_ = {
            active: true,
            startPx: event.pixel.slice(),
            targets,
            targetIndex: -1
          };
        }
      }
      /**
       * @param {TraceTarget} target The trace target.
       * @param {number} endIndex The new end index of the trace.
       * @private
       */
      addOrRemoveTracedCoordinates_(target, endIndex) {
        const previouslyForward = target.startIndex <= target.endIndex;
        const currentlyForward = target.startIndex <= endIndex;
        if (previouslyForward === currentlyForward) {
          if (previouslyForward && endIndex > target.endIndex || !previouslyForward && endIndex < target.endIndex) {
            this.addTracedCoordinates_(target, target.endIndex, endIndex);
          } else if (previouslyForward && endIndex < target.endIndex || !previouslyForward && endIndex > target.endIndex) {
            this.removeTracedCoordinates_(endIndex, target.endIndex);
          }
        } else {
          this.removeTracedCoordinates_(target.startIndex, target.endIndex);
          this.addTracedCoordinates_(target, target.startIndex, endIndex);
        }
      }
      /**
       * @param {number} fromIndex The start index.
       * @param {number} toIndex The end index.
       * @private
       */
      removeTracedCoordinates_(fromIndex, toIndex) {
        if (fromIndex === toIndex) {
          return;
        }
        let remove2 = 0;
        if (fromIndex < toIndex) {
          const start2 = Math.ceil(fromIndex);
          let end = Math.floor(toIndex);
          if (end === toIndex) {
            end -= 1;
          }
          remove2 = end - start2 + 1;
        } else {
          const start2 = Math.floor(fromIndex);
          let end = Math.ceil(toIndex);
          if (end === toIndex) {
            end += 1;
          }
          remove2 = start2 - end + 1;
        }
        if (remove2 > 0) {
          this.removeLastPoints_(remove2);
        }
      }
      /**
       * @param {TraceTarget} target The trace target.
       * @param {number} fromIndex The start index.
       * @param {number} toIndex The end index.
       * @private
       */
      addTracedCoordinates_(target, fromIndex, toIndex) {
        if (fromIndex === toIndex) {
          return;
        }
        const coordinates2 = [];
        if (fromIndex < toIndex) {
          const start2 = Math.ceil(fromIndex);
          let end = Math.floor(toIndex);
          if (end === toIndex) {
            end -= 1;
          }
          for (let i7 = start2; i7 <= end; ++i7) {
            coordinates2.push(getCoordinate(target.coordinates, i7));
          }
        } else {
          const start2 = Math.floor(fromIndex);
          let end = Math.ceil(toIndex);
          if (end === toIndex) {
            end += 1;
          }
          for (let i7 = start2; i7 >= end; --i7) {
            coordinates2.push(getCoordinate(target.coordinates, i7));
          }
        }
        if (coordinates2.length) {
          this.appendCoordinates(coordinates2);
        }
      }
      /**
       * Update the trace.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @private
       */
      updateTrace_(event) {
        const traceState = this.traceState_;
        if (!traceState.active) {
          return;
        }
        if (traceState.targetIndex === -1) {
          if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {
            return;
          }
        }
        const updatedTraceTarget = getTraceTargetUpdate(
          event.coordinate,
          traceState,
          this.getMap(),
          this.snapTolerance_
        );
        if (traceState.targetIndex !== updatedTraceTarget.index) {
          if (traceState.targetIndex !== -1) {
            const oldTarget = traceState.targets[traceState.targetIndex];
            this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);
          }
          const newTarget = traceState.targets[updatedTraceTarget.index];
          this.addTracedCoordinates_(
            newTarget,
            newTarget.startIndex,
            updatedTraceTarget.endIndex
          );
        } else {
          const target2 = traceState.targets[traceState.targetIndex];
          this.addOrRemoveTracedCoordinates_(target2, updatedTraceTarget.endIndex);
        }
        traceState.targetIndex = updatedTraceTarget.index;
        const target = traceState.targets[traceState.targetIndex];
        target.endIndex = updatedTraceTarget.endIndex;
        const coordinate = interpolateCoordinate(
          target.coordinates,
          target.endIndex
        );
        const pixel = this.getMap().getPixelFromCoordinate(coordinate);
        event.coordinate = coordinate;
        event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];
      }
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default<PointerEvent>} event Event.
       * @return {boolean} If the event was consumed.
       * @override
       */
      handleUpEvent(event) {
        let pass = true;
        if (this.getPointerCount() === 0) {
          if (this.downTimeout_) {
            clearTimeout(this.downTimeout_);
            this.downTimeout_ = void 0;
          }
          this.handlePointerMove_(event);
          const tracing = this.traceState_.active;
          this.toggleTraceState_(event);
          if (this.shouldHandle_) {
            const startingToDraw = !this.finishCoordinate_;
            if (startingToDraw) {
              this.startDrawing_(event.coordinate);
            }
            if (!startingToDraw && this.freehand_) {
              this.finishDrawing();
            } else if (!this.freehand_ && (!startingToDraw || this.mode_ === "Point")) {
              if (this.atFinish_(event.pixel, tracing)) {
                if (this.finishCondition_(event)) {
                  this.finishDrawing();
                }
              } else {
                this.addToDrawing_(event.coordinate);
              }
            }
            pass = false;
          } else if (this.freehand_) {
            this.abortDrawing();
          }
        }
        if (!pass && this.stopClick_) {
          event.preventDefault();
        }
        return pass;
      }
      /**
       * Handle move events.
       * @param {import("../MapBrowserEvent.js").default<PointerEvent>} event A move event.
       * @private
       */
      handlePointerMove_(event) {
        this.pointerType_ = event.originalEvent.pointerType;
        if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
          const downPx = this.downPx_;
          const clickPx = event.pixel;
          const dx = downPx[0] - clickPx[0];
          const dy = downPx[1] - clickPx[1];
          const squaredDistance4 = dx * dx + dy * dy;
          this.shouldHandle_ = this.freehand_ ? squaredDistance4 > this.squaredClickTolerance_ : squaredDistance4 <= this.squaredClickTolerance_;
          if (!this.shouldHandle_) {
            return;
          }
        }
        if (!this.finishCoordinate_) {
          this.createOrUpdateSketchPoint_(event.coordinate.slice());
          return;
        }
        this.updateTrace_(event);
        this.modifyDrawing_(event.coordinate);
      }
      /**
       * Determine if an event is within the snapping tolerance of the start coord.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
       * @return {boolean} The event is within the snapping tolerance of the start.
       * @private
       */
      atFinish_(pixel, tracing) {
        let at3 = false;
        if (this.sketchFeature_) {
          let potentiallyDone = false;
          let potentiallyFinishCoordinates = [this.finishCoordinate_];
          const mode2 = this.mode_;
          if (mode2 === "Point") {
            at3 = true;
          } else if (mode2 === "Circle") {
            at3 = this.sketchCoords_.length === 2;
          } else if (mode2 === "LineString") {
            potentiallyDone = !tracing && this.sketchCoords_.length > this.minPoints_;
          } else if (mode2 === "Polygon") {
            const sketchCoords = (
              /** @type {PolyCoordType} */
              this.sketchCoords_
            );
            potentiallyDone = sketchCoords[0].length > this.minPoints_;
            potentiallyFinishCoordinates = [
              sketchCoords[0][0],
              sketchCoords[0][sketchCoords[0].length - 2]
            ];
            if (tracing) {
              potentiallyFinishCoordinates = [sketchCoords[0][0]];
            } else {
              potentiallyFinishCoordinates = [
                sketchCoords[0][0],
                sketchCoords[0][sketchCoords[0].length - 2]
              ];
            }
          }
          if (potentiallyDone) {
            const map = this.getMap();
            for (let i7 = 0, ii = potentiallyFinishCoordinates.length; i7 < ii; i7++) {
              const finishCoordinate = potentiallyFinishCoordinates[i7];
              const finishPixel = map.getPixelFromCoordinate(finishCoordinate);
              const dx = pixel[0] - finishPixel[0];
              const dy = pixel[1] - finishPixel[1];
              const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
              at3 = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
              if (at3) {
                this.finishCoordinate_ = finishCoordinate;
                break;
              }
            }
          }
        }
        return at3;
      }
      /**
       * @param {import("../coordinate").Coordinate} coordinates Coordinate.
       * @private
       */
      createOrUpdateSketchPoint_(coordinates2) {
        if (!this.sketchPoint_) {
          this.sketchPoint_ = new Feature_default(new Point_default(coordinates2));
          this.updateSketchFeatures_();
        } else {
          const sketchPointGeom = this.sketchPoint_.getGeometry();
          sketchPointGeom.setCoordinates(coordinates2);
        }
      }
      /**
       * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
       * @private
       */
      createOrUpdateCustomSketchLine_(geometry) {
        if (!this.sketchLine_) {
          this.sketchLine_ = new Feature_default();
        }
        const ring = geometry.getLinearRing(0);
        let sketchLineGeom = this.sketchLine_.getGeometry();
        if (!sketchLineGeom) {
          sketchLineGeom = new LineString_default(
            ring.getFlatCoordinates(),
            ring.getLayout()
          );
          this.sketchLine_.setGeometry(sketchLineGeom);
        } else {
          sketchLineGeom.setFlatCoordinates(
            ring.getLayout(),
            ring.getFlatCoordinates()
          );
          sketchLineGeom.changed();
        }
      }
      /**
       * Start the drawing.
       * @param {import("../coordinate.js").Coordinate} start Start coordinate.
       * @private
       */
      startDrawing_(start2) {
        const projection = this.getMap().getView().getProjection();
        const stride = getStrideForLayout(this.geometryLayout_);
        while (start2.length < stride) {
          start2.push(0);
        }
        this.finishCoordinate_ = start2;
        if (this.mode_ === "Point") {
          this.sketchCoords_ = start2.slice();
        } else if (this.mode_ === "Polygon") {
          this.sketchCoords_ = [[start2.slice(), start2.slice()]];
          this.sketchLineCoords_ = this.sketchCoords_[0];
        } else {
          this.sketchCoords_ = [start2.slice(), start2.slice()];
        }
        if (this.sketchLineCoords_) {
          this.sketchLine_ = new Feature_default(new LineString_default(this.sketchLineCoords_));
        }
        const geometry = this.geometryFunction_(
          this.sketchCoords_,
          void 0,
          projection
        );
        this.sketchFeature_ = new Feature_default();
        if (this.geometryName_) {
          this.sketchFeature_.setGeometryName(this.geometryName_);
        }
        this.sketchFeature_.setGeometry(geometry);
        this.updateSketchFeatures_();
        this.dispatchEvent(
          new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)
        );
      }
      /**
       * Modify the drawing.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @private
       */
      modifyDrawing_(coordinate) {
        const map = this.getMap();
        const geometry = this.sketchFeature_.getGeometry();
        const projection = map.getView().getProjection();
        const stride = getStrideForLayout(this.geometryLayout_);
        let coordinates2, last;
        while (coordinate.length < stride) {
          coordinate.push(0);
        }
        if (this.mode_ === "Point") {
          last = this.sketchCoords_;
        } else if (this.mode_ === "Polygon") {
          coordinates2 = /** @type {PolyCoordType} */
          this.sketchCoords_[0];
          last = coordinates2[coordinates2.length - 1];
          if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
            coordinate = this.finishCoordinate_.slice();
          }
        } else {
          coordinates2 = this.sketchCoords_;
          last = coordinates2[coordinates2.length - 1];
        }
        last[0] = coordinate[0];
        last[1] = coordinate[1];
        this.geometryFunction_(
          /** @type {!LineCoordType} */
          this.sketchCoords_,
          geometry,
          projection
        );
        if (this.sketchPoint_) {
          const sketchPointGeom = this.sketchPoint_.getGeometry();
          sketchPointGeom.setCoordinates(coordinate);
        }
        if (geometry.getType() === "Polygon" && this.mode_ !== "Polygon") {
          this.createOrUpdateCustomSketchLine_(
            /** @type {Polygon} */
            geometry
          );
        } else if (this.sketchLineCoords_) {
          const sketchLineGeom = this.sketchLine_.getGeometry();
          sketchLineGeom.setCoordinates(this.sketchLineCoords_);
        }
        this.updateSketchFeatures_();
      }
      /**
       * Add a new coordinate to the drawing.
       * @param {!PointCoordType} coordinate Coordinate
       * @return {Feature<import("../geom/SimpleGeometry.js").default>} The sketch feature.
       * @private
       */
      addToDrawing_(coordinate) {
        const geometry = this.sketchFeature_.getGeometry();
        const projection = this.getMap().getView().getProjection();
        let done;
        let coordinates2;
        const mode2 = this.mode_;
        if (mode2 === "LineString" || mode2 === "Circle") {
          this.finishCoordinate_ = coordinate.slice();
          coordinates2 = /** @type {LineCoordType} */
          this.sketchCoords_;
          if (coordinates2.length >= this.maxPoints_) {
            if (this.freehand_) {
              coordinates2.pop();
            } else {
              done = true;
            }
          }
          coordinates2.push(coordinate.slice());
          this.geometryFunction_(coordinates2, geometry, projection);
        } else if (mode2 === "Polygon") {
          coordinates2 = /** @type {PolyCoordType} */
          this.sketchCoords_[0];
          if (coordinates2.length >= this.maxPoints_) {
            if (this.freehand_) {
              coordinates2.pop();
            } else {
              done = true;
            }
          }
          coordinates2.push(coordinate.slice());
          if (done) {
            this.finishCoordinate_ = coordinates2[0];
          }
          this.geometryFunction_(this.sketchCoords_, geometry, projection);
        }
        this.createOrUpdateSketchPoint_(coordinate.slice());
        this.updateSketchFeatures_();
        if (done) {
          return this.finishDrawing();
        }
        return this.sketchFeature_;
      }
      /**
       * @param {number} n The number of points to remove.
       */
      removeLastPoints_(n6) {
        if (!this.sketchFeature_) {
          return;
        }
        const geometry = this.sketchFeature_.getGeometry();
        const projection = this.getMap().getView().getProjection();
        const mode2 = this.mode_;
        for (let i7 = 0; i7 < n6; ++i7) {
          let coordinates2;
          if (mode2 === "LineString" || mode2 === "Circle") {
            coordinates2 = /** @type {LineCoordType} */
            this.sketchCoords_;
            coordinates2.splice(-2, 1);
            if (coordinates2.length >= 2) {
              this.finishCoordinate_ = coordinates2[coordinates2.length - 2].slice();
              const finishCoordinate = this.finishCoordinate_.slice();
              coordinates2[coordinates2.length - 1] = finishCoordinate;
              this.createOrUpdateSketchPoint_(finishCoordinate);
            }
            this.geometryFunction_(coordinates2, geometry, projection);
            if (geometry.getType() === "Polygon" && this.sketchLine_) {
              this.createOrUpdateCustomSketchLine_(
                /** @type {Polygon} */
                geometry
              );
            }
          } else if (mode2 === "Polygon") {
            coordinates2 = /** @type {PolyCoordType} */
            this.sketchCoords_[0];
            coordinates2.splice(-2, 1);
            const sketchLineGeom = this.sketchLine_.getGeometry();
            if (coordinates2.length >= 2) {
              const finishCoordinate = coordinates2[coordinates2.length - 2].slice();
              coordinates2[coordinates2.length - 1] = finishCoordinate;
              this.createOrUpdateSketchPoint_(finishCoordinate);
            }
            sketchLineGeom.setCoordinates(coordinates2);
            this.geometryFunction_(this.sketchCoords_, geometry, projection);
          }
          if (coordinates2.length === 1) {
            this.abortDrawing();
            break;
          }
        }
        this.updateSketchFeatures_();
      }
      /**
       * Remove last point of the feature currently being drawn. Does not do anything when
       * drawing POINT or MULTI_POINT geometries.
       * @api
       */
      removeLastPoint() {
        this.removeLastPoints_(1);
      }
      /**
       * Stop drawing and add the sketch feature to the target layer.
       * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
       * dispatched before inserting the feature.
       * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The drawn feature.
       * @api
       */
      finishDrawing() {
        const sketchFeature = this.abortDrawing_();
        if (!sketchFeature) {
          return null;
        }
        let coordinates2 = this.sketchCoords_;
        const geometry = sketchFeature.getGeometry();
        const projection = this.getMap().getView().getProjection();
        if (this.mode_ === "LineString") {
          coordinates2.pop();
          this.geometryFunction_(coordinates2, geometry, projection);
        } else if (this.mode_ === "Polygon") {
          coordinates2[0].pop();
          this.geometryFunction_(coordinates2, geometry, projection);
          coordinates2 = geometry.getCoordinates();
        }
        if (this.type_ === "MultiPoint") {
          sketchFeature.setGeometry(
            new MultiPoint_default([
              /** @type {PointCoordType} */
              coordinates2
            ])
          );
        } else if (this.type_ === "MultiLineString") {
          sketchFeature.setGeometry(
            new MultiLineString_default([
              /** @type {LineCoordType} */
              coordinates2
            ])
          );
        } else if (this.type_ === "MultiPolygon") {
          sketchFeature.setGeometry(
            new MultiPolygon_default([
              /** @type {PolyCoordType} */
              coordinates2
            ])
          );
        }
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
        if (this.features_) {
          this.features_.push(sketchFeature);
        }
        if (this.source_) {
          this.source_.addFeature(sketchFeature);
        }
        return sketchFeature;
      }
      /**
       * Stop drawing without adding the sketch feature to the target layer.
       * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
       * @private
       */
      abortDrawing_() {
        this.finishCoordinate_ = null;
        const sketchFeature = this.sketchFeature_;
        this.sketchFeature_ = null;
        this.sketchPoint_ = null;
        this.sketchLine_ = null;
        this.overlay_.getSource().clear(true);
        this.deactivateTrace_();
        return sketchFeature;
      }
      /**
       * Stop drawing without adding the sketch feature to the target layer.
       * @api
       */
      abortDrawing() {
        const sketchFeature = this.abortDrawing_();
        if (sketchFeature) {
          this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
        }
      }
      /**
       * Append coordinates to the end of the geometry that is currently being drawn.
       * This can be used when drawing LineStrings or Polygons. Coordinates will
       * either be appended to the current LineString or the outer ring of the current
       * Polygon. If no geometry is being drawn, a new one will be created.
       * @param {!LineCoordType} coordinates Linear coordinates to be appended to
       * the coordinate array.
       * @api
       */
      appendCoordinates(coordinates2) {
        const mode2 = this.mode_;
        const newDrawing = !this.sketchFeature_;
        if (newDrawing) {
          this.startDrawing_(coordinates2[0]);
        }
        let sketchCoords;
        if (mode2 === "LineString" || mode2 === "Circle") {
          sketchCoords = /** @type {LineCoordType} */
          this.sketchCoords_;
        } else if (mode2 === "Polygon") {
          sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? (
            /** @type {PolyCoordType} */
            this.sketchCoords_[0]
          ) : [];
        } else {
          return;
        }
        if (newDrawing) {
          sketchCoords.shift();
        }
        sketchCoords.pop();
        for (let i7 = 0; i7 < coordinates2.length; i7++) {
          this.addToDrawing_(coordinates2[i7]);
        }
        const ending = coordinates2[coordinates2.length - 1];
        this.sketchFeature_ = this.addToDrawing_(ending);
        this.modifyDrawing_(ending);
      }
      /**
       * Initiate draw mode by starting from an existing geometry which will
       * receive new additional points. This only works on features with
       * `LineString` geometries, where the interaction will extend lines by adding
       * points to the end of the coordinates array.
       * This will change the original feature, instead of drawing a copy.
       *
       * The function will dispatch a `drawstart` event.
       *
       * @param {!Feature<LineString>} feature Feature to be extended.
       * @api
       */
      extend(feature) {
        const geometry = feature.getGeometry();
        const lineString = geometry;
        this.sketchFeature_ = feature;
        this.sketchCoords_ = lineString.getCoordinates();
        const last = this.sketchCoords_[this.sketchCoords_.length - 1];
        this.finishCoordinate_ = last.slice();
        this.sketchCoords_.push(last.slice());
        this.sketchPoint_ = new Feature_default(new Point_default(last));
        this.updateSketchFeatures_();
        this.dispatchEvent(
          new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)
        );
      }
      /**
       * Redraw the sketch features.
       * @private
       */
      updateSketchFeatures_() {
        const sketchFeatures = [];
        if (this.sketchFeature_) {
          sketchFeatures.push(this.sketchFeature_);
        }
        if (this.sketchLine_) {
          sketchFeatures.push(this.sketchLine_);
        }
        if (this.sketchPoint_) {
          sketchFeatures.push(this.sketchPoint_);
        }
        const overlaySource = this.overlay_.getSource();
        overlaySource.clear(true);
        overlaySource.addFeatures(sketchFeatures);
      }
      /**
       * @private
       */
      updateState_() {
        const map = this.getMap();
        const active = this.getActive();
        if (!map || !active) {
          this.abortDrawing();
        }
        this.overlay_.setMap(active ? map : null);
      }
    };
    Draw_default = Draw;
  }
});

// node_modules/@allmaps/stdlib/dist/fetch.js
async function fetchUrl(input, init35, fetchFn) {
  let response;
  if (typeof fetchFn === "function") {
    response = await fetchFn(input, init35);
  } else {
    response = await fetch(input, init35);
  }
  if (!response.ok) {
    const json2 = await response.json();
    if (json2 && json2.error) {
      throw new Error(json2.error);
    } else if (response.statusText) {
      throw new Error(response.statusText);
    } else if (response.status === 404) {
      throw new Error(`Not found: ${input} (404)`);
    } else if (response.status === 500) {
      throw new Error("Internal server error (500)");
    } else {
      throw new Error(`Failed to fetch: ${input} (${response.status})`);
    }
  }
  return response;
}
async function fetchJson(input, init35, fetchFn) {
  const response = await fetchUrl(input, init35, fetchFn);
  return await response.json();
}
var init_fetch2 = __esm({
  "node_modules/@allmaps/stdlib/dist/fetch.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/api.js
function fetchAnnotationsByIiifUrl(url) {
  return fetchJson(`https://annotations.allmaps.org/?url=${url}`);
}
async function fetchAnnotationsForImage(parsedImage) {
  try {
    const annotations = await fetchAnnotationsByIiifUrl(`${parsedImage.uri}/info.json`);
    return [annotations];
  } catch (err) {
    return [];
  }
}
async function fetchAnnotationsForManifest(parsedManifest) {
  try {
    const annotations = await fetchAnnotationsByIiifUrl(parsedManifest.uri);
    return [annotations];
  } catch (err) {
    const annotations = [];
    for (const canvas of parsedManifest.canvases) {
      const imageAnnotations = await fetchAnnotationsForImage(canvas.image);
      annotations.push(...imageAnnotations);
    }
    return annotations;
  }
}
async function fetchAnnotationsForCollection(parsedCollection) {
  try {
    const annotations = await fetchAnnotationsByIiifUrl(parsedCollection.uri);
    return [annotations];
  } catch (err) {
    const annotations = [];
    if ("items" in parsedCollection) {
      for (const item of parsedCollection.items) {
        if (item.type === "collection") {
          const itemAnnotations = await fetchAnnotationsForCollection(item);
          annotations.push(...itemAnnotations);
        } else if (item.type === "manifest" && "canvases" in item) {
          const itemAnnotations = await fetchAnnotationsForManifest(item);
          annotations.push(...itemAnnotations);
        }
      }
    }
    return annotations;
  }
}
function fetchAnnotationsFromApi(parsedIiif) {
  if (parsedIiif.type === "image") {
    return fetchAnnotationsForImage(parsedIiif);
  } else if (parsedIiif.type === "manifest") {
    return fetchAnnotationsForManifest(parsedIiif);
  } else if (parsedIiif.type === "collection") {
    return fetchAnnotationsForCollection(parsedIiif);
  } else {
    throw new Error("Unsupported IIIF resource");
  }
}
var init_api = __esm({
  "node_modules/@allmaps/stdlib/dist/api.js"() {
    init_fetch2();
  }
});

// node_modules/@allmaps/stdlib/dist/background-color.js
var init_background_color = __esm({
  "node_modules/@allmaps/stdlib/dist/background-color.js"() {
  }
});

// node_modules/monotone-chain-convex-hull/lib-esm/index.js
var init_lib_esm = __esm({
  "node_modules/monotone-chain-convex-hull/lib-esm/index.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/geometry.js
var init_geometry = __esm({
  "node_modules/@allmaps/stdlib/dist/geometry.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/geojson.js
var init_geojson = __esm({
  "node_modules/@allmaps/stdlib/dist/geojson.js"() {
    init_geometry();
  }
});

// node_modules/@allmaps/stdlib/dist/bbox.js
var init_bbox = __esm({
  "node_modules/@allmaps/stdlib/dist/bbox.js"() {
    init_lib_esm();
    init_geojson();
    init_geometry();
  }
});

// node_modules/@allmaps/stdlib/dist/cache.js
var init_cache = __esm({
  "node_modules/@allmaps/stdlib/dist/cache.js"() {
  }
});

// node_modules/hex-rgb/index.js
var hexCharacters, match3or4Hex, match6or8Hex, nonHexChars, validHexSize;
var init_hex_rgb = __esm({
  "node_modules/hex-rgb/index.js"() {
    hexCharacters = "a-f\\d";
    match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;
    match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;
    nonHexChars = new RegExp(`[^#${hexCharacters}]`, "gi");
    validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, "i");
  }
});

// node_modules/rgb-hex/index.js
var init_rgb_hex = __esm({
  "node_modules/rgb-hex/index.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/color.js
var init_color2 = __esm({
  "node_modules/@allmaps/stdlib/dist/color.js"() {
    init_hex_rgb();
    init_rgb_hex();
  }
});

// node_modules/@allmaps/stdlib/dist/main.js
var init_main = __esm({
  "node_modules/@allmaps/stdlib/dist/main.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/masks.js
var init_masks = __esm({
  "node_modules/@allmaps/stdlib/dist/masks.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/matrix.js
var init_matrix = __esm({
  "node_modules/@allmaps/stdlib/dist/matrix.js"() {
    init_main();
  }
});

// node_modules/@allmaps/stdlib/dist/options.js
var init_options = __esm({
  "node_modules/@allmaps/stdlib/dist/options.js"() {
  }
});

// node_modules/svg-parser/dist/svg-parser.esm.js
var init_svg_parser_esm = __esm({
  "node_modules/svg-parser/dist/svg-parser.esm.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/svg.js
var init_svg = __esm({
  "node_modules/@allmaps/stdlib/dist/svg.js"() {
    init_svg_parser_esm();
  }
});

// node_modules/@allmaps/stdlib/dist/self-intersect.js
var init_self_intersect = __esm({
  "node_modules/@allmaps/stdlib/dist/self-intersect.js"() {
    init_geometry();
    init_main();
  }
});

// node_modules/@allmaps/stdlib/dist/index.js
var init_dist5 = __esm({
  "node_modules/@allmaps/stdlib/dist/index.js"() {
    init_api();
    init_background_color();
    init_bbox();
    init_cache();
    init_color2();
    init_fetch2();
    init_geojson();
    init_geometry();
    init_main();
    init_masks();
    init_matrix();
    init_options();
    init_svg();
    init_self_intersect();
  }
});

// node_modules/@allmaps/transform/dist/shared/distortion.js
var init_distortion = __esm({
  "node_modules/@allmaps/transform/dist/shared/distortion.js"() {
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BaseTransformation.js
var init_BaseTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BaseTransformation.js"() {
    init_dist5();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BaseLinearWeightsTransformation.js
var init_BaseLinearWeightsTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BaseLinearWeightsTransformation.js"() {
    init_BaseTransformation();
  }
});

// node_modules/@allmaps/transform/dist/shared/solve-functions.js
var init_solve_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/solve-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Helmert.js
var init_Helmert = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Helmert.js"() {
    init_dist5();
    init_BaseLinearWeightsTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Straight.js
var init_Straight = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Straight.js"() {
    init_Helmert();
    init_BaseTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BaseIndependentLinearWeightsTransformation.js
var init_BaseIndependentLinearWeightsTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BaseIndependentLinearWeightsTransformation.js"() {
    init_BaseLinearWeightsTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BasePolynomialTransformation.js
var init_BasePolynomialTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BasePolynomialTransformation.js"() {
    init_dist5();
    init_BaseIndependentLinearWeightsTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial1.js
var init_Polynomial1 = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Polynomial1.js"() {
    init_BasePolynomialTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial2.js
var init_Polynomial2 = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Polynomial2.js"() {
    init_BasePolynomialTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial3.js
var init_Polynomial3 = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Polynomial3.js"() {
    init_BasePolynomialTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Projective.js
var init_Projective = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Projective.js"() {
    init_dist5();
    init_BaseTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/RBF.js
var init_RBF = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/RBF.js"() {
    init_dist5();
    init_Polynomial1();
    init_BaseIndependentLinearWeightsTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/shared/kernel-functions.js
var init_kernel_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/kernel-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/shared/norm-functions.js
var init_norm_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/norm-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/shared/refinement-functions.js
var init_refinement_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/refinement-functions.js"() {
    init_dist5();
  }
});

// node_modules/@allmaps/transform/dist/shared/transform-functions.js
function generalGcpTransformOptionsToGcpTransformOptions(generalGcpTransformOptions) {
  if (generalGcpTransformOptions === void 0) {
    return {};
  }
  const gcpTransformOptions = generalGcpTransformOptions;
  if (generalGcpTransformOptions.destinationIsGeographic) {
    gcpTransformOptions.geoIsGeographic = generalGcpTransformOptions.destinationIsGeographic;
  }
  if (generalGcpTransformOptions.postForward) {
    gcpTransformOptions.postToGeo = generalGcpTransformOptions.postForward;
  }
  if (generalGcpTransformOptions.preBackward) {
    gcpTransformOptions.preToResource = generalGcpTransformOptions.preBackward;
  }
  return gcpTransformOptions;
}
function generalGcpTransformerOptionsToGcpTransformerOptions(generalGcpTransformerOptions) {
  if (generalGcpTransformerOptions == void 0) {
    return {};
  }
  const gcpTransformerOptions = generalGcpTransformerOptions;
  return gcpTransformerOptions;
}
var defaultGeneralGcpTransformOptions, defaultGeneralGcpTransformerOptions, defaultGcpTransformOptions, defaultGcpTransformerOptions;
var init_transform_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/transform-functions.js"() {
    init_dist5();
    init_refinement_functions();
    defaultGeneralGcpTransformOptions = {
      maxDepth: 0,
      minOffsetRatio: 0,
      minOffsetDistance: Infinity,
      minLineDistance: Infinity,
      sourceIsGeographic: false,
      destinationIsGeographic: false,
      isMultiGeometry: false,
      distortionMeasures: [],
      referenceScale: 1,
      preForward: (point) => point,
      postForward: (point) => point,
      preBackward: (point) => point,
      postBackward: (point) => point
    };
    defaultGeneralGcpTransformerOptions = {
      differentHandedness: false,
      ...defaultGeneralGcpTransformOptions
    };
    defaultGcpTransformOptions = generalGcpTransformOptionsToGcpTransformOptions(defaultGeneralGcpTransformOptions);
    defaultGcpTransformerOptions = generalGcpTransformerOptionsToGcpTransformerOptions(defaultGeneralGcpTransformerOptions);
  }
});

// node_modules/@allmaps/transform/dist/shared/conversion-functions.js
var init_conversion_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/conversion-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/transformers/BaseGcpTransformer.js
var init_BaseGcpTransformer = __esm({
  "node_modules/@allmaps/transform/dist/transformers/BaseGcpTransformer.js"() {
    init_dist5();
    init_distortion();
    init_Straight();
    init_Helmert();
    init_Polynomial1();
    init_Polynomial2();
    init_Polynomial3();
    init_Projective();
    init_RBF();
    init_kernel_functions();
    init_norm_functions();
    init_transform_functions();
    init_refinement_functions();
    init_conversion_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformers/GcpTransformer.js
var init_GcpTransformer = __esm({
  "node_modules/@allmaps/transform/dist/transformers/GcpTransformer.js"() {
    init_dist5();
    init_BaseGcpTransformer();
    init_transform_functions();
    init_conversion_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformers/GeneralGcpTransformer.js
var init_GeneralGcpTransformer = __esm({
  "node_modules/@allmaps/transform/dist/transformers/GeneralGcpTransformer.js"() {
    init_BaseGcpTransformer();
    init_conversion_functions();
  }
});

// node_modules/@allmaps/transform/dist/shared/types.js
var init_types4 = __esm({
  "node_modules/@allmaps/transform/dist/shared/types.js"() {
  }
});

// node_modules/@allmaps/transform/dist/index.js
var init_dist6 = __esm({
  "node_modules/@allmaps/transform/dist/index.js"() {
    init_GcpTransformer();
    init_GeneralGcpTransformer();
    init_BaseIndependentLinearWeightsTransformation();
    init_BaseLinearWeightsTransformation();
    init_BasePolynomialTransformation();
    init_BaseTransformation();
    init_Helmert();
    init_Polynomial1();
    init_Polynomial2();
    init_Polynomial3();
    init_Projective();
    init_RBF();
    init_Straight();
    init_types4();
    init_distortion();
    init_transform_functions();
    init_solve_functions();
  }
});

// node_modules/@allmaps/tailwind/dist/colors.js
var black, white, inherit, current, transparent, originalColorIndex, blueShades, darkblueShades, purpleShades, pinkShades, orangeShades, redShades, greenShades, yellowShades, grayShades, shades, blue, darkblue, purple, pink, orange, red, green, yellow, gray;
var init_colors = __esm({
  "node_modules/@allmaps/tailwind/dist/colors.js"() {
    black = "#222222";
    white = "#ffffff";
    inherit = "inherit";
    current = "currentColor";
    transparent = "transparent";
    originalColorIndex = 4;
    blueShades = [
      "#dff7fa",
      "#c0eff5",
      "#a1e7f0",
      "#82dfeb",
      "#63d8e6",
      // Original color
      "#4facb8",
      "#3b818a",
      "#27565c",
      "#132b2d"
    ];
    darkblueShades = [
      "#d7d9ee",
      "#b0b4de",
      "#898ecd",
      "#6269bd",
      "#3b44ad",
      // Original color
      "#2f368a",
      "#232867",
      "#171b45",
      "#0b0d22"
    ];
    purpleShades = [
      "#f3dcf0",
      "#e7b9e1",
      "#dc97d2",
      "#d074c3",
      "#c552b5",
      // Original color
      "#9d4190",
      "#76316c",
      "#4e2048",
      "#271024"
    ];
    pinkShades = [
      "#ffddf1",
      "#ffbbe3",
      "#ff99d5",
      "#ff77c7",
      "#ff56ba",
      // Original color
      "#cc4494",
      "#99336f",
      "#66224a",
      "#321125"
    ];
    orangeShades = [
      "#ffe3d0",
      "#ffc7a1",
      "#ffab72",
      "#ff8f43",
      "#ff7415",
      // Original color
      "#cc5c10",
      "#99450c",
      "#662e08",
      "#321704"
    ];
    redShades = [
      "#fededf",
      "#febebf",
      "#fe9e9f",
      "#fe7e7f",
      "#fe5e60",
      // Original color
      "#cb4b4c",
      "#983839",
      "#652526",
      "#321213"
    ];
    greenShades = [
      "#e0f2e8",
      "#c1e6d2",
      "#a2d9bb",
      "#83cda5",
      "#64c18f",
      // Original color
      "#509a72",
      "#3c7355",
      "#284d39",
      "#13261c"
    ];
    yellowShades = [
      "#fff3d9",
      "#ffe8b3",
      "#ffdd8d",
      "#ffd267",
      "#ffc742",
      // Original color
      "#cc9f34",
      "#997727",
      "#664f1a",
      "#32270d"
    ];
    grayShades = [
      "#efefef",
      "#e0e0e0",
      "#d0d0d0",
      "#c1c1c1",
      "#b2b2b2",
      "#8e8e8e",
      "#6a6a6a",
      "#474747",
      "#232323"
    ];
    shades = {
      blue: blueShades,
      darkblue: darkblueShades,
      purple: purpleShades,
      pink: pinkShades,
      orange: orangeShades,
      red: redShades,
      green: greenShades,
      yellow: yellowShades,
      gray: grayShades
    };
    blue = blueShades[originalColorIndex];
    darkblue = darkblueShades[originalColorIndex];
    purple = purpleShades[originalColorIndex];
    pink = pinkShades[originalColorIndex];
    orange = orangeShades[originalColorIndex];
    red = redShades[originalColorIndex];
    green = greenShades[originalColorIndex];
    yellow = yellowShades[originalColorIndex];
    gray = grayShades[originalColorIndex];
  }
});

// node_modules/@allmaps/tailwind/dist/theme-colors.js
function flattenShades(color, shades2) {
  return shades2.reduce((flattened, hex, index13) => {
    const shade = (index13 + 1) * 100;
    const key = `${color}-${shade}`;
    flattened[key] = hex;
    return flattened;
  }, {});
}
var themeColors;
var init_theme_colors = __esm({
  "node_modules/@allmaps/tailwind/dist/theme-colors.js"() {
    init_colors();
    themeColors = {
      blue,
      darkblue,
      purple,
      pink,
      orange,
      red,
      green,
      yellow,
      gray,
      black,
      white,
      inherit,
      current,
      transparent,
      // Add shades
      ...flattenShades("blue", shades.blue),
      ...flattenShades("darkblue", shades.darkblue),
      ...flattenShades("purple", shades.purple),
      ...flattenShades("pink", shades.pink),
      ...flattenShades("orange", shades.orange),
      ...flattenShades("red", shades.red),
      ...flattenShades("green", shades.green),
      ...flattenShades("yellow", shades.yellow),
      ...flattenShades("gray", shades.gray)
    };
  }
});

// node_modules/@allmaps/tailwind/dist/theme.js
var theme;
var init_theme = __esm({
  "node_modules/@allmaps/tailwind/dist/theme.js"() {
    init_theme_colors();
    theme = {
      extend: {
        textColor: {
          DEFAULT: themeColors.black
        },
        transitionDuration: {
          0: "0ms"
        }
      },
      colors: themeColors,
      fontFamily: {
        sans: ["Geograph", "sans-serif"],
        // Consider using https://tosche.net/fonts/codelia
        mono: ["DM Mono", "monospace"]
      }
    };
  }
});

// node_modules/@allmaps/tailwind/dist/index.js
var init_dist7 = __esm({
  "node_modules/@allmaps/tailwind/dist/index.js"() {
    init_theme_colors();
    init_theme();
    init_colors();
  }
});

// node_modules/@allmaps/render/dist/shared/events.js
var init_events2 = __esm({
  "node_modules/@allmaps/render/dist/shared/events.js"() {
  }
});

// node_modules/@allmaps/render/dist/shared/tiles.js
var init_tiles = __esm({
  "node_modules/@allmaps/render/dist/shared/tiles.js"() {
    init_dist5();
  }
});

// node_modules/@allmaps/render/dist/tilecache/TileCache.js
var init_TileCache = __esm({
  "node_modules/@allmaps/render/dist/tilecache/TileCache.js"() {
    init_dist5();
    init_events2();
    init_tiles();
  }
});

// node_modules/@allmaps/id/dist/checksum.js
var init_checksum = __esm({
  "node_modules/@allmaps/id/dist/checksum.js"() {
  }
});

// node_modules/@allmaps/id/dist/index.js
var init_dist8 = __esm({
  "node_modules/@allmaps/id/dist/index.js"() {
    init_checksum();
  }
});

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType;
var init_util2 = __esm({
  "node_modules/zod/v3/helpers/util.js"() {
    (function(util2) {
      util2.assertEqual = (_5) => {
      };
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k5) => typeof obj[obj[k5]] !== "number");
        const filtered = {};
        for (const k5 of validKeys) {
          filtered[k5] = obj[k5];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e3) {
          return obj[e3];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_5, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t4 = typeof data;
      switch (t4) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
  }
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson, ZodError;
var init_ZodError = __esm({
  "node_modules/zod/v3/ZodError.js"() {
    init_util2();
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json2 = JSON.stringify(obj, null, 2);
      return json2.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class _ZodError extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error2) => {
          for (const issue of error2.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i7 = 0;
              while (i7 < issue.path.length) {
                const el = issue.path[i7];
                const terminal = i7 === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i7++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error2 = new ZodError(issues);
      return error2;
    };
  }
});

// node_modules/zod/v3/locales/en.js
var errorMap, en_default;
var init_en = __esm({
  "node_modules/zod/v3/locales/en.js"() {
    init_ZodError();
    init_util2();
    errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "bigint")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    en_default = errorMap;
  }
});

// node_modules/zod/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors2 = __esm({
  "node_modules/zod/v3/errors.js"() {
    init_en();
    overrideErrorMap = en_default;
  }
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x4) => !!x4)
  });
  ctx.common.issues.push(issue);
}
var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync;
var init_parseUtil = __esm({
  "node_modules/zod/v3/helpers/parseUtil.js"() {
    init_errors2();
    init_en();
    makeIssue = (params2) => {
      const { data, path, errorMaps, issueData } = params2;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m8) => !!m8).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s5 of results) {
          if (s5.status === "aborted")
            return INVALID;
          if (s5.status === "dirty")
            status.dirty();
          arrayValue.push(s5.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x4) => x4.status === "aborted";
    isDirty = (x4) => x4.status === "dirty";
    isValid = (x4) => x4.status === "valid";
    isAsync = (x4) => typeof Promise !== "undefined" && x4 instanceof Promise;
  }
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = __esm({
  "node_modules/zod/v3/helpers/typeAliases.js"() {
  }
});

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm({
  "node_modules/zod/v3/helpers/errorUtil.js"() {
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (errorUtil = {}));
  }
});

// node_modules/zod/v3/types.js
function processCreateParams(params2) {
  if (!params2)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params2;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version5) {
  if ((version5 === "v4" || !version5) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version5 === "v6" || !version5) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version5) {
  if ((version5 === "v4" || !version5) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version5 === "v6" || !version5) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a5, b8) {
  const aType = getParsedType(a5);
  const bType = getParsedType(b8);
  if (a5 === b8) {
    return { valid: true, data: a5 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b8);
    const sharedKeys = util.objectKeys(a5).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a5, ...b8 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a5[key], b8[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a5.length !== b8.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index13 = 0; index13 < a5.length; index13++) {
      const itemA = a5[index13];
      const itemB = b8[index13];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a5 === +b8) {
    return { valid: true, data: a5 };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params2) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params2)
  });
}
function cleanParams(params2, data) {
  const p6 = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
  const p23 = typeof p6 === "string" ? { message: p6 } : p6;
  return p23;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r5 = check(data);
      if (r5 instanceof Promise) {
        return r5.then((r6) => {
          if (!r6) {
            const params2 = cleanParams(_params, data);
            const _fatal = params2.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params2, fatal: _fatal });
          }
        });
      }
      if (!r5) {
        const params2 = cleanParams(_params, data);
        const _fatal = params2.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params2, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER;
var init_types5 = __esm({
  "node_modules/zod/v3/types.js"() {
    init_ZodError();
    init_errors2();
    init_errorUtil();
    init_parseUtil();
    init_util2();
    ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error2 = new ZodError(ctx.common.issues);
            this._error = error2;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params2) {
        const result = this.safeParse(data, params2);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params2) {
        const ctx = {
          common: {
            issues: [],
            async: params2?.async ?? false,
            contextualErrorMap: params2?.errorMap
          },
          path: params2?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params2) {
        const result = await this.safeParseAsync(data, params2);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params2) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params2?.errorMap,
            async: true
          },
          path: params2?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform3) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform: transform3 }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params2) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params2?.coerce ?? false,
        ...processCreateParams(params2)
      });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params2) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params2?.coerce || false,
        ...processCreateParams(params2)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params2) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params2?.coerce ?? false,
        ...processCreateParams(params2)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params2) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params2?.coerce || false,
        ...processCreateParams(params2)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params2) => {
      return new ZodDate({
        checks: [],
        coerce: params2?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params2)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params2) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params2)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params2) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params2)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params2) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params2)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params2) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params2)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params2) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params2)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params2) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params2)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params2) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params2)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i7) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i7));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i7) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i7));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params2) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params2)
      });
    };
    ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index13) {
        return new _ZodObject({
          ...this._def,
          catchall: index13
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params2) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.strictCreate = (shape, params2) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.lazycreate = (shape, params2) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params2) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params2)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params2) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params2)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params2) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params2)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x4) => !!x4);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params2) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params2)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index13) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index13, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index13, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params2) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params2)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i7) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i7)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params2) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params2)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error2) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x4) => !!x4),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error2
            }
          });
        }
        function makeReturnsIssue(returns, error2) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x4) => !!x4),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error2
            }
          });
        }
        const params2 = { errorMap: ctx.common.contextualErrorMap };
        const fn4 = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me3 = this;
          return OK(async function(...args) {
            const error2 = new ZodError([]);
            const parsedArgs = await me3._def.args.parseAsync(args, params2).catch((e3) => {
              error2.addIssue(makeArgsIssue(args, e3));
              throw error2;
            });
            const result = await Reflect.apply(fn4, this, parsedArgs);
            const parsedReturns = await me3._def.returns._def.type.parseAsync(result, params2).catch((e3) => {
              error2.addIssue(makeReturnsIssue(result, e3));
              throw error2;
            });
            return parsedReturns;
          });
        } else {
          const me3 = this;
          return OK(function(...args) {
            const parsedArgs = me3._def.args.safeParse(args, params2);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn4, this, parsedArgs.data);
            const parsedReturns = me3._def.returns.safeParse(result, params2);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params2) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params2)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params2) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params2)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params2) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params2)
      });
    };
    ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params2) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params2)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params2) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params2)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params2) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params2)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params2) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params2)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params2) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params2)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params2) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params2)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params2) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default,
        ...processCreateParams(params2)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params2) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch,
        ...processCreateParams(params2)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params2) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params2)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a5, b8) {
        return new _ZodPipeline({
          in: a5,
          out: b8,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params2) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params2)
      });
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params2 = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params2);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
  }
});

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
var init_external = __esm({
  "node_modules/zod/v3/external.js"() {
    init_errors2();
    init_parseUtil();
    init_typeAliases();
    init_util2();
    init_types5();
    init_ZodError();
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_external();
    init_external();
  }
});

// node_modules/@allmaps/annotation/dist/schemas/shared.js
function ensureArray(val) {
  if (val) {
    return Array.isArray(val) ? val : [val];
  }
}
function parseInvalidTransformation(val) {
  const valLowerCase = val.toLowerCase();
  if (valLowerCase === "thinplatespline" || valLowerCase === "thin-plate-spline") {
    return {
      type: "thinPlateSpline"
    };
  } else if (valLowerCase === "polynomial1") {
    return {
      type: "polynomial",
      options: { order: 1 }
    };
  } else if (valLowerCase === "polynomial2") {
    return {
      type: "polynomial",
      options: { order: 2 }
    };
  }
}
var SingleValueSchema, LanguageValueSchema, PointSchema, PointGeometrySchema, ResourceMaskSchema, ImageServices, ResourceTypes, ImageServiceSchema, ResourceTypeSchema, basePartOfItemSchema, PartOfItemSchema, PartOfSchema, ValidTransformationSchema, TransformationSchema, ProjectionSchema, ContextSchema;
var init_shared = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/shared.js"() {
    init_zod();
    SingleValueSchema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]);
    LanguageValueSchema = external_exports.record(external_exports.string(), SingleValueSchema.array());
    PointSchema = external_exports.tuple([external_exports.number(), external_exports.number()]);
    PointGeometrySchema = external_exports.object({
      type: external_exports.literal("Point"),
      coordinates: PointSchema
    });
    ResourceMaskSchema = PointSchema.array().min(3);
    ImageServices = [
      "ImageService1",
      "ImageService2",
      "ImageService3"
    ];
    ResourceTypes = [...ImageServices, ...["Canvas"]];
    ImageServiceSchema = external_exports.enum(ImageServices);
    ResourceTypeSchema = external_exports.enum(ResourceTypes);
    basePartOfItemSchema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string(),
      label: LanguageValueSchema.optional()
    });
    PartOfItemSchema = basePartOfItemSchema.extend({
      partOf: external_exports.lazy(() => PartOfItemSchema.array()).optional()
    });
    PartOfSchema = external_exports.union([PartOfItemSchema.array(), PartOfItemSchema]).transform(ensureArray);
    ValidTransformationSchema = external_exports.object({
      type: external_exports.enum(["helmert", "polynomial", "thinPlateSpline", "projective"]),
      options: external_exports.object({}).passthrough().optional()
    });
    TransformationSchema = external_exports.union([
      ValidTransformationSchema,
      // Catchall for unknown transformation types
      external_exports.unknown()
    ]).transform((val) => {
      const { success, data } = ValidTransformationSchema.safeParse(val);
      if (success) {
        return data;
      } else if (val === "string") {
        return parseInvalidTransformation(val);
      } else if (val && typeof val === "object" && "type" in val && typeof val.type === "string") {
        return parseInvalidTransformation(val.type);
      }
    });
    ProjectionSchema = external_exports.object({
      name: external_exports.string().optional(),
      definition: external_exports.union([external_exports.string(), external_exports.unknown()])
    });
    ContextSchema = external_exports.union([
      external_exports.string().url().array(),
      external_exports.string().url()
    ]);
  }
});

// node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.0.js
var svg, SvgSelectorSchema, TargetSchema, FeaturePropertiesSchema, BodySchema, AnnotationSchema, AnnotationPageSchema;
var init_annotation_0 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.0.js"() {
    init_zod();
    init_shared();
    svg = /^<svg\s+width="\d+"\s+height="\d+"\s*>\s*<polygon\s+points="\s*(-?\d+(\.\d+)?,-?\d+(\.\d+)?\s+){2,}-?\d+(\.\d+)?,-?\d+(\.\d+)?\s*"\s*\/>\s*<\/svg>$/;
    SvgSelectorSchema = external_exports.object({
      type: external_exports.literal("SvgSelector"),
      value: external_exports.string().regex(svg)
    });
    TargetSchema = external_exports.object({
      source: external_exports.string().url(),
      service: external_exports.array(external_exports.object({
        "@id": external_exports.string().url(),
        type: ResourceTypeSchema
      })).length(1),
      selector: SvgSelectorSchema
    });
    FeaturePropertiesSchema = external_exports.object({
      pixelCoords: PointSchema
    });
    BodySchema = external_exports.object({
      type: external_exports.literal("FeatureCollection"),
      transformation: TransformationSchema.optional(),
      features: external_exports.array(external_exports.object({
        type: external_exports.literal("Feature"),
        properties: FeaturePropertiesSchema,
        geometry: PointGeometrySchema
      }))
    });
    AnnotationSchema = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("Annotation"),
      "@context": ContextSchema.optional(),
      motivation: external_exports.string().default("georeferencing").optional(),
      target: TargetSchema,
      body: BodySchema
    });
    AnnotationPageSchema = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("AnnotationPage"),
      "@context": ContextSchema.optional(),
      items: external_exports.array(AnnotationSchema)
    });
  }
});

// node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.1.js
var polygonRegex, svgWidthHeightRegex, svgHeightWidthRegex, svgRegex, SvgRegexSchema, SvgWidthHeightRegexSchema, SvgHeightWidthRegexSchema, SvgSelectorSchema2, Source1Schema, Source2Schema, Canvas3Schema, SourceSchema, TargetSchema2, FeaturePropertiesSchema2, BodySchema2, AnnotationSchema2, AnnotationPageSchema2;
var init_annotation_1 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.1.js"() {
    init_zod();
    init_shared();
    polygonRegex = /<polygon\s+points="\s*(-?\d+(\.\d+)?,-?\d+(\.\d+)?\s+){2,}-?\d+(\.\d+)?,-?\d+(\.\d+)?\s*"\s*\/>/;
    svgWidthHeightRegex = new RegExp(`^<svg\\s+width="\\d+"\\s+height="\\d+"\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
    svgHeightWidthRegex = new RegExp(`^<svg\\s+height="\\d+"\\s+width="\\d+"\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
    svgRegex = new RegExp(`^<svg\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
    SvgRegexSchema = external_exports.string().regex(svgRegex);
    SvgWidthHeightRegexSchema = external_exports.string().regex(svgWidthHeightRegex);
    SvgHeightWidthRegexSchema = external_exports.string().regex(svgHeightWidthRegex);
    SvgSelectorSchema2 = external_exports.object({
      type: external_exports.literal("SvgSelector"),
      value: external_exports.union([
        SvgRegexSchema,
        SvgWidthHeightRegexSchema,
        SvgHeightWidthRegexSchema
      ])
    });
    Source1Schema = external_exports.object({
      "@id": external_exports.string().url(),
      type: ImageServiceSchema,
      height: external_exports.number().positive(),
      width: external_exports.number().positive(),
      partOf: PartOfSchema.optional()
    });
    Source2Schema = external_exports.object({
      id: external_exports.string().url(),
      type: ImageServiceSchema,
      height: external_exports.number().positive().optional(),
      width: external_exports.number().positive().optional(),
      partOf: PartOfSchema.optional()
    });
    Canvas3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Canvas"),
      height: external_exports.number().positive().optional(),
      width: external_exports.number().positive().optional(),
      partOf: PartOfSchema.optional()
    });
    SourceSchema = external_exports.union([
      Source1Schema,
      Source2Schema,
      Canvas3Schema
    ]);
    TargetSchema2 = external_exports.object({
      type: external_exports.literal("SpecificResource"),
      source: SourceSchema,
      // selector: z.union([SvgSelectorSchema, ImageApiSelectorSchema])
      selector: SvgSelectorSchema2
    });
    FeaturePropertiesSchema2 = external_exports.object({
      resourceCoords: PointSchema
    });
    BodySchema2 = external_exports.object({
      type: external_exports.literal("FeatureCollection"),
      transformation: TransformationSchema.optional(),
      resourceCrs: ProjectionSchema.optional(),
      features: external_exports.array(external_exports.object({
        type: external_exports.literal("Feature"),
        properties: FeaturePropertiesSchema2,
        geometry: PointGeometrySchema
      }))
    });
    AnnotationSchema2 = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("Annotation"),
      "@context": ContextSchema.optional(),
      motivation: external_exports.string().default("georeferencing").optional(),
      created: external_exports.string().datetime().optional(),
      modified: external_exports.string().datetime().optional(),
      target: TargetSchema2,
      body: BodySchema2
    });
    AnnotationPageSchema2 = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("AnnotationPage"),
      "@context": ContextSchema.optional(),
      items: external_exports.array(AnnotationSchema2)
    });
  }
});

// node_modules/@allmaps/annotation/dist/schemas/annotation.js
var AnnotationAllVersionsSchema, AnnotationPageAllVersionsSchema, FeaturePropertiesAllVersionsSchema;
var init_annotation = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/annotation.js"() {
    init_zod();
    init_annotation_0();
    init_annotation_1();
    init_shared();
    AnnotationAllVersionsSchema = external_exports.union([
      AnnotationSchema,
      AnnotationSchema2
    ]);
    AnnotationPageAllVersionsSchema = external_exports.union([
      AnnotationPageSchema,
      AnnotationPageSchema2
    ]);
    FeaturePropertiesAllVersionsSchema = external_exports.union([
      FeaturePropertiesSchema,
      FeaturePropertiesSchema2
    ]);
  }
});

// node_modules/@allmaps/annotation/dist/before-parse.js
var init_before_parse = __esm({
  "node_modules/@allmaps/annotation/dist/before-parse.js"() {
  }
});

// node_modules/@allmaps/annotation/dist/guards.js
var init_guards = __esm({
  "node_modules/@allmaps/annotation/dist/guards.js"() {
  }
});

// node_modules/@allmaps/annotation/dist/parser.js
var init_parser = __esm({
  "node_modules/@allmaps/annotation/dist/parser.js"() {
    init_annotation();
    init_before_parse();
    init_guards();
  }
});

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.1.js
var GCPSchema, ImageSchema, GeoreferencedMapSchema, GeoreferencedMapsSchema;
var init_georeferenced_map_1 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.1.js"() {
    init_zod();
    init_shared();
    GCPSchema = external_exports.object({
      image: PointSchema,
      world: PointSchema
    });
    ImageSchema = external_exports.object({
      uri: external_exports.string().url(),
      width: external_exports.number(),
      height: external_exports.number(),
      type: ImageServiceSchema
    });
    GeoreferencedMapSchema = external_exports.object({
      id: external_exports.string().optional(),
      version: external_exports.number().min(1).max(1).default(1),
      image: ImageSchema,
      gcps: GCPSchema.array(),
      pixelMask: ResourceMaskSchema,
      transformation: TransformationSchema.optional()
    });
    GeoreferencedMapsSchema = external_exports.array(GeoreferencedMapSchema);
  }
});

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.2.js
var GCPSchema2, ResourceSchema, GeoreferencedMapSchema2, GeoreferencedMapsSchema2;
var init_georeferenced_map_2 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.2.js"() {
    init_zod();
    init_shared();
    GCPSchema2 = external_exports.object({
      resource: PointSchema,
      geo: PointSchema
    });
    ResourceSchema = external_exports.object({
      id: external_exports.string().url(),
      height: external_exports.number().positive().optional(),
      width: external_exports.number().positive().optional(),
      type: ResourceTypeSchema,
      partOf: PartOfSchema.optional()
    });
    GeoreferencedMapSchema2 = external_exports.object({
      "@context": external_exports.literal("https://schemas.allmaps.org/map/2/context.json").optional(),
      type: external_exports.literal("GeoreferencedMap"),
      id: external_exports.string().optional(),
      created: external_exports.string().datetime().optional(),
      modified: external_exports.string().datetime().optional(),
      resource: ResourceSchema,
      gcps: GCPSchema2.array(),
      resourceMask: ResourceMaskSchema,
      transformation: TransformationSchema.optional(),
      resourceCrs: ProjectionSchema.optional()
    });
    GeoreferencedMapsSchema2 = external_exports.array(GeoreferencedMapSchema2);
  }
});

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map.js
var GeoreferencedMapAllVersionsSchema, GeoreferencedMapsAllVersionsSchema, GCPAllVersionsSchema;
var init_georeferenced_map = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/georeferenced-map.js"() {
    init_zod();
    init_georeferenced_map_1();
    init_georeferenced_map_2();
    init_shared();
    GeoreferencedMapAllVersionsSchema = external_exports.union([
      GeoreferencedMapSchema,
      GeoreferencedMapSchema2
    ]);
    GeoreferencedMapsAllVersionsSchema = external_exports.union([
      GeoreferencedMapsSchema,
      GeoreferencedMapsSchema2
    ]);
    GCPAllVersionsSchema = external_exports.union([
      GCPSchema,
      GCPSchema2
    ]);
  }
});

// node_modules/@allmaps/annotation/dist/generator.js
var init_generator = __esm({
  "node_modules/@allmaps/annotation/dist/generator.js"() {
    init_georeferenced_map();
    init_before_parse();
    init_guards();
  }
});

// node_modules/@allmaps/annotation/dist/convert.js
var init_convert = __esm({
  "node_modules/@allmaps/annotation/dist/convert.js"() {
    init_parser();
    init_generator();
    init_guards();
  }
});

// node_modules/@allmaps/annotation/dist/validator.js
var init_validator = __esm({
  "node_modules/@allmaps/annotation/dist/validator.js"() {
    init_annotation();
    init_georeferenced_map();
    init_convert();
    init_before_parse();
  }
});

// node_modules/@allmaps/annotation/dist/index.js
var init_dist9 = __esm({
  "node_modules/@allmaps/annotation/dist/index.js"() {
    init_parser();
    init_generator();
    init_validator();
    init_georeferenced_map();
    init_annotation();
    init_shared();
  }
});

// node_modules/proj4/lib/global.js
function global_default(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var i7 = 1; i7 <= 60; ++i7) {
    defs2("EPSG:" + (32600 + i7), "+proj=utm +zone=" + i7 + " +datum=WGS84 +units=m");
    defs2("EPSG:" + (32700 + i7), "+proj=utm +zone=" + i7 + " +south +datum=WGS84 +units=m");
  }
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}
var init_global = __esm({
  "node_modules/proj4/lib/global.js"() {
  }
});

// node_modules/proj4/lib/constants/values.js
var PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT, PJD_WGS84, PJD_NODATUM, SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR, SRS_WGS84_ESQUARED, SEC_TO_RAD, HALF_PI, SIXTH, RA4, RA6, EPSLN, D2R, R2D, FORTPI, TWO_PI, SPI;
var init_values = __esm({
  "node_modules/proj4/lib/constants/values.js"() {
    PJD_3PARAM = 1;
    PJD_7PARAM = 2;
    PJD_GRIDSHIFT = 3;
    PJD_WGS84 = 4;
    PJD_NODATUM = 5;
    SRS_WGS84_SEMIMAJOR = 6378137;
    SRS_WGS84_SEMIMINOR = 6356752314e-3;
    SRS_WGS84_ESQUARED = 0.0066943799901413165;
    SEC_TO_RAD = 484813681109536e-20;
    HALF_PI = Math.PI / 2;
    SIXTH = 0.16666666666666666;
    RA4 = 0.04722222222222222;
    RA6 = 0.022156084656084655;
    EPSLN = 1e-10;
    D2R = 0.017453292519943295;
    R2D = 57.29577951308232;
    FORTPI = Math.PI / 4;
    TWO_PI = Math.PI * 2;
    SPI = 3.14159265359;
  }
});

// node_modules/proj4/lib/constants/PrimeMeridian.js
var primeMeridian, PrimeMeridian_default;
var init_PrimeMeridian = __esm({
  "node_modules/proj4/lib/constants/PrimeMeridian.js"() {
    primeMeridian = {};
    primeMeridian.greenwich = 0;
    primeMeridian.lisbon = -9.131906111111;
    primeMeridian.paris = 2.337229166667;
    primeMeridian.bogota = -74.080916666667;
    primeMeridian.madrid = -3.687938888889;
    primeMeridian.rome = 12.452333333333;
    primeMeridian.bern = 7.439583333333;
    primeMeridian.jakarta = 106.807719444444;
    primeMeridian.ferro = -17.666666666667;
    primeMeridian.brussels = 4.367975;
    primeMeridian.stockholm = 18.058277777778;
    primeMeridian.athens = 23.7163375;
    primeMeridian.oslo = 10.722916666667;
    PrimeMeridian_default = primeMeridian;
  }
});

// node_modules/proj4/lib/constants/units.js
var units_default;
var init_units = __esm({
  "node_modules/proj4/lib/constants/units.js"() {
    units_default = {
      mm: { to_meter: 1e-3 },
      cm: { to_meter: 0.01 },
      ft: { to_meter: 0.3048 },
      "us-ft": { to_meter: 1200 / 3937 },
      fath: { to_meter: 1.8288 },
      kmi: { to_meter: 1852 },
      "us-ch": { to_meter: 20.1168402336805 },
      "us-mi": { to_meter: 1609.34721869444 },
      km: { to_meter: 1e3 },
      "ind-ft": { to_meter: 0.30479841 },
      "ind-yd": { to_meter: 0.91439523 },
      mi: { to_meter: 1609.344 },
      yd: { to_meter: 0.9144 },
      ch: { to_meter: 20.1168 },
      link: { to_meter: 0.201168 },
      dm: { to_meter: 0.1 },
      in: { to_meter: 0.0254 },
      "ind-ch": { to_meter: 20.11669506 },
      "us-in": { to_meter: 0.025400050800101 },
      "us-yd": { to_meter: 0.914401828803658 }
    };
  }
});

// node_modules/proj4/lib/match.js
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i7 = -1;
  var testkey, processedKey;
  while (++i7 < keys.length) {
    testkey = keys[i7];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}
var ignoredChar;
var init_match = __esm({
  "node_modules/proj4/lib/match.js"() {
    ignoredChar = /[\s_\-\/\(\)]/g;
  }
});

// node_modules/proj4/lib/projString.js
function projString_default(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v5) {
    return v5.trim();
  }).filter(function(a5) {
    return a5;
  }).reduce(function(p6, a5) {
    var split = a5.split("=");
    split.push(true);
    p6[split[0].toLowerCase()] = split[1];
    return p6;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v5) {
      self2.rf = parseFloat(v5);
    },
    lat_0: function(v5) {
      self2.lat0 = v5 * D2R;
    },
    lat_1: function(v5) {
      self2.lat1 = v5 * D2R;
    },
    lat_2: function(v5) {
      self2.lat2 = v5 * D2R;
    },
    lat_ts: function(v5) {
      self2.lat_ts = v5 * D2R;
    },
    lon_0: function(v5) {
      self2.long0 = v5 * D2R;
    },
    lon_1: function(v5) {
      self2.long1 = v5 * D2R;
    },
    lon_2: function(v5) {
      self2.long2 = v5 * D2R;
    },
    alpha: function(v5) {
      self2.alpha = parseFloat(v5) * D2R;
    },
    gamma: function(v5) {
      self2.rectified_grid_angle = parseFloat(v5) * D2R;
    },
    lonc: function(v5) {
      self2.longc = v5 * D2R;
    },
    x_0: function(v5) {
      self2.x0 = parseFloat(v5);
    },
    y_0: function(v5) {
      self2.y0 = parseFloat(v5);
    },
    k_0: function(v5) {
      self2.k0 = parseFloat(v5);
    },
    k: function(v5) {
      self2.k0 = parseFloat(v5);
    },
    a: function(v5) {
      self2.a = parseFloat(v5);
    },
    b: function(v5) {
      self2.b = parseFloat(v5);
    },
    r: function(v5) {
      self2.a = self2.b = parseFloat(v5);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v5) {
      self2.zone = parseInt(v5, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v5) {
      self2.datum_params = v5.split(",").map(function(a5) {
        return parseFloat(a5);
      });
    },
    to_meter: function(v5) {
      self2.to_meter = parseFloat(v5);
    },
    units: function(v5) {
      self2.units = v5;
      var unit = match(units_default, v5);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v5) {
      self2.from_greenwich = v5 * D2R;
    },
    pm: function(v5) {
      var pm = match(PrimeMeridian_default, v5);
      self2.from_greenwich = (pm ? pm : parseFloat(v5)) * D2R;
    },
    nadgrids: function(v5) {
      if (v5 === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v5;
      }
    },
    axis: function(v5) {
      var legalAxis = "ewnsud";
      if (v5.length === 3 && legalAxis.indexOf(v5.substr(0, 1)) !== -1 && legalAxis.indexOf(v5.substr(1, 1)) !== -1 && legalAxis.indexOf(v5.substr(2, 1)) !== -1) {
        self2.axis = v5;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}
var init_projString = __esm({
  "node_modules/proj4/lib/projString.js"() {
    init_values();
    init_PrimeMeridian();
    init_units();
    init_match();
  }
});

// node_modules/wkt-parser/PROJJSONBuilderBase.js
var PROJJSONBuilderBase, PROJJSONBuilderBase_default;
var init_PROJJSONBuilderBase = __esm({
  "node_modules/wkt-parser/PROJJSONBuilderBase.js"() {
    PROJJSONBuilderBase = class {
      static getId(node) {
        const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
        if (idNode && idNode.length >= 3) {
          return {
            authority: idNode[1],
            code: parseInt(idNode[2], 10)
          };
        }
        return null;
      }
      static convertUnit(node, type = "unit") {
        if (!node || node.length < 3) {
          return { type, name: "unknown", conversion_factor: null };
        }
        const name = node[1];
        const conversionFactor = parseFloat(node[2]) || null;
        const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
        const id = idNode ? {
          authority: idNode[1],
          code: parseInt(idNode[2], 10)
        } : null;
        return {
          type,
          name,
          conversion_factor: conversionFactor,
          id
        };
      }
      static convertAxis(node) {
        const name = node[1] || "Unknown";
        let direction;
        const abbreviationMatch = name.match(/^\((.)\)$/);
        if (abbreviationMatch) {
          const abbreviation = abbreviationMatch[1].toUpperCase();
          if (abbreviation === "E") direction = "east";
          else if (abbreviation === "N") direction = "north";
          else if (abbreviation === "U") direction = "up";
          else throw new Error(`Unknown axis abbreviation: ${abbreviation}`);
        } else {
          direction = node[2] ? node[2].toLowerCase() : "unknown";
        }
        const orderNode = node.find((child) => Array.isArray(child) && child[0] === "ORDER");
        const order = orderNode ? parseInt(orderNode[1], 10) : null;
        const unitNode = node.find(
          (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
        );
        const unit = this.convertUnit(unitNode);
        return {
          name,
          direction,
          // Use the valid PROJJSON direction value
          unit,
          order
        };
      }
      static extractAxes(node) {
        return node.filter((child) => Array.isArray(child) && child[0] === "AXIS").map((axis) => this.convertAxis(axis)).sort((a5, b8) => (a5.order || 0) - (b8.order || 0));
      }
      static convert(node, result = {}) {
        switch (node[0]) {
          case "PROJCRS":
            result.type = "ProjectedCRS";
            result.name = node[1];
            result.base_crs = node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS")) : null;
            result.conversion = node.find((child) => Array.isArray(child) && child[0] === "CONVERSION") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "CONVERSION")) : null;
            const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
            if (csNode) {
              result.coordinate_system = {
                type: csNode[1],
                axis: this.extractAxes(node)
              };
            }
            const lengthUnitNode = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT");
            if (lengthUnitNode) {
              const unit2 = this.convertUnit(lengthUnitNode);
              result.coordinate_system.unit = unit2;
            }
            result.id = this.getId(node);
            break;
          case "BASEGEOGCRS":
          case "GEOGCRS":
            result.type = "GeographicCRS";
            result.name = node[1];
            const datumOrEnsembleNode = node.find(
              (child) => Array.isArray(child) && (child[0] === "DATUM" || child[0] === "ENSEMBLE")
            );
            if (datumOrEnsembleNode) {
              const datumOrEnsemble = this.convert(datumOrEnsembleNode);
              if (datumOrEnsembleNode[0] === "ENSEMBLE") {
                result.datum_ensemble = datumOrEnsemble;
              } else {
                result.datum = datumOrEnsemble;
              }
              const primem = node.find((child) => Array.isArray(child) && child[0] === "PRIMEM");
              if (primem && primem[1] !== "Greenwich") {
                datumOrEnsemble.prime_meridian = {
                  name: primem[1],
                  longitude: parseFloat(primem[2])
                };
              }
            }
            result.coordinate_system = {
              type: "ellipsoidal",
              axis: this.extractAxes(node)
            };
            result.id = this.getId(node);
            break;
          case "DATUM":
            result.type = "GeodeticReferenceFrame";
            result.name = node[1];
            result.ellipsoid = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID")) : null;
            break;
          case "ENSEMBLE":
            result.type = "DatumEnsemble";
            result.name = node[1];
            result.members = node.filter((child) => Array.isArray(child) && child[0] === "MEMBER").map((member) => ({
              type: "DatumEnsembleMember",
              name: member[1],
              id: this.getId(member)
              // Extract ID as { authority, code }
            }));
            const accuracyNode = node.find((child) => Array.isArray(child) && child[0] === "ENSEMBLEACCURACY");
            if (accuracyNode) {
              result.accuracy = parseFloat(accuracyNode[1]);
            }
            const ellipsoidNode = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID");
            if (ellipsoidNode) {
              result.ellipsoid = this.convert(ellipsoidNode);
            }
            result.id = this.getId(node);
            break;
          case "ELLIPSOID":
            result.type = "Ellipsoid";
            result.name = node[1];
            result.semi_major_axis = parseFloat(node[2]);
            result.inverse_flattening = parseFloat(node[3]);
            const units = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT"), result) : null;
            break;
          case "CONVERSION":
            result.type = "Conversion";
            result.name = node[1];
            result.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
            result.parameters = node.filter((child) => Array.isArray(child) && child[0] === "PARAMETER").map((param) => this.convert(param));
            break;
          case "METHOD":
            result.type = "Method";
            result.name = node[1];
            result.id = this.getId(node);
            break;
          case "PARAMETER":
            result.type = "Parameter";
            result.name = node[1];
            result.value = parseFloat(node[2]);
            result.unit = this.convertUnit(
              node.find(
                (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
              )
            );
            result.id = this.getId(node);
            break;
          case "BOUNDCRS":
            result.type = "BoundCRS";
            const sourceCrsNode = node.find((child) => Array.isArray(child) && child[0] === "SOURCECRS");
            if (sourceCrsNode) {
              const sourceCrsContent = sourceCrsNode.find((child) => Array.isArray(child));
              result.source_crs = sourceCrsContent ? this.convert(sourceCrsContent) : null;
            }
            const targetCrsNode = node.find((child) => Array.isArray(child) && child[0] === "TARGETCRS");
            if (targetCrsNode) {
              const targetCrsContent = targetCrsNode.find((child) => Array.isArray(child));
              result.target_crs = targetCrsContent ? this.convert(targetCrsContent) : null;
            }
            const transformationNode = node.find((child) => Array.isArray(child) && child[0] === "ABRIDGEDTRANSFORMATION");
            if (transformationNode) {
              result.transformation = this.convert(transformationNode);
            } else {
              result.transformation = null;
            }
            break;
          case "ABRIDGEDTRANSFORMATION":
            result.type = "Transformation";
            result.name = node[1];
            result.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
            result.parameters = node.filter((child) => Array.isArray(child) && (child[0] === "PARAMETER" || child[0] === "PARAMETERFILE")).map((param) => {
              if (param[0] === "PARAMETER") {
                return this.convert(param);
              } else if (param[0] === "PARAMETERFILE") {
                return {
                  name: param[1],
                  value: param[2],
                  id: {
                    "authority": "EPSG",
                    "code": 8656
                  }
                };
              }
            });
            if (result.parameters.length === 7) {
              const scaleDifference = result.parameters[6];
              if (scaleDifference.name === "Scale difference") {
                scaleDifference.value = Math.round((scaleDifference.value - 1) * 1e12) / 1e6;
              }
            }
            result.id = this.getId(node);
            break;
          case "AXIS":
            if (!result.coordinate_system) {
              result.coordinate_system = { type: "unspecified", axis: [] };
            }
            result.coordinate_system.axis.push(this.convertAxis(node));
            break;
          case "LENGTHUNIT":
            const unit = this.convertUnit(node, "LinearUnit");
            if (result.coordinate_system && result.coordinate_system.axis) {
              result.coordinate_system.axis.forEach((axis) => {
                if (!axis.unit) {
                  axis.unit = unit;
                }
              });
            }
            if (unit.conversion_factor && unit.conversion_factor !== 1) {
              if (result.semi_major_axis) {
                result.semi_major_axis = {
                  value: result.semi_major_axis,
                  unit
                };
              }
            }
            break;
          default:
            result.keyword = node[0];
            break;
        }
        return result;
      }
    };
    PROJJSONBuilderBase_default = PROJJSONBuilderBase;
  }
});

// node_modules/wkt-parser/PROJJSONBuilder2015.js
var PROJJSONBuilder2015, PROJJSONBuilder2015_default;
var init_PROJJSONBuilder2015 = __esm({
  "node_modules/wkt-parser/PROJJSONBuilder2015.js"() {
    init_PROJJSONBuilderBase();
    PROJJSONBuilder2015 = class extends PROJJSONBuilderBase_default {
      static convert(node, result = {}) {
        super.convert(node, result);
        if (result.coordinate_system && result.coordinate_system.subtype === "Cartesian") {
          delete result.coordinate_system;
        }
        if (result.usage) {
          delete result.usage;
        }
        return result;
      }
    };
    PROJJSONBuilder2015_default = PROJJSONBuilder2015;
  }
});

// node_modules/wkt-parser/PROJJSONBuilder2019.js
var PROJJSONBuilder2019, PROJJSONBuilder2019_default;
var init_PROJJSONBuilder2019 = __esm({
  "node_modules/wkt-parser/PROJJSONBuilder2019.js"() {
    init_PROJJSONBuilderBase();
    PROJJSONBuilder2019 = class extends PROJJSONBuilderBase_default {
      static convert(node, result = {}) {
        super.convert(node, result);
        const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
        if (csNode) {
          result.coordinate_system = {
            subtype: csNode[1],
            axis: this.extractAxes(node)
          };
        }
        const usageNode = node.find((child) => Array.isArray(child) && child[0] === "USAGE");
        if (usageNode) {
          const scope = usageNode.find((child) => Array.isArray(child) && child[0] === "SCOPE");
          const area = usageNode.find((child) => Array.isArray(child) && child[0] === "AREA");
          const bbox = usageNode.find((child) => Array.isArray(child) && child[0] === "BBOX");
          result.usage = {};
          if (scope) {
            result.usage.scope = scope[1];
          }
          if (area) {
            result.usage.area = area[1];
          }
          if (bbox) {
            result.usage.bbox = bbox.slice(1);
          }
        }
        return result;
      }
    };
    PROJJSONBuilder2019_default = PROJJSONBuilder2019;
  }
});

// node_modules/wkt-parser/buildPROJJSON.js
function detectWKT2Version(root) {
  if (root.find((child) => Array.isArray(child) && child[0] === "USAGE")) {
    return "2019";
  }
  if (root.find((child) => Array.isArray(child) && child[0] === "CS")) {
    return "2015";
  }
  if (root[0] === "BOUNDCRS" || root[0] === "PROJCRS" || root[0] === "GEOGCRS") {
    return "2015";
  }
  return "2015";
}
function buildPROJJSON(root) {
  const version5 = detectWKT2Version(root);
  const builder = version5 === "2019" ? PROJJSONBuilder2019_default : PROJJSONBuilder2015_default;
  return builder.convert(root);
}
var init_buildPROJJSON = __esm({
  "node_modules/wkt-parser/buildPROJJSON.js"() {
    init_PROJJSONBuilder2015();
    init_PROJJSONBuilder2019();
  }
});

// node_modules/wkt-parser/detectWKTVersion.js
function detectWKTVersion(wkt) {
  const normalizedWKT = wkt.toUpperCase();
  if (normalizedWKT.includes("PROJCRS") || normalizedWKT.includes("GEOGCRS") || normalizedWKT.includes("BOUNDCRS") || normalizedWKT.includes("VERTCRS") || normalizedWKT.includes("LENGTHUNIT") || normalizedWKT.includes("ANGLEUNIT") || normalizedWKT.includes("SCALEUNIT")) {
    return "WKT2";
  }
  if (normalizedWKT.includes("PROJCS") || normalizedWKT.includes("GEOGCS") || normalizedWKT.includes("LOCAL_CS") || normalizedWKT.includes("VERT_CS") || normalizedWKT.includes("UNIT")) {
    return "WKT1";
  }
  return "WKT1";
}
var init_detectWKTVersion = __esm({
  "node_modules/wkt-parser/detectWKTVersion.js"() {
  }
});

// node_modules/wkt-parser/parser.js
function Parser(text2) {
  if (typeof text2 !== "string") {
    throw new Error("not a string");
  }
  this.text = text2.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
function parseString2(txt) {
  var parser = new Parser(txt);
  return parser.output();
}
var parser_default, NEUTRAL, KEYWORD, NUMBER, QUOTED, AFTERQUOTE, ENDED, whitespace, latin, keyword, endThings, digets;
var init_parser2 = __esm({
  "node_modules/wkt-parser/parser.js"() {
    parser_default = parseString2;
    NEUTRAL = 1;
    KEYWORD = 2;
    NUMBER = 3;
    QUOTED = 4;
    AFTERQUOTE = 5;
    ENDED = -1;
    whitespace = /\s/;
    latin = /[A-Za-z]/;
    keyword = /[A-Za-z84_]/;
    endThings = /[,\]]/;
    digets = /[\d\.E\-\+]/;
    Parser.prototype.readCharicter = function() {
      var char = this.text[this.place++];
      if (this.state !== QUOTED) {
        while (whitespace.test(char)) {
          if (this.place >= this.text.length) {
            return;
          }
          char = this.text[this.place++];
        }
      }
      switch (this.state) {
        case NEUTRAL:
          return this.neutral(char);
        case KEYWORD:
          return this.keyword(char);
        case QUOTED:
          return this.quoted(char);
        case AFTERQUOTE:
          return this.afterquote(char);
        case NUMBER:
          return this.number(char);
        case ENDED:
          return;
      }
    };
    Parser.prototype.afterquote = function(char) {
      if (char === '"') {
        this.word += '"';
        this.state = QUOTED;
        return;
      }
      if (endThings.test(char)) {
        this.word = this.word.trim();
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
    };
    Parser.prototype.afterItem = function(char) {
      if (char === ",") {
        if (this.word !== null) {
          this.currentObject.push(this.word);
        }
        this.word = null;
        this.state = NEUTRAL;
        return;
      }
      if (char === "]") {
        this.level--;
        if (this.word !== null) {
          this.currentObject.push(this.word);
          this.word = null;
        }
        this.state = NEUTRAL;
        this.currentObject = this.stack.pop();
        if (!this.currentObject) {
          this.state = ENDED;
        }
        return;
      }
    };
    Parser.prototype.number = function(char) {
      if (digets.test(char)) {
        this.word += char;
        return;
      }
      if (endThings.test(char)) {
        this.word = parseFloat(this.word);
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
    };
    Parser.prototype.quoted = function(char) {
      if (char === '"') {
        this.state = AFTERQUOTE;
        return;
      }
      this.word += char;
      return;
    };
    Parser.prototype.keyword = function(char) {
      if (keyword.test(char)) {
        this.word += char;
        return;
      }
      if (char === "[") {
        var newObjects = [];
        newObjects.push(this.word);
        this.level++;
        if (this.root === null) {
          this.root = newObjects;
        } else {
          this.currentObject.push(newObjects);
        }
        this.stack.push(this.currentObject);
        this.currentObject = newObjects;
        this.state = NEUTRAL;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
    };
    Parser.prototype.neutral = function(char) {
      if (latin.test(char)) {
        this.word = char;
        this.state = KEYWORD;
        return;
      }
      if (char === '"') {
        this.word = "";
        this.state = QUOTED;
        return;
      }
      if (digets.test(char)) {
        this.word = char;
        this.state = NUMBER;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
    };
    Parser.prototype.output = function() {
      while (this.place < this.text.length) {
        this.readCharicter();
      }
      if (this.state === ENDED) {
        return this.root;
      }
      throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
    };
  }
});

// node_modules/wkt-parser/process.js
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v5, obj) {
  if (!Array.isArray(v5)) {
    obj[v5] = true;
    return;
  }
  var key = v5.shift();
  if (key === "PARAMETER") {
    key = v5.shift();
  }
  if (v5.length === 1) {
    if (Array.isArray(v5[0])) {
      obj[key] = {};
      sExpr(v5[0], obj[key]);
      return;
    }
    obj[key] = v5[0];
    return;
  }
  if (!v5.length) {
    obj[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj[key] = v5;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v5);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i7;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key] = {
        name: v5[0].toLowerCase(),
        convert: v5[1]
      };
      if (v5.length === 3) {
        sExpr(v5[2], obj[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key] = {
        name: v5[0],
        a: v5[1],
        rf: v5[2]
      };
      if (v5.length === 4) {
        sExpr(v5[3], obj[key]);
      }
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      v5[0] = ["name", v5[0]];
      mapit(obj, key, v5);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      v5[0] = ["name", v5[0]];
      mapit(obj, key, v5);
      obj[key].type = key;
      return;
    default:
      i7 = -1;
      while (++i7 < v5.length) {
        if (!Array.isArray(v5[i7])) {
          return sExpr(v5, obj[key]);
        }
      }
      return mapit(obj, key, v5);
  }
}
var init_process = __esm({
  "node_modules/wkt-parser/process.js"() {
  }
});

// node_modules/wkt-parser/util.js
function d2r(input) {
  return input * D2R2;
}
function applyProjectionDefaults(wkt) {
  const normalizedProjName = (wkt.projName || "").toLowerCase().replace(/_/g, " ");
  if (!wkt.long0 && wkt.longc && (normalizedProjName === "albers conic equal area" || normalizedProjName === "lambert azimuthal equal area")) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (normalizedProjName === "stereographic south pole" || normalizedProjName === "polar stereographic (variant b)")) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
    delete wkt.lat1;
  } else if (!wkt.lat_ts && wkt.lat0 && (normalizedProjName === "polar stereographic" || normalizedProjName === "polar stereographic (variant a)")) {
    wkt.lat_ts = wkt.lat0;
    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
    delete wkt.lat1;
  }
}
var D2R2;
var init_util3 = __esm({
  "node_modules/wkt-parser/util.js"() {
    D2R2 = 0.017453292519943295;
  }
});

// node_modules/wkt-parser/transformPROJJSON.js
function processUnit(unit) {
  let result = { units: null, to_meter: void 0 };
  if (typeof unit === "string") {
    result.units = unit.toLowerCase();
    if (result.units === "metre") {
      result.units = "meter";
    }
    if (result.units === "meter") {
      result.to_meter = 1;
    }
  } else if (unit && unit.name) {
    result.units = unit.name.toLowerCase();
    if (result.units === "metre") {
      result.units = "meter";
    }
    result.to_meter = unit.conversion_factor;
  }
  return result;
}
function toValue(valueOrObject) {
  if (typeof valueOrObject === "object") {
    return valueOrObject.value * valueOrObject.unit.conversion_factor;
  }
  return valueOrObject;
}
function calculateEllipsoid(value, result) {
  if (value.ellipsoid.radius) {
    result.a = value.ellipsoid.radius;
    result.rf = 0;
  } else {
    result.a = toValue(value.ellipsoid.semi_major_axis);
    if (value.ellipsoid.inverse_flattening !== void 0) {
      result.rf = value.ellipsoid.inverse_flattening;
    } else if (value.ellipsoid.semi_major_axis !== void 0 && value.ellipsoid.semi_minor_axis !== void 0) {
      result.rf = result.a / (result.a - toValue(value.ellipsoid.semi_minor_axis));
    }
  }
}
function transformPROJJSON(projjson, result = {}) {
  if (!projjson || typeof projjson !== "object") {
    return projjson;
  }
  if (projjson.type === "BoundCRS") {
    transformPROJJSON(projjson.source_crs, result);
    if (projjson.transformation) {
      if (projjson.transformation.method && projjson.transformation.method.name === "NTv2") {
        result.nadgrids = projjson.transformation.parameters[0].value;
      } else {
        result.datum_params = projjson.transformation.parameters.map((param) => param.value);
      }
    }
    return result;
  }
  Object.keys(projjson).forEach((key) => {
    const value = projjson[key];
    if (value === null) {
      return;
    }
    switch (key) {
      case "name":
        if (result.srsCode) {
          break;
        }
        result.name = value;
        result.srsCode = value;
        break;
      case "type":
        if (value === "GeographicCRS") {
          result.projName = "longlat";
        } else if (value === "ProjectedCRS" && projjson.conversion && projjson.conversion.method) {
          result.projName = projjson.conversion.method.name;
        }
        break;
      case "datum":
      case "datum_ensemble":
        if (value.ellipsoid) {
          result.ellps = value.ellipsoid.name;
          calculateEllipsoid(value, result);
        }
        if (value.prime_meridian) {
          result.from_greenwich = value.prime_meridian.longitude * Math.PI / 180;
        }
        break;
      case "ellipsoid":
        result.ellps = value.name;
        calculateEllipsoid(value, result);
        break;
      case "prime_meridian":
        result.long0 = (value.longitude || 0) * Math.PI / 180;
        break;
      case "coordinate_system":
        if (value.axis) {
          result.axis = value.axis.map((axis) => {
            const direction = axis.direction;
            if (direction === "east") return "e";
            if (direction === "north") return "n";
            if (direction === "west") return "w";
            if (direction === "south") return "s";
            throw new Error(`Unknown axis direction: ${direction}`);
          }).join("") + "u";
          if (value.unit) {
            const { units, to_meter } = processUnit(value.unit);
            result.units = units;
            result.to_meter = to_meter;
          } else if (value.axis[0] && value.axis[0].unit) {
            const { units, to_meter } = processUnit(value.axis[0].unit);
            result.units = units;
            result.to_meter = to_meter;
          }
        }
        break;
      case "id":
        if (value.authority && value.code) {
          result.title = value.authority + ":" + value.code;
        }
        break;
      case "conversion":
        if (value.method && value.method.name) {
          result.projName = value.method.name;
        }
        if (value.parameters) {
          value.parameters.forEach((param) => {
            const paramName = param.name.toLowerCase().replace(/\s+/g, "_");
            const paramValue = param.value;
            if (param.unit && param.unit.conversion_factor) {
              result[paramName] = paramValue * param.unit.conversion_factor;
            } else if (param.unit === "degree") {
              result[paramName] = paramValue * Math.PI / 180;
            } else {
              result[paramName] = paramValue;
            }
          });
        }
        break;
      case "unit":
        if (value.name) {
          result.units = value.name.toLowerCase();
          if (result.units === "metre") {
            result.units = "meter";
          }
        }
        if (value.conversion_factor) {
          result.to_meter = value.conversion_factor;
        }
        break;
      case "base_crs":
        transformPROJJSON(value, result);
        result.datumCode = value.id ? value.id.authority + "_" + value.id.code : value.name;
        break;
      default:
        break;
    }
  });
  if (result.latitude_of_false_origin !== void 0) {
    result.lat0 = result.latitude_of_false_origin;
  }
  if (result.longitude_of_false_origin !== void 0) {
    result.long0 = result.longitude_of_false_origin;
  }
  if (result.latitude_of_standard_parallel !== void 0) {
    result.lat0 = result.latitude_of_standard_parallel;
    result.lat1 = result.latitude_of_standard_parallel;
  }
  if (result.latitude_of_1st_standard_parallel !== void 0) {
    result.lat1 = result.latitude_of_1st_standard_parallel;
  }
  if (result.latitude_of_2nd_standard_parallel !== void 0) {
    result.lat2 = result.latitude_of_2nd_standard_parallel;
  }
  if (result.latitude_of_projection_centre !== void 0) {
    result.lat0 = result.latitude_of_projection_centre;
  }
  if (result.longitude_of_projection_centre !== void 0) {
    result.longc = result.longitude_of_projection_centre;
  }
  if (result.easting_at_false_origin !== void 0) {
    result.x0 = result.easting_at_false_origin;
  }
  if (result.northing_at_false_origin !== void 0) {
    result.y0 = result.northing_at_false_origin;
  }
  if (result.latitude_of_natural_origin !== void 0) {
    result.lat0 = result.latitude_of_natural_origin;
  }
  if (result.longitude_of_natural_origin !== void 0) {
    result.long0 = result.longitude_of_natural_origin;
  }
  if (result.longitude_of_origin !== void 0) {
    result.long0 = result.longitude_of_origin;
  }
  if (result.false_easting !== void 0) {
    result.x0 = result.false_easting;
  }
  if (result.easting_at_projection_centre) {
    result.x0 = result.easting_at_projection_centre;
  }
  if (result.false_northing !== void 0) {
    result.y0 = result.false_northing;
  }
  if (result.northing_at_projection_centre) {
    result.y0 = result.northing_at_projection_centre;
  }
  if (result.standard_parallel_1 !== void 0) {
    result.lat1 = result.standard_parallel_1;
  }
  if (result.standard_parallel_2 !== void 0) {
    result.lat2 = result.standard_parallel_2;
  }
  if (result.scale_factor_at_natural_origin !== void 0) {
    result.k0 = result.scale_factor_at_natural_origin;
  }
  if (result.scale_factor_at_projection_centre !== void 0) {
    result.k0 = result.scale_factor_at_projection_centre;
  }
  if (result.scale_factor_on_pseudo_standard_parallel !== void 0) {
    result.k0 = result.scale_factor_on_pseudo_standard_parallel;
  }
  if (result.azimuth !== void 0) {
    result.alpha = result.azimuth;
  }
  if (result.azimuth_at_projection_centre !== void 0) {
    result.alpha = result.azimuth_at_projection_centre;
  }
  if (result.angle_from_rectified_to_skew_grid) {
    result.rectified_grid_angle = result.angle_from_rectified_to_skew_grid;
  }
  applyProjectionDefaults(result);
  return result;
}
var init_transformPROJJSON = __esm({
  "node_modules/wkt-parser/transformPROJJSON.js"() {
    init_util3();
  }
});

// node_modules/wkt-parser/index.js
function rename(obj, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params2.length === 3) {
      obj[outName] = params2[2](obj[outName]);
    }
  }
}
function cleanWKT(wkt) {
  var keys = Object.keys(wkt);
  for (var i7 = 0, ii = keys.length; i7 < ii; ++i7) {
    var key = keys[i7];
    if (knownTypes.indexOf(key) !== -1) {
      setPropertiesFromWkt(wkt[key]);
    }
    if (typeof wkt[key] === "object") {
      cleanWKT(wkt[key]);
    }
  }
}
function setPropertiesFromWkt(wkt) {
  if (wkt.AUTHORITY) {
    var authority = Object.keys(wkt.AUTHORITY)[0];
    if (authority && authority in wkt.AUTHORITY) {
      wkt.title = authority + ":" + wkt.AUTHORITY[authority];
    }
  }
  if (wkt.type === "GEOGCS") {
    wkt.projName = "longlat";
  } else if (wkt.type === "LOCAL_CS") {
    wkt.projName = "identity";
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = "";
    for (var i7 = 0, ii = wkt.AXIS.length; i7 < ii; ++i7) {
      var axis = [wkt.AXIS[i7][0].toLowerCase(), wkt.AXIS[i7][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === "metre") {
      wkt.units = "meter";
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === "GEOGCS") {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === "GEOGCS") {
    geogcs = wkt;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === "d_") {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === "new_zealand_1949") {
      wkt.datumCode = "nzgd49";
    }
    if (wkt.datumCode === "wgs_1984" || wkt.datumCode === "world_geodetic_system_1984") {
      if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt.sphere = true;
      }
      wkt.datumCode = "wgs84";
    }
    if (wkt.datumCode === "belge_1972") {
      wkt.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = "intl";
      }
      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf("osgb_1936")) {
      wkt.datumCode = "osgb36";
    }
    if (~wkt.datumCode.indexOf("osni_1952")) {
      wkt.datumCode = "osni52";
    }
    if (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt.datumCode = "ire65";
    }
    if (wkt.datumCode === "ch1903+") {
      wkt.datumCode = "ch1903";
    }
    if (~wkt.datumCode.indexOf("israel")) {
      wkt.datumCode = "isr93";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }
  if (wkt.rectified_grid_angle) {
    wkt.rectified_grid_angle = d2r(wkt.rectified_grid_angle);
  }
  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a5) {
    return rename(wkt, a5);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  applyProjectionDefaults(wkt);
}
function wkt_parser_default(wkt) {
  if (typeof wkt === "object") {
    return transformPROJJSON(wkt);
  }
  const version5 = detectWKTVersion(wkt);
  var lisp = parser_default(wkt);
  if (version5 === "WKT2") {
    const projjson = buildPROJJSON(lisp);
    return transformPROJJSON(projjson);
  }
  var type = lisp[0];
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj[type];
}
var knownTypes;
var init_wkt_parser = __esm({
  "node_modules/wkt-parser/index.js"() {
    init_buildPROJJSON();
    init_detectWKTVersion();
    init_parser2();
    init_process();
    init_transformPROJJSON();
    init_util3();
    knownTypes = [
      "PROJECTEDCRS",
      "PROJCRS",
      "GEOGCS",
      "GEOCCS",
      "PROJCS",
      "LOCAL_CS",
      "GEODCRS",
      "GEODETICCRS",
      "GEODETICDATUM",
      "ENGCRS",
      "ENGINEERINGCRS"
    ];
  }
});

// node_modules/proj4/lib/defs.js
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[
          /** @type {string} */
          name
        ] = projString_default(arguments[1]);
      } else {
        defs[
          /** @type {string} */
          name
        ] = wkt_parser_default(arguments[1]);
      }
    } else {
      defs[
        /** @type {string} */
        name
      ] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v5) {
        if (Array.isArray(v5)) {
          return defs.apply(that, v5);
        } else {
          return defs(v5);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
var defs_default;
var init_defs = __esm({
  "node_modules/proj4/lib/defs.js"() {
    init_global();
    init_projString();
    init_wkt_parser();
    global_default(defs);
    defs_default = defs;
  }
});

// node_modules/proj4/lib/parseCode.js
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs_default;
}
function testWKT(code) {
  return code.indexOf("+") !== 0 && code.indexOf("[") !== -1 || typeof code === "object" && !("srsCode" in code);
}
function checkMercator(item) {
  var auth = match(item, "authority");
  if (!auth) {
    return;
  }
  var code = match(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, "extension");
  if (!ext) {
    return;
  }
  return match(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse5(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs_default[code];
    }
    if (testWKT(code)) {
      var out = wkt_parser_default(code);
      if (checkMercator(out)) {
        return defs_default["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString_default(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projString_default(code);
    }
  } else if (!("projName" in code)) {
    return wkt_parser_default(code);
  } else {
    return code;
  }
}
var codes, parseCode_default;
var init_parseCode = __esm({
  "node_modules/proj4/lib/parseCode.js"() {
    init_defs();
    init_wkt_parser();
    init_projString();
    init_match();
    codes = ["3857", "900913", "3785", "102113"];
    parseCode_default = parse5;
  }
});

// node_modules/proj4/lib/extend.js
function extend_default(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== void 0) {
      destination[property] = value;
    }
  }
  return destination;
}
var init_extend = __esm({
  "node_modules/proj4/lib/extend.js"() {
  }
});

// node_modules/proj4/lib/common/msfnz.js
function msfnz_default(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}
var init_msfnz = __esm({
  "node_modules/proj4/lib/common/msfnz.js"() {
  }
});

// node_modules/proj4/lib/common/sign.js
function sign_default(x4) {
  return x4 < 0 ? -1 : 1;
}
var init_sign = __esm({
  "node_modules/proj4/lib/common/sign.js"() {
  }
});

// node_modules/proj4/lib/common/adjust_lon.js
function adjust_lon_default(x4) {
  return Math.abs(x4) <= SPI ? x4 : x4 - sign_default(x4) * TWO_PI;
}
var init_adjust_lon = __esm({
  "node_modules/proj4/lib/common/adjust_lon.js"() {
    init_values();
    init_sign();
  }
});

// node_modules/proj4/lib/common/tsfnz.js
function tsfnz_default(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}
var init_tsfnz = __esm({
  "node_modules/proj4/lib/common/tsfnz.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/common/phi2z.js
function phi2z_default(eccent, ts2) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts2);
  for (var i7 = 0; i7 <= 15; i7++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts2 * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}
var init_phi2z = __esm({
  "node_modules/proj4/lib/common/phi2z.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/projections/merc.js
function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward(p6) {
  var lon = p6.x;
  var lat = p6.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x4, y5;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x4 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y5 = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts2 = tsfnz_default(this.e, lat, sinphi);
      x4 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y5 = this.y0 - this.a * this.k0 * Math.log(ts2);
    }
    p6.x = x4;
    p6.y = y5;
    return p6;
  }
}
function inverse(p6) {
  var x4 = p6.x - this.x0;
  var y5 = p6.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y5 / (this.a * this.k0)));
  } else {
    var ts2 = Math.exp(-y5 / (this.a * this.k0));
    lat = phi2z_default(this.e, ts2);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon_default(this.long0 + x4 / (this.a * this.k0));
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names, merc_default;
var init_merc = __esm({
  "node_modules/proj4/lib/projections/merc.js"() {
    init_msfnz();
    init_adjust_lon();
    init_tsfnz();
    init_phi2z();
    init_values();
    names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "Mercator_Variant_A", "merc"];
    merc_default = {
      init,
      forward,
      inverse,
      names
    };
  }
});

// node_modules/proj4/lib/projections/longlat.js
function init2() {
}
function identity(pt2) {
  return pt2;
}
var names2, longlat_default;
var init_longlat = __esm({
  "node_modules/proj4/lib/projections/longlat.js"() {
    names2 = ["longlat", "identity"];
    longlat_default = {
      init: init2,
      forward: identity,
      inverse: identity,
      names: names2
    };
  }
});

// node_modules/proj4/lib/projections.js
function add4(proj, i7) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i7);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n6) {
    names3[n6.toLowerCase()] = len;
  });
  return this;
}
function getNormalizedProjName(n6) {
  return n6.replace(/[-\(\)\s]+/g, " ").trim().replace(/ /g, "_");
}
function get6(name) {
  if (!name) {
    return false;
  }
  var n6 = name.toLowerCase();
  if (typeof names3[n6] !== "undefined" && projStore[names3[n6]]) {
    return projStore[names3[n6]];
  }
  n6 = getNormalizedProjName(n6);
  if (n6 in names3 && projStore[names3[n6]]) {
    return projStore[names3[n6]];
  }
}
function start() {
  projs.forEach(add4);
}
var projs, names3, projStore, projections_default;
var init_projections2 = __esm({
  "node_modules/proj4/lib/projections.js"() {
    init_merc();
    init_longlat();
    projs = [merc_default, longlat_default];
    names3 = {};
    projStore = [];
    projections_default = {
      start,
      add: add4,
      get: get6
    };
  }
});

// node_modules/proj4/lib/constants/Ellipsoid.js
var ellipsoids, Ellipsoid_default;
var init_Ellipsoid = __esm({
  "node_modules/proj4/lib/constants/Ellipsoid.js"() {
    ellipsoids = {
      MERIT: {
        a: 6378137,
        rf: 298.257,
        ellipseName: "MERIT 1983"
      },
      SGS85: {
        a: 6378136,
        rf: 298.257,
        ellipseName: "Soviet Geodetic System 85"
      },
      GRS80: {
        a: 6378137,
        rf: 298.257222101,
        ellipseName: "GRS 1980(IUGG, 1980)"
      },
      IAU76: {
        a: 6378140,
        rf: 298.257,
        ellipseName: "IAU 1976"
      },
      airy: {
        a: 6377563396e-3,
        b: 635625691e-2,
        ellipseName: "Airy 1830"
      },
      APL4: {
        a: 6378137,
        rf: 298.25,
        ellipseName: "Appl. Physics. 1965"
      },
      NWL9D: {
        a: 6378145,
        rf: 298.25,
        ellipseName: "Naval Weapons Lab., 1965"
      },
      mod_airy: {
        a: 6377340189e-3,
        b: 6356034446e-3,
        ellipseName: "Modified Airy"
      },
      andrae: {
        a: 637710443e-2,
        rf: 300,
        ellipseName: "Andrae 1876 (Den., Iclnd.)"
      },
      aust_SA: {
        a: 6378160,
        rf: 298.25,
        ellipseName: "Australian Natl & S. Amer. 1969"
      },
      GRS67: {
        a: 6378160,
        rf: 298.247167427,
        ellipseName: "GRS 67(IUGG 1967)"
      },
      bessel: {
        a: 6377397155e-3,
        rf: 299.1528128,
        ellipseName: "Bessel 1841"
      },
      bess_nam: {
        a: 6377483865e-3,
        rf: 299.1528128,
        ellipseName: "Bessel 1841 (Namibia)"
      },
      clrk66: {
        a: 63782064e-1,
        b: 63565838e-1,
        ellipseName: "Clarke 1866"
      },
      clrk80: {
        a: 6378249145e-3,
        rf: 293.4663,
        ellipseName: "Clarke 1880 mod."
      },
      clrk80ign: {
        a: 63782492e-1,
        b: 6356515,
        rf: 293.4660213,
        ellipseName: "Clarke 1880 (IGN)"
      },
      clrk58: {
        a: 6378293645208759e-9,
        rf: 294.2606763692654,
        ellipseName: "Clarke 1858"
      },
      CPM: {
        a: 63757387e-1,
        rf: 334.29,
        ellipseName: "Comm. des Poids et Mesures 1799"
      },
      delmbr: {
        a: 6376428,
        rf: 311.5,
        ellipseName: "Delambre 1810 (Belgium)"
      },
      engelis: {
        a: 637813605e-2,
        rf: 298.2566,
        ellipseName: "Engelis 1985"
      },
      evrst30: {
        a: 6377276345e-3,
        rf: 300.8017,
        ellipseName: "Everest 1830"
      },
      evrst48: {
        a: 6377304063e-3,
        rf: 300.8017,
        ellipseName: "Everest 1948"
      },
      evrst56: {
        a: 6377301243e-3,
        rf: 300.8017,
        ellipseName: "Everest 1956"
      },
      evrst69: {
        a: 6377295664e-3,
        rf: 300.8017,
        ellipseName: "Everest 1969"
      },
      evrstSS: {
        a: 6377298556e-3,
        rf: 300.8017,
        ellipseName: "Everest (Sabah & Sarawak)"
      },
      fschr60: {
        a: 6378166,
        rf: 298.3,
        ellipseName: "Fischer (Mercury Datum) 1960"
      },
      fschr60m: {
        a: 6378155,
        rf: 298.3,
        ellipseName: "Fischer 1960"
      },
      fschr68: {
        a: 6378150,
        rf: 298.3,
        ellipseName: "Fischer 1968"
      },
      helmert: {
        a: 6378200,
        rf: 298.3,
        ellipseName: "Helmert 1906"
      },
      hough: {
        a: 6378270,
        rf: 297,
        ellipseName: "Hough"
      },
      intl: {
        a: 6378388,
        rf: 297,
        ellipseName: "International 1909 (Hayford)"
      },
      kaula: {
        a: 6378163,
        rf: 298.24,
        ellipseName: "Kaula 1961"
      },
      lerch: {
        a: 6378139,
        rf: 298.257,
        ellipseName: "Lerch 1979"
      },
      mprts: {
        a: 6397300,
        rf: 191,
        ellipseName: "Maupertius 1738"
      },
      new_intl: {
        a: 63781575e-1,
        b: 63567722e-1,
        ellipseName: "New International 1967"
      },
      plessis: {
        a: 6376523,
        rf: 6355863,
        ellipseName: "Plessis 1817 (France)"
      },
      krass: {
        a: 6378245,
        rf: 298.3,
        ellipseName: "Krassovsky, 1942"
      },
      SEasia: {
        a: 6378155,
        b: 63567733205e-4,
        ellipseName: "Southeast Asia"
      },
      walbeck: {
        a: 6376896,
        b: 63558348467e-4,
        ellipseName: "Walbeck"
      },
      WGS60: {
        a: 6378165,
        rf: 298.3,
        ellipseName: "WGS 60"
      },
      WGS66: {
        a: 6378145,
        rf: 298.25,
        ellipseName: "WGS 66"
      },
      WGS7: {
        a: 6378135,
        rf: 298.26,
        ellipseName: "WGS 72"
      },
      WGS84: {
        a: 6378137,
        rf: 298.257223563,
        ellipseName: "WGS 84"
      },
      sphere: {
        a: 6370997,
        b: 6370997,
        ellipseName: "Normal Sphere (r=6370997)"
      }
    };
    Ellipsoid_default = ellipsoids;
  }
});

// node_modules/proj4/lib/deriveConstants.js
function eccentricity(a5, b8, rf, R_A) {
  var a23 = a5 * a5;
  var b23 = b8 * b8;
  var es2 = (a23 - b23) / a23;
  var e3 = 0;
  if (R_A) {
    a5 *= 1 - es2 * (SIXTH + es2 * (RA4 + es2 * RA6));
    a23 = a5 * a5;
    es2 = 0;
  } else {
    e3 = Math.sqrt(es2);
  }
  var ep2 = (a23 - b23) / b23;
  return {
    es: es2,
    e: e3,
    ep2
  };
}
function sphere(a5, b8, rf, ellps, sphere2) {
  if (!a5) {
    var ellipse = match(Ellipsoid_default, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a5 = ellipse.a;
    b8 = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b8) {
    b8 = (1 - 1 / rf) * a5;
  }
  if (rf === 0 || Math.abs(a5 - b8) < EPSLN) {
    sphere2 = true;
    b8 = a5;
  }
  return {
    a: a5,
    b: b8,
    rf,
    sphere: sphere2
  };
}
var WGS84;
var init_deriveConstants = __esm({
  "node_modules/proj4/lib/deriveConstants.js"() {
    init_values();
    init_Ellipsoid();
    init_match();
    WGS84 = Ellipsoid_default.WGS84;
  }
});

// node_modules/proj4/lib/constants/Datum.js
var datums, datum2, key, Datum_default;
var init_Datum = __esm({
  "node_modules/proj4/lib/constants/Datum.js"() {
    datums = {
      wgs84: {
        towgs84: "0,0,0",
        ellipse: "WGS84",
        datumName: "WGS84"
      },
      ch1903: {
        towgs84: "674.374,15.056,405.346",
        ellipse: "bessel",
        datumName: "swiss"
      },
      ggrs87: {
        towgs84: "-199.87,74.79,246.62",
        ellipse: "GRS80",
        datumName: "Greek_Geodetic_Reference_System_1987"
      },
      nad83: {
        towgs84: "0,0,0",
        ellipse: "GRS80",
        datumName: "North_American_Datum_1983"
      },
      nad27: {
        nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
        ellipse: "clrk66",
        datumName: "North_American_Datum_1927"
      },
      potsdam: {
        towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
        ellipse: "bessel",
        datumName: "Potsdam Rauenberg 1950 DHDN"
      },
      carthage: {
        towgs84: "-263.0,6.0,431.0",
        ellipse: "clark80",
        datumName: "Carthage 1934 Tunisia"
      },
      hermannskogel: {
        towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
        ellipse: "bessel",
        datumName: "Hermannskogel"
      },
      mgi: {
        towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
        ellipse: "bessel",
        datumName: "Militar-Geographische Institut"
      },
      osni52: {
        towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
        ellipse: "airy",
        datumName: "Irish National"
      },
      ire65: {
        towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
        ellipse: "mod_airy",
        datumName: "Ireland 1965"
      },
      rassadiran: {
        towgs84: "-133.63,-157.5,-158.62",
        ellipse: "intl",
        datumName: "Rassadiran"
      },
      nzgd49: {
        towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
        ellipse: "intl",
        datumName: "New Zealand Geodetic Datum 1949"
      },
      osgb36: {
        towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
        ellipse: "airy",
        datumName: "Ordnance Survey of Great Britain 1936"
      },
      s_jtsk: {
        towgs84: "589,76,480",
        ellipse: "bessel",
        datumName: "S-JTSK (Ferro)"
      },
      beduaram: {
        towgs84: "-106,-87,188",
        ellipse: "clrk80",
        datumName: "Beduaram"
      },
      gunung_segara: {
        towgs84: "-403,684,41",
        ellipse: "bessel",
        datumName: "Gunung Segara Jakarta"
      },
      rnb72: {
        towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
        ellipse: "intl",
        datumName: "Reseau National Belge 1972"
      },
      EPSG_5451: {
        towgs84: "6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649"
      },
      IGNF_LURESG: {
        towgs84: "-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43"
      },
      EPSG_4614: {
        towgs84: "-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065"
      },
      EPSG_4615: {
        towgs84: "-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748"
      },
      ESRI_37241: {
        towgs84: "-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031"
      },
      ESRI_37249: {
        towgs84: "-440.296,58.548,296.265,1.128,10.202,4.559,-0.438"
      },
      ESRI_37245: {
        towgs84: "-511.151,-181.269,139.609,1.05,2.703,1.798,3.071"
      },
      EPSG_4178: {
        towgs84: "24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01"
      },
      EPSG_4622: {
        towgs84: "-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984"
      },
      EPSG_4625: {
        towgs84: "126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227"
      },
      EPSG_5252: {
        towgs84: "0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439"
      },
      EPSG_4314: {
        towgs84: "597.1,71.4,412.1,0.894,0.068,-1.563,7.58"
      },
      EPSG_4282: {
        towgs84: "-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166"
      },
      EPSG_4231: {
        towgs84: "-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218"
      },
      EPSG_4274: {
        towgs84: "-230.994,102.591,25.199,0.633,-0.239,0.9,1.95"
      },
      EPSG_4134: {
        towgs84: "-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006"
      },
      EPSG_4254: {
        towgs84: "18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013"
      },
      EPSG_4159: {
        towgs84: "-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175"
      },
      EPSG_4687: {
        towgs84: "0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093"
      },
      EPSG_4227: {
        towgs84: "-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225"
      },
      EPSG_4746: {
        towgs84: "599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46"
      },
      EPSG_4745: {
        towgs84: "612.4,77,440.2,-0.054,0.057,-2.797,2.55"
      },
      EPSG_6311: {
        towgs84: "8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926"
      },
      EPSG_4289: {
        towgs84: "565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244"
      },
      EPSG_4230: {
        towgs84: "-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4"
      },
      EPSG_4154: {
        towgs84: "-123.02,-158.95,-168.47"
      },
      EPSG_4156: {
        towgs84: "570.8,85.7,462.8,4.998,1.587,5.261,3.56"
      },
      EPSG_4299: {
        towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
      },
      EPSG_4179: {
        towgs84: "33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84"
      },
      EPSG_4313: {
        towgs84: "-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747"
      },
      EPSG_4194: {
        towgs84: "163.511,127.533,-159.789"
      },
      EPSG_4195: {
        towgs84: "105,326,-102.5"
      },
      EPSG_4196: {
        towgs84: "-45,417,-3.5"
      },
      EPSG_4611: {
        towgs84: "-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246"
      },
      EPSG_4633: {
        towgs84: "137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824"
      },
      EPSG_4641: {
        towgs84: "-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993"
      },
      EPSG_4643: {
        towgs84: "-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002"
      },
      EPSG_4300: {
        towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
      },
      EPSG_4188: {
        towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
      },
      EPSG_4660: {
        towgs84: "982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805"
      },
      EPSG_4662: {
        towgs84: "97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259"
      },
      EPSG_3906: {
        towgs84: "577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664"
      },
      EPSG_4307: {
        towgs84: "-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547"
      },
      EPSG_6892: {
        towgs84: "-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686"
      },
      EPSG_4690: {
        towgs84: "221.597,152.441,176.523,2.403,1.3893,0.884,11.4648"
      },
      EPSG_4691: {
        towgs84: "218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817"
      },
      EPSG_4629: {
        towgs84: "72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653"
      },
      EPSG_4630: {
        towgs84: "165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111"
      },
      EPSG_4692: {
        towgs84: "217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093"
      },
      EPSG_9333: {
        towgs84: "0,0,0,-8.393,0.749,-10.276,0"
      },
      EPSG_9059: {
        towgs84: "0,0,0"
      },
      EPSG_4312: {
        towgs84: "601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887"
      },
      EPSG_4123: {
        towgs84: "-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496"
      },
      EPSG_4309: {
        towgs84: "-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365"
      },
      ESRI_104106: {
        towgs84: "-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058"
      },
      EPSG_4281: {
        towgs84: "-219.247,-73.802,269.529"
      },
      EPSG_4322: {
        towgs84: "0,0,4.5"
      },
      EPSG_4324: {
        towgs84: "0,0,1.9"
      },
      EPSG_4284: {
        towgs84: "43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549"
      },
      EPSG_4277: {
        towgs84: "446.448,-125.157,542.06,0.15,0.247,0.842,-20.489"
      },
      EPSG_4207: {
        towgs84: "-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46"
      },
      EPSG_4688: {
        towgs84: "347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647"
      },
      EPSG_4689: {
        towgs84: "410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218"
      },
      EPSG_4720: {
        towgs84: "0,0,4.5"
      },
      EPSG_4273: {
        towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
      },
      EPSG_4240: {
        towgs84: "204.64,834.74,293.8"
      },
      EPSG_4817: {
        towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
      },
      ESRI_104131: {
        towgs84: "426.62,142.62,460.09,4.98,4.49,-12.42,-17.1"
      },
      EPSG_4265: {
        towgs84: "-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68"
      },
      EPSG_4263: {
        towgs84: "-111.92,-87.85,114.5,1.875,0.202,0.219,0.032"
      },
      EPSG_4298: {
        towgs84: "-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536"
      },
      EPSG_4270: {
        towgs84: "-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424"
      },
      EPSG_4229: {
        towgs84: "-121.8,98.1,-10.7"
      },
      EPSG_4220: {
        towgs84: "-55.5,-348,-229.2"
      },
      EPSG_4214: {
        towgs84: "12.646,-155.176,-80.863"
      },
      EPSG_4232: {
        towgs84: "-345,3,223"
      },
      EPSG_4238: {
        towgs84: "-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037"
      },
      EPSG_4168: {
        towgs84: "-170,33,326"
      },
      EPSG_4131: {
        towgs84: "199,931,318.9"
      },
      EPSG_4152: {
        towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
      },
      EPSG_5228: {
        towgs84: "572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378"
      },
      EPSG_8351: {
        towgs84: "485.021,169.465,483.839,7.786342,4.397554,4.102655,0"
      },
      EPSG_4683: {
        towgs84: "-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06"
      },
      EPSG_4133: {
        towgs84: "0,0,0"
      },
      EPSG_7373: {
        towgs84: "0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693"
      },
      EPSG_9075: {
        towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
      },
      EPSG_9072: {
        towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
      },
      EPSG_9294: {
        towgs84: "1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388"
      },
      EPSG_4212: {
        towgs84: "-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492"
      },
      EPSG_4191: {
        towgs84: "-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703"
      },
      EPSG_4237: {
        towgs84: "52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191"
      },
      EPSG_4740: {
        towgs84: "-1.08,-0.27,-0.9"
      },
      EPSG_4124: {
        towgs84: "419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496"
      },
      EPSG_5681: {
        towgs84: "584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922"
      },
      EPSG_4141: {
        towgs84: "23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262"
      },
      EPSG_4204: {
        towgs84: "-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194"
      },
      EPSG_4319: {
        towgs84: "226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798"
      },
      EPSG_4200: {
        towgs84: "24.82,-131.21,-82.66"
      },
      EPSG_4130: {
        towgs84: "0,0,0"
      },
      EPSG_4127: {
        towgs84: "-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359"
      },
      EPSG_4149: {
        towgs84: "674.374,15.056,405.346"
      },
      EPSG_4617: {
        towgs84: "-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0"
      },
      EPSG_4663: {
        towgs84: "-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485"
      },
      EPSG_4664: {
        towgs84: "-211.939,137.626,58.3,-0.089,0.251,0.079,0.384"
      },
      EPSG_4665: {
        towgs84: "-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048"
      },
      EPSG_4666: {
        towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
      },
      EPSG_4756: {
        towgs84: "-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188"
      },
      EPSG_4723: {
        towgs84: "-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925"
      },
      EPSG_4726: {
        towgs84: "8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081"
      },
      EPSG_4267: {
        towgs84: "-8.0,160.0,176.0"
      },
      EPSG_5365: {
        towgs84: "-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693"
      },
      EPSG_4218: {
        towgs84: "304.5,306.5,-318.1"
      },
      EPSG_4242: {
        towgs84: "-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95"
      },
      EPSG_4216: {
        towgs84: "-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289"
      },
      ESRI_104105: {
        towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
      },
      ESRI_104129: {
        towgs84: "0,0,0"
      },
      EPSG_4673: {
        towgs84: "174.05,-25.49,112.57"
      },
      EPSG_4202: {
        towgs84: "-124,-60,154"
      },
      EPSG_4203: {
        towgs84: "-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191"
      },
      EPSG_3819: {
        towgs84: "595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408"
      },
      EPSG_8694: {
        towgs84: "-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169"
      },
      EPSG_4145: {
        towgs84: "275.57,676.78,229.6"
      },
      EPSG_4283: {
        towgs84: "61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994"
      },
      EPSG_4317: {
        towgs84: "2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266"
      },
      EPSG_4272: {
        towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993"
      },
      EPSG_4248: {
        towgs84: "-307.7,265.3,-363.5"
      },
      EPSG_5561: {
        towgs84: "24,-121,-76"
      },
      EPSG_5233: {
        towgs84: "-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338"
      },
      ESRI_104130: {
        towgs84: "-86,-98,-119"
      },
      ESRI_104102: {
        towgs84: "682,-203,480"
      },
      ESRI_37207: {
        towgs84: "7,-10,-26"
      },
      EPSG_4675: {
        towgs84: "59.935,118.4,-10.871"
      },
      ESRI_104109: {
        towgs84: "-89.121,-348.182,260.871"
      },
      ESRI_104112: {
        towgs84: "-185.583,-230.096,281.361"
      },
      ESRI_104113: {
        towgs84: "25.1,-275.6,222.6"
      },
      IGNF_WGS72G: {
        towgs84: "0,12,6"
      },
      IGNF_NTFG: {
        towgs84: "-168,-60,320"
      },
      IGNF_EFATE57G: {
        towgs84: "-127,-769,472"
      },
      IGNF_PGP50G: {
        towgs84: "324.8,153.6,172.1"
      },
      IGNF_REUN47G: {
        towgs84: "94,-948,-1262"
      },
      IGNF_CSG67G: {
        towgs84: "-186,230,110"
      },
      IGNF_GUAD48G: {
        towgs84: "-467,-16,-300"
      },
      IGNF_TAHI51G: {
        towgs84: "162,117,154"
      },
      IGNF_TAHAAG: {
        towgs84: "65,342,77"
      },
      IGNF_NUKU72G: {
        towgs84: "84,274,65"
      },
      IGNF_PETRELS72G: {
        towgs84: "365,194,166"
      },
      IGNF_WALL78G: {
        towgs84: "253,-133,-127"
      },
      IGNF_MAYO50G: {
        towgs84: "-382,-59,-262"
      },
      IGNF_TANNAG: {
        towgs84: "-139,-967,436"
      },
      IGNF_IGN72G: {
        towgs84: "-13,-348,292"
      },
      IGNF_ATIGG: {
        towgs84: "1118,23,66"
      },
      IGNF_FANGA84G: {
        towgs84: "150.57,158.33,118.32"
      },
      IGNF_RUSAT84G: {
        towgs84: "202.13,174.6,-15.74"
      },
      IGNF_KAUE70G: {
        towgs84: "126.74,300.1,-75.49"
      },
      IGNF_MOP90G: {
        towgs84: "-10.8,-1.8,12.77"
      },
      IGNF_MHPF67G: {
        towgs84: "338.08,212.58,-296.17"
      },
      IGNF_TAHI79G: {
        towgs84: "160.61,116.05,153.69"
      },
      IGNF_ANAA92G: {
        towgs84: "1.5,3.84,4.81"
      },
      IGNF_MARQUI72G: {
        towgs84: "330.91,-13.92,58.56"
      },
      IGNF_APAT86G: {
        towgs84: "143.6,197.82,74.05"
      },
      IGNF_TUBU69G: {
        towgs84: "237.17,171.61,-77.84"
      },
      IGNF_STPM50G: {
        towgs84: "11.363,424.148,373.13"
      },
      EPSG_4150: {
        towgs84: "674.374,15.056,405.346"
      },
      EPSG_4754: {
        towgs84: "-208.4058,-109.8777,-2.5764"
      },
      ESRI_104101: {
        towgs84: "374,150,588"
      },
      EPSG_4693: {
        towgs84: "0,-0.15,0.68"
      },
      EPSG_6207: {
        towgs84: "293.17,726.18,245.36"
      },
      EPSG_4153: {
        towgs84: "-133.63,-157.5,-158.62"
      },
      EPSG_4132: {
        towgs84: "-241.54,-163.64,396.06"
      },
      EPSG_4221: {
        towgs84: "-154.5,150.7,100.4"
      },
      EPSG_4266: {
        towgs84: "-80.7,-132.5,41.1"
      },
      EPSG_4193: {
        towgs84: "-70.9,-151.8,-41.4"
      },
      EPSG_5340: {
        towgs84: "-0.41,0.46,-0.35"
      },
      EPSG_4246: {
        towgs84: "-294.7,-200.1,525.5"
      },
      EPSG_4318: {
        towgs84: "-3.2,-5.7,2.8"
      },
      EPSG_4121: {
        towgs84: "-199.87,74.79,246.62"
      },
      EPSG_4223: {
        towgs84: "-260.1,5.5,432.2"
      },
      EPSG_4158: {
        towgs84: "-0.465,372.095,171.736"
      },
      EPSG_4285: {
        towgs84: "-128.16,-282.42,21.93"
      },
      EPSG_4613: {
        towgs84: "-404.78,685.68,45.47"
      },
      EPSG_4607: {
        towgs84: "195.671,332.517,274.607"
      },
      EPSG_4475: {
        towgs84: "-381.788,-57.501,-256.673"
      },
      EPSG_4208: {
        towgs84: "-157.84,308.54,-146.6"
      },
      EPSG_4743: {
        towgs84: "70.995,-335.916,262.898"
      },
      EPSG_4710: {
        towgs84: "-323.65,551.39,-491.22"
      },
      EPSG_7881: {
        towgs84: "-0.077,0.079,0.086"
      },
      EPSG_4682: {
        towgs84: "283.729,735.942,261.143"
      },
      EPSG_4739: {
        towgs84: "-156,-271,-189"
      },
      EPSG_4679: {
        towgs84: "-80.01,253.26,291.19"
      },
      EPSG_4750: {
        towgs84: "-56.263,16.136,-22.856"
      },
      EPSG_4644: {
        towgs84: "-10.18,-350.43,291.37"
      },
      EPSG_4695: {
        towgs84: "-103.746,-9.614,-255.95"
      },
      EPSG_4292: {
        towgs84: "-355,21,72"
      },
      EPSG_4302: {
        towgs84: "-61.702,284.488,472.052"
      },
      EPSG_4143: {
        towgs84: "-124.76,53,466.79"
      },
      EPSG_4606: {
        towgs84: "-153,153,307"
      },
      EPSG_4699: {
        towgs84: "-770.1,158.4,-498.2"
      },
      EPSG_4247: {
        towgs84: "-273.5,110.6,-357.9"
      },
      EPSG_4160: {
        towgs84: "8.88,184.86,106.69"
      },
      EPSG_4161: {
        towgs84: "-233.43,6.65,173.64"
      },
      EPSG_9251: {
        towgs84: "-9.5,122.9,138.2"
      },
      EPSG_9253: {
        towgs84: "-78.1,101.6,133.3"
      },
      EPSG_4297: {
        towgs84: "-198.383,-240.517,-107.909"
      },
      EPSG_4269: {
        towgs84: "0,0,0"
      },
      EPSG_4301: {
        towgs84: "-147,506,687"
      },
      EPSG_4618: {
        towgs84: "-59,-11,-52"
      },
      EPSG_4612: {
        towgs84: "0,0,0"
      },
      EPSG_4678: {
        towgs84: "44.585,-131.212,-39.544"
      },
      EPSG_4250: {
        towgs84: "-130,29,364"
      },
      EPSG_4144: {
        towgs84: "214,804,268"
      },
      EPSG_4147: {
        towgs84: "-17.51,-108.32,-62.39"
      },
      EPSG_4259: {
        towgs84: "-254.1,-5.36,-100.29"
      },
      EPSG_4164: {
        towgs84: "-76,-138,67"
      },
      EPSG_4211: {
        towgs84: "-378.873,676.002,-46.255"
      },
      EPSG_4182: {
        towgs84: "-422.651,-172.995,84.02"
      },
      EPSG_4224: {
        towgs84: "-143.87,243.37,-33.52"
      },
      EPSG_4225: {
        towgs84: "-205.57,168.77,-4.12"
      },
      EPSG_5527: {
        towgs84: "-67.35,3.88,-38.22"
      },
      EPSG_4752: {
        towgs84: "98,390,-22"
      },
      EPSG_4310: {
        towgs84: "-30,190,89"
      },
      EPSG_9248: {
        towgs84: "-192.26,65.72,132.08"
      },
      EPSG_4680: {
        towgs84: "124.5,-63.5,-281"
      },
      EPSG_4701: {
        towgs84: "-79.9,-158,-168.9"
      },
      EPSG_4706: {
        towgs84: "-146.21,112.63,4.05"
      },
      EPSG_4805: {
        towgs84: "682,-203,480"
      },
      EPSG_4201: {
        towgs84: "-165,-11,206"
      },
      EPSG_4210: {
        towgs84: "-157,-2,-299"
      },
      EPSG_4183: {
        towgs84: "-104,167,-38"
      },
      EPSG_4139: {
        towgs84: "11,72,-101"
      },
      EPSG_4668: {
        towgs84: "-86,-98,-119"
      },
      EPSG_4717: {
        towgs84: "-2,151,181"
      },
      EPSG_4732: {
        towgs84: "102,52,-38"
      },
      EPSG_4280: {
        towgs84: "-377,681,-50"
      },
      EPSG_4209: {
        towgs84: "-138,-105,-289"
      },
      EPSG_4261: {
        towgs84: "31,146,47"
      },
      EPSG_4658: {
        towgs84: "-73,46,-86"
      },
      EPSG_4721: {
        towgs84: "265.025,384.929,-194.046"
      },
      EPSG_4222: {
        towgs84: "-136,-108,-292"
      },
      EPSG_4601: {
        towgs84: "-255,-15,71"
      },
      EPSG_4602: {
        towgs84: "725,685,536"
      },
      EPSG_4603: {
        towgs84: "72,213.7,93"
      },
      EPSG_4605: {
        towgs84: "9,183,236"
      },
      EPSG_4621: {
        towgs84: "137,248,-430"
      },
      EPSG_4657: {
        towgs84: "-28,199,5"
      },
      EPSG_4316: {
        towgs84: "103.25,-100.4,-307.19"
      },
      EPSG_4642: {
        towgs84: "-13,-348,292"
      },
      EPSG_4698: {
        towgs84: "145,-187,103"
      },
      EPSG_4192: {
        towgs84: "-206.1,-174.7,-87.7"
      },
      EPSG_4311: {
        towgs84: "-265,120,-358"
      },
      EPSG_4135: {
        towgs84: "58,-283,-182"
      },
      ESRI_104138: {
        towgs84: "198,-226,-347"
      },
      EPSG_4245: {
        towgs84: "-11,851,5"
      },
      EPSG_4142: {
        towgs84: "-125,53,467"
      },
      EPSG_4213: {
        towgs84: "-106,-87,188"
      },
      EPSG_4253: {
        towgs84: "-133,-77,-51"
      },
      EPSG_4129: {
        towgs84: "-132,-110,-335"
      },
      EPSG_4713: {
        towgs84: "-77,-128,142"
      },
      EPSG_4239: {
        towgs84: "217,823,299"
      },
      EPSG_4146: {
        towgs84: "295,736,257"
      },
      EPSG_4155: {
        towgs84: "-83,37,124"
      },
      EPSG_4165: {
        towgs84: "-173,253,27"
      },
      EPSG_4672: {
        towgs84: "175,-38,113"
      },
      EPSG_4236: {
        towgs84: "-637,-549,-203"
      },
      EPSG_4251: {
        towgs84: "-90,40,88"
      },
      EPSG_4271: {
        towgs84: "-2,374,172"
      },
      EPSG_4175: {
        towgs84: "-88,4,101"
      },
      EPSG_4716: {
        towgs84: "298,-304,-375"
      },
      EPSG_4315: {
        towgs84: "-23,259,-9"
      },
      EPSG_4744: {
        towgs84: "-242.2,-144.9,370.3"
      },
      EPSG_4244: {
        towgs84: "-97,787,86"
      },
      EPSG_4293: {
        towgs84: "616,97,-251"
      },
      EPSG_4714: {
        towgs84: "-127,-769,472"
      },
      EPSG_4736: {
        towgs84: "260,12,-147"
      },
      EPSG_6883: {
        towgs84: "-235,-110,393"
      },
      EPSG_6894: {
        towgs84: "-63,176,185"
      },
      EPSG_4205: {
        towgs84: "-43,-163,45"
      },
      EPSG_4256: {
        towgs84: "41,-220,-134"
      },
      EPSG_4262: {
        towgs84: "639,405,60"
      },
      EPSG_4604: {
        towgs84: "174,359,365"
      },
      EPSG_4169: {
        towgs84: "-115,118,426"
      },
      EPSG_4620: {
        towgs84: "-106,-129,165"
      },
      EPSG_4184: {
        towgs84: "-203,141,53"
      },
      EPSG_4616: {
        towgs84: "-289,-124,60"
      },
      EPSG_9403: {
        towgs84: "-307,-92,127"
      },
      EPSG_4684: {
        towgs84: "-133,-321,50"
      },
      EPSG_4708: {
        towgs84: "-491,-22,435"
      },
      EPSG_4707: {
        towgs84: "114,-116,-333"
      },
      EPSG_4709: {
        towgs84: "145,75,-272"
      },
      EPSG_4712: {
        towgs84: "-205,107,53"
      },
      EPSG_4711: {
        towgs84: "124,-234,-25"
      },
      EPSG_4718: {
        towgs84: "230,-199,-752"
      },
      EPSG_4719: {
        towgs84: "211,147,111"
      },
      EPSG_4724: {
        towgs84: "208,-435,-229"
      },
      EPSG_4725: {
        towgs84: "189,-79,-202"
      },
      EPSG_4735: {
        towgs84: "647,1777,-1124"
      },
      EPSG_4722: {
        towgs84: "-794,119,-298"
      },
      EPSG_4728: {
        towgs84: "-307,-92,127"
      },
      EPSG_4734: {
        towgs84: "-632,438,-609"
      },
      EPSG_4727: {
        towgs84: "912,-58,1227"
      },
      EPSG_4729: {
        towgs84: "185,165,42"
      },
      EPSG_4730: {
        towgs84: "170,42,84"
      },
      EPSG_4733: {
        towgs84: "276,-57,149"
      },
      ESRI_37218: {
        towgs84: "230,-199,-752"
      },
      ESRI_37240: {
        towgs84: "-7,215,225"
      },
      ESRI_37221: {
        towgs84: "252,-209,-751"
      },
      ESRI_4305: {
        towgs84: "-123,-206,219"
      },
      ESRI_104139: {
        towgs84: "-73,-247,227"
      },
      EPSG_4748: {
        towgs84: "51,391,-36"
      },
      EPSG_4219: {
        towgs84: "-384,664,-48"
      },
      EPSG_4255: {
        towgs84: "-333,-222,114"
      },
      EPSG_4257: {
        towgs84: "-587.8,519.75,145.76"
      },
      EPSG_4646: {
        towgs84: "-963,510,-359"
      },
      EPSG_6881: {
        towgs84: "-24,-203,268"
      },
      EPSG_6882: {
        towgs84: "-183,-15,273"
      },
      EPSG_4715: {
        towgs84: "-104,-129,239"
      },
      IGNF_RGF93GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGM04GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGSPM06GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGTAAF07GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGFG95GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGNCG: {
        towgs84: "0,0,0"
      },
      IGNF_RGPFGDD: {
        towgs84: "0,0,0"
      },
      IGNF_ETRS89G: {
        towgs84: "0,0,0"
      },
      IGNF_RGR92GDD: {
        towgs84: "0,0,0"
      },
      EPSG_4173: {
        towgs84: "0,0,0"
      },
      EPSG_4180: {
        towgs84: "0,0,0"
      },
      EPSG_4619: {
        towgs84: "0,0,0"
      },
      EPSG_4667: {
        towgs84: "0,0,0"
      },
      EPSG_4075: {
        towgs84: "0,0,0"
      },
      EPSG_6706: {
        towgs84: "0,0,0"
      },
      EPSG_7798: {
        towgs84: "0,0,0"
      },
      EPSG_4661: {
        towgs84: "0,0,0"
      },
      EPSG_4669: {
        towgs84: "0,0,0"
      },
      EPSG_8685: {
        towgs84: "0,0,0"
      },
      EPSG_4151: {
        towgs84: "0,0,0"
      },
      EPSG_9702: {
        towgs84: "0,0,0"
      },
      EPSG_4758: {
        towgs84: "0,0,0"
      },
      EPSG_4761: {
        towgs84: "0,0,0"
      },
      EPSG_4765: {
        towgs84: "0,0,0"
      },
      EPSG_8997: {
        towgs84: "0,0,0"
      },
      EPSG_4023: {
        towgs84: "0,0,0"
      },
      EPSG_4670: {
        towgs84: "0,0,0"
      },
      EPSG_4694: {
        towgs84: "0,0,0"
      },
      EPSG_4148: {
        towgs84: "0,0,0"
      },
      EPSG_4163: {
        towgs84: "0,0,0"
      },
      EPSG_4167: {
        towgs84: "0,0,0"
      },
      EPSG_4189: {
        towgs84: "0,0,0"
      },
      EPSG_4190: {
        towgs84: "0,0,0"
      },
      EPSG_4176: {
        towgs84: "0,0,0"
      },
      EPSG_4659: {
        towgs84: "0,0,0"
      },
      EPSG_3824: {
        towgs84: "0,0,0"
      },
      EPSG_3889: {
        towgs84: "0,0,0"
      },
      EPSG_4046: {
        towgs84: "0,0,0"
      },
      EPSG_4081: {
        towgs84: "0,0,0"
      },
      EPSG_4558: {
        towgs84: "0,0,0"
      },
      EPSG_4483: {
        towgs84: "0,0,0"
      },
      EPSG_5013: {
        towgs84: "0,0,0"
      },
      EPSG_5264: {
        towgs84: "0,0,0"
      },
      EPSG_5324: {
        towgs84: "0,0,0"
      },
      EPSG_5354: {
        towgs84: "0,0,0"
      },
      EPSG_5371: {
        towgs84: "0,0,0"
      },
      EPSG_5373: {
        towgs84: "0,0,0"
      },
      EPSG_5381: {
        towgs84: "0,0,0"
      },
      EPSG_5393: {
        towgs84: "0,0,0"
      },
      EPSG_5489: {
        towgs84: "0,0,0"
      },
      EPSG_5593: {
        towgs84: "0,0,0"
      },
      EPSG_6135: {
        towgs84: "0,0,0"
      },
      EPSG_6365: {
        towgs84: "0,0,0"
      },
      EPSG_5246: {
        towgs84: "0,0,0"
      },
      EPSG_7886: {
        towgs84: "0,0,0"
      },
      EPSG_8431: {
        towgs84: "0,0,0"
      },
      EPSG_8427: {
        towgs84: "0,0,0"
      },
      EPSG_8699: {
        towgs84: "0,0,0"
      },
      EPSG_8818: {
        towgs84: "0,0,0"
      },
      EPSG_4757: {
        towgs84: "0,0,0"
      },
      EPSG_9140: {
        towgs84: "0,0,0"
      },
      EPSG_8086: {
        towgs84: "0,0,0"
      },
      EPSG_4686: {
        towgs84: "0,0,0"
      },
      EPSG_4737: {
        towgs84: "0,0,0"
      },
      EPSG_4702: {
        towgs84: "0,0,0"
      },
      EPSG_4747: {
        towgs84: "0,0,0"
      },
      EPSG_4749: {
        towgs84: "0,0,0"
      },
      EPSG_4674: {
        towgs84: "0,0,0"
      },
      EPSG_4755: {
        towgs84: "0,0,0"
      },
      EPSG_4759: {
        towgs84: "0,0,0"
      },
      EPSG_4762: {
        towgs84: "0,0,0"
      },
      EPSG_4763: {
        towgs84: "0,0,0"
      },
      EPSG_4764: {
        towgs84: "0,0,0"
      },
      EPSG_4166: {
        towgs84: "0,0,0"
      },
      EPSG_4170: {
        towgs84: "0,0,0"
      },
      EPSG_5546: {
        towgs84: "0,0,0"
      },
      EPSG_7844: {
        towgs84: "0,0,0"
      },
      EPSG_4818: {
        towgs84: "589,76,480"
      }
    };
    for (key in datums) {
      datum2 = datums[key];
      if (!datum2.datumName) {
        continue;
      }
      datums[datum2.datumName] = datum2;
    }
    Datum_default = datums;
  }
});

// node_modules/proj4/lib/datum.js
function datum(datumCode, datum_params, a5, b8, es2, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a5;
  out.b = b8;
  out.es = es2;
  out.ep2 = ep2;
  return out;
}
var datum_default;
var init_datum = __esm({
  "node_modules/proj4/lib/datum.js"() {
    init_values();
    datum_default = datum;
  }
});

// node_modules/proj4/lib/nadgrid.js
function nadgrid(key, data, options) {
  if (data instanceof ArrayBuffer) {
    return readNTV2Grid(key, data, options);
  }
  return { ready: readGeotiffGrid(key, data) };
}
function readNTV2Grid(key, data, options) {
  var includeErrorFields = true;
  if (options !== void 0 && options.includeErrorFields === false) {
    includeErrorFields = false;
  }
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  var subgrids = readSubgrids(view, header, isLittleEndian, includeErrorFields);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key] = nadgrid2;
  return nadgrid2;
}
async function readGeotiffGrid(key, tiff) {
  var subgrids = [];
  var subGridCount = await tiff.getImageCount();
  for (var subgridIndex = subGridCount - 1; subgridIndex >= 0; subgridIndex--) {
    var image = await tiff.getImage(subgridIndex);
    var rasters = await image.readRasters();
    var data = rasters;
    var lim = [image.getWidth(), image.getHeight()];
    var imageBBoxRadians = image.getBoundingBox().map(degreesToRadians2);
    var del = [image.fileDirectory.ModelPixelScale[0], image.fileDirectory.ModelPixelScale[1]].map(degreesToRadians2);
    var maxX = imageBBoxRadians[0] + (lim[0] - 1) * del[0];
    var minY = imageBBoxRadians[3] - (lim[1] - 1) * del[1];
    var latitudeOffsetBand = data[0];
    var longitudeOffsetBand = data[1];
    var nodes = [];
    for (let i7 = lim[1] - 1; i7 >= 0; i7--) {
      for (let j6 = lim[0] - 1; j6 >= 0; j6--) {
        var index13 = i7 * lim[0] + j6;
        nodes.push([-secondsToRadians(longitudeOffsetBand[index13]), secondsToRadians(latitudeOffsetBand[index13])]);
      }
    }
    subgrids.push({
      del,
      lim,
      ll: [-maxX, minY],
      cvs: nodes
    });
  }
  var tifGrid = {
    header: {
      nSubgrids: subGridCount
    },
    subgrids
  };
  loadedNadgrids[key] = tifGrid;
  return tifGrid;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === "@";
  if (optional) {
    value = value.slice(1);
  }
  if (value === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function degreesToRadians2(degrees) {
  return degrees * Math.PI / 180;
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian, includeErrorFields) {
  var gridOffset = 176;
  var grids = [];
  for (var i7 = 0; i7 < header.nSubgrids; i7++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian, includeErrorFields);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
    );
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
    );
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
    var rowSize = 16;
    if (includeErrorFields === false) {
      rowSize = 8;
    }
    gridOffset += 176 + subHeader.gridNodeCount * rowSize;
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r5) {
    return [secondsToRadians(r5.longitudeShift), secondsToRadians(r5.latitudeShift)];
  });
}
function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset, gridHeader, isLittleEndian, includeErrorFields) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  if (includeErrorFields === false) {
    gridRecordLength = 8;
  }
  var gridShiftRecords = [];
  for (var i7 = 0; i7 < gridHeader.gridNodeCount; i7++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i7 * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i7 * gridRecordLength + 4, isLittleEndian)
    };
    if (includeErrorFields !== false) {
      record.latitudeAccuracy = view.getFloat32(nodesOffset + i7 * gridRecordLength + 8, isLittleEndian);
      record.longitudeAccuracy = view.getFloat32(nodesOffset + i7 * gridRecordLength + 12, isLittleEndian);
    }
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}
var loadedNadgrids;
var init_nadgrid = __esm({
  "node_modules/proj4/lib/nadgrid.js"() {
    loadedNadgrids = {};
  }
});

// node_modules/proj4/lib/Proj.js
function Projection2(srsCode, callback) {
  if (!(this instanceof Projection2)) {
    return new Projection2(srsCode);
  }
  this.forward = null;
  this.inverse = null;
  this.init = null;
  this.name;
  this.names = null;
  this.title;
  callback = callback || function(error2) {
    if (error2) {
      throw error2;
    }
  };
  var json2 = parseCode_default(srsCode);
  if (typeof json2 !== "object") {
    callback("Could not parse to valid json: " + srsCode);
    return;
  }
  var ourProj = Projection2.projections.get(json2.projName);
  if (!ourProj) {
    callback("Could not get projection name from: " + srsCode);
    return;
  }
  if (json2.datumCode && json2.datumCode !== "none") {
    var datumDef = match(Datum_default, json2.datumCode);
    if (datumDef) {
      json2.datum_params = json2.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json2.ellps = datumDef.ellipse;
      json2.datumName = datumDef.datumName ? datumDef.datumName : json2.datumCode;
    }
  }
  json2.k0 = json2.k0 || 1;
  json2.axis = json2.axis || "enu";
  json2.ellps = json2.ellps || "wgs84";
  json2.lat1 = json2.lat1 || json2.lat0;
  var sphere_ = sphere(json2.a, json2.b, json2.rf, json2.ellps, json2.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json2.R_A);
  var nadgrids = getNadgrids(json2.nadgrids);
  var datumObj = json2.datum || datum_default(
    json2.datumCode,
    json2.datum_params,
    sphere_.a,
    sphere_.b,
    ecc.es,
    ecc.ep2,
    nadgrids
  );
  extend_default(this, json2);
  extend_default(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  if ("init" in this && typeof this.init === "function") {
    this.init();
  }
  callback(null, this);
}
var Proj_default;
var init_Proj = __esm({
  "node_modules/proj4/lib/Proj.js"() {
    init_parseCode();
    init_extend();
    init_projections2();
    init_deriveConstants();
    init_Datum();
    init_datum();
    init_match();
    init_nadgrid();
    Projection2.projections = projections_default;
    Projection2.projections.start();
    Proj_default = Projection2;
  }
});

// node_modules/proj4/lib/datumUtils.js
function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false;
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p6, es2, a5) {
  var Longitude = p6.x;
  var Latitude = p6.y;
  var Height = p6.z ? p6.z : 0;
  var Rn2;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p6.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p6.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn2 = a5 / Math.sqrt(1 - es2 * Sin2_Lat);
  return {
    x: (Rn2 + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn2 + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn2 * (1 - es2) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p6, es2, a5, b8) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P8;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X4 = p6.x;
  var Y3 = p6.y;
  var Z5 = p6.z ? p6.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P8 = Math.sqrt(X4 * X4 + Y3 * Y3);
  RR = Math.sqrt(X4 * X4 + Y3 * Y3 + Z5 * Z5);
  if (P8 / a5 < genau) {
    Longitude = 0;
    if (RR / a5 < genau) {
      Latitude = HALF_PI;
      Height = -b8;
      return {
        x: p6.x,
        y: p6.y,
        z: p6.z
      };
    }
  } else {
    Longitude = Math.atan2(Y3, X4);
  }
  CT = Z5 / RR;
  ST = P8 / RR;
  RX = 1 / Math.sqrt(1 - es2 * (2 - es2) * ST * ST);
  CPHI0 = ST * (1 - es2) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a5 / Math.sqrt(1 - es2 * SPHI0 * SPHI0);
    Height = P8 * CPHI0 + Z5 * SPHI0 - RN * (1 - es2 * SPHI0 * SPHI0);
    RK = es2 * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p6, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p6.x + datum_params[0],
      y: p6.y + datum_params[1],
      z: p6.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p6.x - Rz_BF * p6.y + Ry_BF * p6.z) + Dx_BF,
      y: M_BF * (Rz_BF * p6.x + p6.y - Rx_BF * p6.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p6.x + Rx_BF * p6.y + p6.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p6, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p6.x - datum_params[0],
      y: p6.y - datum_params[1],
      z: p6.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p6.x - Dx_BF) / M_BF;
    var y_tmp = (p6.y - Dy_BF) / M_BF;
    var z_tmp = (p6.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}
var init_datumUtils = __esm({
  "node_modules/proj4/lib/datumUtils.js"() {
    "use strict";
    init_values();
  }
});

// node_modules/proj4/lib/datum_transform.js
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform_default(source, dest, point) {
  if (compareDatums(source, dest)) {
    return point;
  }
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }
  point = geodeticToGeocentric(point, source_es, source_a);
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point;
}
function applyGridShift(source, inverse33, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point.x, y: point.y };
  var output = { x: Number.NaN, y: Number.NaN };
  var attemptedGrids = [];
  outer:
    for (var i7 = 0; i7 < source.grids.length; i7++) {
      var grid = source.grids[i7];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrids = grid.grid.subgrids;
      for (var j6 = 0, jj = subgrids.length; j6 < jj; j6++) {
        var subgrid = subgrids[j6];
        var epsilon2 = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
        var minX = subgrid.ll[0] - epsilon2;
        var minY = subgrid.ll[1] - epsilon2;
        var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon2;
        var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon2;
        if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
          continue;
        }
        output = applySubgridShift(input, inverse33, subgrid);
        if (!isNaN(output.x)) {
          break outer;
        }
      }
    }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse33, ct4) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct4.ll[0];
  tb.y -= ct4.ll[1];
  tb.x = adjust_lon_default(tb.x - Math.PI) + Math.PI;
  var t4 = nadInterpolate(tb, ct4);
  if (inverse33) {
    if (isNaN(t4.x)) {
      return val;
    }
    t4.x = tb.x - t4.x;
    t4.y = tb.y - t4.y;
    var i7 = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t4, ct4);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del.x + t4.x), y: tb.y - (del.y + t4.y) };
      t4.x += dif.x;
      t4.y += dif.y;
    } while (i7-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i7 < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon_default(t4.x + ct4.ll[0]);
    val.y = t4.y + ct4.ll[1];
  } else {
    if (!isNaN(t4.x)) {
      val.x = pin.x + t4.x;
      val.y = pin.y + t4.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct4) {
  var t4 = { x: pin.x / ct4.del[0], y: pin.y / ct4.del[1] };
  var indx = { x: Math.floor(t4.x), y: Math.floor(t4.y) };
  var frct = { x: t4.x - 1 * indx.x, y: t4.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct4.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct4.lim[1]) {
    return val;
  }
  inx = indx.y * ct4.lim[0] + indx.x;
  var f00 = { x: ct4.cvs[inx][0], y: ct4.cvs[inx][1] };
  inx++;
  var f10 = { x: ct4.cvs[inx][0], y: ct4.cvs[inx][1] };
  inx += ct4.lim[0];
  var f11 = { x: ct4.cvs[inx][0], y: ct4.cvs[inx][1] };
  inx--;
  var f01 = { x: ct4.cvs[inx][0], y: ct4.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
var init_datum_transform = __esm({
  "node_modules/proj4/lib/datum_transform.js"() {
    init_values();
    init_datumUtils();
    init_adjust_lon();
  }
});

// node_modules/proj4/lib/adjust_axis.js
function adjust_axis_default(crs, denorm, point) {
  var xin = point.x, yin = point.y, zin = point.z || 0;
  var v5, t4, i7;
  var out = {};
  for (i7 = 0; i7 < 3; i7++) {
    if (denorm && i7 === 2 && point.z === void 0) {
      continue;
    }
    if (i7 === 0) {
      v5 = xin;
      if ("ew".indexOf(crs.axis[i7]) !== -1) {
        t4 = "x";
      } else {
        t4 = "y";
      }
    } else if (i7 === 1) {
      v5 = yin;
      if ("ns".indexOf(crs.axis[i7]) !== -1) {
        t4 = "y";
      } else {
        t4 = "x";
      }
    } else {
      v5 = zin;
      t4 = "z";
    }
    switch (crs.axis[i7]) {
      case "e":
        out[t4] = v5;
        break;
      case "w":
        out[t4] = -v5;
        break;
      case "n":
        out[t4] = v5;
        break;
      case "s":
        out[t4] = -v5;
        break;
      case "u":
        if (point[t4] !== void 0) {
          out.z = v5;
        }
        break;
      case "d":
        if (point[t4] !== void 0) {
          out.z = -v5;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}
var init_adjust_axis = __esm({
  "node_modules/proj4/lib/adjust_axis.js"() {
  }
});

// node_modules/proj4/lib/common/toPoint.js
function toPoint_default(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}
var init_toPoint = __esm({
  "node_modules/proj4/lib/common/toPoint.js"() {
  }
});

// node_modules/proj4/lib/checkSanity.js
function checkSanity_default(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}
var init_checkSanity = __esm({
  "node_modules/proj4/lib/checkSanity.js"() {
  }
});

// node_modules/proj4/lib/transform.js
function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== "WGS84";
}
function transform2(source, dest, point, enforceAxis) {
  var wgs842;
  if (Array.isArray(point)) {
    point = toPoint_default(point);
  } else {
    point = {
      x: point.x,
      y: point.y,
      z: point.z,
      m: point.m
    };
  }
  var hasZ = point.z !== void 0;
  checkSanity_default(point);
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs842 = new Proj_default("WGS84");
    point = transform2(source, wgs842, point, enforceAxis);
    source = wgs842;
  }
  if (enforceAxis && source.axis !== "enu") {
    point = adjust_axis_default(source, false, point);
  }
  if (source.projName === "longlat") {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point);
    if (!point) {
      return;
    }
  }
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }
  point = datum_transform_default(source.datum, dest.datum, point);
  if (!point) {
    return;
  }
  point = /** @type {import('./core').InterfaceCoordinates} */
  point;
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis_default(dest, true, point);
  }
  if (point && !hasZ) {
    delete point.z;
  }
  return point;
}
var init_transform3 = __esm({
  "node_modules/proj4/lib/transform.js"() {
    init_values();
    init_datum_transform();
    init_adjust_axis();
    init_Proj();
    init_toPoint();
    init_checkSanity();
  }
});

// node_modules/proj4/lib/core.js
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform2(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return (
            /** @type {T} */
            [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.slice(3))
          );
        } else {
          return (
            /** @type {T} */
            [transformedArray.x, transformedArray.y, coords[2]].concat(coords.slice(3))
          );
        }
      } else {
        return (
          /** @type {T} */
          [transformedArray.x, transformedArray.y].concat(coords.slice(2))
        );
      }
    } else {
      return (
        /** @type {T} */
        [transformedArray.x, transformedArray.y]
      );
    }
  } else {
    out = transform2(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return (
        /** @type {T} */
        out
      );
    }
    keys.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return (
      /** @type {T} */
      out
    );
  }
}
function checkProj(item) {
  if (item instanceof Proj_default) {
    return item;
  }
  if (typeof item === "object" && "oProj" in item) {
    return item.oProj;
  }
  return Proj_default(
    /** @type {string | PROJJSONDefinition} */
    item
  );
}
function proj4(fromProjOrToProj, toProjOrCoord, coord) {
  var fromProj;
  var toProj;
  var single = false;
  var obj;
  if (typeof toProjOrCoord === "undefined") {
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  } else if (typeof /** @type {?} */
  toProjOrCoord.x !== "undefined" || Array.isArray(toProjOrCoord)) {
    coord = /** @type {T} */
    /** @type {?} */
    toProjOrCoord;
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  }
  if (!fromProj) {
    fromProj = checkProj(fromProjOrToProj);
  }
  if (!toProj) {
    toProj = checkProj(
      /** @type {string | PROJJSONDefinition | proj } */
      toProjOrCoord
    );
  }
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var wgs84, core_default;
var init_core = __esm({
  "node_modules/proj4/lib/core.js"() {
    init_Proj();
    init_transform3();
    wgs84 = Proj_default("WGS84");
    core_default = proj4;
  }
});

// node_modules/mgrs/mgrs.js
function forward2(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse2(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
function toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a5 = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N5, T4, C6, A13, M9;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N5 = a5 / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T4 = Math.tan(LatRad) * Math.tan(LatRad);
  C6 = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A13 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M9 = a5 * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N5 * (A13 + (1 - T4 + C6) * A13 * A13 * A13 / 6 + (5 - 18 * T4 + T4 * T4 + 72 * C6 - 58 * eccPrimeSquared) * A13 * A13 * A13 * A13 * A13 / 120) + 5e5;
  var UTMNorthing = k0 * (M9 + N5 * Math.tan(LatRad) * (A13 * A13 / 2 + (5 - T4 + 9 * C6 + 4 * C6 * C6) * A13 * A13 * A13 * A13 / 24 + (61 - 58 * T4 + T4 * T4 + 600 * C6 - 330 * eccPrimeSquared) * A13 * A13 * A13 * A13 * A13 * A13 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm) {
  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a5 = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C13, R1, D7, M9;
  var LongOrigin;
  var mu, phi1Rad;
  var x4 = UTMEasting - 5e5;
  var y5 = UTMNorthing;
  if (zoneLetter < "N") {
    y5 -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M9 = y5 / k0;
  mu = M9 / (a5 * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a5 / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C13 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a5 * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D7 = x4 / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D7 * D7 / 2 - (5 + 3 * T1 + 10 * C13 - 4 * C13 * C13 - 9 * eccPrimeSquared) * D7 * D7 * D7 * D7 / 24 + (61 + 90 * T1 + 298 * C13 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C13 * C13) * D7 * D7 * D7 * D7 * D7 * D7 / 720);
  lat = radToDeg(lat);
  var lon = (D7 - (1 + 2 * T1 + C13) * D7 * D7 * D7 / 6 + (5 - 2 * C13 + 28 * T1 - 3 * C13 * C13 + 8 * eccPrimeSquared + 24 * T1 * T1) * D7 * D7 * D7 * D7 * D7 / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat,
      lon
    };
  }
  return result;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode(utm, accuracy) {
  var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i7) {
  var setParm = i7 % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index13 = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index13);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index13);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z3) {
    colInt = colInt - Z3 + A5 - 1;
    rollover = true;
  }
  if (colInt === I4 || colOrigin < I4 && colInt > I4 || (colInt > I4 || colOrigin < I4) && rollover) {
    colInt++;
  }
  if (colInt === O4 || colOrigin < O4 && colInt > O4 || (colInt > O4 || colOrigin < O4) && rollover) {
    colInt++;
    if (colInt === I4) {
      colInt++;
    }
  }
  if (colInt > Z3) {
    colInt = colInt - Z3 + A5 - 1;
  }
  if (rowInt > V2) {
    rowInt = rowInt - V2 + A5 - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I4 || rowOrigin < I4 && rowInt > I4 || (rowInt > I4 || rowOrigin < I4) && rollover) {
    rowInt++;
  }
  if (rowInt === O4 || rowOrigin < O4 && rowInt > O4 || (rowInt > O4 || rowOrigin < O4) && rollover) {
    rowInt++;
    if (rowInt === I4) {
      rowInt++;
    }
  }
  if (rowInt > V2) {
    rowInt = rowInt - V2 + A5 - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i7 = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i7))) {
    if (i7 >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i7++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i7 === 0 || i7 + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i7++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i7, i7 += 2);
  var set = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i7;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i7, i7 + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i7 + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e3, set) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e3.charCodeAt(0)) {
    curCol++;
    if (curCol === I4) {
      curCol++;
    }
    if (curCol === O4) {
      curCol++;
    }
    if (curCol > Z3) {
      if (rewindMarker) {
        throw "Bad character: " + e3;
      }
      curCol = A5;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n6, set) {
  if (n6 > "V") {
    throw "MGRSPoint given invalid Northing " + n6;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n6.charCodeAt(0)) {
    curRow++;
    if (curRow === I4) {
      curRow++;
    }
    if (curRow === O4) {
      curRow++;
    }
    if (curRow > V2) {
      if (rewindMarker) {
        throw "Bad character: " + n6;
      }
      curRow = A5;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
var NUM_100K_SETS, SET_ORIGIN_COLUMN_LETTERS, SET_ORIGIN_ROW_LETTERS, A5, I4, O4, V2, Z3, mgrs_default;
var init_mgrs = __esm({
  "node_modules/mgrs/mgrs.js"() {
    NUM_100K_SETS = 6;
    SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
    SET_ORIGIN_ROW_LETTERS = "AFAFAF";
    A5 = 65;
    I4 = 73;
    O4 = 79;
    V2 = 86;
    Z3 = 90;
    mgrs_default = {
      forward: forward2,
      inverse: inverse2,
      toPoint
    };
  }
});

// node_modules/proj4/lib/Point.js
function Point2(x4, y5, z3) {
  if (!(this instanceof Point2)) {
    return new Point2(x4, y5, z3);
  }
  if (Array.isArray(x4)) {
    this.x = x4[0];
    this.y = x4[1];
    this.z = x4[2] || 0;
  } else if (typeof x4 === "object") {
    this.x = x4.x;
    this.y = x4.y;
    this.z = x4.z || 0;
  } else if (typeof x4 === "string" && typeof y5 === "undefined") {
    var coords = x4.split(",");
    this.x = parseFloat(coords[0]);
    this.y = parseFloat(coords[1]);
    this.z = parseFloat(coords[2]) || 0;
  } else {
    this.x = x4;
    this.y = y5;
    this.z = z3 || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
var Point_default2;
var init_Point2 = __esm({
  "node_modules/proj4/lib/Point.js"() {
    init_mgrs();
    Point2.fromMGRS = function(mgrsStr) {
      return new Point2(toPoint(mgrsStr));
    };
    Point2.prototype.toMGRS = function(accuracy) {
      return forward2([this.x, this.y], accuracy);
    };
    Point_default2 = Point2;
  }
});

// node_modules/proj4/lib/common/pj_enfn.js
function pj_enfn_default(es2) {
  var en3 = [];
  en3[0] = C00 - es2 * (C02 + es2 * (C04 + es2 * (C06 + es2 * C08)));
  en3[1] = es2 * (C22 - es2 * (C04 + es2 * (C06 + es2 * C08)));
  var t4 = es2 * es2;
  en3[2] = t4 * (C44 - es2 * (C46 + es2 * C48));
  t4 *= es2;
  en3[3] = t4 * (C66 - es2 * C68);
  en3[4] = t4 * es2 * C88;
  return en3;
}
var C00, C02, C04, C06, C08, C22, C44, C46, C48, C66, C68, C88;
var init_pj_enfn = __esm({
  "node_modules/proj4/lib/common/pj_enfn.js"() {
    C00 = 1;
    C02 = 0.25;
    C04 = 0.046875;
    C06 = 0.01953125;
    C08 = 0.01068115234375;
    C22 = 0.75;
    C44 = 0.46875;
    C46 = 0.013020833333333334;
    C48 = 0.007120768229166667;
    C66 = 0.3645833333333333;
    C68 = 0.005696614583333333;
    C88 = 0.3076171875;
  }
});

// node_modules/proj4/lib/common/pj_mlfn.js
function pj_mlfn_default(phi, sphi, cphi, en3) {
  cphi *= sphi;
  sphi *= sphi;
  return en3[0] * phi - cphi * (en3[1] + sphi * (en3[2] + sphi * (en3[3] + sphi * en3[4])));
}
var init_pj_mlfn = __esm({
  "node_modules/proj4/lib/common/pj_mlfn.js"() {
  }
});

// node_modules/proj4/lib/common/pj_inv_mlfn.js
function pj_inv_mlfn_default(arg, es2, en3) {
  var k5 = 1 / (1 - es2);
  var phi = arg;
  for (var i7 = MAX_ITER; i7; --i7) {
    var s5 = Math.sin(phi);
    var t4 = 1 - es2 * s5 * s5;
    t4 = (pj_mlfn_default(phi, s5, Math.cos(phi), en3) - arg) * (t4 * Math.sqrt(t4)) * k5;
    phi -= t4;
    if (Math.abs(t4) < EPSLN) {
      return phi;
    }
  }
  return phi;
}
var MAX_ITER;
var init_pj_inv_mlfn = __esm({
  "node_modules/proj4/lib/common/pj_inv_mlfn.js"() {
    init_pj_mlfn();
    init_values();
    MAX_ITER = 20;
  }
});

// node_modules/proj4/lib/projections/tmerc.js
function init3() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.ml0 = pj_mlfn_default(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward3(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var con;
  var x4, y5;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b8 = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b8) - 1) < EPSLN) {
      return 93;
    } else {
      x4 = 0.5 * this.a * this.k0 * Math.log((1 + b8) / (1 - b8)) + this.x0;
      y5 = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b8, 2));
      b8 = Math.abs(y5);
      if (b8 >= 1) {
        if (b8 - 1 > EPSLN) {
          return 93;
        } else {
          y5 = 0;
        }
      } else {
        y5 = Math.acos(y5);
      }
      if (lat < 0) {
        y5 = -y5;
      }
      y5 = this.a * this.k0 * (y5 - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als2 = Math.pow(al, 2);
    var c7 = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c7, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t4 = Math.pow(tq, 2);
    var ts2 = Math.pow(t4, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn_default(lat, sin_phi, cos_phi, this.en);
    x4 = this.a * (this.k0 * al * (1 + als2 / 6 * (1 - t4 + c7 + als2 / 20 * (5 - 18 * t4 + ts2 + 14 * c7 - 58 * t4 * c7 + als2 / 42 * (61 + 179 * ts2 - ts2 * t4 - 479 * t4))))) + this.x0;
    y5 = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als2 / 12 * (5 - t4 + 9 * c7 + 4 * cs + als2 / 30 * (61 + ts2 - 58 * t4 + 270 * c7 - 330 * t4 * c7 + als2 / 56 * (1385 + 543 * ts2 - ts2 * t4 - 3111 * t4)))))) + this.y0;
  }
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse3(p6) {
  var con, phi;
  var lat, lon;
  var x4 = (p6.x - this.x0) * (1 / this.a);
  var y5 = (p6.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f8 = Math.exp(x4 / this.k0);
    var g5 = 0.5 * (f8 - 1 / f8);
    var temp = this.lat0 + y5 / this.k0;
    var h5 = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h5, 2)) / (1 + Math.pow(g5, 2)));
    lat = Math.asin(con);
    if (y5 < 0) {
      lat = -lat;
    }
    if (g5 === 0 && h5 === 0) {
      lon = 0;
    } else {
      lon = adjust_lon_default(Math.atan2(g5, h5) + this.long0);
    }
  } else {
    con = this.ml0 + y5 / this.k0;
    phi = pj_inv_mlfn_default(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c7 = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c7, 2);
      var t4 = Math.pow(tan_phi, 2);
      var ts2 = Math.pow(t4, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d2 = x4 * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d2, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t4 - 9 * c7 * t4 + c7 - 4 * cs - ds / 30 * (61 + 90 * t4 - 252 * c7 * t4 + 45 * ts2 + 46 * c7 - ds / 56 * (1385 + 3633 * t4 + 4095 * ts2 + 1574 * ts2 * t4))));
      lon = adjust_lon_default(this.long0 + d2 * (1 - ds / 6 * (1 + 2 * t4 + c7 - ds / 20 * (5 + 28 * t4 + 24 * ts2 + 8 * c7 * t4 + 6 * c7 - ds / 42 * (61 + 662 * t4 + 1320 * ts2 + 720 * ts2 * t4)))) / cos_phi);
    } else {
      lat = HALF_PI * sign_default(y5);
      lon = 0;
    }
  }
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names4, tmerc_default;
var init_tmerc = __esm({
  "node_modules/proj4/lib/projections/tmerc.js"() {
    init_pj_enfn();
    init_pj_mlfn();
    init_pj_inv_mlfn();
    init_adjust_lon();
    init_values();
    init_sign();
    names4 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
    tmerc_default = {
      init: init3,
      forward: forward3,
      inverse: inverse3,
      names: names4
    };
  }
});

// node_modules/proj4/lib/common/sinh.js
function sinh_default(x4) {
  var r5 = Math.exp(x4);
  r5 = (r5 - 1 / r5) / 2;
  return r5;
}
var init_sinh = __esm({
  "node_modules/proj4/lib/common/sinh.js"() {
  }
});

// node_modules/proj4/lib/common/hypot.js
function hypot_default(x4, y5) {
  x4 = Math.abs(x4);
  y5 = Math.abs(y5);
  var a5 = Math.max(x4, y5);
  var b8 = Math.min(x4, y5) / (a5 ? a5 : 1);
  return a5 * Math.sqrt(1 + Math.pow(b8, 2));
}
var init_hypot = __esm({
  "node_modules/proj4/lib/common/hypot.js"() {
  }
});

// node_modules/proj4/lib/common/log1py.js
function log1py_default(x4) {
  var y5 = 1 + x4;
  var z3 = y5 - 1;
  return z3 === 0 ? x4 : x4 * Math.log(y5) / z3;
}
var init_log1py = __esm({
  "node_modules/proj4/lib/common/log1py.js"() {
  }
});

// node_modules/proj4/lib/common/asinhy.js
function asinhy_default(x4) {
  var y5 = Math.abs(x4);
  y5 = log1py_default(y5 * (1 + y5 / (hypot_default(1, y5) + 1)));
  return x4 < 0 ? -y5 : y5;
}
var init_asinhy = __esm({
  "node_modules/proj4/lib/common/asinhy.js"() {
    init_hypot();
    init_log1py();
  }
});

// node_modules/proj4/lib/common/gatg.js
function gatg_default(pp, B5) {
  var cos_2B = 2 * Math.cos(2 * B5);
  var i7 = pp.length - 1;
  var h1 = pp[i7];
  var h22 = 0;
  var h5;
  while (--i7 >= 0) {
    h5 = -h22 + cos_2B * h1 + pp[i7];
    h22 = h1;
    h1 = h5;
  }
  return B5 + h5 * Math.sin(2 * B5);
}
var init_gatg = __esm({
  "node_modules/proj4/lib/common/gatg.js"() {
  }
});

// node_modules/proj4/lib/common/clens.js
function clens_default(pp, arg_r) {
  var r5 = 2 * Math.cos(arg_r);
  var i7 = pp.length - 1;
  var hr1 = pp[i7];
  var hr2 = 0;
  var hr3;
  while (--i7 >= 0) {
    hr3 = -hr2 + r5 * hr1 + pp[i7];
    hr2 = hr1;
    hr1 = hr3;
  }
  return Math.sin(arg_r) * hr3;
}
var init_clens = __esm({
  "node_modules/proj4/lib/common/clens.js"() {
  }
});

// node_modules/proj4/lib/common/cosh.js
function cosh_default(x4) {
  var r5 = Math.exp(x4);
  r5 = (r5 + 1 / r5) / 2;
  return r5;
}
var init_cosh = __esm({
  "node_modules/proj4/lib/common/cosh.js"() {
  }
});

// node_modules/proj4/lib/common/clens_cmplx.js
function clens_cmplx_default(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh_default(arg_i);
  var cosh_arg_i = cosh_default(arg_i);
  var r5 = 2 * cos_arg_r * cosh_arg_i;
  var i7 = -2 * sin_arg_r * sinh_arg_i;
  var j6 = pp.length - 1;
  var hr2 = pp[j6];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr22;
  var hi2;
  while (--j6 >= 0) {
    hr22 = hr1;
    hi2 = hi1;
    hr1 = hr2;
    hi1 = hi;
    hr2 = -hr22 + r5 * hr1 - i7 * hi1 + pp[j6];
    hi = -hi2 + i7 * hr1 + r5 * hi1;
  }
  r5 = sin_arg_r * cosh_arg_i;
  i7 = cos_arg_r * sinh_arg_i;
  return [r5 * hr2 - i7 * hi, r5 * hi + i7 * hr2];
}
var init_clens_cmplx = __esm({
  "node_modules/proj4/lib/common/clens_cmplx.js"() {
    init_sinh();
    init_cosh();
  }
});

// node_modules/proj4/lib/projections/etmerc.js
function init4() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc_default.init.apply(this);
    this.forward = tmerc_default.forward;
    this.inverse = tmerc_default.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f8 = this.es / (1 + Math.sqrt(1 - this.es));
  var n6 = f8 / (2 - f8);
  var np = n6;
  this.cgb[0] = n6 * (2 + n6 * (-2 / 3 + n6 * (-2 + n6 * (116 / 45 + n6 * (26 / 45 + n6 * (-2854 / 675))))));
  this.cbg[0] = n6 * (-2 + n6 * (2 / 3 + n6 * (4 / 3 + n6 * (-82 / 45 + n6 * (32 / 45 + n6 * (4642 / 4725))))));
  np = np * n6;
  this.cgb[1] = np * (7 / 3 + n6 * (-8 / 5 + n6 * (-227 / 45 + n6 * (2704 / 315 + n6 * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n6 * (-16 / 15 + n6 * (-13 / 9 + n6 * (904 / 315 + n6 * (-1522 / 945)))));
  np = np * n6;
  this.cgb[2] = np * (56 / 15 + n6 * (-136 / 35 + n6 * (-1262 / 105 + n6 * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n6 * (34 / 21 + n6 * (8 / 5 + n6 * (-12686 / 2835))));
  np = np * n6;
  this.cgb[3] = np * (4279 / 630 + n6 * (-332 / 35 + n6 * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n6 * (-12 / 5 + n6 * (-24832 / 14175)));
  np = np * n6;
  this.cgb[4] = np * (4174 / 315 + n6 * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n6 * (109598 / 31185));
  np = np * n6;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n6, 2);
  this.Qn = this.k0 / (1 + n6) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n6 * (-0.5 + n6 * (2 / 3 + n6 * (-37 / 96 + n6 * (1 / 360 + n6 * (81 / 512 + n6 * (-96199 / 604800))))));
  this.gtu[0] = n6 * (0.5 + n6 * (-2 / 3 + n6 * (5 / 16 + n6 * (41 / 180 + n6 * (-127 / 288 + n6 * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n6 * (-1 / 15 + n6 * (437 / 1440 + n6 * (-46 / 105 + n6 * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n6 * (-3 / 5 + n6 * (557 / 1440 + n6 * (281 / 630 + n6 * (-1983433 / 1935360)))));
  np = np * n6;
  this.utg[2] = np * (-17 / 480 + n6 * (37 / 840 + n6 * (209 / 4480 + n6 * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n6 * (-103 / 140 + n6 * (15061 / 26880 + n6 * (167603 / 181440))));
  np = np * n6;
  this.utg[3] = np * (-4397 / 161280 + n6 * (11 / 504 + n6 * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n6 * (-179 / 168 + n6 * (6601661 / 7257600)));
  np = np * n6;
  this.utg[4] = np * (-4583 / 161280 + n6 * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n6 * (-3418889 / 1995840));
  np = np * n6;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z5 = gatg_default(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z5 + clens_default(this.gtu, 2 * Z5));
}
function forward4(p6) {
  var Ce3 = adjust_lon_default(p6.x - this.long0);
  var Cn2 = p6.y;
  Cn2 = gatg_default(this.cbg, Cn2);
  var sin_Cn = Math.sin(Cn2);
  var cos_Cn = Math.cos(Cn2);
  var sin_Ce = Math.sin(Ce3);
  var cos_Ce = Math.cos(Ce3);
  Cn2 = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce3 = Math.atan2(sin_Ce * cos_Cn, hypot_default(sin_Cn, cos_Cn * cos_Ce));
  Ce3 = asinhy_default(Math.tan(Ce3));
  var tmp = clens_cmplx_default(this.gtu, 2 * Cn2, 2 * Ce3);
  Cn2 = Cn2 + tmp[0];
  Ce3 = Ce3 + tmp[1];
  var x4;
  var y5;
  if (Math.abs(Ce3) <= 2.623395162778) {
    x4 = this.a * (this.Qn * Ce3) + this.x0;
    y5 = this.a * (this.Qn * Cn2 + this.Zb) + this.y0;
  } else {
    x4 = Infinity;
    y5 = Infinity;
  }
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse4(p6) {
  var Ce3 = (p6.x - this.x0) * (1 / this.a);
  var Cn2 = (p6.y - this.y0) * (1 / this.a);
  Cn2 = (Cn2 - this.Zb) / this.Qn;
  Ce3 = Ce3 / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce3) <= 2.623395162778) {
    var tmp = clens_cmplx_default(this.utg, 2 * Cn2, 2 * Ce3);
    Cn2 = Cn2 + tmp[0];
    Ce3 = Ce3 + tmp[1];
    Ce3 = Math.atan(sinh_default(Ce3));
    var sin_Cn = Math.sin(Cn2);
    var cos_Cn = Math.cos(Cn2);
    var sin_Ce = Math.sin(Ce3);
    var cos_Ce = Math.cos(Ce3);
    Cn2 = Math.atan2(sin_Cn * cos_Ce, hypot_default(sin_Ce, cos_Ce * cos_Cn));
    Ce3 = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon_default(Ce3 + this.long0);
    lat = gatg_default(this.cgb, Cn2);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names5, etmerc_default;
var init_etmerc = __esm({
  "node_modules/proj4/lib/projections/etmerc.js"() {
    init_tmerc();
    init_sinh();
    init_hypot();
    init_asinhy();
    init_gatg();
    init_clens();
    init_clens_cmplx();
    init_adjust_lon();
    names5 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
    etmerc_default = {
      init: init4,
      forward: forward4,
      inverse: inverse4,
      names: names5
    };
  }
});

// node_modules/proj4/lib/common/adjust_zone.js
function adjust_zone_default(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon_default(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}
var init_adjust_zone = __esm({
  "node_modules/proj4/lib/common/adjust_zone.js"() {
    init_adjust_lon();
  }
});

// node_modules/proj4/lib/projections/utm.js
function init5() {
  var zone = adjust_zone_default(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc_default.init.apply(this);
  this.forward = etmerc_default.forward;
  this.inverse = etmerc_default.inverse;
}
var dependsOn, names6, utm_default;
var init_utm2 = __esm({
  "node_modules/proj4/lib/projections/utm.js"() {
    init_adjust_zone();
    init_etmerc();
    init_values();
    dependsOn = "etmerc";
    names6 = ["Universal Transverse Mercator System", "utm"];
    utm_default = {
      init: init5,
      names: names6,
      dependsOn
    };
  }
});

// node_modules/proj4/lib/common/srat.js
function srat_default(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
var init_srat = __esm({
  "node_modules/proj4/lib/common/srat.js"() {
  }
});

// node_modules/proj4/lib/projections/gauss.js
function init6() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat_default(this.e * sphi, this.ratexp));
}
function forward5(p6) {
  var lon = p6.x;
  var lat = p6.y;
  p6.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat_default(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p6.x = this.C * lon;
  return p6;
}
function inverse5(p6) {
  var DEL_TOL = 1e-14;
  var lon = p6.x / this.C;
  var lat = p6.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i7 = MAX_ITER2; i7 > 0; --i7) {
    lat = 2 * Math.atan(num * srat_default(this.e * Math.sin(p6.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p6.y) < DEL_TOL) {
      break;
    }
    p6.y = lat;
  }
  if (!i7) {
    return null;
  }
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var MAX_ITER2, names7, gauss_default;
var init_gauss = __esm({
  "node_modules/proj4/lib/projections/gauss.js"() {
    init_srat();
    init_values();
    MAX_ITER2 = 20;
    names7 = ["gauss"];
    gauss_default = {
      init: init6,
      forward: forward5,
      inverse: inverse5,
      names: names7
    };
  }
});

// node_modules/proj4/lib/projections/sterea.js
function init7() {
  gauss_default.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward6(p6) {
  var sinc, cosc, cosl, k5;
  p6.x = adjust_lon_default(p6.x - this.long0);
  gauss_default.forward.apply(this, [p6]);
  sinc = Math.sin(p6.y);
  cosc = Math.cos(p6.y);
  cosl = Math.cos(p6.x);
  k5 = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p6.x = k5 * cosc * Math.sin(p6.x);
  p6.y = k5 * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p6.x = this.a * p6.x + this.x0;
  p6.y = this.a * p6.y + this.y0;
  return p6;
}
function inverse6(p6) {
  var sinc, cosc, lon, lat, rho;
  p6.x = (p6.x - this.x0) / this.a;
  p6.y = (p6.y - this.y0) / this.a;
  p6.x /= this.k0;
  p6.y /= this.k0;
  if (rho = hypot_default(p6.x, p6.y)) {
    var c7 = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c7);
    cosc = Math.cos(c7);
    lat = Math.asin(cosc * this.sinc0 + p6.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p6.x * sinc, rho * this.cosc0 * cosc - p6.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p6.x = lon;
  p6.y = lat;
  gauss_default.inverse.apply(this, [p6]);
  p6.x = adjust_lon_default(p6.x + this.long0);
  return p6;
}
var names8, sterea_default;
var init_sterea = __esm({
  "node_modules/proj4/lib/projections/sterea.js"() {
    init_gauss();
    init_adjust_lon();
    init_hypot();
    names8 = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
    sterea_default = {
      init: init7,
      forward: forward6,
      inverse: inverse6,
      names: names8
    };
  }
});

// node_modules/proj4/lib/projections/stere.js
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init8() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign_default(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && Math.abs(Math.cos(this.lat_ts)) > EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz_default(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz_default(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward7(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A13, X4, sinX, cosX, ts2, rh;
  var dlon = adjust_lon_default(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p6.x = NaN;
    p6.y = NaN;
    return p6;
  }
  if (this.sphere) {
    A13 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p6.x = this.a * A13 * coslat * Math.sin(dlon) + this.x0;
    p6.y = this.a * A13 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p6;
  } else {
    X4 = 2 * Math.atan(ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X4);
    sinX = Math.sin(X4);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts2 = tsfnz_default(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts2 / this.cons;
      p6.x = this.x0 + rh * Math.sin(lon - this.long0);
      p6.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p6;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A13 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p6.y = A13 * sinX;
    } else {
      A13 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p6.y = A13 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p6.x = A13 * cosX * Math.sin(dlon) + this.x0;
  }
  return p6;
}
function inverse7(p6) {
  p6.x -= this.x0;
  p6.y -= this.y0;
  var lon, lat, ts2, ce3, Chi;
  var rh = Math.sqrt(p6.x * p6.x + p6.y * p6.y);
  if (this.sphere) {
    var c7 = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p6.x = lon;
      p6.y = lat;
      return p6;
    }
    lat = Math.asin(Math.cos(c7) * this.sinlat0 + p6.y * Math.sin(c7) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon_default(this.long0 + Math.atan2(p6.x, -1 * p6.y));
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p6.x, p6.y));
      }
    } else {
      lon = adjust_lon_default(this.long0 + Math.atan2(p6.x * Math.sin(c7), rh * this.coslat0 * Math.cos(c7) - p6.y * this.sinlat0 * Math.sin(c7)));
    }
    p6.x = lon;
    p6.y = lat;
    return p6;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p6.x = lon;
        p6.y = lat;
        return p6;
      }
      p6.x *= this.con;
      p6.y *= this.con;
      ts2 = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z_default(this.e, ts2);
      lon = this.con * adjust_lon_default(this.con * this.long0 + Math.atan2(p6.x, -1 * p6.y));
    } else {
      ce3 = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce3) * this.sinX0 + p6.y * Math.sin(ce3) * this.cosX0 / rh);
        lon = adjust_lon_default(this.long0 + Math.atan2(p6.x * Math.sin(ce3), rh * this.cosX0 * Math.cos(ce3) - p6.y * this.sinX0 * Math.sin(ce3)));
      }
      lat = -1 * phi2z_default(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names9, stere_default;
var init_stere = __esm({
  "node_modules/proj4/lib/projections/stere.js"() {
    init_values();
    init_sign();
    init_msfnz();
    init_tsfnz();
    init_phi2z();
    init_adjust_lon();
    names9 = ["stere", "Stereographic_South_Pole", "Polar_Stereographic_variant_A", "Polar_Stereographic_variant_B", "Polar_Stereographic"];
    stere_default = {
      init: init8,
      forward: forward7,
      inverse: inverse7,
      names: names9,
      ssfn_
    };
  }
});

// node_modules/proj4/lib/projections/somerc.js
function init9() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e23 = 2 * flattening - Math.pow(flattening, 2);
  var e3 = this.e = Math.sqrt(e23);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e23) / (1 - e23 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e23 / (1 - e23) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k22 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k32 = Math.log((1 + e3 * sinPhy0) / (1 - e3 * sinPhy0));
  this.K = k1 - this.alpha * k22 + this.alpha * e3 / 2 * k32;
}
function forward8(p6) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p6.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p6.y)) / (1 - this.e * Math.sin(p6.y)));
  var S5 = -this.alpha * (Sa1 + Sa2) + this.K;
  var b8 = 2 * (Math.atan(Math.exp(S5)) - Math.PI / 4);
  var I9 = this.alpha * (p6.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I9) / (Math.sin(this.b0) * Math.tan(b8) + Math.cos(this.b0) * Math.cos(I9)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b8) - Math.sin(this.b0) * Math.cos(b8) * Math.cos(I9));
  p6.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p6.x = this.R * rotI + this.x0;
  return p6;
}
function inverse8(p6) {
  var Y3 = p6.x - this.x0;
  var X4 = p6.y - this.y0;
  var rotI = Y3 / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X4 / this.R)) - Math.PI / 4);
  var b8 = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I9 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I9 / this.alpha;
  var S5 = 0;
  var phy = b8;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S5 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b8 / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S5)) - Math.PI / 2;
  }
  p6.x = lambda;
  p6.y = phy;
  return p6;
}
var names10, somerc_default;
var init_somerc = __esm({
  "node_modules/proj4/lib/projections/somerc.js"() {
    names10 = ["somerc"];
    somerc_default = {
      init: init9,
      forward: forward8,
      inverse: inverse8,
      names: names10
    };
  }
});

// node_modules/proj4/lib/projections/omerc.js
function isTypeA(P8) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P8.projName === "object" ? Object.keys(P8.projName)[0] : P8.projName;
  return "no_uoff" in P8 || "no_off" in P8 || typeAProjections.indexOf(projectionName) !== -1 || typeAProjections.indexOf(getNormalizedProjName(projectionName)) !== -1;
}
function init10() {
  var con, com, cosph0, D7, F5, H6, L4, sinph0, p6, J4, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D7 = this.B * com / (cosph0 * Math.sqrt(con));
    F5 = D7 * D7 - 1;
    if (F5 <= 0) {
      F5 = 0;
    } else {
      F5 = Math.sqrt(F5);
      if (this.lat0 < 0) {
        F5 = -F5;
      }
    }
    this.E = F5 += D7;
    this.E *= Math.pow(tsfnz_default(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D7 = F5 = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D7);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D7 * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F5 - 1 / F5) * Math.tan(gamma0)) / this.B;
  } else {
    H6 = Math.pow(tsfnz_default(this.e, phi1, Math.sin(phi1)), this.B);
    L4 = Math.pow(tsfnz_default(this.e, phi2, Math.sin(phi2)), this.B);
    F5 = this.E / H6;
    p6 = (L4 - H6) / (L4 + H6);
    J4 = this.E * this.E;
    J4 = (J4 - L4 * H6) / (J4 + L4 * H6);
    con = lam1 - lam2;
    if (con < -Math.PI) {
      lam2 -= TWO_PI;
    } else if (con > Math.PI) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon_default(0.5 * (lam1 + lam2) - Math.atan(J4 * Math.tan(0.5 * this.B * (lam1 - lam2)) / p6) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon_default(lam1 - this.lam0)) / (F5 - 1 / F5));
    gamma = alpha_c = Math.asin(D7 * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D7 * D7 - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F5 = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F5));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F5));
}
function forward9(p6) {
  var coords = {};
  var S5, T4, U4, V4, W2, temp, u8, v5;
  p6.x = p6.x - this.lam0;
  if (Math.abs(Math.abs(p6.y) - HALF_PI) > EPSLN) {
    W2 = this.E / Math.pow(tsfnz_default(this.e, p6.y, Math.sin(p6.y)), this.B);
    temp = 1 / W2;
    S5 = 0.5 * (W2 - temp);
    T4 = 0.5 * (W2 + temp);
    V4 = Math.sin(this.B * p6.x);
    U4 = (S5 * this.singam - V4 * this.cosgam) / T4;
    if (Math.abs(Math.abs(U4) - 1) < EPSLN) {
      throw new Error();
    }
    v5 = 0.5 * this.ArB * Math.log((1 - U4) / (1 + U4));
    temp = Math.cos(this.B * p6.x);
    if (Math.abs(temp) < TOL) {
      u8 = this.A * p6.x;
    } else {
      u8 = this.ArB * Math.atan2(S5 * this.cosgam + V4 * this.singam, temp);
    }
  } else {
    v5 = p6.y > 0 ? this.v_pole_n : this.v_pole_s;
    u8 = this.ArB * p6.y;
  }
  if (this.no_rot) {
    coords.x = u8;
    coords.y = v5;
  } else {
    u8 -= this.u_0;
    coords.x = v5 * this.cosrot + u8 * this.sinrot;
    coords.y = u8 * this.cosrot - v5 * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse9(p6) {
  var u8, v5, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p6.x = (p6.x - this.x0) * (1 / this.a);
  p6.y = (p6.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v5 = p6.y;
    u8 = p6.x;
  } else {
    v5 = p6.x * this.cosrot - p6.y * this.sinrot;
    u8 = p6.y * this.cosrot + p6.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v5);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u8);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z_default(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u8));
  }
  coords.x += this.lam0;
  return coords;
}
var TOL, names11, omerc_default;
var init_omerc = __esm({
  "node_modules/proj4/lib/projections/omerc.js"() {
    init_tsfnz();
    init_adjust_lon();
    init_phi2z();
    init_values();
    init_projections2();
    TOL = 1e-7;
    names11 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Variant_B", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
    omerc_default = {
      init: init10,
      forward: forward9,
      inverse: inverse9,
      names: names11
    };
  }
});

// node_modules/proj4/lib/projections/lcc.js
function init11() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz_default(this.e, sin1, cos1);
  var ts1 = tsfnz_default(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz_default(this.e, sin2, cos2);
  var ts2 = tsfnz_default(this.e, this.lat2, sin2);
  var ts0 = Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN ? 0 : tsfnz_default(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward10(p6) {
  var lon = p6.x;
  var lat = p6.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign_default(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts2, rh1;
  if (con > EPSLN) {
    ts2 = tsfnz_default(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts2, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  p6.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p6.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p6;
}
function inverse10(p6) {
  var rh1, con, ts2;
  var lat, lon;
  var x4 = (p6.x - this.x0) / this.k0;
  var y5 = this.rh - (p6.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x4 * x4 + y5 * y5);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x4 * x4 + y5 * y5);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x4, con * y5);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts2 = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z_default(this.e, ts2);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon_default(theta / this.ns + this.long0);
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names12, lcc_default;
var init_lcc = __esm({
  "node_modules/proj4/lib/projections/lcc.js"() {
    init_msfnz();
    init_tsfnz();
    init_sign();
    init_adjust_lon();
    init_phi2z();
    init_values();
    names12 = [
      "Lambert Tangential Conformal Conic Projection",
      "Lambert_Conformal_Conic",
      "Lambert_Conformal_Conic_1SP",
      "Lambert_Conformal_Conic_2SP",
      "lcc",
      "Lambert Conic Conformal (1SP)",
      "Lambert Conic Conformal (2SP)"
    ];
    lcc_default = {
      init: init11,
      forward: forward10,
      inverse: inverse10,
      names: names12
    };
  }
});

// node_modules/proj4/lib/projections/krovak.js
function init12() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward11(p6) {
  var gfi, u8, deltav, s5, d2, eps, ro;
  var lon = p6.x;
  var lat = p6.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u8 = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s5 = Math.asin(Math.cos(this.ad) * Math.sin(u8) + Math.sin(this.ad) * Math.cos(u8) * Math.cos(deltav));
  d2 = Math.asin(Math.cos(u8) * Math.sin(deltav) / Math.cos(s5));
  eps = this.n * d2;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s5 / 2 + this.s45), this.n);
  p6.y = ro * Math.cos(eps) / 1;
  p6.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p6.y *= -1;
    p6.x *= -1;
  }
  return p6;
}
function inverse11(p6) {
  var u8, deltav, s5, d2, eps, ro, fi1;
  var ok;
  var tmp = p6.x;
  p6.x = p6.y;
  p6.y = tmp;
  if (!this.czech) {
    p6.y *= -1;
    p6.x *= -1;
  }
  ro = Math.sqrt(p6.x * p6.x + p6.y * p6.y);
  eps = Math.atan2(p6.y, p6.x);
  d2 = eps / Math.sin(this.s0);
  s5 = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u8 = Math.asin(Math.cos(this.ad) * Math.sin(s5) - Math.sin(this.ad) * Math.cos(s5) * Math.cos(d2));
  deltav = Math.asin(Math.cos(s5) * Math.sin(d2) / Math.cos(u8));
  p6.x = this.long0 - deltav / this.alfa;
  fi1 = u8;
  ok = 0;
  var iter = 0;
  do {
    p6.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u8 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p6.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p6.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p6;
}
var names13, krovak_default;
var init_krovak = __esm({
  "node_modules/proj4/lib/projections/krovak.js"() {
    init_adjust_lon();
    names13 = ["Krovak", "krovak"];
    krovak_default = {
      init: init12,
      forward: forward11,
      inverse: inverse11,
      names: names13
    };
  }
});

// node_modules/proj4/lib/common/mlfn.js
function mlfn_default(e0, e1, e23, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e23 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}
var init_mlfn = __esm({
  "node_modules/proj4/lib/common/mlfn.js"() {
  }
});

// node_modules/proj4/lib/common/e0fn.js
function e0fn_default(x4) {
  return 1 - 0.25 * x4 * (1 + x4 / 16 * (3 + 1.25 * x4));
}
var init_e0fn = __esm({
  "node_modules/proj4/lib/common/e0fn.js"() {
  }
});

// node_modules/proj4/lib/common/e1fn.js
function e1fn_default(x4) {
  return 0.375 * x4 * (1 + 0.25 * x4 * (1 + 0.46875 * x4));
}
var init_e1fn = __esm({
  "node_modules/proj4/lib/common/e1fn.js"() {
  }
});

// node_modules/proj4/lib/common/e2fn.js
function e2fn_default(x4) {
  return 0.05859375 * x4 * x4 * (1 + 0.75 * x4);
}
var init_e2fn = __esm({
  "node_modules/proj4/lib/common/e2fn.js"() {
  }
});

// node_modules/proj4/lib/common/e3fn.js
function e3fn_default(x4) {
  return x4 * x4 * x4 * (35 / 3072);
}
var init_e3fn = __esm({
  "node_modules/proj4/lib/common/e3fn.js"() {
  }
});

// node_modules/proj4/lib/common/gN.js
function gN_default(a5, e3, sinphi) {
  var temp = e3 * sinphi;
  return a5 / Math.sqrt(1 - temp * temp);
}
var init_gN = __esm({
  "node_modules/proj4/lib/common/gN.js"() {
  }
});

// node_modules/proj4/lib/common/adjust_lat.js
function adjust_lat_default(x4) {
  return Math.abs(x4) < HALF_PI ? x4 : x4 - sign_default(x4) * Math.PI;
}
var init_adjust_lat = __esm({
  "node_modules/proj4/lib/common/adjust_lat.js"() {
    init_values();
    init_sign();
  }
});

// node_modules/proj4/lib/common/imlfn.js
function imlfn_default(ml, e0, e1, e23, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i7 = 0; i7 < 15; i7++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e23 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e23 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
var init_imlfn = __esm({
  "node_modules/proj4/lib/common/imlfn.js"() {
  }
});

// node_modules/proj4/lib/projections/cass.js
function init13() {
  if (!this.sphere) {
    this.e0 = e0fn_default(this.es);
    this.e1 = e1fn_default(this.es);
    this.e2 = e2fn_default(this.es);
    this.e3 = e3fn_default(this.es);
    this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward12(p6) {
  var x4, y5;
  var lam = p6.x;
  var phi = p6.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    x4 = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y5 = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN_default(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
    x4 = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y5 = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p6.x = x4 + this.x0;
  p6.y = y5 + this.y0;
  return p6;
}
function inverse12(p6) {
  p6.x -= this.x0;
  p6.y -= this.y0;
  var x4 = p6.x / this.a;
  var y5 = p6.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y5 + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x4));
    lam = Math.atan2(Math.tan(x4), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y5;
    var phi1 = imlfn_default(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p6.x = this.long0;
      p6.y = HALF_PI;
      if (y5 < 0) {
        p6.y *= -1;
      }
      return p6;
    }
    var nl1 = gN_default(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x4 * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p6.x = adjust_lon_default(lam + this.long0);
  p6.y = adjust_lat_default(phi);
  return p6;
}
var names14, cass_default;
var init_cass = __esm({
  "node_modules/proj4/lib/projections/cass.js"() {
    init_mlfn();
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_gN();
    init_adjust_lon();
    init_adjust_lat();
    init_imlfn();
    init_values();
    names14 = ["Cassini", "Cassini_Soldner", "cass"];
    cass_default = {
      init: init13,
      forward: forward12,
      inverse: inverse12,
      names: names14
    };
  }
});

// node_modules/proj4/lib/common/qsfnz.js
function qsfnz_default(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}
var init_qsfnz = __esm({
  "node_modules/proj4/lib/common/qsfnz.js"() {
  }
});

// node_modules/proj4/lib/projections/laea.js
function init14() {
  var t4 = Math.abs(this.lat0);
  if (Math.abs(t4 - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? S_POLE : N_POLE;
  } else if (Math.abs(t4) < EPSLN) {
    this.mode = EQUIT;
  } else {
    this.mode = OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz_default(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case N_POLE:
        this.dd = 1;
        break;
      case S_POLE:
        this.dd = 1;
        break;
      case EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz_default(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward13(p6) {
  var x4, y5, coslam, sinlam, sinphi, q5, sinb, cosb, b8, cosphi;
  var lam = p6.x;
  var phi = p6.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y5 = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y5 <= EPSLN) {
        return null;
      }
      y5 = Math.sqrt(2 / y5);
      x4 = y5 * cosphi * Math.sin(lam);
      y5 *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y5 = FORTPI - phi * 0.5;
      y5 = 2 * (this.mode === this.S_POLE ? Math.cos(y5) : Math.sin(y5));
      x4 = y5 * Math.sin(lam);
      y5 *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b8 = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q5 = qsfnz_default(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q5 / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b8 = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b8 = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b8 = HALF_PI + phi;
        q5 = this.qp - q5;
        break;
      case this.S_POLE:
        b8 = phi - HALF_PI;
        q5 = this.qp + q5;
        break;
    }
    if (Math.abs(b8) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b8 = Math.sqrt(2 / b8);
        if (this.mode === this.OBLIQ) {
          y5 = this.ymf * b8 * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y5 = (b8 = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x4 = this.xmf * b8 * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q5 >= 0) {
          x4 = (b8 = Math.sqrt(q5)) * sinlam;
          y5 = coslam * (this.mode === this.S_POLE ? b8 : -b8);
        } else {
          x4 = y5 = 0;
        }
        break;
    }
  }
  p6.x = this.a * x4 + this.x0;
  p6.y = this.a * y5 + this.y0;
  return p6;
}
function inverse13(p6) {
  p6.x -= this.x0;
  p6.y -= this.y0;
  var x4 = p6.x / this.a;
  var y5 = p6.y / this.a;
  var lam, phi, cCe, sCe, q5, rho, ab4;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x4 * x4 + y5 * y5);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y5 * sinz / rh);
        x4 *= sinz;
        y5 = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y5 * sinz * this.cosph0 / rh);
        x4 *= sinz * this.cosph0;
        y5 = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y5 = -y5;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y5 === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x4, y5);
  } else {
    ab4 = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x4 /= this.dd;
      y5 *= this.dd;
      rho = Math.sqrt(x4 * x4 + y5 * y5);
      if (rho < EPSLN) {
        p6.x = this.long0;
        p6.y = this.lat0;
        return p6;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x4 *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab4 = cCe * this.sinb1 + y5 * sCe * this.cosb1 / rho;
        q5 = this.qp * ab4;
        y5 = rho * this.cosb1 * cCe - y5 * this.sinb1 * sCe;
      } else {
        ab4 = y5 * sCe / rho;
        q5 = this.qp * ab4;
        y5 = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y5 = -y5;
      }
      q5 = x4 * x4 + y5 * y5;
      if (!q5) {
        p6.x = this.long0;
        p6.y = this.lat0;
        return p6;
      }
      ab4 = 1 - q5 / this.qp;
      if (this.mode === this.S_POLE) {
        ab4 = -ab4;
      }
    }
    lam = Math.atan2(x4, y5);
    phi = authlat(Math.asin(ab4), this.apa);
  }
  p6.x = adjust_lon_default(this.long0 + lam);
  p6.y = phi;
  return p6;
}
function authset(es2) {
  var t4;
  var APA = [];
  APA[0] = es2 * P00;
  t4 = es2 * es2;
  APA[0] += t4 * P01;
  APA[1] = t4 * P10;
  t4 *= es2;
  APA[0] += t4 * P02;
  APA[1] += t4 * P11;
  APA[2] = t4 * P20;
  return APA;
}
function authlat(beta, APA) {
  var t4 = beta + beta;
  return beta + APA[0] * Math.sin(t4) + APA[1] * Math.sin(t4 + t4) + APA[2] * Math.sin(t4 + t4 + t4);
}
var S_POLE, N_POLE, EQUIT, OBLIQ, P00, P01, P02, P10, P11, P20, names15, laea_default;
var init_laea = __esm({
  "node_modules/proj4/lib/projections/laea.js"() {
    init_values();
    init_qsfnz();
    init_adjust_lon();
    S_POLE = 1;
    N_POLE = 2;
    EQUIT = 3;
    OBLIQ = 4;
    P00 = 0.3333333333333333;
    P01 = 0.17222222222222222;
    P02 = 0.10257936507936508;
    P10 = 0.06388888888888888;
    P11 = 0.0664021164021164;
    P20 = 0.016415012942191543;
    names15 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
    laea_default = {
      init: init14,
      forward: forward13,
      inverse: inverse13,
      names: names15,
      S_POLE,
      N_POLE,
      EQUIT,
      OBLIQ
    };
  }
});

// node_modules/proj4/lib/common/asinz.js
function asinz_default(x4) {
  if (Math.abs(x4) > 1) {
    x4 = x4 > 1 ? 1 : -1;
  }
  return Math.asin(x4);
}
var init_asinz = __esm({
  "node_modules/proj4/lib/common/asinz.js"() {
  }
});

// node_modules/proj4/lib/projections/aea.js
function init15() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz_default(this.e3, this.sin_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward14(p6) {
  var lon = p6.x;
  var lat = p6.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz_default(this.e3, this.sin_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon_default(lon - this.long0);
  var x4 = rh1 * Math.sin(theta) + this.x0;
  var y5 = this.rh - rh1 * Math.cos(theta) + this.y0;
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse14(p6) {
  var rh1, qs, con, theta, lon, lat;
  p6.x -= this.x0;
  p6.y = this.rh - p6.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p6.x * p6.x + p6.y * p6.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p6.x * p6.x + p6.y * p6.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p6.x, con * p6.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon_default(theta / this.ns0 + this.long0);
  p6.x = lon;
  p6.y = lat;
  return p6;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz_default(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i7 = 1; i7 <= 25; i7++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names16, aea_default;
var init_aea = __esm({
  "node_modules/proj4/lib/projections/aea.js"() {
    init_msfnz();
    init_qsfnz();
    init_adjust_lon();
    init_asinz();
    init_values();
    names16 = ["Albers_Conic_Equal_Area", "Albers_Equal_Area", "Albers", "aea"];
    aea_default = {
      init: init15,
      forward: forward14,
      inverse: inverse14,
      names: names16,
      phi1z
    };
  }
});

// node_modules/proj4/lib/projections/gnom.js
function init16() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward15(p6) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g5;
  var x4, y5;
  var lon = p6.x;
  var lat = p6.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g5 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g5 > 0 || Math.abs(g5) <= EPSLN) {
    x4 = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g5;
    y5 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g5;
  } else {
    x4 = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y5 = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse15(p6) {
  var rh;
  var sinc, cosc;
  var c7;
  var lon, lat;
  p6.x = (p6.x - this.x0) / this.a;
  p6.y = (p6.y - this.y0) / this.a;
  p6.x /= this.k0;
  p6.y /= this.k0;
  if (rh = Math.sqrt(p6.x * p6.x + p6.y * p6.y)) {
    c7 = Math.atan2(rh, this.rc);
    sinc = Math.sin(c7);
    cosc = Math.cos(c7);
    lat = asinz_default(cosc * this.sin_p14 + p6.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p6.x * sinc, rh * this.cos_p14 * cosc - p6.y * this.sin_p14 * sinc);
    lon = adjust_lon_default(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names17, gnom_default;
var init_gnom = __esm({
  "node_modules/proj4/lib/projections/gnom.js"() {
    init_adjust_lon();
    init_asinz();
    init_values();
    names17 = ["gnom"];
    gnom_default = {
      init: init16,
      forward: forward15,
      inverse: inverse15,
      names: names17
    };
  }
});

// node_modules/proj4/lib/common/iqsfnz.js
function iqsfnz_default(eccent, q5) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q5) - temp) < 1e-6) {
    if (q5 < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q5);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i7 = 0; i7 < 30; i7++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q5 / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
var init_iqsfnz = __esm({
  "node_modules/proj4/lib/common/iqsfnz.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/projections/cea.js
function init17() {
  if (!this.sphere) {
    this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward16(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var x4, y5;
  var dlon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    x4 = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y5 = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz_default(this.e, Math.sin(lat));
    x4 = this.x0 + this.a * this.k0 * dlon;
    y5 = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse16(p6) {
  p6.x -= this.x0;
  p6.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + p6.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p6.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz_default(this.e, 2 * p6.y * this.k0 / this.a);
    lon = adjust_lon_default(this.long0 + p6.x / (this.a * this.k0));
  }
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names18, cea_default;
var init_cea = __esm({
  "node_modules/proj4/lib/projections/cea.js"() {
    init_adjust_lon();
    init_qsfnz();
    init_msfnz();
    init_iqsfnz();
    names18 = ["cea"];
    cea_default = {
      init: init17,
      forward: forward16,
      inverse: inverse16,
      names: names18
    };
  }
});

// node_modules/proj4/lib/projections/eqc.js
function init18() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward17(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var dlat = adjust_lat_default(lat - this.lat0);
  p6.x = this.x0 + this.a * dlon * this.rc;
  p6.y = this.y0 + this.a * dlat;
  return p6;
}
function inverse17(p6) {
  var x4 = p6.x;
  var y5 = p6.y;
  p6.x = adjust_lon_default(this.long0 + (x4 - this.x0) / (this.a * this.rc));
  p6.y = adjust_lat_default(this.lat0 + (y5 - this.y0) / this.a);
  return p6;
}
var names19, eqc_default;
var init_eqc = __esm({
  "node_modules/proj4/lib/projections/eqc.js"() {
    init_adjust_lon();
    init_adjust_lat();
    names19 = ["Equirectangular", "Equidistant_Cylindrical", "Equidistant_Cylindrical_Spherical", "eqc"];
    eqc_default = {
      init: init18,
      forward: forward17,
      inverse: inverse17,
      names: names19
    };
  }
});

// node_modules/proj4/lib/projections/poly.js
function init19() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward18(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var x4, y5, el;
  var dlon = adjust_lon_default(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x4 = this.a * dlon;
      y5 = -1 * this.a * this.lat0;
    } else {
      x4 = this.a * Math.sin(el) / Math.tan(lat);
      y5 = this.a * (adjust_lat_default(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x4 = this.a * dlon;
      y5 = -1 * this.ml0;
    } else {
      var nl = gN_default(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x4 = nl * Math.sin(el);
      y5 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p6.x = x4 + this.x0;
  p6.y = y5 + this.y0;
  return p6;
}
function inverse18(p6) {
  var lon, lat, x4, y5, i7;
  var al, bl;
  var phi, dphi;
  x4 = p6.x - this.x0;
  y5 = p6.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y5 + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon_default(x4 / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y5 / this.a;
      bl = x4 * x4 / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i7 = MAX_ITER3; i7; --i7) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon_default(this.long0 + Math.asin(x4 * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y5 + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon_default(this.long0 + x4 / this.a);
    } else {
      al = (this.ml0 + y5) / this.a;
      bl = x4 * x4 / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i7 = MAX_ITER3; i7; --i7) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon_default(this.long0 + Math.asin(x4 * cl / this.a) / Math.sin(lat));
    }
  }
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var MAX_ITER3, names20, poly_default;
var init_poly = __esm({
  "node_modules/proj4/lib/projections/poly.js"() {
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_adjust_lon();
    init_adjust_lat();
    init_mlfn();
    init_values();
    init_gN();
    MAX_ITER3 = 20;
    names20 = ["Polyconic", "American_Polyconic", "poly"];
    poly_default = {
      init: init19,
      forward: forward18,
      inverse: inverse18,
      names: names20
    };
  }
});

// node_modules/proj4/lib/projections/nzmg.js
function init20() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward19(p6) {
  var n6;
  var lon = p6.x;
  var lat = p6.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n6 = 1; n6 <= 10; n6++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n6] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n6 = 1; n6 <= 6; n6++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n6] * th_n_re - this.B_im[n6] * th_n_im;
    z_im = z_im + this.B_im[n6] * th_n_re + this.B_re[n6] * th_n_im;
  }
  p6.x = z_im * this.a + this.x0;
  p6.y = z_re * this.a + this.y0;
  return p6;
}
function inverse19(p6) {
  var n6;
  var x4 = p6.x;
  var y5 = p6.y;
  var delta_x = x4 - this.x0;
  var delta_y = y5 - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n6 = 1; n6 <= 6; n6++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n6] * z_n_re - this.C_im[n6] * z_n_im;
    th_im = th_im + this.C_im[n6] * z_n_re + this.C_re[n6] * z_n_im;
  }
  for (var i7 = 0; i7 < this.iterations; i7++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n6 = 2; n6 <= 6; n6++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n6 - 1) * (this.B_re[n6] * th_n_re - this.B_im[n6] * th_n_im);
      num_im = num_im + (n6 - 1) * (this.B_im[n6] * th_n_re + this.B_re[n6] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n6 = 2; n6 <= 6; n6++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n6 * (this.B_re[n6] * th_n_re - this.B_im[n6] * th_n_im);
      den_im = den_im + n6 * (this.B_im[n6] * th_n_re + this.B_re[n6] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n6 = 1; n6 <= 9; n6++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n6] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names21, nzmg_default;
var init_nzmg = __esm({
  "node_modules/proj4/lib/projections/nzmg.js"() {
    init_values();
    names21 = ["New_Zealand_Map_Grid", "nzmg"];
    nzmg_default = {
      init: init20,
      forward: forward19,
      inverse: inverse19,
      names: names21
    };
  }
});

// node_modules/proj4/lib/projections/mill.js
function init21() {
}
function forward20(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x4 = this.x0 + this.a * dlon;
  var y5 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse20(p6) {
  p6.x -= this.x0;
  p6.y -= this.y0;
  var lon = adjust_lon_default(this.long0 + p6.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p6.y / this.a)) - Math.PI / 4);
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names22, mill_default;
var init_mill = __esm({
  "node_modules/proj4/lib/projections/mill.js"() {
    init_adjust_lon();
    names22 = ["Miller_Cylindrical", "mill"];
    mill_default = {
      init: init21,
      forward: forward20,
      inverse: inverse20,
      names: names22
    };
  }
});

// node_modules/proj4/lib/projections/sinu.js
function init22() {
  if (!this.sphere) {
    this.en = pj_enfn_default(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward21(p6) {
  var x4, y5;
  var lon = p6.x;
  var lat = p6.y;
  lon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k5 = this.n * Math.sin(lat);
      for (var i7 = MAX_ITER4; i7; --i7) {
        var V4 = (this.m * lat + Math.sin(lat) - k5) / (this.m + Math.cos(lat));
        lat -= V4;
        if (Math.abs(V4) < EPSLN) {
          break;
        }
      }
    }
    x4 = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y5 = this.a * this.C_y * lat;
  } else {
    var s5 = Math.sin(lat);
    var c7 = Math.cos(lat);
    y5 = this.a * pj_mlfn_default(lat, s5, c7, this.en);
    x4 = this.a * lon * c7 / Math.sqrt(1 - this.es * s5 * s5);
  }
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse21(p6) {
  var lat, temp, lon, s5;
  p6.x -= this.x0;
  lon = p6.x / this.a;
  p6.y -= this.y0;
  lat = p6.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz_default((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz_default(Math.sin(lat) / this.n);
    }
    lon = adjust_lon_default(lon + this.long0);
    lat = adjust_lat_default(lat);
  } else {
    lat = pj_inv_mlfn_default(p6.y / this.a, this.es, this.en);
    s5 = Math.abs(lat);
    if (s5 < HALF_PI) {
      s5 = Math.sin(lat);
      temp = this.long0 + p6.x * Math.sqrt(1 - this.es * s5 * s5) / (this.a * Math.cos(lat));
      lon = adjust_lon_default(temp);
    } else if (s5 - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var MAX_ITER4, names23, sinu_default;
var init_sinu = __esm({
  "node_modules/proj4/lib/projections/sinu.js"() {
    init_adjust_lon();
    init_adjust_lat();
    init_pj_enfn();
    init_pj_mlfn();
    init_pj_inv_mlfn();
    init_values();
    init_asinz();
    MAX_ITER4 = 20;
    names23 = ["Sinusoidal", "sinu"];
    sinu_default = {
      init: init22,
      forward: forward21,
      inverse: inverse21,
      names: names23
    };
  }
});

// node_modules/proj4/lib/projections/moll.js
function init23() {
}
function forward22(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x4 = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y5 = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse22(p6) {
  var theta;
  var arg;
  p6.x -= this.x0;
  p6.y -= this.y0;
  arg = p6.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon_default(this.long0 + p6.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names24, moll_default;
var init_moll = __esm({
  "node_modules/proj4/lib/projections/moll.js"() {
    init_adjust_lon();
    init_values();
    names24 = ["Mollweide", "moll"];
    moll_default = {
      init: init23,
      forward: forward22,
      inverse: inverse22,
      names: names24
    };
  }
});

// node_modules/proj4/lib/projections/eqdc.js
function init24() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.sin_phi = Math.sin(this.lat1);
  this.cos_phi = Math.cos(this.lat1);
  this.ms1 = msfnz_default(this.e, this.sin_phi, this.cos_phi);
  this.ml1 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sin_phi;
  } else {
    this.sin_phi = Math.sin(this.lat2);
    this.cos_phi = Math.cos(this.lat2);
    this.ms2 = msfnz_default(this.e, this.sin_phi, this.cos_phi);
    this.ml2 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward23(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn_default(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  var x4 = this.x0 + rh1 * Math.sin(theta);
  var y5 = this.y0 + this.rh - rh1 * Math.cos(theta);
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse23(p6) {
  p6.x -= this.x0;
  p6.y = this.rh - p6.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p6.x * p6.x + p6.y * p6.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p6.x * p6.x + p6.y * p6.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p6.x, con * p6.y);
  }
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    lat = adjust_lat_default(this.g - rh1 / this.a);
    p6.x = lon;
    p6.y = lat;
    return p6;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn_default(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    p6.x = lon;
    p6.y = lat;
    return p6;
  }
}
var names25, eqdc_default;
var init_eqdc = __esm({
  "node_modules/proj4/lib/projections/eqdc.js"() {
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_msfnz();
    init_mlfn();
    init_adjust_lon();
    init_adjust_lat();
    init_imlfn();
    init_values();
    names25 = ["Equidistant_Conic", "eqdc"];
    eqdc_default = {
      init: init24,
      forward: forward23,
      inverse: inverse23,
      names: names25
    };
  }
});

// node_modules/proj4/lib/projections/vandg.js
function init25() {
  this.R = this.a;
}
function forward24(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x4, y5;
  if (Math.abs(lat) <= EPSLN) {
    x4 = this.x0 + this.R * dlon;
    y5 = this.y0;
  }
  var theta = asinz_default(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x4 = this.x0;
    if (lat >= 0) {
      y5 = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y5 = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g5 = costh / (sinth + costh - 1);
  var gsq = g5 * g5;
  var m8 = g5 * (2 / sinth - 1);
  var msq = m8 * m8;
  var con = Math.PI * this.R * (al * (g5 - msq) + Math.sqrt(asq * (g5 - msq) * (g5 - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x4 = this.x0 + con;
  var q5 = asq + g5;
  con = Math.PI * this.R * (m8 * q5 - al * Math.sqrt((msq + asq) * (asq + 1) - q5 * q5)) / (msq + asq);
  if (lat >= 0) {
    y5 = this.y0 + con;
  } else {
    y5 = this.y0 - con;
  }
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse24(p6) {
  var lon, lat;
  var xx, yy, xys, c1, c22, c32;
  var a12;
  var m1;
  var con;
  var th1;
  var d2;
  p6.x -= this.x0;
  p6.y -= this.y0;
  con = Math.PI * this.R;
  xx = p6.x / con;
  yy = p6.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c22 = c1 - 2 * yy * yy + xx * xx;
  c32 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d2 = yy * yy / c32 + (2 * c22 * c22 * c22 / c32 / c32 / c32 - 9 * c1 * c22 / c32 / c32) / 27;
  a12 = (c1 - c22 * c22 / 3 / c32) / c32;
  m1 = 2 * Math.sqrt(-a12 / 3);
  con = 3 * d2 / a12 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p6.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c22 / 3 / c32) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c22 / 3 / c32) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon_default(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names26, vandg_default;
var init_vandg = __esm({
  "node_modules/proj4/lib/projections/vandg.js"() {
    init_adjust_lon();
    init_values();
    init_asinz();
    names26 = ["Van_der_Grinten_I", "VanDerGrinten", "Van_der_Grinten", "vandg"];
    vandg_default = {
      init: init25,
      forward: forward24,
      inverse: inverse24,
      names: names26
    };
  }
});

// node_modules/proj4/lib/common/vincenty.js
function vincentyInverse(lat1, lon1, lat2, lon2, a5, f8) {
  const L4 = lon2 - lon1;
  const U1 = Math.atan((1 - f8) * Math.tan(lat1));
  const U22 = Math.atan((1 - f8) * Math.tan(lat2));
  const sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
  const sinU2 = Math.sin(U22), cosU2 = Math.cos(U22);
  let lambda = L4, lambdaP, iterLimit = 100;
  let sinLambda, cosLambda, sinSigma, cosSigma, sigma, sinAlpha, cos2Alpha, cos2SigmaM, C6;
  let uSq, A13, B5, deltaSigma, s5;
  do {
    sinLambda = Math.sin(lambda);
    cosLambda = Math.cos(lambda);
    sinSigma = Math.sqrt(
      cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)
    );
    if (sinSigma === 0) {
      return { azi1: 0, s12: 0 };
    }
    cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
    sigma = Math.atan2(sinSigma, cosSigma);
    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
    cos2Alpha = 1 - sinAlpha * sinAlpha;
    cos2SigmaM = cos2Alpha !== 0 ? cosSigma - 2 * sinU1 * sinU2 / cos2Alpha : 0;
    C6 = f8 / 16 * cos2Alpha * (4 + f8 * (4 - 3 * cos2Alpha));
    lambdaP = lambda;
    lambda = L4 + (1 - C6) * f8 * sinAlpha * (sigma + C6 * sinSigma * (cos2SigmaM + C6 * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return { azi1: NaN, s12: NaN };
  }
  uSq = cos2Alpha * (a5 * a5 - a5 * (1 - f8) * (a5 * (1 - f8))) / (a5 * (1 - f8) * (a5 * (1 - f8)));
  A13 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  B5 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  deltaSigma = B5 * sinSigma * (cos2SigmaM + B5 / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B5 / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
  s5 = a5 * (1 - f8) * A13 * (sigma - deltaSigma);
  const azi1 = Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
  return { azi1, s12: s5 };
}
function vincentyDirect(lat1, lon1, azi1, s12, a5, f8) {
  const U1 = Math.atan((1 - f8) * Math.tan(lat1));
  const sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
  const sinAlpha1 = Math.sin(azi1), cosAlpha1 = Math.cos(azi1);
  const sigma1 = Math.atan2(sinU1, cosU1 * cosAlpha1);
  const sinAlpha = cosU1 * sinAlpha1;
  const cos2Alpha = 1 - sinAlpha * sinAlpha;
  const uSq = cos2Alpha * (a5 * a5 - a5 * (1 - f8) * (a5 * (1 - f8))) / (a5 * (1 - f8) * (a5 * (1 - f8)));
  const A13 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  const B5 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  let sigma = s12 / (a5 * (1 - f8) * A13), sigmaP, iterLimit = 100;
  let cos2SigmaM, sinSigma, cosSigma, deltaSigma;
  do {
    cos2SigmaM = Math.cos(2 * sigma1 + sigma);
    sinSigma = Math.sin(sigma);
    cosSigma = Math.cos(sigma);
    deltaSigma = B5 * sinSigma * (cos2SigmaM + B5 / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B5 / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
    sigmaP = sigma;
    sigma = s12 / (a5 * (1 - f8) * A13) + deltaSigma;
  } while (Math.abs(sigma - sigmaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return { lat2: NaN, lon2: NaN };
  }
  const tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;
  const lat2 = Math.atan2(
    sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1,
    (1 - f8) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp)
  );
  const lambda = Math.atan2(
    sinSigma * sinAlpha1,
    cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1
  );
  const C6 = f8 / 16 * cos2Alpha * (4 + f8 * (4 - 3 * cos2Alpha));
  const L4 = lambda - (1 - C6) * f8 * sinAlpha * (sigma + C6 * sinSigma * (cos2SigmaM + C6 * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  const lon2 = lon1 + L4;
  return { lat2, lon2 };
}
var init_vincenty = __esm({
  "node_modules/proj4/lib/common/vincenty.js"() {
  }
});

// node_modules/proj4/lib/projections/aeqd.js
function init26() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
  this.f = this.es / (1 + Math.sqrt(1 - this.es));
}
function forward25(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var sinphi = Math.sin(p6.y);
  var cosphi = Math.cos(p6.y);
  var dlon = adjust_lon_default(lon - this.long0);
  var e0, e1, e23, e3, Mlp, Ml, c7, kp, cos_c, vars, azi1;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p6.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p6.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p6;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p6.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p6.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p6;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c7 = Math.acos(cos_c);
      kp = c7 ? c7 / Math.sin(c7) : 1;
      p6.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p6.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p6;
    }
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e23 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e23, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e23, e3, lat);
      p6.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p6.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p6;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e23, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e23, e3, lat);
      p6.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p6.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p6;
    } else {
      if (Math.abs(lon) < EPSLN && Math.abs(lat - this.lat0) < EPSLN) {
        p6.x = p6.y = 0;
        return p6;
      }
      vars = vincentyInverse(this.lat0, this.long0, lat, lon, this.a, this.f);
      azi1 = vars.azi1;
      p6.x = vars.s12 * Math.sin(azi1);
      p6.y = vars.s12 * Math.cos(azi1);
      return p6;
    }
  }
}
function inverse25(p6) {
  p6.x -= this.x0;
  p6.y -= this.y0;
  var rh, z3, sinz, cosz, lon, lat, con, e0, e1, e23, e3, Mlp, M9, azi1, s12, vars;
  if (this.sphere) {
    rh = Math.sqrt(p6.x * p6.x + p6.y * p6.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z3 = rh / this.a;
    sinz = Math.sin(z3);
    cosz = Math.cos(z3);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz_default(cosz * this.sin_p12 + p6.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon_default(this.long0 + Math.atan2(p6.x, -p6.y));
        } else {
          lon = adjust_lon_default(this.long0 - Math.atan2(-p6.x, p6.y));
        }
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p6.x * sinz, rh * this.cos_p12 * cosz - p6.y * this.sin_p12 * sinz));
      }
    }
    p6.x = lon;
    p6.y = lat;
    return p6;
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e23 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e23, e3, HALF_PI);
      rh = Math.sqrt(p6.x * p6.x + p6.y * p6.y);
      M9 = Mlp - rh;
      lat = imlfn_default(M9 / this.a, e0, e1, e23, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p6.x, -1 * p6.y));
      p6.x = lon;
      p6.y = lat;
      return p6;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e23, e3, HALF_PI);
      rh = Math.sqrt(p6.x * p6.x + p6.y * p6.y);
      M9 = rh - Mlp;
      lat = imlfn_default(M9 / this.a, e0, e1, e23, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p6.x, p6.y));
      p6.x = lon;
      p6.y = lat;
      return p6;
    } else {
      azi1 = Math.atan2(p6.x, p6.y);
      s12 = Math.sqrt(p6.x * p6.x + p6.y * p6.y);
      vars = vincentyDirect(this.lat0, this.long0, azi1, s12, this.a, this.f);
      p6.x = vars.lon2;
      p6.y = vars.lat2;
      return p6;
    }
  }
}
var names27, aeqd_default;
var init_aeqd = __esm({
  "node_modules/proj4/lib/projections/aeqd.js"() {
    init_adjust_lon();
    init_values();
    init_mlfn();
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_asinz();
    init_imlfn();
    init_vincenty();
    names27 = ["Azimuthal_Equidistant", "aeqd"];
    aeqd_default = {
      init: init26,
      forward: forward25,
      inverse: inverse25,
      names: names27
    };
  }
});

// node_modules/proj4/lib/projections/ortho.js
function init27() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward26(p6) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g5, x4, y5;
  var lon = p6.x;
  var lat = p6.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g5 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g5 > 0 || Math.abs(g5) <= EPSLN) {
    x4 = this.a * ksp * cosphi * Math.sin(dlon);
    y5 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p6.x = x4;
  p6.y = y5;
  return p6;
}
function inverse26(p6) {
  var rh;
  var z3;
  var sinz, cosz;
  var con;
  var lon, lat;
  p6.x -= this.x0;
  p6.y -= this.y0;
  rh = Math.sqrt(p6.x * p6.x + p6.y * p6.y);
  z3 = asinz_default(rh / this.a);
  sinz = Math.sin(z3);
  cosz = Math.cos(z3);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p6.x = lon;
    p6.y = lat;
    return p6;
  }
  lat = asinz_default(cosz * this.sin_p14 + p6.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon_default(this.long0 + Math.atan2(p6.x, -p6.y));
    } else {
      lon = adjust_lon_default(this.long0 - Math.atan2(-p6.x, p6.y));
    }
    p6.x = lon;
    p6.y = lat;
    return p6;
  }
  lon = adjust_lon_default(this.long0 + Math.atan2(p6.x * sinz, rh * this.cos_p14 * cosz - p6.y * this.sin_p14 * sinz));
  p6.x = lon;
  p6.y = lat;
  return p6;
}
var names28, ortho_default;
var init_ortho = __esm({
  "node_modules/proj4/lib/projections/ortho.js"() {
    init_adjust_lon();
    init_asinz();
    init_values();
    names28 = ["ortho"];
    ortho_default = {
      init: init27,
      forward: forward26,
      inverse: inverse26,
      names: names28
    };
  }
});

// node_modules/proj4/lib/projections/qsc.js
function init28() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward27(p6) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t4, mu;
  var area = { value: 0 };
  p6.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p6.y));
  } else {
    lat = p6.y;
  }
  lon = p6.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q5, r5, s5;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q5 = coslat * coslon;
    r5 = coslat * sinlon;
    s5 = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q5);
      theta = qsc_fwd_equat_face_theta(phi, s5, r5, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r5);
      theta = qsc_fwd_equat_face_theta(phi, s5, -q5, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q5);
      theta = qsc_fwd_equat_face_theta(phi, s5, -r5, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r5);
      theta = qsc_fwd_equat_face_theta(phi, s5, q5, area);
    } else {
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t4 = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t4 * Math.cos(mu);
  xy.y = t4 * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p6.x = xy.x;
  p6.y = xy.y;
  return p6;
}
function inverse27(p6) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t4;
  var area = { value: 0 };
  p6.x = (p6.x - this.x0) / this.a;
  p6.y = (p6.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p6.x * p6.x + p6.y * p6.y));
  mu = Math.atan2(p6.y, p6.x);
  if (p6.x >= 0 && p6.x >= Math.abs(p6.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p6.y >= 0 && p6.y >= Math.abs(p6.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p6.x < 0 && -p6.x >= Math.abs(p6.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t4 = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t4) / (Math.cos(t4) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q5, r5, s5;
    q5 = cosphi;
    t4 = q5 * q5;
    if (t4 >= 1) {
      s5 = 0;
    } else {
      s5 = Math.sqrt(1 - t4) * Math.sin(theta);
    }
    t4 += s5 * s5;
    if (t4 >= 1) {
      r5 = 0;
    } else {
      r5 = Math.sqrt(1 - t4);
    }
    if (area.value === AREA_ENUM.AREA_1) {
      t4 = r5;
      r5 = -s5;
      s5 = t4;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r5 = -r5;
      s5 = -s5;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t4 = r5;
      r5 = s5;
      s5 = -t4;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t4 = q5;
      q5 = -r5;
      r5 = t4;
    } else if (this.face === FACE_ENUM.BACK) {
      q5 = -q5;
      r5 = -r5;
    } else if (this.face === FACE_ENUM.LEFT) {
      t4 = q5;
      q5 = r5;
      r5 = -t4;
    }
    lp.phi = Math.acos(-s5) - HALF_PI;
    lp.lam = Math.atan2(r5, q5);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p6.x = lp.lam;
  p6.y = lp.phi;
  return p6;
}
function qsc_fwd_equat_face_theta(phi, y5, x4, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y5, x4);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var FACE_ENUM, AREA_ENUM, names29, qsc_default;
var init_qsc = __esm({
  "node_modules/proj4/lib/projections/qsc.js"() {
    init_values();
    FACE_ENUM = {
      FRONT: 1,
      RIGHT: 2,
      BACK: 3,
      LEFT: 4,
      TOP: 5,
      BOTTOM: 6
    };
    AREA_ENUM = {
      AREA_0: 1,
      AREA_1: 2,
      AREA_2: 3,
      AREA_3: 4
    };
    names29 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
    qsc_default = {
      init: init28,
      forward: forward27,
      inverse: inverse27,
      names: names29
    };
  }
});

// node_modules/proj4/lib/projections/robin.js
function newton_rapshon(f_df, start2, max_err, iters) {
  var x4 = start2;
  for (; iters; --iters) {
    var upd = f_df(x4);
    x4 -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x4;
}
function init29() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward28(ll) {
  var lon = adjust_lon_default(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i7 = Math.floor(dphi * C1);
  if (i7 < 0) {
    i7 = 0;
  } else if (i7 >= NODES) {
    i7 = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i7);
  var xy = {
    x: poly3_val(COEFS_X[i7], dphi) * lon,
    y: poly3_val(COEFS_Y[i7], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse28(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i7 = Math.floor(ll.y * NODES);
    if (i7 < 0) {
      i7 = 0;
    } else if (i7 >= NODES) {
      i7 = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i7][0] > ll.y) {
        --i7;
      } else if (COEFS_Y[i7 + 1][0] <= ll.y) {
        ++i7;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i7];
    var t4 = 5 * (ll.y - coefs[0]) / (COEFS_Y[i7 + 1][0] - coefs[0]);
    t4 = newton_rapshon(function(x4) {
      return (poly3_val(coefs, x4) - ll.y) / poly3_der(coefs, x4);
    }, t4, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i7], t4);
    ll.y = (5 * i7 + t4) * D2R;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon_default(ll.x + this.long0);
  return ll;
}
var COEFS_X, COEFS_Y, FXC, FYC, C1, RC1, NODES, poly3_val, poly3_der, names30, robin_default;
var init_robin = __esm({
  "node_modules/proj4/lib/projections/robin.js"() {
    init_values();
    init_adjust_lon();
    COEFS_X = [
      [1, 22199e-21, -715515e-10, 31103e-10],
      [0.9986, -482243e-9, -24897e-9, -13309e-10],
      [0.9954, -83103e-8, -448605e-10, -986701e-12],
      [0.99, -135364e-8, -59661e-9, 36777e-10],
      [0.9822, -167442e-8, -449547e-11, -572411e-11],
      [0.973, -214868e-8, -903571e-10, 18736e-12],
      [0.96, -305085e-8, -900761e-10, 164917e-11],
      [0.9427, -382792e-8, -653386e-10, -26154e-10],
      [0.9216, -467746e-8, -10457e-8, 481243e-11],
      [0.8962, -536223e-8, -323831e-10, -543432e-11],
      [0.8679, -609363e-8, -113898e-9, 332484e-11],
      [0.835, -698325e-8, -640253e-10, 934959e-12],
      [0.7986, -755338e-8, -500009e-10, 935324e-12],
      [0.7597, -798324e-8, -35971e-9, -227626e-11],
      [0.7186, -851367e-8, -701149e-10, -86303e-10],
      [0.6732, -986209e-8, -199569e-9, 191974e-10],
      [0.6213, -0.010418, 883923e-10, 624051e-11],
      [0.5722, -906601e-8, 182e-6, 624051e-11],
      [0.5322, -677797e-8, 275608e-9, 624051e-11]
    ];
    COEFS_Y = [
      [-520417e-23, 0.0124, 121431e-23, -845284e-16],
      [0.062, 0.0124, -126793e-14, 422642e-15],
      [0.124, 0.0124, 507171e-14, -160604e-14],
      [0.186, 0.0123999, -190189e-13, 600152e-14],
      [0.248, 0.0124002, 710039e-13, -224e-10],
      [0.31, 0.0123992, -264997e-12, 835986e-13],
      [0.372, 0.0124029, 988983e-12, -311994e-12],
      [0.434, 0.0123893, -369093e-11, -435621e-12],
      [0.4958, 0.0123198, -102252e-10, -345523e-12],
      [0.5571, 0.0121916, -154081e-10, -582288e-12],
      [0.6176, 0.0119938, -241424e-10, -525327e-12],
      [0.6769, 0.011713, -320223e-10, -516405e-12],
      [0.7346, 0.0113541, -397684e-10, -609052e-12],
      [0.7903, 0.0109107, -489042e-10, -104739e-11],
      [0.8435, 0.0103431, -64615e-9, -140374e-14],
      [0.8936, 969686e-8, -64636e-9, -8547e-9],
      [0.9394, 840947e-8, -192841e-9, -42106e-10],
      [0.9761, 616527e-8, -256e-6, -42106e-10],
      [1, 328947e-8, -319159e-9, -42106e-10]
    ];
    FXC = 0.8487;
    FYC = 1.3523;
    C1 = R2D / 5;
    RC1 = 1 / C1;
    NODES = 18;
    poly3_val = function(coefs, x4) {
      return coefs[0] + x4 * (coefs[1] + x4 * (coefs[2] + x4 * coefs[3]));
    };
    poly3_der = function(coefs, x4) {
      return coefs[1] + x4 * (2 * coefs[2] + x4 * 3 * coefs[3]);
    };
    names30 = ["Robinson", "robin"];
    robin_default = {
      init: init29,
      forward: forward28,
      inverse: inverse28,
      names: names30
    };
  }
});

// node_modules/proj4/lib/projections/geocent.js
function init30() {
  this.name = "geocent";
}
function forward29(p6) {
  var point = geodeticToGeocentric(p6, this.es, this.a);
  return point;
}
function inverse29(p6) {
  var point = geocentricToGeodetic(p6, this.es, this.a, this.b);
  return point;
}
var names31, geocent_default;
var init_geocent = __esm({
  "node_modules/proj4/lib/projections/geocent.js"() {
    init_datumUtils();
    names31 = ["Geocentric", "geocentric", "geocent", "Geocent"];
    geocent_default = {
      init: init30,
      forward: forward29,
      inverse: inverse29,
      names: names31
    };
  }
});

// node_modules/proj4/lib/projections/tpers.js
function init31() {
  Object.keys(params).forEach(function(p6) {
    if (typeof this[p6] === "undefined") {
      this[p6] = params[p6].def;
    } else if (params[p6].num && isNaN(this[p6])) {
      throw new Error("Invalid parameter value, must be numeric " + p6 + " = " + this[p6]);
    } else if (params[p6].num) {
      this[p6] = parseFloat(this[p6]);
    }
    if (params[p6].degrees) {
      this[p6] = this[p6] * D2R;
    }
  }.bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward30(p6) {
  p6.x -= this.long0;
  var sinphi = Math.sin(p6.y);
  var cosphi = Math.cos(p6.y);
  var coslam = Math.cos(p6.x);
  var x4, y5;
  switch (this.mode) {
    case mode.OBLIQ:
      y5 = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y5 = cosphi * coslam;
      break;
    case mode.S_POLE:
      y5 = -sinphi;
      break;
    case mode.N_POLE:
      y5 = sinphi;
      break;
  }
  y5 = this.pn1 / (this.p - y5);
  x4 = y5 * cosphi * Math.sin(p6.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y5 *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y5 *= sinphi;
      break;
    case mode.N_POLE:
      y5 *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y5 *= cosphi * coslam;
      break;
  }
  var yt3, ba;
  yt3 = y5 * this.cg + x4 * this.sg;
  ba = 1 / (yt3 * this.sw * this.h1 + this.cw);
  x4 = (x4 * this.cg - y5 * this.sg) * this.cw * ba;
  y5 = yt3 * ba;
  p6.x = x4 * this.a;
  p6.y = y5 * this.a;
  return p6;
}
function inverse30(p6) {
  p6.x /= this.a;
  p6.y /= this.a;
  var r5 = { x: p6.x, y: p6.y };
  var bm, bq, yt3;
  yt3 = 1 / (this.pn1 - p6.y * this.sw);
  bm = this.pn1 * p6.x * yt3;
  bq = this.pn1 * p6.y * this.cw * yt3;
  p6.x = bm * this.cg + bq * this.sg;
  p6.y = bq * this.cg - bm * this.sg;
  var rh = hypot_default(p6.x, p6.y);
  if (Math.abs(rh) < EPSLN) {
    r5.x = 0;
    r5.y = p6.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r5.y = Math.asin(cosz * this.sinph0 + p6.y * sinz * this.cosph0 / rh);
        p6.y = (cosz - this.sinph0 * Math.sin(r5.y)) * rh;
        p6.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r5.y = Math.asin(p6.y * sinz / rh);
        p6.y = cosz * rh;
        p6.x *= sinz;
        break;
      case mode.N_POLE:
        r5.y = Math.asin(cosz);
        p6.y = -p6.y;
        break;
      case mode.S_POLE:
        r5.y = -Math.asin(cosz);
        break;
    }
    r5.x = Math.atan2(p6.x, p6.y);
  }
  p6.x = r5.x + this.long0;
  p6.y = r5.y;
  return p6;
}
var mode, params, names32, tpers_default;
var init_tpers = __esm({
  "node_modules/proj4/lib/projections/tpers.js"() {
    init_values();
    init_hypot();
    mode = {
      N_POLE: 0,
      S_POLE: 1,
      EQUIT: 2,
      OBLIQ: 3
    };
    params = {
      h: { def: 1e5, num: true },
      // default is Karman line, no default in PROJ.7
      azi: { def: 0, num: true, degrees: true },
      // default is North
      tilt: { def: 0, num: true, degrees: true },
      // default is Nadir
      long0: { def: 0, num: true },
      // default is Greenwich, conversion to rad is automatic
      lat0: { def: 0, num: true }
      // default is Equator, conversion to rad is automatic
    };
    names32 = ["Tilted_Perspective", "tpers"];
    tpers_default = {
      init: init31,
      forward: forward30,
      inverse: inverse30,
      names: names32
    };
  }
});

// node_modules/proj4/lib/projections/geos.js
function init32() {
  this.flip_axis = this.sweep === "x" ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;
  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }
  this.radius_g = 1 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1;
  if (this.es !== 0) {
    var one_es = 1 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = "ellipse";
  } else {
    this.radius_p = 1;
    this.radius_p2 = 1;
    this.radius_p_inv2 = 1;
    this.shape = "sphere";
  }
  if (!this.title) {
    this.title = "Geostationary Satellite View";
  }
}
function forward31(p6) {
  var lon = p6.x;
  var lat = p6.y;
  var tmp, v_x, v_y, v_z;
  lon = lon - this.long0;
  if (this.shape === "ellipse") {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r5 = this.radius_p / hypot_default(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r5 * Math.cos(lon) * Math.cos(lat);
    v_y = r5 * Math.sin(lon) * Math.cos(lat);
    v_z = r5 * Math.sin(lat);
    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
      p6.x = Number.NaN;
      p6.y = Number.NaN;
      return p6;
    }
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p6.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p6.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p6.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p6.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  } else if (this.shape === "sphere") {
    tmp = Math.cos(lat);
    v_x = Math.cos(lon) * tmp;
    v_y = Math.sin(lon) * tmp;
    v_z = Math.sin(lat);
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p6.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p6.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p6.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p6.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  }
  p6.x = p6.x * this.a;
  p6.y = p6.y * this.a;
  return p6;
}
function inverse31(p6) {
  var v_x = -1;
  var v_y = 0;
  var v_z = 0;
  var a5, b8, det, k5;
  p6.x = p6.x / this.a;
  p6.y = p6.y / this.a;
  if (this.shape === "ellipse") {
    if (this.flip_axis) {
      v_z = Math.tan(p6.y / this.radius_g_1);
      v_y = Math.tan(p6.x / this.radius_g_1) * hypot_default(1, v_z);
    } else {
      v_y = Math.tan(p6.x / this.radius_g_1);
      v_z = Math.tan(p6.y / this.radius_g_1) * hypot_default(1, v_y);
    }
    var v_zp = v_z / this.radius_p;
    a5 = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b8 = 2 * this.radius_g * v_x;
    det = b8 * b8 - 4 * a5 * this.C;
    if (det < 0) {
      p6.x = Number.NaN;
      p6.y = Number.NaN;
      return p6;
    }
    k5 = (-b8 - Math.sqrt(det)) / (2 * a5);
    v_x = this.radius_g + k5 * v_x;
    v_y *= k5;
    v_z *= k5;
    p6.x = Math.atan2(v_y, v_x);
    p6.y = Math.atan(v_z * Math.cos(p6.x) / v_x);
    p6.y = Math.atan(this.radius_p_inv2 * Math.tan(p6.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis) {
      v_z = Math.tan(p6.y / this.radius_g_1);
      v_y = Math.tan(p6.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
    } else {
      v_y = Math.tan(p6.x / this.radius_g_1);
      v_z = Math.tan(p6.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
    }
    a5 = v_y * v_y + v_z * v_z + v_x * v_x;
    b8 = 2 * this.radius_g * v_x;
    det = b8 * b8 - 4 * a5 * this.C;
    if (det < 0) {
      p6.x = Number.NaN;
      p6.y = Number.NaN;
      return p6;
    }
    k5 = (-b8 - Math.sqrt(det)) / (2 * a5);
    v_x = this.radius_g + k5 * v_x;
    v_y *= k5;
    v_z *= k5;
    p6.x = Math.atan2(v_y, v_x);
    p6.y = Math.atan(v_z * Math.cos(p6.x) / v_x);
  }
  p6.x = p6.x + this.long0;
  return p6;
}
var names33, geos_default;
var init_geos = __esm({
  "node_modules/proj4/lib/projections/geos.js"() {
    init_hypot();
    names33 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
    geos_default = {
      init: init32,
      forward: forward31,
      inverse: inverse31,
      names: names33
    };
  }
});

// node_modules/proj4/lib/projections/eqearth.js
function init33() {
  this.es = 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function forward32(p6) {
  var lam = adjust_lon_default(p6.x - this.long0);
  var phi = p6.y;
  var paramLat = Math.asin(M6 * Math.sin(phi)), paramLatSq = paramLat * paramLat, paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p6.x = lam * Math.cos(paramLat) / (M6 * (A1 + 3 * A22 * paramLatSq + paramLatPow6 * (7 * A32 + 9 * A42 * paramLatSq)));
  p6.y = paramLat * (A1 + A22 * paramLatSq + paramLatPow6 * (A32 + A42 * paramLatSq));
  p6.x = this.a * p6.x + this.x0;
  p6.y = this.a * p6.y + this.y0;
  return p6;
}
function inverse32(p6) {
  p6.x = (p6.x - this.x0) / this.a;
  p6.y = (p6.y - this.y0) / this.a;
  var EPS = 1e-9, NITER = 12, paramLat = p6.y, paramLatSq, paramLatPow6, fy, fpy, dlat, i7;
  for (i7 = 0; i7 < NITER; ++i7) {
    paramLatSq = paramLat * paramLat;
    paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
    fy = paramLat * (A1 + A22 * paramLatSq + paramLatPow6 * (A32 + A42 * paramLatSq)) - p6.y;
    fpy = A1 + 3 * A22 * paramLatSq + paramLatPow6 * (7 * A32 + 9 * A42 * paramLatSq);
    paramLat -= dlat = fy / fpy;
    if (Math.abs(dlat) < EPS) {
      break;
    }
  }
  paramLatSq = paramLat * paramLat;
  paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p6.x = M6 * p6.x * (A1 + 3 * A22 * paramLatSq + paramLatPow6 * (7 * A32 + 9 * A42 * paramLatSq)) / Math.cos(paramLat);
  p6.y = Math.asin(Math.sin(paramLat) / M6);
  p6.x = adjust_lon_default(p6.x + this.long0);
  return p6;
}
var A1, A22, A32, A42, M6, names34, eqearth_default;
var init_eqearth = __esm({
  "node_modules/proj4/lib/projections/eqearth.js"() {
    init_adjust_lon();
    A1 = 1.340264;
    A22 = -0.081106;
    A32 = 893e-6;
    A42 = 3796e-6;
    M6 = Math.sqrt(3) / 2;
    names34 = ["eqearth", "Equal Earth", "Equal_Earth"];
    eqearth_default = {
      init: init33,
      forward: forward32,
      inverse: inverse32,
      names: names34
    };
  }
});

// node_modules/proj4/lib/projections/bonne.js
function init34() {
  var c7;
  this.phi1 = this.lat1;
  if (Math.abs(this.phi1) < EPS10) {
    throw new Error();
  }
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.m1 = pj_mlfn_default(
      this.phi1,
      this.am1 = Math.sin(this.phi1),
      c7 = Math.cos(this.phi1),
      this.en
    );
    this.am1 = c7 / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1);
    this.inverse = e_inv;
    this.forward = e_fwd;
  } else {
    if (Math.abs(this.phi1) + EPS10 >= HALF_PI) {
      this.cphi1 = 0;
    } else {
      this.cphi1 = 1 / Math.tan(this.phi1);
    }
    this.inverse = s_inv;
    this.forward = s_fwd;
  }
}
function e_fwd(p6) {
  var lam = adjust_lon_default(p6.x - (this.long0 || 0));
  var phi = p6.y;
  var rh, E7, c7;
  rh = this.am1 + this.m1 - pj_mlfn_default(phi, E7 = Math.sin(phi), c7 = Math.cos(phi), this.en);
  E7 = c7 * lam / (rh * Math.sqrt(1 - this.es * E7 * E7));
  p6.x = rh * Math.sin(E7);
  p6.y = this.am1 - rh * Math.cos(E7);
  p6.x = this.a * p6.x + (this.x0 || 0);
  p6.y = this.a * p6.y + (this.y0 || 0);
  return p6;
}
function e_inv(p6) {
  p6.x = (p6.x - (this.x0 || 0)) / this.a;
  p6.y = (p6.y - (this.y0 || 0)) / this.a;
  var s5, rh, lam, phi;
  rh = hypot_default(p6.x, p6.y = this.am1 - p6.y);
  phi = pj_inv_mlfn_default(this.am1 + this.m1 - rh, this.es, this.en);
  if ((s5 = Math.abs(phi)) < HALF_PI) {
    s5 = Math.sin(phi);
    lam = rh * Math.atan2(p6.x, p6.y) * Math.sqrt(1 - this.es * s5 * s5) / Math.cos(phi);
  } else if (Math.abs(s5 - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    throw new Error();
  }
  p6.x = adjust_lon_default(lam + (this.long0 || 0));
  p6.y = adjust_lat_default(phi);
  return p6;
}
function s_fwd(p6) {
  var lam = adjust_lon_default(p6.x - (this.long0 || 0));
  var phi = p6.y;
  var E7, rh;
  rh = this.cphi1 + this.phi1 - phi;
  if (Math.abs(rh) > EPS10) {
    p6.x = rh * Math.sin(E7 = lam * Math.cos(phi) / rh);
    p6.y = this.cphi1 - rh * Math.cos(E7);
  } else {
    p6.x = p6.y = 0;
  }
  p6.x = this.a * p6.x + (this.x0 || 0);
  p6.y = this.a * p6.y + (this.y0 || 0);
  return p6;
}
function s_inv(p6) {
  p6.x = (p6.x - (this.x0 || 0)) / this.a;
  p6.y = (p6.y - (this.y0 || 0)) / this.a;
  var lam, phi;
  var rh = hypot_default(p6.x, p6.y = this.cphi1 - p6.y);
  phi = this.cphi1 + this.phi1 - rh;
  if (Math.abs(phi) > HALF_PI) {
    throw new Error();
  }
  if (Math.abs(Math.abs(phi) - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    lam = rh * Math.atan2(p6.x, p6.y) / Math.cos(phi);
  }
  p6.x = adjust_lon_default(lam + (this.long0 || 0));
  p6.y = adjust_lat_default(phi);
  return p6;
}
var EPS10, names35, bonne_default;
var init_bonne = __esm({
  "node_modules/proj4/lib/projections/bonne.js"() {
    init_adjust_lat();
    init_adjust_lon();
    init_hypot();
    init_pj_enfn();
    init_pj_inv_mlfn();
    init_pj_mlfn();
    init_values();
    EPS10 = 1e-10;
    names35 = ["bonne", "Bonne (Werner lat_1=90)"];
    bonne_default = {
      init: init34,
      names: names35
    };
  }
});

// node_modules/proj4/projs.js
function projs_default(proj43) {
  proj43.Proj.projections.add(tmerc_default);
  proj43.Proj.projections.add(etmerc_default);
  proj43.Proj.projections.add(utm_default);
  proj43.Proj.projections.add(sterea_default);
  proj43.Proj.projections.add(stere_default);
  proj43.Proj.projections.add(somerc_default);
  proj43.Proj.projections.add(omerc_default);
  proj43.Proj.projections.add(lcc_default);
  proj43.Proj.projections.add(krovak_default);
  proj43.Proj.projections.add(cass_default);
  proj43.Proj.projections.add(laea_default);
  proj43.Proj.projections.add(aea_default);
  proj43.Proj.projections.add(gnom_default);
  proj43.Proj.projections.add(cea_default);
  proj43.Proj.projections.add(eqc_default);
  proj43.Proj.projections.add(poly_default);
  proj43.Proj.projections.add(nzmg_default);
  proj43.Proj.projections.add(mill_default);
  proj43.Proj.projections.add(sinu_default);
  proj43.Proj.projections.add(moll_default);
  proj43.Proj.projections.add(eqdc_default);
  proj43.Proj.projections.add(vandg_default);
  proj43.Proj.projections.add(aeqd_default);
  proj43.Proj.projections.add(ortho_default);
  proj43.Proj.projections.add(qsc_default);
  proj43.Proj.projections.add(robin_default);
  proj43.Proj.projections.add(geocent_default);
  proj43.Proj.projections.add(tpers_default);
  proj43.Proj.projections.add(geos_default);
  proj43.Proj.projections.add(eqearth_default);
  proj43.Proj.projections.add(bonne_default);
}
var init_projs = __esm({
  "node_modules/proj4/projs.js"() {
    init_tmerc();
    init_etmerc();
    init_utm2();
    init_sterea();
    init_stere();
    init_somerc();
    init_omerc();
    init_lcc();
    init_krovak();
    init_cass();
    init_laea();
    init_aea();
    init_gnom();
    init_cea();
    init_eqc();
    init_poly();
    init_nzmg();
    init_mill();
    init_sinu();
    init_moll();
    init_eqdc();
    init_vandg();
    init_aeqd();
    init_ortho();
    init_qsc();
    init_robin();
    init_geocent();
    init_tpers();
    init_geos();
    init_eqearth();
    init_bonne();
  }
});

// node_modules/proj4/lib/index.js
var proj42, lib_default;
var init_lib = __esm({
  "node_modules/proj4/lib/index.js"() {
    init_core();
    init_Proj();
    init_Point2();
    init_toPoint();
    init_defs();
    init_nadgrid();
    init_transform3();
    init_mgrs();
    init_projs();
    proj42 = Object.assign(core_default, {
      defaultDatum: "WGS84",
      Proj: Proj_default,
      WGS84: new Proj_default("WGS84"),
      Point: Point_default2,
      toPoint: toPoint_default,
      defs: defs_default,
      nadgrid,
      transform: transform2,
      mgrs: mgrs_default,
      version: "__VERSION__"
    });
    projs_default(proj42);
    lib_default = proj42;
  }
});

// node_modules/@allmaps/project/dist/shared/project-functions.js
var lonLatEquivalentDefinitions, webMercatorEquivalentDefinitions, lonLatProjection, webMercatorProjection, defaultProjectedGcpTransformerOptions, defaultProjectedGcpTransformOptions, lonLatProjectionToWebMecatorProjectionConverter, lonLatToWebMercator, webMercatorToLonLat;
var init_project_functions = __esm({
  "node_modules/@allmaps/project/dist/shared/project-functions.js"() {
    init_lib();
    init_dist6();
    lonLatEquivalentDefinitions = [
      "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees",
      "+proj=longlat +datum=WGS84 +no_defs +type=crs",
      "EPSG:4326",
      "WGS84"
    ];
    webMercatorEquivalentDefinitions = [
      "+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs +type=crs",
      "EPSG:3857",
      "EPSG:3785",
      "GOOGLE",
      "EPSG:900913",
      "EPSG:102113"
    ];
    lonLatProjection = {
      name: "EPSG:4326",
      definition: lonLatEquivalentDefinitions[0]
    };
    webMercatorProjection = {
      name: "EPSG:3857",
      definition: webMercatorEquivalentDefinitions[0]
    };
    defaultProjectedGcpTransformerOptions = {
      internalProjection: webMercatorProjection,
      projection: webMercatorProjection,
      ...defaultGcpTransformerOptions
    };
    defaultProjectedGcpTransformOptions = {
      projection: webMercatorProjection,
      ...defaultGcpTransformerOptions
    };
    lonLatProjectionToWebMecatorProjectionConverter = lib_default(lonLatProjection.definition, webMercatorProjection.definition);
    lonLatToWebMercator = lonLatProjectionToWebMecatorProjectionConverter.forward;
    webMercatorToLonLat = lonLatProjectionToWebMecatorProjectionConverter.inverse;
  }
});

// node_modules/@allmaps/project/dist/projected-transformers/ProjectedGcpTransformer.js
var init_ProjectedGcpTransformer = __esm({
  "node_modules/@allmaps/project/dist/projected-transformers/ProjectedGcpTransformer.js"() {
    init_lib();
    init_dist5();
    init_dist6();
    init_project_functions();
  }
});

// node_modules/@allmaps/project/dist/index.js
var init_dist10 = __esm({
  "node_modules/@allmaps/project/dist/index.js"() {
    init_lib();
    init_ProjectedGcpTransformer();
    init_project_functions();
  }
});

// node_modules/robust-predicates/esm/util.js
function sum(elen, e3, flen, f8, h5) {
  let Q3, Qnew, hh, bvirt;
  let enow = e3[0];
  let fnow = f8[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q3 = enow;
    enow = e3[++eindex];
  } else {
    Q3 = fnow;
    fnow = f8[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q3;
      hh = Q3 - (Qnew - enow);
      enow = e3[++eindex];
    } else {
      Qnew = fnow + Q3;
      hh = Q3 - (Qnew - fnow);
      fnow = f8[++findex];
    }
    Q3 = Qnew;
    if (hh !== 0) {
      h5[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q3 + enow;
        bvirt = Qnew - Q3;
        hh = Q3 - (Qnew - bvirt) + (enow - bvirt);
        enow = e3[++eindex];
      } else {
        Qnew = Q3 + fnow;
        bvirt = Qnew - Q3;
        hh = Q3 - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f8[++findex];
      }
      Q3 = Qnew;
      if (hh !== 0) {
        h5[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q3 + enow;
    bvirt = Qnew - Q3;
    hh = Q3 - (Qnew - bvirt) + (enow - bvirt);
    enow = e3[++eindex];
    Q3 = Qnew;
    if (hh !== 0) {
      h5[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q3 + fnow;
    bvirt = Qnew - Q3;
    hh = Q3 - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f8[++findex];
    Q3 = Qnew;
    if (hh !== 0) {
      h5[hindex++] = hh;
    }
  }
  if (Q3 !== 0 || hindex === 0) {
    h5[hindex++] = Q3;
  }
  return hindex;
}
function sum_three(alen, a5, blen, b8, clen, c7, tmp, out) {
  return sum(sum(alen, a5, blen, b8, tmp), tmp, clen, c7, out);
}
function scale2(elen, e3, b8, h5) {
  let Q3, sum2, hh, product1, product0;
  let bvirt, c7, ahi, alo, bhi, blo;
  c7 = splitter * b8;
  bhi = c7 - (c7 - b8);
  blo = b8 - bhi;
  let enow = e3[0];
  Q3 = enow * b8;
  c7 = splitter * enow;
  ahi = c7 - (c7 - enow);
  alo = enow - ahi;
  hh = alo * blo - (Q3 - ahi * bhi - alo * bhi - ahi * blo);
  let hindex = 0;
  if (hh !== 0) {
    h5[hindex++] = hh;
  }
  for (let i7 = 1; i7 < elen; i7++) {
    enow = e3[i7];
    product1 = enow * b8;
    c7 = splitter * enow;
    ahi = c7 - (c7 - enow);
    alo = enow - ahi;
    product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);
    sum2 = Q3 + product0;
    bvirt = sum2 - Q3;
    hh = Q3 - (sum2 - bvirt) + (product0 - bvirt);
    if (hh !== 0) {
      h5[hindex++] = hh;
    }
    Q3 = product1 + sum2;
    hh = sum2 - (Q3 - product1);
    if (hh !== 0) {
      h5[hindex++] = hh;
    }
  }
  if (Q3 !== 0 || hindex === 0) {
    h5[hindex++] = Q3;
  }
  return hindex;
}
function estimate(elen, e3) {
  let Q3 = e3[0];
  for (let i7 = 1; i7 < elen; i7++) Q3 += e3[i7];
  return Q3;
}
function vec(n6) {
  return new Float64Array(n6);
}
var epsilon, splitter, resulterrbound;
var init_util4 = __esm({
  "node_modules/robust-predicates/esm/util.js"() {
    epsilon = 11102230246251565e-32;
    splitter = 134217729;
    resulterrbound = (3 + 8 * epsilon) * epsilon;
  }
});

// node_modules/robust-predicates/esm/orient2d.js
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c7, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c7 = splitter * acx;
  ahi = c7 - (c7 - acx);
  alo = acx - ahi;
  c7 = splitter * bcy;
  bhi = c7 - (c7 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c7 = splitter * acy;
  ahi = c7 - (c7 - acy);
  alo = acy - ahi;
  c7 = splitter * bcx;
  bhi = c7 - (c7 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B2[3] = u32;
  let det = estimate(4, B2);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c7 = splitter * acxtail;
  ahi = c7 - (c7 - acxtail);
  alo = acxtail - ahi;
  c7 = splitter * bcy;
  bhi = c7 - (c7 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c7 = splitter * acytail;
  ahi = c7 - (c7 - acytail);
  alo = acytail - ahi;
  c7 = splitter * bcx;
  bhi = c7 - (c7 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u5[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u5[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u5[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u5[3] = u32;
  const C1len = sum(4, B2, 4, u5, C12);
  s1 = acx * bcytail;
  c7 = splitter * acx;
  ahi = c7 - (c7 - acx);
  alo = acx - ahi;
  c7 = splitter * bcytail;
  bhi = c7 - (c7 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c7 = splitter * acy;
  ahi = c7 - (c7 - acy);
  alo = acy - ahi;
  c7 = splitter * bcxtail;
  bhi = c7 - (c7 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u5[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u5[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u5[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u5[3] = u32;
  const C2len = sum(C1len, C12, 4, u5, C23);
  s1 = acxtail * bcytail;
  c7 = splitter * acxtail;
  ahi = c7 - (c7 - acxtail);
  alo = acxtail - ahi;
  c7 = splitter * bcytail;
  bhi = c7 - (c7 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c7 = splitter * acytail;
  ahi = c7 - (c7 - acytail);
  alo = acytail - ahi;
  c7 = splitter * bcxtail;
  bhi = c7 - (c7 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u5[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u5[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u5[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u5[3] = u32;
  const Dlen = sum(C2len, C23, 4, u5, D4);
  return D4[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
var ccwerrboundA, ccwerrboundB, ccwerrboundC, B2, C12, C23, D4, u5;
var init_orient2d = __esm({
  "node_modules/robust-predicates/esm/orient2d.js"() {
    init_util4();
    ccwerrboundA = (3 + 16 * epsilon) * epsilon;
    ccwerrboundB = (2 + 12 * epsilon) * epsilon;
    ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
    B2 = vec(4);
    C12 = vec(8);
    C23 = vec(12);
    D4 = vec(16);
    u5 = vec(4);
  }
});

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA, o3derrboundB, o3derrboundC, bc, ca, ab, at_b, at_c, bt_c, bt_a, ct_a, ct_b, bct, cat, abt, u6, _8, _8b, _16, _12, fin, fin2;
var init_orient3d = __esm({
  "node_modules/robust-predicates/esm/orient3d.js"() {
    init_util4();
    o3derrboundA = (7 + 56 * epsilon) * epsilon;
    o3derrboundB = (3 + 28 * epsilon) * epsilon;
    o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
    bc = vec(4);
    ca = vec(4);
    ab = vec(4);
    at_b = vec(4);
    at_c = vec(4);
    bt_c = vec(4);
    bt_a = vec(4);
    ct_a = vec(4);
    ct_b = vec(4);
    bct = vec(8);
    cat = vec(8);
    abt = vec(8);
    u6 = vec(4);
    _8 = vec(8);
    _8b = vec(8);
    _16 = vec(8);
    _12 = vec(12);
    fin = vec(192);
    fin2 = vec(192);
  }
});

// node_modules/robust-predicates/esm/incircle.js
function finadd(finlen, a5, alen) {
  finlen = sum(finlen, fin3, a5, alen, fin22);
  const tmp = fin3;
  fin3 = fin22;
  fin22 = tmp;
  return finlen;
}
function incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {
  let finlen;
  let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;
  let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;
  let abtlen, bctlen, catlen;
  let abttlen, bcttlen, cattlen;
  let n1, n0;
  let bvirt, c7, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  s1 = bdx * cdy;
  c7 = splitter * bdx;
  ahi = c7 - (c7 - bdx);
  alo = bdx - ahi;
  c7 = splitter * cdy;
  bhi = c7 - (c7 - cdy);
  blo = cdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cdx * bdy;
  c7 = splitter * cdx;
  ahi = c7 - (c7 - cdx);
  alo = cdx - ahi;
  c7 = splitter * bdy;
  bhi = c7 - (c7 - bdy);
  blo = bdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bc2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bc2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  bc2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  bc2[3] = u32;
  s1 = cdx * ady;
  c7 = splitter * cdx;
  ahi = c7 - (c7 - cdx);
  alo = cdx - ahi;
  c7 = splitter * ady;
  bhi = c7 - (c7 - ady);
  blo = ady - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = adx * cdy;
  c7 = splitter * adx;
  ahi = c7 - (c7 - adx);
  alo = adx - ahi;
  c7 = splitter * cdy;
  bhi = c7 - (c7 - cdy);
  blo = cdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ca2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ca2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  ca2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  ca2[3] = u32;
  s1 = adx * bdy;
  c7 = splitter * adx;
  ahi = c7 - (c7 - adx);
  alo = adx - ahi;
  c7 = splitter * bdy;
  bhi = c7 - (c7 - bdy);
  blo = bdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = bdx * ady;
  c7 = splitter * bdx;
  ahi = c7 - (c7 - bdx);
  alo = bdx - ahi;
  c7 = splitter * ady;
  bhi = c7 - (c7 - ady);
  blo = ady - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ab2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ab2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  ab2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  ab2[3] = u32;
  finlen = sum(
    sum(
      sum(
        scale2(scale2(4, bc2, adx, _82), _82, adx, _162),
        _162,
        scale2(scale2(4, bc2, ady, _82), _82, ady, _16b),
        _16b,
        _32
      ),
      _32,
      sum(
        scale2(scale2(4, ca2, bdx, _82), _82, bdx, _162),
        _162,
        scale2(scale2(4, ca2, bdy, _82), _82, bdy, _16b),
        _16b,
        _32b
      ),
      _32b,
      _64
    ),
    _64,
    sum(
      scale2(scale2(4, ab2, cdx, _82), _82, cdx, _162),
      _162,
      scale2(scale2(4, ab2, cdy, _82), _82, cdy, _16b),
      _16b,
      _32
    ),
    _32,
    fin3
  );
  let det = estimate(finlen, fin3);
  let errbound = iccerrboundB * permanent;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - adx;
  adxtail = ax - (adx + bvirt) + (bvirt - dx);
  bvirt = ay - ady;
  adytail = ay - (ady + bvirt) + (bvirt - dy);
  bvirt = bx - bdx;
  bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
  bvirt = by - bdy;
  bdytail = by - (bdy + bvirt) + (bvirt - dy);
  bvirt = cx - cdx;
  cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
  bvirt = cy - cdy;
  cdytail = cy - (cdy + bvirt) + (bvirt - dy);
  if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) {
    return det;
  }
  errbound = iccerrboundC * permanent + resulterrbound * Math.abs(det);
  det += (adx * adx + ady * ady) * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + 2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx) + ((bdx * bdx + bdy * bdy) * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + 2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) + ((cdx * cdx + cdy * cdy) * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + 2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
    s1 = adx * adx;
    c7 = splitter * adx;
    ahi = c7 - (c7 - adx);
    alo = adx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = ady * ady;
    c7 = splitter * ady;
    ahi = c7 - (c7 - ady);
    alo = ady - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    aa[2] = _j - (u32 - bvirt) + (_i - bvirt);
    aa[3] = u32;
  }
  if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
    s1 = bdx * bdx;
    c7 = splitter * bdx;
    ahi = c7 - (c7 - bdx);
    alo = bdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = bdy * bdy;
    c7 = splitter * bdy;
    ahi = c7 - (c7 - bdy);
    alo = bdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    bb[2] = _j - (u32 - bvirt) + (_i - bvirt);
    bb[3] = u32;
  }
  if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
    s1 = cdx * cdx;
    c7 = splitter * cdx;
    ahi = c7 - (c7 - cdx);
    alo = cdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = cdy * cdy;
    c7 = splitter * cdy;
    ahi = c7 - (c7 - cdy);
    alo = cdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    cc[2] = _j - (u32 - bvirt) + (_i - bvirt);
    cc[3] = u32;
  }
  if (adxtail !== 0) {
    axtbclen = scale2(4, bc2, adxtail, axtbc);
    finlen = finadd(finlen, sum_three(
      scale2(axtbclen, axtbc, 2 * adx, _162),
      _162,
      scale2(scale2(4, cc, adxtail, _82), _82, bdy, _16b),
      _16b,
      scale2(scale2(4, bb, adxtail, _82), _82, -cdy, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (adytail !== 0) {
    aytbclen = scale2(4, bc2, adytail, aytbc);
    finlen = finadd(finlen, sum_three(
      scale2(aytbclen, aytbc, 2 * ady, _162),
      _162,
      scale2(scale2(4, bb, adytail, _82), _82, cdx, _16b),
      _16b,
      scale2(scale2(4, cc, adytail, _82), _82, -bdx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (bdxtail !== 0) {
    bxtcalen = scale2(4, ca2, bdxtail, bxtca);
    finlen = finadd(finlen, sum_three(
      scale2(bxtcalen, bxtca, 2 * bdx, _162),
      _162,
      scale2(scale2(4, aa, bdxtail, _82), _82, cdy, _16b),
      _16b,
      scale2(scale2(4, cc, bdxtail, _82), _82, -ady, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (bdytail !== 0) {
    bytcalen = scale2(4, ca2, bdytail, bytca);
    finlen = finadd(finlen, sum_three(
      scale2(bytcalen, bytca, 2 * bdy, _162),
      _162,
      scale2(scale2(4, cc, bdytail, _82), _82, adx, _16b),
      _16b,
      scale2(scale2(4, aa, bdytail, _82), _82, -cdx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (cdxtail !== 0) {
    cxtablen = scale2(4, ab2, cdxtail, cxtab);
    finlen = finadd(finlen, sum_three(
      scale2(cxtablen, cxtab, 2 * cdx, _162),
      _162,
      scale2(scale2(4, bb, cdxtail, _82), _82, ady, _16b),
      _16b,
      scale2(scale2(4, aa, cdxtail, _82), _82, -bdy, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (cdytail !== 0) {
    cytablen = scale2(4, ab2, cdytail, cytab);
    finlen = finadd(finlen, sum_three(
      scale2(cytablen, cytab, 2 * cdy, _162),
      _162,
      scale2(scale2(4, aa, cdytail, _82), _82, bdx, _16b),
      _16b,
      scale2(scale2(4, bb, cdytail, _82), _82, -adx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (adxtail !== 0 || adytail !== 0) {
    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
      s1 = bdxtail * cdy;
      c7 = splitter * bdxtail;
      ahi = c7 - (c7 - bdxtail);
      alo = bdxtail - ahi;
      c7 = splitter * cdy;
      bhi = c7 - (c7 - cdy);
      blo = cdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * cdytail;
      c7 = splitter * bdx;
      ahi = c7 - (c7 - bdx);
      alo = bdx - ahi;
      c7 = splitter * cdytail;
      bhi = c7 - (c7 - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u7[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u7[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u7[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u7[3] = u32;
      s1 = cdxtail * -bdy;
      c7 = splitter * cdxtail;
      ahi = c7 - (c7 - cdxtail);
      alo = cdxtail - ahi;
      c7 = splitter * -bdy;
      bhi = c7 - (c7 - -bdy);
      blo = -bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * -bdytail;
      c7 = splitter * cdx;
      ahi = c7 - (c7 - cdx);
      alo = cdx - ahi;
      c7 = splitter * -bdytail;
      bhi = c7 - (c7 - -bdytail);
      blo = -bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v4[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v4[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v4[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v4[3] = u32;
      bctlen = sum(4, u7, 4, v4, bct2);
      s1 = bdxtail * cdytail;
      c7 = splitter * bdxtail;
      ahi = c7 - (c7 - bdxtail);
      alo = bdxtail - ahi;
      c7 = splitter * cdytail;
      bhi = c7 - (c7 - cdytail);
      blo = cdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdxtail * bdytail;
      c7 = splitter * cdxtail;
      ahi = c7 - (c7 - cdxtail);
      alo = cdxtail - ahi;
      c7 = splitter * bdytail;
      bhi = c7 - (c7 - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      bctt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      bctt[3] = u32;
      bcttlen = 4;
    } else {
      bct2[0] = 0;
      bctlen = 1;
      bctt[0] = 0;
      bcttlen = 1;
    }
    if (adxtail !== 0) {
      const len = scale2(bctlen, bct2, adxtail, _16c);
      finlen = finadd(finlen, sum(
        scale2(axtbclen, axtbc, adxtail, _162),
        _162,
        scale2(len, _16c, 2 * adx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(bcttlen, bctt, adxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * adx, _162),
        _162,
        scale2(len2, _82, adxtail, _16b),
        _16b,
        scale2(len, _16c, adxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (bdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, cc, adxtail, _82), _82, bdytail, _162), _162);
      }
      if (cdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, bb, -adxtail, _82), _82, cdytail, _162), _162);
      }
    }
    if (adytail !== 0) {
      const len = scale2(bctlen, bct2, adytail, _16c);
      finlen = finadd(finlen, sum(
        scale2(aytbclen, aytbc, adytail, _162),
        _162,
        scale2(len, _16c, 2 * ady, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(bcttlen, bctt, adytail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * ady, _162),
        _162,
        scale2(len2, _82, adytail, _16b),
        _16b,
        scale2(len, _16c, adytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  if (bdxtail !== 0 || bdytail !== 0) {
    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
      s1 = cdxtail * ady;
      c7 = splitter * cdxtail;
      ahi = c7 - (c7 - cdxtail);
      alo = cdxtail - ahi;
      c7 = splitter * ady;
      bhi = c7 - (c7 - ady);
      blo = ady - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * adytail;
      c7 = splitter * cdx;
      ahi = c7 - (c7 - cdx);
      alo = cdx - ahi;
      c7 = splitter * adytail;
      bhi = c7 - (c7 - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u7[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u7[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u7[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u7[3] = u32;
      n1 = -cdy;
      n0 = -cdytail;
      s1 = adxtail * n1;
      c7 = splitter * adxtail;
      ahi = c7 - (c7 - adxtail);
      alo = adxtail - ahi;
      c7 = splitter * n1;
      bhi = c7 - (c7 - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * n0;
      c7 = splitter * adx;
      ahi = c7 - (c7 - adx);
      alo = adx - ahi;
      c7 = splitter * n0;
      bhi = c7 - (c7 - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v4[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v4[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v4[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v4[3] = u32;
      catlen = sum(4, u7, 4, v4, cat2);
      s1 = cdxtail * adytail;
      c7 = splitter * cdxtail;
      ahi = c7 - (c7 - cdxtail);
      alo = cdxtail - ahi;
      c7 = splitter * adytail;
      bhi = c7 - (c7 - adytail);
      blo = adytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adxtail * cdytail;
      c7 = splitter * adxtail;
      ahi = c7 - (c7 - adxtail);
      alo = adxtail - ahi;
      c7 = splitter * cdytail;
      bhi = c7 - (c7 - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      catt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      catt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      catt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      catt[3] = u32;
      cattlen = 4;
    } else {
      cat2[0] = 0;
      catlen = 1;
      catt[0] = 0;
      cattlen = 1;
    }
    if (bdxtail !== 0) {
      const len = scale2(catlen, cat2, bdxtail, _16c);
      finlen = finadd(finlen, sum(
        scale2(bxtcalen, bxtca, bdxtail, _162),
        _162,
        scale2(len, _16c, 2 * bdx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(cattlen, catt, bdxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * bdx, _162),
        _162,
        scale2(len2, _82, bdxtail, _16b),
        _16b,
        scale2(len, _16c, bdxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (cdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, aa, bdxtail, _82), _82, cdytail, _162), _162);
      }
      if (adytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, cc, -bdxtail, _82), _82, adytail, _162), _162);
      }
    }
    if (bdytail !== 0) {
      const len = scale2(catlen, cat2, bdytail, _16c);
      finlen = finadd(finlen, sum(
        scale2(bytcalen, bytca, bdytail, _162),
        _162,
        scale2(len, _16c, 2 * bdy, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(cattlen, catt, bdytail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * bdy, _162),
        _162,
        scale2(len2, _82, bdytail, _16b),
        _16b,
        scale2(len, _16c, bdytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  if (cdxtail !== 0 || cdytail !== 0) {
    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
      s1 = adxtail * bdy;
      c7 = splitter * adxtail;
      ahi = c7 - (c7 - adxtail);
      alo = adxtail - ahi;
      c7 = splitter * bdy;
      bhi = c7 - (c7 - bdy);
      blo = bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * bdytail;
      c7 = splitter * adx;
      ahi = c7 - (c7 - adx);
      alo = adx - ahi;
      c7 = splitter * bdytail;
      bhi = c7 - (c7 - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u7[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u7[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u7[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u7[3] = u32;
      n1 = -ady;
      n0 = -adytail;
      s1 = bdxtail * n1;
      c7 = splitter * bdxtail;
      ahi = c7 - (c7 - bdxtail);
      alo = bdxtail - ahi;
      c7 = splitter * n1;
      bhi = c7 - (c7 - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * n0;
      c7 = splitter * bdx;
      ahi = c7 - (c7 - bdx);
      alo = bdx - ahi;
      c7 = splitter * n0;
      bhi = c7 - (c7 - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v4[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v4[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v4[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v4[3] = u32;
      abtlen = sum(4, u7, 4, v4, abt2);
      s1 = adxtail * bdytail;
      c7 = splitter * adxtail;
      ahi = c7 - (c7 - adxtail);
      alo = adxtail - ahi;
      c7 = splitter * bdytail;
      bhi = c7 - (c7 - bdytail);
      blo = bdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdxtail * adytail;
      c7 = splitter * bdxtail;
      ahi = c7 - (c7 - bdxtail);
      alo = bdxtail - ahi;
      c7 = splitter * adytail;
      bhi = c7 - (c7 - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      abtt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      abtt[3] = u32;
      abttlen = 4;
    } else {
      abt2[0] = 0;
      abtlen = 1;
      abtt[0] = 0;
      abttlen = 1;
    }
    if (cdxtail !== 0) {
      const len = scale2(abtlen, abt2, cdxtail, _16c);
      finlen = finadd(finlen, sum(
        scale2(cxtablen, cxtab, cdxtail, _162),
        _162,
        scale2(len, _16c, 2 * cdx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(abttlen, abtt, cdxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * cdx, _162),
        _162,
        scale2(len2, _82, cdxtail, _16b),
        _16b,
        scale2(len, _16c, cdxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (adytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, bb, cdxtail, _82), _82, adytail, _162), _162);
      }
      if (bdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, aa, -cdxtail, _82), _82, bdytail, _162), _162);
      }
    }
    if (cdytail !== 0) {
      const len = scale2(abtlen, abt2, cdytail, _16c);
      finlen = finadd(finlen, sum(
        scale2(cytablen, cytab, cdytail, _162),
        _162,
        scale2(len, _16c, 2 * cdy, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(abttlen, abtt, cdytail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * cdy, _162),
        _162,
        scale2(len2, _82, cdytail, _16b),
        _16b,
        scale2(len, _16c, cdytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  return fin3[finlen - 1];
}
function incircle(ax, ay, bx, by, cx, cy, dx, dy) {
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  const bdxcdy = bdx * cdy;
  const cdxbdy = cdx * bdy;
  const alift = adx * adx + ady * ady;
  const cdxady = cdx * ady;
  const adxcdy = adx * cdy;
  const blift = bdx * bdx + bdy * bdy;
  const adxbdy = adx * bdy;
  const bdxady = bdx * ady;
  const clift = cdx * cdx + cdy * cdy;
  const det = alift * (bdxcdy - cdxbdy) + blift * (cdxady - adxcdy) + clift * (adxbdy - bdxady);
  const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift + (Math.abs(cdxady) + Math.abs(adxcdy)) * blift + (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;
  const errbound = iccerrboundA * permanent;
  if (det > errbound || -det > errbound) {
    return det;
  }
  return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);
}
var iccerrboundA, iccerrboundB, iccerrboundC, bc2, ca2, ab2, aa, bb, cc, u7, v4, axtbc, aytbc, bxtca, bytca, cxtab, cytab, abt2, bct2, cat2, abtt, bctt, catt, _82, _162, _16b, _16c, _32, _32b, _48, _64, fin3, fin22;
var init_incircle = __esm({
  "node_modules/robust-predicates/esm/incircle.js"() {
    init_util4();
    iccerrboundA = (10 + 96 * epsilon) * epsilon;
    iccerrboundB = (4 + 48 * epsilon) * epsilon;
    iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
    bc2 = vec(4);
    ca2 = vec(4);
    ab2 = vec(4);
    aa = vec(4);
    bb = vec(4);
    cc = vec(4);
    u7 = vec(4);
    v4 = vec(4);
    axtbc = vec(8);
    aytbc = vec(8);
    bxtca = vec(8);
    bytca = vec(8);
    cxtab = vec(8);
    cytab = vec(8);
    abt2 = vec(8);
    bct2 = vec(8);
    cat2 = vec(8);
    abtt = vec(4);
    bctt = vec(4);
    catt = vec(4);
    _82 = vec(8);
    _162 = vec(16);
    _16b = vec(16);
    _16c = vec(16);
    _32 = vec(32);
    _32b = vec(32);
    _48 = vec(48);
    _64 = vec(64);
    fin3 = vec(1152);
    fin22 = vec(1152);
  }
});

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA, isperrboundB, isperrboundC, ab3, bc3, cd, de3, ea, ac, bd, ce2, da, eb, abc, bcd, cde, dea, eab, abd, bce, cda, deb, eac, adet, bdet, cdet, ddet, edet, abdet, cddet, cdedet, deter, _83, _8b2, _8c, _163, _24, _482, _48b, _96, _192, _384x, _384y, _384z, _768, xdet, ydet, zdet, fin4;
var init_insphere = __esm({
  "node_modules/robust-predicates/esm/insphere.js"() {
    init_util4();
    isperrboundA = (16 + 224 * epsilon) * epsilon;
    isperrboundB = (5 + 72 * epsilon) * epsilon;
    isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
    ab3 = vec(4);
    bc3 = vec(4);
    cd = vec(4);
    de3 = vec(4);
    ea = vec(4);
    ac = vec(4);
    bd = vec(4);
    ce2 = vec(4);
    da = vec(4);
    eb = vec(4);
    abc = vec(24);
    bcd = vec(24);
    cde = vec(24);
    dea = vec(24);
    eab = vec(24);
    abd = vec(24);
    bce = vec(24);
    cda = vec(24);
    deb = vec(24);
    eac = vec(24);
    adet = vec(1152);
    bdet = vec(1152);
    cdet = vec(1152);
    ddet = vec(1152);
    edet = vec(1152);
    abdet = vec(2304);
    cddet = vec(2304);
    cdedet = vec(3456);
    deter = vec(5760);
    _83 = vec(8);
    _8b2 = vec(8);
    _8c = vec(8);
    _163 = vec(16);
    _24 = vec(24);
    _482 = vec(48);
    _48b = vec(48);
    _96 = vec(96);
    _192 = vec(192);
    _384x = vec(384);
    _384y = vec(384);
    _384z = vec(384);
    _768 = vec(768);
    xdet = vec(96);
    ydet = vec(96);
    zdet = vec(96);
    fin4 = vec(1152);
  }
});

// node_modules/robust-predicates/index.js
var init_robust_predicates = __esm({
  "node_modules/robust-predicates/index.js"() {
    init_orient2d();
    init_orient3d();
    init_incircle();
    init_insphere();
  }
});

// node_modules/point-in-polygon-hao/dist/esm/index.js
var init_esm = __esm({
  "node_modules/point-in-polygon-hao/dist/esm/index.js"() {
    init_robust_predicates();
  }
});

// node_modules/@allmaps/render/dist/maps/RTree.js
var init_RTree = __esm({
  "node_modules/@allmaps/render/dist/maps/RTree.js"() {
    init_rbush();
    init_esm();
    init_dist5();
  }
});

// node_modules/@allmaps/render/dist/maps/WarpedMapList.js
var init_WarpedMapList = __esm({
  "node_modules/@allmaps/render/dist/maps/WarpedMapList.js"() {
    init_dist8();
    init_dist9();
    init_dist10();
    init_RTree();
    init_dist5();
    init_events2();
  }
});

// node_modules/@allmaps/render/dist/tilecache/FetchableTile.js
var init_FetchableTile = __esm({
  "node_modules/@allmaps/render/dist/tilecache/FetchableTile.js"() {
    init_tiles();
  }
});

// node_modules/@allmaps/render/dist/renderers/BaseRenderer.js
var MAX_MAP_OVERVIEW_RESOLUTION;
var init_BaseRenderer = __esm({
  "node_modules/@allmaps/render/dist/renderers/BaseRenderer.js"() {
    init_TileCache();
    init_WarpedMapList();
    init_FetchableTile();
    init_events2();
    init_tiles();
    init_dist5();
    init_dist10();
    MAX_MAP_OVERVIEW_RESOLUTION = 1024 * 1024;
  }
});

// node_modules/@allmaps/triangulate/dist/shared.js
var init_shared2 = __esm({
  "node_modules/@allmaps/triangulate/dist/shared.js"() {
    init_esm();
    init_dist5();
  }
});

// node_modules/@kninnug/constrainautor/lib/Constrainautor.mjs
function nextEdge(e3) {
  return e3 % 3 === 2 ? e3 - 2 : e3 + 1;
}
function prevEdge(e3) {
  return e3 % 3 === 0 ? e3 + 2 : e3 - 1;
}
function intersectSegments(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
  const x0 = orient2d(p1x, p1y, p3x, p3y, p4x, p4y), y0 = orient2d(p2x, p2y, p3x, p3y, p4x, p4y);
  if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0) {
    return false;
  }
  const x1 = orient2d(p3x, p3y, p1x, p1y, p2x, p2y), y1 = orient2d(p4x, p4y, p1x, p1y, p2x, p2y);
  if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0) {
    return false;
  }
  if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return !(Math.max(p3x, p4x) < Math.min(p1x, p2x) || Math.max(p1x, p2x) < Math.min(p3x, p4x) || Math.max(p3y, p4y) < Math.min(p1y, p2y) || Math.max(p1y, p2y) < Math.min(p3y, p4y));
  }
  return true;
}
var BitSet, BitSet8, Constrainautor;
var init_Constrainautor = __esm({
  "node_modules/@kninnug/constrainautor/lib/Constrainautor.mjs"() {
    init_robust_predicates();
    BitSet = class {
      constructor(W2, bs) {
        this.W = W2;
        this.bs = bs;
      }
      /**
       * Add a number to the set.
       *
       * @param idx The number to add. Must be 0 <= idx < len.
       * @return this.
       */
      add(idx) {
        const W2 = this.W, byte = idx / W2 | 0, bit = idx % W2;
        this.bs[byte] |= 1 << bit;
        return this;
      }
      /**
       * Delete a number from the set.
       *
       * @param idx The number to delete. Must be 0 <= idx < len.
       * @return this.
       */
      delete(idx) {
        const W2 = this.W, byte = idx / W2 | 0, bit = idx % W2;
        this.bs[byte] &= ~(1 << bit);
        return this;
      }
      /**
       * Add or delete a number in the set, depending on the second argument.
       *
       * @param idx The number to add or delete. Must be 0 <= idx < len.
       * @param val If true, add the number, otherwise delete.
       * @return val.
       */
      set(idx, val) {
        const W2 = this.W, byte = idx / W2 | 0, bit = idx % W2, m8 = 1 << bit;
        this.bs[byte] ^= (-val ^ this.bs[byte]) & m8;
        return val;
      }
      /**
       * Whether the number is in the set.
       *
       * @param idx The number to test. Must be 0 <= idx < len.
       * @return True if the number is in the set.
       */
      has(idx) {
        const W2 = this.W, byte = idx / W2 | 0, bit = idx % W2;
        return !!(this.bs[byte] & 1 << bit);
      }
      /**
       * Iterate over the numbers that are in the set. The callback is invoked
       * with each number that is set. It is allowed to change the BitSet during
       * iteration. If it deletes a number that has not been iterated over, that
       * number will not show up in a later call. If it adds a number during
       * iteration, that number may or may not show up in a later call.
       *
       * @param fn The function to call for each number.
       * @return this.
       */
      forEach(fn4) {
        const W2 = this.W, bs = this.bs, len = bs.length;
        for (let byte = 0; byte < len; byte++) {
          let bit = 0;
          while (bs[byte] && bit < W2) {
            if (bs[byte] & 1 << bit) {
              fn4(byte * W2 + bit);
            }
            bit++;
          }
        }
        return this;
      }
    };
    BitSet8 = class extends BitSet {
      /**
       * Create a bit set.
       *
       * @param len The length of the bit set, limiting the maximum value that
       *        can be stored in it to len - 1.
       */
      constructor(len) {
        const W2 = 8, bs = new Uint8Array(Math.ceil(len / W2)).fill(0);
        super(W2, bs);
      }
    };
    Constrainautor = class {
      /**
       * Make a Constrainautor.
       *
       * @param del The triangulation output from Delaunator.
       * @param edges If provided, constrain these edges as by constrainAll.
       */
      constructor(del, edges) {
        if (!del || typeof del !== "object" || !del.triangles || !del.halfedges || !del.coords) {
          throw new Error("Expected an object with Delaunator output");
        }
        if (del.triangles.length % 3 || del.halfedges.length !== del.triangles.length || del.coords.length % 2) {
          throw new Error("Delaunator output appears inconsistent");
        }
        if (del.triangles.length < 3) {
          throw new Error("No edges in triangulation");
        }
        this.del = del;
        const U32NIL = 2 ** 32 - 1, numPoints = del.coords.length >> 1, numEdges = del.triangles.length;
        this.vertMap = new Uint32Array(numPoints).fill(U32NIL);
        this.flips = new BitSet8(numEdges);
        this.consd = new BitSet8(numEdges);
        for (let e3 = 0; e3 < numEdges; e3++) {
          const v5 = del.triangles[e3];
          if (this.vertMap[v5] === U32NIL) {
            this.updateVert(e3);
          }
        }
        if (edges) {
          this.constrainAll(edges);
        }
      }
      /**
       * Constrain the triangulation such that there is an edge between p1 and p2.
       *
       * @param segP1 The index of one segment end-point in the coords array.
       * @param segP2 The index of the other segment end-point in the coords array.
       * @return The id of the edge that points from p1 to p2. If the
       *         constrained edge lies on the hull and points in the opposite
       *         direction (p2 to p1), the negative of its id is returned.
       */
      constrainOne(segP1, segP2) {
        const { triangles, halfedges } = this.del, vm = this.vertMap, consd = this.consd, start2 = vm[segP1];
        let edg = start2;
        do {
          const p43 = triangles[edg], nxt = nextEdge(edg);
          if (p43 === segP2) {
            return this.protect(edg);
          }
          const opp = prevEdge(edg), p33 = triangles[opp];
          if (p33 === segP2) {
            this.protect(nxt);
            return nxt;
          }
          if (this.intersectSegments(segP1, segP2, p33, p43)) {
            edg = opp;
            break;
          }
          const adj = halfedges[nxt];
          edg = adj;
        } while (edg !== -1 && edg !== start2);
        let conEdge = edg;
        let rescan = -1;
        while (edg !== -1) {
          const adj = halfedges[edg], bot = prevEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj);
          if (adj === -1) {
            throw new Error("Constraining edge exited the hull");
          }
          if (consd.has(edg)) {
            throw new Error("Edge intersects already constrained edge");
          }
          if (this.isCollinear(segP1, segP2, triangles[edg]) || this.isCollinear(segP1, segP2, triangles[adj])) {
            throw new Error("Constraining edge intersects point");
          }
          const convex = this.intersectSegments(triangles[edg], triangles[adj], triangles[bot], triangles[top]);
          if (!convex) {
            if (rescan === -1) {
              rescan = edg;
            }
            if (triangles[top] === segP2) {
              if (edg === rescan) {
                throw new Error("Infinite loop: non-convex quadrilateral");
              }
              edg = rescan;
              rescan = -1;
              continue;
            }
            if (this.intersectSegments(segP1, segP2, triangles[top], triangles[adj])) {
              edg = top;
            } else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {
              edg = rgt;
            } else if (rescan === edg) {
              throw new Error("Infinite loop: no further intersect after non-convex");
            }
            continue;
          }
          this.flipDiagonal(edg);
          if (this.intersectSegments(segP1, segP2, triangles[bot], triangles[top])) {
            if (rescan === -1) {
              rescan = bot;
            }
            if (rescan === bot) {
              throw new Error("Infinite loop: flipped diagonal still intersects");
            }
          }
          if (triangles[top] === segP2) {
            conEdge = top;
            edg = rescan;
            rescan = -1;
          } else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {
            edg = rgt;
          }
        }
        const flips = this.flips;
        this.protect(conEdge);
        do {
          var flipped = 0;
          flips.forEach((edg2) => {
            flips.delete(edg2);
            const adj = halfedges[edg2];
            if (adj === -1) {
              return;
            }
            flips.delete(adj);
            if (!this.isDelaunay(edg2)) {
              this.flipDiagonal(edg2);
              flipped++;
            }
          });
        } while (flipped > 0);
        return this.findEdge(segP1, segP2);
      }
      /**
       * Fix the Delaunay condition. It is no longer necessary to call this
       * method after constraining (many) edges, since constrainOne will do it
       * after each.
       *
       * @param deep If true, keep checking & flipping edges until all
       *        edges are Delaunay, otherwise only check the edges once.
       * @return The triangulation object.
       */
      delaunify(deep = false) {
        const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd, len = halfedges.length;
        do {
          var flipped = 0;
          for (let edg = 0; edg < len; edg++) {
            if (consd.has(edg)) {
              continue;
            }
            flips.delete(edg);
            const adj = halfedges[edg];
            if (adj === -1) {
              continue;
            }
            flips.delete(adj);
            if (!this.isDelaunay(edg)) {
              this.flipDiagonal(edg);
              flipped++;
            }
          }
        } while (deep && flipped > 0);
        return this;
      }
      /**
       * Call constrainOne on each edge, and delaunify afterwards.
       *
       * @param edges The edges to constrain: each element is an array with
       *        [p1, p2] which are indices into the points array originally
       *        supplied to Delaunator.
       * @return The triangulation object.
       */
      constrainAll(edges) {
        const len = edges.length;
        for (let i7 = 0; i7 < len; i7++) {
          const e3 = edges[i7];
          this.constrainOne(e3[0], e3[1]);
        }
        return this;
      }
      /**
       * Whether an edge is a constrained edge.
       *
       * @param edg The edge id.
       * @return True if the edge is constrained.
       */
      isConstrained(edg) {
        return this.consd.has(edg);
      }
      /**
       * Find the edge that points from p1 -> p2. If there is only an edge from
       * p2 -> p1 (i.e. it is on the hull), returns the negative id of it.
       *
       * @param p1 The index of the first point into the points array.
       * @param p2 The index of the second point into the points array.
       * @return The id of the edge that points from p1 -> p2, or the negative
       *         id of the edge that goes from p2 -> p1, or Infinity if there is
       *         no edge between p1 and p2.
       */
      findEdge(p12, p23) {
        const start1 = this.vertMap[p23], { triangles, halfedges } = this.del;
        let edg = start1, prv = -1;
        do {
          if (triangles[edg] === p12) {
            return edg;
          }
          prv = nextEdge(edg);
          edg = halfedges[prv];
        } while (edg !== -1 && edg !== start1);
        if (triangles[nextEdge(prv)] === p12) {
          return -prv;
        }
        return Infinity;
      }
      /**
       * Mark an edge as constrained, i.e. should not be touched by `delaunify`.
       *
       * @private
       * @param edg The edge id.
       * @return If edg has an adjacent, returns that, otherwise -edg.
       */
      protect(edg) {
        const adj = this.del.halfedges[edg], flips = this.flips, consd = this.consd;
        flips.delete(edg);
        consd.add(edg);
        if (adj !== -1) {
          flips.delete(adj);
          consd.add(adj);
          return adj;
        }
        return -edg;
      }
      /**
       * Mark an edge as flipped, unless it is already marked as constrained.
       *
       * @private
       * @param edg The edge id.
       * @return True if edg was not constrained.
       */
      markFlip(edg) {
        const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd;
        if (consd.has(edg)) {
          return false;
        }
        const adj = halfedges[edg];
        if (adj !== -1) {
          flips.add(edg);
          flips.add(adj);
        }
        return true;
      }
      /**
       * Flip the edge shared by two triangles.
       *
       * @private
       * @param edg The edge shared by the two triangles, must have an
       *        adjacent half-edge.
       * @return The new diagonal.
       */
      flipDiagonal(edg) {
        const { triangles, halfedges } = this.del, flips = this.flips, consd = this.consd, adj = halfedges[edg], bot = prevEdge(edg), lft = nextEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj), adjBot = halfedges[bot], adjTop = halfedges[top];
        if (consd.has(edg)) {
          throw new Error("Trying to flip a constrained edge");
        }
        triangles[edg] = triangles[top];
        halfedges[edg] = adjTop;
        if (!flips.set(edg, flips.has(top))) {
          consd.set(edg, consd.has(top));
        }
        if (adjTop !== -1) {
          halfedges[adjTop] = edg;
        }
        halfedges[bot] = top;
        triangles[adj] = triangles[bot];
        halfedges[adj] = adjBot;
        if (!flips.set(adj, flips.has(bot))) {
          consd.set(adj, consd.has(bot));
        }
        if (adjBot !== -1) {
          halfedges[adjBot] = adj;
        }
        halfedges[top] = bot;
        this.markFlip(edg);
        this.markFlip(lft);
        this.markFlip(adj);
        this.markFlip(rgt);
        flips.add(bot);
        consd.delete(bot);
        flips.add(top);
        consd.delete(top);
        this.updateVert(edg);
        this.updateVert(lft);
        this.updateVert(adj);
        this.updateVert(rgt);
        return bot;
      }
      /**
       * Whether the two triangles sharing edg conform to the Delaunay condition.
       * As a shortcut, if the given edge has no adjacent (is on the hull), it is
       * certainly Delaunay.
       *
       * @private
       * @param edg The edge shared by the triangles to test.
       * @return True if they are Delaunay.
       */
      isDelaunay(edg) {
        const { triangles, halfedges } = this.del, adj = halfedges[edg];
        if (adj === -1) {
          return true;
        }
        const p12 = triangles[prevEdge(edg)], p23 = triangles[edg], p33 = triangles[nextEdge(edg)], px = triangles[prevEdge(adj)];
        return !this.inCircle(p12, p23, p33, px);
      }
      /**
       * Update the vertex -> incoming edge map.
       *
       * @private
       * @param start The id of an *outgoing* edge.
       * @return The id of the right-most incoming edge.
       */
      updateVert(start2) {
        const { triangles, halfedges } = this.del, vm = this.vertMap, v5 = triangles[start2];
        let inc = prevEdge(start2), adj = halfedges[inc];
        while (adj !== -1 && adj !== start2) {
          inc = prevEdge(adj);
          adj = halfedges[inc];
        }
        vm[v5] = inc;
        return inc;
      }
      /**
       * Whether the segment between [p1, p2] intersects with [p3, p4]. When the
       * segments share an end-point (e.g. p1 == p3 etc.), they are not considered
       * intersecting.
       *
       * @private
       * @param p1 The index of point 1 into this.del.coords.
       * @param p2 The index of point 2 into this.del.coords.
       * @param p3 The index of point 3 into this.del.coords.
       * @param p4 The index of point 4 into this.del.coords.
       * @return True if the segments intersect.
       */
      intersectSegments(p12, p23, p33, p43) {
        const pts = this.del.coords;
        if (p12 === p33 || p12 === p43 || p23 === p33 || p23 === p43) {
          return false;
        }
        return intersectSegments(pts[p12 * 2], pts[p12 * 2 + 1], pts[p23 * 2], pts[p23 * 2 + 1], pts[p33 * 2], pts[p33 * 2 + 1], pts[p43 * 2], pts[p43 * 2 + 1]);
      }
      /**
       * Whether point px is in the circumcircle of the triangle formed by p1, p2,
       * and p3 (which are in counter-clockwise order).
       *
       * @param p1 The index of point 1 into this.del.coords.
       * @param p2 The index of point 2 into this.del.coords.
       * @param p3 The index of point 3 into this.del.coords.
       * @param px The index of point x into this.del.coords.
       * @return True if (px, py) is in the circumcircle.
       */
      inCircle(p12, p23, p33, px) {
        const pts = this.del.coords;
        return incircle(pts[p12 * 2], pts[p12 * 2 + 1], pts[p23 * 2], pts[p23 * 2 + 1], pts[p33 * 2], pts[p33 * 2 + 1], pts[px * 2], pts[px * 2 + 1]) < 0;
      }
      /**
       * Whether point p1, p2, and p are collinear.
       *
       * @private
       * @param p1 The index of segment point 1 into this.del.coords.
       * @param p2 The index of segment point 2 into this.del.coords.
       * @param p The index of the point p into this.del.coords.
       * @return True if the points are collinear.
       */
      isCollinear(p12, p23, p6) {
        const pts = this.del.coords;
        return orient2d(pts[p12 * 2], pts[p12 * 2 + 1], pts[p23 * 2], pts[p23 * 2 + 1], pts[p6 * 2], pts[p6 * 2 + 1]) === 0;
      }
    };
    Constrainautor.intersectSegments = intersectSegments;
  }
});

// node_modules/@allmaps/triangulate/dist/index.js
var init_dist11 = __esm({
  "node_modules/@allmaps/triangulate/dist/index.js"() {
    init_shared2();
    init_dist5();
    init_Constrainautor();
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image.1.js
var image1ProfileUriRegex, Image1ProfileUri, Image1ProfileSchema, Image1ContextString, Image1ContextStringIncorrect, Image1Context, Image1Schema;
var init_image_1 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image.1.js"() {
    init_zod();
    image1ProfileUriRegex = /^https?:\/\/library.stanford.edu\/iiif\/image-api\/1.1\/compliance.html#level(?<level>[012])$/;
    Image1ProfileUri = external_exports.string().regex(image1ProfileUriRegex);
    Image1ProfileSchema = Image1ProfileUri;
    Image1ContextString = "http://library.stanford.edu/iiif/image-api/1.1/context.json";
    Image1ContextStringIncorrect = "http://iiif.io/api/image/1/context.json";
    Image1Context = external_exports.literal(Image1ContextString);
    Image1Schema = external_exports.object({
      "@context": Image1Context,
      "@id": external_exports.string().url(),
      profile: Image1ProfileUri.optional(),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      scale_factors: external_exports.number().array().optional(),
      tile_width: external_exports.number().optional(),
      tile_height: external_exports.number().optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/shared.js
var SizeSchema, TilesetSchema, imageServiceTypes, ImageServiceTypesSchema, ValidNavDateSchema, NavDateSchema, NavPlaceSchema;
var init_shared3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/shared.js"() {
    init_zod();
    SizeSchema = external_exports.object({
      width: external_exports.number().int(),
      height: external_exports.number().int()
    });
    TilesetSchema = external_exports.object({
      width: external_exports.number().int(),
      height: external_exports.number().int().optional(),
      scaleFactors: external_exports.array(external_exports.number().int())
    });
    imageServiceTypes = [
      "ImageService1",
      "ImageService2",
      "ImageService3"
    ];
    ImageServiceTypesSchema = external_exports.enum(imageServiceTypes);
    ValidNavDateSchema = external_exports.coerce.date();
    NavDateSchema = external_exports.union([
      ValidNavDateSchema,
      // Catchall for incorrect values
      external_exports.any()
    ]).transform((val) => {
      const { success, data } = ValidNavDateSchema.safeParse(val);
      if (success) {
        return data;
      }
    });
    NavPlaceSchema = external_exports.object({}).passthrough();
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image.2.js
function isValidImage2ProfileArrayItem(item) {
  return item !== void 0;
}
var image2ProfileUriRegex, Image2ProfileUri, Image2ProfileDescriptionSchema, ValidImage2ProfileArrayItemSchema, Image2ProfileSchema, Image2ContextString, Image2Context, Image2Schema;
var init_image_2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image.2.js"() {
    init_zod();
    init_shared3();
    image2ProfileUriRegex = /^https?:\/\/iiif.io\/api\/image\/2.*level(?<level>[012])(.json)?$/;
    Image2ProfileUri = external_exports.string().regex(image2ProfileUriRegex);
    Image2ProfileDescriptionSchema = external_exports.object({
      formats: external_exports.string().array().optional(),
      maxArea: external_exports.number().int().optional(),
      maxHeight: external_exports.number().int().optional(),
      maxWidth: external_exports.number().int().optional(),
      qualities: external_exports.string().array().optional(),
      supports: external_exports.string().array().optional()
    });
    ValidImage2ProfileArrayItemSchema = external_exports.union([
      Image2ProfileUri,
      Image2ProfileDescriptionSchema
    ]);
    Image2ProfileSchema = external_exports.union([
      Image2ProfileUri,
      external_exports.array(external_exports.union([
        ValidImage2ProfileArrayItemSchema,
        // Catchall for incorrect profiles
        external_exports.unknown()
      ]).transform((val) => {
        const { success, data } = ValidImage2ProfileArrayItemSchema.safeParse(val);
        if (success) {
          return data;
        }
      }))
    ]).transform((val) => {
      if (val && Array.isArray(val)) {
        const firstProfile = val[0];
        if (typeof firstProfile !== "string") {
          throw new Error("First profile must be a string");
        }
        return [
          firstProfile,
          ...val.slice(1).filter(isValidImage2ProfileArrayItem)
        ];
      }
      return val;
    });
    Image2ContextString = "http://iiif.io/api/image/2/context.json";
    Image2Context = external_exports.union([
      external_exports.literal(Image2ContextString),
      // Invalid, but used by https://iiif.archivelab.org
      external_exports.literal("https://iiif.io/api/image/2/context.json"),
      external_exports.string().url()
    ]);
    Image2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.union([external_exports.literal("iiif:Image"), external_exports.literal("ImageService2")]).optional(),
      "@context": Image2Context,
      protocol: external_exports.literal("http://iiif.io/api/image"),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      profile: Image2ProfileSchema,
      sizes: SizeSchema.array().optional(),
      tiles: TilesetSchema.array().optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image.3.js
var image3Profiles, Image3ProfileSchema, Image3Schema;
var init_image_3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image.3.js"() {
    init_zod();
    init_shared3();
    image3Profiles = ["level0", "level1", "level2"];
    Image3ProfileSchema = external_exports.enum(image3Profiles);
    Image3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("ImageService3"),
      protocol: external_exports.literal("http://iiif.io/api/image"),
      profile: Image3ProfileSchema,
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      maxWidth: external_exports.number().int().optional(),
      maxHeight: external_exports.number().int().optional(),
      maxArea: external_exports.number().int().optional(),
      sizes: SizeSchema.array().optional(),
      tiles: TilesetSchema.array().optional(),
      extraFeatures: external_exports.string().array().optional()
      // TODO: add partOf, seeAlso, and service
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image-service.2.js
var ImageService2Schema;
var init_image_service_2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image-service.2.js"() {
    init_zod();
    init_image_1();
    init_image_2();
    init_image_3();
    init_shared3();
    ImageService2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": ImageServiceTypesSchema.optional(),
      profile: external_exports.union([
        Image1ProfileSchema,
        Image2ProfileSchema,
        Image3ProfileSchema
      ]),
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional(),
      "@context": external_exports.union([
        Image1Context,
        external_exports.literal("http://iiif.io/api/image/1/context.json"),
        Image2Context
      ]).optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image-service.3.js
var complianceLevels, Presentation3ImageService2Schema, Presentation3ImageService3Schema, ImageService3Schema;
var init_image_service_3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image-service.3.js"() {
    init_zod();
    init_image_2();
    init_shared3();
    complianceLevels = ["level0", "level1", "level2"];
    Presentation3ImageService2Schema = external_exports.union([
      external_exports.object({
        id: external_exports.string().url(),
        type: external_exports.literal("ImageService2"),
        profile: Image2ProfileSchema
      }),
      external_exports.object({
        "@id": external_exports.string().url(),
        "@type": external_exports.literal("ImageService2"),
        profile: Image2ProfileSchema
      })
    ]);
    Presentation3ImageService3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: ImageServiceTypesSchema,
      profile: external_exports.enum(complianceLevels)
    });
    ImageService3Schema = external_exports.union([
      Presentation3ImageService2Schema,
      Presentation3ImageService3Schema
    ]);
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image-service.js
var ImageServiceSchema2;
var init_image_service = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image-service.js"() {
    init_zod();
    init_image_service_2();
    init_image_service_3();
    ImageServiceSchema2 = external_exports.union([
      ImageService2Schema,
      ImageService3Schema
    ]);
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/convert.js
function ensureArray2(val) {
  if (val) {
    return Array.isArray(val) ? val : [val];
  }
}
function parseVersion2String(str) {
  if (typeof str === "string") {
    return {
      none: [str]
    };
  } else if (Array.isArray(str)) {
    let strings = {};
    str.forEach((item) => {
      if (typeof item === "string") {
        if (!strings["none"]) {
          strings["none"] = [];
        }
        strings["none"].push(item);
      } else if (typeof item === "object") {
        strings = { ...strings, ...parseVersion2String(item) };
      } else {
        throw new Error("Unable to parse string");
      }
    });
    return strings;
  } else if (str && typeof str === "object") {
    str;
    const language = str["@language"] || "none";
    const valueOrValues = str["@value"] || "";
    return {
      [language]: Array.isArray(valueOrValues) ? valueOrValues : [valueOrValues]
    };
  }
}
function parseVersion3String(str) {
  if (!str) {
    return;
  }
  const parsedStr = {};
  for (const language in str) {
    parsedStr[language] = str[language];
  }
  return parsedStr;
}
function parseMetadata2Item(item) {
  if (item) {
    const label = parseVersion2String(item.label);
    const value = parseVersion2String(item.value);
    if (label && value) {
      return { label, value };
    }
  }
}
function parseMetadata3Item(item) {
  if (item) {
    const label = parseVersion3String(item.label);
    const value = parseVersion3String(item.value);
    if (label && value) {
      return { label, value };
    }
  }
}
function isValidMetadataItem(item) {
  return item !== void 0;
}
function parseVersion2Metadata(metadata) {
  if (Array.isArray(metadata)) {
    if (metadata.length === 0) {
      return void 0;
    }
    return metadata.map(parseMetadata2Item).filter(isValidMetadataItem);
  } else if (!metadata) {
    return void 0;
  } else {
    throw new Error("Unable to parse metadata");
  }
}
function parseVersion3Metadata(metadata) {
  if (Array.isArray(metadata)) {
    if (metadata.length === 0) {
      return void 0;
    }
    return metadata.map(parseMetadata3Item).filter(isValidMetadataItem);
  } else if (!metadata) {
    return void 0;
  } else {
    throw new Error("Unable to parse metadata");
  }
}
function parseVersion2Attribution(attribution) {
  if (attribution) {
    if (typeof attribution === "string") {
      return {
        label: {
          none: ["Attribution"]
        },
        value: {
          none: [attribution]
        }
      };
    } else {
      const value = parseVersion2String(attribution);
      if (value) {
        return {
          label: {
            none: ["Attribution"]
          },
          value
        };
      }
    }
  }
}
function parseVersion2Thumbnail(thumbnail2) {
  return thumbnail2?.map((thumbnail) => {
    if (typeof thumbnail === "string") {
      return {
        id: thumbnail
      };
    } else {
      return {
        id: thumbnail["@id"],
        type: thumbnail["@type"],
        format: thumbnail.format,
        width: thumbnail.width,
        height: thumbnail.height
      };
    }
  });
}
function parseVersion2Rendering(rendering2) {
  return rendering2?.map((rendering) => ({
    id: rendering["@id"],
    type: rendering["@type"],
    label: parseVersion2String(rendering.label),
    format: rendering.format
  }));
}
function parseVersion2Related(related) {
  if (related) {
    if (typeof related === "string") {
      return [
        {
          id: related
        }
      ];
    } else if (Array.isArray(related)) {
      return related.map((item) => {
        return {
          id: item["@id"],
          label: parseVersion2String(item.label),
          format: item.format
        };
      });
    } else {
      return [
        {
          id: related["@id"],
          label: parseVersion2String(related.label),
          format: related.format
        }
      ];
    }
  }
}
var LanguageString3Schema, MetadataStringItem3Schema;
var init_convert2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/convert.js"() {
    init_zod();
    LanguageString3Schema = external_exports.record(external_exports.string(), external_exports.string().array());
    MetadataStringItem3Schema = external_exports.object({
      label: LanguageString3Schema.optional(),
      value: LanguageString3Schema.optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/presentation.2.js
var SingleValue2Schema, Value2Schema, RelatedItem2Schema, Related2Schema, ThumbnailItem2Schema, Thumbnail2Schema, RenderingItem2Schema, Rendering2Schema, ValidLanguageValue2Schema, LanguageValue2Schema, PossibleLanguageValue2Schema, Attribution2Schema, ValidMetadataItem2Schema, MetadataItem2Schema, Metadata2Schema, ImageResource2Schema, Annotation2Schema, Canvas2Schema, Sequence2Schema, Manifest2Schema, EmbeddedManifest2Schema, Collection2Schema, EmbeddedCollection2Schema;
var init_presentation_2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/presentation.2.js"() {
    init_zod();
    init_image_service();
    init_shared3();
    init_convert2();
    SingleValue2Schema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]).transform((val) => String(val));
    Value2Schema = external_exports.union([
      SingleValue2Schema.array(),
      SingleValue2Schema
    ]);
    RelatedItem2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      format: external_exports.string().optional(),
      label: Value2Schema.optional()
    });
    Related2Schema = external_exports.union([
      RelatedItem2Schema.array(),
      RelatedItem2Schema,
      SingleValue2Schema
    ]);
    ThumbnailItem2Schema = external_exports.union([
      external_exports.string(),
      external_exports.object({
        "@id": external_exports.string().url(),
        "@type": external_exports.string().optional(),
        format: external_exports.string().optional(),
        height: external_exports.number().optional(),
        width: external_exports.number().optional()
      })
    ]);
    Thumbnail2Schema = external_exports.union([ThumbnailItem2Schema.array(), ThumbnailItem2Schema]).transform(ensureArray2);
    RenderingItem2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.string().optional(),
      label: Value2Schema.optional(),
      format: external_exports.string().optional()
    });
    Rendering2Schema = external_exports.union([RenderingItem2Schema.array(), RenderingItem2Schema]).transform(ensureArray2);
    ValidLanguageValue2Schema = external_exports.union([
      external_exports.object({ "@value": Value2Schema, "@language": external_exports.string().optional() }),
      // This is invalid but some IIIF manifests use this incorrect format
      external_exports.object({ value: Value2Schema, language: external_exports.string().optional() })
    ]).transform((val) => {
      if ("value" in val) {
        return {
          "@value": val.value,
          "@language": val.language
        };
      } else {
        return val;
      }
    });
    LanguageValue2Schema = ValidLanguageValue2Schema;
    PossibleLanguageValue2Schema = external_exports.union([
      LanguageValue2Schema.array(),
      LanguageValue2Schema,
      Value2Schema
    ]);
    Attribution2Schema = external_exports.union([
      external_exports.string(),
      PossibleLanguageValue2Schema
    ]);
    ValidMetadataItem2Schema = external_exports.object({
      label: PossibleLanguageValue2Schema.optional(),
      value: PossibleLanguageValue2Schema.optional()
    });
    MetadataItem2Schema = external_exports.union([
      ValidMetadataItem2Schema,
      // Catchall for incorrect values
      external_exports.any()
    ]).transform((val) => {
      const { success, data } = ValidMetadataItem2Schema.safeParse(val);
      if (success) {
        return data;
      }
    });
    Metadata2Schema = MetadataItem2Schema.array();
    ImageResource2Schema = external_exports.object({
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional(),
      service: ImageServiceSchema2
    });
    Annotation2Schema = external_exports.object({
      resource: ImageResource2Schema
    });
    Canvas2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Canvas"),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      images: Annotation2Schema.array().length(1),
      label: PossibleLanguageValue2Schema.optional(),
      description: PossibleLanguageValue2Schema.optional(),
      related: Related2Schema.optional(),
      attribution: Attribution2Schema.optional(),
      thumbnail: Thumbnail2Schema.optional(),
      rendering: Rendering2Schema.optional(),
      metadata: Metadata2Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional()
    });
    Sequence2Schema = external_exports.object({
      canvases: Canvas2Schema.array().nonempty()
    });
    Manifest2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Manifest"),
      sequences: Sequence2Schema.array().length(1),
      label: PossibleLanguageValue2Schema.optional(),
      description: PossibleLanguageValue2Schema.optional(),
      metadata: Metadata2Schema.optional(),
      related: Related2Schema.optional(),
      attribution: Attribution2Schema.optional(),
      rendering: Rendering2Schema.optional(),
      thumbnail: Thumbnail2Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional()
    });
    EmbeddedManifest2Schema = external_exports.lazy(() => external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Manifest"),
      label: PossibleLanguageValue2Schema.optional()
    }));
    Collection2Schema = external_exports.lazy(() => external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Collection"),
      manifests: EmbeddedManifest2Schema.array().optional(),
      collections: Collection2Schema.array().optional(),
      members: external_exports.union([
        EmbeddedManifest2Schema,
        Collection2Schema,
        EmbeddedCollection2Schema
      ]).array().optional(),
      label: PossibleLanguageValue2Schema.optional(),
      description: PossibleLanguageValue2Schema.optional(),
      metadata: Metadata2Schema.optional(),
      related: Related2Schema.optional(),
      attribution: Attribution2Schema.optional(),
      thumbnail: Thumbnail2Schema.optional(),
      rendering: Rendering2Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional()
    }));
    EmbeddedCollection2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Collection"),
      label: PossibleLanguageValue2Schema.optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/presentation.3.js
var SingleValue3Schema, LanguageValue3Schema, Summary3Schema, HomepageItem3Schema, Rendering3ItemSchema, Rendering3Schema, Homepage3Schema, ThumbnailItem3Schema, Thumbnail3Schema, SeeAlsoItem3Schema, SeeAlso3Schema, NonPaintingAnnotations3, ValidMetadataItem3Schema, MetadataItem3Schema, Metadata3Schema, RequiredStatement3Schema, AnnotationBody3Schema, Choice3Schema, Annotation3Schema, AnnotationPage3Schema, Canvas3Schema2, Manifest3Schema, EmbeddedManifest3Schema, Collection3Schema, EmbeddedCollection3Schema;
var init_presentation_3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/presentation.3.js"() {
    init_zod();
    init_image_service();
    init_shared3();
    init_convert2();
    SingleValue3Schema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]).transform((val) => String(val));
    LanguageValue3Schema = external_exports.record(external_exports.string(), SingleValue3Schema.array());
    Summary3Schema = LanguageValue3Schema;
    HomepageItem3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      label: LanguageValue3Schema,
      format: external_exports.string().optional(),
      language: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional()
    });
    Rendering3ItemSchema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      label: LanguageValue3Schema,
      format: external_exports.string().optional()
    });
    Rendering3Schema = external_exports.union([Rendering3ItemSchema.array(), Rendering3ItemSchema]).transform(ensureArray2);
    Homepage3Schema = external_exports.union([HomepageItem3Schema.array(), HomepageItem3Schema]).transform(ensureArray2);
    ThumbnailItem3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      format: external_exports.string().optional(),
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional()
    });
    Thumbnail3Schema = external_exports.union([ThumbnailItem3Schema.array(), ThumbnailItem3Schema]).transform(ensureArray2);
    SeeAlsoItem3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      format: external_exports.string().optional(),
      profile: external_exports.string().optional()
    });
    SeeAlso3Schema = external_exports.union([SeeAlsoItem3Schema.array(), SeeAlsoItem3Schema]).transform(ensureArray2);
    NonPaintingAnnotations3 = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("AnnotationPage"),
      items: external_exports.object({}).passthrough().array().optional()
    }).array();
    ValidMetadataItem3Schema = external_exports.object({
      label: LanguageValue3Schema,
      value: LanguageValue3Schema
    });
    MetadataItem3Schema = external_exports.union([
      ValidMetadataItem3Schema,
      // Catchall for incorrect values
      external_exports.any()
    ]).transform((val) => {
      const { success, data } = ValidMetadataItem3Schema.safeParse(val);
      if (success) {
        return data;
      }
    });
    Metadata3Schema = MetadataItem3Schema.array();
    RequiredStatement3Schema = MetadataItem3Schema;
    AnnotationBody3Schema = external_exports.object({
      type: external_exports.literal("Image"),
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional(),
      service: ImageServiceSchema2.array()
    });
    Choice3Schema = external_exports.object({
      type: external_exports.literal("Choice"),
      items: AnnotationBody3Schema.array()
    });
    Annotation3Schema = external_exports.object({
      type: external_exports.literal("Annotation"),
      body: external_exports.union([
        AnnotationBody3Schema,
        AnnotationBody3Schema.array().length(1),
        Choice3Schema
      ])
    });
    AnnotationPage3Schema = external_exports.object({
      type: external_exports.literal("AnnotationPage"),
      items: Annotation3Schema.array().length(1)
    });
    Canvas3Schema2 = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Canvas"),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      items: AnnotationPage3Schema.array().length(1),
      label: LanguageValue3Schema.optional(),
      description: LanguageValue3Schema.optional(),
      metadata: Metadata3Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional(),
      homepage: Homepage3Schema.optional(),
      thumbnail: Thumbnail3Schema.optional(),
      rendering: Rendering3Schema.optional(),
      seeAlso: SeeAlso3Schema.optional(),
      summary: Summary3Schema.optional(),
      requiredStatement: RequiredStatement3Schema.optional(),
      annotations: NonPaintingAnnotations3.optional()
    });
    Manifest3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Manifest"),
      items: Canvas3Schema2.array().nonempty(),
      label: LanguageValue3Schema.optional(),
      description: LanguageValue3Schema.optional(),
      metadata: Metadata3Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional(),
      homepage: Homepage3Schema.optional(),
      thumbnail: Thumbnail3Schema.optional(),
      rendering: Rendering3Schema.optional(),
      seeAlso: SeeAlso3Schema.optional(),
      summary: Summary3Schema.optional(),
      requiredStatement: RequiredStatement3Schema.optional(),
      annotations: NonPaintingAnnotations3.optional()
    });
    EmbeddedManifest3Schema = external_exports.lazy(() => external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Manifest"),
      label: LanguageValue3Schema.optional()
    }));
    Collection3Schema = external_exports.lazy(() => external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Collection"),
      items: external_exports.union([
        EmbeddedManifest3Schema,
        Collection3Schema,
        EmbeddedCollection3Schema
      ]).array(),
      label: LanguageValue3Schema.optional(),
      description: LanguageValue3Schema.optional(),
      metadata: Metadata3Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional(),
      homepage: Homepage3Schema.optional(),
      thumbnail: Thumbnail3Schema.optional(),
      rendering: Rendering3Schema.optional(),
      seeAlso: SeeAlso3Schema.optional(),
      summary: Summary3Schema.optional(),
      requiredStatement: RequiredStatement3Schema.optional(),
      annotations: NonPaintingAnnotations3.optional()
    }));
    EmbeddedCollection3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Collection"),
      label: LanguageValue3Schema.optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/iiif.js
var ImageSchema2, CanvasSchema, ManifestSchema, CollectionSchema, IIIF1Schema, IIIF2Schema, IIIF3Schema, IIIFSchema;
var init_iiif = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/iiif.js"() {
    init_zod();
    init_image_1();
    init_image_2();
    init_image_3();
    init_presentation_2();
    init_presentation_3();
    ImageSchema2 = external_exports.union([Image1Schema, Image2Schema, Image3Schema]);
    CanvasSchema = external_exports.union([Canvas2Schema, Canvas3Schema2]);
    ManifestSchema = external_exports.union([Manifest2Schema, Manifest3Schema]);
    CollectionSchema = external_exports.union([Collection2Schema, Collection3Schema]);
    IIIF1Schema = Image1Schema;
    IIIF2Schema = external_exports.union([
      Collection2Schema,
      Manifest2Schema,
      Canvas2Schema,
      Image2Schema
    ]);
    IIIF3Schema = external_exports.union([
      Collection3Schema,
      Manifest3Schema,
      Canvas3Schema2,
      Image3Schema
    ]);
    IIIFSchema = external_exports.union([IIIF1Schema, IIIF2Schema, IIIF3Schema]);
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/tiles.js
function getTileImageRequest({ width: imageWidth, height: imageHeight }, zoomLevel, column, row) {
  const regionX = column * zoomLevel.originalWidth;
  const regionY = row * zoomLevel.originalHeight;
  const regionWidth = column * zoomLevel.originalWidth + zoomLevel.width * zoomLevel.scaleFactor > imageWidth ? imageWidth - column * zoomLevel.originalWidth : zoomLevel.width * zoomLevel.scaleFactor;
  const regionHeight = row * zoomLevel.originalHeight + zoomLevel.height * zoomLevel.scaleFactor > imageHeight ? imageHeight - row * zoomLevel.originalHeight : zoomLevel.height * zoomLevel.scaleFactor;
  let tileWidth = zoomLevel.width;
  let tileHeight = zoomLevel.height;
  if (regionX + zoomLevel.width * zoomLevel.scaleFactor > imageWidth) {
    tileWidth = Math.floor((imageWidth - regionX + zoomLevel.scaleFactor - 1) / zoomLevel.scaleFactor);
  }
  if (regionY + zoomLevel.height * zoomLevel.scaleFactor > imageHeight) {
    tileHeight = Math.floor((imageHeight - regionY + zoomLevel.scaleFactor - 1) / zoomLevel.scaleFactor);
  }
  return {
    region: {
      x: regionX,
      y: regionY,
      width: regionWidth,
      height: regionHeight
    },
    size: {
      width: tileWidth,
      height: tileHeight
    }
  };
}
function getDefaultTileset({ width: imageWidth, height: imageHeight }, tileWidth = 768) {
  const maxTilesPerSide = Math.max(imageWidth, imageHeight) / tileWidth;
  const maxExponent = Math.ceil(Math.log(maxTilesPerSide) / Math.log(2));
  return {
    scaleFactors: Array.from({ length: maxExponent }, (_5, exponent) => 2 ** exponent),
    // .filter((scaleFactor) => {
    //   if (maxTileSide) {
    //     return tileWidth * scaleFactor <= maxTileSide
    //   } else {
    //     return true
    //   }
    // }),
    width: tileWidth
  };
}
function getTileZoomLevelFromScaleFactor({ width: imageWidth, height: imageHeight }, tileset, scaleFactor) {
  const height = tileset.height || tileset.width;
  const originalWidth = tileset.width * scaleFactor;
  const originalHeight = height * scaleFactor;
  return {
    scaleFactor,
    width: tileset.width,
    height,
    originalWidth,
    originalHeight,
    columns: Math.ceil(imageWidth / originalWidth),
    rows: Math.ceil(imageHeight / originalHeight)
  };
}
function getTileZoomLevelsFromTilesets(imageSize, tilesets) {
  return tilesets.map((tileset) => tileset.scaleFactors.map((scaleFactor) => getTileZoomLevelFromScaleFactor(imageSize, tileset, scaleFactor))).flat();
}
function hasValidTileset(tilesets) {
  if (tilesets.some((tileset) => tileset.width && tileset.scaleFactors && tileset.scaleFactors.length)) {
    return true;
  }
  return false;
}
function getTileZoomLevels(imageSize, tilesets, supportsAnyRegionAndSize) {
  if (!tilesets || !hasValidTileset(tilesets)) {
    if (supportsAnyRegionAndSize) {
      tilesets = [getDefaultTileset(imageSize)];
    } else {
      throw new Error("Image does not support tiles or custom regions and sizes.");
    }
  }
  return getTileZoomLevelsFromTilesets(imageSize, tilesets);
}
var init_tiles2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/tiles.js"() {
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/image-requests.js
function getImageRequestSize(imageSize, containerSize, mode2 = "cover") {
  if (mode2 === "cover" || mode2 === "contain") {
    const widthRatio = containerSize.width / imageSize.width;
    const heightRatio = containerSize.height / imageSize.height;
    const ratio = mode2 === "cover" ? Math.max(widthRatio, heightRatio) : Math.min(widthRatio, heightRatio);
    const width = imageSize.width * ratio;
    const height = imageSize.height * ratio;
    return {
      width,
      height
    };
  } else {
    throw new Error('Mode must be either "cover" or "contain"');
  }
}
function getImageRequest(imageSize, containerSize, mode2 = "cover", { sizes, tileZoomLevels, supportsAnyRegionAndSize, maxWidth, maxHeight, maxArea }) {
  let { width, height } = getImageRequestSize(imageSize, containerSize, mode2);
  if (maxWidth && width > maxWidth) {
    height = height / width * maxWidth;
    width = maxWidth;
  }
  if (maxHeight && height > maxHeight) {
    width = width / height * maxHeight;
    height = maxHeight;
  }
  if (maxArea && width * height > maxArea) {
    const aspectRatio2 = height / width;
    const thumbnailMaxWidth = Math.floor(Math.sqrt(maxArea / aspectRatio2));
    const thumbnailMaxHeight = thumbnailMaxWidth * aspectRatio2;
    width = Math.floor(thumbnailMaxHeight) / aspectRatio2;
    height = width * aspectRatio2;
  }
  const aspectRatio = imageSize.width / imageSize.height;
  width = Math.floor(width);
  height = Math.round(width / aspectRatio);
  if (sizes) {
    let matchingSize;
    for (const size of sizes) {
      const scaleFactor = size.width / width;
      if (scaleFactor >= maxThumbnailDownscale && scaleFactor <= maxThumbnailUpscale) {
        matchingSize = size;
        break;
      }
    }
    if (matchingSize) {
      return {
        size: matchingSize
      };
    }
  }
  if (supportsAnyRegionAndSize) {
    return {
      size: {
        width: Math.round(width),
        height: Math.round(height)
      }
    };
  }
  if (tileZoomLevels) {
    const ratio = imageSize.width / width;
    const nearestZoomLevels = tileZoomLevels.map(({ scaleFactor }, index13) => ({
      index: index13,
      scaleFactor,
      diff: Math.abs(scaleFactor - ratio)
    })).sort((a5, b8) => a5.diff - b8.diff);
    const zoomLevel = tileZoomLevels[nearestZoomLevels[0].index];
    const tilesX = Math.ceil(imageSize.width / (zoomLevel.scaleFactor * tileZoomLevels[0].width));
    const tilesY = Math.ceil(imageSize.height / (zoomLevel.scaleFactor * tileZoomLevels[0].height));
    const thumbnailTiles = [];
    for (let y5 = 0; y5 < tilesY; y5++) {
      const thumbnailRow = [];
      for (let x4 = 0; x4 < tilesX; x4++) {
        const thumbnailTile = getTileImageRequest(imageSize, zoomLevel, x4, y5);
        thumbnailRow.push(thumbnailTile);
      }
      thumbnailTiles.push(thumbnailRow);
    }
    return thumbnailTiles;
  }
  throw new Error("Unable to create thumbnail");
}
var maxThumbnailDownscale, maxThumbnailUpscale;
var init_image_requests = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/image-requests.js"() {
    init_tiles2();
    maxThumbnailDownscale = 0.8;
    maxThumbnailUpscale = 1.5;
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/profile.js
function parseImage1ProfileUri(uri) {
  const match2 = uri.match(image1ProfileUriRegex);
  if (match2 && match2.groups) {
    const level2 = parseInt(match2.groups.level);
    return level2;
  }
}
function parseImage2ProfileUri(uri) {
  const match2 = uri.match(image2ProfileUriRegex);
  if (match2 && match2.groups) {
    const level2 = parseInt(match2.groups.level);
    return level2;
  }
}
function parseImage2ProfileDescription(parsedProfileDescription) {
  return {
    maxWidth: parsedProfileDescription?.maxWidth,
    maxHeight: parsedProfileDescription?.maxHeight,
    maxArea: parsedProfileDescription?.maxArea,
    supportsAnyRegionAndSize: anyRegionAndSizeFeatures.every((feature) => parsedProfileDescription?.supports && parsedProfileDescription?.supports?.includes(feature))
  };
}
function getMajorIiifVersionFromImageService(imageService) {
  if ("type" in imageService && imageService.type === "ImageService3") {
    return 3;
  } else if ("type" in imageService && imageService.type === "ImageService2" || "@type" in imageService && imageService["@type"] === "ImageService2" || "@context" in imageService && imageService["@context"] === Image2ContextString) {
    return 2;
  } else if ("@context" in imageService && (imageService["@context"] === Image1ContextString || imageService["@context"] === Image1ContextStringIncorrect)) {
    return 1;
  } else if ("profile" in imageService) {
    let profile;
    if (Array.isArray(imageService.profile)) {
      profile = imageService.profile[0];
    } else {
      profile = imageService.profile;
    }
    if (profile.match(image1ProfileUriRegex)) {
      return 1;
    } else if (profile.match(image2ProfileUriRegex)) {
      return 2;
    } else {
      return 3;
    }
  } else {
    throw new Error("Unsupported IIIF Image Service");
  }
}
function getProfileProperties(parsedImage) {
  if ("type" in parsedImage || "@type" in parsedImage) {
    const profile = parsedImage.profile;
    let supportsAnyRegionAndSize = false;
    if (profile === "level0" || typeof profile === "string" && profile.endsWith("level0.json")) {
      if ("extraFeatures" in parsedImage) {
        supportsAnyRegionAndSize = anyRegionAndSizeFeatures.every((feature) => parsedImage.extraFeatures && parsedImage.extraFeatures.includes(feature));
      }
    } else {
      supportsAnyRegionAndSize = true;
    }
    return {
      maxWidth: "maxWidth" in parsedImage ? parsedImage.maxWidth : void 0,
      maxHeight: "maxHeight" in parsedImage ? parsedImage.maxHeight : void 0,
      maxArea: "maxArea" in parsedImage ? parsedImage.maxArea : void 0,
      supportsAnyRegionAndSize
    };
  } else if (Array.isArray(parsedImage.profile)) {
    let supportsAnyRegionAndSize = false;
    let maxHeight = Number.NEGATIVE_INFINITY;
    let maxWidth = Number.NEGATIVE_INFINITY;
    let maxArea = Number.NEGATIVE_INFINITY;
    parsedImage.profile.forEach((profile) => {
      if (typeof profile === "string") {
        const profileLevel = parseImage2ProfileUri(profile);
        if (profileLevel) {
          supportsAnyRegionAndSize = supportsAnyRegionAndSize || profileLevel >= 1;
        }
      } else {
        const { maxWidth: profileMaxWidth, maxHeight: profileMaxHeight, maxArea: profileMaxArea, supportsAnyRegionAndSize: profileSupportsAnyRegionAndSize } = parseImage2ProfileDescription(profile);
        if (profileMaxWidth !== void 0) {
          maxWidth = Math.max(profileMaxWidth, maxWidth);
        }
        if (profileMaxHeight !== void 0) {
          maxHeight = Math.max(profileMaxHeight, maxHeight);
        }
        if (profileMaxArea !== void 0) {
          maxArea = Math.max(profileMaxArea, maxArea);
        }
        supportsAnyRegionAndSize = supportsAnyRegionAndSize || profileSupportsAnyRegionAndSize;
      }
    });
    return {
      maxWidth: maxWidth >= 0 ? maxWidth : void 0,
      maxHeight: maxHeight >= 0 ? maxHeight : void 0,
      maxArea: maxArea >= 0 ? maxArea : void 0,
      supportsAnyRegionAndSize
    };
  } else if ("profile" in parsedImage && parsedImage.profile) {
    const profileLevel1 = parseImage1ProfileUri(parsedImage.profile);
    const profileLevel2 = parseImage2ProfileUri(parsedImage.profile);
    if (profileLevel1) {
      return {
        supportsAnyRegionAndSize: profileLevel1 >= 1
      };
    } else if (profileLevel2) {
      return {
        supportsAnyRegionAndSize: profileLevel2 >= 1
      };
    } else {
      return {
        supportsAnyRegionAndSize: false
      };
    }
  } else {
    throw new Error("Invalid Image");
  }
}
var anyRegionAndSizeFeatures;
var init_profile = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/profile.js"() {
    init_image_1();
    init_image_2();
    anyRegionAndSizeFeatures = ["regionByPx", "sizeByWh"];
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/image.js
var ImageTypeString, EmbeddedImage, Image2;
var init_image = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/image.js"() {
    init_iiif();
    init_image_1();
    init_image_2();
    init_tiles2();
    init_image_requests();
    init_profile();
    ImageTypeString = "image";
    EmbeddedImage = class {
      embedded = true;
      uri;
      type = ImageTypeString;
      maxWidth;
      maxHeight;
      maxArea;
      supportsAnyRegionAndSize;
      width;
      height;
      majorVersion;
      constructor(...args) {
        const parsedImage = args[0];
        const parsedCanvas = args[1];
        if (args.length === 2) {
          const parsedEmbeddedImage = args[0];
          let imageService;
          let majorVersion;
          if (Array.isArray(parsedEmbeddedImage.service)) {
            parsedEmbeddedImage.service.forEach((currentImageService) => {
              try {
                const currentMajorVersion = getMajorIiifVersionFromImageService(currentImageService);
                if (!majorVersion || currentMajorVersion > majorVersion) {
                  majorVersion = currentMajorVersion;
                  imageService = currentImageService;
                }
              } catch {
              }
            });
          } else {
            imageService = parsedEmbeddedImage.service;
          }
          if (!imageService) {
            throw new Error("Unsupported IIIF Image Service");
          }
          if ("@id" in imageService) {
            this.uri = imageService["@id"];
          } else if ("id" in imageService) {
            this.uri = imageService.id;
          } else {
            throw new Error("Unsupported IIIF Image Service");
          }
          if ("type" in imageService && imageService.type === "ImageService3") {
            this.majorVersion = 3;
          } else if ("type" in imageService && imageService.type === "ImageService2" || "@type" in imageService && imageService["@type"] === "ImageService2" || "@context" in imageService && imageService["@context"] === Image2ContextString) {
            this.majorVersion = 2;
          } else if ("@context" in imageService && (imageService["@context"] === Image1ContextString || imageService["@context"] === Image1ContextStringIncorrect)) {
            this.majorVersion = 1;
          } else if ("profile" in imageService) {
            let profile;
            if (Array.isArray(imageService.profile) && imageService.profile.length > 0) {
              profile = imageService.profile[0];
            } else if (typeof imageService.profile === "string") {
              profile = imageService.profile;
            } else {
              throw new Error("Unsupported IIIF Image Service");
            }
            if (profile.match(image1ProfileUriRegex)) {
              this.majorVersion = 1;
            } else if (profile.match(image2ProfileUriRegex)) {
              this.majorVersion = 2;
            } else {
              this.majorVersion = 3;
            }
          } else {
            throw new Error("Unsupported IIIF Image Service");
          }
          if ("profile" in imageService) {
            const profileProperties = getProfileProperties(imageService);
            this.supportsAnyRegionAndSize = profileProperties.supportsAnyRegionAndSize;
            this.maxWidth = profileProperties.maxWidth;
            this.maxHeight = profileProperties.maxHeight;
            this.maxArea = profileProperties.maxArea;
          } else {
            this.supportsAnyRegionAndSize = false;
          }
        } else {
          if ("@id" in parsedImage) {
            this.uri = parsedImage["@id"];
          } else if ("id" in parsedImage) {
            this.uri = parsedImage.id;
          } else {
            throw new Error("Unsupported IIIF Image");
          }
          if ("type" in parsedImage && parsedImage.type === "ImageService3") {
            this.majorVersion = 3;
          } else if ("@type" in parsedImage && parsedImage["@type"] === "iiif:Image" || "@context" in parsedImage && parsedImage["@context"] === Image2ContextString) {
            this.majorVersion = 2;
          } else if ("@context" in parsedImage && parsedImage["@context"] === Image1ContextString) {
            this.majorVersion = 1;
          } else {
            throw new Error("Unsupported IIIF Image");
          }
          if ("profile" in parsedImage) {
            const profileProperties = getProfileProperties(parsedImage);
            this.supportsAnyRegionAndSize = profileProperties.supportsAnyRegionAndSize;
            this.maxWidth = profileProperties.maxWidth;
            this.maxHeight = profileProperties.maxHeight;
            this.maxArea = profileProperties.maxArea;
          } else {
            this.supportsAnyRegionAndSize = false;
          }
        }
        if (parsedImage.width !== void 0) {
          this.width = parsedImage.width;
        } else if (parsedCanvas) {
          this.width = parsedCanvas.width;
        } else {
          throw new Error("Width not present on either Canvas or Image Resource");
        }
        if (parsedImage.height !== void 0) {
          this.height = parsedImage.height;
        } else if (parsedCanvas) {
          this.height = parsedCanvas.height;
        } else {
          throw new Error("Height not present on either Canvas or Image Resource");
        }
      }
      /**
       * Generates a IIIF Image API URL for the requested region and size
       * @param imageRequest - Image request object containing the desired region and size of the requested image
       * @returns Image API URL that can be used to fetch the requested image
       */
      getImageUrl(imageRequest) {
        const { region, size } = imageRequest;
        let width;
        let height;
        let regionHeight;
        let regionWidth;
        let urlRegion;
        if (region) {
          urlRegion = `${region.x},${region.y},${region.width},${region.height}`;
          regionHeight = region.height;
          regionWidth = region.width;
        } else {
          urlRegion = "full";
          regionHeight = this.height;
          regionWidth = this.width;
        }
        let urlSize;
        if (size) {
          width = Math.round(size.width);
          height = Math.round(size.height);
          const widthStr = String(width);
          let heightStr = String(height);
          const aspectRatio = regionWidth / regionHeight;
          const aspectRatioWidth = height * aspectRatio;
          const aspectRatioHeight = aspectRatioWidth / aspectRatio;
          if (this.majorVersion <= 2) {
            if (height === Math.round(aspectRatioHeight)) {
              heightStr = "";
            }
          }
          urlSize = `${widthStr},${heightStr}`;
        } else {
          width = this.width;
          height = this.height;
          urlSize = this.majorVersion === 2 ? "full" : "max";
        }
        const area = width * height;
        if (this.maxWidth !== void 0) {
          if (width > this.maxWidth) {
            throw new Error(`Width of requested image is too large: ${width} > ${this.maxWidth}`);
          }
        }
        if (this.maxHeight !== void 0) {
          if (height > this.maxHeight) {
            throw new Error(`Height of requested image is too large: ${height} > ${this.maxHeight}`);
          }
        }
        if (this.maxArea !== void 0) {
          if (area > this.maxArea) {
            throw new Error(`Area of requested image is too large: ${area} > ${this.maxArea}`);
          }
        }
        const quality = this.majorVersion === 1 ? "native" : "default";
        return `${this.uri}/${urlRegion}/${urlSize}/0/${quality}.jpg`;
      }
      getImageRequest(size, mode2 = "cover") {
        return getImageRequest({ width: this.width, height: this.height }, size, mode2, {
          supportsAnyRegionAndSize: this.supportsAnyRegionAndSize,
          maxWidth: this.maxWidth,
          maxHeight: this.maxHeight,
          maxArea: this.maxArea
        });
      }
    };
    Image2 = class _Image extends EmbeddedImage {
      tileZoomLevels;
      sizes;
      embedded = false;
      constructor(parsedImage) {
        super(parsedImage);
        const profileProperties = getProfileProperties(parsedImage);
        let tilesets;
        if ("tiles" in parsedImage) {
          tilesets = parsedImage.tiles;
        }
        this.tileZoomLevels = getTileZoomLevels({ width: this.width, height: this.height }, tilesets, profileProperties.supportsAnyRegionAndSize);
        if ("sizes" in parsedImage) {
          this.sizes = parsedImage.sizes;
        }
      }
      /**
       * Parses a IIIF image and returns a [Image](#image) containing the parsed version
       * @param iiifImage - Source data of IIIF Image
       * @param majorVersion - IIIF API version of Image. If not provided, it will be determined automatically
       * @returns Parsed IIIF Image
       * @static
       */
      static parse(iiifImage, majorVersion = null) {
        let parsedImage;
        if (majorVersion === 1) {
          parsedImage = Image1Schema.parse(iiifImage);
        } else if (majorVersion === 2) {
          parsedImage = Image2Schema.parse(iiifImage);
        } else if (majorVersion === 3) {
          parsedImage = Image3Schema.parse(iiifImage);
        } else {
          parsedImage = ImageSchema2.parse(iiifImage);
        }
        return new _Image(parsedImage);
      }
      // TODO: rename this to getImageRequest
      /**
       * Returns a Image request object for a tile with the requested zoom level, column, and row
       * @param zoomLevel - Desired zoom level of the requested tile
       * @param column - Column of the requested tile
       * @param row - Row of the requested tile
       * @returns Image request object that can be used to fetch the requested tile
       */
      getTileImageRequest(zoomLevel, column, row) {
        return getTileImageRequest({ width: this.width, height: this.height }, zoomLevel, column, row);
      }
      /**
       * Returns a Image request object for the requested region and size
       * @param size - Size of the requested thumbnail
       * @param mode - Desired fit mode of the requested thumbnail
       * @returns Image request object that can be used to fetch the requested thumbnail
       */
      getImageRequest(size, mode2 = "cover") {
        return getImageRequest({ width: this.width, height: this.height }, size, mode2, {
          supportsAnyRegionAndSize: this.supportsAnyRegionAndSize,
          sizes: this.sizes,
          tileZoomLevels: this.tileZoomLevels,
          maxWidth: this.maxWidth,
          maxHeight: this.maxHeight,
          maxArea: this.maxArea
        });
      }
    };
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/canvas.js
var CanvasTypeString, Canvas;
var init_canvas2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/canvas.js"() {
    init_image();
    init_convert2();
    CanvasTypeString = "canvas";
    Canvas = class {
      uri;
      type = CanvasTypeString;
      height;
      width;
      image;
      label;
      description;
      metadata;
      navDate;
      navPlace;
      homepage;
      thumbnail;
      rendering;
      seeAlso;
      summary;
      requiredStatement;
      annotations;
      constructor(parsedCanvas) {
        this.width = parsedCanvas.width;
        this.height = parsedCanvas.height;
        if ("@id" in parsedCanvas) {
          this.uri = parsedCanvas["@id"];
          this.description = parseVersion2String(parsedCanvas.description);
          this.label = parseVersion2String(parsedCanvas.label);
          this.metadata = parseVersion2Metadata(parsedCanvas.metadata);
          this.navDate = parsedCanvas.navDate;
          this.navPlace = parsedCanvas.navPlace;
          this.requiredStatement = parseVersion2Attribution(parsedCanvas.attribution);
          this.thumbnail = parseVersion2Thumbnail(parsedCanvas.thumbnail);
          this.rendering = parseVersion2Rendering(parsedCanvas.rendering);
          this.homepage = parseVersion2Related(parsedCanvas.related);
          this.image = new EmbeddedImage(parsedCanvas.images[0].resource, parsedCanvas);
        } else if ("id" in parsedCanvas) {
          this.uri = parsedCanvas.id;
          this.label = parseVersion3String(parsedCanvas.label);
          this.description = parseVersion3String(parsedCanvas.description);
          this.metadata = parseVersion3Metadata(parsedCanvas.metadata);
          this.navDate = parsedCanvas.navDate;
          this.navPlace = parsedCanvas.navPlace;
          this.homepage = parsedCanvas.homepage;
          this.thumbnail = parsedCanvas.thumbnail;
          this.rendering = parsedCanvas.rendering;
          this.seeAlso = parsedCanvas.seeAlso;
          this.summary = parsedCanvas.summary;
          this.requiredStatement = parsedCanvas.requiredStatement;
          this.annotations = parsedCanvas.annotations;
          const annotationBodyOrBodies = parsedCanvas.items[0].items[0].body;
          let annotationBody;
          if (Array.isArray(annotationBodyOrBodies)) {
            annotationBody = annotationBodyOrBodies[0];
          } else if (annotationBodyOrBodies.type === "Image") {
            annotationBody = annotationBodyOrBodies;
          } else if (annotationBodyOrBodies.type === "Choice") {
            annotationBody = annotationBodyOrBodies.items[0];
          } else {
            throw new Error("Invalid IIIF Canvas");
          }
          this.image = new EmbeddedImage(annotationBody, parsedCanvas);
        } else {
          throw new Error("Invalid IIIF Canvas");
        }
      }
    };
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/manifest.js
var ManifestTypeString, EmbeddedManifest, Manifest;
var init_manifest = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/manifest.js"() {
    init_iiif();
    init_image();
    init_canvas2();
    init_convert2();
    ManifestTypeString = "manifest";
    EmbeddedManifest = class {
      embedded = true;
      uri;
      type = ManifestTypeString;
      label;
      majorVersion;
      constructor(parsedManifest) {
        if ("@type" in parsedManifest) {
          this.uri = parsedManifest["@id"];
          this.majorVersion = 2;
          this.label = parseVersion2String(parsedManifest.label);
        } else if ("type" in parsedManifest) {
          this.uri = parsedManifest.id;
          this.majorVersion = 3;
          this.label = parseVersion3String(parsedManifest.label);
        } else {
          throw new Error("Unsupported Manifest");
        }
      }
    };
    Manifest = class _Manifest extends EmbeddedManifest {
      canvases = [];
      description;
      metadata;
      navDate;
      navPlace;
      homepage;
      thumbnail;
      rendering;
      seeAlso;
      summary;
      requiredStatement;
      annotations;
      embedded = false;
      constructor(parsedManifest) {
        super(parsedManifest);
        if ("@type" in parsedManifest) {
          this.description = parseVersion2String(parsedManifest.description);
          this.metadata = parseVersion2Metadata(parsedManifest.metadata);
          const sequence = parsedManifest.sequences[0];
          this.canvases = sequence.canvases.map((canvas) => new Canvas(canvas));
          this.navDate = parsedManifest.navDate;
          this.navPlace = parsedManifest.navPlace;
          this.requiredStatement = parseVersion2Attribution(parsedManifest.attribution);
          this.thumbnail = parseVersion2Thumbnail(parsedManifest.thumbnail);
          this.rendering = parseVersion2Rendering(parsedManifest.rendering);
          this.homepage = parseVersion2Related(parsedManifest.related);
        } else if ("type" in parsedManifest) {
          this.description = parseVersion3String(parsedManifest.description);
          this.metadata = parseVersion3Metadata(parsedManifest.metadata);
          this.metadata = parseVersion3Metadata(parsedManifest.metadata);
          this.navDate = parsedManifest.navDate;
          this.navPlace = parsedManifest.navPlace;
          this.homepage = parsedManifest.homepage;
          this.thumbnail = parsedManifest.thumbnail;
          this.rendering = parsedManifest.rendering;
          this.seeAlso = parsedManifest.seeAlso;
          this.summary = parsedManifest.summary;
          this.requiredStatement = parsedManifest.requiredStatement;
          this.annotations = parsedManifest.annotations;
          this.canvases = parsedManifest.items.map((canvas) => new Canvas(canvas));
        } else {
          throw new Error("Unsupported Manifest");
        }
      }
      /**
       * Parses a IIIF resource and returns a [Manifest](#manifest) containing the parsed version
       * @param iiifManifest - Source data of IIIF Manifest
       * @param majorVersion - IIIF API version of Manifest. If not provided, it will be determined automatically
       * @returns Parsed IIIF Manifest
       */
      static parse(iiifManifest, majorVersion = null) {
        let parsedManifest;
        if (majorVersion === 2) {
          parsedManifest = Manifest2Schema.parse(iiifManifest);
        } else if (majorVersion === 3) {
          parsedManifest = Manifest3Schema.parse(iiifManifest);
        } else {
          parsedManifest = ManifestSchema.parse(iiifManifest);
        }
        return new _Manifest(parsedManifest);
      }
      get images() {
        return this.canvases.map((canvas) => canvas.image);
      }
      async #fetchImage(image, fetchFn) {
        if (image instanceof EmbeddedImage) {
          const url = `${image.uri}/info.json`;
          const iiifImage = await fetchFn(url).then((response) => response.json());
          const fetchedImage = Image2.parse(iiifImage);
          return fetchedImage;
        } else {
          return image;
        }
      }
      async fetchAll(fetchFn = globalThis.fetch) {
        const results = [];
        for await (const next of this.fetchNext(fetchFn)) {
          results.push(next);
        }
        return results;
      }
      async *fetchNext(fetchFn = globalThis.fetch, depth = 0) {
        for (const canvas of this.canvases) {
          const fetchedImage = await this.#fetchImage(canvas.image, fetchFn);
          canvas.image = fetchedImage;
          yield {
            item: fetchedImage,
            depth,
            parent: {
              uri: this.uri,
              type: this.type
            }
          };
        }
      }
      // TODO: implement fetchByUri function, also for collections
      async fetchImageByUri(imageUri, fetchFn = globalThis.fetch) {
        for (const canvas of this.canvases) {
          if (canvas.image.uri === imageUri) {
            const fetchedImage = await this.#fetchImage(canvas.image, fetchFn);
            canvas.image = fetchedImage;
            return fetchedImage;
          }
        }
      }
    };
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/collection.js
var CollectionTypeString, defaulfFetchNextOptions, EmbeddedCollection, Collection2;
var init_collection = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/collection.js"() {
    init_iiif();
    init_manifest();
    init_convert2();
    CollectionTypeString = "collection";
    defaulfFetchNextOptions = {
      maxDepth: Number.POSITIVE_INFINITY,
      fetchCollections: true,
      fetchManifests: true,
      fetchImages: false,
      fetchFn: globalThis.fetch
    };
    EmbeddedCollection = class {
      uri;
      type = CollectionTypeString;
      majorVersion;
      // TODO: add description?
      // TODO: add metadata?
      label;
      embedded = true;
      constructor(parsedCollection) {
        if ("@type" in parsedCollection) {
          this.uri = parsedCollection["@id"];
          this.majorVersion = 2;
          this.label = parseVersion2String(parsedCollection.label);
        } else if ("type" in parsedCollection) {
          this.uri = parsedCollection.id;
          this.majorVersion = 3;
          this.label = parseVersion3String(parsedCollection.label);
        } else {
          throw new Error("Unsupported Collection");
        }
      }
      /**
       * Parses a IIIF Collection and returns a [Collection](#collection) containing the parsed version
       * @param iiifCollection - Source data of IIIF Collection
       * @param majorVersion - IIIF API version of Collection. If not provided, it will be determined automatically
       * @returns Parsed IIIF Collection
       * @static
       */
      static parse(iiifCollection, majorVersion = null) {
        let parsedCollection;
        if (majorVersion === 2) {
          parsedCollection = Collection2Schema.parse(iiifCollection);
        } else if (majorVersion === 3) {
          parsedCollection = Collection3Schema.parse(iiifCollection);
        } else {
          parsedCollection = CollectionSchema.parse(iiifCollection);
        }
        return new Collection2(parsedCollection);
      }
    };
    Collection2 = class _Collection extends EmbeddedCollection {
      items = [];
      embedded = false;
      description;
      metadata;
      navDate;
      navPlace;
      homepage;
      thumbnail;
      rendering;
      seeAlso;
      summary;
      requiredStatement;
      annotations;
      constructor(parsedCollection) {
        super(parsedCollection);
        if ("@type" in parsedCollection) {
          this.description = parseVersion2String(parsedCollection.description);
          this.label = parseVersion2String(parsedCollection.label);
          this.metadata = parseVersion2Metadata(parsedCollection.metadata);
          this.navDate = parsedCollection.navDate;
          this.navPlace = parsedCollection.navPlace;
          this.requiredStatement = parseVersion2Attribution(parsedCollection.attribution);
          this.thumbnail = parseVersion2Thumbnail(parsedCollection.thumbnail);
          this.rendering = parseVersion2Rendering(parsedCollection.rendering);
          this.homepage = parseVersion2Related(parsedCollection.related);
          const manifests = "manifests" in parsedCollection && parsedCollection.manifests ? parsedCollection.manifests : [];
          const collections = "collections" in parsedCollection && parsedCollection.collections ? parsedCollection.collections : [];
          const members = "members" in parsedCollection && parsedCollection.members ? parsedCollection.members : [];
          const items = [...manifests, ...collections, ...members];
          this.items = items.map((item) => {
            if (item["@type"] === "sc:Collection") {
              return new _Collection(item);
            } else {
              return new EmbeddedManifest(item);
            }
          });
        } else if ("type" in parsedCollection) {
          this.description = parseVersion3String(parsedCollection.description);
          this.metadata = parseVersion3Metadata(parsedCollection.metadata);
          this.navDate = parsedCollection.navDate;
          this.navPlace = parsedCollection.navPlace;
          this.homepage = parsedCollection.homepage;
          this.thumbnail = parsedCollection.thumbnail;
          this.rendering = parsedCollection.rendering;
          this.seeAlso = parsedCollection.seeAlso;
          this.summary = parsedCollection.summary;
          this.requiredStatement = parsedCollection.requiredStatement;
          this.annotations = parsedCollection.annotations;
          if ("items" in parsedCollection) {
            this.items = parsedCollection.items.map((item) => {
              if (item.type === "Collection") {
                if ("items" in item) {
                  return new _Collection(item);
                } else {
                  item;
                  return new EmbeddedCollection(item);
                }
              } else {
                return new EmbeddedManifest(item);
              }
            });
          }
        } else {
          throw new Error("Unsupported Collection");
        }
      }
      /**
       * Parses a IIIF Collection and returns a [Collection](#collection) containing the parsed version
       * @param iiifCollection - Source data of IIIF Collection
       * @param majorVersion - IIIF API version of Collection. If not provided, it will be determined automatically
       * @returns Parsed IIIF Collection
       */
      static parse(iiifCollection, majorVersion = null) {
        let parsedCollection;
        if (majorVersion === 2) {
          parsedCollection = Collection2Schema.parse(iiifCollection);
        } else if (majorVersion === 3) {
          parsedCollection = Collection3Schema.parse(iiifCollection);
        } else {
          parsedCollection = CollectionSchema.parse(iiifCollection);
        }
        return new _Collection(parsedCollection);
      }
      get canvases() {
        const initialValue = [];
        return this.items.reduce((canvases, item) => {
          if (item instanceof Manifest) {
            return [...canvases, ...item.canvases];
          } else if (item instanceof EmbeddedManifest) {
            return canvases;
          } else if (item instanceof _Collection) {
            return [...canvases, ...item.canvases];
          }
          return canvases;
        }, initialValue);
      }
      get images() {
        return this.canvases.map((canvas) => canvas.image);
      }
      async fetchAll(options) {
        const results = [];
        for await (const next of this.fetchNext(options)) {
          results.push(next);
        }
        return results;
      }
      async *fetchNext(options, depth = 0) {
        options = {
          ...defaulfFetchNextOptions,
          ...options
        };
        if (Number.isNaN(options.maxDepth)) {
          return;
        }
        if (options.maxDepth === void 0) {
          options.maxDepth = defaulfFetchNextOptions.maxDepth;
        }
        if (options.fetchImages === void 0) {
          options.fetchImages = defaulfFetchNextOptions.fetchImages;
        }
        if (options.fetchManifests === void 0) {
          options.fetchManifests = defaulfFetchNextOptions.fetchManifests;
        }
        let fetchFn = defaulfFetchNextOptions.fetchFn;
        if (options.fetchFn) {
          fetchFn = options.fetchFn;
        }
        if (depth >= options.maxDepth) {
          return;
        }
        for (const itemIndex in this.items) {
          let item = this.items[itemIndex];
          if (item instanceof Manifest) {
            if (options.fetchImages) {
              yield* item.fetchNext(fetchFn, depth + 1);
            }
          } else if (item instanceof EmbeddedManifest && options.fetchManifests) {
            const manifestUri = item.uri;
            const iiifManifest = await fetchFn(manifestUri).then((response) => response.json());
            const newParsedManifest = Manifest.parse(iiifManifest);
            this.items[itemIndex] = newParsedManifest;
            yield {
              item: newParsedManifest,
              depth: depth + 1,
              parent: {
                uri: this.uri,
                type: this.type
              }
            };
            if (depth + 1 < options.maxDepth && options.fetchImages) {
              yield* newParsedManifest.fetchNext(fetchFn, depth + 2);
            }
          } else if (item instanceof EmbeddedCollection && options.fetchCollections) {
            const collectionUri = item.uri;
            const iiifCollection = await fetchFn(collectionUri).then((response) => response.json());
            const newParsedCollection = _Collection.parse(iiifCollection);
            this.items[itemIndex] = newParsedCollection;
            yield {
              item: newParsedCollection,
              depth: depth + 1,
              parent: {
                uri: this.uri,
                type: this.type
              }
            };
            item = newParsedCollection;
            if (depth + 1 < options.maxDepth) {
              yield* newParsedCollection.fetchNext(options, depth + 2);
            }
          }
        }
      }
    };
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/iiif.js
var IIIF;
var init_iiif2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/iiif.js"() {
    init_iiif();
    init_image_1();
    init_image();
    init_manifest();
    init_collection();
    IIIF = class {
      /**
       * Parses as IIIF resource and returns a class containing the parsed version
       * @param iiifResource - Source data of a IIIF resource
       * @param majorVersion - IIIF API version of resource. If not provided, it will be determined automatically
       * @returns Parsed IIIF resource
       */
      static parse(iiifResource, majorVersion = null) {
        if (iiifResource && typeof iiifResource === "object") {
          if (majorVersion === 1 || "@context" in iiifResource && iiifResource["@context"] === Image1ContextString) {
            const parsedImage = Image1Schema.parse(iiifResource);
            return new Image2(parsedImage);
          } else if (majorVersion === 2 || "@id" in iiifResource) {
            if ("protocol" in iiifResource && iiifResource.protocol === "http://iiif.io/api/image") {
              const parsedImage = Image2Schema.parse(iiifResource);
              return new Image2(parsedImage);
            } else if ("@type" in iiifResource && iiifResource["@type"] === "sc:Manifest") {
              const parsedManifest = Manifest2Schema.parse(iiifResource);
              return new Manifest(parsedManifest);
            } else if ("@type" in iiifResource && iiifResource["@type"] === "sc:Collection") {
              const parsedCollection = Collection2Schema.parse(iiifResource);
              return new Collection2(parsedCollection);
            }
          } else if (majorVersion === 3 || "id" in iiifResource) {
            if ("protocol" in iiifResource && iiifResource.protocol === "http://iiif.io/api/image") {
              const parsedImage = Image3Schema.parse(iiifResource);
              return new Image2(parsedImage);
            } else if ("type" in iiifResource && iiifResource.type === "Manifest") {
              const parsedManifest = Manifest3Schema.parse(iiifResource);
              return new Manifest(parsedManifest);
            } else if ("type" in iiifResource && iiifResource.type === "Collection") {
              const parsedCollection = Collection3Schema.parse(iiifResource);
              return new Collection2(parsedCollection);
            }
          }
        }
        throw new Error("Invalid IIIF data or unsupported IIIF type");
      }
    };
  }
});

// node_modules/@allmaps/iiif-parser/dist/index.js
var init_dist12 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/index.js"() {
    init_iiif2();
    init_collection();
    init_manifest();
    init_canvas2();
    init_image();
  }
});

// node_modules/@allmaps/render/dist/shared/homogeneous-transform.js
var init_homogeneous_transform = __esm({
  "node_modules/@allmaps/render/dist/shared/homogeneous-transform.js"() {
  }
});

// node_modules/@allmaps/render/dist/maps/WarpedMap.js
var init_WarpedMap = __esm({
  "node_modules/@allmaps/render/dist/maps/WarpedMap.js"() {
    init_dist12();
    init_dist10();
    init_dist5();
    init_homogeneous_transform();
    init_events2();
  }
});

// node_modules/@allmaps/render/dist/maps/TriangulatedWarpedMap.js
var init_TriangulatedWarpedMap = __esm({
  "node_modules/@allmaps/render/dist/maps/TriangulatedWarpedMap.js"() {
    init_dist11();
    init_dist5();
    init_WarpedMap();
  }
});

// node_modules/@allmaps/render/dist/shared/webgl2.js
var init_webgl2 = __esm({
  "node_modules/@allmaps/render/dist/shared/webgl2.js"() {
  }
});

// node_modules/@allmaps/render/dist/maps/WebGL2WarpedMap.js
var init_WebGL2WarpedMap = __esm({
  "node_modules/@allmaps/render/dist/maps/WebGL2WarpedMap.js"() {
    init_dist5();
    init_dist7();
    init_TriangulatedWarpedMap();
    init_events2();
    init_homogeneous_transform();
    init_webgl2();
    init_tiles();
  }
});

// node_modules/@allmaps/render/dist/tilecache/CacheableTile.js
var init_CacheableTile = __esm({
  "node_modules/@allmaps/render/dist/tilecache/CacheableTile.js"() {
  }
});

// node_modules/@allmaps/render/dist/tilecache/CacheableWorkerImageDataTile.js
var init_CacheableWorkerImageDataTile = __esm({
  "node_modules/@allmaps/render/dist/tilecache/CacheableWorkerImageDataTile.js"() {
    init_CacheableTile();
    init_events2();
  }
});

// node_modules/@allmaps/render/dist/viewport/Viewport.js
var init_Viewport = __esm({
  "node_modules/@allmaps/render/dist/viewport/Viewport.js"() {
    init_dist5();
    init_dist10();
    init_homogeneous_transform();
  }
});

// node_modules/@allmaps/render/dist/shaders/map/vertex-shader.glsl.js
var init_vertex_shader_glsl = __esm({
  "node_modules/@allmaps/render/dist/shaders/map/vertex-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/map/fragment-shader.glsl.js
var init_fragment_shader_glsl = __esm({
  "node_modules/@allmaps/render/dist/shaders/map/fragment-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/lines/vertex-shader.glsl.js
var init_vertex_shader_glsl2 = __esm({
  "node_modules/@allmaps/render/dist/shaders/lines/vertex-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/lines/fragment-shader.glsl.js
var init_fragment_shader_glsl2 = __esm({
  "node_modules/@allmaps/render/dist/shaders/lines/fragment-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/points/vertex-shader.glsl.js
var init_vertex_shader_glsl3 = __esm({
  "node_modules/@allmaps/render/dist/shaders/points/vertex-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/points/fragment-shader.glsl.js
var init_fragment_shader_glsl3 = __esm({
  "node_modules/@allmaps/render/dist/shaders/points/fragment-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/workers/fetch-and-get-image-data.js
var encodedJs, decodeBase64, blob;
var init_fetch_and_get_image_data = __esm({
  "node_modules/@allmaps/render/dist/workers/fetch-and-get-image-data.js"() {
    encodedJs = "LyoqCiAqIEBsaWNlbnNlCiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAKICovCmNvbnN0IHByb3h5TWFya2VyID0gU3ltYm9sKCJDb21saW5rLnByb3h5Iik7CmNvbnN0IGNyZWF0ZUVuZHBvaW50ID0gU3ltYm9sKCJDb21saW5rLmVuZHBvaW50Iik7CmNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbCgiQ29tbGluay5yZWxlYXNlUHJveHkiKTsKY29uc3QgZmluYWxpemVyID0gU3ltYm9sKCJDb21saW5rLmZpbmFsaXplciIpOwpjb25zdCB0aHJvd01hcmtlciA9IFN5bWJvbCgiQ29tbGluay50aHJvd24iKTsKY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAib2JqZWN0IiAmJiB2YWwgIT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gImZ1bmN0aW9uIjsKY29uc3QgcHJveHlUcmFuc2ZlckhhbmRsZXIgPSB7CiAgY2FuSGFuZGxlOiAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIHZhbFtwcm94eU1hcmtlcl0sCiAgc2VyaWFsaXplKG9iaikgewogICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpOwogICAgZXhwb3NlKG9iaiwgcG9ydDEpOwogICAgcmV0dXJuIFtwb3J0MiwgW3BvcnQyXV07CiAgfSwKICBkZXNlcmlhbGl6ZShwb3J0KSB7CiAgICBwb3J0LnN0YXJ0KCk7CiAgICByZXR1cm4gd3JhcChwb3J0KTsKICB9Cn07CmNvbnN0IHRocm93VHJhbnNmZXJIYW5kbGVyID0gewogIGNhbkhhbmRsZTogKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgdGhyb3dNYXJrZXIgaW4gdmFsdWUsCiAgc2VyaWFsaXplKHsgdmFsdWUgfSkgewogICAgbGV0IHNlcmlhbGl6ZWQ7CiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikgewogICAgICBzZXJpYWxpemVkID0gewogICAgICAgIGlzRXJyb3I6IHRydWUsCiAgICAgICAgdmFsdWU6IHsKICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsCiAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lLAogICAgICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrCiAgICAgICAgfQogICAgICB9OwogICAgfSBlbHNlIHsKICAgICAgc2VyaWFsaXplZCA9IHsgaXNFcnJvcjogZmFsc2UsIHZhbHVlIH07CiAgICB9CiAgICByZXR1cm4gW3NlcmlhbGl6ZWQsIFtdXTsKICB9LAogIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHsKICAgIGlmIChzZXJpYWxpemVkLmlzRXJyb3IpIHsKICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3Ioc2VyaWFsaXplZC52YWx1ZS5tZXNzYWdlKSwgc2VyaWFsaXplZC52YWx1ZSk7CiAgICB9CiAgICB0aHJvdyBzZXJpYWxpemVkLnZhbHVlOwogIH0KfTsKY29uc3QgdHJhbnNmZXJIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFsKICBbInByb3h5IiwgcHJveHlUcmFuc2ZlckhhbmRsZXJdLAogIFsidGhyb3ciLCB0aHJvd1RyYW5zZmVySGFuZGxlcl0KXSk7CmZ1bmN0aW9uIGlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgb3JpZ2luKSB7CiAgZm9yIChjb25zdCBhbGxvd2VkT3JpZ2luIG9mIGFsbG93ZWRPcmlnaW5zKSB7CiAgICBpZiAob3JpZ2luID09PSBhbGxvd2VkT3JpZ2luIHx8IGFsbG93ZWRPcmlnaW4gPT09ICIqIikgewogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIGlmIChhbGxvd2VkT3JpZ2luIGluc3RhbmNlb2YgUmVnRXhwICYmIGFsbG93ZWRPcmlnaW4udGVzdChvcmlnaW4pKSB7CiAgICAgIHJldHVybiB0cnVlOwogICAgfQogIH0KICByZXR1cm4gZmFsc2U7Cn0KZnVuY3Rpb24gZXhwb3NlKG9iaiwgZXAgPSBnbG9iYWxUaGlzLCBhbGxvd2VkT3JpZ2lucyA9IFsiKiJdKSB7CiAgZXAuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGZ1bmN0aW9uIGNhbGxiYWNrKGV2KSB7CiAgICBpZiAoIWV2IHx8ICFldi5kYXRhKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICghaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBldi5vcmlnaW4pKSB7CiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBvcmlnaW4gJyR7ZXYub3JpZ2lufScgZm9yIGNvbWxpbmsgcHJveHlgKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgeyBpZCwgdHlwZSwgcGF0aCB9ID0gT2JqZWN0LmFzc2lnbih7IHBhdGg6IFtdIH0sIGV2LmRhdGEpOwogICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7CiAgICBsZXQgcmV0dXJuVmFsdWU7CiAgICB0cnkgewogICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iajIsIHByb3ApID0+IG9iajJbcHJvcF0sIG9iaik7CiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcGF0aC5yZWR1Y2UoKG9iajIsIHByb3ApID0+IG9iajJbcHJvcF0sIG9iaik7CiAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgIGNhc2UgIkdFVCI6CiAgICAgICAgICB7CiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJTRVQiOgogICAgICAgICAgewogICAgICAgICAgICBwYXJlbnRbcGF0aC5zbGljZSgtMSlbMF1dID0gZnJvbVdpcmVWYWx1ZShldi5kYXRhLnZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiQVBQTFkiOgogICAgICAgICAgewogICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlLmFwcGx5KHBhcmVudCwgYXJndW1lbnRMaXN0KTsKICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgIkNPTlNUUlVDVCI6CiAgICAgICAgICB7CiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7CiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcHJveHkodmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiRU5EUE9JTlQiOgogICAgICAgICAgewogICAgICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7CiAgICAgICAgICAgIGV4cG9zZShvYmosIHBvcnQyKTsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cmFuc2Zlcihwb3J0MSwgW3BvcnQxXSk7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJSRUxFQVNFIjoKICAgICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICB9IGNhdGNoICh2YWx1ZSkgewogICAgICByZXR1cm5WYWx1ZSA9IHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTsKICAgIH0KICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkuY2F0Y2goKHZhbHVlKSA9PiB7CiAgICAgIHJldHVybiB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07CiAgICB9KS50aGVuKChyZXR1cm5WYWx1ZTIpID0+IHsKICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyZXR1cm5WYWx1ZTIpOwogICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpOwogICAgICBpZiAodHlwZSA9PT0gIlJFTEVBU0UiKSB7CiAgICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGNhbGxiYWNrKTsKICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTsKICAgICAgICBpZiAoZmluYWxpemVyIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpbmFsaXplcl0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIG9ialtmaW5hbGl6ZXJdKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsKICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZSh7CiAgICAgICAgdmFsdWU6IG5ldyBUeXBlRXJyb3IoIlVuc2VyaWFsaXphYmxlIHJldHVybiB2YWx1ZSIpLAogICAgICAgIFt0aHJvd01hcmtlcl06IDAKICAgICAgfSk7CiAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7CiAgICB9KTsKICB9KTsKICBpZiAoZXAuc3RhcnQpIHsKICAgIGVwLnN0YXJ0KCk7CiAgfQp9CmZ1bmN0aW9uIGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpIHsKICByZXR1cm4gZW5kcG9pbnQuY29uc3RydWN0b3IubmFtZSA9PT0gIk1lc3NhZ2VQb3J0IjsKfQpmdW5jdGlvbiBjbG9zZUVuZFBvaW50KGVuZHBvaW50KSB7CiAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKQogICAgZW5kcG9pbnQuY2xvc2UoKTsKfQpmdW5jdGlvbiB3cmFwKGVwLCB0YXJnZXQpIHsKICBjb25zdCBwZW5kaW5nTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBlcC5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldikgewogICAgY29uc3QgeyBkYXRhIH0gPSBldjsKICAgIGlmICghZGF0YSB8fCAhZGF0YS5pZCkgewogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCByZXNvbHZlciA9IHBlbmRpbmdMaXN0ZW5lcnMuZ2V0KGRhdGEuaWQpOwogICAgaWYgKCFyZXNvbHZlcikgewogICAgICByZXR1cm47CiAgICB9CiAgICB0cnkgewogICAgICByZXNvbHZlcihkYXRhKTsKICAgIH0gZmluYWxseSB7CiAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuZGVsZXRlKGRhdGEuaWQpOwogICAgfQogIH0pOwogIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgW10sIHRhcmdldCk7Cn0KZnVuY3Rpb24gdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNSZWxlYXNlZCkgewogIGlmIChpc1JlbGVhc2VkKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZSIpOwogIH0KfQpmdW5jdGlvbiByZWxlYXNlRW5kcG9pbnQoZXApIHsKICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgewogICAgdHlwZTogIlJFTEVBU0UiCiAgfSkudGhlbigoKSA9PiB7CiAgICBjbG9zZUVuZFBvaW50KGVwKTsKICB9KTsKfQpjb25zdCBwcm94eUNvdW50ZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTsKY29uc3QgcHJveHlGaW5hbGl6ZXJzID0gIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiBpbiBnbG9iYWxUaGlzICYmIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoZXApID0+IHsKICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSAtIDE7CiAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpOwogIGlmIChuZXdDb3VudCA9PT0gMCkgewogICAgcmVsZWFzZUVuZHBvaW50KGVwKTsKICB9Cn0pOwpmdW5jdGlvbiByZWdpc3RlclByb3h5KHByb3h5MiwgZXApIHsKICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSArIDE7CiAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpOwogIGlmIChwcm94eUZpbmFsaXplcnMpIHsKICAgIHByb3h5RmluYWxpemVycy5yZWdpc3Rlcihwcm94eTIsIGVwLCBwcm94eTIpOwogIH0KfQpmdW5jdGlvbiB1bnJlZ2lzdGVyUHJveHkocHJveHkyKSB7CiAgaWYgKHByb3h5RmluYWxpemVycykgewogICAgcHJveHlGaW5hbGl6ZXJzLnVucmVnaXN0ZXIocHJveHkyKTsKICB9Cn0KZnVuY3Rpb24gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHBhdGggPSBbXSwgdGFyZ2V0ID0gZnVuY3Rpb24oKSB7Cn0pIHsKICBsZXQgaXNQcm94eVJlbGVhc2VkID0gZmFsc2U7CiAgY29uc3QgcHJveHkyID0gbmV3IFByb3h5KHRhcmdldCwgewogICAgZ2V0KF90YXJnZXQsIHByb3ApIHsKICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTsKICAgICAgaWYgKHByb3AgPT09IHJlbGVhc2VQcm94eSkgewogICAgICAgIHJldHVybiAoKSA9PiB7CiAgICAgICAgICB1bnJlZ2lzdGVyUHJveHkocHJveHkyKTsKICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7CiAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmNsZWFyKCk7CiAgICAgICAgICBpc1Byb3h5UmVsZWFzZWQgPSB0cnVlOwogICAgICAgIH07CiAgICAgIH0KICAgICAgaWYgKHByb3AgPT09ICJ0aGVuIikgewogICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gcHJveHkyIH07CiAgICAgICAgfQogICAgICAgIGNvbnN0IHIgPSByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgICB0eXBlOiAiR0VUIiwKICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpCiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgICAgICByZXR1cm4gci50aGVuLmJpbmQocik7CiAgICAgIH0KICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBbLi4ucGF0aCwgcHJvcF0pOwogICAgfSwKICAgIHNldChfdGFyZ2V0LCBwcm9wLCByYXdWYWx1ZSkgewogICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpOwogICAgICBjb25zdCBbdmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmF3VmFsdWUpOwogICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgewogICAgICAgIHR5cGU6ICJTRVQiLAogICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksCiAgICAgICAgdmFsdWUKICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgIH0sCiAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgcmF3QXJndW1lbnRMaXN0KSB7CiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7CiAgICAgIGNvbnN0IGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07CiAgICAgIGlmIChsYXN0ID09PSBjcmVhdGVFbmRwb2ludCkgewogICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgICB0eXBlOiAiRU5EUE9JTlQiCiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgICAgfQogICAgICBpZiAobGFzdCA9PT0gImJpbmQiKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBwYXRoLnNsaWNlKDAsIC0xKSk7CiAgICAgIH0KICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7CiAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgdHlwZTogIkFQUExZIiwKICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSwKICAgICAgICBhcmd1bWVudExpc3QKICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgIH0sCiAgICBjb25zdHJ1Y3QoX3RhcmdldCwgcmF3QXJndW1lbnRMaXN0KSB7CiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7CiAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpOwogICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgewogICAgICAgIHR5cGU6ICJDT05TVFJVQ1QiLAogICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLAogICAgICAgIGFyZ3VtZW50TGlzdAogICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpOwogICAgfQogIH0pOwogIHJlZ2lzdGVyUHJveHkocHJveHkyLCBlcCk7CiAgcmV0dXJuIHByb3h5MjsKfQpmdW5jdGlvbiBteUZsYXQoYXJyKSB7CiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7Cn0KZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3QpIHsKICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTsKICByZXR1cm4gW3Byb2Nlc3NlZC5tYXAoKHYpID0+IHZbMF0pLCBteUZsYXQocHJvY2Vzc2VkLm1hcCgodikgPT4gdlsxXSkpXTsKfQpjb25zdCB0cmFuc2ZlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7CmZ1bmN0aW9uIHRyYW5zZmVyKG9iaiwgdHJhbnNmZXJzKSB7CiAgdHJhbnNmZXJDYWNoZS5zZXQob2JqLCB0cmFuc2ZlcnMpOwogIHJldHVybiBvYmo7Cn0KZnVuY3Rpb24gcHJveHkob2JqKSB7CiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCB7IFtwcm94eU1hcmtlcl06IHRydWUgfSk7Cn0KZnVuY3Rpb24gdG9XaXJlVmFsdWUodmFsdWUpIHsKICBmb3IgKGNvbnN0IFtuYW1lLCBoYW5kbGVyXSBvZiB0cmFuc2ZlckhhbmRsZXJzKSB7CiAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodmFsdWUpKSB7CiAgICAgIGNvbnN0IFtzZXJpYWxpemVkVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gaGFuZGxlci5zZXJpYWxpemUodmFsdWUpOwogICAgICByZXR1cm4gWwogICAgICAgIHsKICAgICAgICAgIHR5cGU6ICJIQU5ETEVSIiwKICAgICAgICAgIG5hbWUsCiAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFZhbHVlCiAgICAgICAgfSwKICAgICAgICB0cmFuc2ZlcmFibGVzCiAgICAgIF07CiAgICB9CiAgfQogIHJldHVybiBbCiAgICB7CiAgICAgIHR5cGU6ICJSQVciLAogICAgICB2YWx1ZQogICAgfSwKICAgIHRyYW5zZmVyQ2FjaGUuZ2V0KHZhbHVlKSB8fCBbXQogIF07Cn0KZnVuY3Rpb24gZnJvbVdpcmVWYWx1ZSh2YWx1ZSkgewogIHN3aXRjaCAodmFsdWUudHlwZSkgewogICAgY2FzZSAiSEFORExFUiI6CiAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7CiAgICBjYXNlICJSQVciOgogICAgICByZXR1cm4gdmFsdWUudmFsdWU7CiAgfQp9CmZ1bmN0aW9uIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIG1zZywgdHJhbnNmZXJzKSB7CiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpOwogICAgcGVuZGluZ0xpc3RlbmVycy5zZXQoaWQsIHJlc29sdmUpOwogICAgaWYgKGVwLnN0YXJ0KSB7CiAgICAgIGVwLnN0YXJ0KCk7CiAgICB9CiAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKHsgaWQgfSwgbXNnKSwgdHJhbnNmZXJzKTsKICB9KTsKfQpmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7CiAgcmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKDApLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikudG9TdHJpbmcoMTYpKS5qb2luKCItIik7Cn0KYXN5bmMgZnVuY3Rpb24gZmV0Y2hVcmwoaW5wdXQsIGluaXQsIGZldGNoRm4pIHsKICBsZXQgcmVzcG9uc2U7CiAgaWYgKHR5cGVvZiBmZXRjaEZuID09PSAiZnVuY3Rpb24iKSB7CiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoRm4oaW5wdXQsIGluaXQpOwogIH0gZWxzZSB7CiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKGlucHV0LCBpbml0KTsKICB9CiAgaWYgKCFyZXNwb25zZS5vaykgewogICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTsKICAgIGlmIChqc29uICYmIGpzb24uZXJyb3IpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKGpzb24uZXJyb3IpOwogICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNUZXh0KSB7CiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTsKICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgZm91bmQ6ICR7aW5wdXR9ICg0MDQpYCk7CiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAwKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiSW50ZXJuYWwgc2VydmVyIGVycm9yICg1MDApIik7CiAgICB9IGVsc2UgewogICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaDogJHtpbnB1dH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSlgKTsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3BvbnNlOwp9CmNvbnN0IGZldGNoQW5kR2V0SW1hZ2VEYXRhV29ya2VyID0gewogIGFzeW5jIGdldEltYWdlRGF0YSh0aWxlVXJsLCBvbkFib3J0LCBmZXRjaEZuLCB3aWR0aCwgaGVpZ2h0KSB7CiAgICBjb25zdCB3b3JrZXJBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7CiAgICBvbkFib3J0KCk7CiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoVXJsKAogICAgICB0aWxlVXJsLAogICAgICB7CiAgICAgICAgc2lnbmFsOiB3b3JrZXJBYm9ydENvbnRyb2xsZXIuc2lnbmFsCiAgICAgIH0sCiAgICAgIGZldGNoRm4KICAgICk7CiAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpOwogICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7CiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICBpZiAoIWNvbnRleHQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJDb3VsZCBub3QgY3JlYXRlIE9mZnNjcmVlbkNhbnZhcyBjb250ZXh0Iik7CiAgICB9CiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZUJpdG1hcCwgMCwgMCk7CiAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgIHJldHVybiB0cmFuc2ZlcihpbWFnZURhdGEsIFtpbWFnZURhdGEuZGF0YS5idWZmZXJdKTsKICB9Cn07CmV4cG9zZShmZXRjaEFuZEdldEltYWdlRGF0YVdvcmtlcik7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLWFuZC1nZXQtaW1hZ2UtZGF0YS1CQzRZc0lHNy5qcy5tYXAK";
    decodeBase64 = (base64) => Uint8Array.from(atob(base64), (c7) => c7.charCodeAt(0));
    blob = typeof self !== "undefined" && self.Blob && new Blob(["URL.revokeObjectURL(import.meta.url);", decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
  }
});

// node_modules/@allmaps/render/dist/renderers/WebGL2Renderer.js
var SIGNIFICANT_VIEWPORT_EPSILON;
var init_WebGL2Renderer = __esm({
  "node_modules/@allmaps/render/dist/renderers/WebGL2Renderer.js"() {
    init_dist5();
    init_dist6();
    init_dist7();
    init_BaseRenderer();
    init_WebGL2WarpedMap();
    init_CacheableWorkerImageDataTile();
    init_events2();
    init_homogeneous_transform();
    init_webgl2();
    init_Viewport();
    init_vertex_shader_glsl();
    init_fragment_shader_glsl();
    init_vertex_shader_glsl2();
    init_fragment_shader_glsl2();
    init_vertex_shader_glsl3();
    init_fragment_shader_glsl3();
    init_fetch_and_get_image_data();
    SIGNIFICANT_VIEWPORT_EPSILON = 100 * Number.EPSILON;
  }
});

// node_modules/@allmaps/render/dist/webgl2.js
var init_webgl22 = __esm({
  "node_modules/@allmaps/render/dist/webgl2.js"() {
    init_WebGL2Renderer();
    init_WebGL2WarpedMap();
  }
});

// node_modules/@allmaps/render/dist/index.js
var init_dist13 = __esm({
  "node_modules/@allmaps/render/dist/index.js"() {
    init_Viewport();
    init_WarpedMapList();
    init_WarpedMap();
    init_TriangulatedWarpedMap();
    init_events2();
  }
});

// node_modules/@allmaps/openlayers/dist/OLWarpedMapEvent.js
var init_OLWarpedMapEvent = __esm({
  "node_modules/@allmaps/openlayers/dist/OLWarpedMapEvent.js"() {
  }
});

// node_modules/@allmaps/openlayers/dist/WarpedMapLayer.js
var init_WarpedMapLayer = __esm({
  "node_modules/@allmaps/openlayers/dist/WarpedMapLayer.js"() {
    init_webgl22();
    init_dist13();
    init_dist5();
    init_OLWarpedMapEvent();
  }
});

// node_modules/@allmaps/openlayers/dist/index.js
var init_dist14 = __esm({
  "node_modules/@allmaps/openlayers/dist/index.js"() {
    init_WarpedMapLayer();
    init_OLWarpedMapEvent();
    init_dist13();
  }
});

// .svelte-kit/output/server/chunks/MapSearchBar.js
function j4(l7) {
  const s5 = l7.trim();
  if (!s5) return null;
  const t4 = s5.match(/^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)$/);
  if (!t4) return null;
  const a5 = parseFloat(t4[1]), o5 = parseFloat(t4[2]);
  return isNaN(a5) || isNaN(o5) ? null : Math.abs(a5) <= 90 && Math.abs(o5) <= 180 ? { lat: a5, lng: o5 } : Math.abs(a5) <= 180 && Math.abs(o5) <= 90 ? { lat: o5, lng: a5 } : null;
}
function k3(l7, s5, t4, a5) {
  const i7 = (t4 - l7) * Math.PI / 180, e3 = (a5 - s5) * Math.PI / 180, n6 = Math.sin(i7 / 2) * Math.sin(i7 / 2) + Math.cos(l7 * Math.PI / 180) * Math.cos(t4 * Math.PI / 180) * Math.sin(e3 / 2) * Math.sin(e3 / 2);
  return 6371 * (2 * Math.atan2(Math.sqrt(n6), Math.sqrt(1 - n6)));
}
function A6(l7, s5, t4) {
  const [a5, o5, i7, e3] = t4;
  if (l7 >= a5 && l7 <= i7 && s5 >= o5 && s5 <= e3) return 0;
  const n6 = Math.max(a5, Math.min(l7, i7)), v5 = Math.max(o5, Math.min(s5, e3));
  return k3(s5, l7, v5, n6);
}
function M7(l7) {
  return (l7[2] - l7[0]) * (l7[3] - l7[1]);
}
function P6(l7, s5, t4, a5 = 50) {
  const o5 = [];
  for (const i7 of t4) {
    if (!i7.bounds) continue;
    const e3 = A6(s5, l7, i7.bounds);
    e3 <= a5 && o5.push({ map: i7, dist: e3 });
  }
  return o5.sort((i7, e3) => i7.dist !== e3.dist ? i7.dist - e3.dist : M7(i7.map.bounds) - M7(e3.map.bounds)), o5.map((i7) => i7.map);
}
function q4(l7, s5) {
  l7.component((t4) => {
    let a5, o5, i7 = q(s5.open, false), e3 = q(s5.maps, () => [], true), n6 = q(s5.selectedMapId, null), v5 = q(s5.showAddAsPoint, false), w5 = "maps", d2 = "";
    if (a5 = j4(""), a5 && e3.length && (P6(a5.lat, a5.lng, e3), `${a5.lat.toFixed(3)}${a5.lng.toFixed(3)}`), o5 = (() => {
      const p6 = d2.trim().toLowerCase();
      return p6 ? e3.filter((c7) => [c7.name, c7.type, c7.summary ?? "", c7.year != null ? String(c7.year) : ""].join(" ").toLowerCase().includes(p6)) : e3;
    })(), i7) {
      t4.push("<!--[-->"), t4.push(`<div class="search-backdrop svelte-l3wrew" role="presentation"></div> <div class="search-panel svelte-l3wrew" role="dialog" aria-label="Search" tabindex="-1"><div class="tab-bar svelte-l3wrew"><button type="button"${Jn("tb svelte-l3wrew", void 0, { active: w5 === "maps" })}>Maps</button> <button type="button"${Jn("tb svelte-l3wrew", void 0, { active: w5 === "location" })}>Location</button> <div class="tab-spacer svelte-l3wrew"></div> <button type="button" class="close-btn svelte-l3wrew" aria-label="Close search"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><path d="M18 6L6 18M6 6l12 12"></path></svg></button></div> `);
      {
        if (t4.push("<!--[-->"), t4.push(`<div class="search-form svelte-l3wrew"><input type="text" placeholder="Filter maps by name, city, year..."${En("value", d2)} class="svelte-l3wrew"/></div> <div class="results-list custom-scrollbar svelte-l3wrew">`), o5.length) {
          t4.push("<!--[-->"), t4.push("<!--[-->");
          const p6 = rs(o5);
          for (let c7 = 0, b8 = p6.length; c7 < b8; c7++) {
            let u8 = p6[c7];
            t4.push(`<button type="button"${Jn("result-item map-item svelte-l3wrew", void 0, { "active-map": u8.id === n6 })}><div class="result-row svelte-l3wrew"><span class="result-title svelte-l3wrew">${C2(u8.name)}</span> `), u8.id === n6 ? (t4.push("<!--[-->"), t4.push('<span class="badge active-badge svelte-l3wrew">Active</span>')) : t4.push("<!--[!-->"), t4.push('<!--]--></div> <div class="result-meta svelte-l3wrew">'), u8.year ? (t4.push("<!--[-->"), t4.push(`<span class="badge year-badge svelte-l3wrew">${C2(u8.year)}</span>`)) : t4.push("<!--[!-->"), t4.push("<!--]--> "), u8.type ? (t4.push("<!--[-->"), t4.push(`<span class="badge type-badge svelte-l3wrew">${C2(u8.type)}</span>`)) : t4.push("<!--[!-->"), t4.push("<!--]--></div></button>");
          }
          t4.push("<!--]-->");
        } else t4.push("<!--[!-->"), d2.trim() ? (t4.push("<!--[-->"), t4.push(`<p class="empty-msg svelte-l3wrew">No maps match "${C2(d2)}"</p>`)) : (t4.push("<!--[!-->"), t4.push('<p class="empty-msg svelte-l3wrew">No maps available</p>')), t4.push("<!--]-->");
        t4.push("<!--]--></div>");
      }
      t4.push("<!--]--></div>");
    } else t4.push("<!--[!-->");
    t4.push("<!--]-->"), ss(s5, { open: i7, maps: e3, selectedMapId: n6, showAddAsPoint: v5 });
  });
}
function F2(l7, s5) {
  l7.component((t4) => {
    let a5 = q(s5.maps, () => [], true), o5 = q(s5.selectedMapId, null), i7 = q(s5.toolbarEl, null), e3 = q(s5.showAddAsPoint, false), n6 = false;
    M5(() => {
    }), t4.push(`<div${Jn("top-search-bar svelte-tjhq9j", void 0, { hidden: n6 })}${Qn("", { width: void 0 })}><button type="button" class="search-trigger svelte-tjhq9j"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="svelte-tjhq9j"><circle cx="11" cy="11" r="7"></circle><path d="M21 21l-4.35-4.35"></path></svg> <span class="search-trigger-text svelte-tjhq9j">Search maps, places, coordinates...</span></button></div> <div class="search-anchor svelte-tjhq9j"${Qn("", { "--toolbar-width": "320px" })}>`), q4(t4, { open: n6, maps: a5, selectedMapId: o5, showAddAsPoint: e3 }), t4.push("<!----></div>"), ss(s5, { maps: a5, selectedMapId: o5, toolbarEl: i7, showAddAsPoint: e3 });
  });
}
var init_MapSearchBar = __esm({
  ".svelte-kit/output/server/chunks/MapSearchBar.js"() {
    init_index2();
    init_MapSearchBar_svelte_svelte_type_style_lang();
    init_context();
  }
});

// .svelte-kit/output/server/entries/pages/annotate/_page.svelte.js
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => fn3
});
function Ce2(i7 = Te2) {
  const { subscribe: r5, update: o5, set: c7 } = a3({ history: [], future: [] });
  return { subscribe: r5, limit: i7, push(l7) {
    o5((d2) => ({ history: [...d2.history.slice(-i7 + 1), l7], future: [] }));
  }, undo() {
    let l7 = null;
    return o5((d2) => d2.history.length ? (l7 = d2.history[d2.history.length - 1], { history: d2.history.slice(0, -1), future: [...d2.future, l7] }) : d2), l7;
  }, redo() {
    let l7 = null;
    return o5((d2) => d2.future.length ? (l7 = d2.future[d2.future.length - 1], { history: [...d2.history, l7], future: d2.future.slice(0, -1) }) : d2), l7;
  }, reset() {
    c7({ history: [], future: [] });
  } };
}
function Oe2(i7, r5 = {}) {
  const { geoJson: o5 = new GeoJSON_default() } = r5, c7 = String(i7.getId()), l7 = o5.writeFeatureObject(i7, { featureProjection: "EPSG:3857", dataProjection: "EPSG:4326" });
  return l7.id = c7, { id: c7, feature: l7 };
}
function De2(i7, r5 = {}) {
  const { geoJson: o5 = new GeoJSON_default() } = r5, c7 = o5.readFeature(i7.feature, { dataProjection: "EPSG:4326", featureProjection: "EPSG:3857" });
  return c7.setId(i7.id), c7;
}
function ze3(i7, r5) {
  return r5 && i7.some((o5) => o5.id === r5) ? r5 : null;
}
function Ge3() {
  const { subscribe: i7, update: r5, set: o5 } = a3({ list: [], selectedId: null });
  return { subscribe: i7, setList(c7) {
    r5((l7) => ({ list: c7, selectedId: ze3(c7, l7.selectedId) }));
  }, setSelected(c7) {
    r5((l7) => ({ ...l7, selectedId: c7 }));
  }, clearSelection() {
    r5((c7) => ({ ...c7, selectedId: null }));
  }, clearSelectionIfMatches(c7) {
    c7 && r5((l7) => ({ ...l7, selectedId: l7.selectedId === c7 ? null : l7.selectedId }));
  }, reset() {
    o5({ list: [], selectedId: null });
  } };
}
function _e2(i7) {
  I(xt3, i7);
}
function Re2() {
  const i7 = G(xt3);
  if (!i7) throw new Error("Annotation context is not available \u2014 call setAnnotationContext first.");
  return i7;
}
function Be2(i7 = "anno") {
  return D3(i7);
}
function J2(i7) {
  let r5 = i7.getId();
  r5 || (r5 = Be2(), i7.setId(r5)), i7.get("label") || i7.set("label", "Untitled"), i7.get("color") || i7.set("color", v3), typeof i7.get("hidden") != "boolean" && i7.set("hidden", false);
}
function He3(i7) {
  return J2(i7), { id: i7.getId(), label: i7.get("label") ?? "Untitled", type: i7.getGeometry()?.getType() ?? "Geometry", color: i7.get("color") ?? v3, details: i7.get("details") ?? "", hidden: !!i7.get("hidden") };
}
function Ve2(i7, r5) {
  i7.component((o5) => {
    const { history: c7, state: l7 } = Re2(), d2 = new GeoJSON_default();
    let y5 = q(r5.basemapSelection, "g-streets"), w5 = q(r5.viewMode, "overlay"), F5 = q(r5.sideRatio, 0.5), P8 = q(r5.lensRadius, 150), j6 = q(r5.opacity, 0.8), L4 = q(r5.drawingMode, null), E7 = q(r5.editingEnabled, true), s5 = null, g5 = null, u8 = null, x4 = null, h5 = null, m8 = null, T4 = null, k5 = null, b8 = null, H6 = [];
    const V4 = {};
    let S5 = null, Z5 = null, z3 = null, G3 = null, R7 = false;
    function K2(t4, e3 = false) {
    }
    function M9() {
      const t4 = u8 ? u8.getFeatures().map((e3) => He3(e3)) : [];
      l7.setList(t4);
    }
    function B5(t4) {
      return J2(t4), Oe2(t4, { geoJson: d2 });
    }
    function St3(t4) {
      const e3 = De2(t4, { geoJson: d2 });
      return J2(e3), e3;
    }
    function X4(t4) {
      if (!u8) return null;
      const e3 = u8.getFeatureById(t4.id);
      e3 && u8.removeFeature(e3);
      const n6 = St3(t4);
      return u8.addFeature(n6), n6;
    }
    function ot3(t4) {
      if (!u8) return null;
      const e3 = u8.getFeatureById(t4);
      return e3 && u8.removeFeature(e3), e3;
    }
    function Y3(t4) {
      R7 || c7.push(t4);
    }
    function lt4(t4) {
      Y3({ kind: "annotation-add", snapshot: B5(t4) });
    }
    function It3(t4) {
      Y3({ kind: "annotation-delete", snapshot: B5(t4) });
    }
    function $5(t4, e3, n6, a5) {
      n6 !== a5 && Y3({ kind: "annotation-update", id: String(t4.getId()), changes: [{ field: e3, before: n6, after: a5 }] });
    }
    function At4(t4) {
      if (!t4.length) return;
      const e3 = t4.map((n6) => B5(n6));
      Y3({ kind: "annotation-clear", snapshots: e3 });
    }
    function Pt4(t4) {
      if (!t4.length) return;
      const e3 = t4.map((n6) => B5(n6));
      Y3({ kind: "annotation-bulk-add", snapshots: e3 });
    }
    function Et3() {
      return g5?.getCanvas() ?? null;
    }
    function kt3() {
      const t4 = Et3();
      if (!t4 || !s5) return;
      const e3 = s5.getSize();
      if (!e3) return;
      const [n6, a5] = e3;
      if (w5 === "overlay") t4.style.clipPath = "";
      else if (w5 === "side-x") {
        const p6 = n6 * F5;
        t4.style.clipPath = `polygon(${p6}px 0, ${n6}px 0, ${n6}px ${a5}px, ${p6}px ${a5}px)`;
      } else if (w5 === "side-y") {
        const p6 = a5 * F5;
        t4.style.clipPath = `polygon(0 ${p6}px, ${n6}px ${p6}px, ${n6}px ${a5}px, 0 ${a5}px)`;
      } else if (w5 === "spy") {
        const p6 = P8;
        t4.style.clipPath = `circle(${p6}px at ${n6 / 2}px ${a5 / 2}px)`;
      }
    }
    function Mt4() {
      if (!s5) return;
      const t4 = s5.getSize();
      if (!t4) return;
      const [e3, n6] = t4;
    }
    function Ft3() {
      if (!s5) return;
      const t4 = s5.getSize();
      if (!t4) return;
      const [e3, n6] = t4;
    }
    function W2() {
      kt3(), Mt4(), Ft3();
    }
    function jt4(t4) {
      w5 = t4, W2();
    }
    function Lt4(t4) {
    }
    function rt4() {
    }
    function ct4(t4) {
      s5 && s5.getLayers().getArray().forEach((e3) => {
        const n6 = e3.getProperties();
        n6.base && e3.setVisible(n6.name === t4);
      });
    }
    function Tt4(t4) {
      if (!t4) return false;
      try {
        const e3 = new URL(t4);
        return e3.protocol === "http:" || e3.protocol === "https:";
      } catch {
        return false;
      }
    }
    async function Ct3(t4, e3) {
      if (Tt4(t4)) {
        const n6 = await fetch(t4, { signal: e3 });
        if (!n6.ok) throw new Error(`IIIF resource not accessible (HTTP ${n6.status})`);
        const a5 = await n6.json();
        if (e3.aborted) return { annotations: [], cacheKey: t4 };
        let p6;
        try {
          p6 = IIIF.parse(a5);
        } catch (v5) {
          throw new Error(`Failed to parse IIIF: ${v5.message}`);
        }
        let f8 = [], _5 = null;
        try {
          f8 = await fetchAnnotationsFromApi(p6);
        } catch (v5) {
          _5 = v5 instanceof Error ? v5 : new Error("Unknown Allmaps API error.");
        }
        if (!f8.length) try {
          const v5 = `https://annotations.allmaps.org/?url=${encodeURIComponent(t4)}`, tt2 = await fetch(v5, { signal: e3 });
          if (tt2.ok) {
            const U4 = await tt2.json();
            Array.isArray(U4) ? f8 = U4 : U4 && Array.isArray(U4.annotations) && (f8 = U4.annotations);
          } else {
            const U4 = await tt2.text();
            _5 ??= new Error(`Fallback lookup failed (HTTP ${tt2.status}): ${U4 || "No body"}`);
          }
        } catch (v5) {
          _5 || (_5 = v5 instanceof Error ? v5 : new Error("Unknown fallback lookup error."));
        }
        if (!f8.length) {
          const v5 = _5 ? ` ${_5.message}` : "";
          throw new Error(`No Allmaps annotations found for that IIIF resource.${v5 ? ` ${v5}` : ""}`);
        }
        return { annotations: f8, cacheKey: t4 };
      } else {
        const n6 = `https://annotations.allmaps.org/images/${t4}`, a5 = await fetch(n6, { signal: e3 });
        if (!a5.ok) throw new Error(`Annotation not found (HTTP ${a5.status})`);
        return { annotations: [await a5.json()], cacheKey: t4 };
      }
    }
    async function Ot4(t4, e3) {
      if (!g5) return [];
      const n6 = [];
      for (const a5 of t4) {
        if (e3.aborted) return n6;
        const p6 = await g5.addGeoreferenceAnnotation(a5);
        if (e3.aborted) return n6;
        if (!(!p6 || !p6.length)) for (const f8 of p6) {
          if (f8 instanceof Error) throw f8;
          n6.push(f8);
        }
      }
      return n6;
    }
    async function Dt3(t4) {
      if (!g5) return;
      const e3 = t4.trim();
      if (!e3) return;
      z3 && z3.abort();
      const n6 = new AbortController();
      z3 = n6;
      const { signal: a5 } = n6, p6 = e3;
      if (p6 === Z5 && S5) {
        try {
          g5.setMapOpacity(S5, j6);
        } catch {
        }
        return;
      }
      if (S5) try {
        g5.setMapOpacity(S5, 0);
      } catch {
      }
      try {
        let f8 = [];
        if (p6 in V4) f8 = V4[p6].mapIds;
        else {
          const { annotations: v5 } = await Ct3(p6, a5);
          if (a5.aborted) return;
          if (f8 = await Ot4(v5, a5), !f8.length) throw new Error("Map could not be added to the viewer.");
          V4[p6] = { mapIds: f8 };
        }
        const _5 = f8[0];
        if (!_5) throw new Error("Could not determine map identifier.");
        S5 = _5, Z5 = p6;
        try {
          for (const v5 of f8) g5.setMapOpacity(v5, j6);
        } catch {
        }
        W2();
      } catch (f8) {
        if (f8.name === "AbortError") return;
        `${f8 instanceof Error ? f8.message : "Unknown error"}`;
      } finally {
        a5.aborted || (z3 = null);
      }
    }
    function zt3() {
      if (g5 && S5) try {
        g5.setMapOpacity(S5, 0);
      } catch {
      }
      S5 = null, Z5 = null;
    }
    function Gt2() {
      if (!s5 || !g5) return;
      const t4 = g5.getExtent();
      t4 && s5.getView().fit(t4, { padding: [80, 80, 80, 80], maxZoom: 18, duration: 500 });
    }
    function _t3(t4) {
      if (S5 && g5) try {
        g5.setMapOpacity(S5, t4);
      } catch {
      }
    }
    function at3() {
      !s5 || !T4 || (s5.removeInteraction(T4), T4 = null);
    }
    function ut4() {
      if (!s5 || !u8 || (at3(), !L4)) return;
      const t4 = A4[L4], e3 = new Draw_default({ source: u8, type: t4 });
      e3.on("drawstart", () => b8?.getFeatures().clear()), e3.on("drawend", (n6) => {
        const a5 = n6.feature;
        J2(a5), l7.setSelected(String(a5.getId())), M9(), lt4(a5);
      }), T4 = e3, s5.addInteraction(e3);
    }
    function Rt3() {
      L4 = null, at3();
    }
    function Bt3() {
      if (!s5 || !k5) return;
      E7 = !E7;
      const e3 = s5.getInteractions().getArray().includes(k5);
      E7 && !e3 ? s5.addInteraction(k5) : !E7 && e3 && s5.removeInteraction(k5);
    }
    function N5(t4) {
      return u8?.getFeatureById(t4) ?? null;
    }
    function Ht4(t4, e3) {
      const n6 = N5(t4);
      if (!n6) return;
      const a5 = n6.get("label") ?? "";
      a5 !== e3 && (n6.set("label", e3), $5(n6, "label", a5, e3), M9());
    }
    function Vt2(t4, e3) {
      const n6 = N5(t4);
      if (!n6) return;
      const a5 = n6.get("details") ?? "";
      a5 !== e3 && (n6.set("details", e3), $5(n6, "details", a5, e3), M9());
    }
    function Nt4(t4, e3) {
      const n6 = N5(t4);
      if (!n6) return;
      const a5 = n6.get("color") ?? "";
      a5 !== e3 && (n6.set("color", e3), $5(n6, "color", a5, e3), M9());
    }
    function Ut4(t4) {
      const e3 = N5(t4);
      if (!e3) return;
      const n6 = !!e3.get("hidden");
      e3.set("hidden", !n6), $5(e3, "hidden", n6, !n6), M9();
    }
    function Jt3(t4) {
      if (!s5) return;
      const n6 = N5(t4)?.getGeometry();
      if (n6) if (n6.getType() === "Point") {
        const a5 = n6.getCoordinates();
        s5.getView().animate({ center: a5, zoom: Math.max(s5.getView().getZoom() ?? 16, 17), duration: 350 });
      } else s5.getView().fit(n6.getExtent(), { padding: [80, 80, 80, 80], duration: 400, maxZoom: 18 });
    }
    function Zt3(t4) {
      const e3 = N5(t4);
      !e3 || !u8 || (It3(e3), u8.removeFeature(e3), l7.clearSelectionIfMatches(t4), M9());
    }
    function Kt3() {
      if (!u8) return;
      const t4 = u8.getFeatures();
      At4(t4), u8.clear(), l7.reset();
    }
    function Xt() {
      if (!u8) return;
      const t4 = u8.getFeatures();
      if (!t4.length) return;
      const e3 = d2.writeFeaturesObject(t4, { featureProjection: "EPSG:3857", dataProjection: "EPSG:4326" }), n6 = new Blob([JSON.stringify(e3, null, 2)], { type: "application/geo+json;charset=utf-8;" }), a5 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-"), p6 = URL.createObjectURL(n6), f8 = document.createElement("a");
      f8.href = p6, f8.download = `annotations-${a5}.geojson`, f8.click(), URL.revokeObjectURL(p6);
    }
    async function Yt3(t4) {
      if (!u8) return;
      const e3 = JSON.parse(t4), n6 = d2.readFeatures(e3, { dataProjection: "EPSG:4326", featureProjection: "EPSG:3857" });
      return n6.forEach((a5) => J2(a5)), u8.addFeatures(n6), Pt4(n6), M9(), n6.length;
    }
    function dt3(t4, e3) {
      switch (t4.kind) {
        case "annotation-add":
          e3 === "undo" ? (ot3(t4.snapshot.id), l7.clearSelectionIfMatches(t4.snapshot.id)) : X4(t4.snapshot) && l7.setSelected(t4.snapshot.id);
          break;
        case "annotation-delete":
          e3 === "undo" ? X4(t4.snapshot) && l7.setSelected(t4.snapshot.id) : (ot3(t4.snapshot.id), l7.clearSelectionIfMatches(t4.snapshot.id));
          break;
        case "annotation-update": {
          const n6 = u8?.getFeatureById(t4.id);
          if (!n6) break;
          t4.changes.forEach((a5) => {
            const p6 = e3 === "undo" ? a5.before : a5.after;
            n6.set(a5.field, a5.field === "hidden" ? !!p6 : p6);
          }), n6.changed?.();
          break;
        }
        case "annotation-geometry": {
          const n6 = e3 === "undo" ? t4.before : t4.after;
          X4(n6), l7.setSelected(n6.id);
          break;
        }
        case "annotation-clear":
          e3 === "undo" ? (u8?.clear(), t4.snapshots.forEach((n6) => X4(n6))) : (u8?.clear(), l7.clearSelection());
          break;
        case "annotation-bulk-add":
          e3 === "undo" ? t4.snapshots.forEach((n6) => {
            ot3(n6.id), l7.clearSelectionIfMatches(n6.id);
          }) : t4.snapshots.forEach((n6) => X4(n6));
          break;
      }
      M9();
    }
    function Wt3() {
      const t4 = c7.undo();
      t4 && (R7 = true, dt3(t4, "undo"), R7 = false);
    }
    function qt4() {
      const t4 = c7.redo();
      t4 && (R7 = true, dt3(t4, "redo"), R7 = false);
    }
    function st3(t4) {
      try {
        if (t4.geojson) {
          const e3 = d2.readFeature({ type: "Feature", geometry: t4.geojson, properties: {} }, { dataProjection: "EPSG:4326", featureProjection: "EPSG:3857" });
          return e3.set("label", t4.display_name ?? t4.type ?? "Search result"), e3;
        }
        if (t4.lon && t4.lat) {
          const e3 = new Point_default(fromLonLat2([Number(t4.lon), Number(t4.lat)])), n6 = new Feature_default({ geometry: e3 });
          return n6.set("label", t4.display_name ?? t4.type ?? "Search result"), n6;
        }
      } catch (e3) {
        console.warn("Unable to create feature from search result", e3);
      }
      return null;
    }
    function Qt3(t4) {
      if (!s5 || !x4) return;
      const e3 = st3(t4);
      if (!e3) return;
      x4.clear(), x4.addFeature(e3);
      const n6 = e3.getGeometry();
      if (n6) if (n6.getType() === "Point") {
        const a5 = n6.getCoordinates();
        s5.getView().animate({ center: a5, zoom: Math.max(s5.getView().getZoom() ?? 12, 16), duration: 400 });
      } else s5.getView().fit(n6.getExtent(), { padding: [80, 80, 80, 80], duration: 400, maxZoom: 18 });
    }
    function $t4(t4) {
      if (!u8) return;
      const e3 = st3(t4);
      e3 && (J2(e3), u8.addFeature(e3), lt4(e3), l7.setSelected(String(e3.getId())), M9());
    }
    function te2() {
      x4?.clear();
    }
    function ee3() {
      !s5 || !x4 || "geolocation" in navigator && navigator.geolocation.getCurrentPosition((t4) => {
        const { latitude: e3, longitude: n6 } = t4.coords, a5 = fromLonLat2([n6, e3]);
        x4.clear();
        const p6 = new Feature_default({ geometry: new Point_default(a5) });
        p6.set("label", "Current location"), x4.addFeature(p6), s5.getView().animate({ center: a5, zoom: Math.max(s5.getView().getZoom() ?? 12, 16), duration: 450 });
      }, () => {
      });
    }
    function ne2(t4) {
      if (h5 && (h5.clear(), t4.forEach((e3) => {
        const n6 = new Point_default(fromLonLat2(e3.coordinates)), a5 = new Feature_default({ geometry: n6 });
        a5.setId(e3.id), a5.set("order", e3.order), a5.set("stopId", e3.id), a5.set("completed", false), a5.set("active", false), h5.addFeature(a5);
      }), t4.length >= 2)) {
        const e3 = t4.map((a5) => fromLonLat2(a5.coordinates)), n6 = new Feature_default({ geometry: new LineString_default(e3) });
        n6.setId("hunt-route"), h5.addFeature(n6);
      }
    }
    function oe2(t4, e3) {
      if (!h5) return;
      const n6 = h5.getFeatureById(t4);
      n6 && (e3.completed !== void 0 && n6.set("completed", e3.completed), e3.active !== void 0 && n6.set("active", e3.active), n6.changed?.());
    }
    function ae3() {
      h5?.clear();
    }
    function se2(t4) {
      if (!m8) return;
      m8.clear();
      const e3 = new Point_default(fromLonLat2(t4)), n6 = new Feature_default({ geometry: e3 });
      n6.setId("player-position"), m8.addFeature(n6);
    }
    function ie2() {
      m8?.clear();
    }
    function le3() {
      if (!s5 || !h5) return;
      const t4 = h5.getExtent();
      !t4 || t4.every((e3) => !isFinite(e3)) || s5.getView().fit(t4, { padding: [80, 80, 80, 80], maxZoom: 17, duration: 500 });
    }
    function re2(t4) {
      if (!s5 || !h5) return;
      const n6 = h5.getFeatureById(t4)?.getGeometry();
      if (!n6 || n6.getType() !== "Point") return;
      const a5 = n6.getCoordinates();
      s5.getView().animate({ center: a5, zoom: Math.max(s5.getView().getZoom() ?? 16, 17), duration: 350 });
    }
    function ce3() {
      return s5;
    }
    function ue3() {
      return Z5;
    }
    function de4() {
      return u8;
    }
    function pe2() {
      return d2;
    }
    function pt2() {
      s5 && (G3 !== null && cancelAnimationFrame(G3), G3 = requestAnimationFrame(() => {
        G3 = null, s5?.updateSize(), W2();
      }));
    }
    function fe2(t4) {
      if (u8) try {
        const e3 = d2.readFeatures(t4, { dataProjection: "EPSG:4326", featureProjection: "EPSG:3857" });
        u8.clear(), e3.forEach((n6) => J2(n6)), u8.addFeatures(e3), M9();
      } catch (e3) {
        console.warn("Could not restore saved annotations", e3), u8.clear();
      }
    }
    function he2() {
      if (!u8) return null;
      const t4 = u8.getFeatures();
      return t4.length ? d2.writeFeaturesObject(t4, { featureProjection: "EPSG:3857", dataProjection: "EPSG:4326" }) : null;
    }
    if (M5(() => {
      z3?.abort(), window.removeEventListener("pointermove", Lt4), window.removeEventListener("pointerup", rt4), window.removeEventListener("pointercancel", rt4), window.removeEventListener("resize", pt2), H6.forEach((t4) => unByKey(t4)), H6 = [], at3(), s5 && k5 && s5.removeInteraction(k5), s5 && b8 && s5.removeInteraction(b8), s5?.setTarget(void 0), s5 = null, g5 = null, u8 = null, x4 = null, h5 = null, m8 = null, k5 = null, b8 = null, G3 !== null && (cancelAnimationFrame(G3), G3 = null);
    }), ct4(y5), W2(), L4 !== void 0 && ut4(), S5 && g5 && j6 !== void 0) try {
      g5.setMapOpacity(S5, j6);
    } catch {
    }
    o5.push('<div class="map-surface svelte-g6sn5m"><div class="map svelte-g6sn5m"></div> <div class="divider vertical svelte-g6sn5m" aria-hidden="true"></div> <div class="divider horizontal svelte-g6sn5m" aria-hidden="true"></div> <button class="handle vertical svelte-g6sn5m" type="button" aria-label="Drag vertical split" title="Drag vertical split"></button> <button class="handle horizontal svelte-g6sn5m" type="button" aria-label="Drag horizontal split" title="Drag horizontal split"></button> <div class="lens svelte-g6sn5m" aria-hidden="true"></div> <button class="lens-handle svelte-g6sn5m" type="button" aria-label="Adjust spyglass radius" title="Adjust spyglass radius"></button></div>'), ss(r5, { basemapSelection: y5, viewMode: w5, sideRatio: F5, lensRadius: P8, opacity: j6, drawingMode: L4, editingEnabled: E7, refreshDecorations: W2, setViewMode: jt4, applyBasemap: ct4, loadOverlaySource: Dt3, clearOverlay: zt3, zoomToOverlayExtent: Gt2, setMapOpacity: _t3, applyDrawInteraction: ut4, deactivateDrawing: Rt3, toggleEditing: Bt3, getAnnotationFeature: N5, updateAnnotationLabel: Ht4, updateAnnotationDetails: Vt2, updateAnnotationColor: Nt4, toggleAnnotationVisibility: Ut4, zoomToAnnotation: Jt3, deleteAnnotation: Zt3, clearAnnotations: Kt3, exportAnnotationsAsGeoJSON: Xt, importGeoJsonText: Yt3, undoLastAction: Wt3, redoLastAction: qt4, featureFromSearchResult: st3, zoomToSearchResult: Qt3, addSearchResultToAnnotations: $t4, clearSearchLayer: te2, locateUser: ee3, setHuntStops: ne2, updateHuntStopState: oe2, clearHuntStops: ae3, updatePlayerPosition: se2, clearPlayerPosition: ie2, zoomToHuntStops: le3, zoomToHuntStop: re2, getMapInstance: ce3, getLoadedOverlayId: ue3, getAnnotationSource: de4, getGeoJsonFormat: pe2, scheduleMapResize: pt2, restoreAnnotations: fe2, getAnnotationsGeoJSON: he2 });
  });
}
function Ne2(i7, r5) {
  i7.component((o5) => {
    let c7 = q(r5.annotations, () => [], true), l7 = q(r5.selectedAnnotationId, null), d2 = q(r5.selectedMap, null), y5 = q(r5.drawingMode, null), w5 = q(r5.collapsed, false), F5 = q(r5.projectTitle, ""), P8 = q(r5.projectDescription, ""), j6 = null, L4 = null, E7 = null, s5 = "info";
    function g5(h5, m8 = "info") {
      E7 = h5, s5 = m8;
    }
    function u8(h5) {
      switch (h5) {
        case "Point":
          return "Pt";
        case "LineString":
          return "Ln";
        case "Polygon":
          return "Pg";
        default:
          return "??";
      }
    }
    function x4(h5) {
      switch (h5) {
        case "Point":
          return "type-point";
        case "LineString":
          return "type-line";
        case "Polygon":
          return "type-polygon";
        default:
          return "";
      }
    }
    if (l7 !== L4 && (L4 = l7, l7 && (j6 = l7)), w5) o5.push("<!--[-->"), o5.push('<button type="button" class="panel-toggle svelte-1tx3b38">Show editor</button>');
    else {
      o5.push("<!--[!-->"), o5.push('<aside class="panel svelte-1tx3b38"><div class="panel-header svelte-1tx3b38"><a href="/" class="home-link svelte-1tx3b38"><svg width="16" height="16" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.5 15L7.5 10L12.5 5"></path></svg> Home</a> <button type="button" class="panel-close svelte-1tx3b38" aria-label="Close panel"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M18 6L6 18M6 6l12 12"></path></svg></button></div> <div class="panel-scroll custom-scrollbar svelte-1tx3b38">'), d2 ? (o5.push("<!--[-->"), o5.push(`<section class="panel-card map-info-card svelte-1tx3b38"><h2 class="map-title svelte-1tx3b38">${C2(d2.name)}</h2> <div class="map-meta svelte-1tx3b38">`), d2.year ? (o5.push("<!--[-->"), o5.push(`<span class="meta-badge meta-year svelte-1tx3b38">${C2(d2.year)}</span>`)) : o5.push("<!--[!-->"), o5.push("<!--]--> "), d2.type ? (o5.push("<!--[-->"), o5.push(`<span class="meta-badge meta-city svelte-1tx3b38">${C2(d2.type)}</span>`)) : o5.push("<!--[!-->"), o5.push("<!--]--></div> "), d2.summary ? (o5.push("<!--[-->"), o5.push(`<p class="map-summary svelte-1tx3b38">${C2(d2.summary)}</p>`)) : o5.push("<!--[!-->"), o5.push('<!--]--> <div class="map-actions svelte-1tx3b38"><button type="button" class="action-btn svelte-1tx3b38"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="7"></circle><path d="M21 21l-4.35-4.35"></path><path d="M11 8v6M8 11h6"></path></svg> Zoom to map</button></div></section>')) : (o5.push("<!--[!-->"), o5.push('<section class="panel-card no-map-card svelte-1tx3b38"><div class="instruction-step svelte-1tx3b38"><span class="step-badge svelte-1tx3b38">1</span> <p class="no-map-text svelte-1tx3b38"><strong>Start by choosing a map.</strong><br/> Search for a location above to select a historical overlay.</p></div></section>')), o5.push(`<!--]--> <section class="panel-card editor-card svelte-1tx3b38"><div class="editor-card-header svelte-1tx3b38"><h2 class="panel-card-title svelte-1tx3b38">Annotations</h2> <div class="right-actions svelte-1tx3b38"><button type="button" class="chip ghost small svelte-1tx3b38"${En("disabled", !c7.length, true)}>Clear</button> <button type="button" class="chip ghost small svelte-1tx3b38"${En("disabled", !c7.length, true)}>Export</button> <label class="chip ghost small upload svelte-1tx3b38">Import <input type="file" accept="application/geo+json,.geojson,.json" class="svelte-1tx3b38"/></label></div></div> `), E7 ? (o5.push("<!--[-->"), o5.push(`<p${Jn("notice svelte-1tx3b38", void 0, { errored: s5 === "error", success: s5 === "success" })}>${C2(E7)}</p>`)) : o5.push("<!--[!-->"), o5.push(`<!--]--> <div class="story-meta svelte-1tx3b38"><input type="text"${En("value", F5)} placeholder="Project title" class="svelte-1tx3b38"/> <textarea rows="2" placeholder="Project description" class="svelte-1tx3b38">`);
      const h5 = C2(P8);
      if (h5 && o5.push(`${h5}`), o5.push(`</textarea></div> <div class="draw-controls svelte-1tx3b38"><button type="button"${Jn("chip svelte-1tx3b38", void 0, { placing: y5 === "point" })}>${C2(y5 === "point" ? "Placing..." : "Point")}</button> <button type="button"${Jn("chip svelte-1tx3b38", void 0, { placing: y5 === "line" })}>${C2(y5 === "line" ? "Drawing..." : "Line")}</button> <button type="button"${Jn("chip svelte-1tx3b38", void 0, { placing: y5 === "polygon" })}>${C2(y5 === "polygon" ? "Drawing..." : "Polygon")}</button></div> <div class="points-list svelte-1tx3b38">`), c7.length) {
        o5.push("<!--[-->"), o5.push("<!--[-->");
        const m8 = rs(c7);
        for (let T4 = 0, k5 = m8.length; T4 < k5; T4++) {
          let b8 = m8[T4];
          if (o5.push(`<div${Jn("list-card svelte-1tx3b38", void 0, { selected: b8.id === l7 })} role="button" tabindex="0"><div class="list-card-header svelte-1tx3b38"><span${Jn(`type-badge ${Zn(x4(b8.type))}`, "svelte-1tx3b38")}>${C2(u8(b8.type))}</span> <input type="text"${En("value", b8.label)} placeholder="Annotation name" class="svelte-1tx3b38"/> <div class="list-card-actions svelte-1tx3b38"><button type="button" class="chip ghost small svelte-1tx3b38">Zoom</button> <button type="button" class="chip danger small svelte-1tx3b38">Delete</button></div></div> `), j6 === b8.id) {
            o5.push("<!--[-->"), o5.push('<div class="point-details svelte-1tx3b38"><textarea rows="2" placeholder="Annotation details" class="svelte-1tx3b38">');
            const H6 = C2(b8.details ?? "");
            H6 && o5.push(`${H6}`), o5.push(`</textarea> <div class="color-row svelte-1tx3b38"><span class="field-label svelte-1tx3b38">Colour</span> <input type="color"${En("value", b8.color)} class="svelte-1tx3b38"/> <button type="button" class="chip ghost small svelte-1tx3b38">${C2(b8.hidden ? "Show" : "Hide")}</button></div></div>`);
          } else o5.push("<!--[!-->");
          o5.push("<!--]--></div>");
        }
        o5.push("<!--]-->");
      } else o5.push("<!--[!-->"), o5.push('<div class="empty-state-guide svelte-1tx3b38"><div class="instruction-step svelte-1tx3b38"><span class="step-badge svelte-1tx3b38">2</span> <p><strong>Draw annotations on the map:</strong></p></div> <ul class="instruction-list svelte-1tx3b38"><li class="svelte-1tx3b38">Click <strong>Point</strong>, <strong>Line</strong>, or <strong>Polygon</strong> above</li> <li class="svelte-1tx3b38">Then click on the map to draw</li> <li class="svelte-1tx3b38">Or <strong>Import</strong> a GeoJSON file</li></ul></div>');
      o5.push("<!--]--></div></section></div></aside>");
    }
    o5.push("<!--]-->"), ss(r5, { annotations: c7, selectedAnnotationId: l7, selectedMap: d2, drawingMode: y5, collapsed: w5, projectTitle: F5, projectDescription: P8, setNotice: g5 });
  });
}
function Ue2(i7, r5) {
  i7.component((o5) => {
    var c7;
    let l7, d2, y5, w5, F5, P8, j6, L4, E7;
    const { supabase: s5, session: g5 } = u3(), u8 = Ce2(100), x4 = Ge3();
    _e2({ history: u8, state: x4 });
    const h5 = b5(), m8 = f5();
    let T4 = [], k5 = null, b8 = "", H6 = "", V4 = false, S5 = false, Z5, z3 = null;
    const G3 = [{ mode: "overlay", label: "Overlay", title: "Full overlay" }, { mode: "side-x", label: "Side X", title: "Side by side (horizontal)" }, { mode: "side-y", label: "Side Y", title: "Side by side (vertical)" }, { mode: "spy", label: "Lens", title: "Spy glass" }];
    M5(() => {
    }), l7 = ts(c7 ??= {}, "$mapStore", h5).activeMapId ?? "", d2 = ts(c7 ??= {}, "$layerStore", m8).basemap, y5 = ts(c7 ??= {}, "$layerStore", m8).sideRatio, w5 = ts(c7 ??= {}, "$layerStore", m8).viewMode, F5 = ts(c7 ??= {}, "$layerStore", m8).overlayOpacity, P8 = ts(c7 ??= {}, "$layerStore", m8).lensRadius, j6 = ts(c7 ??= {}, "$annotationState", x4).list, L4 = ts(c7 ??= {}, "$annotationState", x4).selectedId, E7 = l7 ? T4.find((K2) => K2.id === l7) ?? null : null, z3 && clearTimeout(z3), z3 = null, ts(c7 ??= {}, "$annotationHistory", u8).history.length > 0, ts(c7 ??= {}, "$annotationHistory", u8).future.length > 0, o5.push(`<div${Jn("annotate-mode svelte-fhtp41", void 0, { mobile: V4 })}><div${Jn("workspace svelte-fhtp41", void 0, { "with-sidebar": !V4, compact: S5 })}>`), o5.push("<!--[-->"), Ne2(o5, { annotations: j6, selectedAnnotationId: L4, selectedMap: E7, drawingMode: k5, projectTitle: b8, projectDescription: H6, collapsed: false }), o5.push('<!--]--> <div class="map-stage svelte-fhtp41">'), Ve2(o5, { basemapSelection: d2, viewMode: w5, sideRatio: y5, lensRadius: P8, opacity: F5, drawingMode: k5, editingEnabled: true }), o5.push("<!----> "), o5.push("<!--[!-->"), o5.push(`<!--]--> <div class="floating-controls svelte-fhtp41"><button type="button" class="ctrl-btn svelte-fhtp41"${En("title", d2 === "g-streets" ? "Switch to Satellite" : "Switch to Streets")}><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">`), d2 === "g-streets" ? (o5.push("<!--[-->"), o5.push('<circle cx="12" cy="12" r="10"></circle><path d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"></path>')) : (o5.push("<!--[!-->"), o5.push('<rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M3 9h18M3 15h18M9 3v18M15 3v18"></path>')), o5.push("<!--]--></svg></button> "), o5.push("<!--[!-->"), o5.push(`<!--]--></div> <div${Jn("map-toolbar svelte-fhtp41", void 0, { mobile: V4 })}><div class="toolbar-row svelte-fhtp41"><div class="toolbar-group svelte-fhtp41"><span class="toolbar-label svelte-fhtp41">View</span> <div class="toolbar-btns svelte-fhtp41"><!--[-->`);
    const R7 = rs(G3);
    for (let K2 = 0, M9 = R7.length; K2 < M9; K2++) {
      let B5 = R7[K2];
      o5.push(`<button type="button"${Jn("tb svelte-fhtp41", void 0, { active: w5 === B5.mode })}${En("title", B5.title)}>${C2(B5.label)}</button>`);
    }
    o5.push(`<!--]--></div></div> <div class="toolbar-sep svelte-fhtp41"></div> <div class="toolbar-group toolbar-opacity svelte-fhtp41"><span class="toolbar-label svelte-fhtp41">Opacity</span> <div class="toolbar-slider-row svelte-fhtp41"><input type="range" min="0" max="1" step="0.05"${En("value", F5)} class="toolbar-slider svelte-fhtp41"/> <span class="toolbar-slider-val svelte-fhtp41">${C2(Math.round(F5 * 100))}%</span></div></div></div></div> `), w5 === "spy" ? (o5.push("<!--[-->"), o5.push(`<div class="lens-overlay"><div class="lens-ring"${Qn(`width: ${Zn(P8 * 2)}px; height: ${Zn(P8 * 2)}px;`)}></div> <div class="lens-knob"${Qn(`transform: translateX(${Zn(P8)}px);`)} role="slider" aria-label="Lens size"${En("aria-valuemin", 30)}${En("aria-valuemax", 500)}${En("aria-valuenow", P8)} tabindex="0"></div></div>`)) : o5.push("<!--[!-->"), o5.push("<!--]--> "), o5.push("<!--[!-->"), o5.push("<!--]--> "), o5.push("<!--[!-->"), o5.push("<!--]--> "), F2(o5, { maps: T4, selectedMapId: l7, toolbarEl: Z5, showAddAsPoint: false }), o5.push("<!----></div></div> "), o5.push("<!--[!-->"), o5.push("<!--]--></div>"), c7 && es(c7);
  });
}
function fn3(i7) {
  Xn(i7, (r5) => {
    r5.title((o5) => {
      o5.push("<title>Annotate \u2014 Vietnam Map Archive</title>");
    }), r5.push('<meta name="description" content="Draw and annotate historical maps of Vietnam. Create points, lines, and polygons to mark places of interest."/> <link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
  }), Ue2(i7);
}
var Te2, xt3;
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/annotate/_page.svelte.js"() {
    init_index2();
    init_MapSearchBar_svelte_svelte_type_style_lang();
    init_proj();
    init_chunks();
    init_GeoJSON();
    init_context();
    init_context2();
    init_Draw();
    init_LineString();
    init_Feature();
    init_Point();
    init_Observable();
    init_dist14();
    init_dist12();
    init_dist5();
    init_Style();
    init_Fill();
    init_Stroke();
    init_Circle2();
    init_MapSearchBar();
    Te2 = 100;
    xt3 = Symbol("annotation-context");
    new Style_default({ image: new Circle_default2({ radius: 6, fill: new Fill_default({ color: "#06b6d4" }), stroke: new Stroke_default({ color: "#0e7490", width: 2 }) }), stroke: new Stroke_default({ color: "#06b6d4", width: 2 }), fill: new Fill_default({ color: "rgba(6, 182, 212, 0.18)" }) });
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  stylesheets: () => stylesheets5,
  universal: () => universal3,
  universal_id: () => universal_id3
});
var index5, component_cache5, component5, universal3, universal_id3, imports5, stylesheets5, fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    index5 = 4;
    component5 = async () => component_cache5 ??= (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default;
    universal3 = {
      "ssr": false
    };
    universal_id3 = "src/routes/annotate/+page.ts";
    imports5 = ["_app/immutable/nodes/4.wsd_1tcd.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DAqcWgJQ.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/PPVm8Dsz.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/BWsF3rHZ.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/DxkUhP4x.js", "_app/immutable/chunks/m2V9rbtF.js", "_app/immutable/chunks/BqlTOgs2.js", "_app/immutable/chunks/nobbrJXm.js", "_app/immutable/chunks/DezgiKfJ.js", "_app/immutable/chunks/C4Cza0Sg.js", "_app/immutable/chunks/BKtb5Vzl.js", "_app/immutable/chunks/CzAFXcu7.js", "_app/immutable/chunks/Dp1RyEzT.js", "_app/immutable/chunks/BY0SMKbK.js"];
    stylesheets5 = ["_app/immutable/assets/TileImage.BtPuoxOl.css", "_app/immutable/assets/MapSearchBar.CaB7_K8M.css", "_app/immutable/assets/4.DnC1sFfi.css"];
    fonts5 = [];
  }
});

// .svelte-kit/output/server/entries/pages/catalog/_page.svelte.js
var page_svelte_exports4 = {};
__export(page_svelte_exports4, {
  default: () => A7
});
function A7(r5, y5) {
  r5.component((s5) => {
    let o5;
    const { supabase: w5, session: x4 } = u3();
    let u8 = false, v5 = [], h5 = "grid", n6 = "all", c7 = "all", i7 = "", d2 = "name";
    if (o5 = Array.from(new Set(v5.map((e3) => e3.type).filter(Boolean))).sort(), (() => {
      let e3 = v5;
      if (i7.trim()) {
        const t4 = i7.trim().toLowerCase();
        e3 = e3.filter((a5) => a5.name.toLowerCase().includes(t4) || a5.type && a5.type.toLowerCase().includes(t4));
      }
      return e3 = [...e3].sort((t4, a5) => t4.name.localeCompare(a5.name)), e3;
    })(), Xn(s5, (e3) => {
      e3.title((t4) => {
        t4.push("<title>Map Catalog \u2014 Vietnam Map Archive</title>");
      }), e3.push('<meta name="description" content="Browse the full collection of historical maps of Vietnam." class="svelte-ec29qo"/> <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700;800&amp;family=Outfit:wght@400;600;800&amp;family=Be+Vietnam+Pro:wght@400;600;800&amp;display=swap" rel="stylesheet" class="svelte-ec29qo"/>');
    }), s5.push(`<div${Jn("page svelte-ec29qo", void 0, { mounted: u8 })}><header class="top-bar svelte-ec29qo"><div class="top-bar-left svelte-ec29qo"><a href="/" class="icon-btn back-btn svelte-ec29qo" aria-label="Back to home"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svelte-ec29qo"><path d="M19 12H5M12 19l-7-7 7-7" class="svelte-ec29qo"></path></svg></a> <h1 class="page-title svelte-ec29qo">The Archive <span class="sparkle svelte-ec29qo">\u2728</span></h1></div> <div class="top-bar-right svelte-ec29qo"><div class="search-box svelte-ec29qo"><span class="search-emoji svelte-ec29qo">\u{1F50D}</span> <input type="text" placeholder="Search maps..."${En("value", i7)} class="chunky-input svelte-ec29qo"/></div> <div class="controls-group svelte-ec29qo"><div class="view-toggle svelte-ec29qo"><button${Jn("toggle-btn svelte-ec29qo", void 0, { active: h5 === "grid" })} aria-label="Grid view"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" class="svelte-ec29qo"><rect x="3" y="3" width="7" height="7" rx="1" class="svelte-ec29qo"></rect><rect x="14" y="3" width="7" height="7" rx="1" class="svelte-ec29qo"></rect><rect x="3" y="14" width="7" height="7" rx="1" class="svelte-ec29qo"></rect><rect x="14" y="14" width="7" height="7" rx="1" class="svelte-ec29qo"></rect></svg></button> <button${Jn("toggle-btn svelte-ec29qo", void 0, { active: h5 === "list" })} aria-label="List view"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" class="svelte-ec29qo"><rect x="3" y="4" width="18" height="4" rx="1" class="svelte-ec29qo"></rect><rect x="3" y="10" width="18" height="4" rx="1" class="svelte-ec29qo"></rect><rect x="3" y="16" width="18" height="4" rx="1" class="svelte-ec29qo"></rect></svg></button></div> `), s5.select({ class: "chunky-select", value: d2 }, (e3) => {
      e3.option({ value: "name", class: "" }, (t4) => {
        t4.push("Name A\u2013Z");
      }, "svelte-ec29qo"), e3.option({ value: "year", class: "" }, (t4) => {
        t4.push("Oldest First");
      }, "svelte-ec29qo"), e3.option({ value: "newest", class: "" }, (t4) => {
        t4.push("Newest First");
      }, "svelte-ec29qo");
    }, "svelte-ec29qo"), s5.push(`</div></div></header> <main class="content svelte-ec29qo"><div class="controls-card svelte-ec29qo"><div class="collection-tabs svelte-ec29qo"><button${Jn("chunky-tab svelte-ec29qo", void 0, { active: c7 === "all" })}>\u{1F4DA} All Maps</button> <button${Jn("chunky-tab svelte-ec29qo", void 0, { active: c7 === "featured" })}>\u{1F31F} Featured</button> <button${Jn("chunky-tab svelte-ec29qo", void 0, { active: c7 === "favorites" })}>\u2764\uFE0F Favorites</button></div> `), o5.length > 1) {
      s5.push("<!--[-->"), s5.push(`<div class="city-filters svelte-ec29qo"><button${Jn("filter-pill svelte-ec29qo", void 0, { active: n6 === "all" })}>All Cities</button> <!--[-->`);
      const e3 = rs(o5);
      for (let t4 = 0, a5 = e3.length; t4 < a5; t4++) {
        let p6 = e3[t4];
        s5.push(`<button${Jn("filter-pill svelte-ec29qo", void 0, { active: n6 === p6 })}>${C2(p6)}</button>`);
      }
      s5.push("<!--]--></div>");
    } else s5.push("<!--[!-->");
    s5.push("<!--]--></div> "), s5.push("<!--[-->"), s5.push('<div class="state-panel svelte-ec29qo"><div class="spinner svelte-ec29qo">\u{1F30E}</div> <h2 class="state-title svelte-ec29qo">Digging through the archives...</h2></div>'), s5.push("<!--]--></main></div>");
  });
}
var init_page_svelte4 = __esm({
  ".svelte-kit/output/server/entries/pages/catalog/_page.svelte.js"() {
    init_index2();
    init_context2();
    init_context();
  }
});

// .svelte-kit/output/server/nodes/5.js
var __exports6 = {};
__export(__exports6, {
  component: () => component6,
  fonts: () => fonts6,
  imports: () => imports6,
  index: () => index6,
  stylesheets: () => stylesheets6
});
var index6, component_cache6, component6, imports6, stylesheets6, fonts6;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    index6 = 5;
    component6 = async () => component_cache6 ??= (await Promise.resolve().then(() => (init_page_svelte4(), page_svelte_exports4))).default;
    imports6 = ["_app/immutable/nodes/5.DnnGDKS1.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DAqcWgJQ.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/BWsF3rHZ.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/DxkUhP4x.js", "_app/immutable/chunks/CzAFXcu7.js", "_app/immutable/chunks/Cg4Xvy-O.js", "_app/immutable/chunks/BqlTOgs2.js", "_app/immutable/chunks/CvFblwoI.js"];
    stylesheets6 = ["_app/immutable/assets/5.dC7IEDJw.css"];
    fonts6 = [];
  }
});

// .svelte-kit/output/server/entries/pages/contribute/georef/_page.svelte.js
var page_svelte_exports5 = {};
__export(page_svelte_exports5, {
  default: () => f6
});
function f6(a5, u8) {
  a5.component((s5) => {
    const { supabase: h5, session: m8 } = u3();
    let l7 = false;
    Xn(s5, (t4) => {
      t4.title((e3) => {
        e3.push("<title>Help Georeference Maps \u2014 Vietnam Map Archive</title>");
      }), t4.push('<link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
    }), s5.push(`<div${Jn("page svelte-1xe2uml", void 0, { mounted: l7 })}><header class="hero svelte-1xe2uml"><div class="hero-content svelte-1xe2uml"><a href="/" class="back-link svelte-1xe2uml">\u2190 Back to Home</a> <h1 class="hero-title svelte-1xe2uml">Help Georeference Maps</h1> <p class="hero-subtitle svelte-1xe2uml">Help us bring historical maps to life. Pick a map, georeference it using the Allmaps Editor,
				and submit for review.</p></div></header> <main class="main svelte-1xe2uml">`), s5.push("<!--[!-->"), s5.push("<!--]--> "), s5.push("<!--[!-->"), s5.push("<!--]--> "), s5.push("<!--[!-->"), s5.push('<!--]--> <section class="submissions-section svelte-1xe2uml">'), s5.push("<!--[-->"), s5.push('<div class="loading svelte-1xe2uml">Loading submissions...</div>'), s5.push("<!--]--></section></main> "), s5.push("<!--[!-->"), s5.push("<!--]--> "), s5.push("<!--[!-->"), s5.push("<!--]--></div>");
  });
}
var init_page_svelte5 = __esm({
  ".svelte-kit/output/server/entries/pages/contribute/georef/_page.svelte.js"() {
    init_index2();
    init_context2();
  }
});

// .svelte-kit/output/server/nodes/6.js
var __exports7 = {};
__export(__exports7, {
  component: () => component7,
  fonts: () => fonts7,
  imports: () => imports7,
  index: () => index7,
  stylesheets: () => stylesheets7
});
var index7, component_cache7, component7, imports7, stylesheets7, fonts7;
var init__7 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    index7 = 6;
    component7 = async () => component_cache7 ??= (await Promise.resolve().then(() => (init_page_svelte5(), page_svelte_exports5))).default;
    imports7 = ["_app/immutable/nodes/6.CHe5PhpD.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DAqcWgJQ.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/BWsF3rHZ.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/CzAFXcu7.js", "_app/immutable/chunks/BqlTOgs2.js"];
    stylesheets7 = ["_app/immutable/assets/6.z6PksWx2.css"];
    fonts7 = [];
  }
});

// .svelte-kit/output/server/entries/pages/contribute/label/_page.svelte.js
var page_svelte_exports6 = {};
__export(page_svelte_exports6, {
  default: () => A8
});
function I5(h5, n6) {
  h5.component((s5) => {
    let u8;
    function w5(t4, i7) {
      const l7 = typeof t4 == "string" ? t4 : t4.val;
      return typeof t4 != "string" ? i7.some((b8) => b8.label === l7) : false;
    }
    function m8(t4) {
      return typeof t4 == "string" ? t4 : t4.label;
    }
    function g5(t4) {
      return typeof t4 == "string" ? t4 : t4.val;
    }
    let e3 = q(n6.legendItems, () => [], true), d2 = q(n6.selectedLabel, null), o5 = q(n6.placedPins, () => [], true), p6 = "";
    u8 = p6.trim() ? e3.filter((t4) => {
      const i7 = p6.trim().toLowerCase(), l7 = g5(t4).toString().toLowerCase(), b8 = m8(t4).toLowerCase();
      return l7.includes(i7) || b8.includes(i7);
    }) : e3, s5.push(`<aside class="sidebar"><div class="sidebar-header"><a href="/" class="back-link small" title="Back to home"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 6l6-4.5L14 6v7.5a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 012 13.5V6z"></path><path d="M6 15V9h4v6"></path></svg></a> <h3 class="sidebar-header-title">Label Studio</h3></div> <section class="sidebar-section legend-section"><h3 class="section-title">Legend</h3> <p class="section-hint">Select a label, then click on the map image to place it.</p> <div class="legend-search"><svg class="legend-search-icon" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"></circle><path d="M15 15l-3.5-3.5"></path></svg> <input type="text" class="legend-search-input" placeholder="Search by number or name..."${En("value", p6)}/></div> <div class="legend-list"><!--[-->`);
    const f8 = rs(u8);
    for (let t4 = 0, i7 = f8.length; t4 < i7; t4++) {
      let l7 = f8[t4];
      const b8 = g5(l7), x4 = m8(l7), k5 = w5(l7, o5);
      s5.push(`<button type="button"${Jn("legend-item", void 0, { "list-item": typeof l7 != "string", selected: b8 === d2, mapped: k5 })}${En("disabled", k5, true)}${En("title", k5 ? "Already mapped" : x4)}>`), typeof l7 != "string" ? (s5.push("<!--[-->"), s5.push(`<span class="item-val">${C2(b8)}</span> <span class="item-label">${C2(x4)}</span>`)) : (s5.push("<!--[!-->"), s5.push(`${C2(l7)}`)), s5.push("<!--]--></button>");
    }
    s5.push("<!--]--> "), e3.length ? (s5.push("<!--[!-->"), u8.length ? s5.push("<!--[!-->") : (s5.push("<!--[-->"), s5.push(`<p class="empty-state">No matches for "${C2(p6)}"</p>`)), s5.push("<!--]-->")) : (s5.push("<!--[-->"), s5.push('<p class="empty-state">No legend items for this task.</p>')), s5.push(`<!--]--></div></section> <section class="sidebar-section"><h3 class="section-title">Placed Labels (${C2(o5.length)})</h3> <div class="pin-list custom-scrollbar"><!--[-->`);
    const c7 = rs(o5);
    for (let t4 = 0, i7 = c7.length; t4 < i7; t4++) {
      let l7 = c7[t4];
      s5.push(`<div class="pin-item"><span class="pin-label">${C2(l7.label)}</span> <span class="pin-coords">(${C2(Math.round(l7.pixelX))}, ${C2(Math.round(l7.pixelY))})</span> <button type="button" class="pin-remove" aria-label="Remove pin">\xD7</button></div>`);
    }
    s5.push("<!--]--> "), o5.length ? s5.push("<!--[!-->") : (s5.push("<!--[-->"), s5.push('<p class="empty-state">No labels placed yet.</p>')), s5.push(`<!--]--></div></section> <div class="sidebar-footer"><button type="button" class="submit-btn"${En("disabled", o5.length === 0, true)}>Submit Labels</button></div></aside>`), ss(n6, { legendItems: e3, selectedLabel: d2, placedPins: o5 });
  });
}
function B3(h5, n6) {
  h5.component((s5) => {
    let u8;
    const { supabase: w5, session: m8 } = u3(), g5 = m8?.user?.id;
    let e3 = [], d2 = 0, o5 = [], p6 = [], f8 = null;
    if (u8 = ["Building", "Temple", "Market", "School", "Hospital", "Government", "Residence", "Bridge", "Park", "Unknown"], p6 = g5 ? o5.filter((c7) => c7.userId === g5) : [], s5.push('<div class="label-studio svelte-gndb16">'), s5.push("<!--[!-->"), s5.push('<!--]--> <div class="studio-body svelte-gndb16"><div class="canvas-area svelte-gndb16">'), s5.push("<!--[-->"), s5.push('<div class="loading svelte-gndb16">Loading tasks...</div>'), s5.push('<!--]--></div> <div class="sidebar-area svelte-gndb16">'), I5(s5, { legendItems: u8, selectedLabel: f8, placedPins: p6 }), s5.push("<!----> "), s5.push("<!--[!-->"), s5.push("<!--]--> "), e3.length > 1 ? (s5.push("<!--[-->"), s5.push(`<div class="nav-controls svelte-gndb16"><button class="skip-btn svelte-gndb16"${En("disabled", d2 >= e3.length - 1, true)}>Skip \u2192 Next Task</button> <span class="task-counter svelte-gndb16">${C2(d2 + 1)} / ${C2(e3.length)}</span></div>`)) : s5.push("<!--[!-->"), s5.push("<!--]--></div></div> "), s5.push("<!--[!-->"), s5.push("<!--]--> "), e3.length > 1) {
      s5.push("<!--[-->"), s5.push('<div class="task-nav svelte-gndb16"><!--[-->');
      const c7 = rs(e3);
      for (let t4 = 0, i7 = c7.length; t4 < i7; t4++) c7[t4], s5.push(`<button type="button"${Jn("task-btn svelte-gndb16", void 0, { active: t4 === d2 })}>Task ${C2(t4 + 1)}</button>`);
      s5.push("<!--]--></div>");
    } else s5.push("<!--[!-->");
    s5.push("<!--]--></div>");
  });
}
function A8(h5) {
  Xn(h5, (n6) => {
    n6.title((s5) => {
      s5.push("<title>Label Studio \u2014 Vietnam Map Archive</title>");
    }), n6.push('<meta name="description" content="Help identify buildings and landmarks on historical maps. Place labels, reach consensus, and contribute to the archive."/> <link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
  }), B3(h5);
}
var init_page_svelte6 = __esm({
  ".svelte-kit/output/server/entries/pages/contribute/label/_page.svelte.js"() {
    init_index2();
    init_context2();
    init_context();
  }
});

// .svelte-kit/output/server/nodes/7.js
var __exports8 = {};
__export(__exports8, {
  component: () => component8,
  fonts: () => fonts8,
  imports: () => imports8,
  index: () => index8,
  stylesheets: () => stylesheets8,
  universal: () => universal4,
  universal_id: () => universal_id4
});
var index8, component_cache8, component8, universal4, universal_id4, imports8, stylesheets8, fonts8;
var init__8 = __esm({
  ".svelte-kit/output/server/nodes/7.js"() {
    index8 = 7;
    component8 = async () => component_cache8 ??= (await Promise.resolve().then(() => (init_page_svelte6(), page_svelte_exports6))).default;
    universal4 = {
      "ssr": false
    };
    universal_id4 = "src/routes/contribute/label/+page.ts";
    imports8 = ["_app/immutable/nodes/7.bDsP6CZh.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DAqcWgJQ.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/BWsF3rHZ.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/CzAFXcu7.js", "_app/immutable/chunks/m2V9rbtF.js", "_app/immutable/chunks/nobbrJXm.js", "_app/immutable/chunks/DezgiKfJ.js", "_app/immutable/chunks/C4Cza0Sg.js"];
    stylesheets8 = ["_app/immutable/assets/TileImage.BtPuoxOl.css", "_app/immutable/assets/7.Dp01XZEv.css"];
    fonts8 = [];
  }
});

// .svelte-kit/output/server/chunks/StoryPlayback.svelte_svelte_type_style_lang.js
function R6(t4) {
  return { id: t4.id, order: t4.sort_order, title: t4.title, description: t4.description || "", hint: t4.hint || void 0, quest: t4.quest || void 0, coordinates: [t4.lon, t4.lat], triggerRadius: t4.trigger_radius, interaction: t4.interaction, challenge: { type: "reach", triggerRadius: t4.trigger_radius }, qrPayload: t4.qr_payload || void 0, overlayMapId: t4.overlay_map_id || void 0 };
}
function H4(t4, r5) {
  const e3 = r5.filter((n6) => n6.hunt_id === t4.id).sort((n6, d2) => n6.sort_order - d2.sort_order).map(R6);
  return { id: t4.id, title: t4.title, description: t4.description || "", mode: "guided", points: e3, stops: e3, region: t4.region, createdAt: new Date(t4.created_at).getTime(), updatedAt: new Date(t4.updated_at).getTime(), isPublic: t4.is_public, authorId: t4.user_id };
}
async function O5(t4, r5) {
  const { data: e3, error: n6 } = await t4.from("hunts").select("*").eq("user_id", r5).order("updated_at", { ascending: false });
  if (n6 || !e3) return console.error("Failed to fetch stories:", n6), [];
  const d2 = e3;
  if (d2.length === 0) return [];
  const l7 = d2.map((c7) => c7.id), { data: p6, error: h5 } = await t4.from("hunt_stops").select("*").in("hunt_id", l7).order("sort_order");
  return h5 && console.error("Failed to fetch story points:", h5), d2.map((c7) => H4(c7, p6 || []));
}
async function b6(t4, r5, e3) {
  const n6 = { user_id: r5, title: e3.title, description: e3.description || null, region: e3.region || null }, { data: d2, error: l7 } = await t4.from("hunts").insert(n6).select("id").single();
  return l7 ? (console.error("Failed to create story:", l7), null) : d2.id;
}
async function E5(t4, r5, e3) {
  const { error: n6 } = await t4.from("hunts").update({ ...e3, updated_at: (/* @__PURE__ */ new Date()).toISOString() }).eq("id", r5);
  return n6 ? (console.error("Failed to update story:", n6), false) : true;
}
async function Y2(t4, r5) {
  const { error: e3 } = await t4.from("hunts").delete().eq("id", r5);
  return e3 ? (console.error("Failed to delete story:", e3), false) : true;
}
async function $3(t4, r5, e3) {
  const n6 = { hunt_id: r5, sort_order: e3.sortOrder, title: e3.title, lon: e3.coordinates[0], lat: e3.coordinates[1] }, { data: d2, error: l7 } = await t4.from("hunt_stops").insert(n6).select("id").single();
  return l7 ? (console.error("Failed to add point:", l7), null) : (await t4.from("hunts").update({ updated_at: (/* @__PURE__ */ new Date()).toISOString() }).eq("id", r5), d2.id);
}
async function M8(t4, r5, e3) {
  const { error: n6 } = await t4.from("hunt_stops").update(e3).eq("id", r5);
  return n6 ? (console.error("Failed to update point:", n6), false) : true;
}
async function L3(t4, r5) {
  const { error: e3 } = await t4.from("hunt_stops").delete().eq("id", r5);
  return e3 ? (console.error("Failed to remove point:", e3), false) : true;
}
async function w4(t4, r5, e3, n6) {
  const { error: d2 } = await t4.from("hunt_progress").upsert({ user_id: r5, hunt_id: e3, ...n6 }, { onConflict: "user_id,hunt_id" });
  return d2 ? (console.error("Failed to upsert progress:", d2), false) : true;
}
async function I6(t4, r5) {
  const { data: e3, error: n6 } = await t4.from("hunt_progress").select("*").eq("user_id", r5);
  if (n6 || !e3) return {};
  const d2 = e3, l7 = {};
  for (const p6 of d2) l7[p6.hunt_id] = { storyId: p6.hunt_id, huntId: p6.hunt_id, currentPointIndex: p6.current_stop_index, currentStopIndex: p6.current_stop_index, completedPoints: p6.completed_stops, completedStops: p6.completed_stops, startedAt: new Date(p6.started_at).getTime(), completedAt: p6.completed_at ? new Date(p6.completed_at).getTime() : void 0 };
  return l7;
}
function D5() {
  return typeof window < "u";
}
function N3(t4, r5) {
  let e3;
  return (n6) => {
    e3 !== void 0 && clearTimeout(e3), e3 = setTimeout(() => {
      t4(n6), e3 = void 0;
    }, r5);
  };
}
function U3(t4, r5, e3) {
  if (!D5()) return r5;
  const n6 = e3 ?? window.localStorage;
  try {
    const d2 = n6.getItem(t4);
    if (d2) {
      const l7 = JSON.parse(d2);
      return typeof r5 == "object" && r5 !== null && !Array.isArray(r5) ? { ...r5, ...l7 } : l7;
    }
  } catch (d2) {
    console.warn(`[PersistedStore] Failed to load "${t4}":`, d2);
  }
  return r5;
}
function A9(t4, r5, e3) {
  if (!D5()) return;
  const n6 = e3 ?? window.localStorage;
  try {
    n6.setItem(t4, JSON.stringify(r5));
  } catch (d2) {
    console.warn(`[PersistedStore] Failed to save "${t4}":`, d2);
  }
}
function F3(t4) {
  const { key: r5, defaultValue: e3, debounceMs: n6 = 0, storage: d2 } = t4, l7 = U3(r5, e3, d2), { subscribe: p6, set: h5, update: c7 } = a3(l7), f8 = n6 > 0 ? N3((i7) => A9(r5, i7, d2), n6) : (i7) => A9(r5, i7, d2);
  function y5(i7) {
    h5(i7), f8(i7);
  }
  function _5(i7) {
    c7((a5) => {
      const o5 = i7(a5);
      return f8(o5), o5;
    });
  }
  function v5() {
    y5(e3);
  }
  return { subscribe: p6, set: y5, update: _5, reset: v5 };
}
function B4(t4) {
  return { ...t4, hunts: t4.stories };
}
function z(t4, r5) {
  const e3 = F3({ key: j5, defaultValue: { stories: [], hunts: [] }, debounceMs: 300 }), n6 = { subscribe: e3.subscribe, set(i7) {
    e3.set(B4(i7));
  }, update(i7) {
    e3.update((a5) => {
      const o5 = i7(a5), s5 = o5.stories ?? o5.hunts ?? a5.stories;
      return { stories: s5, hunts: s5 };
    });
  }, reset: e3.reset };
  async function d2() {
    if (!(!t4 || !r5)) try {
      const i7 = await O5(t4, r5);
      i7.length > 0 && n6.set({ stories: i7, hunts: i7 });
    } catch (i7) {
      console.error("Failed to load stories from Supabase:", i7);
    }
  }
  d2();
  function l7(i7 = "New Story", a5 = "") {
    const o5 = D3("story"), s5 = Date.now(), g5 = { id: o5, title: i7, description: a5, mode: "guided", points: [], stops: [], createdAt: s5, updatedAt: s5, isPublic: false, authorId: r5 ?? "" };
    return n6.update((u8) => ({ stories: [...u8.stories, g5] })), t4 && r5 && b6(t4, r5, { title: i7, description: a5 }).then((u8) => {
      u8 && n6.update((m8) => ({ stories: m8.stories.map((S5) => S5.id === o5 ? { ...S5, id: u8 } : S5) }));
    }), o5;
  }
  function p6(i7, a5) {
    n6.update((o5) => ({ stories: o5.stories.map((s5) => s5.id === i7 ? { ...s5, ...a5, updatedAt: Date.now() } : s5) })), t4 && r5 && E5(t4, i7, a5);
  }
  function h5(i7) {
    n6.update((a5) => ({ stories: a5.stories.filter((o5) => o5.id !== i7) })), t4 && r5 && Y2(t4, i7);
  }
  function c7(i7, a5) {
    return i7.find((o5) => o5.id === a5);
  }
  function f8(i7, a5) {
    const o5 = D3("point");
    let s5 = 0;
    return n6.update((g5) => ({ stories: g5.stories.map((u8) => {
      if (u8.id !== i7) return u8;
      s5 = u8.points.length;
      const m8 = { id: o5, order: s5, title: `Point ${u8.points.length + 1}`, description: "", coordinates: a5, triggerRadius: 10, interaction: "proximity", challenge: { type: "reach", triggerRadius: 10 } }, S5 = [...u8.points, m8];
      return { ...u8, points: S5, stops: S5, updatedAt: Date.now() };
    }) })), t4 && r5 && $3(t4, i7, { title: `Point ${s5 + 1}`, coordinates: a5, sortOrder: s5 }).then((g5) => {
      g5 && n6.update((u8) => ({ stories: u8.stories.map((m8) => m8.id !== i7 ? m8 : { ...m8, points: m8.points.map((S5) => S5.id === o5 ? { ...S5, id: g5 } : S5) }) }));
    }), o5;
  }
  function y5(i7, a5, o5) {
    if (n6.update((s5) => ({ stories: s5.stories.map((g5) => {
      if (g5.id !== i7) return g5;
      const u8 = g5.points.map((m8) => m8.id === a5 ? { ...m8, ...o5 } : m8);
      return { ...g5, points: u8, stops: u8, updatedAt: Date.now() };
    }) })), t4 && r5) {
      const s5 = {};
      o5.title !== void 0 && (s5.title = o5.title), o5.description !== void 0 && (s5.description = o5.description), o5.hint !== void 0 && (s5.hint = o5.hint), o5.quest !== void 0 && (s5.quest = o5.quest), o5.coordinates !== void 0 && (s5.lon = o5.coordinates[0], s5.lat = o5.coordinates[1]), o5.triggerRadius !== void 0 && (s5.trigger_radius = o5.triggerRadius), o5.interaction !== void 0 && (s5.interaction = o5.interaction), o5.qrPayload !== void 0 && (s5.qr_payload = o5.qrPayload), o5.overlayMapId !== void 0 && (s5.overlay_map_id = o5.overlayMapId), o5.order !== void 0 && (s5.sort_order = o5.order), M8(t4, a5, s5);
    }
  }
  function _5(i7, a5) {
    n6.update((o5) => ({ stories: o5.stories.map((s5) => {
      if (s5.id !== i7) return s5;
      const u8 = s5.points.filter((m8) => m8.id !== a5).map((m8, S5) => ({ ...m8, order: S5 }));
      return { ...s5, points: u8, stops: u8, updatedAt: Date.now() };
    }) })), t4 && r5 && L3(t4, a5);
  }
  function v5(i7, a5, o5) {
    n6.update((s5) => ({ stories: s5.stories.map((g5) => {
      if (g5.id !== i7) return g5;
      const u8 = [...g5.points], [m8] = u8.splice(a5, 1);
      u8.splice(o5, 0, m8);
      const S5 = u8.map((q5, x4) => ({ ...q5, order: x4 }));
      return { ...g5, points: S5, stops: S5, updatedAt: Date.now() };
    }) }));
  }
  return { subscribe: n6.subscribe, set: n6.set, update: n6.update, reset: n6.reset, createStory: l7, updateStory: p6, deleteStory: h5, getStory: c7, addPoint: f8, updatePoint: y5, removePoint: _5, reorderPoints: v5, loadFromSupabase: d2, createHunt: l7, updateHunt: p6, deleteHunt: h5, getHunt: c7, addStop: f8, updateStop: y5, removeStop: _5, reorderStops: v5 };
}
function G2(t4, r5) {
  const e3 = F3({ key: k4, defaultValue: J3, debounceMs: 300 });
  async function n6() {
    if (!(!t4 || !r5)) try {
      const c7 = await I6(t4, r5);
      Object.keys(c7).length > 0 && e3.update((f8) => ({ ...f8, progress: { ...f8.progress, ...c7 } }));
    } catch (c7) {
      console.error("Failed to load story progress from Supabase:", c7);
    }
  }
  n6();
  function d2(c7) {
    e3.update((f8) => {
      const y5 = f8.progress[c7];
      if (y5 && !y5.completedAt) return { ...f8, activeStoryId: c7 };
      const _5 = { storyId: c7, huntId: c7, currentPointIndex: 0, currentStopIndex: 0, completedPoints: [], completedStops: [], startedAt: Date.now() };
      return { activeStoryId: c7, progress: { ...f8.progress, [c7]: _5 } };
    }), t4 && r5 && w4(t4, r5, c7, { current_stop_index: 0, completed_stops: [] });
  }
  function l7(c7, f8, y5) {
    let _5;
    e3.update((v5) => {
      const i7 = v5.progress[c7];
      if (!i7) return v5;
      const a5 = [...i7.completedPoints, f8], o5 = i7.currentPointIndex + 1, s5 = o5 >= y5;
      return _5 = { ...i7, completedPoints: a5, completedStops: a5, currentPointIndex: o5, currentStopIndex: o5, completedAt: s5 ? Date.now() : void 0 }, { ...v5, progress: { ...v5.progress, [c7]: _5 } };
    }), t4 && r5 && _5 && w4(t4, r5, c7, { current_stop_index: _5.currentPointIndex, completed_stops: _5.completedPoints, completed_at: _5.completedAt ? new Date(_5.completedAt).toISOString() : null });
  }
  function p6() {
    e3.update((c7) => ({ ...c7, activeStoryId: null }));
  }
  function h5(c7) {
    e3.update((f8) => {
      const { [c7]: y5, ..._5 } = f8.progress;
      return { ...f8, activeStoryId: f8.activeStoryId === c7 ? null : f8.activeStoryId, progress: _5 };
    });
  }
  return { subscribe: e3.subscribe, set: e3.set, update: e3.update, reset: e3.reset, startStory: d2, completePoint: l7, stopStory: p6, resetProgress: h5, loadFromSupabase: n6, startHunt: d2, completeStop: l7, stopHunt: p6 };
}
var j5, k4, J3;
var init_StoryPlayback_svelte_svelte_type_style_lang = __esm({
  ".svelte-kit/output/server/chunks/StoryPlayback.svelte_svelte_type_style_lang.js"() {
    init_chunks();
    init_MapSearchBar_svelte_svelte_type_style_lang();
    j5 = "vma-story-library-v1";
    k4 = "vma-story-player-v1";
    J3 = { activeStoryId: null, progress: {} };
  }
});

// .svelte-kit/output/server/entries/pages/create/_page.svelte.js
var page_svelte_exports7 = {};
__export(page_svelte_exports7, {
  default: () => Z4
});
function H5(t4, a5) {
  t4.push('<div class="catalog-page"><!--[-->'), ns(t4, a5, "header", {}), t4.push('<!--]--> <div class="catalog-container"><!--[-->'), ns(t4, a5, "filters", {}), t4.push('<!--]--> <main class="catalog-main"><!--[-->'), ns(t4, a5, "default", {}), t4.push("<!--]--></main></div></div>");
}
function z2(t4, a5) {
  let s5 = a5.title, i7 = q(a5.subtitle, ""), l7 = q(a5.backLink, "/"), u8 = q(a5.backLabel, "Back to home"), h5 = q(a5.searchQuery, ""), p6 = q(a5.placeholder, "Search..."), d2 = q(a5.variant, "default");
  t4.push(`<header${Jn(`catalog-header ${Zn(d2)}`)}>`), d2 === "hero" ? (t4.push("<!--[-->"), t4.push('<div class="hero-content">'), l7 ? (t4.push("<!--[-->"), t4.push(`<a${En("href", l7)} class="back-link-hero"${En("aria-label", u8)}>\u2190 ${C2(u8)}</a>`)) : t4.push("<!--[!-->"), t4.push(`<!--]--> <h1 class="page-title">${C2(s5)}</h1> `), i7 ? (t4.push("<!--[-->"), t4.push(`<p class="page-subtitle">${C2(i7)}</p>`)) : t4.push("<!--[!-->"), t4.push('<!--]--> <div class="hero-actions"><!--[-->'), ns(t4, a5, "actions", {}), t4.push("<!--]--></div></div> "), h5 ? (t4.push("<!--[-->"), t4.push(`<div class="search-box-hero"><svg class="search-icon" width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="7" cy="7" r="5.5" stroke="currentColor" stroke-width="1.5"></circle><path d="M11 11L14 14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg> <input type="text"${En("placeholder", p6)}${En("value", h5)} class="search-input"/></div>`)) : t4.push("<!--[!-->"), t4.push("<!--]-->")) : (t4.push("<!--[!-->"), t4.push('<div class="header-left">'), l7 ? (t4.push("<!--[-->"), t4.push(`<a${En("href", l7)} class="back-link"${En("aria-label", u8)}><svg width="20" height="20" viewBox="0 0 20 20" fill="none"><path d="M12.5 15L7.5 10L12.5 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></a>`)) : t4.push("<!--[!-->"), t4.push(`<!--]--> <h1 class="page-title">${C2(s5)}</h1></div> <div class="header-right">`), h5 !== void 0 ? (t4.push("<!--[-->"), t4.push(`<div class="search-box"><svg class="search-icon" width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="7" cy="7" r="5.5" stroke="currentColor" stroke-width="1.5"></circle><path d="M11 11L14 14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg> <input type="text"${En("placeholder", p6)}${En("value", h5)} class="search-input"/></div>`)) : t4.push("<!--[!-->"), t4.push("<!--]--> <!--[-->"), ns(t4, a5, "actions", {}), t4.push("<!--]--></div>")), t4.push("<!--]--></header>"), ss(a5, { title: s5, subtitle: i7, backLink: l7, backLabel: u8, searchQuery: h5, placeholder: p6, variant: d2 });
}
function I7(t4, a5) {
  t4.component((s5) => {
    var i7;
    let l7;
    const { supabase: u8, session: h5 } = u3(), p6 = h5?.user?.id, d2 = b5(), v5 = f5(), m8 = z(u8, p6);
    let b8 = [], f8 = null;
    M5(() => {
    }), l7 = ts(i7 ??= {}, "$mapStore", d2).activeMapId ?? "", ts(i7 ??= {}, "$layerStore", v5).basemap, ts(i7 ??= {}, "$layerStore", v5).sideRatio, ts(i7 ??= {}, "$layerStore", v5).viewMode, ts(i7 ??= {}, "$layerStore", v5).overlayOpacity, ts(i7 ??= {}, "$layerStore", v5).lensRadius, l7 && b8.find((o5) => o5.id === l7), ts(i7 ??= {}, "$storyLibrary", m8).stories.filter((o5) => o5.authorId === p6), f8 && clearTimeout(f8), f8 = null, h5 ? (s5.push("<!--[!-->"), s5.push("<!--[-->"), H5(s5, { children: (o5) => {
      o5.push("<!--[-->"), o5.push('<div class="library-loading"><div class="loading-spinner"></div> <span>Loading stories...</span></div>'), o5.push("<!--]-->");
    }, $$slots: { default: true, header: (o5) => {
      o5.push('<div slot="header">'), z2(o5, { title: "My Stories", subtitle: "Create guided stories and adventures on historical maps", variant: "hero", backLink: "/", backLabel: "Return to Home", $$slots: { actions: (y5) => {
        y5.push('<div slot="actions"><button type="button" class="library-create-btn"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M12 5v14M5 12h14"></path></svg> New Story</button></div>');
      } } }), o5.push("<!----></div>");
    } } }), s5.push("<!--]-->")) : (s5.push("<!--[-->"), s5.push('<div class="auth-gate"><div class="auth-gate-card"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#d4af37" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0110 0v4"></path></svg> <h2 class="auth-gate-title">Sign in to Create</h2> <p class="auth-gate-text">Sign in with your Google account to create and manage stories.</p> <button type="button" class="auth-gate-btn google"><svg width="18" height="18" viewBox="0 0 24 24"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 01-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z" fill="#4285F4"></path><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"></path><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"></path><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"></path></svg> Continue with Google</button></div></div>')), s5.push("<!--]-->"), i7 && es(i7);
  });
}
function Z4(t4) {
  Xn(t4, (a5) => {
    a5.title((s5) => {
      s5.push("<title>Create \u2014 Vietnam Map Archive</title>");
    }), a5.push('<meta name="description" content="Create guided stories and adventures on historical maps of Vietnam. Place points, configure challenges, and share your creations."/> <link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
  }), I7(t4);
}
var init_page_svelte7 = __esm({
  ".svelte-kit/output/server/entries/pages/create/_page.svelte.js"() {
    init_index2();
    init_MapSearchBar_svelte_svelte_type_style_lang();
    init_proj();
    init_context2();
    init_StoryPlayback_svelte_svelte_type_style_lang();
    init_dist14();
    init_clsx();
    init_internal();
    init_exports2();
    init_utils2();
    init_server();
    init_state_svelte();
    init_context();
  }
});

// .svelte-kit/output/server/nodes/8.js
var __exports9 = {};
__export(__exports9, {
  component: () => component9,
  fonts: () => fonts9,
  imports: () => imports9,
  index: () => index9,
  stylesheets: () => stylesheets9,
  universal: () => universal5,
  universal_id: () => universal_id5
});
var index9, component_cache9, component9, universal5, universal_id5, imports9, stylesheets9, fonts9;
var init__9 = __esm({
  ".svelte-kit/output/server/nodes/8.js"() {
    index9 = 8;
    component9 = async () => component_cache9 ??= (await Promise.resolve().then(() => (init_page_svelte7(), page_svelte_exports7))).default;
    universal5 = {
      "ssr": false
    };
    universal_id5 = "src/routes/create/+page.ts";
    imports9 = ["_app/immutable/nodes/8.DCdRZk0Q.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DAqcWgJQ.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/BWsF3rHZ.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/DxkUhP4x.js", "_app/immutable/chunks/m2V9rbtF.js", "_app/immutable/chunks/BqlTOgs2.js", "_app/immutable/chunks/nobbrJXm.js", "_app/immutable/chunks/DezgiKfJ.js", "_app/immutable/chunks/C4Cza0Sg.js", "_app/immutable/chunks/BKtb5Vzl.js", "_app/immutable/chunks/CzAFXcu7.js", "_app/immutable/chunks/BU5cCx0i.js", "_app/immutable/chunks/DB88mmUq.js", "_app/immutable/chunks/BY0SMKbK.js"];
    stylesheets9 = ["_app/immutable/assets/TileImage.BtPuoxOl.css", "_app/immutable/assets/MapSearchBar.CaB7_K8M.css", "_app/immutable/assets/StoryPlayback.ClnAOQ2K.css", "_app/immutable/assets/8.Dzc2acnN.css"];
    fonts9 = [];
  }
});

// .svelte-kit/output/server/entries/pages/login/_page.svelte.js
var page_svelte_exports8 = {};
__export(page_svelte_exports8, {
  default: () => y4
});
function y4(e3, c7) {
  e3.component((t4) => {
    const { supabase: r5, session: v5 } = u3();
    let a5 = "", l7 = "", i7 = false;
    Xn(t4, (o5) => {
      o5.title((p6) => {
        p6.push("<title>Login \u2014 Vietnam Map Archive</title>");
      });
    }), t4.push('<div class="auth-page svelte-1x05zx6"><div class="auth-card svelte-1x05zx6"><h1 class="auth-title svelte-1x05zx6">Login</h1> '), t4.push("<!--[!-->"), t4.push(`<!--]--> <form class="auth-form svelte-1x05zx6"><label class="auth-field svelte-1x05zx6"><span class="svelte-1x05zx6">Email</span> <input type="email"${En("value", a5)} required autocomplete="email" class="svelte-1x05zx6"/></label> <label class="auth-field svelte-1x05zx6"><span class="svelte-1x05zx6">Password</span> <input type="password"${En("value", l7)} required autocomplete="current-password" class="svelte-1x05zx6"/></label> <button type="submit" class="auth-btn primary svelte-1x05zx6"${En("disabled", i7, true)}>${C2("Login")}</button></form> <div class="auth-divider svelte-1x05zx6"><span>or</span></div> <button class="auth-btn google svelte-1x05zx6">Continue with Google</button> <p class="auth-link svelte-1x05zx6">Don't have an account? <a href="/signup" class="svelte-1x05zx6">Sign up</a></p></div></div>`);
  });
}
var init_page_svelte8 = __esm({
  ".svelte-kit/output/server/entries/pages/login/_page.svelte.js"() {
    init_index2();
    init_context2();
    init_internal();
    init_exports2();
    init_utils2();
    init_server();
    init_state_svelte();
    init_context();
  }
});

// .svelte-kit/output/server/nodes/9.js
var __exports10 = {};
__export(__exports10, {
  component: () => component10,
  fonts: () => fonts10,
  imports: () => imports10,
  index: () => index10,
  stylesheets: () => stylesheets10
});
var index10, component_cache10, component10, imports10, stylesheets10, fonts10;
var init__10 = __esm({
  ".svelte-kit/output/server/nodes/9.js"() {
    index10 = 9;
    component10 = async () => component_cache10 ??= (await Promise.resolve().then(() => (init_page_svelte8(), page_svelte_exports8))).default;
    imports10 = ["_app/immutable/nodes/9.kr_BjzWT.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/CzAFXcu7.js", "_app/immutable/chunks/DB88mmUq.js", "_app/immutable/chunks/DezgiKfJ.js"];
    stylesheets10 = ["_app/immutable/assets/9.BvsEncdf.css"];
    fonts10 = [];
  }
});

// .svelte-kit/output/server/entries/pages/signup/_page.svelte.js
var page_svelte_exports9 = {};
__export(page_svelte_exports9, {
  default: () => C5
});
function C5(a5, n6) {
  a5.component((s5) => {
    const { supabase: v5, session: r5 } = u3();
    let e3 = "", l7 = "", o5 = "", p6 = false;
    Xn(s5, (c7) => {
      c7.title((i7) => {
        i7.push("<title>Sign Up \u2014 Vietnam Map Archive</title>");
      });
    }), s5.push('<div class="auth-page svelte-kmqcod"><div class="auth-card svelte-kmqcod"><h1 class="auth-title svelte-kmqcod">Create Account</h1> '), s5.push("<!--[!-->"), s5.push("<!--[!-->"), s5.push(`<!--]--> <form class="auth-form svelte-kmqcod"><label class="auth-field svelte-kmqcod"><span class="svelte-kmqcod">Email</span> <input type="email"${En("value", e3)} required autocomplete="email" class="svelte-kmqcod"/></label> <label class="auth-field svelte-kmqcod"><span class="svelte-kmqcod">Password</span> <input type="password"${En("value", l7)} required autocomplete="new-password" class="svelte-kmqcod"/></label> <label class="auth-field svelte-kmqcod"><span class="svelte-kmqcod">Confirm Password</span> <input type="password"${En("value", o5)} required autocomplete="new-password" class="svelte-kmqcod"/></label> <button type="submit" class="auth-btn primary svelte-kmqcod"${En("disabled", p6, true)}>${C2("Sign Up")}</button></form> <div class="auth-divider svelte-kmqcod"><span>or</span></div> <button class="auth-btn google svelte-kmqcod">Continue with Google</button>`), s5.push('<!--]--> <p class="auth-link svelte-kmqcod">Already have an account? <a href="/login" class="svelte-kmqcod">Login</a></p></div></div>');
  });
}
var init_page_svelte9 = __esm({
  ".svelte-kit/output/server/entries/pages/signup/_page.svelte.js"() {
    init_index2();
    init_context2();
    init_internal();
    init_exports2();
    init_utils2();
    init_server();
    init_state_svelte();
    init_context();
  }
});

// .svelte-kit/output/server/nodes/10.js
var __exports11 = {};
__export(__exports11, {
  component: () => component11,
  fonts: () => fonts11,
  imports: () => imports11,
  index: () => index11,
  stylesheets: () => stylesheets11
});
var index11, component_cache11, component11, imports11, stylesheets11, fonts11;
var init__11 = __esm({
  ".svelte-kit/output/server/nodes/10.js"() {
    index11 = 10;
    component11 = async () => component_cache11 ??= (await Promise.resolve().then(() => (init_page_svelte9(), page_svelte_exports9))).default;
    imports11 = ["_app/immutable/nodes/10.YQWc9RN-.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/CzAFXcu7.js", "_app/immutable/chunks/DB88mmUq.js", "_app/immutable/chunks/DezgiKfJ.js"];
    stylesheets11 = ["_app/immutable/assets/10.BCx_-o9u.css"];
    fonts11 = [];
  }
});

// .svelte-kit/output/server/entries/pages/view/_page.svelte.js
var page_svelte_exports10 = {};
__export(page_svelte_exports10, {
  default: () => Pt3
});
function it3(s5) {
  I(D6, s5);
}
function F4() {
  const s5 = G(D6);
  if (!s5) throw new Error("Shell context not found \u2014 is this component inside a <MapShell>?");
  return s5;
}
function ct3(s5, o5) {
  s5.component((t4) => {
    let e3 = o5.mapStore, c7 = o5.layerStore, p6 = q(o5.disableUrlSync, false), u8 = q(o5.map, null);
    const i7 = a3(null);
    let l7 = /* @__PURE__ */ new Map();
    it3({ map: i7, mapStore: e3, layerStore: c7 }), M5(() => {
      i7.set(null), l7.clear();
    }), t4.push('<div class="shell svelte-cnq0vs"><div class="shell-map svelte-cnq0vs"></div> <div class="shell-overlay svelte-cnq0vs"><!--[-->'), ns(t4, o5, "default", {}), t4.push("<!--]--></div></div>"), ss(o5, { mapStore: e3, layerStore: c7, disableUrlSync: p6, map: u8 });
  });
}
function nt3(s5, o5) {
  s5.component((t4) => {
    const { map: e3, mapStore: c7, layerStore: p6 } = F4();
    let u8 = [];
    M5(() => {
      u8.forEach((i7) => i7()), u8 = [];
    });
  });
}
function pt(s5, o5) {
  s5.component((t4) => {
    let e3 = q(o5.selectedMap, null), c7 = q(o5.stories, () => [], true), p6 = q(o5.activeStoryId, null), u8 = "idle";
    if (t4.push('<aside class="panel svelte-1m31mfq"><div class="panel-header svelte-1m31mfq"><a href="/" class="home-link svelte-1m31mfq"><svg width="16" height="16" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.5 15L7.5 10L12.5 5"></path></svg> Home</a> <button type="button" class="panel-close svelte-1m31mfq" aria-label="Close panel"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M18 6L6 18M6 6l12 12"></path></svg></button></div> <div class="panel-scroll custom-scrollbar svelte-1m31mfq">'), e3 ? (t4.push("<!--[-->"), t4.push(`<section class="panel-card map-info-card svelte-1m31mfq"><h2 class="map-title svelte-1m31mfq">${C2(e3.name)}</h2> <div class="map-meta svelte-1m31mfq">`), e3.year ? (t4.push("<!--[-->"), t4.push(`<span class="meta-badge meta-year svelte-1m31mfq">${C2(e3.year)}</span>`)) : t4.push("<!--[!-->"), t4.push("<!--]--> "), e3.type ? (t4.push("<!--[-->"), t4.push(`<span class="meta-badge meta-city svelte-1m31mfq">${C2(e3.type)}</span>`)) : t4.push("<!--[!-->"), t4.push("<!--]--></div> "), e3.summary ? (t4.push("<!--[-->"), t4.push(`<p class="map-summary svelte-1m31mfq">${C2(e3.summary)}</p>`)) : t4.push("<!--[!-->"), t4.push("<!--]--> "), e3.description ? (t4.push("<!--[-->"), t4.push(`<p class="map-description svelte-1m31mfq">${C2(e3.description)}</p>`)) : t4.push("<!--[!-->"), t4.push(`<!--]--> <div class="map-actions svelte-1m31mfq"><button type="button" class="action-btn svelte-1m31mfq"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="7"></circle><path d="M21 21l-4.35-4.35"></path><path d="M11 8v6M8 11h6"></path></svg> Zoom to map</button> <button type="button"${Jn("action-btn svelte-1m31mfq", void 0, { success: u8 === "success" })}><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">`), t4.push("<!--[!-->"), t4.push('<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><path d="M8.59 13.51l6.83 3.98M15.41 6.51l-6.82 3.98"></path>'), t4.push(`<!--]--></svg> ${C2("Share map")}</button> <a${En("href", `/annotate?map=${Zn(e3.id)}`)} class="action-btn svelte-1m31mfq"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M9 3v18M3 9h18"></path></svg> Annotate this map</a> <a${En("href", `/create?map=${Zn(e3.id)}`)} class="action-btn svelte-1m31mfq"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 013 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg> Create story</a></div></section>`)) : (t4.push("<!--[!-->"), t4.push('<section class="panel-card no-map-card svelte-1m31mfq"><div class="no-map-icon svelte-1m31mfq">\u{1F5FA}\uFE0F</div> <p class="no-map-text svelte-1m31mfq">Select a historical map using the search toolbar.</p></section>')), t4.push("<!--]--> "), c7.length) {
      t4.push("<!--[-->"), t4.push('<section class="panel-card svelte-1m31mfq"><header class="panel-card-header svelte-1m31mfq"><h2 class="svelte-1m31mfq">Stories</h2></header> <div class="story-list svelte-1m31mfq"><!--[-->');
      const i7 = rs(c7);
      for (let l7 = 0, h5 = i7.length; l7 < h5; l7++) {
        let r5 = i7[l7];
        t4.push(`<button type="button"${Jn("story-card svelte-1m31mfq", void 0, { active: r5.id === p6 })}><h3 class="story-title svelte-1m31mfq">${C2(r5.title)}</h3> `), r5.description ? (t4.push("<!--[-->"), t4.push(`<p class="story-description svelte-1m31mfq">${C2(r5.description)}</p>`)) : t4.push("<!--[!-->"), t4.push(`<!--]--> <div class="story-footer svelte-1m31mfq"><span class="story-author svelte-1m31mfq" title="Creator"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="svelte-1m31mfq"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg> ${C2(r5.authorName || "Unknown")}</span></div></button>`);
      }
      t4.push("<!--]--></div></section>");
    } else t4.push("<!--[!-->");
    t4.push("<!--]--></div></aside>"), ss(o5, { selectedMap: e3, stories: c7, activeStoryId: p6 });
  });
}
function ht3(s5, o5 = ut3) {
  return "geolocation" in navigator ? navigator.geolocation.watchPosition(s5.onPosition, s5.onError, o5) : (s5.onError({ code: 0, message: "Geolocation not supported", PERMISSION_DENIED: 1, POSITION_UNAVAILABLE: 2, TIMEOUT: 3 }), null);
}
function V3(s5) {
  navigator.geolocation.clearWatch(s5);
}
function mt3(s5) {
  switch (s5.code) {
    case s5.PERMISSION_DENIED:
      return "Location access denied. Please enable location permissions.";
    case s5.POSITION_UNAVAILABLE:
      return "Location unavailable. Please check your device settings.";
    case s5.TIMEOUT:
      return "Location request timed out. Please try again.";
    default:
      return "An unknown location error occurred.";
  }
}
function rt3(s5, o5) {
  s5.component((t4) => {
    let e3 = q(o5.active, false), c7 = q(o5.autoFollow, true), p6 = q(o5.showTrack, true);
    const { map: u8 } = F4();
    let i7 = [], l7 = null, h5 = "inactive";
    function r5(y5) {
      const { longitude: b8, latitude: q5 } = y5.coords, k5 = fromLonLat2([b8, q5]);
      i7 = [...i7, k5];
    }
    function x4() {
      h5 === "inactive" && (i7 = [], l7 = ht3({ onPosition: r5, onError: (y5) => {
        mt3(y5), h5 = "inactive", l7 !== null && (V3(l7), l7 = null);
      } }), l7 !== null && (h5 = "active"));
    }
    function S5() {
      l7 !== null && (V3(l7), l7 = null), h5 = "inactive";
    }
    M5(() => {
      S5();
    }), e3 && h5 === "inactive" && x4(), !e3 && h5 === "active" && S5(), ss(o5, { active: e3, autoFollow: c7, showTrack: p6 });
  });
}
function vt3(s5, o5) {
  s5.component((t4) => {
    var e3;
    let c7, p6, u8, i7, l7, h5;
    const { supabase: r5, session: x4 } = u3(), S5 = x4?.user?.id, y5 = b5(), b8 = f5(), q5 = G2(r5, S5);
    let k5 = [], H6 = [], _5 = false, W2 = false, T4 = false, z3, B5 = null, I9 = null;
    const G3 = [{ mode: "overlay", label: "Overlay", title: "Full overlay" }, { mode: "side-x", label: "Side X", title: "Side by side (horizontal)" }, { mode: "side-y", label: "Side Y", title: "Side by side (vertical)" }, { mode: "spy", label: "Lens", title: "Spy glass" }];
    M5(() => {
    }), c7 = ts(e3 ??= {}, "$mapStore", y5).activeMapId ?? "", p6 = ts(e3 ??= {}, "$layerStore", b8).basemap, u8 = ts(e3 ??= {}, "$layerStore", b8).viewMode, i7 = ts(e3 ??= {}, "$layerStore", b8).overlayOpacity, l7 = ts(e3 ??= {}, "$layerStore", b8).lensRadius, h5 = c7 ? k5.find((a5) => a5.id === c7) ?? null : null, ts(e3 ??= {}, "$storyPlayer", q5), I9 && clearTimeout(I9), I9 = null, ts(e3 ??= {}, "$page", N4).url.searchParams.get("map"), ts(e3 ??= {}, "$page", N4).url.searchParams.get("story");
    let L4 = true, C6;
    function R7(a5) {
      a5.push(`<div${Jn("view-mode", void 0, { mobile: _5 })}><div${Jn("workspace", void 0, { "with-sidebar": !_5, compact: W2 })}>`), a5.push("<!--[-->"), pt(a5, { selectedMap: h5, stories: H6, activeStoryId: null }), a5.push('<!--]--> <div class="map-stage">'), ct3(a5, { mapStore: y5, layerStore: b8, get map() {
        return B5;
      }, set map(n6) {
        B5 = n6, L4 = false;
      }, children: (n6) => {
        nt3(n6), n6.push("<!----> "), rt3(n6, { active: T4 }), n6.push("<!----> "), n6.push("<!--[!-->"), n6.push("<!--]-->");
      }, $$slots: { default: true } }), a5.push("<!----> "), a5.push("<!--[!-->"), a5.push(`<!--]--> <div class="floating-controls"><button type="button" class="ctrl-btn"${En("title", p6 === "g-streets" ? "Switch to Satellite" : "Switch to Streets")}><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">`), p6 === "g-streets" ? (a5.push("<!--[-->"), a5.push('<circle cx="12" cy="12" r="10"></circle><path d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"></path>')) : (a5.push("<!--[!-->"), a5.push('<rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M3 9h18M3 15h18M9 3v18M15 3v18"></path>')), a5.push(`<!--]--></svg></button> <button type="button"${Jn("ctrl-btn", void 0, { active: T4 })}${En("title", "Start GPS tracking")}><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M12 2v4M12 18v4M2 12h4M18 12h4"></path></svg></button> `), a5.push("<!--[!-->"), a5.push(`<!--]--></div> <div${Jn("map-toolbar", void 0, { mobile: _5 })}><div class="toolbar-group"><span class="toolbar-label">View</span> <div class="toolbar-btns"><!--[-->`);
      const A13 = rs(G3);
      for (let n6 = 0, X4 = A13.length; n6 < X4; n6++) {
        let E7 = A13[n6];
        a5.push(`<button type="button"${Jn("tb", void 0, { active: u8 === E7.mode })}${En("title", E7.title)}>${C2(E7.label)}</button>`);
      }
      a5.push(`<!--]--></div></div> <div class="toolbar-sep"></div> <div class="toolbar-group toolbar-opacity"><span class="toolbar-label">Opacity</span> <div class="toolbar-slider-row"><input type="range" min="0" max="1" step="0.05"${En("value", i7)} class="toolbar-slider"/> <span class="toolbar-slider-val">${C2(Math.round(i7 * 100))}%</span></div></div></div> `), u8 === "spy" ? (a5.push("<!--[-->"), a5.push(`<div class="lens-overlay"><div class="lens-ring"${Qn(`width: ${Zn(l7 * 2)}px; height: ${Zn(l7 * 2)}px;`)}></div> <div class="lens-knob"${Qn(`transform: translateX(${Zn(l7)}px);`)} role="slider" aria-label="Lens size"${En("aria-valuemin", 30)}${En("aria-valuemax", 500)}${En("aria-valuenow", l7)} tabindex="0"></div></div>`)) : a5.push("<!--[!-->"), a5.push("<!--]--> "), a5.push("<!--[!-->"), a5.push("<!--]--> "), a5.push("<!--[!-->"), a5.push("<!--]--> "), a5.push("<!--[!-->"), a5.push("<!--]--> "), F2(a5, { maps: k5, selectedMapId: c7, toolbarEl: z3 }), a5.push("<!----></div></div> "), a5.push("<!--[!-->"), a5.push("<!--]--></div>");
    }
    do
      L4 = true, C6 = t4.copy(), R7(C6);
    while (!L4);
    t4.subsume(C6), e3 && es(e3);
  });
}
function Pt3(s5) {
  Xn(s5, (o5) => {
    o5.title((t4) => {
      t4.push("<title>View \u2014 Vietnam Map Archive</title>");
    }), o5.push('<meta name="description" content="Explore historical maps of Vietnam. Browse georeferenced overlays, play guided stories, and track your location."/> <link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;600;700;800&amp;family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&amp;family=Be+Vietnam+Pro:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>');
  }), vt3(s5);
}
var lt3, N4, D6, ut3;
var init_page_svelte10 = __esm({
  ".svelte-kit/output/server/entries/pages/view/_page.svelte.js"() {
    init_index2();
    init_MapSearchBar_svelte_svelte_type_style_lang();
    init_context();
    init_internal();
    init_exports2();
    init_utils2();
    init_clsx();
    init_server();
    init_state_svelte();
    init_proj();
    init_context2();
    init_StoryPlayback_svelte_svelte_type_style_lang();
    init_dist14();
    init_chunks();
    init_MapSearchBar();
    lt3 = () => {
      const s5 = G("__svelte__");
      return { page: { subscribe: s5.page.subscribe }, navigating: { subscribe: s5.navigating.subscribe }, updated: s5.updated };
    };
    N4 = { subscribe(s5) {
      return lt3().page.subscribe(s5);
    } };
    D6 = Symbol("shell-context");
    ut3 = { enableHighAccuracy: true, timeout: 1e4, maximumAge: 0 };
  }
});

// .svelte-kit/output/server/nodes/11.js
var __exports12 = {};
__export(__exports12, {
  component: () => component12,
  fonts: () => fonts12,
  imports: () => imports12,
  index: () => index12,
  stylesheets: () => stylesheets12,
  universal: () => universal6,
  universal_id: () => universal_id6
});
var index12, component_cache12, component12, universal6, universal_id6, imports12, stylesheets12, fonts12;
var init__12 = __esm({
  ".svelte-kit/output/server/nodes/11.js"() {
    index12 = 11;
    component12 = async () => component_cache12 ??= (await Promise.resolve().then(() => (init_page_svelte10(), page_svelte_exports10))).default;
    universal6 = {
      "ssr": false
    };
    universal_id6 = "src/routes/view/+page.ts";
    imports12 = ["_app/immutable/nodes/11.BcH00VD5.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DAqcWgJQ.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/BWsF3rHZ.js", "_app/immutable/chunks/DjrK7u_z.js", "_app/immutable/chunks/DxkUhP4x.js", "_app/immutable/chunks/m2V9rbtF.js", "_app/immutable/chunks/BqlTOgs2.js", "_app/immutable/chunks/nobbrJXm.js", "_app/immutable/chunks/DezgiKfJ.js", "_app/immutable/chunks/DB88mmUq.js", "_app/immutable/chunks/C4Cza0Sg.js", "_app/immutable/chunks/BKtb5Vzl.js", "_app/immutable/chunks/CzAFXcu7.js", "_app/immutable/chunks/BU5cCx0i.js", "_app/immutable/chunks/Dp1RyEzT.js"];
    stylesheets12 = ["_app/immutable/assets/TileImage.BtPuoxOl.css", "_app/immutable/assets/MapSearchBar.CaB7_K8M.css", "_app/immutable/assets/StoryPlayback.ClnAOQ2K.css", "_app/immutable/assets/11.CoS36Kii.css"];
    fonts12 = [];
  }
});

// .svelte-kit/output/server/chunks/private.js
var I8, c5, S3;
var init_private = __esm({
  ".svelte-kit/output/server/chunks/private.js"() {
    I8 = "0cxh4UFSc6ZXl4ZH";
    c5 = "NhW6LdWMO1Xz9qvc";
    S3 = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRyaW95a2poaHdycnV3anNrbGZvIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc3MDQ5NDA3MywiZXhwIjoyMDg2MDcwMDczfQ.CHhv2_2RZ80Nb9YBptMT_WRMDiMIKDUyf0LUohy19Fs";
  }
});

// .svelte-kit/output/server/entries/endpoints/api/admin/labels/_server.ts.js
var server_ts_exports = {};
__export(server_ts_exports, {
  GET: () => E6,
  POST: () => h4
});
async function m7(r5) {
  const { session: t4, user: e3 } = await r5.safeGetSession();
  if (!t4 || !e3) throw error(401, "Unauthorized");
  const a5 = createClient(I3, S3), { data: o5 } = await a5.from("profiles").select("role").eq("id", e3.id).single();
  if (o5?.role !== "admin") throw error(403, "Forbidden");
  return a5;
}
var E6, h4;
var init_server_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/admin/labels/_server.ts.js"() {
    init_exports();
    init_dist4();
    init_public();
    init_private();
    E6 = async ({ locals: r5 }) => {
      const t4 = await m7(r5), { data: e3, error: a5 } = await t4.from("label_tasks").select("*, maps(name)").order("created_at", { ascending: false });
      if (a5) throw error(500, a5.message);
      return json(e3);
    };
    h4 = async ({ locals: r5, request: t4 }) => {
      const e3 = await m7(r5), a5 = await t4.json(), { map_id: o5, allmaps_id: n6, region: l7, legend: c7 } = a5;
      if (!o5 || !n6) throw error(400, "map_id and allmaps_id are required");
      const { data: f8, error: i7 } = await e3.from("label_tasks").insert({ map_id: o5, allmaps_id: n6, region: l7 || {}, legend: c7 || [], status: "open" }).select().single();
      if (i7) throw error(500, i7.message);
      return json(f8, { status: 201 });
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/api/admin/labels/_id_/_server.ts.js
var server_ts_exports2 = {};
__export(server_ts_exports2, {
  DELETE: () => A10,
  PATCH: () => b7
});
async function f7(a5) {
  const { session: r5, user: t4 } = await a5.safeGetSession();
  if (!r5 || !t4) throw error(401, "Unauthorized");
  const e3 = createClient(I3, S3), { data: s5 } = await e3.from("profiles").select("role").eq("id", t4.id).single();
  if (s5?.role !== "admin") throw error(403, "Forbidden");
  return e3;
}
var b7, A10;
var init_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/admin/labels/_id_/_server.ts.js"() {
    init_exports();
    init_dist4();
    init_public();
    init_private();
    b7 = async ({ locals: a5, params: r5, request: t4 }) => {
      const e3 = await f7(a5), s5 = r5.id, o5 = await t4.json(), i7 = {};
      o5.status !== void 0 && (i7.status = o5.status), o5.legend !== void 0 && (i7.legend = o5.legend), o5.region !== void 0 && (i7.region = o5.region);
      const { data: l7, error: d2 } = await e3.from("label_tasks").update(i7).eq("id", s5).select().single();
      if (d2) throw error(500, d2.message);
      return json(l7);
    };
    A10 = async ({ locals: a5, params: r5 }) => {
      const t4 = await f7(a5), e3 = r5.id, { error: s5 } = await t4.from("label_tasks").delete().eq("id", e3);
      if (s5) throw error(500, s5.message);
      return json({ success: true });
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/api/admin/maps/_server.ts.js
var server_ts_exports3 = {};
__export(server_ts_exports3, {
  GET: () => A11,
  POST: () => P7
});
async function l5(e3) {
  const { session: t4, user: a5 } = await e3.safeGetSession();
  if (!t4 || !a5) throw error(401, "Unauthorized");
  const r5 = createClient(I3, S3), { data: o5 } = await r5.from("profiles").select("role").eq("id", a5.id).single();
  if (o5?.role !== "admin") throw error(403, "Forbidden");
  return r5;
}
var A11, P7;
var init_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/admin/maps/_server.ts.js"() {
    init_exports();
    init_dist4();
    init_public();
    init_private();
    A11 = async ({ locals: e3 }) => {
      const t4 = await l5(e3), { data: a5, error: r5 } = await t4.from("maps").select("*").order("name");
      if (r5) throw error(500, r5.message);
      return json(a5);
    };
    P7 = async ({ locals: e3, request: t4 }) => {
      const a5 = await l5(e3), r5 = await t4.json(), { name: o5, allmaps_id: n6, type: c7, year: i7, summary: u8, description: f8, is_featured: p6 } = r5;
      if (!o5 || !n6) throw error(400, "name and allmaps_id are required");
      const { data: w5, error: m8 } = await a5.from("maps").insert({ name: o5, allmaps_id: n6, type: c7 || null, year: i7 ? Number(i7) : null, summary: u8 || null, description: f8 || null, is_featured: p6 || false }).select().single();
      if (m8) throw error(500, m8.message);
      return json(w5, { status: 201 });
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/api/admin/maps/_id_/_server.ts.js
var server_ts_exports4 = {};
__export(server_ts_exports4, {
  DELETE: () => _4,
  PATCH: () => S4
});
async function l6(o5) {
  const { session: s5, user: e3 } = await o5.safeGetSession();
  if (!s5 || !e3) throw error(401, "Unauthorized");
  const r5 = createClient(I3, S3), { data: t4 } = await r5.from("profiles").select("role").eq("id", e3.id).single();
  if (t4?.role !== "admin") throw error(403, "Forbidden");
  return r5;
}
var S4, _4;
var init_server_ts4 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/admin/maps/_id_/_server.ts.js"() {
    init_exports();
    init_dist4();
    init_public();
    init_private();
    S4 = async ({ locals: o5, params: s5, request: e3 }) => {
      const r5 = await l6(o5), t4 = s5.id, a5 = await e3.json(), i7 = {};
      a5.name !== void 0 && (i7.name = a5.name), a5.allmaps_id !== void 0 && (i7.allmaps_id = a5.allmaps_id), a5.type !== void 0 && (i7.type = a5.type || null), a5.year !== void 0 && (i7.year = a5.year ? Number(a5.year) : null), a5.summary !== void 0 && (i7.summary = a5.summary || null), a5.description !== void 0 && (i7.description = a5.description || null), a5.is_featured !== void 0 && (i7.is_featured = !!a5.is_featured), a5.thumbnail !== void 0 && (i7.thumbnail = a5.thumbnail || null);
      const { data: u8, error: d2 } = await r5.from("maps").update(i7).eq("id", t4).select().single();
      if (d2) throw error(500, d2.message);
      return json(u8);
    };
    _4 = async ({ locals: o5, params: s5 }) => {
      const e3 = await l6(o5), r5 = s5.id, { error: t4 } = await e3.from("maps").delete().eq("id", r5);
      if (t4) throw error(500, t4.message);
      return json({ success: true });
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/api/admin/maps/_id_/image/_server.ts.js
var server_ts_exports5 = {};
__export(server_ts_exports5, {
  POST: () => $4
});
async function A12(r5) {
  const { session: n6, user: a5 } = await r5.safeGetSession();
  if (!n6 || !a5) throw error(401, "Unauthorized");
  const i7 = createClient(I3, S3), { data: t4 } = await i7.from("profiles").select("role").eq("id", a5.id).single();
  if (t4?.role !== "admin") throw error(403, "Forbidden");
  return i7;
}
var $4;
var init_server_ts5 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/admin/maps/_id_/image/_server.ts.js"() {
    init_exports();
    init_dist4();
    init_public();
    init_private();
    $4 = async ({ locals: r5, params: n6, request: a5 }) => {
      const i7 = await A12(r5), t4 = n6.id, { data: c7 } = await i7.from("maps").select("name, allmaps_id").eq("id", t4).single();
      if (!c7) throw error(404, "Map not found");
      const o5 = (await a5.formData()).get("image");
      if (!o5) throw error(400, "No image file provided");
      const s5 = `vma-map-${t4}`, m8 = o5.name.replace(/[^a-zA-Z0-9.-]/g, "_"), l7 = `https://s3.us.archive.org/${s5}/${m8}`, f8 = await fetch(l7, { method: "PUT", headers: { Authorization: `LOW ${I8}:${c5}`, "x-amz-auto-make-bucket": "1", "x-archive-meta-title": c7.name, "x-archive-meta-mediatype": "image", "x-archive-meta-collection": "opensource_image", "Content-Type": o5.type }, body: await o5.arrayBuffer() });
      if (!f8.ok) {
        const d2 = await f8.text();
        throw console.error("IA S3 Upload Error:", d2), error(500, `Internet Archive upload failed: ${d2}`);
      }
      const p6 = `https://iiif.archive.org/iiif/3/${s5}%2F${m8}/info.json`;
      return json({ success: true, ia_identifier: s5, ia_filename: m8, iiif_url: p6 });
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/auth/callback/_server.ts.js
var server_ts_exports6 = {};
__export(server_ts_exports6, {
  GET: () => n4
});
var n4;
var init_server_ts6 = __esm({
  ".svelte-kit/output/server/entries/endpoints/auth/callback/_server.ts.js"() {
    init_exports();
    n4 = async ({ url: s5, locals: e3 }) => {
      const a5 = s5.searchParams.get("code"), t4 = s5.searchParams.get("next") || "/";
      a5 && await e3.supabase.auth.exchangeCodeForSession(a5);
      const o5 = t4.startsWith("/") && !t4.startsWith("//") ? t4 : "/";
      redirect(303, o5);
    };
  }
});

// .svelte-kit/output/server/index.js
init_false();
init_exports();
init_internal();
init_server();

// .svelte-kit/output/server/chunks/environment.js
var e = "";
var t = e;
var i = "_app";
var r = true;
var a = { base: e, assets: t };
function o(s5) {
  e = s5.base, t = s5.assets;
}
function c() {
  e = a.base, t = a.assets;
}

// node_modules/devalue/src/utils.js
var escaped = {
  "<": "\\u003C",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var DevalueError = class extends Error {
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys) {
    super(message);
    this.name = "DevalueError";
    this.path = keys.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i7 = 0; i7 < len; i7 += 1) {
    const char = str[i7];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i7) + replacement;
      last_pos = i7 + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
var is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key) {
  return is_identifier.test(key) ? "." + key : "[" + JSON.stringify(key) + "]";
}

// node_modules/devalue/src/uneval.js
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom2 = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing, (value2) => uneval(value2, replacer));
        if (typeof str2 === "string") {
          custom2.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
        case "URL":
        case "URLSearchParams":
          return;
        case "Array":
          thing.forEach((value2, i7) => {
            keys.push(`[${i7}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key) ? stringify_primitive(key) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          walk(thing.buffer);
          return;
        case "ArrayBuffer":
          return;
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          return;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key in thing) {
            keys.push(stringify_key(key));
            walk(thing[key]);
            keys.pop();
          }
      }
    }
  }
  walk(value);
  const names36 = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a5, b8) => b8[1] - a5[1]).forEach((entry, i7) => {
    names36.set(entry[0], get_name(i7));
  });
  function stringify2(thing) {
    if (names36.has(thing)) {
      return names36.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive(thing);
    }
    if (custom2.has(thing)) {
      return custom2.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify2(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "URL":
        return `new URL(${stringify_string(thing.toString())})`;
      case "URLSearchParams":
        return `new URLSearchParams(${stringify_string(thing.toString())})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v5, i7) => i7 in thing ? stringify2(v5) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify2).join(",")}])`;
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array": {
        let str2 = `new ${type}`;
        if (counts.get(thing.buffer) === 1) {
          const array = new thing.constructor(thing.buffer);
          str2 += `([${array}])`;
        } else {
          str2 += `([${stringify2(thing.buffer)}])`;
        }
        const a5 = thing.byteOffset;
        const b8 = a5 + thing.byteLength;
        if (a5 > 0 || b8 !== thing.buffer.byteLength) {
          const m8 = +/(\d+)/.exec(type)[1] / 8;
          str2 += `.subarray(${a5 / m8},${b8 / m8})`;
        }
        return str2;
      }
      case "ArrayBuffer": {
        const ui8 = new Uint8Array(thing);
        return `new Uint8Array([${ui8.toString()}]).buffer`;
      }
      case "Temporal.Duration":
      case "Temporal.Instant":
      case "Temporal.PlainDate":
      case "Temporal.PlainTime":
      case "Temporal.PlainDateTime":
      case "Temporal.PlainMonthDay":
      case "Temporal.PlainYearMonth":
      case "Temporal.ZonedDateTime":
        return `${type}.from(${stringify_string(thing.toString())})`;
      default:
        const keys2 = Object.keys(thing);
        const obj = keys2.map((key) => `${safe_key(key)}:${stringify2(thing[key])}`).join(",");
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return keys2.length > 0 ? `{${obj},__proto__:null}` : `{__proto__:null}`;
        }
        return `{${obj}}`;
    }
  }
  const str = stringify2(value);
  if (names36.size) {
    const params2 = [];
    const statements = [];
    const values = [];
    names36.forEach((name, thing) => {
      params2.push(name);
      if (custom2.has(thing)) {
        values.push(
          /** @type {string} */
          custom2.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify2(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v5, i7) => {
            statements.push(`${name}[${i7}]=${stringify2(v5)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name}.${Array.from(thing).map((v5) => `add(${stringify2(v5)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name}.${Array.from(thing).map(([k5, v5]) => `set(${stringify2(k5)}, ${stringify2(v5)})`).join(".")}`
          );
          break;
        case "ArrayBuffer":
          values.push(
            `new Uint8Array([${new Uint8Array(thing).join(",")}]).buffer`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key) => {
            statements.push(
              `${name}${safe_prop(key)}=${stringify2(thing[key])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params2.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function get_name(num) {
  let name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
function escape_unsafe_char(c7) {
  return escaped[c7] || c7;
}
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escape_unsafe_chars(JSON.stringify(key));
}
function safe_prop(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? `.${key}` : `[${escape_unsafe_chars(JSON.stringify(key))}]`;
}
function stringify_primitive(thing) {
  if (typeof thing === "string") return stringify_string(thing);
  if (thing === void 0) return "void 0";
  if (thing === 0 && 1 / thing < 0) return "-0";
  const str = String(thing);
  if (typeof thing === "number") return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint") return thing + "n";
  return str;
}

// node_modules/devalue/src/base64.js
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i7 = 0; i7 < arraybuffer.byteLength; i7++) {
    binaryString += String.fromCharCode(dv.getUint8(i7));
  }
  return binaryToAscii(binaryString);
}
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i7 = 0; i7 < arraybuffer.byteLength; i7++) {
    dv.setUint8(i7, binaryString.charCodeAt(i7));
  }
  return arraybuffer;
}
var KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer2 = 0;
  let accumulatedBits = 0;
  for (let i7 = 0; i7 < data.length; i7++) {
    buffer2 <<= 6;
    buffer2 |= KEY_STRING.indexOf(data[i7]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer2 & 16711680) >> 16);
      output += String.fromCharCode((buffer2 & 65280) >> 8);
      output += String.fromCharCode(buffer2 & 255);
      buffer2 = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer2 >>= 4;
    output += String.fromCharCode(buffer2);
  } else if (accumulatedBits === 18) {
    buffer2 >>= 2;
    output += String.fromCharCode((buffer2 & 65280) >> 8);
    output += String.fromCharCode(buffer2 & 255);
  }
  return output;
}
function binaryToAscii(str) {
  let out = "";
  for (let i7 = 0; i7 < str.length; i7 += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i7) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i7) & 3) << 4;
    if (str.length > i7 + 1) {
      groupsOfSix[1] |= str.charCodeAt(i7 + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i7 + 1) & 15) << 2;
    }
    if (str.length > i7 + 2) {
      groupsOfSix[2] |= str.charCodeAt(i7 + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i7 + 2) & 63;
    }
    for (let j6 = 0; j6 < groupsOfSix.length; j6++) {
      if (typeof groupsOfSix[j6] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j6]];
      }
    }
  }
  return out;
}

// node_modules/devalue/src/constants.js
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;

// node_modules/devalue/src/parse.js
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate(index13, standalone = false) {
    if (index13 === UNDEFINED) return void 0;
    if (index13 === NAN) return NaN;
    if (index13 === POSITIVE_INFINITY) return Infinity;
    if (index13 === NEGATIVE_INFINITY) return -Infinity;
    if (index13 === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index13 !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index13 in hydrated) return hydrated[index13];
    const value = values[index13];
    if (!value || typeof value !== "object") {
      hydrated[index13] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          let i7 = value[1];
          if (typeof i7 !== "number") {
            i7 = values.push(value[1]) - 1;
          }
          return hydrated[index13] = reviver(hydrate(i7));
        }
        switch (type) {
          case "Date":
            hydrated[index13] = new Date(value[1]);
            break;
          case "Set":
            const set = /* @__PURE__ */ new Set();
            hydrated[index13] = set;
            for (let i7 = 1; i7 < value.length; i7 += 1) {
              set.add(hydrate(value[i7]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index13] = map;
            for (let i7 = 1; i7 < value.length; i7 += 2) {
              map.set(hydrate(value[i7]), hydrate(value[i7 + 1]));
            }
            break;
          case "RegExp":
            hydrated[index13] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index13] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index13] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index13] = obj;
            for (let i7 = 1; i7 < value.length; i7 += 2) {
              obj[value[i7]] = hydrate(value[i7 + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate(value[1]));
            hydrated[index13] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base64 = value[1];
            const arraybuffer = decode64(base64);
            hydrated[index13] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index13] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url = new URL(value[1]);
            hydrated[index13] = url;
            break;
          }
          case "URLSearchParams": {
            const url = new URLSearchParams(value[1]);
            hydrated[index13] = url;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array = new Array(value.length);
        hydrated[index13] = array;
        for (let i7 = 0; i7 < value.length; i7 += 1) {
          const n6 = value[i7];
          if (n6 === HOLE) continue;
          array[i7] = hydrate(n6);
        }
      }
    } else {
      const object = {};
      hydrated[index13] = object;
      for (const key in value) {
        if (key === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n6 = value[key];
        object[key] = hydrate(n6);
      }
    }
    return hydrated[index13];
  }
  return hydrate(0);
}

// node_modules/devalue/src/stringify.js
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  if (reducers) {
    for (const key of Object.getOwnPropertyNames(reducers)) {
      custom2.push({ key, fn: reducers[key] });
    }
  }
  const keys = [];
  let p6 = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index14 = p6++;
    indexes.set(thing, index14);
    for (const { key, fn: fn4 } of custom2) {
      const value2 = fn4(thing);
      if (value2) {
        stringified[index14] = `["${key}",${flatten(value2)}]`;
        return index14;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive2(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive2(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source)},"${flags}"]` : `["RegExp",${stringify_string(source)}]`;
          break;
        case "Array":
          str = "[";
          for (let i7 = 0; i7 < thing.length; i7 += 1) {
            if (i7 > 0) str += ",";
            if (i7 in thing) {
              keys.push(`[${i7}]`);
              str += flatten(thing[i7]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key) ? stringify_primitive2(key) : "..."})`
            );
            str += `,${flatten(key)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a5 = thing.byteOffset;
          const b8 = a5 + thing.byteLength;
          if (a5 > 0 || b8 !== typedArray.buffer.byteLength) {
            const m8 = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a5 / m8},${b8 / m8}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base64 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base64}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key in thing) {
              keys.push(stringify_key(key));
              str += `,${stringify_string(key)},${flatten(thing[key])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key));
              str += `${stringify_string(key)}:${flatten(thing[key])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index14] = str;
    return index14;
  }
  const index13 = flatten(value);
  if (index13 < 0) return `${index13}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive2(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}

// .svelte-kit/output/server/index.js
init_exports2();
init_utils2();
init_chunks();

// .svelte-kit/output/server/chunks/internal.js
init_index2();
init_context();
init_clsx();
var Tt2 = {};
function Jt2(s5) {
}
function Kt2(s5) {
  Tt2 = s5;
}
function Q2(s5) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function Rt() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
var p4 = false;
function T3(s5) {
  p4 = s5;
}
var u;
function k2(s5) {
  if (s5 === null) throw Q2(), Rn;
  return u = s5;
}
function Ot2() {
  return k2(_e(u));
}
function St(s5 = 1) {
  if (p4) {
    for (var t4 = s5, e3 = u; t4--; ) e3 = _e(e3);
    u = e3;
  }
}
function Ct(s5 = true) {
  for (var t4 = 0, e3 = u; ; ) {
    if (e3.nodeType === Nn) {
      var i7 = e3.data;
      if (i7 === Ke) {
        if (t4 === 0) return e3;
        t4 -= 1;
      } else (i7 === He || i7 === Dn) && (t4 += 1);
    }
    var a5 = _e(e3);
    s5 && e3.remove(), e3 = a5;
  }
}
function Pt(s5) {
  let t4 = 0, e3 = oe(0), i7;
  return () => {
    jn() && (ot(e3), Hn(() => (t4 === 0 && (i7 = _n(() => s5(() => Et(e3)))), t4 += 1, () => {
      Xe(() => {
        t4 -= 1, t4 === 0 && (i7?.(), i7 = void 0, Et(e3));
      });
    })));
  };
}
var Nt2 = yt | kt | At;
function Dt(s5, t4, e3) {
  new At2(s5, t4, e3);
}
var At2 = class {
  parent;
  #e = false;
  #t;
  #g = p4 ? u : null;
  #r;
  #f;
  #i;
  #s = null;
  #n = null;
  #a = null;
  #o = null;
  #l = null;
  #u = 0;
  #h = 0;
  #d = false;
  #c = null;
  #y = () => {
    this.#c && en(this.#c, this.#u);
  };
  #b = Pt(() => (this.#c = oe(this.#u), () => {
    this.#c = null;
  }));
  constructor(t4, e3, i7) {
    this.#t = t4, this.#r = e3, this.#f = i7, this.parent = F.b, this.#e = !!this.#r.pending, this.#i = Kn(() => {
      if (F.b = this, p4) {
        const n6 = this.#g;
        Ot2(), n6.nodeType === Nn && n6.data === Dn ? this.#k() : this.#w();
      } else {
        var a5 = this.#m();
        try {
          this.#s = Vn(() => i7(a5));
        } catch (n6) {
          this.error(n6);
        }
        this.#h > 0 ? this.#_() : this.#e = false;
      }
      return () => {
        this.#l?.remove();
      };
    }, Nt2), p4 && (this.#t = u);
  }
  #w() {
    try {
      this.#s = Vn(() => this.#f(this.#t));
    } catch (t4) {
      this.error(t4);
    }
    this.#e = false;
  }
  #k() {
    const t4 = this.#r.pending;
    t4 && (this.#n = Vn(() => t4(this.#t)), X2.enqueue(() => {
      var e3 = this.#m();
      this.#s = this.#p(() => (X2.ensure(), Vn(() => this.#f(e3)))), this.#h > 0 ? this.#_() : (un(this.#n, () => {
        this.#n = null;
      }), this.#e = false);
    }));
  }
  #m() {
    var t4 = this.#t;
    return this.#e && (this.#l = qn(), this.#t.before(this.#l), t4 = this.#l), t4;
  }
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#r.pending;
  }
  #p(t4) {
    var e3 = F, i7 = _3, a5 = U2;
    _t(this.#i), J(this.#i), Mt(this.#i.ctx);
    try {
      return t4();
    } catch (n6) {
      return Je(n6), null;
    } finally {
      _t(e3), J(i7), Mt(a5);
    }
  }
  #_() {
    const t4 = this.#r.pending;
    this.#s !== null && (this.#o = document.createDocumentFragment(), this.#o.append(this.#l), zn(this.#s, this.#o)), this.#n === null && (this.#n = Vn(() => t4(this.#t)));
  }
  #v(t4) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#v(t4);
      return;
    }
    this.#h += t4, this.#h === 0 && (this.#e = false, this.#n && un(this.#n, () => {
      this.#n = null;
    }), this.#o && (this.#t.before(this.#o), this.#o = null));
  }
  update_pending_count(t4) {
    this.#v(t4), this.#u += t4, Lt.add(this.#y);
  }
  get_effect_pending() {
    return this.#b(), ot(this.#c);
  }
  error(t4) {
    var e3 = this.#r.onerror;
    let i7 = this.#r.failed;
    if (this.#d || !e3 && !i7) throw t4;
    this.#s && (H(this.#s), this.#s = null), this.#n && (H(this.#n), this.#n = null), this.#a && (H(this.#a), this.#a = null), p4 && (k2(this.#g), St(), k2(Ct()));
    var a5 = false, n6 = false;
    const r5 = () => {
      if (a5) {
        Rt();
        return;
      }
      a5 = true, n6 && Cn(), X2.ensure(), this.#u = 0, this.#a !== null && un(this.#a, () => {
        this.#a = null;
      }), this.#e = this.has_pending_snippet(), this.#s = this.#p(() => (this.#d = false, Vn(() => this.#f(this.#t)))), this.#h > 0 ? this.#_() : this.#e = false;
    };
    var o5 = _3;
    try {
      J(null), n6 = true, e3?.(t4, r5), n6 = false;
    } catch (c7) {
      ne(c7, this.#i && this.#i.parent);
    } finally {
      J(o5);
    }
    i7 && Xe(() => {
      this.#a = this.#p(() => {
        X2.ensure(), this.#d = true;
        try {
          return Vn(() => {
            i7(this.#t, () => t4, () => r5);
          });
        } catch (c7) {
          return ne(c7, this.#i.parent), null;
        } finally {
          this.#d = false;
        }
      });
    });
  }
};
var Ft2 = /* @__PURE__ */ new Set();
var q3 = /* @__PURE__ */ new Set();
var H2 = null;
function R4(s5) {
  var t4 = this, e3 = t4.ownerDocument, i7 = s5.type, a5 = s5.composedPath?.() || [], n6 = a5[0] || s5.target;
  H2 = s5;
  var r5 = 0, o5 = H2 === s5 && s5.__root;
  if (o5) {
    var c7 = a5.indexOf(o5);
    if (c7 !== -1 && (t4 === document || t4 === window)) {
      s5.__root = t4;
      return;
    }
    var d2 = a5.indexOf(t4);
    if (d2 === -1) return;
    c7 <= d2 && (r5 = c7);
  }
  if (n6 = a5[r5] || s5.target, n6 !== t4) {
    m2(s5, "currentTarget", { configurable: true, get() {
      return n6 || e3;
    } });
    var b8 = _3, f8 = F;
    J(null), _t(null);
    try {
      for (var l7, h5 = []; n6 !== null; ) {
        var g5 = n6.assignedSlot || n6.parentNode || n6.host || null;
        try {
          var w5 = n6["__" + i7];
          w5 != null && (!n6.disabled || s5.target === n6) && w5.call(n6, s5);
        } catch (E7) {
          l7 ? h5.push(E7) : l7 = E7;
        }
        if (s5.cancelBubble || g5 === t4 || g5 === null) break;
        n6 = g5;
      }
      if (l7) {
        for (let E7 of h5) queueMicrotask(() => {
          throw E7;
        });
        throw l7;
      }
    } finally {
      s5.__root = t4, delete s5.currentTarget, J(b8), _t(f8);
    }
  }
}
function jt2(s5, t4) {
  var e3 = F;
  e3.nodes_start === null && (e3.nodes_start = s5, e3.nodes_end = t4);
}
function X3(s5, t4) {
  return Z2(s5, t4);
}
function Lt2(s5, t4) {
  Ln(), t4.intro = t4.intro ?? false;
  const e3 = t4.target, i7 = p4, a5 = u;
  try {
    for (var n6 = Bn(e3); n6 && (n6.nodeType !== Nn || n6.data !== He); ) n6 = _e(n6);
    if (!n6) throw Rn;
    T3(true), k2(n6);
    const r5 = Z2(s5, { ...t4, anchor: n6 });
    return T3(false), r5;
  } catch (r5) {
    if (r5 instanceof Error && r5.message.split(`
`).some((o5) => o5.startsWith("https://svelte.dev/e/"))) throw r5;
    return r5 !== Rn && console.warn("Failed to hydrate: ", r5), t4.recover === false && On(), Ln(), Yn(e3), T3(false), X3(s5, t4);
  } finally {
    T3(i7), k2(a5);
  }
}
var m4 = /* @__PURE__ */ new Map();
function Z2(s5, { target: t4, anchor: e3, props: i7 = {}, events: a5, context: n6, intro: r5 = true }) {
  Ln();
  var o5 = /* @__PURE__ */ new Set(), c7 = (f8) => {
    for (var l7 = 0; l7 < f8.length; l7++) {
      var h5 = f8[l7];
      if (!o5.has(h5)) {
        o5.add(h5);
        var g5 = Gn(h5);
        t4.addEventListener(h5, R4, { passive: g5 });
        var w5 = m4.get(h5);
        w5 === void 0 ? (document.addEventListener(h5, R4, { passive: g5 }), m4.set(h5, 1)) : m4.set(h5, w5 + 1);
      }
    }
  };
  c7(g2(Ft2)), q3.add(c7);
  var d2 = void 0, b8 = Un(() => {
    var f8 = e3 ?? t4.appendChild(qn());
    return Dt(f8, { pending: () => {
    } }, (l7) => {
      if (n6) {
        In({});
        var h5 = U2;
        h5.c = n6;
      }
      if (a5 && (i7.$$events = a5), p4 && jt2(l7, null), d2 = s5(l7, i7) || {}, p4 && (F.nodes_end = u, u === null || u.nodeType !== Nn || u.data !== Ke)) throw Q2(), Rn;
      n6 && Pn();
    }), () => {
      for (var l7 of o5) {
        t4.removeEventListener(l7, R4);
        var h5 = m4.get(l7);
        --h5 === 0 ? (document.removeEventListener(l7, R4), m4.delete(l7)) : m4.set(l7, h5);
      }
      q3.delete(c7), f8 !== e3 && f8.parentNode?.removeChild(f8);
    };
  });
  return L2.set(d2, b8), d2;
}
var L2 = /* @__PURE__ */ new WeakMap();
function It(s5, t4) {
  const e3 = L2.get(s5);
  return e3 ? (L2.delete(s5), e3(t4)) : Promise.resolve();
}
function Bt2(s5) {
  return class extends Mt2 {
    constructor(t4) {
      super({ component: s5, ...t4 });
    }
  };
}
var Mt2 = class {
  #e;
  #t;
  constructor(t4) {
    var e3 = /* @__PURE__ */ new Map(), i7 = (n6, r5) => {
      var o5 = Mn(r5, false, false);
      return e3.set(n6, o5), o5;
    };
    const a5 = new Proxy({ ...t4.props || {}, $$events: {} }, { get(n6, r5) {
      return ot(e3.get(r5) ?? i7(r5, Reflect.get(n6, r5)));
    }, has(n6, r5) {
      return r5 === An ? true : (ot(e3.get(r5) ?? i7(r5, Reflect.get(n6, r5))), Reflect.has(n6, r5));
    }, set(n6, r5, o5) {
      return q2(e3.get(r5) ?? i7(r5, o5), o5), Reflect.set(n6, r5, o5);
    } });
    this.#t = (t4.hydrate ? Lt2 : X3)(t4.component, { target: t4.target, anchor: t4.anchor, props: a5, context: t4.context, intro: t4.intro ?? false, recover: t4.recover }), (!t4?.props?.$$host || t4.sync === false) && $n(), this.#e = a5.$$events;
    for (const n6 of Object.keys(this.#t)) n6 === "$set" || n6 === "$destroy" || n6 === "$on" || m2(this, n6, { get() {
      return this.#t[n6];
    }, set(r5) {
      this.#t[n6] = r5;
    }, enumerable: true });
    this.#t.$set = (n6) => {
      Object.assign(a5, n6);
    }, this.#t.$destroy = () => {
      It(this.#t);
    };
  }
  $set(t4) {
    this.#t.$set(t4);
  }
  $on(t4, e3) {
    this.#e[t4] = this.#e[t4] || [];
    const i7 = (...a5) => e3.call(this, ...a5);
    return this.#e[t4].push(i7), () => {
      this.#e[t4] = this.#e[t4].filter((a5) => a5 !== i7);
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
};
var qt2 = null;
function Qt2(s5) {
  qt2 = s5;
}
function Ht2(s5) {
  const t4 = Bt2(s5), e3 = (i7, { context: a5 } = {}) => {
    const n6 = Wn(s5, { props: i7, context: a5 }), r5 = Object.defineProperties({}, { css: { value: { code: "", map: null } }, head: { get: () => n6.head }, html: { get: () => n6.body }, then: { value: (o5, c7) => {
      {
        const d2 = o5({ css: r5.css, head: r5.head, html: r5.html });
        return Promise.resolve(d2);
      }
    } } });
    return r5;
  };
  return t4.render = e3, t4;
}
function Yt2(s5, t4) {
  s5.component((e3) => {
    let { stores: i7, page: a5, constructors: n6, components: r5 = [], form: o5, data_0: c7 = null, data_1: d2 = null } = t4;
    I("__svelte__", i7), i7.page.set(a5);
    const b8 = n6[1];
    if (n6[1]) {
      e3.push("<!--[-->");
      const f8 = n6[0];
      e3.push("<!---->"), f8(e3, { data: c7, form: o5, params: a5.params, children: (l7) => {
        l7.push("<!---->"), b8(l7, { data: d2, form: o5, params: a5.params }), l7.push("<!---->");
      }, $$slots: { default: true } }), e3.push("<!---->");
    } else {
      e3.push("<!--[!-->");
      const f8 = n6[0];
      e3.push("<!---->"), f8(e3, { data: c7, form: o5, params: a5.params }), e3.push("<!---->");
    }
    e3.push("<!--]--> "), e3.push("<!--[!-->"), e3.push("<!--]-->");
  });
}
var Ut2 = Ht2(Yt2);
var Zt2 = { app_template_contains_nonce: false, async: false, csp: { mode: "auto", directives: { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, reportOnly: { "upgrade-insecure-requests": false, "block-all-mixed-content": false } }, csrf_check_origin: true, csrf_trusted_origins: [], embedded: false, env_public_prefix: "PUBLIC_", env_private_prefix: "", hash_routing: false, hooks: null, preload_strategy: "modulepreload", root: Ut2, service_worker: false, service_worker_options: void 0, templates: { app: ({ head: s5, body: t4, assets: e3, nonce: i7, env: a5 }) => `<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
		<link rel="icon" href="/favicon.ico" sizes="any" />
		<link rel="icon" type="image/png" href="/favicon.png" />
		<link rel="manifest" href="/manifest.json" />
		<meta name="theme-color" content="#faf6f0" />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700;800&family=Outfit:wght@400;600;800&family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
		` + s5 + `
		<script type="text/javascript">
			function googleTranslateElementInit() {
				new google.translate.TranslateElement(
					{
						pageLanguage: "en",
						includedLanguages: "en,vi",
						autoDisplay: false,
					},
					"google_translate_element",
				);
			}
		<\/script>
		<script
			type="text/javascript"
			src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"
		><\/script>
		<style>
			body > .skiptranslate {
				display: none !important;
			}
			body {
				top: 0 !important;
			}
		</style>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">` + t4 + `</div>
	</body>
</html>
`, error: ({ status: s5, message: t4 }) => `<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>` + t4 + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + s5 + `</span>
			<div class="message">
				<h1>` + t4 + `</h1>
			</div>
		</div>
	</body>
</html>
` }, version_hash: "1a0n2n3" };
async function $t2() {
  let s5, t4, e3, i7, a5;
  return { handle: s5, handleFetch: t4, handleError: e3, handleValidationError: i7, init: a5 } = await Promise.resolve().then(() => (init_hooks_server(), hooks_server_exports)), { handle: s5, handleFetch: t4, handleError: e3, handleValidationError: i7, init: a5, reroute: void 0, transport: void 0 };
}

// .svelte-kit/output/server/chunks/shared.js
init_utils2();
var f4 = "x-sveltekit-invalidated";
var p5 = "x-sveltekit-trailing-slash";
function l4(e3, t4) {
  const r5 = Object.fromEntries(Object.entries(t4).map(([n6, s5]) => [n6, s5.encode]));
  return stringify(e3, r5);
}
function u2(e3, t4) {
  if (!e3) return;
  const r5 = i2.decode(l2(e3.replaceAll("-", "+").replaceAll("_", "/"))), n6 = Object.fromEntries(Object.entries(t4).map(([s5, o5]) => [s5, o5.decode]));
  return parse(r5, n6);
}
function m5(e3, t4) {
  return e3 + "/" + t4;
}

// .svelte-kit/output/server/index.js
var import_cookie2 = __toESM(require_cookie(), 1);
var Ze2 = __toESM(require_set_cookie(), 1);
function ht2() {
  let e3, t4;
  return { promise: new Promise((n6, s5) => {
    e3 = n6, t4 = s5;
  }), resolve: e3, reject: t4 };
}
var ir = [101, 103, 204, 205, 304];
var cr = !!globalThis.process?.versions?.webcontainer;
var lr = "/_svelte_kit_assets";
var _t2 = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var dr = ["GET", "POST", "HEAD"];
function Ne(e3, t4) {
  const r5 = [];
  e3.split(",").forEach((a5, o5) => {
    const i7 = /([^/ \t]+)\/([^; \t]+)[ \t]*(?:;[ \t]*q=([0-9.]+))?/.exec(a5);
    if (i7) {
      const [, c7, d2, l7 = "1"] = i7;
      r5.push({ type: c7, subtype: d2, q: +l7, i: o5 });
    }
  }), r5.sort((a5, o5) => a5.q !== o5.q ? o5.q - a5.q : a5.subtype === "*" != (o5.subtype === "*") ? a5.subtype === "*" ? 1 : -1 : a5.type === "*" != (o5.type === "*") ? a5.type === "*" ? 1 : -1 : a5.i - o5.i);
  let n6, s5 = 1 / 0;
  for (const a5 of t4) {
    const [o5, i7] = a5.split("/"), c7 = r5.findIndex((d2) => (d2.type === o5 || d2.type === "*") && (d2.subtype === i7 || d2.subtype === "*"));
    c7 !== -1 && c7 < s5 && (n6 = a5, s5 = c7);
  }
  return n6;
}
function ur(e3, ...t4) {
  const r5 = e3.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return t4.includes(r5.toLowerCase());
}
function He2(e3) {
  return ur(e3, "application/x-www-form-urlencoded", "multipart/form-data", "text/plain");
}
function fr(e3) {
  return e3 instanceof Error || e3 && e3.name && e3.message ? e3 : new Error(JSON.stringify(e3));
}
function ae2(e3) {
  return e3 instanceof HttpError || e3 instanceof SvelteKitError ? e3.status : 500;
}
function pr(e3) {
  return e3 instanceof SvelteKitError ? e3.text : "Internal Error";
}
var mt2 = { "&": "&amp;", '"': "&quot;" };
var yt2 = { "&": "&amp;", "<": "&lt;" };
var gt2 = "[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]";
var hr = new RegExp(`[${Object.keys(mt2).join("")}]|` + gt2, "g");
var _r = new RegExp(`[${Object.keys(yt2).join("")}]|` + gt2, "g");
function Ie(e3, t4) {
  const r5 = t4 ? mt2 : yt2;
  return e3.replace(t4 ? hr : _r, (s5) => s5.length === 2 ? s5 : r5[s5] ?? `&#${s5.charCodeAt(0)};`);
}
function wt2(e3, t4) {
  return text(`${t4} method not allowed`, { status: 405, headers: { allow: mr(e3).join(", ") } });
}
function mr(e3) {
  const t4 = _t2.filter((r5) => r5 in e3);
  return "GET" in e3 && !("HEAD" in e3) && t4.push("HEAD"), t4;
}
function bt2(e3) {
  return `__sveltekit_${e3.version_hash}`;
}
function ye2(e3, t4, r5) {
  let n6 = e3.templates.error({ status: t4, message: Ie(r5) });
  return text(n6, { headers: { "content-type": "text/html; charset=utf-8" }, status: t4 });
}
async function et2(e3, t4, r5, n6) {
  n6 = n6 instanceof HttpError ? n6 : fr(n6);
  const s5 = ae2(n6), a5 = await D2(e3, t4, r5, n6), o5 = Ne(e3.request.headers.get("accept") || "text/html", ["application/json", "text/html"]);
  return e3.isDataRequest || o5 === "application/json" ? json(a5, { status: s5 }) : ye2(r5, s5, a5.message);
}
async function D2(e3, t4, r5, n6) {
  if (n6 instanceof HttpError) return { message: "Unknown Error", ...n6.body };
  const s5 = ae2(n6), a5 = pr(n6);
  return await with_request_store({ event: e3, state: t4 }, () => r5.hooks.handleError({ error: n6, event: e3, status: s5, message: a5 })) ?? { message: a5 };
}
function ge2(e3, t4) {
  return new Response(void 0, { status: e3, headers: { location: t4 } });
}
function kt2(e3, t4) {
  return t4.path ? `Data returned from \`load\` while rendering ${e3.route.id} is not serializable: ${t4.message} (${t4.path}). If you need to serialize/deserialize custom types, use transport hooks: https://svelte.dev/docs/kit/hooks#Universal-hooks-transport.` : t4.path === "" ? `Data returned from \`load\` while rendering ${e3.route.id} is not a plain object` : t4.message;
}
function $t3(e3) {
  const t4 = {};
  return e3.uses && e3.uses.dependencies.size > 0 && (t4.dependencies = Array.from(e3.uses.dependencies)), e3.uses && e3.uses.search_params.size > 0 && (t4.search_params = Array.from(e3.uses.search_params)), e3.uses && e3.uses.params.size > 0 && (t4.params = Array.from(e3.uses.params)), e3.uses?.parent && (t4.parent = 1), e3.uses?.route && (t4.route = 1), e3.uses?.url && (t4.url = 1), t4;
}
function vt2(e3, t4) {
  return e3._.prerendered_routes.has(t4) || t4.at(-1) === "/" && e3._.prerendered_routes.has(t4.slice(0, -1));
}
function yr(e3, t4, r5) {
  const n6 = `
\x1B[1;31m[${e3}] ${r5.request.method} ${r5.url.pathname}\x1B[0m`;
  return e3 === 404 ? n6 : `${n6}
${t4.stack}`;
}
function xt2(e3) {
  const r5 = e3?.split("/")?.at(-1);
  return r5 ? r5.split(".").slice(0, -1).join(".") : "unknown";
}
async function gr(e3, t4, r5, n6) {
  const s5 = e3.request.method;
  let a5 = r5[s5] || r5.fallback;
  if (s5 === "HEAD" && !r5.HEAD && r5.GET && (a5 = r5.GET), !a5) return wt2(r5, s5);
  const o5 = r5.prerender ?? n6.prerender_default;
  if (o5 && (r5.POST || r5.PATCH || r5.PUT || r5.DELETE)) throw new Error("Cannot prerender endpoints that have mutative methods");
  if (n6.prerendering && !n6.prerendering.inside_reroute && !o5) {
    if (n6.depth > 0) throw new Error(`${e3.route.id} is not prerenderable`);
    return new Response(void 0, { status: 204 });
  }
  t4.is_endpoint_request = true;
  try {
    const i7 = await with_request_store({ event: e3, state: t4 }, () => a5(e3));
    if (!(i7 instanceof Response)) throw new Error(`Invalid response from route ${e3.url.pathname}: handler should return a Response object`);
    if (n6.prerendering && (!n6.prerendering.inside_reroute || o5)) {
      const c7 = new Response(i7.clone().body, { status: i7.status, statusText: i7.statusText, headers: new Headers(i7.headers) });
      if (c7.headers.set("x-sveltekit-prerender", String(o5)), n6.prerendering.inside_reroute && o5) c7.headers.set("x-sveltekit-routeid", encodeURI(e3.route.id)), n6.prerendering.dependencies.set(e3.url.pathname, { response: c7, body: null });
      else return c7;
    }
    return i7;
  } catch (i7) {
    if (i7 instanceof Redirect) return new Response(void 0, { status: i7.status, headers: { location: i7.location } });
    throw i7;
  }
}
function wr(e3) {
  const { method: t4, headers: r5 } = e3.request;
  if (_t2.includes(t4) && !dr.includes(t4)) return true;
  if (t4 === "POST" && r5.get("x-sveltekit-action") === "true") return false;
  const n6 = e3.request.headers.get("accept") ?? "*/*";
  return Ne(n6, ["*", "text/html"]) !== "text/html";
}
function Oe(e3) {
  return e3.filter((t4) => t4 != null);
}
var Le2 = "/__data.json";
var we2 = ".html__data.json";
function br(e3) {
  return e3.endsWith(Le2) || e3.endsWith(we2);
}
function De(e3) {
  return e3.endsWith(".html") ? e3.replace(/\.html$/, we2) : e3.replace(/\/$/, "") + Le2;
}
function kr(e3) {
  return e3.endsWith(we2) ? e3.slice(0, -we2.length) + ".html" : e3.slice(0, -Le2.length);
}
var We2 = "/__route.js";
function $r(e3) {
  return e3.endsWith(We2);
}
function Et2(e3) {
  return e3.replace(/\/$/, "") + We2;
}
function vr(e3) {
  return e3.slice(0, -We2.length);
}
var xr = { spanContext() {
  return Er;
}, setAttribute() {
  return this;
}, setAttributes() {
  return this;
}, addEvent() {
  return this;
}, setStatus() {
  return this;
}, updateName() {
  return this;
}, end() {
  return this;
}, isRecording() {
  return false;
}, recordException() {
  return this;
}, addLink() {
  return this;
}, addLinks() {
  return this;
} };
var Er = { traceId: "", spanId: "", traceFlags: 0 };
async function ee2({ name: e3, attributes: t4, fn: r5 }) {
  return r5(xr);
}
function Rt2(e3) {
  return Ne(e3.request.headers.get("accept") ?? "*/*", ["application/json", "text/html"]) === "application/json" && e3.request.method === "POST";
}
async function Rr(e3, t4, r5, n6) {
  const s5 = n6?.actions;
  if (!s5) {
    const a5 = new SvelteKitError(405, "Method Not Allowed", "POST method not allowed. No form actions exist for this page");
    return le2({ type: "error", error: await D2(e3, t4, r5, a5) }, { status: a5.status, headers: { allow: "GET" } });
  }
  St2(s5);
  try {
    const a5 = await Tt3(e3, t4, s5);
    return a5 instanceof ActionFailure ? le2({ type: "failure", status: a5.status, data: tt(a5.data, e3.route.id, r5.hooks.transport) }) : le2({ type: "success", status: a5 ? 200 : 204, data: tt(a5, e3.route.id, r5.hooks.transport) });
  } catch (a5) {
    const o5 = a5;
    return o5 instanceof Redirect ? jt3(o5) : le2({ type: "error", error: await D2(e3, t4, r5, Me2(o5)) }, { status: ae2(o5) });
  }
}
function Me2(e3) {
  return e3 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : e3;
}
function jt3(e3) {
  return le2({ type: "redirect", status: e3.status, location: e3.location });
}
function le2(e3, t4) {
  return json(e3, t4);
}
function jr(e3) {
  return e3.request.method === "POST";
}
async function Sr(e3, t4, r5) {
  const n6 = r5?.actions;
  if (!n6) return e3.setHeaders({ allow: "GET" }), { type: "error", error: new SvelteKitError(405, "Method Not Allowed", "POST method not allowed. No form actions exist for this page") };
  St2(n6);
  try {
    const s5 = await Tt3(e3, t4, n6);
    return s5 instanceof ActionFailure ? { type: "failure", status: s5.status, data: s5.data } : { type: "success", status: 200, data: s5 };
  } catch (s5) {
    const a5 = s5;
    return a5 instanceof Redirect ? { type: "redirect", status: a5.status, location: a5.location } : { type: "error", error: Me2(a5) };
  }
}
function St2(e3) {
  if (e3.default && Object.keys(e3).length > 1) throw new Error("When using named actions, the default action cannot be used. See the docs for more info: https://svelte.dev/docs/kit/form-actions#named-actions");
}
async function Tt3(e3, t4, r5) {
  const n6 = new URL(e3.request.url);
  let s5 = "default";
  for (const o5 of n6.searchParams) if (o5[0].startsWith("/")) {
    if (s5 = o5[0].slice(1), s5 === "default") throw new Error('Cannot use reserved action name "default"');
    break;
  }
  const a5 = r5[s5];
  if (!a5) throw new SvelteKitError(404, "Not Found", `No action with name '${s5}' found`);
  if (!He2(e3.request)) throw new SvelteKitError(415, "Unsupported Media Type", `Form actions expect form-encoded data \u2014 received ${e3.request.headers.get("content-type")}`);
  return ee2({ name: "sveltekit.form_action", attributes: { "http.route": e3.route.id || "unknown" }, fn: async (o5) => {
    const i7 = merge_tracing(e3, o5), c7 = await with_request_store({ event: i7, state: t4 }, () => a5(i7));
    return c7 instanceof ActionFailure && o5.setAttributes({ "sveltekit.form_action.result.type": "failure", "sveltekit.form_action.result.status": c7.status }), c7;
  } });
}
function Tr(e3, t4, r5) {
  const n6 = (s5) => {
    for (const a5 in r5) {
      const o5 = r5[a5].encode(s5);
      if (o5) return `app.decode('${a5}', ${uneval(o5, n6)})`;
    }
  };
  return At3(e3, (s5) => uneval(s5, n6), t4);
}
function tt(e3, t4, r5) {
  const n6 = Object.fromEntries(Object.entries(r5).map(([s5, a5]) => [s5, a5.encode]));
  return At3(e3, (s5) => stringify(s5, n6), t4);
}
function At3(e3, t4, r5) {
  try {
    return t4(e3);
  } catch (n6) {
    const s5 = n6;
    if (e3 instanceof Response) throw new Error(`Data returned from action inside ${r5} is not serializable. Form actions need to return plain objects or fail(). E.g. return { success: true } or return fail(400, { message: "invalid" });`);
    if ("path" in s5) {
      let a5 = `Data returned from action inside ${r5} is not serializable: ${s5.message}`;
      throw s5.path !== "" && (a5 += ` (data.${s5.path})`), new Error(a5);
    }
    throw s5;
  }
}
function Ot3() {
  let e3 = -1, t4 = -1;
  const r5 = [];
  return { iterate: (n6 = (s5) => s5) => ({ [Symbol.asyncIterator]() {
    return { next: async () => {
      const s5 = r5[++t4];
      if (!s5) return { value: null, done: true };
      const a5 = await s5.promise;
      return { value: n6(a5), done: false };
    } };
  } }), add: (n6) => {
    r5.push(ht2()), n6.then((s5) => {
      r5[++e3].resolve(s5);
    });
  } };
}
function de2(e3, t4, r5) {
  let n6 = 1, s5 = -1;
  const a5 = Ot3(), o5 = bt2(r5);
  function i7(d2) {
    return function l7(h5) {
      if (typeof h5?.then == "function") {
        const b8 = n6++, p6 = h5.then((f8) => ({ data: f8 })).catch(async (f8) => ({ error: await D2(e3, t4, r5, f8) })).then(async ({ data: f8, error: u8 }) => {
          let _5;
          try {
            _5 = uneval(u8 ? [, u8] : [f8], l7);
          } catch {
            u8 = await D2(e3, t4, r5, new Error(`Failed to serialize promise while rendering ${e3.route.id}`)), f8 = void 0, _5 = uneval([, u8], l7);
          }
          return { index: d2, str: `${o5}.resolve(${b8}, ${_5.includes("app.decode") ? `(app) => ${_5}` : `() => ${_5}`})` };
        });
        return a5.add(p6), `${o5}.defer(${b8})`;
      } else for (const b8 in r5.hooks.transport) {
        const p6 = r5.hooks.transport[b8].encode(h5);
        if (p6) return `app.decode('${b8}', ${uneval(p6, l7)})`;
      }
    };
  }
  const c7 = [];
  return { set_max_nodes(d2) {
    s5 = d2;
  }, add_node(d2, l7) {
    try {
      if (!l7) {
        c7[d2] = "null";
        return;
      }
      const h5 = { type: "data", data: l7.data, uses: $t3(l7) };
      l7.slash && (h5.slash = l7.slash), c7[d2] = uneval(h5, i7(d2));
    } catch (h5) {
      throw h5.path = h5.path.slice(1), new Error(kt2(e3, h5));
    }
  }, get_data(d2) {
    const l7 = `<script${d2.script_needs_nonce ? ` nonce="${d2.nonce}"` : ""}>`, h5 = `<\/script>
`;
    return { data: `[${Oe(s5 > -1 ? c7.slice(0, s5) : c7).join(",")}]`, chunks: n6 > 1 ? a5.iterate(({ index: b8, str: p6 }) => s5 > -1 && b8 >= s5 ? "" : l7 + p6 + h5) : null };
  } };
}
function qt3(e3, t4, r5) {
  let n6 = 1;
  const s5 = Ot3(), a5 = { ...Object.fromEntries(Object.entries(r5.hooks.transport).map(([i7, c7]) => [i7, c7.encode])), Promise: (i7) => {
    if (typeof i7?.then != "function") return;
    const c7 = n6++;
    let d2 = "data";
    const l7 = i7.catch(async (h5) => (d2 = "error", D2(e3, t4, r5, h5))).then(async (h5) => {
      let b8;
      try {
        b8 = stringify(h5, a5);
      } catch {
        const p6 = await D2(e3, t4, r5, new Error(`Failed to serialize promise while rendering ${e3.route.id}`));
        d2 = "error", b8 = stringify(p6, a5);
      }
      return `{"type":"chunk","id":${c7},"${d2}":${b8}}
`;
    });
    return s5.add(l7), c7;
  } }, o5 = [];
  return { add_node(i7, c7) {
    try {
      if (!c7) {
        o5[i7] = "null";
        return;
      }
      if (c7.type === "error" || c7.type === "skip") {
        o5[i7] = JSON.stringify(c7);
        return;
      }
      o5[i7] = `{"type":"data","data":${stringify(c7.data, a5)},"uses":${JSON.stringify($t3(c7))}${c7.slash ? `,"slash":${JSON.stringify(c7.slash)}` : ""}}`;
    } catch (d2) {
      throw d2.path = "data" + d2.path, new Error(kt2(e3, d2));
    }
  }, get_data() {
    return { data: `{"type":"data","nodes":[${o5.join(",")}]}
`, chunks: n6 > 1 ? s5.iterate() : null };
  } };
}
async function Fe2({ event: e3, event_state: t4, state: r5, node: n6, parent: s5 }) {
  if (!n6?.server) return null;
  let a5 = true;
  const o5 = { dependencies: /* @__PURE__ */ new Set(), params: /* @__PURE__ */ new Set(), parent: false, route: false, url: false, search_params: /* @__PURE__ */ new Set() }, i7 = n6.server.load, c7 = n6.server.trailingSlash;
  if (!i7) return { type: "data", data: null, uses: o5, slash: c7 };
  const d2 = y(e3.url, () => {
    a5 && (o5.url = true);
  }, (h5) => {
    a5 && o5.search_params.add(h5);
  });
  return r5.prerendering && j(d2), { type: "data", data: await ee2({ name: "sveltekit.load", attributes: { "sveltekit.load.node_id": n6.server_id || "unknown", "sveltekit.load.node_type": xt2(n6.server_id), "http.route": e3.route.id || "unknown" }, fn: async (h5) => {
    const b8 = merge_tracing(e3, h5);
    return await with_request_store({ event: b8, state: t4 }, () => i7.call(null, { ...b8, fetch: (f8, u8) => (new URL(f8 instanceof Request ? f8.url : f8, e3.url), e3.fetch(f8, u8)), depends: (...f8) => {
      for (const u8 of f8) {
        const { href: _5 } = new URL(u8, e3.url);
        o5.dependencies.add(_5);
      }
    }, params: new Proxy(e3.params, { get: (f8, u8) => (a5 && o5.params.add(u8), f8[u8]) }), parent: async () => (a5 && (o5.parent = true), s5()), route: new Proxy(e3.route, { get: (f8, u8) => (a5 && (o5.route = true), f8[u8]) }), url: d2, untrack(f8) {
      a5 = false;
      try {
        return f8();
      } finally {
        a5 = true;
      }
    } }));
  } }) ?? null, uses: o5, slash: c7 };
}
async function Pt2({ event: e3, event_state: t4, fetched: r5, node: n6, parent: s5, server_data_promise: a5, state: o5, resolve_opts: i7, csr: c7 }) {
  const d2 = await a5, l7 = n6?.universal?.load;
  return l7 ? await ee2({ name: "sveltekit.load", attributes: { "sveltekit.load.node_id": n6.universal_id || "unknown", "sveltekit.load.node_type": xt2(n6.universal_id), "http.route": e3.route.id || "unknown" }, fn: async (b8) => {
    const p6 = merge_tracing(e3, b8);
    return await with_request_store({ event: p6, state: t4 }, () => l7.call(null, { url: e3.url, params: e3.params, data: d2?.data ?? null, route: e3.route, fetch: Ar(e3, o5, r5, c7, i7), setHeaders: e3.setHeaders, depends: () => {
    }, parent: s5, untrack: (f8) => f8(), tracing: p6.tracing }));
  } }) ?? null : d2?.data ?? null;
}
function Ar(e3, t4, r5, n6, s5) {
  const a5 = async (o5, i7) => {
    const c7 = o5 instanceof Request && o5.body ? o5.clone().body : null, d2 = o5 instanceof Request && [...o5.headers].length ? new Headers(o5.headers) : i7?.headers;
    let l7 = await e3.fetch(o5, i7);
    const h5 = new URL(o5 instanceof Request ? o5.url : o5, e3.url), b8 = h5.origin === e3.url.origin;
    let p6;
    if (b8) t4.prerendering && (p6 = { response: l7, body: null }, t4.prerendering.dependencies.set(h5.pathname, p6));
    else if (h5.protocol === "https:" || h5.protocol === "http:") if ((o5 instanceof Request ? o5.mode : i7?.mode ?? "cors") === "no-cors") l7 = new Response("", { status: l7.status, statusText: l7.statusText, headers: l7.headers });
    else {
      const y5 = l7.headers.get("access-control-allow-origin");
      if (!y5 || y5 !== e3.url.origin && y5 !== "*") throw new Error(`CORS error: ${y5 ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`);
    }
    let f8;
    const u8 = new Proxy(l7, { get(_5, y5, $5) {
      async function j6(x4, m8) {
        const g5 = Number(_5.status);
        if (isNaN(g5)) throw new Error(`response.status is not a number. value: "${_5.status}" type: ${typeof _5.status}`);
        r5.push({ url: b8 ? h5.href.slice(e3.url.origin.length) : h5.href, method: e3.request.method, request_body: o5 instanceof Request && c7 ? await Or(c7) : i7?.body, request_headers: d2, response_body: x4, response: _5, is_b64: m8 });
      }
      if (y5 === "body") {
        if (_5.body === null) return null;
        if (f8) return f8;
        const [x4, m8] = _5.body.tee();
        return (async () => {
          let g5 = new Uint8Array();
          for await (const w5 of x4) {
            const k5 = new Uint8Array(g5.length + w5.length);
            k5.set(g5, 0), k5.set(w5, g5.length), g5 = k5;
          }
          p6 && (p6.body = new Uint8Array(g5)), j6(f2(g5), true);
        })(), f8 = m8;
      }
      if (y5 === "arrayBuffer") return async () => {
        const x4 = await _5.arrayBuffer(), m8 = new Uint8Array(x4);
        return p6 && (p6.body = m8), x4 instanceof ArrayBuffer && await j6(f2(m8), true), x4;
      };
      async function v5() {
        const x4 = await _5.text();
        if (x4 === "" && ir.includes(_5.status)) {
          await j6(void 0, false);
          return;
        }
        return (!x4 || typeof x4 == "string") && await j6(x4, false), p6 && (p6.body = x4), x4;
      }
      return y5 === "text" ? v5 : y5 === "json" ? async () => {
        const x4 = await v5();
        return x4 ? JSON.parse(x4) : void 0;
      } : Reflect.get(_5, y5, _5);
    } });
    if (n6) {
      const _5 = l7.headers.get;
      l7.headers.get = (y5) => {
        const $5 = y5.toLowerCase(), j6 = _5.call(l7.headers, $5);
        if (j6 && !$5.startsWith("x-sveltekit-") && !s5.filterSerializedResponseHeaders($5, j6)) throw new Error(`Failed to get response header "${$5}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://svelte.dev/docs/kit/hooks#Server-hooks-handle (at ${e3.route.id})`);
        return j6;
      };
    }
    return u8;
  };
  return (o5, i7) => {
    const c7 = a5(o5, i7);
    return c7.catch(() => {
    }), c7;
  };
}
async function Or(e3) {
  let t4 = "";
  const r5 = e3.getReader();
  for (; ; ) {
    const { done: n6, value: s5 } = await r5.read();
    if (n6) break;
    t4 += i2.decode(s5);
  }
  return t4;
}
function Ct2(...e3) {
  let t4 = 5381;
  for (const r5 of e3) if (typeof r5 == "string") {
    let n6 = r5.length;
    for (; n6; ) t4 = t4 * 33 ^ r5.charCodeAt(--n6);
  } else if (ArrayBuffer.isView(r5)) {
    const n6 = new Uint8Array(r5.buffer, r5.byteOffset, r5.byteLength);
    let s5 = n6.length;
    for (; s5; ) t4 = t4 * 33 ^ n6[--s5];
  } else throw new TypeError("value must be a string or TypedArray");
  return (t4 >>> 0).toString(36);
}
var zt2 = { "<": "\\u003C", "\u2028": "\\u2028", "\u2029": "\\u2029" };
var qr = new RegExp(`[${Object.keys(zt2).join("")}]`, "g");
function Pr(e3, t4, r5 = false) {
  const n6 = {};
  let s5 = null, a5 = null, o5 = false;
  for (const [l7, h5] of e3.response.headers) t4(l7, h5) && (n6[l7] = h5), l7 === "cache-control" ? s5 = h5 : l7 === "age" ? a5 = h5 : l7 === "vary" && h5.trim() === "*" && (o5 = true);
  const i7 = { status: e3.response.status, statusText: e3.response.statusText, headers: n6, body: e3.response_body }, c7 = JSON.stringify(i7).replace(qr, (l7) => zt2[l7]), d2 = ['type="application/json"', "data-sveltekit-fetched", `data-url="${Ie(e3.url, true)}"`];
  if (e3.is_b64 && d2.push("data-b64"), e3.request_headers || e3.request_body) {
    const l7 = [];
    e3.request_headers && l7.push([...new Headers(e3.request_headers)].join(",")), e3.request_body && l7.push(e3.request_body), d2.push(`data-hash="${Ct2(...l7)}"`);
  }
  if (!r5 && e3.method === "GET" && s5 && !o5) {
    const l7 = /s-maxage=(\d+)/g.exec(s5) ?? /max-age=(\d+)/g.exec(s5);
    if (l7) {
      const h5 = +l7[1] - +(a5 ?? "0");
      d2.push(`data-ttl="${h5}"`);
    }
  }
  return `<script ${d2.join(" ")}>${c7}<\/script>`;
}
var H3 = JSON.stringify;
function rt2(e3) {
  qe2[0] || Cr();
  const t4 = Ut3.slice(0), r5 = zr(e3);
  for (let s5 = 0; s5 < r5.length; s5 += 16) {
    const a5 = r5.subarray(s5, s5 + 16);
    let o5, i7, c7, d2 = t4[0], l7 = t4[1], h5 = t4[2], b8 = t4[3], p6 = t4[4], f8 = t4[5], u8 = t4[6], _5 = t4[7];
    for (let y5 = 0; y5 < 64; y5++) y5 < 16 ? o5 = a5[y5] : (i7 = a5[y5 + 1 & 15], c7 = a5[y5 + 14 & 15], o5 = a5[y5 & 15] = (i7 >>> 7 ^ i7 >>> 18 ^ i7 >>> 3 ^ i7 << 25 ^ i7 << 14) + (c7 >>> 17 ^ c7 >>> 19 ^ c7 >>> 10 ^ c7 << 15 ^ c7 << 13) + a5[y5 & 15] + a5[y5 + 9 & 15] | 0), o5 = o5 + _5 + (p6 >>> 6 ^ p6 >>> 11 ^ p6 >>> 25 ^ p6 << 26 ^ p6 << 21 ^ p6 << 7) + (u8 ^ p6 & (f8 ^ u8)) + qe2[y5], _5 = u8, u8 = f8, f8 = p6, p6 = b8 + o5 | 0, b8 = h5, h5 = l7, l7 = d2, d2 = o5 + (l7 & h5 ^ b8 & (l7 ^ h5)) + (l7 >>> 2 ^ l7 >>> 13 ^ l7 >>> 22 ^ l7 << 30 ^ l7 << 19 ^ l7 << 10) | 0;
    t4[0] = t4[0] + d2 | 0, t4[1] = t4[1] + l7 | 0, t4[2] = t4[2] + h5 | 0, t4[3] = t4[3] + b8 | 0, t4[4] = t4[4] + p6 | 0, t4[5] = t4[5] + f8 | 0, t4[6] = t4[6] + u8 | 0, t4[7] = t4[7] + _5 | 0;
  }
  const n6 = new Uint8Array(t4.buffer);
  return Nt3(n6), btoa(String.fromCharCode(...n6));
}
var Ut3 = new Uint32Array(8);
var qe2 = new Uint32Array(64);
function Cr() {
  function e3(r5) {
    return (r5 - Math.floor(r5)) * 4294967296;
  }
  let t4 = 2;
  for (let r5 = 0; r5 < 64; t4++) {
    let n6 = true;
    for (let s5 = 2; s5 * s5 <= t4; s5++) if (t4 % s5 === 0) {
      n6 = false;
      break;
    }
    n6 && (r5 < 8 && (Ut3[r5] = e3(t4 ** (1 / 2))), qe2[r5] = e3(t4 ** (1 / 3)), r5++);
  }
}
function Nt3(e3) {
  for (let t4 = 0; t4 < e3.length; t4 += 4) {
    const r5 = e3[t4 + 0], n6 = e3[t4 + 1], s5 = e3[t4 + 2], a5 = e3[t4 + 3];
    e3[t4 + 0] = a5, e3[t4 + 1] = s5, e3[t4 + 2] = n6, e3[t4 + 3] = r5;
  }
}
function zr(e3) {
  const t4 = a2.encode(e3), r5 = t4.length * 8, n6 = 512 * Math.ceil((r5 + 65) / 512), s5 = new Uint8Array(n6 / 8);
  s5.set(t4), s5[t4.length] = 128, Nt3(s5);
  const a5 = new Uint32Array(s5.buffer);
  return a5[a5.length - 2] = Math.floor(r5 / 4294967296), a5[a5.length - 1] = r5, a5;
}
var nt2 = new Uint8Array(16);
function Ur() {
  return crypto.getRandomValues(nt2), btoa(String.fromCharCode(...nt2));
}
var Nr = /* @__PURE__ */ new Set(["self", "unsafe-eval", "unsafe-hashes", "unsafe-inline", "none", "strict-dynamic", "report-sample", "wasm-unsafe-eval", "script"]);
var Hr = /^(nonce|sha\d\d\d)-/;
var Ht3 = class {
  #e;
  #t;
  #c;
  #l;
  #d;
  #u;
  #f;
  #p;
  #n;
  #s;
  #a;
  #o;
  #i;
  #r;
  #h;
  constructor(t4, r5, n6) {
    this.#e = t4, this.#n = r5;
    const s5 = this.#n;
    this.#s = [], this.#a = [], this.#o = [], this.#i = [], this.#r = [];
    const a5 = s5["script-src"] || s5["default-src"], o5 = s5["script-src-elem"], i7 = s5["style-src"] || s5["default-src"], c7 = s5["style-src-attr"], d2 = s5["style-src-elem"], l7 = (h5) => !!h5 && !h5.some((b8) => b8 === "unsafe-inline");
    this.#c = l7(a5), this.#l = l7(o5), this.#u = l7(i7), this.#f = l7(c7), this.#p = l7(d2), this.#t = this.#c || this.#l, this.#d = this.#u || this.#f || this.#p, this.script_needs_nonce = this.#t && !this.#e, this.style_needs_nonce = this.#d && !this.#e, this.#h = n6;
  }
  add_script(t4) {
    if (!this.#t) return;
    const r5 = this.#e ? `sha256-${rt2(t4)}` : `nonce-${this.#h}`;
    this.#c && this.#s.push(r5), this.#l && this.#a.push(r5);
  }
  add_style(t4) {
    if (!this.#d) return;
    const r5 = this.#e ? `sha256-${rt2(t4)}` : `nonce-${this.#h}`;
    if (this.#u && this.#o.push(r5), this.#f && this.#i.push(r5), this.#p) {
      const n6 = "sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=", s5 = this.#n;
      s5["style-src-elem"] && !s5["style-src-elem"].includes(n6) && !this.#r.includes(n6) && this.#r.push(n6), r5 !== n6 && this.#r.push(r5);
    }
  }
  get_header(t4 = false) {
    const r5 = [], n6 = { ...this.#n };
    this.#o.length > 0 && (n6["style-src"] = [...n6["style-src"] || n6["default-src"] || [], ...this.#o]), this.#i.length > 0 && (n6["style-src-attr"] = [...n6["style-src-attr"] || [], ...this.#i]), this.#r.length > 0 && (n6["style-src-elem"] = [...n6["style-src-elem"] || [], ...this.#r]), this.#s.length > 0 && (n6["script-src"] = [...n6["script-src"] || n6["default-src"] || [], ...this.#s]), this.#a.length > 0 && (n6["script-src-elem"] = [...n6["script-src-elem"] || [], ...this.#a]);
    for (const s5 in n6) {
      if (t4 && (s5 === "frame-ancestors" || s5 === "report-uri" || s5 === "sandbox")) continue;
      const a5 = n6[s5];
      if (!a5) continue;
      const o5 = [s5];
      Array.isArray(a5) && a5.forEach((i7) => {
        Nr.has(i7) || Hr.test(i7) ? o5.push(`'${i7}'`) : o5.push(i7);
      }), r5.push(o5.join(" "));
    }
    return r5.join("; ");
  }
};
var Ir = class extends Ht3 {
  get_meta() {
    const t4 = this.get_header(true);
    if (t4) return `<meta http-equiv="content-security-policy" content="${Ie(t4, true)}">`;
  }
};
var Lr = class extends Ht3 {
  constructor(t4, r5, n6) {
    if (super(t4, r5, n6), Object.values(r5).filter((s5) => !!s5).length > 0) {
      const s5 = r5["report-to"]?.length ?? false, a5 = r5["report-uri"]?.length ?? false;
      if (!s5 && !a5) throw Error("`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both");
    }
  }
};
var Dr = class {
  nonce = Ur();
  csp_provider;
  report_only_provider;
  constructor({ mode: t4, directives: r5, reportOnly: n6 }, { prerender: s5 }) {
    const a5 = t4 === "hash" || t4 === "auto" && s5;
    this.csp_provider = new Ir(a5, r5, this.nonce), this.report_only_provider = new Lr(a5, n6, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  add_script(t4) {
    this.csp_provider.add_script(t4), this.report_only_provider.add_script(t4);
  }
  add_style(t4) {
    this.csp_provider.add_style(t4), this.report_only_provider.add_style(t4);
  }
};
function It2(e3, t4, r5) {
  const n6 = {}, s5 = e3.slice(1), a5 = s5.filter((i7) => i7 !== void 0);
  let o5 = 0;
  for (let i7 = 0; i7 < t4.length; i7 += 1) {
    const c7 = t4[i7];
    let d2 = s5[i7 - o5];
    if (c7.chained && c7.rest && o5 && (d2 = s5.slice(i7 - o5, i7 + 1).filter((l7) => l7).join("/"), o5 = 0), d2 === void 0) {
      c7.rest && (n6[c7.name] = "");
      continue;
    }
    if (!c7.matcher || r5[c7.matcher](d2)) {
      n6[c7.name] = d2;
      const l7 = t4[i7 + 1], h5 = s5[i7 + 1];
      l7 && !l7.rest && l7.optional && h5 && c7.chained && (o5 = 0), !l7 && !h5 && Object.keys(n6).length === a5.length && (o5 = 0);
      continue;
    }
    if (c7.optional && c7.chained) {
      o5++;
      continue;
    }
    return;
  }
  if (!o5) return n6;
}
function Lt3(e3, t4, r5) {
  const { errors: n6, layouts: s5, leaf: a5 } = e3, o5 = [...n6, ...s5.map((i7) => i7?.[1]), a5[1]].filter((i7) => typeof i7 == "number").map((i7) => `'${i7}': () => ${Dt2(r5._.client.nodes?.[i7], t4)}`).join(`,
		`);
  return [`{
	id: ${H3(e3.id)}`, `errors: ${H3(e3.errors)}`, `layouts: ${H3(e3.layouts)}`, `leaf: ${H3(e3.leaf)}`, `nodes: {
		${o5}
	}
}`].join(`,
	`);
}
function Dt2(e3, t4) {
  if (!e3) return "Promise.resolve({})";
  if (e3[0] === "/") return `import('${e3}')`;
  if (t !== "") return `import('${t}/${e3}')`;
  let r5 = s2(t4.pathname, `${e}/${e3}`);
  return r5[0] !== "." && (r5 = `./${r5}`), `import('${r5}')`;
}
async function Wr(e3, t4, r5) {
  if (!r5._.client.routes) return text("Server-side route resolution disabled", { status: 400 });
  let n6 = null, s5 = {};
  const a5 = await r5._.matchers();
  for (const o5 of r5._.client.routes) {
    const i7 = o5.pattern.exec(e3);
    if (!i7) continue;
    const c7 = It2(i7, o5.params, a5);
    if (c7) {
      n6 = o5, s5 = x(c7);
      break;
    }
  }
  return Wt2(n6, s5, t4, r5).response;
}
function Wt2(e3, t4, r5, n6) {
  const s5 = new Headers({ "content-type": "application/javascript; charset=utf-8" });
  if (e3) {
    const a5 = Lt3(e3, r5, n6), o5 = `${Mr(e3, r5, n6)}
export const route = ${a5}; export const params = ${JSON.stringify(t4)};`;
    return { response: text(o5, { headers: s5 }), body: o5 };
  } else return { response: text("", { headers: s5 }), body: "" };
}
function Mr(e3, t4, r5) {
  const { errors: n6, layouts: s5, leaf: a5 } = e3;
  let o5 = "";
  for (const i7 of [...n6, ...s5.map((c7) => c7?.[1]), a5[1]]) {
    if (typeof i7 != "number") continue;
    const c7 = r5._.client.css?.[i7];
    for (const d2 of c7 ?? []) o5 += `'${t || e}/${d2}',`;
  }
  return o5 ? `${Dt2(r5._.client.start, t4)}.then(x => x.load_css([${o5}]));` : "";
}
var Fr = { ...g3(false), check: () => false };
async function ue2({ branch: e3, fetched: t4, options: r5, manifest: n6, state: s5, page_config: a5, status: o5, error: i7 = null, event: c7, event_state: d2, resolve_opts: l7, action_result: h5, data_serializer: b8 }) {
  if (s5.prerendering) {
    if (r5.csp.mode === "nonce") throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    if (r5.app_template_contains_nonce) throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
  }
  const { client: p6 } = n6._, f8 = new Set(p6.imports), u8 = new Set(p6.stylesheets), _5 = new Set(p6.fonts), y5 = /* @__PURE__ */ new Set(), $5 = /* @__PURE__ */ new Set(), j6 = /* @__PURE__ */ new Map();
  let v5;
  const x4 = h5?.type === "success" || h5?.type === "failure" ? h5.data ?? null : null;
  let m8 = e, g5 = t, w5 = H3(e);
  if (s5.prerendering?.fallback ? r5.hash_routing && (w5 = "new URL('.', location).pathname.slice(0, -1)") : (m8 = c7.url.pathname.slice(e.length).split("/").slice(2).map(() => "..").join("/") || ".", w5 = `new URL(${H3(m8)}, location).pathname.slice(0, -1)`, (!t || t[0] === "/" && t !== lr) && (g5 = m8)), a5.ssr) {
    const S5 = { stores: { page: a3(null), navigating: a3(null), updated: Fr }, constructors: await Promise.all(e3.map(({ node: q5 }) => {
      if (!q5.component) throw new Error(`Missing +page.svelte component for route ${c7.route.id}`);
      return q5.component();
    })), form: x4 };
    let A13 = {};
    for (let q5 = 0; q5 < e3.length; q5 += 1) A13 = { ...A13, ...e3[q5].data }, S5[`data_${q5}`] = A13;
    S5.page = { error: i7, params: c7.params, route: c7.route, status: o5, url: c7.url, data: A13, form: x4, state: {} };
    const G3 = { context: /* @__PURE__ */ new Map([["__request__", { page: S5.page }]]) }, re2 = globalThis.fetch;
    try {
      v5 = await with_request_store({ event: c7, state: d2 }, async () => {
        r && o({ base: m8, assets: g5 });
        const q5 = r5.root.render(S5, G3), W2 = r5.async && "then" in q5 ? q5.then((O6) => O6) : q5;
        r5.async && c();
        const { head: Q3, html: pe2, css: he2 } = r5.async ? await W2 : W2;
        return { head: Q3, html: pe2, css: he2 };
      });
    } finally {
      c();
    }
    for (const { node: q5 } of e3) {
      for (const W2 of q5.imports) f8.add(W2);
      for (const W2 of q5.stylesheets) u8.add(W2);
      for (const W2 of q5.fonts) _5.add(W2);
      q5.inline_styles && !p6.inline && Object.entries(await q5.inline_styles()).forEach(([W2, Q3]) => j6.set(W2, Q3));
    }
  } else v5 = { head: "", html: "", css: { code: "", map: null } };
  let k5 = "", E7 = v5.html;
  const R7 = new Dr(r5.csp, { prerender: !!s5.prerendering }), T4 = (S5) => S5.startsWith("/") ? e + S5 : `${g5}/${S5}`, P8 = p6.inline ? p6.inline?.style : Array.from(j6.values()).join(`
`);
  if (P8) {
    const S5 = [];
    R7.style_needs_nonce && S5.push(` nonce="${R7.nonce}"`), R7.add_style(P8), k5 += `
	<style${S5.join("")}>${P8}</style>`;
  }
  for (const S5 of u8) {
    const A13 = T4(S5), G3 = ['rel="stylesheet"'];
    j6.has(S5) ? G3.push("disabled", 'media="(max-width: 0)"') : l7.preload({ type: "css", path: A13 }) && y5.add(`<${encodeURI(A13)}>; rel="preload"; as="style"; nopush`), k5 += `
		<link href="${A13}" ${G3.join(" ")}>`;
  }
  for (const S5 of _5) {
    const A13 = T4(S5);
    if (l7.preload({ type: "font", path: A13 })) {
      const G3 = S5.slice(S5.lastIndexOf(".") + 1);
      $5.add(`<link rel="preload" as="font" type="font/${G3}" href="${A13}" crossorigin>`), y5.add(`<${encodeURI(A13)}>; rel="preload"; as="font"; type="font/${G3}"; crossorigin; nopush`);
    }
  }
  const M9 = bt2(r5), { data: F5, chunks: X4 } = b8.get_data(R7);
  if (a5.ssr && a5.csr && (E7 += `
			${t4.map((S5) => Pr(S5, l7.filterSerializedResponseHeaders, !!s5.prerendering)).join(`
			`)}`), a5.csr) {
    const S5 = n6._.client.routes?.find((O6) => O6.id === c7.route.id) ?? null;
    if (p6.uses_env_dynamic_public && s5.prerendering && f8.add(`${i}/env.js`), !p6.inline) {
      const O6 = Array.from(f8, (C6) => T4(C6)).filter((C6) => l7.preload({ type: "js", path: C6 }));
      for (const C6 of O6) y5.add(`<${encodeURI(C6)}>; rel="modulepreload"; nopush`), r5.preload_strategy !== "modulepreload" ? k5 += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${C6}">` : $5.add(`<link rel="modulepreload" href="${C6}">`);
    }
    if (s5.prerendering && $5.size > 0 && (k5 += Array.from($5).map((O6) => `
		${O6}`).join("")), n6._.client.routes && s5.prerendering && !s5.prerendering.fallback) {
      const O6 = Et2(c7.url.pathname);
      s5.prerendering.dependencies.set(O6, Wt2(S5, c7.params, new URL(O6, c7.url), n6));
    }
    const A13 = [], G3 = p6.uses_env_dynamic_public && s5.prerendering, re2 = [`base: ${w5}`];
    if (t && re2.push(`assets: ${H3(t)}`), p6.uses_env_dynamic_public && re2.push(`env: ${G3 ? "null" : H3(Tt2)}`), X4) {
      A13.push("const deferred = new Map();"), re2.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      let O6 = "";
      Object.keys(r5.hooks.transport).length > 0 && (p6.inline ? O6 = `const app = __sveltekit_${r5.version_hash}.app.app;` : p6.app ? O6 = `const app = await import(${H3(T4(p6.app))});` : O6 = `const { app } = await import(${H3(T4(p6.start))});`);
      const C6 = O6 ? `${O6}
							const [data, error] = fn(app);` : "const [data, error] = fn();";
      re2.push(`resolve: async (id, fn) => {
							${C6}

							const try_to_resolve = () => {
								if (!deferred.has(id)) {
									setTimeout(try_to_resolve, 0);
									return;
								}
								const { fulfil, reject } = deferred.get(id);
								deferred.delete(id);
								if (error) reject(error);
								else fulfil(data);
							}
							try_to_resolve();
						}`);
    }
    A13.push(`${M9} = {
						${re2.join(`,
						`)}
					};`);
    const q5 = ["element"];
    if (A13.push("const element = document.currentScript.parentElement;"), a5.ssr) {
      const O6 = { form: "null", error: "null" };
      x4 && (O6.form = Tr(x4, c7.route.id, r5.hooks.transport)), i7 && (O6.error = uneval(i7));
      const C6 = [`node_ids: [${e3.map(({ node: Y3 }) => Y3.index).join(", ")}]`, `data: ${F5}`, `form: ${O6.form}`, `error: ${O6.error}`];
      if (o5 !== 200 && C6.push(`status: ${o5}`), n6._.client.routes) {
        if (S5) {
          const Y3 = Lt3(S5, c7.url, n6).replaceAll(`
`, `
							`);
          C6.push(`params: ${uneval(c7.params)}`, `server_route: ${Y3}`);
        }
      } else r5.embedded && C6.push(`params: ${uneval(c7.params)}`, `route: ${H3(c7.route)}`);
      const Z5 = "	".repeat(G3 ? 7 : 6);
      q5.push(`{
${Z5}	${C6.join(`,
${Z5}	`)}
${Z5}}`);
    }
    const { remote_data: W2 } = d2;
    let Q3 = "";
    if (W2) {
      const O6 = {};
      for (const [Z5, Y3] of W2) if (Z5.id) for (const ie2 in Y3) O6[m5(Z5.id, ie2)] = await Y3[ie2];
      const C6 = (Z5) => {
        for (const Y3 in r5.hooks.transport) {
          const ie2 = r5.hooks.transport[Y3].encode(Z5);
          if (ie2) return `app.decode('${Y3}', ${uneval(ie2, C6)})`;
        }
      };
      Q3 = `${M9}.data = ${uneval(O6, C6)};

						`;
    }
    const pe2 = p6.inline ? `${p6.inline.script}

					${Q3}${M9}.app.start(${q5.join(", ")});` : p6.app ? `Promise.all([
						import(${H3(T4(p6.start))}),
						import(${H3(T4(p6.app))})
					]).then(([kit, app]) => {
						${Q3}kit.start(app, ${q5.join(", ")});
					});` : `import(${H3(T4(p6.start))}).then((app) => {
						${Q3}app.start(${q5.join(", ")})
					});`;
    if (G3 ? A13.push(`import(${H3(`${m8}/${i}/env.js`)}).then(({ env }) => {
						${M9}.env = env;

						${pe2.replace(/\n/g, `
	`)}
					});`) : A13.push(pe2), r5.service_worker) {
      let O6 = "";
      if (r5.service_worker_options != null) {
        const C6 = { ...r5.service_worker_options };
        O6 = `, ${H3(C6)}`;
      }
      A13.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${T4("service-worker.js")}'${O6});
						});
					}`);
    }
    const he2 = `
				{
					${A13.join(`

					`)}
				}
			`;
    R7.add_script(he2), E7 += `
			<script${R7.script_needs_nonce ? ` nonce="${R7.nonce}"` : ""}>${he2}<\/script>
		`;
  }
  const K2 = new Headers({ "x-sveltekit-page": "true", "content-type": "text/html" });
  if (s5.prerendering) {
    const S5 = [], A13 = R7.csp_provider.get_meta();
    A13 && S5.push(A13), s5.prerendering.cache && S5.push(`<meta http-equiv="cache-control" content="${s5.prerendering.cache}">`), S5.length > 0 && (k5 = S5.join(`
`) + k5);
  } else {
    const S5 = R7.csp_provider.get_header();
    S5 && K2.set("content-security-policy", S5);
    const A13 = R7.report_only_provider.get_header();
    A13 && K2.set("content-security-policy-report-only", A13), y5.size && K2.set("link", Array.from(y5).join(", "));
  }
  k5 += v5.head;
  const ke = r5.templates.app({ head: k5, body: E7, assets: g5, nonce: R7.nonce, env: Tt2 }), $e = await l7.transformPageChunk({ html: ke, done: true }) || "";
  return X4 || K2.set("etag", `"${Ct2($e)}"`), X4 ? new Response(new ReadableStream({ async start(S5) {
    S5.enqueue(a2.encode($e + `
`));
    for await (const A13 of X4) A13.length && S5.enqueue(a2.encode(A13));
    S5.close();
  }, type: "bytes" }), { headers: K2 }) : text($e, { status: o5, headers: K2 });
}
var Ge2 = class {
  data;
  constructor(t4) {
    this.data = t4;
  }
  layouts() {
    return this.data.slice(0, -1);
  }
  page() {
    return this.data.at(-1);
  }
  validate() {
    for (const r5 of this.layouts()) r5 && (R(r5.server, r5.server_id), E(r5.universal, r5.universal_id));
    const t4 = this.page();
    t4 && (U(t4.server, t4.server_id), O(t4.universal, t4.universal_id));
  }
  #e(t4) {
    return this.data.reduce((r5, n6) => n6?.universal?.[t4] ?? n6?.server?.[t4] ?? r5, void 0);
  }
  csr() {
    return this.#e("csr") ?? true;
  }
  ssr() {
    return this.#e("ssr") ?? true;
  }
  prerender() {
    return this.#e("prerender") ?? false;
  }
  trailing_slash() {
    return this.#e("trailingSlash") ?? "never";
  }
  get_config() {
    let t4 = {};
    for (const r5 of this.data) !r5?.universal?.config && !r5?.server?.config || (t4 = { ...t4, ...r5?.universal?.config, ...r5?.server?.config });
    return Object.keys(t4).length ? t4 : void 0;
  }
  should_prerender_data() {
    return this.data.some((t4) => t4?.server?.load || t4?.server?.trailingSlash !== void 0);
  }
};
async function Mt3({ event: e3, event_state: t4, options: r5, manifest: n6, state: s5, status: a5, error: o5, resolve_opts: i7 }) {
  if (e3.request.headers.get("x-sveltekit-error")) return ye2(r5, a5, o5.message);
  const c7 = [];
  try {
    const d2 = [], l7 = await n6._.nodes[0](), h5 = new Ge2([l7]), b8 = h5.ssr(), p6 = h5.csr(), f8 = de2(e3, t4, r5);
    if (b8) {
      s5.error = true;
      const u8 = Fe2({ event: e3, event_state: t4, state: s5, node: l7, parent: async () => ({}) }), _5 = await u8;
      f8.add_node(0, _5);
      const y5 = await Pt2({ event: e3, event_state: t4, fetched: c7, node: l7, parent: async () => ({}), resolve_opts: i7, server_data_promise: u8, state: s5, csr: p6 });
      d2.push({ node: l7, server_data: _5, data: y5 }, { node: await n6._.nodes[1](), data: null, server_data: null });
    }
    return await ue2({ options: r5, manifest: n6, state: s5, page_config: { ssr: b8, csr: p6 }, status: a5, error: await D2(e3, t4, r5, o5), branch: d2, fetched: c7, event: e3, event_state: t4, resolve_opts: i7, data_serializer: f8 });
  } catch (d2) {
    return d2 instanceof Redirect ? ge2(d2.status, d2.location) : ye2(r5, ae2(d2), (await D2(e3, t4, r5, d2)).message);
  }
}
async function Gr(e3, t4, r5, n6, s5) {
  return ee2({ name: "sveltekit.remote.call", attributes: {}, fn: (a5) => {
    const o5 = merge_tracing(e3, a5);
    return with_request_store({ event: o5, state: t4 }, () => Br(o5, t4, r5, n6, s5));
  } });
}
async function Br(e3, t4, r5, n6, s5) {
  const [a5, o5, i7] = s5.split("/"), c7 = n6._.remotes;
  c7[a5] || error(404);
  const l7 = (await c7[a5]()).default[o5];
  l7 || error(404);
  const h5 = l7.__, b8 = r5.hooks.transport;
  e3.tracing.current.setAttributes({ "sveltekit.remote.call.type": h5.type, "sveltekit.remote.call.name": h5.name });
  let p6;
  try {
    if (h5.type === "query_batch") {
      if (e3.request.method !== "POST") throw new SvelteKitError(405, "Method Not Allowed", `\`query.batch\` functions must be invoked via POST request, not ${e3.request.method}`);
      const { payloads: y5 } = await e3.request.json(), $5 = y5.map((x4) => u2(x4, b8)), j6 = await with_request_store({ event: e3, state: t4 }, () => h5.run($5)), v5 = await Promise.all($5.map(async (x4, m8) => {
        try {
          return { type: "result", data: j6(x4, m8) };
        } catch (g5) {
          return { type: "error", error: await D2(e3, t4, r5, g5), status: g5 instanceof HttpError || g5 instanceof SvelteKitError ? g5.status : 500 };
        }
      }));
      return json({ type: "result", result: l4(v5, b8) });
    }
    if (h5.type === "form") {
      if (e3.request.method !== "POST") throw new SvelteKitError(405, "Method Not Allowed", `\`form\` functions must be invoked via POST request, not ${e3.request.method}`);
      if (!He2(e3.request)) throw new SvelteKitError(415, "Unsupported Media Type", `\`form\` functions expect form-encoded data \u2014 received ${e3.request.headers.get("content-type")}`);
      const y5 = await e3.request.formData();
      p6 = JSON.parse(y5.get("sveltekit:remote_refreshes") ?? "[]"), y5.delete("sveltekit:remote_refreshes"), i7 && y5.set("sveltekit:id", decodeURIComponent(i7));
      const $5 = h5.fn, j6 = await with_request_store({ event: e3, state: t4 }, () => $5(y5));
      return json({ type: "result", result: l4(j6, b8), refreshes: j6.issues ? {} : await f8(p6) });
    }
    if (h5.type === "command") {
      const { payload: y5, refreshes: $5 } = await e3.request.json(), j6 = u2(y5, b8), v5 = await with_request_store({ event: e3, state: t4 }, () => l7(j6));
      return json({ type: "result", result: l4(v5, b8), refreshes: await f8($5) });
    }
    const u8 = h5.type === "prerender" ? i7 : new URL(e3.request.url).searchParams.get("payload"), _5 = await with_request_store({ event: e3, state: t4 }, () => l7(u2(u8, b8)));
    return json({ type: "result", result: l4(_5, b8) });
  } catch (u8) {
    if (u8 instanceof Redirect) return json({ type: "redirect", location: u8.location, refreshes: await f8(p6 ?? []) });
    const _5 = u8 instanceof HttpError || u8 instanceof SvelteKitError ? u8.status : 500;
    return json({ type: "error", error: await D2(e3, t4, r5, u8), status: _5 }, { status: t4.prerendering ? _5 : void 0, headers: { "cache-control": "private, no-store" } });
  }
  async function f8(u8) {
    const _5 = t4.refreshes ?? {};
    for (const y5 of u8) {
      if (_5[y5] !== void 0) continue;
      const [$5, j6, v5] = y5.split("/"), x4 = n6._.remotes[$5], m8 = (await x4?.())?.default?.[j6];
      m8 || error(400, "Bad Request"), _5[y5] = with_request_store({ event: e3, state: t4 }, () => m8(u2(v5, b8)));
    }
    if (Object.keys(_5).length !== 0) return l4(Object.fromEntries(await Promise.all(Object.entries(_5).map(async ([y5, $5]) => [y5, await $5]))), b8);
  }
}
async function Jr(e3, t4, r5, n6) {
  return ee2({ name: "sveltekit.remote.form.post", attributes: {}, fn: (s5) => {
    const a5 = merge_tracing(e3, s5);
    return with_request_store({ event: a5, state: t4 }, () => Vr(a5, t4, r5, n6));
  } });
}
async function Vr(e3, t4, r5, n6) {
  const [s5, a5, o5] = n6.split("/");
  let d2 = (await r5._.remotes[s5]?.())?.default[a5];
  if (!d2) return e3.setHeaders({ allow: "GET" }), { type: "error", error: new SvelteKitError(405, "Method Not Allowed", "POST method not allowed. No form actions exist for this page") };
  o5 && (d2 = with_request_store({ event: e3, state: t4 }, () => d2.for(JSON.parse(o5))));
  try {
    const l7 = await e3.request.formData(), h5 = d2.__.fn;
    return o5 && !l7.has("id") && l7.set("sveltekit:id", decodeURIComponent(o5)), await with_request_store({ event: e3, state: t4 }, () => h5(l7)), { type: "success", status: 200 };
  } catch (l7) {
    const h5 = l7;
    return h5 instanceof Redirect ? { type: "redirect", status: h5.status, location: h5.location } : { type: "error", error: Me2(h5) };
  }
}
function Xr(e3) {
  return e3.pathname.startsWith(`${e}/${i}/remote/`) && e3.pathname.replace(`${e}/${i}/remote/`, "");
}
function Kr(e3) {
  return e3.searchParams.get("/remote");
}
var Yr = 10;
async function Qr(e3, t4, r5, n6, s5, a5, o5, i7) {
  if (a5.depth > Yr) return text(`Not found: ${e3.url.pathname}`, { status: 404 });
  if (Rt2(e3)) {
    const c7 = await s5._.nodes[r5.leaf]();
    return Rr(e3, t4, n6, c7?.server);
  }
  try {
    const c7 = o5.page();
    let d2 = 200, l7;
    if (jr(e3)) {
      const g5 = Kr(e3.url);
      if (g5 ? l7 = await Jr(e3, t4, s5, g5) : l7 = await Sr(e3, t4, c7.server), l7?.type === "redirect") return ge2(l7.status, l7.location);
      l7?.type === "error" && (d2 = ae2(l7.error)), l7?.type === "failure" && (d2 = l7.status);
    }
    const h5 = o5.prerender();
    if (h5) {
      if (c7.server?.actions) throw new Error("Cannot prerender pages with actions");
    } else if (a5.prerendering) return new Response(void 0, { status: 204 });
    a5.prerender_default = h5;
    const b8 = o5.should_prerender_data(), p6 = De(e3.url.pathname), f8 = [], u8 = o5.ssr(), _5 = o5.csr();
    if (u8 === false && !(a5.prerendering && b8)) return s && l7 && e3.request.headers.has("x-sveltekit-action"), await ue2({ branch: [], fetched: f8, page_config: { ssr: false, csr: _5 }, status: d2, error: null, event: e3, event_state: t4, options: n6, manifest: s5, state: a5, resolve_opts: i7, data_serializer: de2(e3, t4, n6) });
    const y5 = [];
    let $5 = null;
    const j6 = de2(e3, t4, n6), v5 = a5.prerendering && b8 ? qt3(e3, t4, n6) : null, x4 = o5.data.map((g5, w5) => {
      if ($5) throw $5;
      return Promise.resolve().then(async () => {
        try {
          if (g5 === c7 && l7?.type === "error") throw l7.error;
          const k5 = await Fe2({ event: e3, event_state: t4, state: a5, node: g5, parent: async () => {
            const E7 = {};
            for (let R7 = 0; R7 < w5; R7 += 1) {
              const T4 = await x4[R7];
              T4 && Object.assign(E7, T4.data);
            }
            return E7;
          } });
          return g5 && j6.add_node(w5, k5), v5?.add_node(w5, k5), k5;
        } catch (k5) {
          throw $5 = k5, $5;
        }
      });
    }), m8 = o5.data.map((g5, w5) => {
      if ($5) throw $5;
      return Promise.resolve().then(async () => {
        try {
          return await Pt2({ event: e3, event_state: t4, fetched: f8, node: g5, parent: async () => {
            const k5 = {};
            for (let E7 = 0; E7 < w5; E7 += 1) Object.assign(k5, await m8[E7]);
            return k5;
          }, resolve_opts: i7, server_data_promise: x4[w5], state: a5, csr: _5 });
        } catch (k5) {
          throw $5 = k5, $5;
        }
      });
    });
    for (const g5 of x4) g5.catch(() => {
    });
    for (const g5 of m8) g5.catch(() => {
    });
    for (let g5 = 0; g5 < o5.data.length; g5 += 1) {
      const w5 = o5.data[g5];
      if (w5) try {
        const k5 = await x4[g5], E7 = await m8[g5];
        y5.push({ node: w5, server_data: k5, data: E7 });
      } catch (k5) {
        const E7 = k5;
        if (E7 instanceof Redirect) {
          if (a5.prerendering && b8) {
            const P8 = JSON.stringify({ type: "redirect", location: E7.location });
            a5.prerendering.dependencies.set(p6, { response: text(P8), body: P8 });
          }
          return ge2(E7.status, E7.location);
        }
        const R7 = ae2(E7), T4 = await D2(e3, t4, n6, E7);
        for (; g5--; ) if (r5.errors[g5]) {
          const P8 = r5.errors[g5], M9 = await s5._.nodes[P8]();
          let F5 = g5;
          for (; !y5[F5]; ) F5 -= 1;
          j6.set_max_nodes(F5 + 1);
          const X4 = Oe(y5.slice(0, F5 + 1)), K2 = new Ge2(X4.map((ke) => ke.node));
          return await ue2({ event: e3, event_state: t4, options: n6, manifest: s5, state: a5, resolve_opts: i7, page_config: { ssr: K2.ssr(), csr: K2.csr() }, status: R7, error: T4, branch: X4.concat({ node: M9, data: null, server_data: null }), fetched: f8, data_serializer: j6 });
        }
        return ye2(n6, R7, T4.message);
      }
      else y5.push(null);
    }
    if (a5.prerendering && v5) {
      let { data: g5, chunks: w5 } = v5.get_data();
      if (w5) for await (const k5 of w5) g5 += k5;
      a5.prerendering.dependencies.set(p6, { response: text(g5), body: g5 });
    }
    return await ue2({ event: e3, event_state: t4, options: n6, manifest: s5, state: a5, resolve_opts: i7, page_config: { csr: _5, ssr: u8 }, status: d2, error: null, branch: u8 === false ? [] : Oe(y5), action_result: l7, fetched: f8, data_serializer: u8 === false ? de2(e3, t4, n6) : j6 });
  } catch (c7) {
    return await Mt3({ event: e3, event_state: t4, options: n6, manifest: s5, state: a5, status: 500, error: c7, resolve_opts: i7 });
  }
}
function Zr(e3) {
  let t4 = false, r5;
  return () => t4 ? r5 : (t4 = true, r5 = e3());
}
async function en2(e3, t4, r5, n6, s5, a5, o5, i7) {
  if (!r5.page) return new Response(void 0, { status: 404 });
  try {
    const c7 = [...r5.page.layouts, r5.page.leaf], d2 = o5 ?? c7.map(() => true);
    let l7 = false;
    const h5 = new URL(e3.url);
    h5.pathname = $(h5.pathname, i7);
    const b8 = { ...e3, url: h5 }, p6 = c7.map((v5, x4) => Zr(async () => {
      try {
        if (l7) return { type: "skip" };
        const m8 = v5 == null ? v5 : await s5._.nodes[v5]();
        return Fe2({ event: b8, event_state: t4, state: a5, node: m8, parent: async () => {
          const g5 = {};
          for (let w5 = 0; w5 < x4; w5 += 1) {
            const k5 = await p6[w5]();
            k5 && Object.assign(g5, k5.data);
          }
          return g5;
        } });
      } catch (m8) {
        throw l7 = true, m8;
      }
    })), f8 = p6.map(async (v5, x4) => d2[x4] ? v5() : { type: "skip" });
    let u8 = f8.length;
    const _5 = await Promise.all(f8.map((v5, x4) => v5.catch(async (m8) => {
      if (m8 instanceof Redirect) throw m8;
      return u8 = Math.min(u8, x4 + 1), { type: "error", error: await D2(e3, t4, n6, m8), status: m8 instanceof HttpError || m8 instanceof SvelteKitError ? m8.status : void 0 };
    }))), y5 = qt3(e3, t4, n6);
    for (let v5 = 0; v5 < _5.length; v5++) y5.add_node(v5, _5[v5]);
    const { data: $5, chunks: j6 } = y5.get_data();
    return j6 ? new Response(new ReadableStream({ async start(v5) {
      v5.enqueue(a2.encode($5));
      for await (const x4 of j6) v5.enqueue(a2.encode(x4));
      v5.close();
    }, type: "bytes" }), { headers: { "content-type": "text/sveltekit-data", "cache-control": "private, no-store" } }) : Pe($5);
  } catch (c7) {
    const d2 = c7;
    return d2 instanceof Redirect ? Ce(d2) : Pe(await D2(e3, t4, n6, d2), 500);
  }
}
function Pe(e3, t4 = 200) {
  return text(typeof e3 == "string" ? e3 : JSON.stringify(e3), { status: t4, headers: { "content-type": "application/json", "cache-control": "private, no-store" } });
}
function Ce(e3) {
  return Pe({ type: "redirect", location: e3.location });
}
var tn2 = /[\x00-\x1F\x7F()<>@,;:"/[\]?={} \t]/;
function xe2(e3) {
  if (e3?.path === void 0) throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
}
function rn2(e3, t4, r5) {
  return `${e3 || ""}${t4}?${encodeURIComponent(r5)}`;
}
function nn2(e3, t4) {
  const r5 = e3.headers.get("cookie") ?? "", n6 = (0, import_cookie2.parse)(r5, { decode: (b8) => b8 });
  let s5;
  const a5 = /* @__PURE__ */ new Map(), o5 = { httpOnly: true, sameSite: "lax", secure: !(t4.hostname === "localhost" && t4.protocol === "http:") }, i7 = { get(b8, p6) {
    const f8 = Array.from(a5.values()).filter((y5) => y5.name === b8 && Ee2(t4.hostname, y5.options.domain) && Re(t4.pathname, y5.options.path)).sort((y5, $5) => $5.options.path.length - y5.options.path.length)[0];
    return f8 ? f8.options.maxAge === 0 ? void 0 : f8.value : (0, import_cookie2.parse)(r5, { decode: p6?.decode })[b8];
  }, getAll(b8) {
    const p6 = (0, import_cookie2.parse)(r5, { decode: b8?.decode }), f8 = /* @__PURE__ */ new Map();
    for (const u8 of a5.values()) if (Ee2(t4.hostname, u8.options.domain) && Re(t4.pathname, u8.options.path)) {
      const _5 = f8.get(u8.name);
      (!_5 || u8.options.path.length > _5.options.path.length) && f8.set(u8.name, u8);
    }
    for (const u8 of f8.values()) p6[u8.name] = u8.value;
    return Object.entries(p6).map(([u8, _5]) => ({ name: u8, value: _5 }));
  }, set(b8, p6, f8) {
    const u8 = b8.match(tn2);
    u8 && console.warn(`The cookie name "${b8}" will be invalid in SvelteKit 3.0 as it contains ${u8.join(" and ")}. See RFC 2616 for more details https://datatracker.ietf.org/doc/html/rfc2616#section-2.2`), xe2(f8), l7(b8, p6, { ...o5, ...f8 });
  }, delete(b8, p6) {
    xe2(p6), i7.set(b8, "", { ...p6, maxAge: 0 });
  }, serialize(b8, p6, f8) {
    xe2(f8);
    let u8 = f8.path;
    if (!f8.domain || f8.domain === t4.hostname) {
      if (!s5) throw new Error("Cannot serialize cookies until after the route is determined");
      u8 = b(s5, u8);
    }
    return (0, import_cookie2.serialize)(b8, p6, { ...o5, ...f8, path: u8 });
  } };
  function c7(b8, p6) {
    const f8 = { ...n6 };
    for (const u8 of a5.values()) {
      if (!Ee2(b8.hostname, u8.options.domain) || !Re(b8.pathname, u8.options.path)) continue;
      const _5 = u8.options.encode || encodeURIComponent;
      f8[u8.name] = _5(u8.value);
    }
    if (p6) {
      const u8 = (0, import_cookie2.parse)(p6, { decode: (_5) => _5 });
      for (const _5 in u8) f8[_5] = u8[_5];
    }
    return Object.entries(f8).map(([u8, _5]) => `${u8}=${_5}`).join("; ");
  }
  const d2 = [];
  function l7(b8, p6, f8) {
    if (!s5) {
      d2.push(() => l7(b8, p6, f8));
      return;
    }
    let u8 = f8.path;
    (!f8.domain || f8.domain === t4.hostname) && (u8 = b(s5, u8));
    const _5 = rn2(f8.domain, u8, b8), y5 = { name: b8, value: p6, options: { ...f8, path: u8 } };
    a5.set(_5, y5);
  }
  function h5(b8) {
    s5 = $(t4.pathname, b8), d2.forEach((p6) => p6());
  }
  return { cookies: i7, new_cookies: a5, get_cookie_header: c7, set_internal: l7, set_trailing_slash: h5 };
}
function Ee2(e3, t4) {
  if (!t4) return true;
  const r5 = t4[0] === "." ? t4.slice(1) : t4;
  return e3 === r5 ? true : e3.endsWith("." + r5);
}
function Re(e3, t4) {
  if (!t4) return true;
  const r5 = t4.endsWith("/") ? t4.slice(0, -1) : t4;
  return e3 === r5 ? true : e3.startsWith(r5 + "/");
}
function st2(e3, t4) {
  for (const r5 of t4) {
    const { name: n6, value: s5, options: a5 } = r5;
    if (e3.append("set-cookie", (0, import_cookie2.serialize)(n6, s5, a5)), a5.path.endsWith(".html")) {
      const o5 = De(a5.path);
      e3.append("set-cookie", (0, import_cookie2.serialize)(n6, s5, { ...a5, path: o5 }));
    }
  }
}
function sn2({ event: e3, options: t4, manifest: r5, state: n6, get_cookie_header: s5, set_internal: a5 }) {
  const o5 = async (i7, c7) => {
    const d2 = at2(i7, c7, e3.url);
    let l7 = (i7 instanceof Request ? i7.mode : c7?.mode) ?? "cors", h5 = (i7 instanceof Request ? i7.credentials : c7?.credentials) ?? "same-origin";
    return t4.hooks.handleFetch({ event: e3, request: d2, fetch: async (b8, p6) => {
      const f8 = at2(b8, p6, e3.url), u8 = new URL(f8.url);
      if (f8.headers.has("origin") || f8.headers.set("origin", e3.url.origin), b8 !== d2 && (l7 = (b8 instanceof Request ? b8.mode : p6?.mode) ?? "cors", h5 = (b8 instanceof Request ? b8.credentials : p6?.credentials) ?? "same-origin"), (f8.method === "GET" || f8.method === "HEAD") && (l7 === "no-cors" && u8.origin !== e3.url.origin || u8.origin === e3.url.origin) && f8.headers.delete("origin"), u8.origin !== e3.url.origin) {
        if (`.${u8.hostname}`.endsWith(`.${e3.url.hostname}`) && h5 !== "omit") {
          const w5 = s5(u8, f8.headers.get("cookie"));
          w5 && f8.headers.set("cookie", w5);
        }
        return fetch(f8);
      }
      const _5 = t || e, y5 = decodeURIComponent(u8.pathname), $5 = (y5.startsWith(_5) ? y5.slice(_5.length) : y5).slice(1), j6 = `${$5}/index.html`, v5 = r5.assets.has($5) || $5 in r5._.server_assets, x4 = r5.assets.has(j6) || j6 in r5._.server_assets;
      if (v5 || x4) {
        const w5 = v5 ? $5 : j6;
        if (n6.read) {
          const k5 = v5 ? r5.mimeTypes[$5.slice($5.lastIndexOf("."))] : "text/html";
          return new Response(n6.read(w5), { headers: k5 ? { "content-type": k5 } : {} });
        } else if (qt2 && w5 in r5._.server_assets) {
          const k5 = r5._.server_assets[w5], E7 = r5.mimeTypes[w5.slice(w5.lastIndexOf("."))];
          return new Response(qt2(w5), { headers: { "Content-Length": "" + k5, "Content-Type": E7 } });
        }
        return await fetch(f8);
      }
      if (vt2(r5, e + y5)) return await fetch(f8);
      if (h5 !== "omit") {
        const w5 = s5(u8, f8.headers.get("cookie"));
        w5 && f8.headers.set("cookie", w5);
        const k5 = e3.request.headers.get("authorization");
        k5 && !f8.headers.has("authorization") && f8.headers.set("authorization", k5);
      }
      f8.headers.has("accept") || f8.headers.set("accept", "*/*"), f8.headers.has("accept-language") || f8.headers.set("accept-language", e3.request.headers.get("accept-language"));
      const m8 = await an2(f8, t4, r5, n6), g5 = m8.headers.get("set-cookie");
      if (g5) for (const w5 of Ze2.splitCookiesString(g5)) {
        const { name: k5, value: E7, ...R7 } = Ze2.parseString(w5, { decodeValues: false }), T4 = R7.path ?? (u8.pathname.split("/").slice(0, -1).join("/") || "/");
        a5(k5, E7, { path: T4, encode: (P8) => P8, ...R7 });
      }
      return m8;
    } });
  };
  return (i7, c7) => {
    const d2 = o5(i7, c7);
    return d2.catch(() => {
    }), d2;
  };
}
function at2(e3, t4, r5) {
  return e3 instanceof Request ? e3 : new Request(typeof e3 == "string" ? new URL(e3, r5) : e3, t4);
}
async function an2(e3, t4, r5, n6) {
  if (e3.signal) {
    if (e3.signal.aborted) throw new DOMException("The operation was aborted.", "AbortError");
    let s5 = () => {
    };
    const a5 = new Promise((i7, c7) => {
      const d2 = () => {
        c7(new DOMException("The operation was aborted.", "AbortError"));
      };
      e3.signal.addEventListener("abort", d2, { once: true }), s5 = () => e3.signal.removeEventListener("abort", d2);
    }), o5 = await Promise.race([ze2(e3, t4, r5, { ...n6, depth: n6.depth + 1 }), a5]);
    return s5(), o5;
  } else return await ze2(e3, t4, r5, { ...n6, depth: n6.depth + 1 });
}
var ot2;
var je2;
var Se;
function on2(e3) {
  return ot2 ??= `export const env=${JSON.stringify(Tt2)}`, je2 ??= `W/${Date.now()}`, Se ??= new Headers({ "content-type": "application/javascript; charset=utf-8", etag: je2 }), e3.headers.get("if-none-match") === je2 ? new Response(void 0, { status: 304, headers: Se }) : new Response(ot2, { headers: Se });
}
var it2 = ({ html: e3 }) => e3;
var ct2 = () => false;
var lt2 = ({ type: e3 }) => e3 === "js" || e3 === "css";
var cn2 = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var ln2 = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
var ze2 = fn2(dn2);
async function dn2(e3, t4, r5, n6) {
  const s5 = new URL(e3.url), a5 = $r(s5.pathname), o5 = br(s5.pathname), i7 = Xr(s5);
  {
    const m8 = e3.headers.get("origin");
    if (i7) {
      if (e3.method !== "GET" && m8 !== s5.origin) return json({ message: "Cross-site remote requests are forbidden" }, { status: 403 });
    } else if (t4.csrf_check_origin && He2(e3) && (e3.method === "POST" || e3.method === "PUT" || e3.method === "PATCH" || e3.method === "DELETE") && m8 !== s5.origin && (!m8 || !t4.csrf_trusted_origins.includes(m8))) {
      const w5 = `Cross-site ${e3.method} form submissions are forbidden`, k5 = { status: 403 };
      return e3.headers.get("accept") === "application/json" ? json({ message: w5 }, k5) : text(w5, k5);
    }
  }
  if (t4.hash_routing && s5.pathname !== e + "/" && s5.pathname !== "/[fallback]") return text("Not found", { status: 404 });
  let c7;
  a5 ? s5.pathname = vr(s5.pathname) : o5 ? (s5.pathname = kr(s5.pathname) + (s5.searchParams.get(p5) === "1" ? "/" : "") || "/", s5.searchParams.delete(p5), c7 = s5.searchParams.get(f4)?.split("").map((m8) => m8 === "1"), s5.searchParams.delete(f4)) : i7 && (s5.pathname = e3.headers.get("x-sveltekit-pathname") ?? e, s5.search = e3.headers.get("x-sveltekit-search") ?? "");
  const d2 = {}, { cookies: l7, new_cookies: h5, get_cookie_header: b8, set_internal: p6, set_trailing_slash: f8 } = nn2(e3, s5), u8 = { prerendering: n6.prerendering, transport: t4.hooks.transport, handleValidationError: t4.hooks.handleValidationError, tracing: { record_span: ee2 }, is_in_remote_function: false }, _5 = { cookies: l7, fetch: null, getClientAddress: n6.getClientAddress || (() => {
    throw new Error("@sveltejs/adapter-cloudflare does not specify getClientAddress. Please raise an issue");
  }), locals: {}, params: {}, platform: n6.platform, request: e3, route: { id: null }, setHeaders: (m8) => {
    for (const g5 in m8) {
      const w5 = g5.toLowerCase(), k5 = m8[g5];
      if (w5 === "set-cookie") throw new Error("Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies");
      if (w5 in d2) throw new Error(`"${g5}" header is already set`);
      d2[w5] = k5, n6.prerendering && w5 === "cache-control" && (n6.prerendering.cache = k5);
    }
  }, url: s5, isDataRequest: o5, isSubRequest: n6.depth > 0, isRemoteRequest: !!i7 };
  _5.fetch = sn2({ event: _5, options: t4, manifest: r5, state: n6, get_cookie_header: b8, set_internal: p6 }), n6.emulator?.platform && (_5.platform = await n6.emulator.platform({ config: {}, prerender: !!n6.prerendering?.fallback }));
  let y5 = s5.pathname;
  if (!i7) {
    const m8 = n6.prerendering?.inside_reroute;
    try {
      n6.prerendering && (n6.prerendering.inside_reroute = true), y5 = await t4.hooks.reroute({ url: new URL(s5), fetch: _5.fetch }) ?? s5.pathname;
    } catch {
      return text("Internal Server Error", { status: 500 });
    } finally {
      n6.prerendering && (n6.prerendering.inside_reroute = m8);
    }
  }
  try {
    y5 = P(y5);
  } catch {
    return text("Malformed URI", { status: 400 });
  }
  if (y5 !== s5.pathname && !n6.prerendering?.fallback && vt2(r5, y5)) {
    const m8 = new URL(e3.url);
    m8.pathname = o5 ? De(y5) : a5 ? Et2(y5) : y5;
    const g5 = await fetch(m8, e3), w5 = new Headers(g5.headers);
    return w5.has("content-encoding") && (w5.delete("content-encoding"), w5.delete("content-length")), new Response(g5.body, { headers: w5, status: g5.status, statusText: g5.statusText });
  }
  let $5 = null;
  if (e && !n6.prerendering?.fallback) {
    if (!y5.startsWith(e)) return text("Not found", { status: 404 });
    y5 = y5.slice(e.length) || "/";
  }
  if (a5) return Wr(y5, new URL(e3.url), r5);
  if (y5 === `/${i}/env.js`) return on2(e3);
  if (!i7 && y5.startsWith(`/${i}`)) {
    const m8 = new Headers();
    return m8.set("cache-control", "public, max-age=0, must-revalidate"), text("Not found", { status: 404, headers: m8 });
  }
  if (!n6.prerendering?.fallback) {
    const m8 = await r5._.matchers();
    for (const g5 of r5._.routes) {
      const w5 = g5.pattern.exec(y5);
      if (!w5) continue;
      const k5 = It2(w5, g5.params, m8);
      if (k5) {
        $5 = g5, _5.route = { id: $5.id }, _5.params = x(k5);
        break;
      }
    }
  }
  let j6 = { transformPageChunk: it2, filterSerializedResponseHeaders: ct2, preload: lt2 }, v5 = "never";
  try {
    const m8 = $5?.page ? new Ge2(await un2($5.page, r5)) : void 0;
    if ($5 && !i7) {
      if (s5.pathname === e || s5.pathname === e + "/" ? v5 = "always" : m8 ? v5 = m8.trailing_slash() : $5.endpoint && (v5 = (await $5.endpoint()).trailingSlash ?? "never"), !o5) {
        const w5 = $(s5.pathname, v5);
        if (w5 !== s5.pathname && !n6.prerendering?.fallback) return new Response(void 0, { status: 308, headers: { "x-sveltekit-normalize": "1", location: (w5.startsWith("//") ? s5.origin + w5 : w5) + (s5.search === "?" ? "" : s5.search) } });
      }
      if (n6.before_handle || n6.emulator?.platform) {
        let w5 = {}, k5 = false;
        if ($5.endpoint) {
          const E7 = await $5.endpoint();
          w5 = E7.config ?? w5, k5 = E7.prerender ?? k5;
        } else m8 && (w5 = m8.get_config() ?? w5, k5 = m8.prerender());
        n6.before_handle && n6.before_handle(_5, w5, k5), n6.emulator?.platform && (_5.platform = await n6.emulator.platform({ config: w5, prerender: k5 }));
      }
    }
    f8(v5), n6.prerendering && !n6.prerendering.fallback && !n6.prerendering.inside_reroute && j(s5);
    const g5 = await ee2({ name: "sveltekit.handle.root", attributes: { "http.route": _5.route.id || "unknown", "http.method": _5.request.method, "http.url": _5.url.href, "sveltekit.is_data_request": o5, "sveltekit.is_sub_request": _5.isSubRequest }, fn: async (w5) => {
      const k5 = { ..._5, tracing: { enabled: false, root: w5, current: w5 } };
      return await with_request_store({ event: k5, state: u8 }, () => t4.hooks.handle({ event: k5, resolve: (E7, R7) => ee2({ name: "sveltekit.resolve", attributes: { "http.route": E7.route.id || "unknown" }, fn: (T4) => with_request_store(null, () => x4(merge_tracing(E7, T4), m8, R7).then((P8) => {
        for (const M9 in d2) {
          const F5 = d2[M9];
          P8.headers.set(M9, F5);
        }
        return st2(P8.headers, h5.values()), n6.prerendering && E7.route.id !== null && P8.headers.set("x-sveltekit-routeid", encodeURI(E7.route.id)), T4.setAttributes({ "http.response.status_code": P8.status, "http.response.body.size": P8.headers.get("content-length") || "unknown" }), P8;
      })) }) }));
    } });
    if (g5.status === 200 && g5.headers.has("etag")) {
      let w5 = e3.headers.get("if-none-match");
      w5?.startsWith('W/"') && (w5 = w5.substring(2));
      const k5 = g5.headers.get("etag");
      if (w5 === k5) {
        const E7 = new Headers({ etag: k5 });
        for (const R7 of ["cache-control", "content-location", "date", "expires", "vary", "set-cookie"]) {
          const T4 = g5.headers.get(R7);
          T4 && E7.set(R7, T4);
        }
        return new Response(void 0, { status: 304, headers: E7 });
      }
    }
    if (o5 && g5.status >= 300 && g5.status <= 308) {
      const w5 = g5.headers.get("location");
      if (w5) return Ce(new Redirect(g5.status, w5));
    }
    return g5;
  } catch (m8) {
    if (m8 instanceof Redirect) {
      const g5 = o5 || i7 ? Ce(m8) : $5?.page && Rt2(_5) ? jt3(m8) : ge2(m8.status, m8.location);
      return st2(g5.headers, h5.values()), g5;
    }
    return await et2(_5, u8, t4, m8);
  }
  async function x4(m8, g5, w5) {
    try {
      if (w5 && (j6 = { transformPageChunk: w5.transformPageChunk || it2, filterSerializedResponseHeaders: w5.filterSerializedResponseHeaders || ct2, preload: w5.preload || lt2 }), t4.hash_routing || n6.prerendering?.fallback) return await ue2({ event: m8, event_state: u8, options: t4, manifest: r5, state: n6, page_config: { ssr: false, csr: true }, status: 200, error: null, branch: [], fetched: [], resolve_opts: j6, data_serializer: de2(m8, u8, t4) });
      if (i7) return await Gr(m8, u8, t4, r5, i7);
      if ($5) {
        const E7 = m8.request.method;
        let R7;
        if (o5) R7 = await en2(m8, u8, $5, t4, r5, n6, c7, v5);
        else if ($5.endpoint && (!$5.page || wr(m8))) R7 = await gr(m8, u8, await $5.endpoint(), n6);
        else if ($5.page) if (g5) if (cn2.has(E7)) R7 = await Qr(m8, u8, $5.page, t4, r5, n6, g5, j6);
        else {
          const T4 = new Set(ln2);
          if ((await r5._.nodes[$5.page.leaf]())?.server?.actions && T4.add("POST"), E7 === "OPTIONS") R7 = new Response(null, { status: 204, headers: { allow: Array.from(T4.values()).join(", ") } });
          else {
            const M9 = [...T4].reduce((F5, X4) => (F5[X4] = true, F5), {});
            R7 = wt2(M9, E7);
          }
        }
        else throw new Error("page_nodes not found. This should never happen");
        else throw new Error("Route is neither page nor endpoint. This should never happen");
        if (e3.method === "GET" && $5.page && $5.endpoint) {
          const T4 = R7.headers.get("vary")?.split(",")?.map((P8) => P8.trim().toLowerCase());
          T4?.includes("accept") || T4?.includes("*") || (R7 = new Response(R7.body, { status: R7.status, statusText: R7.statusText, headers: new Headers(R7.headers) }), R7.headers.append("Vary", "Accept"));
        }
        return R7;
      }
      if (n6.error && m8.isSubRequest) {
        const E7 = new Headers(e3.headers);
        return E7.set("x-sveltekit-error", "true"), await fetch(e3, { headers: E7 });
      }
      if (n6.error) return text("Internal Server Error", { status: 500 });
      if (n6.depth === 0) return s && m8.url.pathname, await Mt3({ event: m8, event_state: u8, options: t4, manifest: r5, state: n6, status: 404, error: new SvelteKitError(404, "Not Found", `Not found: ${m8.url.pathname}`), resolve_opts: j6 });
      if (n6.prerendering) return text("not found", { status: 404 });
      const k5 = await fetch(e3);
      return new Response(k5.body, k5);
    } catch (k5) {
      return await et2(m8, u8, t4, k5);
    } finally {
      m8.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      }, m8.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
}
function un2(e3, t4) {
  return Promise.all([...e3.layouts.map((r5) => r5 == null ? r5 : t4._.nodes[r5]()), t4._.nodes[e3.leaf]()]);
}
function fn2(e3) {
  return async (t4, ...r5) => e3(t4, ...r5);
}
function dt2(e3, t4, r5) {
  return Object.fromEntries(Object.entries(e3).filter(([n6]) => n6.startsWith(t4) && (r5 === "" || !n6.startsWith(r5))));
}
var pn2;
var ut2 = null;
var Sn = class {
  #e;
  #t;
  constructor(t4) {
    if (this.#e = Zt2, this.#t = t4, cr) {
      const r5 = this.respond.bind(this);
      this.respond = async (...n6) => {
        const { promise: s5, resolve: a5 } = ht2(), o5 = ut2;
        return ut2 = s5, await o5, r5(...n6).finally(a5);
      };
    }
  }
  async init({ env: t4, read: r5 }) {
    const { env_public_prefix: n6, env_private_prefix: s5 } = this.#e;
    Jt2(dt2(t4, s5, n6)), Kt2(dt2(t4, n6, s5)), r5 && Qt2((o5) => {
      const i7 = r5(o5);
      return i7 instanceof ReadableStream ? i7 : new ReadableStream({ async start(c7) {
        try {
          const d2 = await Promise.resolve(i7);
          if (!d2) {
            c7.close();
            return;
          }
          const l7 = d2.getReader();
          for (; ; ) {
            const { done: h5, value: b8 } = await l7.read();
            if (h5) break;
            c7.enqueue(b8);
          }
          c7.close();
        } catch (d2) {
          c7.error(d2);
        }
      } });
    }), await (pn2 ??= (async () => {
      try {
        const a5 = await $t2();
        this.#e.hooks = { handle: a5.handle || (({ event: o5, resolve: i7 }) => i7(o5)), handleError: a5.handleError || (({ status: o5, error: i7, event: c7 }) => {
          const d2 = yr(o5, i7, c7);
          console.error(d2);
        }), handleFetch: a5.handleFetch || (({ request: o5, fetch: i7 }) => i7(o5)), handleValidationError: a5.handleValidationError || (({ issues: o5 }) => (console.error("Remote function schema validation failed:", o5), { message: "Bad Request" })), reroute: a5.reroute || (() => {
        }), transport: a5.transport || {} }, a5.transport && Object.fromEntries(Object.entries(a5.transport).map(([o5, i7]) => [o5, i7.decode])), a5.init && await a5.init();
      } catch (a5) {
        throw a5;
      }
    })());
  }
  async respond(t4, r5) {
    return ze2(t4, this.#e, this.#t, { ...r5, error: false, depth: 0 });
  }
};

// .svelte-kit/cloudflare-tmp/manifest.js
var manifest = (() => {
  function __memo(fn4) {
    let value;
    return () => value ??= value = fn4();
  }
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["favicon.ico", "favicon.png", "icon-192.png", "icon-512.png", "manifest.json", "robots.txt", "sw.js"]),
    mimeTypes: { ".png": "image/png", ".json": "application/json", ".txt": "text/plain", ".js": "text/javascript" },
    _: {
      client: { start: "_app/immutable/entry/start.D3y6tNzc.js", app: "_app/immutable/entry/app.DJsW4nFv.js", imports: ["_app/immutable/entry/start.D3y6tNzc.js", "_app/immutable/chunks/DB88mmUq.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/DezgiKfJ.js", "_app/immutable/entry/app.DJsW4nFv.js", "_app/immutable/chunks/PPVm8Dsz.js", "_app/immutable/chunks/COy29HWL.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/ByhEiHbf.js", "_app/immutable/chunks/m2V9rbtF.js", "_app/immutable/chunks/nobbrJXm.js", "_app/immutable/chunks/DezgiKfJ.js"], stylesheets: [], fonts: [], uses_env_dynamic_public: false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5))),
        __memo(() => Promise.resolve().then(() => (init__6(), __exports6))),
        __memo(() => Promise.resolve().then(() => (init__7(), __exports7))),
        __memo(() => Promise.resolve().then(() => (init__8(), __exports8))),
        __memo(() => Promise.resolve().then(() => (init__9(), __exports9))),
        __memo(() => Promise.resolve().then(() => (init__10(), __exports10))),
        __memo(() => Promise.resolve().then(() => (init__11(), __exports11))),
        __memo(() => Promise.resolve().then(() => (init__12(), __exports12)))
      ],
      remotes: {},
      routes: [
        {
          id: "/",
          pattern: /^\/$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 2 },
          endpoint: null
        },
        {
          id: "/admin",
          pattern: /^\/admin\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 3 },
          endpoint: null
        },
        {
          id: "/annotate",
          pattern: /^\/annotate\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 4 },
          endpoint: null
        },
        {
          id: "/api/admin/labels",
          pattern: /^\/api\/admin\/labels\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts(), server_ts_exports)))
        },
        {
          id: "/api/admin/labels/[id]",
          pattern: /^\/api\/admin\/labels\/([^/]+?)\/?$/,
          params: [{ "name": "id", "optional": false, "rest": false, "chained": false }],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts2(), server_ts_exports2)))
        },
        {
          id: "/api/admin/maps",
          pattern: /^\/api\/admin\/maps\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts3(), server_ts_exports3)))
        },
        {
          id: "/api/admin/maps/[id]",
          pattern: /^\/api\/admin\/maps\/([^/]+?)\/?$/,
          params: [{ "name": "id", "optional": false, "rest": false, "chained": false }],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts4(), server_ts_exports4)))
        },
        {
          id: "/api/admin/maps/[id]/image",
          pattern: /^\/api\/admin\/maps\/([^/]+?)\/image\/?$/,
          params: [{ "name": "id", "optional": false, "rest": false, "chained": false }],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts5(), server_ts_exports5)))
        },
        {
          id: "/auth/callback",
          pattern: /^\/auth\/callback\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts6(), server_ts_exports6)))
        },
        {
          id: "/catalog",
          pattern: /^\/catalog\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 5 },
          endpoint: null
        },
        {
          id: "/contribute/georef",
          pattern: /^\/contribute\/georef\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 6 },
          endpoint: null
        },
        {
          id: "/contribute/label",
          pattern: /^\/contribute\/label\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 7 },
          endpoint: null
        },
        {
          id: "/create",
          pattern: /^\/create\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 8 },
          endpoint: null
        },
        {
          id: "/login",
          pattern: /^\/login\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 9 },
          endpoint: null
        },
        {
          id: "/signup",
          pattern: /^\/signup\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 10 },
          endpoint: null
        },
        {
          id: "/view",
          pattern: /^\/view\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 11 },
          endpoint: null
        }
      ],
      prerendered_routes: /* @__PURE__ */ new Set([]),
      matchers: async () => {
        return {};
      },
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var base_path = "";

// .svelte-kit/cloudflare-tmp/_worker.js
async function e2(e3, t22) {
  let n22 = "string" != typeof t22 && "HEAD" === t22.method;
  n22 && (t22 = new Request(t22, { method: "GET" }));
  let r32 = await e3.match(t22);
  return n22 && r32 && (r32 = new Response(null, r32)), r32;
}
function t3(e3, t22, n22, o22) {
  return ("string" == typeof t22 || "GET" === t22.method) && r4(n22) && (n22.headers.has("Set-Cookie") && (n22 = new Response(n22.body, n22)).headers.append("Cache-Control", "private=Set-Cookie"), o22.waitUntil(e3.put(t22, n22.clone()))), n22;
}
var n5 = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r4(e3) {
  if (!n5.has(e3.status)) return false;
  if (~(e3.headers.get("Vary") || "").indexOf("*")) return false;
  let t22 = e3.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t22);
}
function o4(n22) {
  return async function(r32, o22) {
    let a5 = await e2(n22, r32);
    if (a5) return a5;
    o22.defer((e3) => {
      t3(n22, r32, e3, o22);
    });
  };
}
var s4 = caches.default;
var c6 = t3.bind(0, s4);
var r22 = e2.bind(0, s4);
var e22 = o4.bind(0, s4);
var server = new Sn(manifest);
var app_path = `/${manifest.appPath}`;
var immutable = `${app_path}/immutable/`;
var version_file = `${app_path}/version.json`;
var worker = {
  async fetch(req, env, context) {
    await server.init({ env });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r22(req);
    if (res) return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.slice(base_path.length + 1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
    }
    let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env.ASSETS.fetch(req);
    } else if (location && prerendered.has(location)) {
      if (search) location += search;
      res = new Response("", {
        status: 308,
        headers: {
          location
        }
      });
    } else {
      res = await server.respond(req, {
        // @ts-ignore
        platform: { env, context, caches, cf: req.cf },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c6(req, res, context) : res;
  }
};
var worker_default = worker;
export {
  worker_default as default
};
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=_worker.js.map
