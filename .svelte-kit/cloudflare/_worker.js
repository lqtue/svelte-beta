var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// .svelte-kit/output/server/chunks/false.js
var BROWSER;
var init_false = __esm({
  ".svelte-kit/output/server/chunks/false.js"() {
    BROWSER = false;
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/remote-functions.js
var init_remote_functions = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/remote-functions.js"() {
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/index.js
var HttpError, Redirect, SvelteKitError, ActionFailure;
var init_internal = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/index.js"() {
    init_remote_functions();
    HttpError = class {
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body2) {
        this.status = status;
        if (typeof body2 === "string") {
          this.body = { message: body2 };
        } else if (body2) {
          this.body = body2;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location) {
        this.status = status;
        this.location = location;
      }
    };
    SvelteKitError = class extends Error {
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text2, message) {
        super(message);
        this.status = status;
        this.text = text2;
      }
    };
    ActionFailure = class {
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
  }
});

// node_modules/@sveltejs/kit/src/runtime/server/constants.js
var IN_WEBCONTAINER;
var init_constants = __esm({
  "node_modules/@sveltejs/kit/src/runtime/server/constants.js"() {
    IN_WEBCONTAINER = !!globalThis.process?.versions?.webcontainer;
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/event.js
function with_request_store(store, fn) {
  try {
    sync_store = store;
    return als ? als.run(store, fn) : fn();
  } finally {
    if (!IN_WEBCONTAINER) {
      sync_store = null;
    }
  }
}
var sync_store, als;
var init_event = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/event.js"() {
    init_constants();
    sync_store = null;
    import("node:async_hooks").then((hooks) => als = new hooks.AsyncLocalStorage()).catch(() => {
    });
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/server.js
function merge_tracing(event_like, current3) {
  return {
    ...event_like,
    tracing: {
      ...event_like.tracing,
      current: current3
    }
  };
}
var init_server = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/server.js"() {
    init_event();
  }
});

// .svelte-kit/output/server/chunks/exports.js
function resolve(base2, path) {
  if (path[0] === "/" && path[1] === "/") return path;
  let url = new URL(base2, internal);
  url = new URL(path, url);
  return url.protocol === internal.protocol ? url.pathname + url.search + url.hash : url.href;
}
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore") return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params2) {
  for (const key2 in params2) {
    params2[key2] = decodeURIComponent(params2[key2]);
  }
  return params2;
}
function make_trackable(url, callback, search_params_callback, allow_hash = false) {
  const tracked = new URL(url);
  Object.defineProperty(tracked, "searchParams", {
    value: new Proxy(tracked.searchParams, {
      get(obj, key2) {
        if (key2 === "get" || key2 === "getAll" || key2 === "has") {
          return (param) => {
            search_params_callback(param);
            return obj[key2](param);
          };
        }
        callback();
        const value = Reflect.get(obj, key2);
        return typeof value === "function" ? value.bind(obj) : value;
      }
    }),
    enumerable: true,
    configurable: true
  });
  const tracked_url_properties = ["href", "pathname", "search", "toString", "toJSON"];
  if (allow_hash) tracked_url_properties.push("hash");
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url, opts);
    };
    tracked.searchParams[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url.searchParams, opts);
    };
  }
  if (!allow_hash) {
    disable_hash(tracked);
  }
  return tracked;
}
function disable_hash(url) {
  allow_nodejs_console_log(url);
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `page.url.hash` inside a component instead"
      );
    }
  });
}
function disable_search(url) {
  allow_nodejs_console_log(url);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
function allow_nodejs_console_log(url) {
  {
    url[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(new URL(url), opts);
    };
  }
}
function validator(expected) {
  function validate(module, file) {
    if (!module) return;
    for (const key2 in module) {
      if (key2[0] === "_" || expected.has(key2)) continue;
      const values = [...expected.values()];
      const hint = hint_for_supported_files(key2, file?.slice(file.lastIndexOf("."))) ?? `valid exports are ${values.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key2}'${file ? ` in ${file}` : ""} (${hint})`);
    }
  }
  return validate;
}
function hint_for_supported_files(key2, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key2)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key2)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key2)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key2)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key2)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key2}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
var internal, valid_layout_exports, valid_page_exports, valid_layout_server_exports, valid_page_server_exports, valid_server_exports, validate_layout_exports, validate_page_exports, validate_layout_server_exports, validate_page_server_exports, validate_server_exports;
var init_exports = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    internal = new URL("sveltekit-internal://");
    valid_layout_exports = /* @__PURE__ */ new Set([
      "load",
      "prerender",
      "csr",
      "ssr",
      "trailingSlash",
      "config"
    ]);
    valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
    valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
    valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
    valid_server_exports = /* @__PURE__ */ new Set([
      "GET",
      "POST",
      "PATCH",
      "PUT",
      "DELETE",
      "OPTIONS",
      "HEAD",
      "fallback",
      "prerender",
      "trailingSlash",
      "config",
      "entries"
    ]);
    validate_layout_exports = validator(valid_layout_exports);
    validate_page_exports = validator(valid_page_exports);
    validate_layout_server_exports = validator(valid_layout_server_exports);
    validate_page_server_exports = validator(valid_page_server_exports);
    validate_server_exports = validator(valid_server_exports);
  }
});

// .svelte-kit/output/server/chunks/utils.js
function get_relative_path(from, to) {
  const from_parts = from.split(/[/\\]/);
  const to_parts = to.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  let i = from_parts.length;
  while (i--) from_parts[i] = "..";
  return from_parts.concat(to_parts).join("/");
}
function base64_encode(bytes) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(bytes).toString("base64");
  }
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function base64_decode(encoded) {
  if (globalThis.Buffer) {
    const buffer = globalThis.Buffer.from(encoded, "base64");
    return new Uint8Array(buffer);
  }
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
var text_encoder2, text_decoder2;
var init_utils = __esm({
  ".svelte-kit/output/server/chunks/utils.js"() {
    text_encoder2 = new TextEncoder();
    text_decoder2 = new TextDecoder();
  }
});

// node_modules/clsx/dist/clsx.mjs
function r(e3) {
  var t2, f, n2 = "";
  if ("string" == typeof e3 || "number" == typeof e3) n2 += e3;
  else if ("object" == typeof e3) if (Array.isArray(e3)) {
    var o2 = e3.length;
    for (t2 = 0; t2 < o2; t2++) e3[t2] && (f = r(e3[t2])) && (n2 && (n2 += " "), n2 += f);
  } else for (f in e3) e3[f] && (n2 && (n2 += " "), n2 += f);
  return n2;
}
function clsx() {
  for (var e3, t2, f = 0, n2 = "", o2 = arguments.length; f < o2; f++) (e3 = arguments[f]) && (t2 = r(e3)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var init_clsx = __esm({
  "node_modules/clsx/dist/clsx.mjs"() {
  }
});

// .svelte-kit/output/server/chunks/context.js
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
function deferred() {
  var resolve2;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve2 = res;
    reject = rej;
  });
  return { promise, resolve: resolve2, reject };
}
function fallback(value, fallback2, lazy = false) {
  return value === void 0 ? lazy ? (
    /** @type {() => V} */
    fallback2()
  ) : (
    /** @type {V} */
    fallback2
  ) : value;
}
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
function lifecycle_outside_component(name) {
  {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
function effect_update_depth_exceeded() {
  {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function hydration_failed() {
  {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function state_descriptors_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}
function set_component_context(context2) {
  component_context = context2;
}
function push$1(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: null
  };
}
function pop$1(component8) {
  var context2 = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context2.e;
  if (effects !== null) {
    context2.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  context2.i = true;
  component_context = context2.p;
  return (
    /** @type {T} */
    {}
  );
}
function is_runes() {
  return true;
}
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}
function handle_error(error2) {
  var effect = active_effect;
  if (effect === null) {
    active_reaction.f |= ERROR_VALUE;
    return error2;
  }
  if ((effect.f & EFFECT_RAN) === 0) {
    if ((effect.f & BOUNDARY_EFFECT) === 0) {
      throw error2;
    }
    effect.b.error(error2);
  } else {
    invoke_error_boundary(error2, effect);
  }
}
function invoke_error_boundary(error2, effect) {
  while (effect !== null) {
    if ((effect.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect.b.error(error2);
        return;
      } catch (e3) {
        error2 = e3;
      }
    }
    effect = effect.parent;
  }
  throw error2;
}
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) ;
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        var updates, entry;
        if (BROWSER) ;
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error2) {
    invoke_error_boundary(error2, last_scheduled_effect);
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i = 0;
  while (i < length) {
    var effect = effects[i++];
    if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
      eager_block_effects = /* @__PURE__ */ new Set();
      update_effect(effect);
      if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
        if (effect.teardown === null && effect.ac === null) {
          unlink_effect(effect);
        } else {
          effect.fn = null;
        }
      }
      if (eager_block_effects?.size > 0) {
        old_values.clear();
        for (const e3 of eager_block_effects) {
          if ((e3.f & (DESTROYED | INERT)) !== 0) continue;
          const ordered_effects = [e3];
          let ancestor = e3.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j = ordered_effects.length - 1; j >= 0; j--) {
            const e22 = ordered_effects[j];
            if ((e22.f & (DESTROYED | INERT)) !== 0) continue;
            update_effect(e22);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
function mark_effects(value, sources, marked, checked) {
  if (marked.has(value)) return;
  marked.add(value);
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources,
          marked,
          checked
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags2 & DIRTY) === 0 && // we may have scheduled this one already
      depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (depends !== void 0) return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources,
        checked
      )) {
        checked.set(
          /** @type {Derived} */
          dep,
          true
        );
        return true;
      }
    }
  }
  checked.set(reaction, false);
  return false;
}
function schedule_effect(signal) {
  var effect = last_scheduled_effect = signal;
  while (effect.parent !== null) {
    effect = effect.parent;
    var flags2 = effect.f;
    if (is_flushing && effect === active_effect && (flags2 & BLOCK_EFFECT) !== 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect);
}
function destroy_derived_effects(derived2) {
  var effects = derived2.effects;
  if (effects !== null) {
    derived2.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
function get_derived_parent_effect(derived2) {
  var parent = derived2.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (
        /** @type {Effect} */
        parent
      );
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived2) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived2));
  {
    try {
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived2) {
  var value = execute_derived(derived2);
  if (!derived2.equals(value)) {
    derived2.v = value;
    derived2.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    batch_values.set(derived2, derived2.v);
  } else {
    var status = (skip_reaction || (derived2.f & UNOWNED) !== 0) && derived2.deps !== null ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
  }
}
function source(v2, stack) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: v2,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v2, stack) {
  const s3 = source(v2);
  push_reaction_value(s3);
  return s3;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable2 = false, trackable = true) {
  const s3 = source(initial_value);
  if (!immutable2) {
    s3.equals = safe_equals;
  }
  return s3;
}
function set(source2, value, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value;
}
function flush_eager_effects() {
  eager_effects_deferred = false;
  const inspects = Array.from(eager_effects);
  for (const effect of inspects) {
    if ((effect.f & CLEAN) !== 0) {
      set_signal_status(effect, MAYBE_DIRTY);
    }
    if (is_dirty(effect)) {
      update_effect(effect);
    }
  }
  eager_effects.clear();
}
function increment(source2) {
  set(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      if ((flags2 & WAS_MARKED) === 0) {
        reaction.f |= WAS_MARKED;
        mark_reactions(
          /** @type {Derived} */
          reaction,
          MAYBE_DIRTY
        );
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0) {
        if (eager_block_effects !== null) {
          eager_block_effects.add(
            /** @type {Effect} */
            reaction
          );
        }
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version = /* @__PURE__ */ state(0);
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", /* @__PURE__ */ state(
      /** @type {any[]} */
      value.length
    ));
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s3 = sources.get(prop);
        if (s3 === void 0) {
          s3 = with_parent(() => {
            var s22 = /* @__PURE__ */ state(descriptor.value);
            sources.set(prop, s22);
            return s22;
          });
        } else {
          set(s3, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop) {
        var s3 = sources.get(prop);
        if (s3 === void 0) {
          if (prop in target) {
            const s22 = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED));
            sources.set(prop, s22);
            increment(version);
          }
        } else {
          set(s3, UNINITIALIZED);
          increment(version);
        }
        return true;
      },
      get(target, prop, receiver) {
        if (prop === STATE_SYMBOL) {
          return value;
        }
        var s3 = sources.get(prop);
        var exists = prop in target;
        if (s3 === void 0 && (!exists || get_descriptor(target, prop)?.writable)) {
          s3 = with_parent(() => {
            var p = proxy(exists ? target[prop] : UNINITIALIZED);
            var s22 = /* @__PURE__ */ state(p);
            return s22;
          });
          sources.set(prop, s3);
        }
        if (s3 !== void 0) {
          var v2 = get(s3);
          return v2 === UNINITIALIZED ? void 0 : v2;
        }
        return Reflect.get(target, prop, receiver);
      },
      getOwnPropertyDescriptor(target, prop) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
        if (descriptor && "value" in descriptor) {
          var s3 = sources.get(prop);
          if (s3) descriptor.value = get(s3);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop) {
        if (prop === STATE_SYMBOL) {
          return true;
        }
        var s3 = sources.get(prop);
        var has = s3 !== void 0 && s3.v !== UNINITIALIZED || Reflect.has(target, prop);
        if (s3 !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop)?.writable)) {
          if (s3 === void 0) {
            s3 = with_parent(() => {
              var p = has ? proxy(target[prop]) : UNINITIALIZED;
              var s22 = /* @__PURE__ */ state(p);
              return s22;
            });
            sources.set(prop, s3);
          }
          var value2 = get(s3);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop, value2, receiver) {
        var s3 = sources.get(prop);
        var has = prop in target;
        if (is_proxied_array && prop === "length") {
          for (var i = value2; i < /** @type {Source<number>} */
          s3.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED));
              sources.set(i + "", other_s);
            }
          }
        }
        if (s3 === void 0) {
          if (!has || get_descriptor(target, prop)?.writable) {
            s3 = with_parent(() => /* @__PURE__ */ state(void 0));
            set(s3, proxy(value2));
            sources.set(prop, s3);
          }
        } else {
          has = s3.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value2));
          set(s3, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n2 = Number(prop);
            if (Number.isInteger(n2) && n2 >= ls.v) {
              set(ls, n2 + 1);
            }
          }
          increment(version);
        }
        return true;
      },
      ownKeys(target) {
        get(version);
        var own_keys = Reflect.ownKeys(target).filter((key22) => {
          var source3 = sources.get(key22);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
function clear_text_content(node) {
  node.textContent = "";
}
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function push_effect(effect, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect;
  } else {
    parent_last.next = effect;
    effect.prev = parent_last;
    parent_effect.last = effect;
  }
}
function create_effect(type, fn, sync, push2 = true) {
  var parent = active_effect;
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (sync) {
    try {
      update_effect(effect);
      effect.f |= EFFECT_RAN;
    } catch (e22) {
      destroy_effect(effect);
      throw e22;
    }
  } else if (fn !== null) {
    schedule_effect(effect);
  }
  if (push2) {
    var e3 = effect;
    if (sync && e3.deps === null && e3.teardown === null && e3.nodes_start === null && e3.first === e3.last && // either `null`, or a singular child
    (e3.f & EFFECT_PRESERVED) === 0) {
      e3 = e3.first;
      if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e3 !== null) {
        e3.f |= EFFECT_TRANSPARENT;
      }
    }
    if (e3 !== null) {
      e3.parent = parent;
      if (parent !== null) {
        push_effect(e3, parent);
      }
      if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
        var derived2 = (
          /** @type {Derived} */
          active_reaction
        );
        (derived2.effects ??= []).push(e3);
      }
    }
  }
  return effect;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function component_root(fn) {
  Batch.ensure();
  const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options2 = {}) => {
    return new Promise((fulfil) => {
      if (options2.outro) {
        pause_effect(effect, () => {
          destroy_effect(effect);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect);
        fulfil(void 0);
      }
    });
  };
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function block(fn, flags2 = 0) {
  var effect = create_effect(BLOCK_EFFECT | flags2, fn, true);
  return effect;
}
function branch(fn, push2 = true) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push2);
}
function execute_effect_teardown(effect) {
  var teardown = effect.teardown;
  if (teardown !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect = signal.first;
  signal.first = signal.last = null;
  while (effect !== null) {
    const controller2 = effect.ac;
    if (controller2 !== null) {
      without_reactive_context(() => {
        controller2.abort(STALE_REACTION);
      });
    }
    var next2 = effect.next;
    if ((effect.f & ROOT_EFFECT) !== 0) {
      effect.parent = null;
    } else {
      destroy_effect(effect, remove_dom);
    }
    effect = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect = signal.first;
  while (effect !== null) {
    var next2 = effect.next;
    if ((effect.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect);
    }
    effect = next2;
  }
}
function destroy_effect(effect, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null && effect.nodes_end !== null) {
    remove_effect_dom(
      effect.nodes_start,
      /** @type {TemplateNode} */
      effect.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect, remove_dom && !removed);
  remove_reactions(effect, 0);
  set_signal_status(effect, DESTROYED);
  var transitions = effect.transitions;
  if (transitions !== null) {
    for (const transition of transitions) {
      transition.stop();
    }
  }
  execute_effect_teardown(effect);
  var parent = effect.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect);
  }
  effect.next = effect.prev = effect.teardown = effect.ctx = effect.deps = effect.fn = effect.nodes_start = effect.nodes_end = effect.ac = null;
}
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect) {
  var parent = effect.parent;
  var prev = effect.prev;
  var next2 = effect.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect) parent.first = next2;
    if (parent.last === effect) parent.last = prev;
  }
}
function pause_effect(effect, callback, destroy = true) {
  var transitions = [];
  pause_children(effect, transitions, true);
  run_out_transitions(transitions, () => {
    if (destroy) destroy_effect(effect);
    if (callback) callback();
  });
}
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition of transitions) {
      transition.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect, transitions, local) {
  if ((effect.f & INERT) !== 0) return;
  effect.f ^= INERT;
  if (effect.transitions !== null) {
    for (const transition of effect.transitions) {
      if (transition.is_global || local) {
        transitions.push(transition);
      }
    }
  }
  var child = effect.first;
  while (child !== null) {
    var sibling = child.next;
    var transparent2 = (child.f & EFFECT_TRANSPARENT) !== 0 || // If this is a branch effect without a block effect parent,
    // it means the parent block effect was pruned. In that case,
    // transparency information was transferred to the branch effect.
    (child.f & BRANCH_EFFECT) !== 0 && (effect.f & BLOCK_EFFECT) !== 0;
    pause_children(child, transitions, transparent2 ? local : false);
    child = sibling;
  }
}
function move_effect(effect, fragment) {
  var node = effect.nodes_start;
  var end = effect.nodes_end;
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    fragment.append(node);
    node = next2;
  }
}
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
function set_active_effect(effect) {
  active_effect = effect;
}
function push_reaction_value(value) {
  if (active_reaction !== null && true) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
function set_untracked_writes(value) {
  untracked_writes = value;
}
function set_update_version(value) {
  update_version = value;
}
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    var is_unowned = (flags2 & UNOWNED) !== 0;
    if (flags2 & DERIVED) {
      reaction.f &= ~WAS_MARKED;
    }
    if (dependencies !== null) {
      var i;
      var dependency;
      var is_disconnected = (flags2 & DISCONNECTED) !== 0;
      var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
      var length = dependencies.length;
      if ((is_disconnected || is_unowned_connected) && (active_effect === null || (active_effect.f & DESTROYED) === 0)) {
        var derived2 = (
          /** @type {Derived} */
          reaction
        );
        var parent = derived2.parent;
        for (i = 0; i < length; i++) {
          dependency = dependencies[i];
          if (is_disconnected || !dependency?.reactions?.includes(derived2)) {
            (dependency.reactions ??= []).push(derived2);
          }
        }
        if (is_disconnected) {
          derived2.f ^= DISCONNECTED;
        }
        if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
          derived2.f ^= UNOWNED;
        }
      }
      for (i = 0; i < length; i++) {
        dependency = dependencies[i];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if (!is_unowned || active_effect !== null && !skip_reaction) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect, root2 = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (current_sources?.includes(signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect,
        false
      );
    } else if (effect === reaction) {
      if (root2) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_skip_reaction = skip_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  skip_reaction = (flags2 & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (!skip_reaction || // Deriveds that already have reactions can cleanup, so we still add them as reactions
      (flags2 & DERIVED) !== 0 && /** @type {import('#client').Derived} */
      reaction.reactions !== null) {
        for (i = skipped_deps; i < deps.length; i++) {
          (deps[i].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error2) {
    return handle_error(error2);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    skip_reaction = previous_skip_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index8 = index_of.call(reactions, signal);
    if (index8 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index8] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
function update_effect(effect) {
  var flags2 = effect.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect;
  is_updating_effect = true;
  try {
    if ((flags2 & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect);
    } else {
      destroy_effect_children(effect);
    }
    execute_effect_teardown(effect);
    var teardown = update_reaction(effect);
    effect.teardown = typeof teardown === "function" ? teardown : null;
    effect.wv = write_version;
    var dep;
    if (BROWSER && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) ;
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
  }
}
function get(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!skip_reaction || !new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ??= []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  } else if (is_derived && /** @type {Derived} */
  signal.deps === null && /** @type {Derived} */
  signal.effects === null) {
    var derived2 = (
      /** @type {Derived} */
      signal
    );
    var parent = derived2.parent;
    if (parent !== null && (parent.f & UNOWNED) === 0) {
      derived2.f ^= UNOWNED;
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      derived2 = /** @type {Derived} */
      signal;
      var value = derived2.v;
      if ((derived2.f & CLEAN) === 0 && derived2.reactions !== null || depends_on_old_values(derived2)) {
        value = execute_derived(derived2);
      }
      old_values.set(derived2, value);
      return value;
    }
  } else if (is_derived) {
    derived2 = /** @type {Derived} */
    signal;
    if (batch_values?.has(derived2)) {
      return batch_values.get(derived2);
    }
    if (is_dirty(derived2)) {
      update_derived(derived2);
    }
  }
  if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function depends_on_old_values(derived2) {
  if (derived2.v === UNINITIALIZED) return true;
  if (derived2.deps === null) return false;
  for (const dep of derived2.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last = 0;
  while (pattern2.test(str)) {
    const i = pattern2.lastIndex - 1;
    const ch = str[i];
    escaped2 += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped2 + str.substring(last);
}
function subscribe_to_store(store, run, invalidate) {
  if (store == null) {
    run(void 0);
    if (invalidate) invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store.subscribe(
      run,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function set_ssr_context(v2) {
  ssr_context = v2;
}
function getContext(key2) {
  const context_map = get_or_init_context_map();
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
function setContext(key2, context2) {
  get_or_init_context_map().set(key2, context2);
  return context2;
}
function get_or_init_context_map(name) {
  if (ssr_context === null) {
    lifecycle_outside_component();
  }
  return ssr_context.c ??= new Map(get_parent_context(ssr_context) || void 0);
}
function push(fn) {
  ssr_context = { p: ssr_context, c: null, r: null };
}
function pop() {
  ssr_context = /** @type {SSRContext} */
  ssr_context.p;
}
function get_parent_context(ssr_context2) {
  let parent = ssr_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
var is_array, index_of, array_from, define_property, get_descriptor, object_prototype, array_prototype, get_prototype_of, is_extensible, noop, DERIVED, EFFECT, RENDER_EFFECT, BLOCK_EFFECT, BRANCH_EFFECT, ROOT_EFFECT, BOUNDARY_EFFECT, CLEAN, DIRTY, MAYBE_DIRTY, INERT, DESTROYED, EFFECT_RAN, EFFECT_TRANSPARENT, EAGER_EFFECT, HEAD_EFFECT, EFFECT_PRESERVED, USER_EFFECT, UNOWNED, DISCONNECTED, WAS_MARKED, REACTION_IS_UPDATING, ASYNC, ERROR_VALUE, STATE_SYMBOL, LEGACY_PROPS, STALE_REACTION, COMMENT_NODE, HYDRATION_START, HYDRATION_START_ELSE, HYDRATION_END, HYDRATION_ERROR, ELEMENT_IS_NAMESPACED, ELEMENT_PRESERVE_ATTRIBUTE_CASE, ELEMENT_IS_INPUT, UNINITIALIZED, tracing_mode_flag, component_context, micro_tasks, batches, current_batch, batch_values, effect_pending_updates, queued_root_effects, last_scheduled_effect, is_flushing, is_flushing_sync, Batch, eager_block_effects, eager_effects, old_values, eager_effects_deferred, $window, first_child_getter, next_sibling_getter, is_updating_effect, is_destroying_effect, active_reaction, untracking, active_effect, current_sources, new_deps, skipped_deps, untracked_writes, write_version, read_version, update_version, skip_reaction, STATUS_MASK, ATTR_REGEX, CONTENT_REGEX, ssr_context;
var init_context = __esm({
  ".svelte-kit/output/server/chunks/context.js"() {
    init_false();
    init_clsx();
    is_array = Array.isArray;
    index_of = Array.prototype.indexOf;
    array_from = Array.from;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    object_prototype = Object.prototype;
    array_prototype = Array.prototype;
    get_prototype_of = Object.getPrototypeOf;
    is_extensible = Object.isExtensible;
    noop = () => {
    };
    DERIVED = 1 << 1;
    EFFECT = 1 << 2;
    RENDER_EFFECT = 1 << 3;
    BLOCK_EFFECT = 1 << 4;
    BRANCH_EFFECT = 1 << 5;
    ROOT_EFFECT = 1 << 6;
    BOUNDARY_EFFECT = 1 << 7;
    CLEAN = 1 << 10;
    DIRTY = 1 << 11;
    MAYBE_DIRTY = 1 << 12;
    INERT = 1 << 13;
    DESTROYED = 1 << 14;
    EFFECT_RAN = 1 << 15;
    EFFECT_TRANSPARENT = 1 << 16;
    EAGER_EFFECT = 1 << 17;
    HEAD_EFFECT = 1 << 18;
    EFFECT_PRESERVED = 1 << 19;
    USER_EFFECT = 1 << 20;
    UNOWNED = 1 << 8;
    DISCONNECTED = 1 << 9;
    WAS_MARKED = 1 << 15;
    REACTION_IS_UPDATING = 1 << 21;
    ASYNC = 1 << 22;
    ERROR_VALUE = 1 << 23;
    STATE_SYMBOL = Symbol("$state");
    LEGACY_PROPS = Symbol("legacy props");
    STALE_REACTION = new class StaleReactionError extends Error {
      name = "StaleReactionError";
      message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
    }();
    COMMENT_NODE = 8;
    HYDRATION_START = "[";
    HYDRATION_START_ELSE = "[!";
    HYDRATION_END = "]";
    HYDRATION_ERROR = {};
    ELEMENT_IS_NAMESPACED = 1;
    ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
    ELEMENT_IS_INPUT = 1 << 2;
    UNINITIALIZED = Symbol();
    tracing_mode_flag = false;
    component_context = null;
    micro_tasks = [];
    batches = /* @__PURE__ */ new Set();
    current_batch = null;
    batch_values = null;
    effect_pending_updates = /* @__PURE__ */ new Set();
    queued_root_effects = [];
    last_scheduled_effect = null;
    is_flushing = false;
    is_flushing_sync = false;
    Batch = class _Batch {
      committed = false;
      /**
       * The current values of any sources that are updated in this batch
       * They keys of this map are identical to `this.#previous`
       * @type {Map<Source, any>}
       */
      current = /* @__PURE__ */ new Map();
      /**
       * The values of any sources that are updated in this batch _before_ those updates took place.
       * They keys of this map are identical to `this.#current`
       * @type {Map<Source, any>}
       */
      previous = /* @__PURE__ */ new Map();
      /**
       * When the batch is committed (and the DOM is updated), we need to remove old branches
       * and append new ones by calling the functions added inside (if/each/key/etc) blocks
       * @type {Set<() => void>}
       */
      #commit_callbacks = /* @__PURE__ */ new Set();
      /**
       * If a fork is discarded, we need to destroy any effects that are no longer needed
       * @type {Set<(batch: Batch) => void>}
       */
      #discard_callbacks = /* @__PURE__ */ new Set();
      /**
       * The number of async effects that are currently in flight
       */
      #pending = 0;
      /**
       * The number of async effects that are currently in flight, _not_ inside a pending boundary
       */
      #blocking_pending = 0;
      /**
       * A deferred that resolves when the batch is committed, used with `settled()`
       * TODO replace with Promise.withResolvers once supported widely enough
       * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
       */
      #deferred = null;
      /**
       * Deferred effects (which run after async work has completed) that are DIRTY
       * @type {Effect[]}
       */
      #dirty_effects = [];
      /**
       * Deferred effects that are MAYBE_DIRTY
       * @type {Effect[]}
       */
      #maybe_dirty_effects = [];
      /**
       * A set of branches that still exist, but will be destroyed when this batch
       * is committed  we skip over these during `process`
       * @type {Set<Effect>}
       */
      skipped_effects = /* @__PURE__ */ new Set();
      is_fork = false;
      /**
       *
       * @param {Effect[]} root_effects
       */
      process(root_effects) {
        queued_root_effects = [];
        this.apply();
        var target = {
          parent: null,
          effect: null,
          effects: [],
          render_effects: [],
          block_effects: []
        };
        for (const root2 of root_effects) {
          this.#traverse_effect_tree(root2, target);
        }
        if (!this.is_fork) {
          this.#resolve();
        }
        if (this.#blocking_pending > 0 || this.is_fork) {
          this.#defer_effects(target.effects);
          this.#defer_effects(target.render_effects);
          this.#defer_effects(target.block_effects);
        } else {
          current_batch = null;
          flush_queued_effects(target.render_effects);
          flush_queued_effects(target.effects);
        }
        batch_values = null;
      }
      /**
       * Traverse the effect tree, executing effects or stashing
       * them for later execution as appropriate
       * @param {Effect} root
       * @param {EffectTarget} target
       */
      #traverse_effect_tree(root2, target) {
        root2.f ^= CLEAN;
        var effect = root2.first;
        while (effect !== null) {
          var flags2 = effect.f;
          var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
          var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
          var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect);
          if ((effect.f & BOUNDARY_EFFECT) !== 0 && effect.b?.is_pending()) {
            target = {
              parent: target,
              effect,
              effects: [],
              render_effects: [],
              block_effects: []
            };
          }
          if (!skip && effect.fn !== null) {
            if (is_branch) {
              effect.f ^= CLEAN;
            } else if ((flags2 & EFFECT) !== 0) {
              target.effects.push(effect);
            } else if (is_dirty(effect)) {
              if ((effect.f & BLOCK_EFFECT) !== 0) target.block_effects.push(effect);
              update_effect(effect);
            }
            var child = effect.first;
            if (child !== null) {
              effect = child;
              continue;
            }
          }
          var parent = effect.parent;
          effect = effect.next;
          while (effect === null && parent !== null) {
            if (parent === target.effect) {
              this.#defer_effects(target.effects);
              this.#defer_effects(target.render_effects);
              this.#defer_effects(target.block_effects);
              target = /** @type {EffectTarget} */
              target.parent;
            }
            effect = parent.next;
            parent = parent.parent;
          }
        }
      }
      /**
       * @param {Effect[]} effects
       */
      #defer_effects(effects) {
        for (const e3 of effects) {
          const target = (e3.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
          target.push(e3);
          set_signal_status(e3, CLEAN);
        }
      }
      /**
       * Associate a change to a given source with the current
       * batch, noting its previous and current values
       * @param {Source} source
       * @param {any} value
       */
      capture(source2, value) {
        if (!this.previous.has(source2)) {
          this.previous.set(source2, value);
        }
        this.current.set(source2, source2.v);
        batch_values?.set(source2, source2.v);
      }
      activate() {
        current_batch = this;
      }
      deactivate() {
        current_batch = null;
        batch_values = null;
      }
      flush() {
        this.activate();
        if (queued_root_effects.length > 0) {
          flush_effects();
          if (current_batch !== null && current_batch !== this) {
            return;
          }
        } else if (this.#pending === 0) {
          this.process([]);
        }
        this.deactivate();
        for (const update of effect_pending_updates) {
          effect_pending_updates.delete(update);
          update();
          if (current_batch !== null) {
            break;
          }
        }
      }
      discard() {
        for (const fn of this.#discard_callbacks) fn(this);
        this.#discard_callbacks.clear();
      }
      #resolve() {
        if (this.#blocking_pending === 0) {
          for (const fn of this.#commit_callbacks) fn();
          this.#commit_callbacks.clear();
        }
        if (this.#pending === 0) {
          this.#commit();
        }
      }
      #commit() {
        if (batches.size > 1) {
          this.previous.clear();
          var previous_batch_values = batch_values;
          var is_earlier = true;
          var dummy_target = {
            parent: null,
            effect: null,
            effects: [],
            render_effects: [],
            block_effects: []
          };
          for (const batch of batches) {
            if (batch === this) {
              is_earlier = false;
              continue;
            }
            const sources = [];
            for (const [source2, value] of this.current) {
              if (batch.current.has(source2)) {
                if (is_earlier && value !== batch.current.get(source2)) {
                  batch.current.set(source2, value);
                } else {
                  continue;
                }
              }
              sources.push(source2);
            }
            if (sources.length === 0) {
              continue;
            }
            const others = [...batch.current.keys()].filter((s3) => !this.current.has(s3));
            if (others.length > 0) {
              const marked = /* @__PURE__ */ new Set();
              const checked = /* @__PURE__ */ new Map();
              for (const source2 of sources) {
                mark_effects(source2, others, marked, checked);
              }
              if (queued_root_effects.length > 0) {
                current_batch = batch;
                batch.apply();
                for (const root2 of queued_root_effects) {
                  batch.#traverse_effect_tree(root2, dummy_target);
                }
                queued_root_effects = [];
                batch.deactivate();
              }
            }
          }
          current_batch = null;
          batch_values = previous_batch_values;
        }
        this.committed = true;
        batches.delete(this);
        this.#deferred?.resolve();
      }
      /**
       *
       * @param {boolean} blocking
       */
      increment(blocking) {
        this.#pending += 1;
        if (blocking) this.#blocking_pending += 1;
      }
      /**
       *
       * @param {boolean} blocking
       */
      decrement(blocking) {
        this.#pending -= 1;
        if (blocking) this.#blocking_pending -= 1;
        this.revive();
      }
      revive() {
        for (const e3 of this.#dirty_effects) {
          set_signal_status(e3, DIRTY);
          schedule_effect(e3);
        }
        for (const e3 of this.#maybe_dirty_effects) {
          set_signal_status(e3, MAYBE_DIRTY);
          schedule_effect(e3);
        }
        this.#dirty_effects = [];
        this.#maybe_dirty_effects = [];
        this.flush();
      }
      /** @param {() => void} fn */
      oncommit(fn) {
        this.#commit_callbacks.add(fn);
      }
      /** @param {(batch: Batch) => void} fn */
      ondiscard(fn) {
        this.#discard_callbacks.add(fn);
      }
      settled() {
        return (this.#deferred ??= deferred()).promise;
      }
      static ensure() {
        if (current_batch === null) {
          const batch = current_batch = new _Batch();
          batches.add(current_batch);
          if (!is_flushing_sync) {
            _Batch.enqueue(() => {
              if (current_batch !== batch) {
                return;
              }
              batch.flush();
            });
          }
        }
        return current_batch;
      }
      /** @param {() => void} task */
      static enqueue(task) {
        queue_micro_task(task);
      }
      apply() {
        return;
      }
    };
    eager_block_effects = null;
    eager_effects = /* @__PURE__ */ new Set();
    old_values = /* @__PURE__ */ new Map();
    eager_effects_deferred = false;
    is_updating_effect = false;
    is_destroying_effect = false;
    active_reaction = null;
    untracking = false;
    active_effect = null;
    current_sources = null;
    new_deps = null;
    skipped_deps = 0;
    untracked_writes = null;
    write_version = 1;
    read_version = 0;
    update_version = read_version;
    skip_reaction = false;
    STATUS_MASK = -7169;
    ATTR_REGEX = /[&"<]/g;
    CONTENT_REGEX = /[&<]/g;
    ssr_context = null;
  }
});

// .svelte-kit/output/server/chunks/index.js
function readable(value, start2) {
  return {
    subscribe: writable(value, start2).subscribe
  };
}
function writable(value, start2 = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set2(fn(
      /** @type {T} */
      value
    ));
  }
  function subscribe(run, invalidate = noop) {
    const subscriber = [run, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set2, update) || noop;
    }
    run(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update, subscribe };
}
function derived(stores2, fn, initial_value) {
  const single = !Array.isArray(stores2);
  const stores_array = single ? [stores2] : stores2;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set2, update) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2, update);
      if (auto) {
        set2(result);
      } else {
        cleanup = typeof result === "function" ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe_to_store(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
var subscriber_queue;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    init_context();
    subscriber_queue = [];
  }
});

// .svelte-kit/output/server/chunks/index2.js
function is_void(name) {
  return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
}
function is_boolean_attribute(name) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name);
}
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
function is_raw_text_element(name) {
  return RAW_TEXT_ELEMENTS.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    name
  );
}
function attr(name, value, is_boolean = false) {
  if (name === "hidden" && value !== "until-found") {
    is_boolean = true;
  }
  if (value == null || !value && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value) || value;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
function clsx2(value) {
  if (typeof value === "object") {
    return clsx(value);
  } else {
    return value ?? "";
  }
}
function to_class(value, hash3, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash3) {
    classname = classname ? classname + " " + hash3 : hash3;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a = 0;
        while ((a = classname.indexOf(key2, a)) >= 0) {
          var b = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
          } else {
            a = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function append_styles(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (value != null && value !== "") {
      css += " " + key2 + ": " + value + separator;
    }
  }
  return css;
}
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i = 0; i < len; i++) {
        var c2 = value[i];
        if (in_comment) {
          if (c2 === "/" && value[i - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c2) {
            in_str = false;
          }
        } else if (c2 === "/" && value[i + 1] === "*") {
          in_comment = true;
        } else if (c2 === '"' || c2 === "'") {
          in_str = c2;
        } else if (c2 === "(") {
          in_apo++;
        } else if (c2 === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c2 === ":" && name_index === -1) {
            name_index = i;
          } else if (c2 === ";" || i === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c2 !== ";") {
                  i++;
                }
                var property = value.substring(start_index, i).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}
function abort() {
  controller?.abort(STALE_REACTION);
  controller = null;
}
function await_invalid() {
  const error2 = new Error(`await_invalid
Encountered asynchronous work while rendering synchronously.
https://svelte.dev/e/await_invalid`);
  error2.name = "Svelte error";
  throw error2;
}
function element(renderer, tag, attributes_fn = noop, children_fn = noop) {
  renderer.push("<!---->");
  if (tag) {
    renderer.push(`<${tag}`);
    attributes_fn();
    renderer.push(`>`);
    if (!is_void(tag)) {
      children_fn();
      if (!is_raw_text_element(tag)) {
        renderer.push(EMPTY_COMMENT);
      }
      renderer.push(`</${tag}>`);
    }
  }
  renderer.push("<!---->");
}
function render(component8, options2 = {}) {
  return Renderer.render(
    /** @type {Component<Props>} */
    component8,
    options2
  );
}
function head(renderer, fn) {
  renderer.head((renderer2) => {
    renderer2.push(BLOCK_OPEN);
    renderer2.child(fn);
    renderer2.push(BLOCK_CLOSE);
  });
}
function attributes(attrs, css_hash, classes, styles, flags2 = 0) {
  if (styles) {
    attrs.style = to_style(attrs.style, styles);
  }
  if (attrs.class) {
    attrs.class = clsx2(attrs.class);
  }
  if (css_hash || classes) {
    attrs.class = to_class(attrs.class, css_hash, classes);
  }
  let attr_str = "";
  let name;
  const is_html = (flags2 & ELEMENT_IS_NAMESPACED) === 0;
  const lowercase = (flags2 & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;
  const is_input = (flags2 & ELEMENT_IS_INPUT) !== 0;
  for (name in attrs) {
    if (typeof attrs[name] === "function") continue;
    if (name[0] === "$" && name[1] === "$") continue;
    if (INVALID_ATTR_NAME_CHAR_REGEX.test(name)) continue;
    var value = attrs[name];
    if (lowercase) {
      name = name.toLowerCase();
    }
    if (is_input) {
      if (name === "defaultvalue" || name === "defaultchecked") {
        name = name === "defaultvalue" ? "value" : "checked";
        if (attrs[name]) continue;
      }
    }
    attr_str += attr(name, value, is_html && is_boolean_attribute(name));
  }
  return attr_str;
}
function attr_class(value, hash3, directives) {
  var result = to_class(value, hash3, directives);
  return result ? ` class="${escape_html(result, true)}"` : "";
}
function store_get(store_values, store_name, store) {
  if (store_name in store_values && store_values[store_name][0] === store) {
    return store_values[store_name][2];
  }
  store_values[store_name]?.[1]();
  store_values[store_name] = [store, null, void 0];
  const unsub = subscribe_to_store(
    store,
    /** @param {any} v */
    (v2) => store_values[store_name][2] = v2
  );
  store_values[store_name][1] = unsub;
  return store_values[store_name][2];
}
function unsubscribe_stores(store_values) {
  for (const store_name in store_values) {
    store_values[store_name][1]();
  }
}
function slot(renderer, $$props, name, slot_props, fallback_fn) {
  var slot_fn = $$props.$$slots?.[name];
  if (slot_fn === true) {
    slot_fn = $$props["children"];
  }
  if (slot_fn !== void 0) {
    slot_fn(renderer, slot_props);
  }
}
function rest_props(props, rest) {
  const rest_props2 = {};
  let key2;
  for (key2 in props) {
    if (!rest.includes(key2)) {
      rest_props2[key2] = props[key2];
    }
  }
  return rest_props2;
}
function sanitize_props(props) {
  const { children, $$slots, ...sanitized } = props;
  return sanitized;
}
function bind_props(props_parent, props_now) {
  for (const key2 in props_now) {
    const initial_value = props_parent[key2];
    const value = props_now[key2];
    if (initial_value === void 0 && value !== void 0 && Object.getOwnPropertyDescriptor(props_parent, key2)?.set) {
      props_parent[key2] = value;
    }
  }
}
function ensure_array_like(array_like_or_iterator) {
  if (array_like_or_iterator) {
    return array_like_or_iterator.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }
  return [];
}
var VOID_ELEMENT_NAMES, DOM_BOOLEAN_ATTRIBUTES, PASSIVE_EVENTS, RAW_TEXT_ELEMENTS, replacements, whitespace, BLOCK_OPEN, BLOCK_CLOSE, EMPTY_COMMENT, controller, Renderer, SSRState, INVALID_ATTR_NAME_CHAR_REGEX;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    init_context();
    init_clsx();
    VOID_ELEMENT_NAMES = [
      "area",
      "base",
      "br",
      "col",
      "command",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    DOM_BOOLEAN_ATTRIBUTES = [
      "allowfullscreen",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "disabled",
      "formnovalidate",
      "indeterminate",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "seamless",
      "selected",
      "webkitdirectory",
      "defer",
      "disablepictureinpicture",
      "disableremoteplayback"
    ];
    PASSIVE_EVENTS = ["touchstart", "touchmove"];
    RAW_TEXT_ELEMENTS = /** @type {const} */
    ["textarea", "script", "style", "title"];
    replacements = {
      translate: /* @__PURE__ */ new Map([
        [true, "yes"],
        [false, "no"]
      ])
    };
    whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
    BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
    BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
    EMPTY_COMMENT = `<!---->`;
    controller = null;
    Renderer = class _Renderer {
      /**
       * The contents of the renderer.
       * @type {RendererItem[]}
       */
      #out = [];
      /**
       * Any `onDestroy` callbacks registered during execution of this renderer.
       * @type {(() => void)[] | undefined}
       */
      #on_destroy = void 0;
      /**
       * Whether this renderer is a component body.
       * @type {boolean}
       */
      #is_component_body = false;
      /**
       * The type of string content that this renderer is accumulating.
       * @type {RendererType}
       */
      type;
      /** @type {Renderer | undefined} */
      #parent;
      /**
       * Asynchronous work associated with this renderer
       * @type {Promise<void> | undefined}
       */
      promise = void 0;
      /**
       * State which is associated with the content tree as a whole.
       * It will be re-exposed, uncopied, on all children.
       * @type {SSRState}
       * @readonly
       */
      global;
      /**
       * State that is local to the branch it is declared in.
       * It will be shallow-copied to all children.
       *
       * @type {{ select_value: string | undefined }}
       */
      local;
      /**
       * @param {SSRState} global
       * @param {Renderer | undefined} [parent]
       */
      constructor(global, parent) {
        this.#parent = parent;
        this.global = global;
        this.local = parent ? { ...parent.local } : { select_value: void 0 };
        this.type = parent ? parent.type : "body";
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      head(fn) {
        const head2 = new _Renderer(this.global, this);
        head2.type = "head";
        this.#out.push(head2);
        head2.child(fn);
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      async(fn) {
        this.#out.push(BLOCK_OPEN);
        this.child(fn);
        this.#out.push(BLOCK_CLOSE);
      }
      /**
       * Create a child renderer. The child renderer inherits the state from the parent,
       * but has its own content.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       */
      child(fn) {
        const child = new _Renderer(this.global, this);
        this.#out.push(child);
        const parent = ssr_context;
        set_ssr_context({
          ...ssr_context,
          p: parent,
          c: null,
          r: child
        });
        const result = fn(child);
        set_ssr_context(parent);
        if (result instanceof Promise) {
          if (child.global.mode === "sync") {
            await_invalid();
          }
          result.catch(() => {
          });
          child.promise = result;
        }
        return child;
      }
      /**
       * Create a component renderer. The component renderer inherits the state from the parent,
       * but has its own content. It is treated as an ordering boundary for ondestroy callbacks.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       * @param {Function} [component_fn]
       * @returns {void}
       */
      component(fn, component_fn) {
        push();
        const child = this.child(fn);
        child.#is_component_body = true;
        pop();
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {(renderer: Renderer) => void} fn
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       * @returns {void}
       */
      select(attrs, fn, css_hash, classes, styles, flags2) {
        const { value, ...select_attrs } = attrs;
        this.push(`<select${attributes(select_attrs, css_hash, classes, styles, flags2)}>`);
        this.child((renderer) => {
          renderer.local.select_value = value;
          fn(renderer);
        });
        this.push("</select>");
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {string | number | boolean | ((renderer: Renderer) => void)} body
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       */
      option(attrs, body2, css_hash, classes, styles, flags2) {
        this.#out.push(`<option${attributes(attrs, css_hash, classes, styles, flags2)}`);
        const close = (renderer, value, { head: head2, body: body22 }) => {
          if ("value" in attrs) {
            value = attrs.value;
          }
          if (value === this.local.select_value) {
            renderer.#out.push(" selected");
          }
          renderer.#out.push(`>${body22}</option>`);
          if (head2) {
            renderer.head((child) => child.push(head2));
          }
        };
        if (typeof body2 === "function") {
          this.child((renderer) => {
            const r3 = new _Renderer(this.global, this);
            body2(r3);
            if (this.global.mode === "async") {
              return r3.#collect_content_async().then((content) => {
                close(renderer, content.body.replaceAll("<!---->", ""), content);
              });
            } else {
              const content = r3.#collect_content();
              close(renderer, content.body.replaceAll("<!---->", ""), content);
            }
          });
        } else {
          close(this, body2, { body: body2 });
        }
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      title(fn) {
        const path = this.get_path();
        const close = (head2) => {
          this.global.set_title(head2, path);
        };
        this.child((renderer) => {
          const r3 = new _Renderer(renderer.global, renderer);
          fn(r3);
          if (renderer.global.mode === "async") {
            return r3.#collect_content_async().then((content) => {
              close(content.head);
            });
          } else {
            const content = r3.#collect_content();
            close(content.head);
          }
        });
      }
      /**
       * @param {string | (() => Promise<string>)} content
       */
      push(content) {
        if (typeof content === "function") {
          this.child(async (renderer) => renderer.push(await content()));
        } else {
          this.#out.push(content);
        }
      }
      /**
       * @param {() => void} fn
       */
      on_destroy(fn) {
        (this.#on_destroy ??= []).push(fn);
      }
      /**
       * @returns {number[]}
       */
      get_path() {
        return this.#parent ? [...this.#parent.get_path(), this.#parent.#out.indexOf(this)] : [];
      }
      /**
       * @deprecated this is needed for legacy component bindings
       */
      copy() {
        const copy = new _Renderer(this.global, this.#parent);
        copy.#out = this.#out.map((item) => item instanceof _Renderer ? item.copy() : item);
        copy.promise = this.promise;
        return copy;
      }
      /**
       * @param {Renderer} other
       * @deprecated this is needed for legacy component bindings
       */
      subsume(other) {
        if (this.global.mode !== other.global.mode) {
          throw new Error(
            "invariant: A renderer cannot switch modes. If you're seeing this, there's a compiler bug. File an issue!"
          );
        }
        this.local = other.local;
        this.#out = other.#out.map((item) => {
          if (item instanceof _Renderer) {
            item.subsume(item);
          }
          return item;
        });
        this.promise = other.promise;
        this.type = other.type;
      }
      get length() {
        return this.#out.length;
      }
      /**
       * Only available on the server and when compiling with the `server` option.
       * Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} [options]
       * @returns {RenderOutput}
       */
      static render(component8, options2 = {}) {
        let sync;
        const result = (
          /** @type {RenderOutput} */
          {}
        );
        Object.defineProperties(result, {
          html: {
            get: () => {
              return (sync ??= _Renderer.#render(component8, options2)).body;
            }
          },
          head: {
            get: () => {
              return (sync ??= _Renderer.#render(component8, options2)).head;
            }
          },
          body: {
            get: () => {
              return (sync ??= _Renderer.#render(component8, options2)).body;
            }
          },
          then: {
            value: (
              /**
               * this is not type-safe, but honestly it's the best I can do right now, and it's a straightforward function.
               *
               * @template TResult1
               * @template [TResult2=never]
               * @param { (value: SyncRenderOutput) => TResult1 } onfulfilled
               * @param { (reason: unknown) => TResult2 } onrejected
               */
              (onfulfilled, onrejected) => {
                {
                  const result2 = sync ??= _Renderer.#render(component8, options2);
                  const user_result = onfulfilled({
                    head: result2.head,
                    body: result2.body,
                    html: result2.body
                  });
                  return Promise.resolve(user_result);
                }
              }
            )
          }
        });
        return result;
      }
      /**
       * Collect all of the `onDestroy` callbacks regsitered during rendering. In an async context, this is only safe to call
       * after awaiting `collect_async`.
       *
       * Child renderers are "porous" and don't affect execution order, but component body renderers
       * create ordering boundaries. Within a renderer, callbacks run in order until hitting a component boundary.
       * @returns {Iterable<() => void>}
       */
      *#collect_on_destroy() {
        for (const component8 of this.#traverse_components()) {
          yield* component8.#collect_ondestroy();
        }
      }
      /**
       * Performs a depth-first search of renderers, yielding the deepest components first, then additional components as we backtrack up the tree.
       * @returns {Iterable<Renderer>}
       */
      *#traverse_components() {
        for (const child of this.#out) {
          if (typeof child !== "string") {
            yield* child.#traverse_components();
          }
        }
        if (this.#is_component_body) {
          yield this;
        }
      }
      /**
       * @returns {Iterable<() => void>}
       */
      *#collect_ondestroy() {
        if (this.#on_destroy) {
          for (const fn of this.#on_destroy) {
            yield fn;
          }
        }
        for (const child of this.#out) {
          if (child instanceof _Renderer && !child.#is_component_body) {
            yield* child.#collect_ondestroy();
          }
        }
      }
      /**
       * Render a component. Throws if any of the children are performing asynchronous work.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {AccumulatedContent}
       */
      static #render(component8, options2) {
        var previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("sync", component8, options2);
          const content = renderer.#collect_content();
          return _Renderer.#close_render(content, renderer);
        } finally {
          abort();
          set_ssr_context(previous_context);
        }
      }
      /**
       * Render a component.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Promise<AccumulatedContent>}
       */
      static async #render_async(component8, options2) {
        var previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("async", component8, options2);
          const content = await renderer.#collect_content_async();
          return _Renderer.#close_render(content, renderer);
        } finally {
          abort();
          set_ssr_context(previous_context);
        }
      }
      /**
       * Collect all of the code from the `out` array and return it as a string, or a promise resolving to a string.
       * @param {AccumulatedContent} content
       * @returns {AccumulatedContent}
       */
      #collect_content(content = { head: "", body: "" }) {
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            item.#collect_content(content);
          }
        }
        return content;
      }
      /**
       * Collect all of the code from the `out` array and return it as a string.
       * @param {AccumulatedContent} content
       * @returns {Promise<AccumulatedContent>}
       */
      async #collect_content_async(content = { head: "", body: "" }) {
        await this.promise;
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            await item.#collect_content_async(content);
          }
        }
        return content;
      }
      /**
       * @template {Record<string, any>} Props
       * @param {'sync' | 'async'} mode
       * @param {import('svelte').Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Renderer}
       */
      static #open_render(mode2, component8, options2) {
        const renderer = new _Renderer(
          new SSRState(mode2, options2.idPrefix ? options2.idPrefix + "-" : "")
        );
        renderer.push(BLOCK_OPEN);
        if (options2.context) {
          push();
          ssr_context.c = options2.context;
          ssr_context.r = renderer;
        }
        component8(renderer, options2.props ?? {});
        if (options2.context) {
          pop();
        }
        renderer.push(BLOCK_CLOSE);
        return renderer;
      }
      /**
       * @param {AccumulatedContent} content
       * @param {Renderer} renderer
       */
      static #close_render(content, renderer) {
        for (const cleanup of renderer.#collect_on_destroy()) {
          cleanup();
        }
        let head2 = content.head + renderer.global.get_title();
        let body2 = content.body;
        for (const { hash: hash3, code } of renderer.global.css) {
          head2 += `<style id="${hash3}">${code}</style>`;
        }
        return {
          head: head2,
          body: body2
        };
      }
    };
    SSRState = class {
      /** @readonly @type {'sync' | 'async'} */
      mode;
      /** @readonly @type {() => string} */
      uid;
      /** @readonly @type {Set<{ hash: string; code: string }>} */
      css = /* @__PURE__ */ new Set();
      /** @type {{ path: number[], value: string }} */
      #title = { path: [], value: "" };
      /**
       * @param {'sync' | 'async'} mode
       * @param {string} [id_prefix]
       */
      constructor(mode2, id_prefix = "") {
        this.mode = mode2;
        let uid = 1;
        this.uid = () => `${id_prefix}s${uid++}`;
      }
      get_title() {
        return this.#title.value;
      }
      /**
       * Performs a depth-first (lexicographic) comparison using the path. Rejects sets
       * from earlier than or equal to the current value.
       * @param {string} value
       * @param {number[]} path
       */
      set_title(value, path) {
        const current3 = this.#title.path;
        let i = 0;
        let l = Math.min(path.length, current3.length);
        while (i < l && path[i] === current3[i]) i += 1;
        if (path[i] === void 0) return;
        if (current3[i] === void 0 || path[i] > current3[i]) {
          this.#title.path = path;
          this.#title.value = value;
        }
      }
    };
    INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse5;
    exports.serialize = serialize3;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse5(str, options2) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options2 || {};
      var dec = opt.decode || decode2;
      var index8 = 0;
      while (index8 < str.length) {
        var eqIdx = str.indexOf("=", index8);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index8);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index8 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key2 = str.slice(index8, eqIdx).trim();
        if (void 0 === obj[key2]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key2] = tryDecode(val, dec);
        }
        index8 = endIdx + 1;
      }
      return obj;
    }
    function serialize3(name, val, options2) {
      var opt = options2 || {};
      var enc = opt.encode || encode3;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.partitioned) {
        str += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode2(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode3(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode3) {
      try {
        return decode3(str);
      } catch (e3) {
        return str;
      }
    }
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString3(setCookieValue, options2) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      try {
        value = options2.decodeValues ? decodeURIComponent(value) : value;
      } catch (e3) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e3
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key2 = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key2 === "expires") {
          cookie.expires = new Date(value2);
        } else if (key2 === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key2 === "secure") {
          cookie.secure = true;
        } else if (key2 === "httponly") {
          cookie.httpOnly = true;
        } else if (key2 === "samesite") {
          cookie.sameSite = value2;
        } else if (key2 === "partitioned") {
          cookie.partitioned = true;
        } else {
          cookie[key2] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse5(input, options2) {
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!input) {
        if (!options2.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key2) {
            return key2.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options2.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options2.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString3(str, options2);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString3(str, options2);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start2;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start2 = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start2, lastComma));
              start2 = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start2, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse5;
    module.exports.parse = parse5;
    module.exports.parseString = parseString3;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// .svelte-kit/output/server/entries/pages/_layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => _layout
});
function _layout($$renderer, $$props) {
  let { children } = $$props;
  head($$renderer, ($$renderer2) => {
    $$renderer2.push(`<link rel="icon"${attr("href", favicon)}/>`);
  });
  children?.($$renderer);
  $$renderer.push(`<!---->`);
}
var favicon;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_index2();
    favicon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='107'%20height='128'%20viewBox='0%200%20107%20128'%3e%3ctitle%3esvelte-logo%3c/title%3e%3cpath%20d='M94.157%2022.819c-10.4-14.885-30.94-19.297-45.792-9.835L22.282%2029.608A29.92%2029.92%200%200%200%208.764%2049.65a31.5%2031.5%200%200%200%203.108%2020.231%2030%2030%200%200%200-4.477%2011.183%2031.9%2031.9%200%200%200%205.448%2024.116c10.402%2014.887%2030.942%2019.297%2045.791%209.835l26.083-16.624A29.92%2029.92%200%200%200%2098.235%2078.35a31.53%2031.53%200%200%200-3.105-20.232%2030%2030%200%200%200%204.474-11.182%2031.88%2031.88%200%200%200-5.447-24.116'%20style='fill:%23ff3e00'/%3e%3cpath%20d='M45.817%20106.582a20.72%2020.72%200%200%201-22.237-8.243%2019.17%2019.17%200%200%201-3.277-14.503%2018%2018%200%200%201%20.624-2.435l.49-1.498%201.337.981a33.6%2033.6%200%200%200%2010.203%205.098l.97.294-.09.968a5.85%205.85%200%200%200%201.052%203.878%206.24%206.24%200%200%200%206.695%202.485%205.8%205.8%200%200%200%201.603-.704L69.27%2076.28a5.43%205.43%200%200%200%202.45-3.631%205.8%205.8%200%200%200-.987-4.371%206.24%206.24%200%200%200-6.698-2.487%205.7%205.7%200%200%200-1.6.704l-9.953%206.345a19%2019%200%200%201-5.296%202.326%2020.72%2020.72%200%200%201-22.237-8.243%2019.17%2019.17%200%200%201-3.277-14.502%2017.99%2017.99%200%200%201%208.13-12.052l26.081-16.623a19%2019%200%200%201%205.3-2.329%2020.72%2020.72%200%200%201%2022.237%208.243%2019.17%2019.17%200%200%201%203.277%2014.503%2018%2018%200%200%201-.624%202.435l-.49%201.498-1.337-.98a33.6%2033.6%200%200%200-10.203-5.1l-.97-.294.09-.968a5.86%205.86%200%200%200-1.052-3.878%206.24%206.24%200%200%200-6.696-2.485%205.8%205.8%200%200%200-1.602.704L37.73%2051.72a5.42%205.42%200%200%200-2.449%203.63%205.79%205.79%200%200%200%20.986%204.372%206.24%206.24%200%200%200%206.698%202.486%205.8%205.8%200%200%200%201.602-.704l9.952-6.342a19%2019%200%200%201%205.295-2.328%2020.72%2020.72%200%200%201%2022.237%208.242%2019.17%2019.17%200%200%201%203.277%2014.503%2018%2018%200%200%201-8.13%2012.053l-26.081%2016.622a19%2019%200%200%201-5.3%202.328'%20style='fill:%23fff'/%3e%3c/svg%3e";
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  stylesheets: () => stylesheets
});
var index, component_cache, component, imports, stylesheets, fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    index = 0;
    component = async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default;
    imports = ["_app/immutable/nodes/0.wGTXielk.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DmKfOTeo.js", "_app/immutable/chunks/CyJPgw3D.js"];
    stylesheets = ["_app/immutable/assets/0.Cgbp4RAO.css"];
    fonts = [];
  }
});

// .svelte-kit/output/server/chunks/state.svelte.js
var is_legacy;
var init_state_svelte = __esm({
  ".svelte-kit/output/server/chunks/state.svelte.js"() {
    init_clsx();
    init_context();
    init_server();
    is_legacy = noop.toString().includes("$$") || /function \w+\(\) \{\}/.test(noop.toString());
    if (is_legacy) {
      ({
        data: {},
        form: null,
        error: null,
        params: {},
        route: { id: null },
        state: {},
        status: -1,
        url: new URL("https://example.com")
      });
    }
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error$1
});
function create_updated_store() {
  const { set: set2, subscribe } = writable(false);
  {
    return {
      subscribe,
      // eslint-disable-next-line @typescript-eslint/require-await
      check: async () => false
    };
  }
}
function context() {
  return getContext("__request__");
}
function Error$1($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    $$renderer2.push(`<h1>${escape_html(page.status)}</h1> <p>${escape_html(page.error?.message)}</p>`);
  });
}
var stores, page$1, page;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_context();
    init_clsx();
    init_state_svelte();
    init_internal();
    init_exports();
    init_utils();
    init_chunks();
    init_server();
    stores = {
      updated: /* @__PURE__ */ create_updated_store()
    };
    ({
      check: stores.updated.check
    });
    page$1 = {
      get error() {
        return context().page.error;
      },
      get status() {
        return context().page.status;
      }
    };
    page = page$1;
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2, component_cache2, component2, imports2, stylesheets2, fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default;
    imports2 = ["_app/immutable/nodes/1.-tF8YJX-.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/CVeh0obE.js", "_app/immutable/chunks/DmKfOTeo.js", "_app/immutable/chunks/Ch_7xMJZ.js", "_app/immutable/chunks/D-pHkSQu.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});

// .svelte-kit/output/server/chunks/SidebarNav.js
function BottomNav($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    let items = fallback($$props["items"], () => [], true);
    let onNavigate = fallback($$props["onNavigate"], null);
    $$renderer2.push(`<nav class="bottom-nav svelte-10hguwp" aria-label="Primary"><!--[-->`);
    const each_array = ensure_array_like(items);
    for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
      let item = each_array[$$index];
      $$renderer2.push(`<button type="button"${attr_class("nav-item svelte-10hguwp", void 0, { "active": item.active, "disabled": item.disabled })}${attr("aria-current", item.active ? "page" : void 0)}${attr("disabled", item.disabled, true)}><span class="icon svelte-10hguwp" aria-hidden="true">${escape_html(item.icon)}</span> <span class="label">${escape_html(item.label)}</span></button>`);
    }
    $$renderer2.push(`<!--]--></nav>`);
    bind_props($$props, { items, onNavigate });
  });
}
function SidebarNav($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    let title = fallback($$props["title"], "");
    let items = fallback($$props["items"], () => [], true);
    let onNavigate = fallback($$props["onNavigate"], null);
    $$renderer2.push(`<aside class="sidebar svelte-45rnuk"${attr("aria-label", title || void 0)}>`);
    if (title) {
      $$renderer2.push("<!--[-->");
      $$renderer2.push(`<div class="sidebar-header svelte-45rnuk"><h2 class="svelte-45rnuk">${escape_html(title)}</h2></div>`);
    } else {
      $$renderer2.push("<!--[!-->");
    }
    $$renderer2.push(`<!--]--> <nav class="svelte-45rnuk"><ul class="svelte-45rnuk"><!--[-->`);
    const each_array = ensure_array_like(items);
    for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
      let item = each_array[$$index];
      $$renderer2.push(`<li><button type="button"${attr_class("nav-link svelte-45rnuk", void 0, { "active": item.active, "disabled": item.disabled })}${attr("aria-current", item.active ? "page" : void 0)}${attr("disabled", item.disabled, true)}><span class="icon svelte-45rnuk" aria-hidden="true">${escape_html(item.icon)}</span> <span>${escape_html(item.label)}</span></button></li>`);
    }
    $$renderer2.push(`<!--]--></ul></nav></aside>`);
    bind_props($$props, { title, items, onNavigate });
  });
}
var getStores, page2;
var init_SidebarNav = __esm({
  ".svelte-kit/output/server/chunks/SidebarNav.js"() {
    init_context();
    init_internal();
    init_exports();
    init_utils();
    init_clsx();
    init_server();
    init_state_svelte();
    init_index2();
    getStores = () => {
      const stores$1 = getContext("__svelte__");
      return {
        /** @type {typeof page} */
        page: {
          subscribe: stores$1.page.subscribe
        },
        /** @type {typeof navigating} */
        navigating: {
          subscribe: stores$1.navigating.subscribe
        },
        /** @type {typeof updated} */
        updated: stores$1.updated
      };
    };
    page2 = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
  }
});

// .svelte-kit/output/server/chunks/breakpoints.js
var BREAKPOINTS, initialSize, viewport, screen;
var init_breakpoints = __esm({
  ".svelte-kit/output/server/chunks/breakpoints.js"() {
    init_chunks();
    BREAKPOINTS = {
      tablet: 768,
      desktop: 1024
    };
    initialSize = { width: 0, height: 0 };
    viewport = readable(initialSize, (set2) => {
      {
        return;
      }
    });
    screen = derived(viewport, ({ width, height }) => ({
      width,
      height,
      isMobile: width < BREAKPOINTS.tablet,
      isTablet: width >= BREAKPOINTS.tablet && width < BREAKPOINTS.desktop,
      isDesktop: width >= BREAKPOINTS.desktop
    }));
  }
});

// .svelte-kit/output/server/chunks/mode.js
var initialMode, modeStore;
var init_mode = __esm({
  ".svelte-kit/output/server/chunks/mode.js"() {
    init_chunks();
    initialMode = () => {
      return "view";
    };
    modeStore = writable(initialMode(), (set2) => {
      return;
    });
    modeStore.subscribe((value) => {
      return;
    });
  }
});

// .svelte-kit/output/server/entries/pages/create/_layout.svelte.js
var layout_svelte_exports2 = {};
__export(layout_svelte_exports2, {
  default: () => _layout2
});
function _layout2($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    var $$store_subs;
    const baseItems = [
      { label: "Map", icon: "\u{1F5FA}\uFE0F", href: "/create" },
      {
        label: "Pins",
        icon: "\u{1F4CD}",
        href: "/create/pins",
        disabled: true
      },
      {
        label: "Story",
        icon: "\u{1F4D6}",
        href: "/create/story",
        disabled: true
      },
      {
        label: "More",
        icon: "\u22EE",
        href: "/create/more",
        disabled: true
      }
    ];
    const computeItems = (pathname) => baseItems.map((item) => ({ ...item, active: pathname === item.href }));
    modeStore.set("create");
    let { children } = $$props;
    if (store_get($$store_subs ??= {}, "$screen", screen).isDesktop) {
      $$renderer2.push("<!--[-->");
      $$renderer2.push(`<div class="create-shell desktop svelte-1l9f1ei">`);
      SidebarNav($$renderer2, {
        title: "Create Mode",
        items: computeItems(store_get($$store_subs ??= {}, "$page", page2).url.pathname)
      });
      $$renderer2.push(`<!----> <div class="workspace svelte-1l9f1ei"><header class="workspace-header svelte-1l9f1ei"><div><h1 class="svelte-1l9f1ei">Workspace</h1> <p class="svelte-1l9f1ei">Build custom map stories with annotations and scenes.</p></div> <div class="toolbar svelte-1l9f1ei"><button type="button" disabled class="svelte-1l9f1ei">New Project</button> <button type="button" disabled class="svelte-1l9f1ei">Load Project</button> <button type="button" class="primary svelte-1l9f1ei" disabled>Save</button></div></header> <div class="workspace-body svelte-1l9f1ei">`);
      children?.($$renderer2);
      $$renderer2.push(`<!----></div></div></div>`);
    } else {
      $$renderer2.push("<!--[!-->");
      if (store_get($$store_subs ??= {}, "$screen", screen).isTablet) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<div class="create-shell tablet svelte-1l9f1ei"><aside class="drawer svelte-1l9f1ei">`);
        SidebarNav($$renderer2, {
          title: "Create Mode",
          items: computeItems(store_get($$store_subs ??= {}, "$page", page2).url.pathname)
        });
        $$renderer2.push(`<!----></aside> <div class="tablet-body svelte-1l9f1ei"><header class="tablet-header svelte-1l9f1ei"><h1 class="svelte-1l9f1ei">Workspace</h1> <button type="button" disabled class="svelte-1l9f1ei">Project Actions</button></header> <div class="tablet-canvas svelte-1l9f1ei">`);
        children?.($$renderer2);
        $$renderer2.push(`<!----></div> `);
        BottomNav($$renderer2, {
          items: computeItems(store_get($$store_subs ??= {}, "$page", page2).url.pathname)
        });
        $$renderer2.push(`<!----></div></div>`);
      } else {
        $$renderer2.push("<!--[!-->");
        $$renderer2.push(`<div class="create-shell mobile svelte-1l9f1ei"><header class="mobile-header svelte-1l9f1ei"><h1 class="svelte-1l9f1ei">Create</h1> <button type="button" disabled class="svelte-1l9f1ei">Tools</button></header> <div class="mobile-canvas svelte-1l9f1ei">`);
        children?.($$renderer2);
        $$renderer2.push(`<!----></div> `);
        BottomNav($$renderer2, {
          items: computeItems(store_get($$store_subs ??= {}, "$page", page2).url.pathname)
        });
        $$renderer2.push(`<!----></div>`);
      }
      $$renderer2.push(`<!--]-->`);
    }
    $$renderer2.push(`<!--]-->`);
    if ($$store_subs) unsubscribe_stores($$store_subs);
  });
}
var init_layout_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/create/_layout.svelte.js"() {
    init_index2();
    init_SidebarNav();
    init_breakpoints();
    init_mode();
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  stylesheets: () => stylesheets3
});
var index3, component_cache3, component3, imports3, stylesheets3, fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    index3 = 2;
    component3 = async () => component_cache3 ??= (await Promise.resolve().then(() => (init_layout_svelte2(), layout_svelte_exports2))).default;
    imports3 = ["_app/immutable/nodes/2.CxGwAj-Q.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DmKfOTeo.js", "_app/immutable/chunks/DlFo6P2L.js", "_app/immutable/chunks/CcWUXD1I.js", "_app/immutable/chunks/Ch_7xMJZ.js", "_app/immutable/chunks/2EYxe9t0.js", "_app/immutable/chunks/D-pHkSQu.js", "_app/immutable/chunks/CVeh0obE.js", "_app/immutable/chunks/q2JeGk3q.js", "_app/immutable/chunks/CyJPgw3D.js", "_app/immutable/chunks/B62UVDqu.js"];
    stylesheets3 = ["_app/immutable/assets/breakpoints.yzSdU6gv.css", "_app/immutable/assets/SidebarNav.BhkK5er2.css", "_app/immutable/assets/2.BpDfismB.css"];
    fonts3 = [];
  }
});

// .svelte-kit/output/server/entries/pages/view/_layout.svelte.js
var layout_svelte_exports3 = {};
__export(layout_svelte_exports3, {
  default: () => _layout3
});
function _layout3($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    var $$store_subs;
    const baseItems = [
      { label: "Stories", icon: "\u{1F4DA}", href: "/view" },
      {
        label: "Maps",
        icon: "\u{1F5FA}\uFE0F",
        href: "/view/maps",
        disabled: true
      },
      {
        label: "Saved",
        icon: "\u2764\uFE0F",
        href: "/view/saved",
        disabled: true
      },
      {
        label: "More",
        icon: "\u2699\uFE0F",
        href: "/view/more",
        disabled: true
      }
    ];
    const computeItems = (pathname) => baseItems.map((item) => ({ ...item, active: pathname === item.href }));
    modeStore.set("view");
    let { children } = $$props;
    if (store_get($$store_subs ??= {}, "$screen", screen).isDesktop) {
      $$renderer2.push("<!--[-->");
      $$renderer2.push(`<div class="view-shell desktop svelte-px7o6d">`);
      SidebarNav($$renderer2, {
        title: "View Mode",
        items: computeItems(store_get($$store_subs ??= {}, "$page", page2).url.pathname)
      });
      $$renderer2.push(`<!----> <div class="desktop-body svelte-px7o6d"><header class="desktop-header svelte-px7o6d"><div><h1 class="svelte-px7o6d">Stories</h1> <p class="svelte-px7o6d">Explore curated narratives from the Vietnam Map Archive.</p></div> <button type="button" class="header-action svelte-px7o6d" disabled>Search (soon)</button></header> <div class="desktop-content svelte-px7o6d">`);
      children?.($$renderer2);
      $$renderer2.push(`<!----></div></div></div>`);
    } else {
      $$renderer2.push("<!--[!-->");
      if (store_get($$store_subs ??= {}, "$screen", screen).isTablet) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<div class="view-shell tablet svelte-px7o6d"><aside class="drawer svelte-px7o6d">`);
        SidebarNav($$renderer2, {
          title: "View Mode",
          items: computeItems(store_get($$store_subs ??= {}, "$page", page2).url.pathname)
        });
        $$renderer2.push(`<!----></aside> <div class="tablet-main svelte-px7o6d"><header class="tablet-header svelte-px7o6d"><h1 class="svelte-px7o6d">Stories</h1> <button type="button" disabled class="svelte-px7o6d">Search</button></header> <div class="tablet-content svelte-px7o6d">`);
        children?.($$renderer2);
        $$renderer2.push(`<!----></div> `);
        BottomNav($$renderer2, {
          items: computeItems(store_get($$store_subs ??= {}, "$page", page2).url.pathname)
        });
        $$renderer2.push(`<!----></div></div>`);
      } else {
        $$renderer2.push("<!--[!-->");
        $$renderer2.push(`<div class="view-shell mobile svelte-px7o6d"><header class="mobile-header svelte-px7o6d"><button type="button" class="icon-button svelte-px7o6d" disabled>\u2630</button> <h1 class="svelte-px7o6d">Stories</h1> <button type="button" class="icon-button svelte-px7o6d" disabled>\u2699\uFE0F</button></header> <div class="mobile-content svelte-px7o6d">`);
        children?.($$renderer2);
        $$renderer2.push(`<!----></div> `);
        BottomNav($$renderer2, {
          items: computeItems(store_get($$store_subs ??= {}, "$page", page2).url.pathname)
        });
        $$renderer2.push(`<!----></div>`);
      }
      $$renderer2.push(`<!--]-->`);
    }
    $$renderer2.push(`<!--]-->`);
    if ($$store_subs) unsubscribe_stores($$store_subs);
  });
}
var init_layout_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/view/_layout.svelte.js"() {
    init_index2();
    init_SidebarNav();
    init_breakpoints();
    init_mode();
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  stylesheets: () => stylesheets4
});
var index4, component_cache4, component4, imports4, stylesheets4, fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    index4 = 3;
    component4 = async () => component_cache4 ??= (await Promise.resolve().then(() => (init_layout_svelte3(), layout_svelte_exports3))).default;
    imports4 = ["_app/immutable/nodes/3.CEei3L7y.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DmKfOTeo.js", "_app/immutable/chunks/DlFo6P2L.js", "_app/immutable/chunks/CcWUXD1I.js", "_app/immutable/chunks/Ch_7xMJZ.js", "_app/immutable/chunks/2EYxe9t0.js", "_app/immutable/chunks/D-pHkSQu.js", "_app/immutable/chunks/CVeh0obE.js", "_app/immutable/chunks/q2JeGk3q.js", "_app/immutable/chunks/CyJPgw3D.js", "_app/immutable/chunks/B62UVDqu.js"];
    stylesheets4 = ["_app/immutable/assets/breakpoints.yzSdU6gv.css", "_app/immutable/assets/SidebarNav.BhkK5er2.css", "_app/immutable/assets/3.C8mssoqu.css"];
    fonts4 = [];
  }
});

// .svelte-kit/output/server/entries/pages/_page.svelte.js
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => _page
});
function Container($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["as", "size", "padding", "className", "style"]);
  $$renderer.component(($$renderer2) => {
    let classes, styles;
    const sizes = {
      sm: "640px",
      md: "768px",
      lg: "1024px",
      xl: "1280px",
      full: "100%"
    };
    let as = fallback($$props["as"], "div");
    let size = fallback($$props["size"], "lg");
    let padding = fallback($$props["padding"], "var(--space-6)");
    let className = fallback($$props["className"], "");
    let style = fallback($$props["style"], void 0);
    const resolveSize = (value) => value in sizes ? sizes[value] : value;
    classes = ["container", className, $$sanitized_props.class].filter(Boolean).join(" ");
    styles = [
      style,
      $$sanitized_props.style,
      `--container-max:${resolveSize(size)}`,
      `--container-padding:${padding}`
    ].filter(Boolean).join(";");
    element(
      $$renderer2,
      as,
      () => {
        $$renderer2.push(`${attributes({ ...$$restProps, class: clsx2(classes), style: styles }, "svelte-11wbhul")}`);
      },
      () => {
        $$renderer2.push(`<!--[-->`);
        slot($$renderer2, $$props, "default", {});
        $$renderer2.push(`<!--]-->`);
      }
    );
    bind_props($$props, { as, size, padding, className, style });
  });
}
function Stack($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "as",
    "gap",
    "align",
    "justify",
    "wrap",
    "className",
    "style"
  ]);
  $$renderer.component(($$renderer2) => {
    let resolvedAlign, resolvedJustify, classes, styles;
    const alignments = {
      start: "flex-start",
      center: "center",
      end: "flex-end",
      stretch: "stretch",
      baseline: "baseline"
    };
    const justifications = {
      start: "flex-start",
      center: "center",
      end: "flex-end",
      between: "space-between",
      around: "space-around",
      evenly: "space-evenly"
    };
    let as = fallback($$props["as"], "div");
    let gap = fallback($$props["gap"], "var(--space-4)");
    let align = fallback($$props["align"], "stretch");
    let justify = fallback($$props["justify"], "start");
    let wrap2 = fallback($$props["wrap"], false);
    let className = fallback($$props["className"], "");
    let style = fallback($$props["style"], void 0);
    const resolve2 = (map, value) => value in map ? map[value] : value;
    resolvedAlign = resolve2(alignments, String(align));
    resolvedJustify = resolve2(justifications, String(justify));
    classes = [
      "stack",
      wrap2 ? "stack--wrap" : "",
      className,
      $$sanitized_props.class
    ].filter(Boolean).join(" ");
    styles = [
      style,
      $$sanitized_props.style,
      `--stack-gap:${gap}`,
      `--stack-align:${resolvedAlign}`,
      `--stack-justify:${resolvedJustify}`
    ].filter(Boolean).join(";");
    element(
      $$renderer2,
      as,
      () => {
        $$renderer2.push(`${attributes({ ...$$restProps, class: clsx2(classes), style: styles }, "svelte-h657km")}`);
      },
      () => {
        $$renderer2.push(`<!--[-->`);
        slot($$renderer2, $$props, "default", {});
        $$renderer2.push(`<!--]-->`);
      }
    );
    bind_props($$props, { as, gap, align, justify, wrap: wrap2, className, style });
  });
}
function _page($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    const cards = [
      {
        mode: "view",
        title: "\u{1F441}\uFE0F View Mode",
        subtitle: "Explore curated map stories",
        description: "Browse featured collections, replay immersive stories, and discover historic overlays alongside modern basemaps.",
        features: [
          "Story gallery",
          "Auto-advance playback",
          "Bookmarks & saved stories"
        ]
      },
      {
        mode: "create",
        title: "\u270F\uFE0F Create Mode",
        subtitle: "Build your own narratives",
        description: "Capture scenes with annotations, manage overlays, and export interactive map stories tailored to your audience.",
        features: [
          "Annotation tools",
          "Scene capture & editing",
          "Export as JSON"
        ]
      }
    ];
    $$renderer2.push(`<main class="mode-selection svelte-1uha8ag">`);
    Container($$renderer2, {
      size: "xl",
      children: ($$renderer3) => {
        Stack($$renderer3, {
          gap: "var(--space-6)",
          align: "center",
          children: ($$renderer4) => {
            $$renderer4.push(`<div class="hero svelte-1uha8ag"><div class="logo svelte-1uha8ag"><span>VMA</span></div> <div class="hero-text svelte-1uha8ag"><h1 class="svelte-1uha8ag">Vietnam Map Archive</h1> <p class="svelte-1uha8ag">Experience and create map-based stories that connect the past with the present.</p></div></div> <div class="card-grid svelte-1uha8ag"><!--[-->`);
            const each_array = ensure_array_like(cards);
            for (let $$index_1 = 0, $$length = each_array.length; $$index_1 < $$length; $$index_1++) {
              let card = each_array[$$index_1];
              $$renderer4.push(`<button type="button" class="mode-card svelte-1uha8ag"><div class="card-content svelte-1uha8ag"><div><h2 class="svelte-1uha8ag">${escape_html(card.title)}</h2> <p class="subtitle svelte-1uha8ag">${escape_html(card.subtitle)}</p></div> <p class="description svelte-1uha8ag">${escape_html(card.description)}</p> <ul class="svelte-1uha8ag"><!--[-->`);
              const each_array_1 = ensure_array_like(card.features);
              for (let $$index = 0, $$length2 = each_array_1.length; $$index < $$length2; $$index++) {
                let feature = each_array_1[$$index];
                $$renderer4.push(`<li>${escape_html(feature)}</li>`);
              }
              $$renderer4.push(`<!--]--></ul> <span class="cta svelte-1uha8ag">Enter ${escape_html(card.mode === "view" ? "View" : "Create")} Mode</span></div></button>`);
            }
            $$renderer4.push(`<!--]--></div> <div class="links svelte-1uha8ag"><a href="/about" class="link svelte-1uha8ag" aria-disabled="true">About (coming soon)</a> <span class="divider svelte-1uha8ag" aria-hidden="true">\u2022</span> <a href="/signin" class="link svelte-1uha8ag" aria-disabled="true">Sign In (coming soon)</a></div>`);
          },
          $$slots: { default: true }
        });
      },
      $$slots: { default: true }
    });
    $$renderer2.push(`<!----></main>`);
  });
}
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_page.svelte.js"() {
    init_index2();
    init_internal();
    init_exports();
    init_utils();
    init_context();
    init_clsx();
    init_server();
    init_state_svelte();
    init_breakpoints();
    init_mode();
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  stylesheets: () => stylesheets5,
  universal: () => universal,
  universal_id: () => universal_id
});
var index5, component_cache5, component5, universal, universal_id, imports5, stylesheets5, fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    index5 = 4;
    component5 = async () => component_cache5 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default;
    universal = {
      "ssr": false
    };
    universal_id = "src/routes/+page.ts";
    imports5 = ["_app/immutable/nodes/4.DKNasrTJ.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/CVeh0obE.js", "_app/immutable/chunks/DmKfOTeo.js", "_app/immutable/chunks/Ch_7xMJZ.js", "_app/immutable/chunks/q2JeGk3q.js", "_app/immutable/chunks/D-pHkSQu.js", "_app/immutable/chunks/CyJPgw3D.js", "_app/immutable/chunks/CcWUXD1I.js", "_app/immutable/chunks/B62UVDqu.js"];
    stylesheets5 = ["_app/immutable/assets/breakpoints.yzSdU6gv.css", "_app/immutable/assets/4.BkziFlwD.css"];
    fonts5 = [];
  }
});

// node_modules/ol/console.js
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}
var levels, level;
var init_console = __esm({
  "node_modules/ol/console.js"() {
    levels = {
      info: 1,
      warn: 2,
      error: 3,
      none: 4
    };
    level = levels.info;
  }
});

// node_modules/ol/extent/Relationship.js
var Relationship_default;
var init_Relationship = __esm({
  "node_modules/ol/extent/Relationship.js"() {
    Relationship_default = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16
    };
  }
});

// node_modules/ol/extent.js
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function equals2(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent) {
  let area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getCorner(extent, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent);
  } else {
    throw new Error("Invalid corner");
  }
  return coordinate;
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function intersectsSegment(extent, start2, end) {
  let intersects2 = false;
  const startRel = coordinateRelationship(extent, start2);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects2 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start2[0];
    const startY = start2[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
    if (!intersects2 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
  }
  return intersects2;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates2.push(
        extent[0] + width * i / stops,
        extent[1],
        extent[2],
        extent[1] + height * i / stops,
        extent[2] - width * i / stops,
        extent[3],
        extent[0],
        extent[3] - height * i / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates2.length; i < l; i += 2) {
    xs.push(coordinates2[i]);
    ys.push(coordinates2[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}
function wrapAndSliceX(extent, projection, multiWorld) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth && !multiWorld) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}
var init_extent = __esm({
  "node_modules/ol/extent.js"() {
    init_Relationship();
  }
});

// node_modules/ol/math.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t2 = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t2 > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t2 > 0) {
      x1 += dx * t2;
      y1 += dy * t2;
    }
  }
  return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n2 = mat.length;
  for (let i = 0; i < n2; i++) {
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r3 = i + 1; r3 < n2; r3++) {
      const absValue = Math.abs(mat[r3][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r3;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;
    for (let j = i + 1; j < n2; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n2 + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  const x = new Array(n2);
  for (let l = n2 - 1; l >= 0; l--) {
    x[l] = mat[l][n2] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n2] -= mat[m][l] * x[l];
    }
  }
  return x;
}
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  const r3 = a % b;
  return r3 * b < 0 ? r3 + b : r3;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}
function toFixed(n2, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n2 * factor) / factor;
}
function floor(n2, decimals) {
  return Math.floor(toFixed(n2, decimals));
}
function ceil(n2, decimals) {
  return Math.ceil(toFixed(n2, decimals));
}
function wrap(n2, min, max) {
  if (n2 >= min && n2 < max) {
    return n2;
  }
  const range = max - min;
  return ((n2 - min) % range + range) % range + min;
}
var init_math = __esm({
  "node_modules/ol/math.js"() {
  }
});

// node_modules/ol/coordinate.js
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function equals3(coordinate1, coordinate2) {
  let equals5 = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals5 = false;
      break;
    }
  }
  return equals5;
}
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
var init_coordinate = __esm({
  "node_modules/ol/coordinate.js"() {
  }
});

// node_modules/ol/proj/Units.js
var METERS_PER_UNIT;
var init_Units = __esm({
  "node_modules/ol/proj/Units.js"() {
    METERS_PER_UNIT = {
      // use the radius of the Normal sphere
      "radians": 6370997 / (2 * Math.PI),
      "degrees": 2 * Math.PI * 6370997 / 360,
      "ft": 0.3048,
      "m": 1,
      "us-ft": 1200 / 3937
    };
  }
});

// node_modules/ol/proj/Projection.js
var Projection, Projection_default;
var init_Projection = __esm({
  "node_modules/ol/proj/Projection.js"() {
    init_Units();
    Projection = class {
      /**
       * @param {Options} options Projection options.
       */
      constructor(options2) {
        this.code_ = options2.code;
        this.units_ = /** @type {import("./Units.js").Units} */
        options2.units;
        this.extent_ = options2.extent !== void 0 ? options2.extent : null;
        this.worldExtent_ = options2.worldExtent !== void 0 ? options2.worldExtent : null;
        this.axisOrientation_ = options2.axisOrientation !== void 0 ? options2.axisOrientation : "enu";
        this.global_ = options2.global !== void 0 ? options2.global : false;
        this.canWrapX_ = !!(this.global_ && this.extent_);
        this.getPointResolutionFunc_ = options2.getPointResolution;
        this.defaultTileGrid_ = null;
        this.metersPerUnit_ = options2.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      canWrapX() {
        return this.canWrapX_;
      }
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      getCode() {
        return this.code_;
      }
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        return this.extent_;
      }
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").Units} Units.
       * @api
       */
      getUnits() {
        return this.units_;
      }
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      getMetersPerUnit() {
        return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
      }
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getWorldExtent() {
        return this.worldExtent_;
      }
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      getAxisOrientation() {
        return this.axisOrientation_;
      }
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      isGlobal() {
        return this.global_;
      }
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
      }
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      getDefaultTileGrid() {
        return this.defaultTileGrid_;
      }
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
      }
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
      }
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
      }
      /**
       * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
      }
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {GetPointResolution|undefined} The custom point
       * resolution function (if set).
       */
      getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
      }
    };
    Projection_default = Projection;
  }
});

// node_modules/ol/proj/epsg3857.js
function fromEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = HALF_SIZE * input[i] / 180;
    let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}
var RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, MAX_SAFE_Y, EPSG3857Projection, PROJECTIONS;
var init_epsg3857 = __esm({
  "node_modules/ol/proj/epsg3857.js"() {
    init_Projection();
    RADIUS = 6378137;
    HALF_SIZE = Math.PI * RADIUS;
    EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
    WORLD_EXTENT = [-180, -85, 180, 85];
    MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
    EPSG3857Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       */
      constructor(code) {
        super({
          code,
          units: "m",
          extent: EXTENT,
          global: true,
          worldExtent: WORLD_EXTENT,
          getPointResolution: function(resolution, point) {
            return resolution / Math.cosh(point[1] / RADIUS);
          }
        });
      }
    };
    PROJECTIONS = [
      new EPSG3857Projection("EPSG:3857"),
      new EPSG3857Projection("EPSG:102100"),
      new EPSG3857Projection("EPSG:102113"),
      new EPSG3857Projection("EPSG:900913"),
      new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
      new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
    ];
  }
});

// node_modules/ol/proj/epsg4326.js
var RADIUS2, EXTENT2, METERS_PER_UNIT2, EPSG4326Projection, PROJECTIONS2;
var init_epsg4326 = __esm({
  "node_modules/ol/proj/epsg4326.js"() {
    init_Projection();
    RADIUS2 = 6378137;
    EXTENT2 = [-180, -90, 180, 90];
    METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
    EPSG4326Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       * @param {string} [axisOrientation] Axis orientation.
       */
      constructor(code, axisOrientation) {
        super({
          code,
          units: "degrees",
          extent: EXTENT2,
          axisOrientation,
          global: true,
          metersPerUnit: METERS_PER_UNIT2,
          worldExtent: EXTENT2
        });
      }
    };
    PROJECTIONS2 = [
      new EPSG4326Projection("CRS:84"),
      new EPSG4326Projection("EPSG:4326", "neu"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
      new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
    ];
  }
});

// node_modules/ol/proj/projections.js
function get2(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add2(code, projection) {
  cache[code] = projection;
}
var cache;
var init_projections = __esm({
  "node_modules/ol/proj/projections.js"() {
    cache = {};
  }
});

// node_modules/ol/obj.js
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty2(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}
var init_obj = __esm({
  "node_modules/ol/obj.js"() {
  }
});

// node_modules/ol/proj/transforms.js
function add3(source2, destination, transformFn) {
  const sourceCode = source2.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get3(sourceCode, destinationCode) {
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    return transforms[sourceCode][destinationCode];
  }
  return null;
}
var transforms;
var init_transforms = __esm({
  "node_modules/ol/proj/transforms.js"() {
    transforms = {};
  }
});

// node_modules/ol/proj/utm.js
function toLonLat(easting, northing, zone) {
  const x = easting - 5e5;
  const y = zone.north ? northing : northing - 1e7;
  const m = y / K0;
  const mu = m / (R * M1);
  const pRad = mu + P2 * Math.sin(2 * mu) + P3 * Math.sin(4 * mu) + P4 * Math.sin(6 * mu) + P5 * Math.sin(8 * mu);
  const pSin = Math.sin(pRad);
  const pSin2 = pSin * pSin;
  const pCos = Math.cos(pRad);
  const pTan = pSin / pCos;
  const pTan2 = pTan * pTan;
  const pTan4 = pTan2 * pTan2;
  const epSin = 1 - E * pSin2;
  const epSinSqrt = Math.sqrt(1 - E * pSin2);
  const n2 = R / epSinSqrt;
  const r3 = (1 - E) / epSin;
  const c2 = E_P2 * pCos ** 2;
  const c22 = c2 * c2;
  const d = x / (n2 * K0);
  const d2 = d * d;
  const d3 = d2 * d;
  const d4 = d3 * d;
  const d5 = d4 * d;
  const d6 = d5 * d;
  const latitude = pRad - pTan / r3 * (d2 / 2 - d4 / 24 * (5 + 3 * pTan2 + 10 * c2 - 4 * c22 - 9 * E_P2)) + d6 / 720 * (61 + 90 * pTan2 + 298 * c2 + 45 * pTan4 - 252 * E_P2 - 3 * c22);
  let longitude = (d - d3 / 6 * (1 + 2 * pTan2 + c2) + d5 / 120 * (5 - 2 * c2 + 28 * pTan2 - 3 * c22 + 8 * E_P2 + 24 * pTan4)) / pCos;
  longitude = wrap(
    longitude + toRadians(zoneToCentralLongitude(zone.number)),
    -Math.PI,
    Math.PI
  );
  return [toDegrees(longitude), toDegrees(latitude)];
}
function fromLonLat(longitude, latitude, zone) {
  longitude = wrap(longitude, MIN_LONGITUDE, MAX_LONGITUDE);
  if (latitude < MIN_LATITUDE) {
    latitude = MIN_LATITUDE;
  } else if (latitude > MAX_LATITUDE) {
    latitude = MAX_LATITUDE;
  }
  const latRad = toRadians(latitude);
  const latSin = Math.sin(latRad);
  const latCos = Math.cos(latRad);
  const latTan = latSin / latCos;
  const latTan2 = latTan * latTan;
  const latTan4 = latTan2 * latTan2;
  const lonRad = toRadians(longitude);
  const centralLon = zoneToCentralLongitude(zone.number);
  const centralLonRad = toRadians(centralLon);
  const n2 = R / Math.sqrt(1 - E * latSin ** 2);
  const c2 = E_P2 * latCos ** 2;
  const a = latCos * wrap(lonRad - centralLonRad, -Math.PI, Math.PI);
  const a2 = a * a;
  const a3 = a2 * a;
  const a4 = a3 * a;
  const a5 = a4 * a;
  const a6 = a5 * a;
  const m = R * (M1 * latRad - M2 * Math.sin(2 * latRad) + M3 * Math.sin(4 * latRad) - M4 * Math.sin(6 * latRad));
  const easting = K0 * n2 * (a + a3 / 6 * (1 - latTan2 + c2) + a5 / 120 * (5 - 18 * latTan2 + latTan4 + 72 * c2 - 58 * E_P2)) + 5e5;
  let northing = K0 * (m + n2 * latTan * (a2 / 2 + a4 / 24 * (5 - latTan2 + 9 * c2 + 4 * c2 ** 2) + a6 / 720 * (61 - 58 * latTan2 + latTan4 + 600 * c2 - 330 * E_P2)));
  if (!zone.north) {
    northing += 1e7;
  }
  return [easting, northing];
}
function zoneToCentralLongitude(zone) {
  return (zone - 1) * 6 - 180 + 3;
}
function zoneFromCode(code) {
  let epsgId = 0;
  for (const re of epsgRegExes) {
    const match2 = code.match(re);
    if (match2) {
      epsgId = parseInt(match2[1]);
      break;
    }
  }
  if (!epsgId) {
    return null;
  }
  let number = 0;
  let north = false;
  if (epsgId > 32700 && epsgId < 32761) {
    number = epsgId - 32700;
  } else if (epsgId > 32600 && epsgId < 32661) {
    north = true;
    number = epsgId - 32600;
  }
  if (!number) {
    return null;
  }
  return { number, north };
}
function makeTransformFunction(transformer2, zone) {
  return function(input, output, dimension, stride) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    stride = stride ?? dimension;
    if (!output) {
      if (dimension > 2) {
        output = input.slice();
      } else {
        output = new Array(length);
      }
    }
    for (let i = 0; i < length; i += stride) {
      const x = input[i];
      const y = input[i + 1];
      const coord = transformer2(x, y, zone);
      output[i] = coord[0];
      output[i + 1] = coord[1];
    }
    return output;
  };
}
function makeProjection(code) {
  const zone = zoneFromCode(code);
  if (!zone) {
    return null;
  }
  return new Projection_default({ code, units: "m" });
}
function makeTransforms(projection) {
  const zone = zoneFromCode(projection.getCode());
  if (!zone) {
    return null;
  }
  return {
    forward: makeTransformFunction(fromLonLat, zone),
    inverse: makeTransformFunction(toLonLat, zone)
  };
}
var K0, E, E2, E3, E_P2, SQRT_E, _E, _E2, _E3, _E4, _E5, M1, M2, M3, M4, P2, P3, P4, P5, R, MIN_LATITUDE, MAX_LATITUDE, MIN_LONGITUDE, MAX_LONGITUDE, epsgRegExes;
var init_utm = __esm({
  "node_modules/ol/proj/utm.js"() {
    init_math();
    init_Projection();
    K0 = 0.9996;
    E = 669438e-8;
    E2 = E * E;
    E3 = E2 * E;
    E_P2 = E / (1 - E);
    SQRT_E = Math.sqrt(1 - E);
    _E = (1 - SQRT_E) / (1 + SQRT_E);
    _E2 = _E * _E;
    _E3 = _E2 * _E;
    _E4 = _E3 * _E;
    _E5 = _E4 * _E;
    M1 = 1 - E / 4 - 3 * E2 / 64 - 5 * E3 / 256;
    M2 = 3 * E / 8 + 3 * E2 / 32 + 45 * E3 / 1024;
    M3 = 15 * E2 / 256 + 45 * E3 / 1024;
    M4 = 35 * E3 / 3072;
    P2 = 3 / 2 * _E - 27 / 32 * _E3 + 269 / 512 * _E5;
    P3 = 21 / 16 * _E2 - 55 / 32 * _E4;
    P4 = 151 / 96 * _E3 - 417 / 128 * _E5;
    P5 = 1097 / 512 * _E4;
    R = 6378137;
    MIN_LATITUDE = -80;
    MAX_LATITUDE = 84;
    MIN_LONGITUDE = -180;
    MAX_LONGITUDE = 180;
    epsgRegExes = [
      /^EPSG:(\d+)$/,
      /^urn:ogc:def:crs:EPSG::(\d+)$/,
      /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
    ];
  }
});

// node_modules/ol/sphere.js
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
var DEFAULT_RADIUS;
var init_sphere = __esm({
  "node_modules/ol/sphere.js"() {
    init_math();
    DEFAULT_RADIUS = 63710088e-1;
  }
});

// node_modules/ol/proj.js
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function addProjection(projection) {
  add2(projection.getCode(), projection);
  add3(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get4(projectionLike) {
  if (!(typeof projectionLike === "string")) {
    return projectionLike;
  }
  const projection = get2(projectionLike);
  if (projection) {
    return projection;
  }
  for (const makeProjection2 of projectionFactories) {
    const projection2 = makeProjection2(projectionLike);
    if (projection2) {
      return projection2;
    }
  }
  return null;
}
function getPointResolution(projection, resolution, point, units) {
  projection = get4(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units || units == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(
        projection,
        get4("EPSG:4326")
      );
      if (!toEPSG43262 && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source2) {
    projections.forEach(function(destination) {
      if (source2 !== destination) {
        add3(source2, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add3(projection1, projection2, forwardTransform);
      add3(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get4(defaultCode);
  }
  if (typeof projection === "string") {
    return get4(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimensions that should be transformed.
     * @param {number} [stride] Stride.
     * @return {Array<number>} Output.
     */
    function(input, output, dimension, stride) {
      const length = input.length;
      dimension = dimension !== void 0 ? dimension : 2;
      stride = stride ?? dimension;
      output = output !== void 0 ? output : new Array(length);
      for (let i = 0; i < length; i += stride) {
        const point = coordTransform(input.slice(i, i + dimension));
        const pointLength = point.length;
        for (let j = 0, jj = stride; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}
function fromLonLat2(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    "EPSG:4326",
    projection !== void 0 ? projection : "EPSG:3857"
  );
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(source2, destination) {
  const sourceCode = source2.getCode();
  const destinationCode = destination.getCode();
  let transformFunc = get3(sourceCode, destinationCode);
  if (transformFunc) {
    return transformFunc;
  }
  let sourceTransforms = null;
  let destinationTransforms = null;
  for (const makeTransforms2 of transformFactories) {
    if (!sourceTransforms) {
      sourceTransforms = makeTransforms2(source2);
    }
    if (!destinationTransforms) {
      destinationTransforms = makeTransforms2(destination);
    }
  }
  if (!sourceTransforms && !destinationTransforms) {
    return null;
  }
  const intermediateCode = "EPSG:4326";
  if (!destinationTransforms) {
    const toDestination = get3(intermediateCode, destinationCode);
    if (toDestination) {
      transformFunc = composeTransformFuncs(
        sourceTransforms.inverse,
        toDestination
      );
    }
  } else if (!sourceTransforms) {
    const fromSource = get3(sourceCode, intermediateCode);
    if (fromSource) {
      transformFunc = composeTransformFuncs(
        fromSource,
        destinationTransforms.forward
      );
    }
  } else {
    transformFunc = composeTransformFuncs(
      sourceTransforms.inverse,
      destinationTransforms.forward
    );
  }
  if (transformFunc) {
    addProjection(source2);
    addProjection(destination);
    add3(source2, destination, transformFunc);
  }
  return transformFunc;
}
function composeTransformFuncs(t1, t2) {
  return function(input, output, dimensions, stride) {
    output = t1(input, output, dimensions, stride);
    return t2(output, output, dimensions, stride);
  };
}
function getTransform(source2, destination) {
  const sourceProjection = get4(source2);
  const destinationProjection = get4(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source2, destination) {
  const transformFunc = getTransform(source2, destination);
  if (!transformFunc) {
    const sourceCode = get4(source2).getCode();
    const destinationCode = get4(destination).getCode();
    throw new Error(
      `No transform available between ${sourceCode} and ${destinationCode}`
    );
  }
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source2, destination, stops) {
  const transformFunc = getTransform(source2, destination);
  return applyTransform(extent, transformFunc, void 0, stops);
}
function getUserProjection() {
  return userProjection;
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals3(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
var transformFactories, projectionFactories, showCoordinateWarning, userProjection;
var init_proj = __esm({
  "node_modules/ol/proj.js"() {
    init_console();
    init_coordinate();
    init_extent();
    init_Units();
    init_epsg3857();
    init_epsg4326();
    init_projections();
    init_transforms();
    init_utm();
    init_sphere();
    transformFactories = [makeTransforms];
    projectionFactories = [makeProjection];
    showCoordinateWarning = true;
    userProjection = null;
    addCommon();
  }
});

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default;
var init_ObjectEventType = __esm({
  "node_modules/ol/ObjectEventType.js"() {
    ObjectEventType_default = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: "propertychange"
    };
  }
});

// node_modules/ol/events/EventType.js
var EventType_default;
var init_EventType = __esm({
  "node_modules/ol/events/EventType.js"() {
    EventType_default = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: "change",
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: "error",
      BLUR: "blur",
      CLEAR: "clear",
      CONTEXTMENU: "contextmenu",
      CLICK: "click",
      DBLCLICK: "dblclick",
      DRAGENTER: "dragenter",
      DRAGOVER: "dragover",
      DROP: "drop",
      FOCUS: "focus",
      KEYDOWN: "keydown",
      KEYPRESS: "keypress",
      LOAD: "load",
      RESIZE: "resize",
      TOUCHMOVE: "touchmove",
      WHEEL: "wheel"
    };
  }
});

// node_modules/ol/Disposable.js
var Disposable, Disposable_default;
var init_Disposable = __esm({
  "node_modules/ol/Disposable.js"() {
    Disposable = class {
      constructor() {
        this.disposed = false;
      }
      /**
       * Clean up.
       */
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.disposeInternal();
        }
      }
      /**
       * Extension point for disposable objects.
       * @protected
       */
      disposeInternal() {
      }
    };
    Disposable_default = Disposable;
  }
});

// node_modules/ol/array.js
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n2 = arr.length;
  if (target <= arr[n2 - 1]) {
    return n2 - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n2; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n2 - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n2; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n2 - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n2; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n2 - 1;
  }
  for (let i = 1; i < n2; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n2 - 1;
}
function extend2(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function equals4(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index8) {
    if (index8 === 0) {
      return true;
    }
    const res = compare(arr[index8 - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}
var init_array = __esm({
  "node_modules/ol/array.js"() {
  }
});

// node_modules/ol/functions.js
function VOID() {
}
function memoizeOne(fn) {
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!lastArgs || this !== lastThis || !equals4(nextArgs, lastArgs)) {
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
var init_functions = __esm({
  "node_modules/ol/functions.js"() {
    init_array();
  }
});

// node_modules/ol/events/Event.js
var BaseEvent, Event_default;
var init_Event = __esm({
  "node_modules/ol/events/Event.js"() {
    BaseEvent = class {
      /**
       * @param {string} type Type.
       */
      constructor(type) {
        this.propagationStopped;
        this.defaultPrevented;
        this.type = type;
        this.target = null;
      }
      /**
       * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
       * will be fired.
       * @api
       */
      preventDefault() {
        this.defaultPrevented = true;
      }
      /**
       * Stop event propagation.
       * @api
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
    Event_default = BaseEvent;
  }
});

// node_modules/ol/events/Target.js
var Target, Target_default;
var init_Target = __esm({
  "node_modules/ol/events/Target.js"() {
    init_Disposable();
    init_functions();
    init_obj();
    init_Event();
    Target = class extends Disposable_default {
      /**
       * @param {*} [target] Default event target for dispatched events.
       */
      constructor(target) {
        super();
        this.eventTarget_ = target;
        this.pendingRemovals_ = null;
        this.dispatching_ = null;
        this.listeners_ = null;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      addEventListener(type, listener) {
        if (!type || !listener) {
          return;
        }
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) {
          listenersForType.push(listener);
        }
      }
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      dispatchEvent(event) {
        const isString = typeof event === "string";
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
          return;
        }
        const evt = isString ? new Event_default(event) : (
          /** @type {Event} */
          event
        );
        if (!evt.target) {
          evt.target = this.eventTarget_ || this;
        }
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
          dispatching[type] = 0;
          pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for (let i = 0, ii = listeners.length; i < ii; ++i) {
          if ("handleEvent" in listeners[i]) {
            propagate = /** @type {import("../events.js").ListenerObject} */
            listeners[i].handleEvent(evt);
          } else {
            propagate = /** @type {import("../events.js").ListenerFunction} */
            listeners[i].call(this, evt);
          }
          if (propagate === false || evt.propagationStopped) {
            propagate = false;
            break;
          }
        }
        if (--dispatching[type] === 0) {
          let pr = pendingRemovals[type];
          delete pendingRemovals[type];
          while (pr--) {
            this.removeEventListener(type, VOID);
          }
          delete dispatching[type];
        }
        return propagate;
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        this.listeners_ && clear(this.listeners_);
      }
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      getListeners(type) {
        return this.listeners_ && this.listeners_[type] || void 0;
      }
      /**
       * @param {string} [type] Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      hasListener(type) {
        if (!this.listeners_) {
          return false;
        }
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      removeEventListener(type, listener) {
        if (!this.listeners_) {
          return;
        }
        const listeners = this.listeners_[type];
        if (!listeners) {
          return;
        }
        const index8 = listeners.indexOf(listener);
        if (index8 !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            listeners[index8] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index8, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    };
    Target_default = Target;
  }
});

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once2) {
  if (once2) {
    const originalListener = listener;
    listener = function(event) {
      target.removeEventListener(type, listener);
      return originalListener.call(thisArg ?? this, event);
    };
  } else if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key2) {
  if (key2 && key2.target) {
    key2.target.removeEventListener(key2.type, key2.listener);
    clear(key2);
  }
}
var init_events = __esm({
  "node_modules/ol/events.js"() {
    init_obj();
  }
});

// node_modules/ol/Observable.js
function unByKey(key2) {
  if (Array.isArray(key2)) {
    for (let i = 0, ii = key2.length; i < ii; ++i) {
      unlistenByKey(key2[i]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key2
    );
  }
}
var Observable, Observable_default;
var init_Observable = __esm({
  "node_modules/ol/Observable.js"() {
    init_EventType();
    init_Target();
    init_events();
    Observable = class extends Target_default {
      constructor() {
        super();
        this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onInternal;
        this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onceInternal;
        this.un = /** @type {ObservableOnSignature<void>} */
        this.unInternal;
        this.revision_ = 0;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      changed() {
        ++this.revision_;
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      getRevision() {
        return this.revision_;
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onInternal(type, listener) {
        if (Array.isArray(type)) {
          const len = type.length;
          const keys = new Array(len);
          for (let i = 0; i < len; ++i) {
            keys[i] = listen(this, type[i], listener);
          }
          return keys;
        }
        return listen(
          this,
          /** @type {string} */
          type,
          listener
        );
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onceInternal(type, listener) {
        let key2;
        if (Array.isArray(type)) {
          const len = type.length;
          key2 = new Array(len);
          for (let i = 0; i < len; ++i) {
            key2[i] = listenOnce(this, type[i], listener);
          }
        } else {
          key2 = listenOnce(
            this,
            /** @type {string} */
            type,
            listener
          );
        }
        listener.ol_key = key2;
        return key2;
      }
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @protected
       */
      unInternal(type, listener) {
        const key2 = (
          /** @type {Object} */
          listener.ol_key
        );
        if (key2) {
          unByKey(key2);
        } else if (Array.isArray(type)) {
          for (let i = 0, ii = type.length; i < ii; ++i) {
            this.removeEventListener(type[i], listener);
          }
        } else {
          this.removeEventListener(type, listener);
        }
      }
    };
    Observable.prototype.on;
    Observable.prototype.once;
    Observable.prototype.un;
    Observable_default = Observable;
  }
});

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var uidCounter_;
var init_util = __esm({
  "node_modules/ol/util.js"() {
    uidCounter_ = 0;
  }
});

// node_modules/ol/Object.js
var ObjectEvent, BaseObject, Object_default;
var init_Object = __esm({
  "node_modules/ol/Object.js"() {
    init_ObjectEventType();
    init_Observable();
    init_Event();
    init_obj();
    init_util();
    ObjectEvent = class extends Event_default {
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      constructor(type, key2, oldValue) {
        super(type);
        this.key = key2;
        this.oldValue = oldValue;
      }
    };
    BaseObject = class extends Observable_default {
      /**
       * @param {Object<string, *>} [values] An object with key-value pairs.
       */
      constructor(values) {
        super();
        this.on;
        this.once;
        this.un;
        getUid(this);
        this.values_ = null;
        if (values !== void 0) {
          this.setProperties(values);
        }
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      get(key2) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key2)) {
          value = this.values_[key2];
        }
        return value;
      }
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.values_;
      }
      /**
       * @return {boolean} The object has properties.
       */
      hasProperties() {
        return !!this.values_;
      }
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      notify(key2, oldValue) {
        let eventType;
        eventType = `change:${key2}`;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key2, oldValue));
        }
        eventType = ObjectEventType_default.PROPERTYCHANGE;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key2, oldValue));
        }
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      addChangeListener(key2, listener) {
        this.addEventListener(`change:${key2}`, listener);
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      removeChangeListener(key2, listener) {
        this.removeEventListener(`change:${key2}`, listener);
      }
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      set(key2, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) {
          values[key2] = value;
        } else {
          const oldValue = values[key2];
          values[key2] = value;
          if (oldValue !== value) {
            this.notify(key2, oldValue);
          }
        }
      }
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      setProperties(values, silent) {
        for (const key2 in values) {
          this.set(key2, values[key2], silent);
        }
      }
      /**
       * Apply any properties from another object without triggering events.
       * @param {BaseObject} source The source object.
       * @protected
       */
      applyProperties(source2) {
        if (!source2.values_) {
          return;
        }
        Object.assign(this.values_ || (this.values_ = {}), source2.values_);
      }
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean} [silent] Unset without triggering an event.
       * @api
       */
      unset(key2, silent) {
        if (this.values_ && key2 in this.values_) {
          const oldValue = this.values_[key2];
          delete this.values_[key2];
          if (isEmpty2(this.values_)) {
            this.values_ = null;
          }
          if (!silent) {
            this.notify(key2, oldValue);
          }
        }
      }
    };
    Object_default = BaseObject;
  }
});

// node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
var init_asserts = __esm({
  "node_modules/ol/asserts.js"() {
  }
});

// node_modules/ol/Feature.js
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(
      typeof /** @type {?} */
      obj.getZIndex === "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    );
    const style = (
      /** @type {import("./style/Style.js").default} */
      obj
    );
    styles = [style];
  }
  return function() {
    return styles;
  };
}
var Feature, Feature_default;
var init_Feature = __esm({
  "node_modules/ol/Feature.js"() {
    init_Object();
    init_asserts();
    init_EventType();
    init_events();
    Feature = class _Feature extends Object_default {
      /**
       * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
       *     You may pass a Geometry object directly, or an object literal containing
       *     properties. If you pass an object literal, you may include a Geometry
       *     associated with a `geometry` key.
       */
      constructor(geometryOrProperties) {
        super();
        this.on;
        this.once;
        this.un;
        this.id_ = void 0;
        this.geometryName_ = "geometry";
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
          if (typeof /** @type {?} */
          geometryOrProperties.getSimplifiedGeometry === "function") {
            const geometry = (
              /** @type {Geometry} */
              geometryOrProperties
            );
            this.setGeometry(geometry);
          } else {
            const properties = geometryOrProperties;
            this.setProperties(properties);
          }
        }
      }
      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {Feature<Geometry>} The clone.
       * @api
       */
      clone() {
        const clone = (
          /** @type {Feature<Geometry>} */
          new _Feature(this.hasProperties() ? this.getProperties() : null)
        );
        clone.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) {
          clone.setGeometry(
            /** @type {Geometry} */
            geometry.clone()
          );
        }
        const style = this.getStyle();
        if (style) {
          clone.setStyle(style);
        }
        return clone;
      }
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      getGeometry() {
        return (
          /** @type {Geometry|undefined} */
          this.get(this.geometryName_)
        );
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      getGeometryName() {
        return this.geometryName_;
      }
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @private
       */
      handleGeometryChange_() {
        this.changed();
      }
      /**
       * @private
       */
      handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
          unlistenByKey(this.geometryChangeKey_);
          this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) {
          this.geometryChangeKey_ = listen(
            geometry,
            EventType_default.CHANGE,
            this.handleGeometryChange_,
            this
          );
        }
        this.changed();
      }
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
      }
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
        this.changed();
      }
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setId(id) {
        this.id_ = id;
        this.changed();
      }
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
      }
    };
    Feature_default = Feature;
  }
});

// node_modules/ol/transform.js
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function apply(transform3, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform3[0] * x + transform3[2] * y + transform3[4];
  coordinate[1] = transform3[1] * x + transform3[3] * y + transform3[5];
  return coordinate;
}
function compose(transform3, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform3[0] = sx * cos;
  transform3[1] = sy * sin;
  transform3[2] = -sx * sin;
  transform3[3] = sy * cos;
  transform3[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform3[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform3;
}
function makeInverse(target, source2) {
  const det = determinant(source2);
  assert(det !== 0, "Transformation matrix cannot be inverted");
  const a = source2[0];
  const b = source2[1];
  const c2 = source2[2];
  const d = source2[3];
  const e3 = source2[4];
  const f = source2[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c2 / det;
  target[3] = a / det;
  target[4] = (c2 * f - d * e3) / det;
  target[5] = -(a * f - b * e3) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
function toString(mat) {
  const transformString = "matrix(" + mat.join(", ") + ")";
  return transformString;
}
function fromString(cssTransform) {
  const values = cssTransform.substring(7, cssTransform.length - 1).split(",");
  return values.map(parseFloat);
}
function equivalent2(cssTransform1, cssTransform2) {
  const mat1 = fromString(cssTransform1);
  const mat2 = fromString(cssTransform2);
  for (let i = 0; i < 6; ++i) {
    if (Math.round((mat1[i] - mat2[i]) * matrixPrecision[i]) !== 0) {
      return false;
    }
  }
  return true;
}
var tmp_, matrixPrecision;
var init_transform = __esm({
  "node_modules/ol/transform.js"() {
    init_asserts();
    tmp_ = new Array(6);
    matrixPrecision = [1e5, 1e5, 1e5, 1e5, 2, 2];
  }
});

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset, end, stride, transform3, dest, destinationStride) {
  dest = dest ? dest : [];
  destinationStride = destinationStride ? destinationStride : 2;
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform3[0] * x + transform3[2] * y + transform3[4];
    dest[i++] = transform3[1] * x + transform3[3] * y + transform3[5];
    for (let k = 2; k < destinationStride; k++) {
      dest[i++] = flatCoordinates[j + k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate2(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
var init_transform2 = __esm({
  "node_modules/ol/geom/flat/transform.js"() {
  }
});

// node_modules/ol/geom/Geometry.js
var tmpTransform, tmpPoint, Geometry, Geometry_default;
var init_Geometry = __esm({
  "node_modules/ol/geom/Geometry.js"() {
    init_Object();
    init_extent();
    init_functions();
    init_proj();
    init_transform();
    init_util();
    init_transform2();
    tmpTransform = create();
    tmpPoint = [NaN, NaN];
    Geometry = class extends Object_default {
      constructor() {
        super();
        this.extent_ = createEmpty();
        this.extentRevision_ = -1;
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = 0;
        this.simplifyTransformedInternal = memoizeOne(
          (revision, squaredTolerance, transform3) => {
            if (!transform3) {
              return this.getSimplifiedGeometry(squaredTolerance);
            }
            const clone = this.clone();
            clone.applyTransform(transform3);
            return clone.getSimplifiedGeometry(squaredTolerance);
          }
        );
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform3) {
        return this.simplifyTransformedInternal(
          this.getRevision(),
          squaredTolerance,
          transform3
        );
      }
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */
      clone() {
        return abstract();
      }
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        return abstract();
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        return this.closestPointXY(x, y, tmpPoint, Number.MIN_VALUE) === 0;
      }
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */
      getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [NaN, NaN];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
      }
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
      }
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return abstract();
      }
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */
      getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
          const extent2 = this.computeExtent(this.extent_);
          if (isNaN(extent2[0]) || isNaN(extent2[1])) {
            createOrUpdateEmpty(extent2);
          }
          this.extentRevision_ = this.getRevision();
        }
        return returnOrUpdate(this.extent_, extent);
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        abstract();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      scale(sx, sy, anchor) {
        abstract();
      }
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */
      simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return abstract();
      }
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {Type} Geometry type.
       */
      getType() {
        return abstract();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */
      applyTransform(transformFn) {
        abstract();
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      intersectsExtent(extent) {
        return abstract();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      translate(deltaX, deltaY) {
        abstract();
      }
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {this} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      transform(source2, destination) {
        const sourceProj = get4(source2);
        const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
          const pixelExtent = sourceProj.getExtent();
          const projectedExtent = sourceProj.getWorldExtent();
          const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform,
            projectedExtent[0],
            projectedExtent[3],
            scale4,
            -scale4,
            0,
            0,
            0
          );
          const transformed = transform2D(
            inCoordinates,
            0,
            inCoordinates.length,
            stride,
            tmpTransform,
            outCoordinates
          );
          const projTransform = getTransform(sourceProj, destination);
          if (projTransform) {
            return projTransform(transformed, transformed, stride);
          }
          return transformed;
        } : getTransform(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
      }
    };
    Geometry_default = Geometry;
  }
});

// node_modules/ol/geom/SimpleGeometry.js
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
var SimpleGeometry, SimpleGeometry_default;
var init_SimpleGeometry = __esm({
  "node_modules/ol/geom/SimpleGeometry.js"() {
    init_extent();
    init_util();
    init_Geometry();
    init_transform2();
    SimpleGeometry = class extends Geometry_default {
      constructor() {
        super();
        this.layout = "XY";
        this.stride = 2;
        this.flatCoordinates;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        return createOrUpdateFromFlatCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent
        );
      }
      /**
       * @abstract
       * @return {Array<*> | null} Coordinates.
       */
      getCoordinates() {
        return abstract();
      }
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */
      getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getFlatCoordinates() {
        return this.flatCoordinates;
      }
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */
      getLastCoordinate() {
        return this.flatCoordinates.slice(
          this.flatCoordinates.length - this.stride
        );
      }
      /**
       * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
       * @return {import("./Geometry.js").GeometryLayout} Layout.
       * @api
       */
      getLayout() {
        return this.layout;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @override
       */
      getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }
        const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
          return simplifiedGeometry;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride;
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */
      setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
      }
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      setCoordinates(coordinates2, layout) {
        abstract();
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      setLayout(layout, coordinates2, nesting) {
        let stride;
        if (layout) {
          stride = getStrideForLayout(layout);
        } else {
          for (let i = 0; i < nesting; ++i) {
            if (coordinates2.length === 0) {
              this.layout = "XY";
              this.stride = 2;
              return;
            }
            coordinates2 = /** @type {Array<unknown>} */
            coordinates2[0];
          }
          stride = coordinates2.length;
          layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       * @override
       */
      applyTransform(transformFn) {
        if (this.flatCoordinates) {
          transformFn(
            this.flatCoordinates,
            this.flatCoordinates,
            this.layout.startsWith("XYZ") ? 3 : 2,
            this.stride
          );
          this.changed();
        }
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       * @override
       */
      rotate(angle, anchor) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          rotate2(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            angle,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       * @override
       */
      scale(sx, sy, anchor) {
        if (sy === void 0) {
          sy = sx;
        }
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          scale(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            sx,
            sy,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       * @override
       */
      translate(deltaX, deltaY) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          translate(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            deltaX,
            deltaY,
            flatCoordinates
          );
          this.changed();
        }
      }
    };
    SimpleGeometry_default = SimpleGeometry;
  }
});

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, endss) {
  endss = endss ? endss : [];
  let i = 0;
  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {
    const ends = deflateCoordinatesArray(
      flatCoordinates,
      offset,
      coordinatesss[j],
      stride,
      endss[i]
    );
    if (ends.length === 0) {
      ends[0] = offset;
    }
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}
var init_deflate = __esm({
  "node_modules/ol/geom/flat/deflate.js"() {
  }
});

// node_modules/ol/geom/flat/center.js
function linearRingss(flatCoordinates, offset, endss, stride) {
  const flatCenters = [];
  let extent = createEmpty();
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    extent = createOrUpdateFromFlatCoordinates(
      flatCoordinates,
      offset,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}
var init_center = __esm({
  "node_modules/ol/geom/flat/center.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}
var init_contains = __esm({
  "node_modules/ol/geom/flat/contains.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r3 = 0, rr = ends.length; r3 < rr; ++r3) {
    const end = ends[r3];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  let interiorPoints = [];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      flatCenters,
      2 * i,
      interiorPoints
    );
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}
var init_interiorpoint = __esm({
  "node_modules/ol/geom/flat/interiorpoint.js"() {
    init_array();
    init_contains();
  }
});

// node_modules/ol/geom/flat/interpolate.js
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
  let o2, t2;
  const n2 = (end - offset) / stride;
  if (n2 === 1) {
    o2 = offset;
  } else if (n2 === 2) {
    o2 = offset;
    t2 = fraction;
  } else if (n2 !== 0) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i = offset + stride; i < end; i += stride) {
      const x2 = flatCoordinates[i];
      const y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    const target = fraction * length;
    const index8 = binarySearch(cumulativeLengths, target);
    if (index8 < 0) {
      t2 = (target - cumulativeLengths[-index8 - 2]) / (cumulativeLengths[-index8 - 1] - cumulativeLengths[-index8 - 2]);
      o2 = offset + (-index8 - 2) * stride;
    } else {
      o2 = offset + index8 * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i = 0; i < dimension; ++i) {
    dest[i] = o2 === void 0 ? NaN : t2 === void 0 ? flatCoordinates[o2 + i] : lerp(flatCoordinates[o2 + i], flatCoordinates[o2 + stride + i], t2);
  }
  return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }
  let coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  let lo = offset / stride;
  let hi = end / stride;
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  const m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  const m1 = flatCoordinates[(lo + 1) * stride - 1];
  const t2 = (m - m0) / (m1 - m0);
  coordinate = [];
  for (let i = 0; i < stride - 1; ++i) {
    coordinate.push(
      lerp(
        flatCoordinates[(lo - 1) * stride + i],
        flatCoordinates[lo * stride + i],
        t2
      )
    );
  }
  coordinate.push(m);
  return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates,
      offset,
      ends[ends.length - 1],
      stride,
      m,
      extrapolate
    );
  }
  let coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    }
    if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates,
        offset,
        end,
        stride,
        m,
        false
      );
    }
    offset = end;
  }
  return null;
}
var init_interpolate = __esm({
  "node_modules/ol/geom/flat/interpolate.js"() {
    init_array();
    init_math();
  }
});

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}
var init_reverse = __esm({
  "node_modules/ol/geom/flat/reverse.js"() {
  }
});

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}
function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(
      flatCoordinates,
      offset,
      endss[i],
      stride,
      right
    );
  }
  return offset;
}
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset = 0;
  let prevEndIndex = 0;
  let startOrientation;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
    if (startOrientation === void 0) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset = end;
  }
  return endss;
}
var init_orient = __esm({
  "node_modules/ol/geom/flat/orient.js"() {
    init_reverse();
  }
});

// node_modules/ol/geom/flat/simplify.js
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n2 = (end - offset) / stride;
  if (n2 < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n2);
  markers[0] = 1;
  markers[n2 - 1] = 1;
  const stack = [offset, end - stride];
  let index8 = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance3 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance3 > maxSquaredDistance) {
        index8 = i;
        maxSquaredDistance = squaredDistance3;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index8 - offset) / stride] = 1;
      if (first + stride < index8) {
        stack.push(first, index8);
      }
      if (index8 + stride < last) {
        stack.push(index8, last);
      }
    }
  }
  for (let i = 0; i < n2; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    const x3 = snap(flatCoordinates[offset], tolerance);
    const y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
var init_simplify = __esm({
  "node_modules/ol/geom/flat/simplify.js"() {
    init_math();
  }
});

// node_modules/ol/geom/GeometryCollection.js
function cloneGeometries(geometries) {
  return geometries.map((geometry) => geometry.clone());
}
var GeometryCollection, GeometryCollection_default;
var init_GeometryCollection = __esm({
  "node_modules/ol/geom/GeometryCollection.js"() {
    init_EventType();
    init_events();
    init_extent();
    init_Geometry();
    GeometryCollection = class _GeometryCollection extends Geometry_default {
      /**
       * @param {Array<Geometry>} geometries Geometries.
       */
      constructor(geometries) {
        super();
        this.geometries_ = geometries;
        this.changeEventsKeys_ = [];
        this.listenGeometriesChange_();
      }
      /**
       * @private
       */
      unlistenGeometriesChange_() {
        this.changeEventsKeys_.forEach(unlistenByKey);
        this.changeEventsKeys_.length = 0;
      }
      /**
       * @private
       */
      listenGeometriesChange_() {
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          this.changeEventsKeys_.push(
            listen(geometries[i], EventType_default.CHANGE, this.changed, this)
          );
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!GeometryCollection} Clone.
       * @api
       * @override
       */
      clone() {
        const geometryCollection = new _GeometryCollection(
          cloneGeometries(this.geometries_)
        );
        geometryCollection.applyProperties(this);
        return geometryCollection;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          minSquaredDistance = geometries[i].closestPointXY(
            x,
            y,
            closestPoint,
            minSquaredDistance
          );
        }
        return minSquaredDistance;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x, y) {
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          if (geometries[i].containsXY(x, y)) {
            return true;
          }
        }
        return false;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        createOrUpdateEmpty(extent);
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          extend(extent, geometries[i].getExtent());
        }
        return extent;
      }
      /**
       * Return the geometries that make up this geometry collection.
       * @return {Array<Geometry>} Geometries.
       * @api
       */
      getGeometries() {
        return cloneGeometries(this.geometries_);
      }
      /**
       * @return {Array<Geometry>} Geometries.
       */
      getGeometriesArray() {
        return this.geometries_;
      }
      /**
       * @return {Array<Geometry>} Geometries.
       */
      getGeometriesArrayRecursive() {
        let geometriesArray = [];
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          if (geometries[i].getType() === this.getType()) {
            geometriesArray = geometriesArray.concat(
              /** @type {GeometryCollection} */
              geometries[i].getGeometriesArrayRecursive()
            );
          } else {
            geometriesArray.push(geometries[i]);
          }
        }
        return geometriesArray;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {GeometryCollection} Simplified GeometryCollection.
       * @override
       */
      getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }
        const simplifiedGeometries = [];
        const geometries = this.geometries_;
        let simplified = false;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          const geometry = geometries[i];
          const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
          simplifiedGeometries.push(simplifiedGeometry);
          if (simplifiedGeometry !== geometry) {
            simplified = true;
          }
        }
        if (simplified) {
          const simplifiedGeometryCollection = new _GeometryCollection(
            simplifiedGeometries
          );
          return simplifiedGeometryCollection;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "GeometryCollection";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          if (geometries[i].intersectsExtent(extent)) {
            return true;
          }
        }
        return false;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return this.geometries_.length === 0;
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       * @override
       */
      rotate(angle, anchor) {
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          geometries[i].rotate(angle, anchor);
        }
        this.changed();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       * @override
       */
      scale(sx, sy, anchor) {
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          geometries[i].scale(sx, sy, anchor);
        }
        this.changed();
      }
      /**
       * Set the geometries that make up this geometry collection.
       * @param {Array<Geometry>} geometries Geometries.
       * @api
       */
      setGeometries(geometries) {
        this.setGeometriesArray(cloneGeometries(geometries));
      }
      /**
       * @param {Array<Geometry>} geometries Geometries.
       */
      setGeometriesArray(geometries) {
        this.unlistenGeometriesChange_();
        this.geometries_ = geometries;
        this.listenGeometriesChange_();
        this.changed();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       * @override
       */
      applyTransform(transformFn) {
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          geometries[i].applyTransform(transformFn);
        }
        this.changed();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       * @override
       */
      translate(deltaX, deltaY) {
        const geometries = this.geometries_;
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          geometries[i].translate(deltaX, deltaY);
        }
        this.changed();
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        this.unlistenGeometriesChange_();
        super.disposeInternal();
      }
    };
    GeometryCollection_default = GeometryCollection;
  }
});

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  const x0 = flatCoordinates[end - stride];
  const y0 = flatCoordinates[end - stride + 1];
  let dx1 = 0;
  let dy1 = 0;
  for (; offset < end; offset += stride) {
    const dx2 = flatCoordinates[offset] - x0;
    const dy2 = flatCoordinates[offset + 1] - y0;
    twiceArea += dy1 * dx2 - dx1 * dy2;
    dx1 = dx2;
    dy1 = dy2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}
function linearRingss2(flatCoordinates, offset, endss, stride) {
  let area = 0;
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}
var init_area = __esm({
  "node_modules/ol/geom/flat/area.js"() {
  }
});

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t2 = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t2 > 1) {
      offset = offset2;
    } else if (t2 > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t2
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    const squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing2, x, y, closestPoint, minSquaredDistance, tmpPoint2) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance3;
  if (maxDelta === 0) {
    squaredDistance3 = squaredDistance(
      x,
      y,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance3 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance3;
    }
    return minSquaredDistance;
  }
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  let index8 = offset + stride;
  while (index8 < end) {
    assignClosest(
      flatCoordinates,
      index8 - stride,
      index8,
      stride,
      x,
      y,
      tmpPoint2
    );
    squaredDistance3 = squaredDistance(x, y, tmpPoint2[0], tmpPoint2[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint2[i];
      }
      closestPoint.length = stride;
      index8 += stride;
    } else {
      index8 += stride * Math.max(
        (Math.sqrt(squaredDistance3) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing2) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x,
      y,
      tmpPoint2
    );
    squaredDistance3 = squaredDistance(x, y, tmpPoint2[0], tmpPoint2[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint2[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing2, x, y, closestPoint, minSquaredDistance, tmpPoint2) {
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing2,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint2
    );
    offset = end;
  }
  return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing2, x, y, closestPoint, minSquaredDistance, tmpPoint2) {
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates,
      offset,
      ends,
      stride,
      maxDelta,
      isRing2,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint2
    );
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}
var init_closest = __esm({
  "node_modules/ol/geom/flat/closest.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i]
    );
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      coordinatesss[i]
    );
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}
var init_inflate = __esm({
  "node_modules/ol/geom/flat/inflate.js"() {
  }
});

// node_modules/ol/geom/LinearRing.js
var LinearRing, LinearRing_default;
var init_LinearRing = __esm({
  "node_modules/ol/geom/LinearRing.js"() {
    init_extent();
    init_SimpleGeometry();
    init_area();
    init_closest();
    init_deflate();
    init_inflate();
    init_simplify();
    LinearRing = class _LinearRing extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LinearRing} Clone.
       * @api
       * @override
       */
      clone() {
        return new _LinearRing(this.flatCoordinates.slice(), this.layout);
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRing(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LinearRing(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "LinearRing";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return false;
      }
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LinearRing_default = LinearRing;
  }
});

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}
var init_segments = __esm({
  "node_modules/ol/geom/flat/segments.js"() {
  }
});

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset, end, stride, extent, coordinatesExtent) {
  coordinatesExtent = coordinatesExtent ?? extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2] || coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }
    offset = ends[i];
  }
  return false;
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i - 1],
      ends[i],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}
var init_intersectsextent = __esm({
  "node_modules/ol/geom/flat/intersectsextent.js"() {
    init_extent();
    init_contains();
    init_segments();
  }
});

// node_modules/ol/geom/flat/length.js
function lineStringLength(flatCoordinates, offset, end, stride) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  let length = 0;
  for (let i = offset + stride; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}
var init_length = __esm({
  "node_modules/ol/geom/flat/length.js"() {
  }
});

// node_modules/ol/geom/LineString.js
var LineString, LineString_default;
var init_LineString = __esm({
  "node_modules/ol/geom/LineString.js"() {
    init_array();
    init_extent();
    init_SimpleGeometry();
    init_closest();
    init_deflate();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    init_length();
    init_segments();
    init_simplify();
    LineString = class _LineString extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.flatMidpoint_ = null;
        this.flatMidpointRevision_ = -1;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed coordinate to the coordinates of the linestring.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @api
       */
      appendCoordinate(coordinate) {
        extend2(this.flatCoordinates, coordinate);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LineString} Clone.
       * @api
       * @override
       */
      clone() {
        const lineString = new _LineString(
          this.flatCoordinates.slice(),
          this.layout
        );
        lineString.applyProperties(this);
        return lineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          false,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
       *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */
      forEachSegment(callback) {
        return forEach(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          callback
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m, extrapolate) {
        if (this.layout != "XYM" && this.layout != "XYZM") {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        return lineStringCoordinateAtM(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          m,
          extrapolate
        );
      }
      /**
       * Return the coordinates of the linestring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
       * @api
       */
      getCoordinateAt(fraction, dest) {
        return interpolatePoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          fraction,
          dest,
          this.stride
        );
      }
      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */
      getLength() {
        return lineStringLength(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
          this.flatMidpoint_ = this.getCoordinateAt(
            0.5,
            this.flatMidpoint_ ?? void 0
          );
          this.flatMidpointRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatMidpoint_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LineString} Simplified LineString.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LineString(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "LineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLineString(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent,
          this.getExtent()
        );
      }
      /**
       * Set the coordinates of the linestring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LineString_default = LineString;
  }
});

// node_modules/ol/geom/MultiLineString.js
var MultiLineString, MultiLineString_default;
var init_MultiLineString = __esm({
  "node_modules/ol/geom/MultiLineString.js"() {
    init_array();
    init_extent();
    init_LineString();
    init_SimpleGeometry();
    init_closest();
    init_deflate();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    init_length();
    init_simplify();
    MultiLineString = class _MultiLineString extends SimpleGeometry_default {
      /**
       * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
       *     Coordinates or LineString geometries. (For internal use, flat coordinates in
       *     combination with `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Flat coordinate ends for internal use.
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates2[0])) {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        } else if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          const lineStrings = (
            /** @type {Array<LineString>} */
            coordinates2
          );
          const flatCoordinates = [];
          const ends2 = [];
          for (let i = 0, ii = lineStrings.length; i < ii; ++i) {
            const lineString = lineStrings[i];
            extend2(flatCoordinates, lineString.getFlatCoordinates());
            ends2.push(flatCoordinates.length);
          }
          const layout2 = lineStrings.length === 0 ? this.getLayout() : lineStrings[0].getLayout();
          this.setFlatCoordinates(layout2, flatCoordinates);
          this.ends_ = ends2;
        }
      }
      /**
       * Append the passed linestring to the multilinestring.
       * @param {LineString} lineString LineString.
       * @api
       */
      appendLineString(lineString) {
        extend2(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiLineString} Clone.
       * @api
       * @override
       */
      clone() {
        const multiLineString = new _MultiLineString(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        multiLineString.applyProperties(this);
        return multiLineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          false,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @param {boolean} [interpolate] Interpolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m, extrapolate, interpolate) {
        if (this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0) {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        interpolate = interpolate !== void 0 ? interpolate : false;
        return lineStringsCoordinateAtM(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          m,
          extrapolate,
          interpolate
        );
      }
      /**
       * Return the coordinates of the multilinestring.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinatesArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {LineString} LineString.
       * @api
       */
      getLineString(index8) {
        if (index8 < 0 || this.ends_.length <= index8) {
          return null;
        }
        return new LineString_default(
          this.flatCoordinates.slice(
            index8 === 0 ? 0 : this.ends_[index8 - 1],
            this.ends_[index8]
          ),
          this.layout
        );
      }
      /**
       * Return the linestrings of this multilinestring.
       * @return {Array<LineString>} LineStrings.
       * @api
       */
      getLineStrings() {
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const layout = this.layout;
        const lineStrings = [];
        let offset = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const lineString = new LineString_default(
            flatCoordinates.slice(offset, end),
            layout
          );
          lineStrings.push(lineString);
          offset = end;
        }
        return lineStrings;
      }
      /**
       * Return the sum of all line string lengths
       * @return {number} Length (on projected plane).
       * @api
       */
      getLength() {
        const ends = this.ends_;
        let start2 = 0;
        let length = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          length += lineStringLength(
            this.flatCoordinates,
            start2,
            ends[i],
            this.stride
          );
          start2 = ends[i];
        }
        return length;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        const midpoints = [];
        const flatCoordinates = this.flatCoordinates;
        let offset = 0;
        const ends = this.ends_;
        const stride = this.stride;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const midpoint = interpolatePoint(
            flatCoordinates,
            offset,
            end,
            stride,
            0.5
          );
          extend2(midpoints, midpoint);
          offset = end;
        }
        return midpoints;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiLineString} Simplified MultiLineString.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = douglasPeuckerArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _MultiLineString(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "MultiLineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLineStringArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    MultiLineString_default = MultiLineString;
  }
});

// node_modules/ol/geom/Point.js
var Point, Point_default;
var init_Point = __esm({
  "node_modules/ol/geom/Point.js"() {
    init_extent();
    init_math();
    init_SimpleGeometry();
    init_deflate();
    Point = class _Point extends SimpleGeometry_default {
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.setCoordinates(coordinates2, layout);
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Point} Clone.
       * @api
       * @override
       */
      clone() {
        const point = new _Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const squaredDistance3 = squaredDistance(
          x,
          y,
          flatCoordinates[0],
          flatCoordinates[1]
        );
        if (squaredDistance3 < minSquaredDistance) {
          const stride = this.stride;
          for (let i = 0; i < stride; ++i) {
            closestPoint[i] = flatCoordinates[i];
          }
          closestPoint.length = stride;
          return squaredDistance3;
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return this.flatCoordinates.slice();
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       * @override
       */
      computeExtent(extent) {
        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "Point";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      }
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinate(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    Point_default = Point;
  }
});

// node_modules/ol/geom/MultiPoint.js
var MultiPoint, MultiPoint_default;
var init_MultiPoint = __esm({
  "node_modules/ol/geom/MultiPoint.js"() {
    init_array();
    init_extent();
    init_math();
    init_Point();
    init_SimpleGeometry();
    init_deflate();
    init_inflate();
    MultiPoint = class _MultiPoint extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        if (layout && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed point to this multipoint.
       * @param {Point} point Point.
       * @api
       */
      appendPoint(point) {
        extend2(this.flatCoordinates, point.getFlatCoordinates());
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPoint} Clone.
       * @api
       * @override
       */
      clone() {
        const multiPoint = new _MultiPoint(
          this.flatCoordinates.slice(),
          this.layout
        );
        multiPoint.applyProperties(this);
        return multiPoint;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          const squaredDistance3 = squaredDistance(
            x,
            y,
            flatCoordinates[i],
            flatCoordinates[i + 1]
          );
          if (squaredDistance3 < minSquaredDistance) {
            minSquaredDistance = squaredDistance3;
            for (let j = 0; j < stride; ++j) {
              closestPoint[j] = flatCoordinates[i + j];
            }
            closestPoint.length = stride;
          }
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinates of the multipoint.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       * @override
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {Point} Point.
       * @api
       */
      getPoint(index8) {
        const n2 = this.flatCoordinates.length / this.stride;
        if (index8 < 0 || n2 <= index8) {
          return null;
        }
        return new Point_default(
          this.flatCoordinates.slice(
            index8 * this.stride,
            (index8 + 1) * this.stride
          ),
          this.layout
        );
      }
      /**
       * Return the points of this multipoint.
       * @return {Array<Point>} Points.
       * @api
       */
      getPoints() {
        const flatCoordinates = this.flatCoordinates;
        const layout = this.layout;
        const stride = this.stride;
        const points = [];
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          const point = new Point_default(flatCoordinates.slice(i, i + stride), layout);
          points.push(point);
        }
        return points;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "MultiPoint";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          const x = flatCoordinates[i];
          const y = flatCoordinates[i + 1];
          if (containsXY(extent, x, y)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Set the coordinates of the multipoint.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    MultiPoint_default = MultiPoint;
  }
});

// node_modules/ol/geom/Polygon.js
function fromExtent(extent) {
  if (isEmpty(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}
var Polygon, Polygon_default;
var init_Polygon = __esm({
  "node_modules/ol/geom/Polygon.js"() {
    init_array();
    init_extent();
    init_LinearRing();
    init_Point();
    init_SimpleGeometry();
    init_area();
    init_closest();
    init_contains();
    init_deflate();
    init_inflate();
    init_interiorpoint();
    init_intersectsextent();
    init_orient();
    init_simplify();
    Polygon = class _Polygon extends SimpleGeometry_default {
      /**
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
       *     Array of linear rings that define the polygon. The first linear ring of the
       *     array defines the outer-boundary or surface of the polygon. Each subsequent
       *     linear ring defines a hole in the surface of the polygon. A linear ring is
       *     an array of vertices' coordinates where the first coordinate and the last are
       *     equivalent. (For internal use, flat coordinates in combination with
       *     `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.flatInteriorPointRevision_ = -1;
        this.flatInteriorPoint_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed linear ring to this polygon.
       * @param {LinearRing} linearRing Linear ring.
       * @api
       */
      appendLinearRing(linearRing2) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
        } else {
          extend2(this.flatCoordinates, linearRing2.getFlatCoordinates());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       * @override
       */
      clone() {
        const polygon = new _Polygon(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        polygon.applyProperties(this);
        return polygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x, y) {
        return linearRingsContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          x,
          y
        );
      }
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRings(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       * @override
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * @return {Array<number>} Interior point.
       */
      getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoint_ = getInteriorPointOfArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.ends_,
            this.stride,
            flatCenter,
            0
          );
          this.flatInteriorPointRevision_ = this.getRevision();
        }
        return (
          /** @type {import("../coordinate.js").Coordinate} */
          this.flatInteriorPoint_
        );
      }
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoint() {
        return new Point_default(this.getFlatInteriorPoint(), "XYM");
      }
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      getLinearRingCount() {
        return this.ends_.length;
      }
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing|null} Linear ring.
       * @api
       */
      getLinearRing(index8) {
        if (index8 < 0 || this.ends_.length <= index8) {
          return null;
        }
        return new LinearRing_default(
          this.flatCoordinates.slice(
            index8 === 0 ? 0 : this.ends_[index8 - 1],
            this.ends_[index8]
          ),
          this.layout
        );
      }
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */
      getLinearRings() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const linearRings2 = [];
        let offset = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const linearRing2 = new LinearRing_default(
            flatCoordinates.slice(offset, end),
            layout
          );
          linearRings2.push(linearRing2);
          offset = end;
        }
        return linearRings2;
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRings(
              this.orientedFlatCoordinates_,
              0,
              this.ends_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = quantizeArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "Polygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLinearRingArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    Polygon_default = Polygon;
  }
});

// node_modules/ol/geom/MultiPolygon.js
var MultiPolygon, MultiPolygon_default;
var init_MultiPolygon = __esm({
  "node_modules/ol/geom/MultiPolygon.js"() {
    init_array();
    init_extent();
    init_MultiPoint();
    init_Polygon();
    init_SimpleGeometry();
    init_area();
    init_center();
    init_closest();
    init_contains();
    init_deflate();
    init_inflate();
    init_interiorpoint();
    init_intersectsextent();
    init_orient();
    init_simplify();
    MultiPolygon = class _MultiPolygon extends SimpleGeometry_default {
      /**
       * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
       */
      constructor(coordinates2, layout, endss) {
        super();
        this.endss_ = [];
        this.flatInteriorPointsRevision_ = -1;
        this.flatInteriorPoints_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (!endss && !Array.isArray(coordinates2[0])) {
          const polygons = (
            /** @type {Array<Polygon>} */
            coordinates2
          );
          const flatCoordinates = [];
          const thisEndss = [];
          for (let i = 0, ii = polygons.length; i < ii; ++i) {
            const polygon = polygons[i];
            const offset = flatCoordinates.length;
            const ends = polygon.getEnds();
            for (let j = 0, jj = ends.length; j < jj; ++j) {
              ends[j] += offset;
            }
            extend2(flatCoordinates, polygon.getFlatCoordinates());
            thisEndss.push(ends);
          }
          layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();
          coordinates2 = flatCoordinates;
          endss = thisEndss;
        }
        if (layout !== void 0 && endss) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.endss_ = endss;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed polygon to this multipolygon.
       * @param {Polygon} polygon Polygon.
       * @api
       */
      appendPolygon(polygon) {
        let ends;
        if (!this.flatCoordinates) {
          this.flatCoordinates = polygon.getFlatCoordinates().slice();
          ends = polygon.getEnds().slice();
          this.endss_.push();
        } else {
          const offset = this.flatCoordinates.length;
          extend2(this.flatCoordinates, polygon.getFlatCoordinates());
          ends = polygon.getEnds().slice();
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] += offset;
          }
        }
        this.endss_.push(ends);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPolygon} Clone.
       * @api
       * @override
       */
      clone() {
        const len = this.endss_.length;
        const newEndss = new Array(len);
        for (let i = 0; i < len; ++i) {
          newEndss[i] = this.endss_[i].slice();
        }
        const multiPolygon = new _MultiPolygon(
          this.flatCoordinates.slice(),
          this.layout,
          newEndss
        );
        multiPolygon.applyProperties(this);
        return multiPolygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       * @override
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            multiArrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.endss_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestMultiArrayPoint(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       * @override
       */
      containsXY(x, y) {
        return linearRingssContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          x,
          y
        );
      }
      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRingss2(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
       * @api
       * @override
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRingsArray(
            flatCoordinates,
            0,
            this.endss_,
            this.stride,
            right
          );
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateMultiCoordinatesArray(
          flatCoordinates,
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * @return {Array<Array<number>>} Endss.
       */
      getEndss() {
        return this.endss_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
          const flatCenters = linearRingss(
            this.flatCoordinates,
            0,
            this.endss_,
            this.stride
          );
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.endss_,
            this.stride,
            flatCenters
          );
          this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatInteriorPoints_
        );
      }
      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
       * @return {MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoints() {
        return new MultiPoint_default(this.getFlatInteriorPoints().slice(), "XYM");
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRingsArray(
              this.orientedFlatCoordinates_,
              0,
              this.endss_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiPolygon} Simplified MultiPolygon.
       * @protected
       * @override
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEndss = [];
        simplifiedFlatCoordinates.length = quantizeMultiArray(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEndss
        );
        return new _MultiPolygon(simplifiedFlatCoordinates, "XY", simplifiedEndss);
      }
      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {Polygon} Polygon.
       * @api
       */
      getPolygon(index8) {
        if (index8 < 0 || this.endss_.length <= index8) {
          return null;
        }
        let offset;
        if (index8 === 0) {
          offset = 0;
        } else {
          const prevEnds = this.endss_[index8 - 1];
          offset = prevEnds[prevEnds.length - 1];
        }
        const ends = this.endss_[index8].slice();
        const end = ends[ends.length - 1];
        if (offset !== 0) {
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] -= offset;
          }
        }
        return new Polygon_default(
          this.flatCoordinates.slice(offset, end),
          this.layout,
          ends
        );
      }
      /**
       * Return the polygons of this multipolygon.
       * @return {Array<Polygon>} Polygons.
       * @api
       */
      getPolygons() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const endss = this.endss_;
        const polygons = [];
        let offset = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          const ends = endss[i].slice();
          const end = ends[ends.length - 1];
          if (offset !== 0) {
            for (let j = 0, jj = ends.length; j < jj; ++j) {
              ends[j] -= offset;
            }
          }
          const polygon = new Polygon_default(
            flatCoordinates.slice(offset, end),
            layout,
            ends
          );
          polygons.push(polygon);
          offset = end;
        }
        return polygons;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       * @override
       */
      getType() {
        return "MultiPolygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       * @override
       */
      intersectsExtent(extent) {
        return intersectsLinearRingMultiArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       * @override
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 3);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const endss = deflateMultiCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.endss_
        );
        if (endss.length === 0) {
          this.flatCoordinates.length = 0;
        } else {
          const lastEnds = endss[endss.length - 1];
          this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
      }
    };
    MultiPolygon_default = MultiPolygon;
  }
});

// node_modules/ol/geom.js
var init_geom = __esm({
  "node_modules/ol/geom.js"() {
    init_GeometryCollection();
    init_LineString();
    init_MultiLineString();
    init_MultiPoint();
    init_MultiPolygon();
    init_Point();
    init_Polygon();
  }
});

// node_modules/ol/render/Feature.js
var tmpTransform2, RenderFeature, Feature_default2;
var init_Feature2 = __esm({
  "node_modules/ol/render/Feature.js"() {
    init_array();
    init_extent();
    init_functions();
    init_center();
    init_interiorpoint();
    init_interpolate();
    init_orient();
    init_simplify();
    init_transform2();
    init_proj();
    init_transform();
    tmpTransform2 = create();
    RenderFeature = class _RenderFeature {
      /**
       * @param {Type} type Geometry type.
       * @param {Array<number>} flatCoordinates Flat coordinates. These always need
       *     to be right-handed for polygons.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Object<string, *>} properties Properties.
       * @param {number|string|undefined} id Feature id.
       */
      constructor(type, flatCoordinates, ends, stride, properties, id) {
        this.styleFunction;
        this.extent_;
        this.id_ = id;
        this.type_ = type;
        this.flatCoordinates_ = flatCoordinates;
        this.flatInteriorPoints_ = null;
        this.flatMidpoints_ = null;
        this.ends_ = ends || null;
        this.properties_ = properties;
        this.squaredTolerance_;
        this.stride_ = stride;
        this.simplifiedGeometry_;
      }
      /**
       * Get a feature property by its key.
       * @param {string} key Key
       * @return {*} Value for the requested key.
       * @api
       */
      get(key2) {
        return this.properties_[key2];
      }
      /**
       * Get the extent of this feature's geometry.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        if (!this.extent_) {
          this.extent_ = this.type_ === "Point" ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2
          );
        }
        return this.extent_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoints_ = getInteriorPointOfArray(
            this.flatCoordinates_,
            0,
            this.ends_,
            2,
            flatCenter,
            0
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
          const ends = inflateEnds(this.flatCoordinates_, this.ends_);
          const flatCenters = linearRingss(this.flatCoordinates_, 0, ends, 2);
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.flatCoordinates_,
            0,
            ends,
            2,
            flatCenters
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = interpolatePoint(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            0.5
          );
        }
        return this.flatMidpoints_;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = [];
          const flatCoordinates = this.flatCoordinates_;
          let offset = 0;
          const ends = (
            /** @type {Array<number>} */
            this.ends_
          );
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            const end = ends[i];
            const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);
            extend2(this.flatMidpoints_, midpoint);
            offset = end;
          }
        }
        return this.flatMidpoints_;
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is set when reading data from a remote source.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
      }
      /**
       * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
       * determining the geometry type in style function (see {@link #getType}).
       * @return {RenderFeature} Feature.
       * @api
       */
      getGeometry() {
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {RenderFeature} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return this;
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {RenderFeature} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform3) {
        return this;
      }
      /**
       * Get the feature properties.
       * @return {Object<string, *>} Feature properties.
       * @api
       */
      getProperties() {
        return this.properties_;
      }
      /**
       * Get an object of all property names and values.  This has the same behavior as getProperties,
       * but is here to conform with the {@link module:ol/Feature~Feature} interface.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.properties_;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride_;
      }
      /**
       * @return {import('../style/Style.js').StyleFunction|undefined} Style
       */
      getStyleFunction() {
        return this.styleFunction;
      }
      /**
       * Get the type of this feature's geometry.
       * @return {Type} Geometry type.
       * @api
       */
      getType() {
        return this.type_;
      }
      /**
       * Transform geometry coordinates from tile pixel space to projected.
       *
       * @param {import("../proj.js").ProjectionLike} projection The data projection
       */
      transform(projection) {
        projection = get4(projection);
        const pixelExtent = projection.getExtent();
        const projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
          const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform2,
            projectedExtent[0],
            projectedExtent[3],
            scale4,
            -scale4,
            0,
            0,
            0
          );
          transform2D(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            tmpTransform2,
            this.flatCoordinates_
          );
        }
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       */
      applyTransform(transformFn) {
        transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
      }
      /**
       * @return {RenderFeature} A cloned render feature.
       */
      clone() {
        return new _RenderFeature(
          this.type_,
          this.flatCoordinates_.slice(),
          this.ends_?.slice(),
          this.stride_,
          Object.assign({}, this.properties_),
          this.id_
        );
      }
      /**
       * @return {Array<number>|null} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Add transform and resolution based geometry simplification to this instance.
       * @return {RenderFeature} This render feature.
       */
      enableSimplifyTransformed() {
        this.simplifyTransformed = memoizeOne((squaredTolerance, transform3) => {
          if (squaredTolerance === this.squaredTolerance_) {
            return this.simplifiedGeometry_;
          }
          this.simplifiedGeometry_ = this.clone();
          if (transform3) {
            this.simplifiedGeometry_.applyTransform(transform3);
          }
          const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();
          let simplifiedEnds;
          switch (this.type_) {
            case "LineString":
              simplifiedFlatCoordinates.length = douglasPeucker(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.flatCoordinates_.length,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0
              );
              simplifiedEnds = [simplifiedFlatCoordinates.length];
              break;
            case "MultiLineString":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = douglasPeuckerArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            case "Polygon":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = quantizeArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                Math.sqrt(squaredTolerance),
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            default:
          }
          if (simplifiedEnds) {
            this.simplifiedGeometry_ = new _RenderFeature(
              this.type_,
              simplifiedFlatCoordinates,
              simplifiedEnds,
              2,
              this.properties_,
              this.id_
            );
          }
          this.squaredTolerance_ = squaredTolerance;
          return this.simplifiedGeometry_;
        });
        return this;
      }
    };
    RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
    Feature_default2 = RenderFeature;
  }
});

// node_modules/ol/format/Feature.js
function transformGeometryWithOptions(geometry, write, options2) {
  const featureProjection = options2 ? get4(options2.featureProjection) : null;
  const dataProjection = options2 ? get4(options2.dataProjection) : null;
  let transformed = geometry;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    if (write) {
      transformed = /** @type {T} */
      geometry.clone();
    }
    const fromProjection = write ? featureProjection : dataProjection;
    const toProjection = write ? dataProjection : featureProjection;
    if (fromProjection.getUnits() === "tile-pixels") {
      transformed.transform(fromProjection, toProjection);
    } else {
      transformed.applyTransform(getTransform(fromProjection, toProjection));
    }
  }
  if (write && options2 && /** @type {WriteOptions} */
  options2.decimals !== void 0) {
    const power = Math.pow(
      10,
      /** @type {WriteOptions} */
      options2.decimals
    );
    const transform3 = function(coordinates2) {
      for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
        coordinates2[i] = Math.round(coordinates2[i] * power) / power;
      }
      return coordinates2;
    };
    if (transformed === geometry) {
      transformed = /** @type {T} */
      geometry.clone();
    }
    transformed.applyTransform(transform3);
  }
  return transformed;
}
function orientFlatCoordinates(flatCoordinates, ends, stride) {
  if (Array.isArray(ends[0])) {
    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {
      flatCoordinates = flatCoordinates.slice();
      orientLinearRingsArray(flatCoordinates, 0, ends, stride);
    }
    return flatCoordinates;
  }
  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {
    flatCoordinates = flatCoordinates.slice();
    orientLinearRings(flatCoordinates, 0, ends, stride);
  }
  return flatCoordinates;
}
function createRenderFeature(object, options2) {
  const geometry = object.geometry;
  if (!geometry) {
    return [];
  }
  if (Array.isArray(geometry)) {
    return geometry.map((geometry2) => createRenderFeature({ ...object, geometry: geometry2 })).flat();
  }
  const geometryType = geometry.type === "MultiPolygon" ? "Polygon" : geometry.type;
  if (geometryType === "GeometryCollection" || geometryType === "Circle") {
    throw new Error("Unsupported geometry type: " + geometryType);
  }
  const stride = geometry.layout.length;
  return transformGeometryWithOptions(
    new Feature_default2(
      geometryType,
      geometryType === "Polygon" ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride) : geometry.flatCoordinates,
      geometry.ends?.flat(),
      stride,
      object.properties || {},
      object.id
    ).enableSimplifyTransformed(),
    false,
    options2
  );
}
function createGeometry(object, options2) {
  if (!object) {
    return null;
  }
  if (Array.isArray(object)) {
    const geometries = object.map(
      (geometry) => createGeometry(geometry, options2)
    );
    return new GeometryCollection_default(geometries);
  }
  const Geometry2 = GeometryConstructor[object.type];
  return transformGeometryWithOptions(
    new Geometry2(object.flatCoordinates, object.layout || "XY", object.ends),
    false,
    options2
  );
}
var FeatureFormat, Feature_default3, GeometryConstructor;
var init_Feature3 = __esm({
  "node_modules/ol/format/Feature.js"() {
    init_Feature();
    init_orient();
    init_geom();
    init_proj();
    init_Feature2();
    init_util();
    FeatureFormat = class {
      constructor() {
        this.dataProjection = void 0;
        this.defaultFeatureProjection = void 0;
        this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */
        Feature_default;
        this.supportedMediaTypes = null;
      }
      /**
       * Adds the data projection to the read options.
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Options.
       * @return {ReadOptions|undefined} Options.
       * @protected
       */
      getReadOptions(source2, options2) {
        if (options2) {
          let dataProjection = options2.dataProjection ? get4(options2.dataProjection) : this.readProjection(source2);
          if (options2.extent && dataProjection && dataProjection.getUnits() === "tile-pixels") {
            dataProjection = get4(dataProjection);
            dataProjection.setWorldExtent(options2.extent);
          }
          options2 = {
            dataProjection,
            featureProjection: options2.featureProjection
          };
        }
        return this.adaptOptions(options2);
      }
      /**
       * Sets the `dataProjection` on the options, if no `dataProjection`
       * is set.
       * @param {WriteOptions|ReadOptions|undefined} options
       *     Options.
       * @protected
       * @return {WriteOptions|ReadOptions|undefined}
       *     Updated options.
       */
      adaptOptions(options2) {
        return Object.assign(
          {
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection,
            featureClass: this.featureClass
          },
          options2
        );
      }
      /**
       * @abstract
       * @return {Type} The format type.
       */
      getType() {
        return abstract();
      }
      /**
       * Read a single feature from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {FeatureType|Array<FeatureType>} Feature.
       */
      readFeature(source2, options2) {
        return abstract();
      }
      /**
       * Read all features from a source.
       *
       * @abstract
       * @param {Document|Element|ArrayBuffer|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {Array<FeatureType>} Features.
       */
      readFeatures(source2, options2) {
        return abstract();
      }
      /**
       * Read a single geometry from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      readGeometry(source2, options2) {
        return abstract();
      }
      /**
       * Read the projection from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default|undefined} Projection.
       */
      readProjection(source2) {
        return abstract();
      }
      /**
       * Encode a feature in this format.
       *
       * @abstract
       * @param {Feature} feature Feature.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */
      writeFeature(feature, options2) {
        return abstract();
      }
      /**
       * Encode an array of features in this format.
       *
       * @abstract
       * @param {Array<Feature>} features Features.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */
      writeFeatures(features, options2) {
        return abstract();
      }
      /**
       * Write a single geometry in this format.
       *
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */
      writeGeometry(geometry, options2) {
        return abstract();
      }
    };
    Feature_default3 = FeatureFormat;
    GeometryConstructor = {
      Point: Point_default,
      LineString: LineString_default,
      Polygon: Polygon_default,
      MultiPoint: MultiPoint_default,
      MultiLineString: MultiLineString_default,
      MultiPolygon: MultiPolygon_default
    };
  }
});

// node_modules/ol/format/JSONFeature.js
function getObject(source2) {
  if (typeof source2 === "string") {
    const object = JSON.parse(source2);
    return object ? (
      /** @type {Object} */
      object
    ) : null;
  }
  if (source2 !== null) {
    return source2;
  }
  return null;
}
var JSONFeature, JSONFeature_default;
var init_JSONFeature = __esm({
  "node_modules/ol/format/JSONFeature.js"() {
    init_util();
    init_Feature3();
    JSONFeature = class extends Feature_default3 {
      constructor() {
        super();
      }
      /**
       * @return {import("./Feature.js").Type} Format.
       * @override
       */
      getType() {
        return "json";
      }
      /**
       * Read a feature.  Only works for a single feature. Use `readFeatures` to
       * read a feature collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {FeatureType|Array<FeatureType>} Feature.
       * @api
       * @override
       */
      readFeature(source2, options2) {
        return this.readFeatureFromObject(
          getObject(source2),
          this.getReadOptions(source2, options2)
        );
      }
      /**
       * Read all features.  Works with both a single feature and a feature
       * collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {Array<FeatureType>} Features.
       * @api
       * @override
       */
      readFeatures(source2, options2) {
        return this.readFeaturesFromObject(
          getObject(source2),
          this.getReadOptions(source2, options2)
        );
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {FeatureType|Array<FeatureType>} Feature.
       */
      readFeatureFromObject(object, options2) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {Array<FeatureType>} Features.
       */
      readFeaturesFromObject(object, options2) {
        return abstract();
      }
      /**
       * Read a geometry.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       * @api
       * @override
       */
      readGeometry(source2, options2) {
        return this.readGeometryFromObject(
          getObject(source2),
          this.getReadOptions(source2, options2)
        );
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      readGeometryFromObject(object, options2) {
        return abstract();
      }
      /**
       * Read the projection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default} Projection.
       * @api
       * @override
       */
      readProjection(source2) {
        return this.readProjectionFromObject(getObject(source2));
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       */
      readProjectionFromObject(object) {
        return abstract();
      }
      /**
       * Encode a feature as string.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded feature.
       * @api
       * @override
       */
      writeFeature(feature, options2) {
        return JSON.stringify(this.writeFeatureObject(feature, options2));
      }
      /**
       * @abstract
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */
      writeFeatureObject(feature, options2) {
        return abstract();
      }
      /**
       * Encode an array of features as string.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded features.
       * @api
       * @override
       */
      writeFeatures(features, options2) {
        return JSON.stringify(this.writeFeaturesObject(features, options2));
      }
      /**
       * @abstract
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */
      writeFeaturesObject(features, options2) {
        return abstract();
      }
      /**
       * Encode a geometry as string.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded geometry.
       * @api
       * @override
       */
      writeGeometry(geometry, options2) {
        return JSON.stringify(this.writeGeometryObject(geometry, options2));
      }
      /**
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */
      writeGeometryObject(geometry, options2) {
        return abstract();
      }
    };
    JSONFeature_default = JSONFeature;
  }
});

// node_modules/ol/format/GeoJSON.js
function readGeometryInternal(object, options2) {
  if (!object) {
    return null;
  }
  let geometry;
  switch (object["type"]) {
    case "Point": {
      geometry = readPointGeometry(
        /** @type {GeoJSONPoint} */
        object
      );
      break;
    }
    case "LineString": {
      geometry = readLineStringGeometry(
        /** @type {GeoJSONLineString} */
        object
      );
      break;
    }
    case "Polygon": {
      geometry = readPolygonGeometry(
        /** @type {GeoJSONPolygon} */
        object
      );
      break;
    }
    case "MultiPoint": {
      geometry = readMultiPointGeometry(
        /** @type {GeoJSONMultiPoint} */
        object
      );
      break;
    }
    case "MultiLineString": {
      geometry = readMultiLineStringGeometry(
        /** @type {GeoJSONMultiLineString} */
        object
      );
      break;
    }
    case "MultiPolygon": {
      geometry = readMultiPolygonGeometry(
        /** @type {GeoJSONMultiPolygon} */
        object
      );
      break;
    }
    case "GeometryCollection": {
      geometry = readGeometryCollectionGeometry(
        /** @type {GeoJSONGeometryCollection} */
        object
      );
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object["type"]);
    }
  }
  return geometry;
}
function readGeometry(object, options2) {
  const geometryObject = readGeometryInternal(object, options2);
  return createGeometry(geometryObject, options2);
}
function readGeometryCollectionGeometry(object, options2) {
  const geometries = object["geometries"].map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */
    function(geometry) {
      return readGeometryInternal(geometry, options2);
    }
  );
  return geometries;
}
function readPointGeometry(object) {
  const flatCoordinates = object["coordinates"];
  return {
    type: "Point",
    flatCoordinates,
    layout: getLayoutForStride(flatCoordinates.length)
  };
}
function readLineStringGeometry(object) {
  const coordinates2 = object["coordinates"];
  const flatCoordinates = coordinates2.flat();
  return {
    type: "LineString",
    flatCoordinates,
    ends: [flatCoordinates.length],
    layout: getLayoutForStride(coordinates2[0]?.length || 2)
  };
}
function readMultiLineStringGeometry(object) {
  const coordinates2 = object["coordinates"];
  const stride = coordinates2[0]?.[0]?.length || 2;
  const flatCoordinates = [];
  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates2, stride);
  return {
    type: "MultiLineString",
    flatCoordinates,
    ends,
    layout: getLayoutForStride(stride)
  };
}
function readMultiPointGeometry(object) {
  const coordinates2 = object["coordinates"];
  return {
    type: "MultiPoint",
    flatCoordinates: coordinates2.flat(),
    layout: getLayoutForStride(coordinates2[0]?.length || 2)
  };
}
function readMultiPolygonGeometry(object) {
  const coordinates2 = object["coordinates"];
  const flatCoordinates = [];
  const stride = coordinates2[0]?.[0]?.[0].length || 2;
  const endss = deflateMultiCoordinatesArray(
    flatCoordinates,
    0,
    coordinates2,
    stride
  );
  return {
    type: "MultiPolygon",
    flatCoordinates,
    ends: endss,
    layout: getLayoutForStride(stride)
  };
}
function readPolygonGeometry(object) {
  const coordinates2 = object["coordinates"];
  const flatCoordinates = [];
  const stride = coordinates2[0]?.[0]?.length;
  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates2, stride);
  return {
    type: "Polygon",
    flatCoordinates,
    ends,
    layout: getLayoutForStride(stride)
  };
}
function writeGeometry(geometry, options2) {
  geometry = transformGeometryWithOptions(geometry, true, options2);
  const type = geometry.getType();
  let geoJSON;
  switch (type) {
    case "Point": {
      geoJSON = writePointGeometry(
        /** @type {import("../geom/Point.js").default} */
        geometry,
        options2
      );
      break;
    }
    case "LineString": {
      geoJSON = writeLineStringGeometry(
        /** @type {import("../geom/LineString.js").default} */
        geometry,
        options2
      );
      break;
    }
    case "Polygon": {
      geoJSON = writePolygonGeometry(
        /** @type {import("../geom/Polygon.js").default} */
        geometry,
        options2
      );
      break;
    }
    case "MultiPoint": {
      geoJSON = writeMultiPointGeometry(
        /** @type {import("../geom/MultiPoint.js").default} */
        geometry,
        options2
      );
      break;
    }
    case "MultiLineString": {
      geoJSON = writeMultiLineStringGeometry(
        /** @type {import("../geom/MultiLineString.js").default} */
        geometry,
        options2
      );
      break;
    }
    case "MultiPolygon": {
      geoJSON = writeMultiPolygonGeometry(
        /** @type {import("../geom/MultiPolygon.js").default} */
        geometry,
        options2
      );
      break;
    }
    case "GeometryCollection": {
      geoJSON = writeGeometryCollectionGeometry(
        /** @type {import("../geom/GeometryCollection.js").default} */
        geometry,
        options2
      );
      break;
    }
    case "Circle": {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, options2) {
  options2 = Object.assign({}, options2);
  delete options2.featureProjection;
  const geometries = geometry.getGeometriesArray().map(function(geometry2) {
    return writeGeometry(geometry2, options2);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry(geometry, options2) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry(geometry, options2) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry(geometry, options2) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, options2) {
  let right;
  if (options2) {
    right = options2.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry(geometry, options2) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry(geometry, options2) {
  let right;
  if (options2) {
    right = options2.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
var GeoJSON, GeoJSON_default;
var init_GeoJSON = __esm({
  "node_modules/ol/format/GeoJSON.js"() {
    init_Feature();
    init_SimpleGeometry();
    init_deflate();
    init_obj();
    init_proj();
    init_Feature2();
    init_Feature3();
    init_JSONFeature();
    GeoJSON = class extends JSONFeature_default {
      /**
       * @param {Options<FeatureType>} [options] Options.
       */
      constructor(options2) {
        options2 = options2 ? options2 : {};
        super();
        this.dataProjection = get4(
          options2.dataProjection ? options2.dataProjection : "EPSG:4326"
        );
        if (options2.featureProjection) {
          this.defaultFeatureProjection = get4(options2.featureProjection);
        }
        if (options2.featureClass) {
          this.featureClass = options2.featureClass;
        }
        this.geometryName_ = options2.geometryName;
        this.extractGeometryName_ = options2.extractGeometryName;
        this.supportedMediaTypes = [
          "application/geo+json",
          "application/vnd.geo+json"
        ];
      }
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {FeatureType|Array<FeatureType>} Feature.
       * @override
       */
      readFeatureFromObject(object, options2) {
        let geoJSONFeature = null;
        if (object["type"] === "Feature") {
          geoJSONFeature = /** @type {GeoJSONFeature} */
          object;
        } else {
          geoJSONFeature = {
            "type": "Feature",
            "geometry": (
              /** @type {GeoJSONGeometry} */
              object
            ),
            "properties": null
          };
        }
        const geometry = readGeometryInternal(geoJSONFeature["geometry"], options2);
        if (this.featureClass === Feature_default2) {
          return (
            /** @type {FeatureType|Array<FeatureType>} */
            createRenderFeature(
              {
                geometry,
                id: geoJSONFeature["id"],
                properties: geoJSONFeature["properties"]
              },
              options2
            )
          );
        }
        const feature = new Feature_default();
        if (this.geometryName_) {
          feature.setGeometryName(this.geometryName_);
        } else if (this.extractGeometryName_ && geoJSONFeature["geometry_name"]) {
          feature.setGeometryName(geoJSONFeature["geometry_name"]);
        }
        feature.setGeometry(createGeometry(geometry, options2));
        if ("id" in geoJSONFeature) {
          feature.setId(geoJSONFeature["id"]);
        }
        if (geoJSONFeature["properties"]) {
          feature.setProperties(geoJSONFeature["properties"], true);
        }
        return (
          /** @type {FeatureType|Array<FeatureType>} */
          feature
        );
      }
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {Array<FeatureType>} Features.
       * @override
       */
      readFeaturesFromObject(object, options2) {
        const geoJSONObject = (
          /** @type {GeoJSONObject} */
          object
        );
        let features = null;
        if (geoJSONObject["type"] === "FeatureCollection") {
          const geoJSONFeatureCollection = (
            /** @type {GeoJSONFeatureCollection} */
            object
          );
          features = [];
          const geoJSONFeatures = geoJSONFeatureCollection["features"];
          for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
            const featureObject = this.readFeatureFromObject(
              geoJSONFeatures[i],
              options2
            );
            if (!featureObject) {
              continue;
            }
            features.push(featureObject);
          }
        } else {
          features = [this.readFeatureFromObject(object, options2)];
        }
        return (
          /** @type {Array<FeatureType>} */
          features.flat()
        );
      }
      /**
       * @param {GeoJSONGeometry} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       * @override
       */
      readGeometryFromObject(object, options2) {
        return readGeometry(object, options2);
      }
      /**
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       * @override
       */
      readProjectionFromObject(object) {
        const crs = object["crs"];
        let projection;
        if (crs) {
          if (crs["type"] == "name") {
            projection = get4(crs["properties"]["name"]);
          } else if (crs["type"] === "EPSG") {
            projection = get4("EPSG:" + crs["properties"]["code"]);
          } else {
            throw new Error("Unknown SRS type");
          }
        } else {
          projection = this.dataProjection;
        }
        return (
          /** @type {import("../proj/Projection.js").default} */
          projection
        );
      }
      /**
       * Encode a feature as a GeoJSON Feature object.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONFeature} Object.
       * @api
       * @override
       */
      writeFeatureObject(feature, options2) {
        options2 = this.adaptOptions(options2);
        const object = {
          "type": "Feature",
          geometry: null,
          properties: null
        };
        const id = feature.getId();
        if (id !== void 0) {
          object.id = id;
        }
        if (!feature.hasProperties()) {
          return object;
        }
        const properties = feature.getProperties();
        const geometry = feature.getGeometry();
        if (geometry) {
          object.geometry = writeGeometry(geometry, options2);
          delete properties[feature.getGeometryName()];
        }
        if (!isEmpty2(properties)) {
          object.properties = properties;
        }
        return object;
      }
      /**
       * Encode an array of features as a GeoJSON object.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONFeatureCollection} GeoJSON Object.
       * @api
       * @override
       */
      writeFeaturesObject(features, options2) {
        options2 = this.adaptOptions(options2);
        const objects = [];
        for (let i = 0, ii = features.length; i < ii; ++i) {
          objects.push(this.writeFeatureObject(features[i], options2));
        }
        return {
          type: "FeatureCollection",
          features: objects
        };
      }
      /**
       * Encode a geometry as a GeoJSON object.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
       * @api
       * @override
       */
      writeGeometryObject(geometry, options2) {
        return writeGeometry(geometry, this.adaptOptions(options2));
      }
    };
    GeoJSON_default = GeoJSON;
  }
});

// node_modules/@allmaps/stdlib/dist/fetch.js
var init_fetch = __esm({
  "node_modules/@allmaps/stdlib/dist/fetch.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/api.js
var init_api = __esm({
  "node_modules/@allmaps/stdlib/dist/api.js"() {
    init_fetch();
  }
});

// node_modules/@allmaps/stdlib/dist/background-color.js
var init_background_color = __esm({
  "node_modules/@allmaps/stdlib/dist/background-color.js"() {
  }
});

// node_modules/monotone-chain-convex-hull/lib-esm/index.js
var init_lib_esm = __esm({
  "node_modules/monotone-chain-convex-hull/lib-esm/index.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/geometry.js
var init_geometry = __esm({
  "node_modules/@allmaps/stdlib/dist/geometry.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/geojson.js
var init_geojson = __esm({
  "node_modules/@allmaps/stdlib/dist/geojson.js"() {
    init_geometry();
  }
});

// node_modules/@allmaps/stdlib/dist/bbox.js
var init_bbox = __esm({
  "node_modules/@allmaps/stdlib/dist/bbox.js"() {
    init_lib_esm();
    init_geojson();
    init_geometry();
  }
});

// node_modules/@allmaps/stdlib/dist/cache.js
var init_cache = __esm({
  "node_modules/@allmaps/stdlib/dist/cache.js"() {
  }
});

// node_modules/hex-rgb/index.js
var hexCharacters, match3or4Hex, match6or8Hex, nonHexChars, validHexSize;
var init_hex_rgb = __esm({
  "node_modules/hex-rgb/index.js"() {
    hexCharacters = "a-f\\d";
    match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;
    match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;
    nonHexChars = new RegExp(`[^#${hexCharacters}]`, "gi");
    validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, "i");
  }
});

// node_modules/rgb-hex/index.js
var init_rgb_hex = __esm({
  "node_modules/rgb-hex/index.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/color.js
var init_color = __esm({
  "node_modules/@allmaps/stdlib/dist/color.js"() {
    init_hex_rgb();
    init_rgb_hex();
  }
});

// node_modules/@allmaps/stdlib/dist/main.js
var init_main = __esm({
  "node_modules/@allmaps/stdlib/dist/main.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/masks.js
var init_masks = __esm({
  "node_modules/@allmaps/stdlib/dist/masks.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/matrix.js
var init_matrix = __esm({
  "node_modules/@allmaps/stdlib/dist/matrix.js"() {
    init_main();
  }
});

// node_modules/@allmaps/stdlib/dist/options.js
var init_options = __esm({
  "node_modules/@allmaps/stdlib/dist/options.js"() {
  }
});

// node_modules/svg-parser/dist/svg-parser.esm.js
var init_svg_parser_esm = __esm({
  "node_modules/svg-parser/dist/svg-parser.esm.js"() {
  }
});

// node_modules/@allmaps/stdlib/dist/svg.js
var init_svg = __esm({
  "node_modules/@allmaps/stdlib/dist/svg.js"() {
    init_svg_parser_esm();
  }
});

// node_modules/@allmaps/stdlib/dist/self-intersect.js
var init_self_intersect = __esm({
  "node_modules/@allmaps/stdlib/dist/self-intersect.js"() {
    init_geometry();
    init_main();
  }
});

// node_modules/@allmaps/stdlib/dist/index.js
var init_dist = __esm({
  "node_modules/@allmaps/stdlib/dist/index.js"() {
    init_api();
    init_background_color();
    init_bbox();
    init_cache();
    init_color();
    init_fetch();
    init_geojson();
    init_geometry();
    init_main();
    init_masks();
    init_matrix();
    init_options();
    init_svg();
    init_self_intersect();
  }
});

// node_modules/@allmaps/transform/dist/shared/distortion.js
var init_distortion = __esm({
  "node_modules/@allmaps/transform/dist/shared/distortion.js"() {
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BaseTransformation.js
var init_BaseTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BaseTransformation.js"() {
    init_dist();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BaseLinearWeightsTransformation.js
var init_BaseLinearWeightsTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BaseLinearWeightsTransformation.js"() {
    init_BaseTransformation();
  }
});

// node_modules/@allmaps/transform/dist/shared/solve-functions.js
var init_solve_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/solve-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Helmert.js
var init_Helmert = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Helmert.js"() {
    init_dist();
    init_BaseLinearWeightsTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Straight.js
var init_Straight = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Straight.js"() {
    init_Helmert();
    init_BaseTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BaseIndependentLinearWeightsTransformation.js
var init_BaseIndependentLinearWeightsTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BaseIndependentLinearWeightsTransformation.js"() {
    init_BaseLinearWeightsTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/BasePolynomialTransformation.js
var init_BasePolynomialTransformation = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/BasePolynomialTransformation.js"() {
    init_dist();
    init_BaseIndependentLinearWeightsTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial1.js
var init_Polynomial1 = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Polynomial1.js"() {
    init_BasePolynomialTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial2.js
var init_Polynomial2 = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Polynomial2.js"() {
    init_BasePolynomialTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Polynomial3.js
var init_Polynomial3 = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Polynomial3.js"() {
    init_BasePolynomialTransformation();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/Projective.js
var init_Projective = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/Projective.js"() {
    init_dist();
    init_BaseTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformation-types/RBF.js
var init_RBF = __esm({
  "node_modules/@allmaps/transform/dist/transformation-types/RBF.js"() {
    init_dist();
    init_Polynomial1();
    init_BaseIndependentLinearWeightsTransformation();
    init_solve_functions();
  }
});

// node_modules/@allmaps/transform/dist/shared/kernel-functions.js
var init_kernel_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/kernel-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/shared/norm-functions.js
var init_norm_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/norm-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/shared/refinement-functions.js
var init_refinement_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/refinement-functions.js"() {
    init_dist();
  }
});

// node_modules/@allmaps/transform/dist/shared/transform-functions.js
function generalGcpTransformOptionsToGcpTransformOptions(generalGcpTransformOptions) {
  if (generalGcpTransformOptions === void 0) {
    return {};
  }
  const gcpTransformOptions = generalGcpTransformOptions;
  if (generalGcpTransformOptions.destinationIsGeographic) {
    gcpTransformOptions.geoIsGeographic = generalGcpTransformOptions.destinationIsGeographic;
  }
  if (generalGcpTransformOptions.postForward) {
    gcpTransformOptions.postToGeo = generalGcpTransformOptions.postForward;
  }
  if (generalGcpTransformOptions.preBackward) {
    gcpTransformOptions.preToResource = generalGcpTransformOptions.preBackward;
  }
  return gcpTransformOptions;
}
function generalGcpTransformerOptionsToGcpTransformerOptions(generalGcpTransformerOptions) {
  if (generalGcpTransformerOptions == void 0) {
    return {};
  }
  const gcpTransformerOptions = generalGcpTransformerOptions;
  return gcpTransformerOptions;
}
var defaultGeneralGcpTransformOptions, defaultGeneralGcpTransformerOptions, defaultGcpTransformOptions, defaultGcpTransformerOptions;
var init_transform_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/transform-functions.js"() {
    init_dist();
    init_refinement_functions();
    defaultGeneralGcpTransformOptions = {
      maxDepth: 0,
      minOffsetRatio: 0,
      minOffsetDistance: Infinity,
      minLineDistance: Infinity,
      sourceIsGeographic: false,
      destinationIsGeographic: false,
      isMultiGeometry: false,
      distortionMeasures: [],
      referenceScale: 1,
      preForward: (point) => point,
      postForward: (point) => point,
      preBackward: (point) => point,
      postBackward: (point) => point
    };
    defaultGeneralGcpTransformerOptions = {
      differentHandedness: false,
      ...defaultGeneralGcpTransformOptions
    };
    defaultGcpTransformOptions = generalGcpTransformOptionsToGcpTransformOptions(defaultGeneralGcpTransformOptions);
    defaultGcpTransformerOptions = generalGcpTransformerOptionsToGcpTransformerOptions(defaultGeneralGcpTransformerOptions);
  }
});

// node_modules/@allmaps/transform/dist/shared/conversion-functions.js
var init_conversion_functions = __esm({
  "node_modules/@allmaps/transform/dist/shared/conversion-functions.js"() {
  }
});

// node_modules/@allmaps/transform/dist/transformers/BaseGcpTransformer.js
var init_BaseGcpTransformer = __esm({
  "node_modules/@allmaps/transform/dist/transformers/BaseGcpTransformer.js"() {
    init_dist();
    init_distortion();
    init_Straight();
    init_Helmert();
    init_Polynomial1();
    init_Polynomial2();
    init_Polynomial3();
    init_Projective();
    init_RBF();
    init_kernel_functions();
    init_norm_functions();
    init_transform_functions();
    init_refinement_functions();
    init_conversion_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformers/GcpTransformer.js
var init_GcpTransformer = __esm({
  "node_modules/@allmaps/transform/dist/transformers/GcpTransformer.js"() {
    init_dist();
    init_BaseGcpTransformer();
    init_transform_functions();
    init_conversion_functions();
  }
});

// node_modules/@allmaps/transform/dist/transformers/GeneralGcpTransformer.js
var init_GeneralGcpTransformer = __esm({
  "node_modules/@allmaps/transform/dist/transformers/GeneralGcpTransformer.js"() {
    init_BaseGcpTransformer();
    init_conversion_functions();
  }
});

// node_modules/@allmaps/transform/dist/shared/types.js
var init_types = __esm({
  "node_modules/@allmaps/transform/dist/shared/types.js"() {
  }
});

// node_modules/@allmaps/transform/dist/index.js
var init_dist2 = __esm({
  "node_modules/@allmaps/transform/dist/index.js"() {
    init_GcpTransformer();
    init_GeneralGcpTransformer();
    init_BaseIndependentLinearWeightsTransformation();
    init_BaseLinearWeightsTransformation();
    init_BasePolynomialTransformation();
    init_BaseTransformation();
    init_Helmert();
    init_Polynomial1();
    init_Polynomial2();
    init_Polynomial3();
    init_Projective();
    init_RBF();
    init_Straight();
    init_types();
    init_distortion();
    init_transform_functions();
    init_solve_functions();
  }
});

// node_modules/@allmaps/tailwind/dist/colors.js
var black, white, inherit, current2, transparent, originalColorIndex, blueShades, darkblueShades, purpleShades, pinkShades, orangeShades, redShades, greenShades, yellowShades, grayShades, shades, blue, darkblue, purple, pink, orange, red, green, yellow, gray;
var init_colors = __esm({
  "node_modules/@allmaps/tailwind/dist/colors.js"() {
    black = "#222222";
    white = "#ffffff";
    inherit = "inherit";
    current2 = "currentColor";
    transparent = "transparent";
    originalColorIndex = 4;
    blueShades = [
      "#dff7fa",
      "#c0eff5",
      "#a1e7f0",
      "#82dfeb",
      "#63d8e6",
      // Original color
      "#4facb8",
      "#3b818a",
      "#27565c",
      "#132b2d"
    ];
    darkblueShades = [
      "#d7d9ee",
      "#b0b4de",
      "#898ecd",
      "#6269bd",
      "#3b44ad",
      // Original color
      "#2f368a",
      "#232867",
      "#171b45",
      "#0b0d22"
    ];
    purpleShades = [
      "#f3dcf0",
      "#e7b9e1",
      "#dc97d2",
      "#d074c3",
      "#c552b5",
      // Original color
      "#9d4190",
      "#76316c",
      "#4e2048",
      "#271024"
    ];
    pinkShades = [
      "#ffddf1",
      "#ffbbe3",
      "#ff99d5",
      "#ff77c7",
      "#ff56ba",
      // Original color
      "#cc4494",
      "#99336f",
      "#66224a",
      "#321125"
    ];
    orangeShades = [
      "#ffe3d0",
      "#ffc7a1",
      "#ffab72",
      "#ff8f43",
      "#ff7415",
      // Original color
      "#cc5c10",
      "#99450c",
      "#662e08",
      "#321704"
    ];
    redShades = [
      "#fededf",
      "#febebf",
      "#fe9e9f",
      "#fe7e7f",
      "#fe5e60",
      // Original color
      "#cb4b4c",
      "#983839",
      "#652526",
      "#321213"
    ];
    greenShades = [
      "#e0f2e8",
      "#c1e6d2",
      "#a2d9bb",
      "#83cda5",
      "#64c18f",
      // Original color
      "#509a72",
      "#3c7355",
      "#284d39",
      "#13261c"
    ];
    yellowShades = [
      "#fff3d9",
      "#ffe8b3",
      "#ffdd8d",
      "#ffd267",
      "#ffc742",
      // Original color
      "#cc9f34",
      "#997727",
      "#664f1a",
      "#32270d"
    ];
    grayShades = [
      "#efefef",
      "#e0e0e0",
      "#d0d0d0",
      "#c1c1c1",
      "#b2b2b2",
      "#8e8e8e",
      "#6a6a6a",
      "#474747",
      "#232323"
    ];
    shades = {
      blue: blueShades,
      darkblue: darkblueShades,
      purple: purpleShades,
      pink: pinkShades,
      orange: orangeShades,
      red: redShades,
      green: greenShades,
      yellow: yellowShades,
      gray: grayShades
    };
    blue = blueShades[originalColorIndex];
    darkblue = darkblueShades[originalColorIndex];
    purple = purpleShades[originalColorIndex];
    pink = pinkShades[originalColorIndex];
    orange = orangeShades[originalColorIndex];
    red = redShades[originalColorIndex];
    green = greenShades[originalColorIndex];
    yellow = yellowShades[originalColorIndex];
    gray = grayShades[originalColorIndex];
  }
});

// node_modules/@allmaps/tailwind/dist/theme-colors.js
function flattenShades(color, shades2) {
  return shades2.reduce((flattened, hex, index8) => {
    const shade = (index8 + 1) * 100;
    const key2 = `${color}-${shade}`;
    flattened[key2] = hex;
    return flattened;
  }, {});
}
var themeColors;
var init_theme_colors = __esm({
  "node_modules/@allmaps/tailwind/dist/theme-colors.js"() {
    init_colors();
    themeColors = {
      blue,
      darkblue,
      purple,
      pink,
      orange,
      red,
      green,
      yellow,
      gray,
      black,
      white,
      inherit,
      current: current2,
      transparent,
      // Add shades
      ...flattenShades("blue", shades.blue),
      ...flattenShades("darkblue", shades.darkblue),
      ...flattenShades("purple", shades.purple),
      ...flattenShades("pink", shades.pink),
      ...flattenShades("orange", shades.orange),
      ...flattenShades("red", shades.red),
      ...flattenShades("green", shades.green),
      ...flattenShades("yellow", shades.yellow),
      ...flattenShades("gray", shades.gray)
    };
  }
});

// node_modules/@allmaps/tailwind/dist/theme.js
var theme;
var init_theme = __esm({
  "node_modules/@allmaps/tailwind/dist/theme.js"() {
    init_theme_colors();
    theme = {
      extend: {
        textColor: {
          DEFAULT: themeColors.black
        },
        transitionDuration: {
          0: "0ms"
        }
      },
      colors: themeColors,
      fontFamily: {
        sans: ["Geograph", "sans-serif"],
        // Consider using https://tosche.net/fonts/codelia
        mono: ["DM Mono", "monospace"]
      }
    };
  }
});

// node_modules/@allmaps/tailwind/dist/index.js
var init_dist3 = __esm({
  "node_modules/@allmaps/tailwind/dist/index.js"() {
    init_theme_colors();
    init_theme();
    init_colors();
  }
});

// node_modules/@allmaps/render/dist/shared/events.js
var init_events2 = __esm({
  "node_modules/@allmaps/render/dist/shared/events.js"() {
  }
});

// node_modules/@allmaps/render/dist/shared/tiles.js
var init_tiles = __esm({
  "node_modules/@allmaps/render/dist/shared/tiles.js"() {
    init_dist();
  }
});

// node_modules/@allmaps/render/dist/tilecache/TileCache.js
var init_TileCache = __esm({
  "node_modules/@allmaps/render/dist/tilecache/TileCache.js"() {
    init_dist();
    init_events2();
    init_tiles();
  }
});

// node_modules/@allmaps/id/dist/checksum.js
var init_checksum = __esm({
  "node_modules/@allmaps/id/dist/checksum.js"() {
  }
});

// node_modules/@allmaps/id/dist/index.js
var init_dist4 = __esm({
  "node_modules/@allmaps/id/dist/index.js"() {
    init_checksum();
  }
});

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType;
var init_util2 = __esm({
  "node_modules/zod/v3/helpers/util.js"() {
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e3) {
          return obj[e3];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key2 in object) {
          if (Object.prototype.hasOwnProperty.call(object, key2)) {
            keys.push(key2);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array2, separator = " | ") {
        return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
  }
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson, ZodError;
var init_ZodError = __esm({
  "node_modules/zod/v3/ZodError.js"() {
    init_util2();
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json2 = JSON.stringify(obj, null, 2);
      return json2.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class _ZodError extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error2) => {
          for (const issue of error2.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error2 = new ZodError(issues);
      return error2;
    };
  }
});

// node_modules/zod/v3/locales/en.js
var errorMap, en_default;
var init_en = __esm({
  "node_modules/zod/v3/locales/en.js"() {
    init_ZodError();
    init_util2();
    errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "bigint")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    en_default = errorMap;
  }
});

// node_modules/zod/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors = __esm({
  "node_modules/zod/v3/errors.js"() {
    init_en();
    overrideErrorMap = en_default;
  }
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY2, OK, isAborted, isDirty, isValid, isAsync;
var init_parseUtil = __esm({
  "node_modules/zod/v3/helpers/parseUtil.js"() {
    init_errors();
    init_en();
    makeIssue = (params2) => {
      const { data, path, errorMaps, issueData } = params2;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s3 of results) {
          if (s3.status === "aborted")
            return INVALID;
          if (s3.status === "dirty")
            status.dirty();
          arrayValue.push(s3.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key: key2,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key: key2, value } = pair;
          if (key2.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key2.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key2.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY2 = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x) => x.status === "aborted";
    isDirty = (x) => x.status === "dirty";
    isValid = (x) => x.status === "valid";
    isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  }
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = __esm({
  "node_modules/zod/v3/helpers/typeAliases.js"() {
  }
});

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm({
  "node_modules/zod/v3/helpers/errorUtil.js"() {
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (errorUtil = {}));
  }
});

// node_modules/zod/v3/types.js
function processCreateParams(params2) {
  if (!params2)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params2;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a, ...b };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a[key2], b[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index8 = 0; index8 < a.length; index8++) {
      const itemA = a[index8];
      const itemB = b[index8];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params2) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params2)
  });
}
function cleanParams(params2, data) {
  const p = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r3 = check(data);
      if (r3 instanceof Promise) {
        return r3.then((r4) => {
          if (!r4) {
            const params2 = cleanParams(_params, data);
            const _fatal = params2.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params2, fatal: _fatal });
          }
        });
      }
      if (!r3) {
        const params2 = cleanParams(_params, data);
        const _fatal = params2.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params2, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER;
var init_types2 = __esm({
  "node_modules/zod/v3/types.js"() {
    init_ZodError();
    init_errors();
    init_errorUtil();
    init_parseUtil();
    init_util2();
    ParseInputLazyPath = class {
      constructor(parent, value, path, key2) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key2;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error2 = new ZodError(ctx.common.issues);
            this._error = error2;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params2) {
        const result = this.safeParse(data, params2);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params2) {
        const ctx = {
          common: {
            issues: [],
            async: params2?.async ?? false,
            contextualErrorMap: params2?.errorMap
          },
          path: params2?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params2) {
        const result = await this.safeParseAsync(data, params2);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params2) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params2?.errorMap,
            async: true
          },
          path: params2?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform3) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform: transform3 }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options2) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
      }
      ip(options2) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
      }
      cidr(options2) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
      }
      datetime(options2) {
        if (typeof options2 === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options2
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
          offset: options2?.offset ?? false,
          local: options2?.local ?? false,
          ...errorUtil.errToObj(options2?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options2) {
        if (typeof options2 === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options2
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
          ...errorUtil.errToObj(options2?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options2) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options2?.position,
          ...errorUtil.errToObj(options2?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params2) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params2?.coerce ?? false,
        ...processCreateParams(params2)
      });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params2) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params2?.coerce || false,
        ...processCreateParams(params2)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params2) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params2?.coerce ?? false,
        ...processCreateParams(params2)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params2) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params2?.coerce || false,
        ...processCreateParams(params2)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params2) => {
      return new ZodDate({
        checks: [],
        coerce: params2?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params2)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params2) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params2)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params2) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params2)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params2) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params2)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params2) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params2)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params2) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params2)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params2) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params2)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params2) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params2)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params2) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params2)
      });
    };
    ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key2 in ctx.data) {
            if (!shapeKeys.includes(key2)) {
              extraKeys.push(key2);
            }
          }
        }
        const pairs = [];
        for (const key2 of shapeKeys) {
          const keyValidator = shape[key2];
          const value = ctx.data[key2];
          pairs.push({
            key: { status: "valid", value: key2 },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
            alwaysSet: key2 in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key2 of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key2 },
                value: { status: "valid", value: ctx.data[key2] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key2 of extraKeys) {
            const value = ctx.data[key2];
            pairs.push({
              key: { status: "valid", value: key2 },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key2)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key2 in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key2 = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key: key2,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key2, schema) {
        return this.augment({ [key2]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index8) {
        return new _ZodObject({
          ...this._def,
          catchall: index8
        });
      }
      pick(mask) {
        const shape = {};
        for (const key2 of util.objectKeys(mask)) {
          if (mask[key2] && this.shape[key2]) {
            shape[key2] = this.shape[key2];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        for (const key2 of util.objectKeys(this.shape)) {
          if (!mask[key2]) {
            shape[key2] = this.shape[key2];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key2 of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key2];
          if (mask && !mask[key2]) {
            newShape[key2] = fieldSchema;
          } else {
            newShape[key2] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        for (const key2 of util.objectKeys(this.shape)) {
          if (mask && !mask[key2]) {
            newShape[key2] = this.shape[key2];
          } else {
            const fieldSchema = this.shape[key2];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key2] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params2) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.strictCreate = (shape, params2) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.lazycreate = (shape, params2) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options2 = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options2.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options2) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params2) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params2)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options2, params2) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options2) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options: options2,
          optionsMap,
          ...processCreateParams(params2)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params2) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params2)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params2) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params2)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key2 in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
            alwaysSet: key2 in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key2, value], index8) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index8, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index8, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key2 = await pair.key;
              const value = await pair.value;
              if (key2.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key2.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key2.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key2 = pair.key;
            const value = pair.value;
            if (key2.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key2.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key2.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params2) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params2)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element2 of elements2) {
            if (element2.status === "aborted")
              return INVALID;
            if (element2.status === "dirty")
              status.dirty();
            parsedSet.add(element2.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params2) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params2)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error2) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error2
            }
          });
        }
        function makeReturnsIssue(returns, error2) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error2
            }
          });
        }
        const params2 = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error2 = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params2).catch((e3) => {
              error2.addIssue(makeArgsIssue(args, e3));
              throw error2;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params2).catch((e3) => {
              error2.addIssue(makeReturnsIssue(result, e3));
              throw error2;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params2);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params2);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params2) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params2)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params2) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params2)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params2) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params2)
      });
    };
    ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params2) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params2)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params2) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params2)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY2(result.value);
              if (status.value === "dirty")
                return DIRTY2(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY2(result.value);
            if (status.value === "dirty")
              return DIRTY2(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base2 = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base2))
              return INVALID;
            const result = effect.transform(base2.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
              if (!isValid(base2))
                return INVALID;
              return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params2) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params2)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params2) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params2)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params2) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params2)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params2) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params2)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params2) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default,
        ...processCreateParams(params2)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params2) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch,
        ...processCreateParams(params2)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params2) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params2)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY2(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params2) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params2)
      });
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params2 = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params2);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
  }
});

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY2,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
var init_external = __esm({
  "node_modules/zod/v3/external.js"() {
    init_errors();
    init_parseUtil();
    init_typeAliases();
    init_util2();
    init_types2();
    init_ZodError();
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_external();
    init_external();
  }
});

// node_modules/@allmaps/annotation/dist/schemas/shared.js
function ensureArray(val) {
  if (val) {
    return Array.isArray(val) ? val : [val];
  }
}
function parseInvalidTransformation(val) {
  const valLowerCase = val.toLowerCase();
  if (valLowerCase === "thinplatespline" || valLowerCase === "thin-plate-spline") {
    return {
      type: "thinPlateSpline"
    };
  } else if (valLowerCase === "polynomial1") {
    return {
      type: "polynomial",
      options: { order: 1 }
    };
  } else if (valLowerCase === "polynomial2") {
    return {
      type: "polynomial",
      options: { order: 2 }
    };
  }
}
var SingleValueSchema, LanguageValueSchema, PointSchema, PointGeometrySchema, ResourceMaskSchema, ImageServices, ResourceTypes, ImageServiceSchema, ResourceTypeSchema, basePartOfItemSchema, PartOfItemSchema, PartOfSchema, ValidTransformationSchema, TransformationSchema, ProjectionSchema, ContextSchema;
var init_shared = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/shared.js"() {
    init_zod();
    SingleValueSchema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]);
    LanguageValueSchema = external_exports.record(external_exports.string(), SingleValueSchema.array());
    PointSchema = external_exports.tuple([external_exports.number(), external_exports.number()]);
    PointGeometrySchema = external_exports.object({
      type: external_exports.literal("Point"),
      coordinates: PointSchema
    });
    ResourceMaskSchema = PointSchema.array().min(3);
    ImageServices = [
      "ImageService1",
      "ImageService2",
      "ImageService3"
    ];
    ResourceTypes = [...ImageServices, ...["Canvas"]];
    ImageServiceSchema = external_exports.enum(ImageServices);
    ResourceTypeSchema = external_exports.enum(ResourceTypes);
    basePartOfItemSchema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string(),
      label: LanguageValueSchema.optional()
    });
    PartOfItemSchema = basePartOfItemSchema.extend({
      partOf: external_exports.lazy(() => PartOfItemSchema.array()).optional()
    });
    PartOfSchema = external_exports.union([PartOfItemSchema.array(), PartOfItemSchema]).transform(ensureArray);
    ValidTransformationSchema = external_exports.object({
      type: external_exports.enum(["helmert", "polynomial", "thinPlateSpline", "projective"]),
      options: external_exports.object({}).passthrough().optional()
    });
    TransformationSchema = external_exports.union([
      ValidTransformationSchema,
      // Catchall for unknown transformation types
      external_exports.unknown()
    ]).transform((val) => {
      const { success, data } = ValidTransformationSchema.safeParse(val);
      if (success) {
        return data;
      } else if (val === "string") {
        return parseInvalidTransformation(val);
      } else if (val && typeof val === "object" && "type" in val && typeof val.type === "string") {
        return parseInvalidTransformation(val.type);
      }
    });
    ProjectionSchema = external_exports.object({
      name: external_exports.string().optional(),
      definition: external_exports.union([external_exports.string(), external_exports.unknown()])
    });
    ContextSchema = external_exports.union([
      external_exports.string().url().array(),
      external_exports.string().url()
    ]);
  }
});

// node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.0.js
var svg, SvgSelectorSchema, TargetSchema, FeaturePropertiesSchema, BodySchema, AnnotationSchema, AnnotationPageSchema;
var init_annotation_0 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.0.js"() {
    init_zod();
    init_shared();
    svg = /^<svg\s+width="\d+"\s+height="\d+"\s*>\s*<polygon\s+points="\s*(-?\d+(\.\d+)?,-?\d+(\.\d+)?\s+){2,}-?\d+(\.\d+)?,-?\d+(\.\d+)?\s*"\s*\/>\s*<\/svg>$/;
    SvgSelectorSchema = external_exports.object({
      type: external_exports.literal("SvgSelector"),
      value: external_exports.string().regex(svg)
    });
    TargetSchema = external_exports.object({
      source: external_exports.string().url(),
      service: external_exports.array(external_exports.object({
        "@id": external_exports.string().url(),
        type: ResourceTypeSchema
      })).length(1),
      selector: SvgSelectorSchema
    });
    FeaturePropertiesSchema = external_exports.object({
      pixelCoords: PointSchema
    });
    BodySchema = external_exports.object({
      type: external_exports.literal("FeatureCollection"),
      transformation: TransformationSchema.optional(),
      features: external_exports.array(external_exports.object({
        type: external_exports.literal("Feature"),
        properties: FeaturePropertiesSchema,
        geometry: PointGeometrySchema
      }))
    });
    AnnotationSchema = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("Annotation"),
      "@context": ContextSchema.optional(),
      motivation: external_exports.string().default("georeferencing").optional(),
      target: TargetSchema,
      body: BodySchema
    });
    AnnotationPageSchema = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("AnnotationPage"),
      "@context": ContextSchema.optional(),
      items: external_exports.array(AnnotationSchema)
    });
  }
});

// node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.1.js
var polygonRegex, svgWidthHeightRegex, svgHeightWidthRegex, svgRegex, SvgRegexSchema, SvgWidthHeightRegexSchema, SvgHeightWidthRegexSchema, SvgSelectorSchema2, Source1Schema, Source2Schema, Canvas3Schema, SourceSchema, TargetSchema2, FeaturePropertiesSchema2, BodySchema2, AnnotationSchema2, AnnotationPageSchema2;
var init_annotation_1 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/annotation/annotation.1.js"() {
    init_zod();
    init_shared();
    polygonRegex = /<polygon\s+points="\s*(-?\d+(\.\d+)?,-?\d+(\.\d+)?\s+){2,}-?\d+(\.\d+)?,-?\d+(\.\d+)?\s*"\s*\/>/;
    svgWidthHeightRegex = new RegExp(`^<svg\\s+width="\\d+"\\s+height="\\d+"\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
    svgHeightWidthRegex = new RegExp(`^<svg\\s+height="\\d+"\\s+width="\\d+"\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
    svgRegex = new RegExp(`^<svg\\s*>\\s*${polygonRegex.source}\\s*</svg>$`);
    SvgRegexSchema = external_exports.string().regex(svgRegex);
    SvgWidthHeightRegexSchema = external_exports.string().regex(svgWidthHeightRegex);
    SvgHeightWidthRegexSchema = external_exports.string().regex(svgHeightWidthRegex);
    SvgSelectorSchema2 = external_exports.object({
      type: external_exports.literal("SvgSelector"),
      value: external_exports.union([
        SvgRegexSchema,
        SvgWidthHeightRegexSchema,
        SvgHeightWidthRegexSchema
      ])
    });
    Source1Schema = external_exports.object({
      "@id": external_exports.string().url(),
      type: ImageServiceSchema,
      height: external_exports.number().positive(),
      width: external_exports.number().positive(),
      partOf: PartOfSchema.optional()
    });
    Source2Schema = external_exports.object({
      id: external_exports.string().url(),
      type: ImageServiceSchema,
      height: external_exports.number().positive().optional(),
      width: external_exports.number().positive().optional(),
      partOf: PartOfSchema.optional()
    });
    Canvas3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Canvas"),
      height: external_exports.number().positive().optional(),
      width: external_exports.number().positive().optional(),
      partOf: PartOfSchema.optional()
    });
    SourceSchema = external_exports.union([
      Source1Schema,
      Source2Schema,
      Canvas3Schema
    ]);
    TargetSchema2 = external_exports.object({
      type: external_exports.literal("SpecificResource"),
      source: SourceSchema,
      // selector: z.union([SvgSelectorSchema, ImageApiSelectorSchema])
      selector: SvgSelectorSchema2
    });
    FeaturePropertiesSchema2 = external_exports.object({
      resourceCoords: PointSchema
    });
    BodySchema2 = external_exports.object({
      type: external_exports.literal("FeatureCollection"),
      transformation: TransformationSchema.optional(),
      resourceCrs: ProjectionSchema.optional(),
      features: external_exports.array(external_exports.object({
        type: external_exports.literal("Feature"),
        properties: FeaturePropertiesSchema2,
        geometry: PointGeometrySchema
      }))
    });
    AnnotationSchema2 = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("Annotation"),
      "@context": ContextSchema.optional(),
      motivation: external_exports.string().default("georeferencing").optional(),
      created: external_exports.string().datetime().optional(),
      modified: external_exports.string().datetime().optional(),
      target: TargetSchema2,
      body: BodySchema2
    });
    AnnotationPageSchema2 = external_exports.object({
      id: external_exports.string().optional(),
      type: external_exports.literal("AnnotationPage"),
      "@context": ContextSchema.optional(),
      items: external_exports.array(AnnotationSchema2)
    });
  }
});

// node_modules/@allmaps/annotation/dist/schemas/annotation.js
var AnnotationAllVersionsSchema, AnnotationPageAllVersionsSchema, FeaturePropertiesAllVersionsSchema;
var init_annotation = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/annotation.js"() {
    init_zod();
    init_annotation_0();
    init_annotation_1();
    init_shared();
    AnnotationAllVersionsSchema = external_exports.union([
      AnnotationSchema,
      AnnotationSchema2
    ]);
    AnnotationPageAllVersionsSchema = external_exports.union([
      AnnotationPageSchema,
      AnnotationPageSchema2
    ]);
    FeaturePropertiesAllVersionsSchema = external_exports.union([
      FeaturePropertiesSchema,
      FeaturePropertiesSchema2
    ]);
  }
});

// node_modules/@allmaps/annotation/dist/before-parse.js
var init_before_parse = __esm({
  "node_modules/@allmaps/annotation/dist/before-parse.js"() {
  }
});

// node_modules/@allmaps/annotation/dist/guards.js
var init_guards = __esm({
  "node_modules/@allmaps/annotation/dist/guards.js"() {
  }
});

// node_modules/@allmaps/annotation/dist/parser.js
var init_parser = __esm({
  "node_modules/@allmaps/annotation/dist/parser.js"() {
    init_annotation();
    init_before_parse();
    init_guards();
  }
});

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.1.js
var GCPSchema, ImageSchema, GeoreferencedMapSchema, GeoreferencedMapsSchema;
var init_georeferenced_map_1 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.1.js"() {
    init_zod();
    init_shared();
    GCPSchema = external_exports.object({
      image: PointSchema,
      world: PointSchema
    });
    ImageSchema = external_exports.object({
      uri: external_exports.string().url(),
      width: external_exports.number(),
      height: external_exports.number(),
      type: ImageServiceSchema
    });
    GeoreferencedMapSchema = external_exports.object({
      id: external_exports.string().optional(),
      version: external_exports.number().min(1).max(1).default(1),
      image: ImageSchema,
      gcps: GCPSchema.array(),
      pixelMask: ResourceMaskSchema,
      transformation: TransformationSchema.optional()
    });
    GeoreferencedMapsSchema = external_exports.array(GeoreferencedMapSchema);
  }
});

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.2.js
var GCPSchema2, ResourceSchema, GeoreferencedMapSchema2, GeoreferencedMapsSchema2;
var init_georeferenced_map_2 = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/georeferenced-map/georeferenced-map.2.js"() {
    init_zod();
    init_shared();
    GCPSchema2 = external_exports.object({
      resource: PointSchema,
      geo: PointSchema
    });
    ResourceSchema = external_exports.object({
      id: external_exports.string().url(),
      height: external_exports.number().positive().optional(),
      width: external_exports.number().positive().optional(),
      type: ResourceTypeSchema,
      partOf: PartOfSchema.optional()
    });
    GeoreferencedMapSchema2 = external_exports.object({
      "@context": external_exports.literal("https://schemas.allmaps.org/map/2/context.json").optional(),
      type: external_exports.literal("GeoreferencedMap"),
      id: external_exports.string().optional(),
      created: external_exports.string().datetime().optional(),
      modified: external_exports.string().datetime().optional(),
      resource: ResourceSchema,
      gcps: GCPSchema2.array(),
      resourceMask: ResourceMaskSchema,
      transformation: TransformationSchema.optional(),
      resourceCrs: ProjectionSchema.optional()
    });
    GeoreferencedMapsSchema2 = external_exports.array(GeoreferencedMapSchema2);
  }
});

// node_modules/@allmaps/annotation/dist/schemas/georeferenced-map.js
var GeoreferencedMapAllVersionsSchema, GeoreferencedMapsAllVersionsSchema, GCPAllVersionsSchema;
var init_georeferenced_map = __esm({
  "node_modules/@allmaps/annotation/dist/schemas/georeferenced-map.js"() {
    init_zod();
    init_georeferenced_map_1();
    init_georeferenced_map_2();
    init_shared();
    GeoreferencedMapAllVersionsSchema = external_exports.union([
      GeoreferencedMapSchema,
      GeoreferencedMapSchema2
    ]);
    GeoreferencedMapsAllVersionsSchema = external_exports.union([
      GeoreferencedMapsSchema,
      GeoreferencedMapsSchema2
    ]);
    GCPAllVersionsSchema = external_exports.union([
      GCPSchema,
      GCPSchema2
    ]);
  }
});

// node_modules/@allmaps/annotation/dist/generator.js
var init_generator = __esm({
  "node_modules/@allmaps/annotation/dist/generator.js"() {
    init_georeferenced_map();
    init_before_parse();
    init_guards();
  }
});

// node_modules/@allmaps/annotation/dist/convert.js
var init_convert = __esm({
  "node_modules/@allmaps/annotation/dist/convert.js"() {
    init_parser();
    init_generator();
    init_guards();
  }
});

// node_modules/@allmaps/annotation/dist/validator.js
var init_validator = __esm({
  "node_modules/@allmaps/annotation/dist/validator.js"() {
    init_annotation();
    init_georeferenced_map();
    init_convert();
    init_before_parse();
  }
});

// node_modules/@allmaps/annotation/dist/index.js
var init_dist5 = __esm({
  "node_modules/@allmaps/annotation/dist/index.js"() {
    init_parser();
    init_generator();
    init_validator();
    init_georeferenced_map();
    init_annotation();
    init_shared();
  }
});

// node_modules/proj4/lib/global.js
function global_default(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var i = 1; i <= 60; ++i) {
    defs2("EPSG:" + (32600 + i), "+proj=utm +zone=" + i + " +datum=WGS84 +units=m");
    defs2("EPSG:" + (32700 + i), "+proj=utm +zone=" + i + " +south +datum=WGS84 +units=m");
  }
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}
var init_global = __esm({
  "node_modules/proj4/lib/global.js"() {
  }
});

// node_modules/proj4/lib/constants/values.js
var PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT, PJD_WGS84, PJD_NODATUM, SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR, SRS_WGS84_ESQUARED, SEC_TO_RAD, HALF_PI, SIXTH, RA4, RA6, EPSLN, D2R, R2D, FORTPI, TWO_PI, SPI;
var init_values = __esm({
  "node_modules/proj4/lib/constants/values.js"() {
    PJD_3PARAM = 1;
    PJD_7PARAM = 2;
    PJD_GRIDSHIFT = 3;
    PJD_WGS84 = 4;
    PJD_NODATUM = 5;
    SRS_WGS84_SEMIMAJOR = 6378137;
    SRS_WGS84_SEMIMINOR = 6356752314e-3;
    SRS_WGS84_ESQUARED = 0.0066943799901413165;
    SEC_TO_RAD = 484813681109536e-20;
    HALF_PI = Math.PI / 2;
    SIXTH = 0.16666666666666666;
    RA4 = 0.04722222222222222;
    RA6 = 0.022156084656084655;
    EPSLN = 1e-10;
    D2R = 0.017453292519943295;
    R2D = 57.29577951308232;
    FORTPI = Math.PI / 4;
    TWO_PI = Math.PI * 2;
    SPI = 3.14159265359;
  }
});

// node_modules/proj4/lib/constants/PrimeMeridian.js
var primeMeridian, PrimeMeridian_default;
var init_PrimeMeridian = __esm({
  "node_modules/proj4/lib/constants/PrimeMeridian.js"() {
    primeMeridian = {};
    primeMeridian.greenwich = 0;
    primeMeridian.lisbon = -9.131906111111;
    primeMeridian.paris = 2.337229166667;
    primeMeridian.bogota = -74.080916666667;
    primeMeridian.madrid = -3.687938888889;
    primeMeridian.rome = 12.452333333333;
    primeMeridian.bern = 7.439583333333;
    primeMeridian.jakarta = 106.807719444444;
    primeMeridian.ferro = -17.666666666667;
    primeMeridian.brussels = 4.367975;
    primeMeridian.stockholm = 18.058277777778;
    primeMeridian.athens = 23.7163375;
    primeMeridian.oslo = 10.722916666667;
    PrimeMeridian_default = primeMeridian;
  }
});

// node_modules/proj4/lib/constants/units.js
var units_default;
var init_units = __esm({
  "node_modules/proj4/lib/constants/units.js"() {
    units_default = {
      mm: { to_meter: 1e-3 },
      cm: { to_meter: 0.01 },
      ft: { to_meter: 0.3048 },
      "us-ft": { to_meter: 1200 / 3937 },
      fath: { to_meter: 1.8288 },
      kmi: { to_meter: 1852 },
      "us-ch": { to_meter: 20.1168402336805 },
      "us-mi": { to_meter: 1609.34721869444 },
      km: { to_meter: 1e3 },
      "ind-ft": { to_meter: 0.30479841 },
      "ind-yd": { to_meter: 0.91439523 },
      mi: { to_meter: 1609.344 },
      yd: { to_meter: 0.9144 },
      ch: { to_meter: 20.1168 },
      link: { to_meter: 0.201168 },
      dm: { to_meter: 0.1 },
      in: { to_meter: 0.0254 },
      "ind-ch": { to_meter: 20.11669506 },
      "us-in": { to_meter: 0.025400050800101 },
      "us-yd": { to_meter: 0.914401828803658 }
    };
  }
});

// node_modules/proj4/lib/match.js
function match(obj, key2) {
  if (obj[key2]) {
    return obj[key2];
  }
  var keys = Object.keys(obj);
  var lkey = key2.toLowerCase().replace(ignoredChar, "");
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}
var ignoredChar;
var init_match = __esm({
  "node_modules/proj4/lib/match.js"() {
    ignoredChar = /[\s_\-\/\(\)]/g;
  }
});

// node_modules/proj4/lib/projString.js
function projString_default(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v2) {
    return v2.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split = a.split("=");
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v2) {
      self2.rf = parseFloat(v2);
    },
    lat_0: function(v2) {
      self2.lat0 = v2 * D2R;
    },
    lat_1: function(v2) {
      self2.lat1 = v2 * D2R;
    },
    lat_2: function(v2) {
      self2.lat2 = v2 * D2R;
    },
    lat_ts: function(v2) {
      self2.lat_ts = v2 * D2R;
    },
    lon_0: function(v2) {
      self2.long0 = v2 * D2R;
    },
    lon_1: function(v2) {
      self2.long1 = v2 * D2R;
    },
    lon_2: function(v2) {
      self2.long2 = v2 * D2R;
    },
    alpha: function(v2) {
      self2.alpha = parseFloat(v2) * D2R;
    },
    gamma: function(v2) {
      self2.rectified_grid_angle = parseFloat(v2) * D2R;
    },
    lonc: function(v2) {
      self2.longc = v2 * D2R;
    },
    x_0: function(v2) {
      self2.x0 = parseFloat(v2);
    },
    y_0: function(v2) {
      self2.y0 = parseFloat(v2);
    },
    k_0: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    k: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    a: function(v2) {
      self2.a = parseFloat(v2);
    },
    b: function(v2) {
      self2.b = parseFloat(v2);
    },
    r: function(v2) {
      self2.a = self2.b = parseFloat(v2);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v2) {
      self2.zone = parseInt(v2, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v2) {
      self2.datum_params = v2.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v2) {
      self2.to_meter = parseFloat(v2);
    },
    units: function(v2) {
      self2.units = v2;
      var unit = match(units_default, v2);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v2) {
      self2.from_greenwich = v2 * D2R;
    },
    pm: function(v2) {
      var pm = match(PrimeMeridian_default, v2);
      self2.from_greenwich = (pm ? pm : parseFloat(v2)) * D2R;
    },
    nadgrids: function(v2) {
      if (v2 === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v2;
      }
    },
    axis: function(v2) {
      var legalAxis = "ewnsud";
      if (v2.length === 3 && legalAxis.indexOf(v2.substr(0, 1)) !== -1 && legalAxis.indexOf(v2.substr(1, 1)) !== -1 && legalAxis.indexOf(v2.substr(2, 1)) !== -1) {
        self2.axis = v2;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}
var init_projString = __esm({
  "node_modules/proj4/lib/projString.js"() {
    init_values();
    init_PrimeMeridian();
    init_units();
    init_match();
  }
});

// node_modules/wkt-parser/PROJJSONBuilderBase.js
var PROJJSONBuilderBase, PROJJSONBuilderBase_default;
var init_PROJJSONBuilderBase = __esm({
  "node_modules/wkt-parser/PROJJSONBuilderBase.js"() {
    PROJJSONBuilderBase = class {
      static getId(node) {
        const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
        if (idNode && idNode.length >= 3) {
          return {
            authority: idNode[1],
            code: parseInt(idNode[2], 10)
          };
        }
        return null;
      }
      static convertUnit(node, type = "unit") {
        if (!node || node.length < 3) {
          return { type, name: "unknown", conversion_factor: null };
        }
        const name = node[1];
        const conversionFactor = parseFloat(node[2]) || null;
        const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
        const id = idNode ? {
          authority: idNode[1],
          code: parseInt(idNode[2], 10)
        } : null;
        return {
          type,
          name,
          conversion_factor: conversionFactor,
          id
        };
      }
      static convertAxis(node) {
        const name = node[1] || "Unknown";
        let direction;
        const abbreviationMatch = name.match(/^\((.)\)$/);
        if (abbreviationMatch) {
          const abbreviation = abbreviationMatch[1].toUpperCase();
          if (abbreviation === "E") direction = "east";
          else if (abbreviation === "N") direction = "north";
          else if (abbreviation === "U") direction = "up";
          else throw new Error(`Unknown axis abbreviation: ${abbreviation}`);
        } else {
          direction = node[2] ? node[2].toLowerCase() : "unknown";
        }
        const orderNode = node.find((child) => Array.isArray(child) && child[0] === "ORDER");
        const order = orderNode ? parseInt(orderNode[1], 10) : null;
        const unitNode = node.find(
          (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
        );
        const unit = this.convertUnit(unitNode);
        return {
          name,
          direction,
          // Use the valid PROJJSON direction value
          unit,
          order
        };
      }
      static extractAxes(node) {
        return node.filter((child) => Array.isArray(child) && child[0] === "AXIS").map((axis) => this.convertAxis(axis)).sort((a, b) => (a.order || 0) - (b.order || 0));
      }
      static convert(node, result = {}) {
        switch (node[0]) {
          case "PROJCRS":
            result.type = "ProjectedCRS";
            result.name = node[1];
            result.base_crs = node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS")) : null;
            result.conversion = node.find((child) => Array.isArray(child) && child[0] === "CONVERSION") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "CONVERSION")) : null;
            const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
            if (csNode) {
              result.coordinate_system = {
                type: csNode[1],
                axis: this.extractAxes(node)
              };
            }
            const lengthUnitNode = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT");
            if (lengthUnitNode) {
              const unit2 = this.convertUnit(lengthUnitNode);
              result.coordinate_system.unit = unit2;
            }
            result.id = this.getId(node);
            break;
          case "BASEGEOGCRS":
          case "GEOGCRS":
            result.type = "GeographicCRS";
            result.name = node[1];
            const datumOrEnsembleNode = node.find(
              (child) => Array.isArray(child) && (child[0] === "DATUM" || child[0] === "ENSEMBLE")
            );
            if (datumOrEnsembleNode) {
              const datumOrEnsemble = this.convert(datumOrEnsembleNode);
              if (datumOrEnsembleNode[0] === "ENSEMBLE") {
                result.datum_ensemble = datumOrEnsemble;
              } else {
                result.datum = datumOrEnsemble;
              }
              const primem = node.find((child) => Array.isArray(child) && child[0] === "PRIMEM");
              if (primem && primem[1] !== "Greenwich") {
                datumOrEnsemble.prime_meridian = {
                  name: primem[1],
                  longitude: parseFloat(primem[2])
                };
              }
            }
            result.coordinate_system = {
              type: "ellipsoidal",
              axis: this.extractAxes(node)
            };
            result.id = this.getId(node);
            break;
          case "DATUM":
            result.type = "GeodeticReferenceFrame";
            result.name = node[1];
            result.ellipsoid = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID")) : null;
            break;
          case "ENSEMBLE":
            result.type = "DatumEnsemble";
            result.name = node[1];
            result.members = node.filter((child) => Array.isArray(child) && child[0] === "MEMBER").map((member) => ({
              type: "DatumEnsembleMember",
              name: member[1],
              id: this.getId(member)
              // Extract ID as { authority, code }
            }));
            const accuracyNode = node.find((child) => Array.isArray(child) && child[0] === "ENSEMBLEACCURACY");
            if (accuracyNode) {
              result.accuracy = parseFloat(accuracyNode[1]);
            }
            const ellipsoidNode = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID");
            if (ellipsoidNode) {
              result.ellipsoid = this.convert(ellipsoidNode);
            }
            result.id = this.getId(node);
            break;
          case "ELLIPSOID":
            result.type = "Ellipsoid";
            result.name = node[1];
            result.semi_major_axis = parseFloat(node[2]);
            result.inverse_flattening = parseFloat(node[3]);
            const units = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT"), result) : null;
            break;
          case "CONVERSION":
            result.type = "Conversion";
            result.name = node[1];
            result.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
            result.parameters = node.filter((child) => Array.isArray(child) && child[0] === "PARAMETER").map((param) => this.convert(param));
            break;
          case "METHOD":
            result.type = "Method";
            result.name = node[1];
            result.id = this.getId(node);
            break;
          case "PARAMETER":
            result.type = "Parameter";
            result.name = node[1];
            result.value = parseFloat(node[2]);
            result.unit = this.convertUnit(
              node.find(
                (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
              )
            );
            result.id = this.getId(node);
            break;
          case "BOUNDCRS":
            result.type = "BoundCRS";
            const sourceCrsNode = node.find((child) => Array.isArray(child) && child[0] === "SOURCECRS");
            if (sourceCrsNode) {
              const sourceCrsContent = sourceCrsNode.find((child) => Array.isArray(child));
              result.source_crs = sourceCrsContent ? this.convert(sourceCrsContent) : null;
            }
            const targetCrsNode = node.find((child) => Array.isArray(child) && child[0] === "TARGETCRS");
            if (targetCrsNode) {
              const targetCrsContent = targetCrsNode.find((child) => Array.isArray(child));
              result.target_crs = targetCrsContent ? this.convert(targetCrsContent) : null;
            }
            const transformationNode = node.find((child) => Array.isArray(child) && child[0] === "ABRIDGEDTRANSFORMATION");
            if (transformationNode) {
              result.transformation = this.convert(transformationNode);
            } else {
              result.transformation = null;
            }
            break;
          case "ABRIDGEDTRANSFORMATION":
            result.type = "Transformation";
            result.name = node[1];
            result.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
            result.parameters = node.filter((child) => Array.isArray(child) && (child[0] === "PARAMETER" || child[0] === "PARAMETERFILE")).map((param) => {
              if (param[0] === "PARAMETER") {
                return this.convert(param);
              } else if (param[0] === "PARAMETERFILE") {
                return {
                  name: param[1],
                  value: param[2],
                  id: {
                    "authority": "EPSG",
                    "code": 8656
                  }
                };
              }
            });
            if (result.parameters.length === 7) {
              const scaleDifference = result.parameters[6];
              if (scaleDifference.name === "Scale difference") {
                scaleDifference.value = Math.round((scaleDifference.value - 1) * 1e12) / 1e6;
              }
            }
            result.id = this.getId(node);
            break;
          case "AXIS":
            if (!result.coordinate_system) {
              result.coordinate_system = { type: "unspecified", axis: [] };
            }
            result.coordinate_system.axis.push(this.convertAxis(node));
            break;
          case "LENGTHUNIT":
            const unit = this.convertUnit(node, "LinearUnit");
            if (result.coordinate_system && result.coordinate_system.axis) {
              result.coordinate_system.axis.forEach((axis) => {
                if (!axis.unit) {
                  axis.unit = unit;
                }
              });
            }
            if (unit.conversion_factor && unit.conversion_factor !== 1) {
              if (result.semi_major_axis) {
                result.semi_major_axis = {
                  value: result.semi_major_axis,
                  unit
                };
              }
            }
            break;
          default:
            result.keyword = node[0];
            break;
        }
        return result;
      }
    };
    PROJJSONBuilderBase_default = PROJJSONBuilderBase;
  }
});

// node_modules/wkt-parser/PROJJSONBuilder2015.js
var PROJJSONBuilder2015, PROJJSONBuilder2015_default;
var init_PROJJSONBuilder2015 = __esm({
  "node_modules/wkt-parser/PROJJSONBuilder2015.js"() {
    init_PROJJSONBuilderBase();
    PROJJSONBuilder2015 = class extends PROJJSONBuilderBase_default {
      static convert(node, result = {}) {
        super.convert(node, result);
        if (result.coordinate_system && result.coordinate_system.subtype === "Cartesian") {
          delete result.coordinate_system;
        }
        if (result.usage) {
          delete result.usage;
        }
        return result;
      }
    };
    PROJJSONBuilder2015_default = PROJJSONBuilder2015;
  }
});

// node_modules/wkt-parser/PROJJSONBuilder2019.js
var PROJJSONBuilder2019, PROJJSONBuilder2019_default;
var init_PROJJSONBuilder2019 = __esm({
  "node_modules/wkt-parser/PROJJSONBuilder2019.js"() {
    init_PROJJSONBuilderBase();
    PROJJSONBuilder2019 = class extends PROJJSONBuilderBase_default {
      static convert(node, result = {}) {
        super.convert(node, result);
        const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
        if (csNode) {
          result.coordinate_system = {
            subtype: csNode[1],
            axis: this.extractAxes(node)
          };
        }
        const usageNode = node.find((child) => Array.isArray(child) && child[0] === "USAGE");
        if (usageNode) {
          const scope = usageNode.find((child) => Array.isArray(child) && child[0] === "SCOPE");
          const area = usageNode.find((child) => Array.isArray(child) && child[0] === "AREA");
          const bbox = usageNode.find((child) => Array.isArray(child) && child[0] === "BBOX");
          result.usage = {};
          if (scope) {
            result.usage.scope = scope[1];
          }
          if (area) {
            result.usage.area = area[1];
          }
          if (bbox) {
            result.usage.bbox = bbox.slice(1);
          }
        }
        return result;
      }
    };
    PROJJSONBuilder2019_default = PROJJSONBuilder2019;
  }
});

// node_modules/wkt-parser/buildPROJJSON.js
function detectWKT2Version(root2) {
  if (root2.find((child) => Array.isArray(child) && child[0] === "USAGE")) {
    return "2019";
  }
  if (root2.find((child) => Array.isArray(child) && child[0] === "CS")) {
    return "2015";
  }
  if (root2[0] === "BOUNDCRS" || root2[0] === "PROJCRS" || root2[0] === "GEOGCRS") {
    return "2015";
  }
  return "2015";
}
function buildPROJJSON(root2) {
  const version = detectWKT2Version(root2);
  const builder = version === "2019" ? PROJJSONBuilder2019_default : PROJJSONBuilder2015_default;
  return builder.convert(root2);
}
var init_buildPROJJSON = __esm({
  "node_modules/wkt-parser/buildPROJJSON.js"() {
    init_PROJJSONBuilder2015();
    init_PROJJSONBuilder2019();
  }
});

// node_modules/wkt-parser/detectWKTVersion.js
function detectWKTVersion(wkt) {
  const normalizedWKT = wkt.toUpperCase();
  if (normalizedWKT.includes("PROJCRS") || normalizedWKT.includes("GEOGCRS") || normalizedWKT.includes("BOUNDCRS") || normalizedWKT.includes("VERTCRS") || normalizedWKT.includes("LENGTHUNIT") || normalizedWKT.includes("ANGLEUNIT") || normalizedWKT.includes("SCALEUNIT")) {
    return "WKT2";
  }
  if (normalizedWKT.includes("PROJCS") || normalizedWKT.includes("GEOGCS") || normalizedWKT.includes("LOCAL_CS") || normalizedWKT.includes("VERT_CS") || normalizedWKT.includes("UNIT")) {
    return "WKT1";
  }
  return "WKT1";
}
var init_detectWKTVersion = __esm({
  "node_modules/wkt-parser/detectWKTVersion.js"() {
  }
});

// node_modules/wkt-parser/parser.js
function Parser(text2) {
  if (typeof text2 !== "string") {
    throw new Error("not a string");
  }
  this.text = text2.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
function parseString2(txt) {
  var parser = new Parser(txt);
  return parser.output();
}
var parser_default, NEUTRAL, KEYWORD, NUMBER, QUOTED, AFTERQUOTE, ENDED, whitespace2, latin, keyword, endThings, digets;
var init_parser2 = __esm({
  "node_modules/wkt-parser/parser.js"() {
    parser_default = parseString2;
    NEUTRAL = 1;
    KEYWORD = 2;
    NUMBER = 3;
    QUOTED = 4;
    AFTERQUOTE = 5;
    ENDED = -1;
    whitespace2 = /\s/;
    latin = /[A-Za-z]/;
    keyword = /[A-Za-z84_]/;
    endThings = /[,\]]/;
    digets = /[\d\.E\-\+]/;
    Parser.prototype.readCharicter = function() {
      var char = this.text[this.place++];
      if (this.state !== QUOTED) {
        while (whitespace2.test(char)) {
          if (this.place >= this.text.length) {
            return;
          }
          char = this.text[this.place++];
        }
      }
      switch (this.state) {
        case NEUTRAL:
          return this.neutral(char);
        case KEYWORD:
          return this.keyword(char);
        case QUOTED:
          return this.quoted(char);
        case AFTERQUOTE:
          return this.afterquote(char);
        case NUMBER:
          return this.number(char);
        case ENDED:
          return;
      }
    };
    Parser.prototype.afterquote = function(char) {
      if (char === '"') {
        this.word += '"';
        this.state = QUOTED;
        return;
      }
      if (endThings.test(char)) {
        this.word = this.word.trim();
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
    };
    Parser.prototype.afterItem = function(char) {
      if (char === ",") {
        if (this.word !== null) {
          this.currentObject.push(this.word);
        }
        this.word = null;
        this.state = NEUTRAL;
        return;
      }
      if (char === "]") {
        this.level--;
        if (this.word !== null) {
          this.currentObject.push(this.word);
          this.word = null;
        }
        this.state = NEUTRAL;
        this.currentObject = this.stack.pop();
        if (!this.currentObject) {
          this.state = ENDED;
        }
        return;
      }
    };
    Parser.prototype.number = function(char) {
      if (digets.test(char)) {
        this.word += char;
        return;
      }
      if (endThings.test(char)) {
        this.word = parseFloat(this.word);
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
    };
    Parser.prototype.quoted = function(char) {
      if (char === '"') {
        this.state = AFTERQUOTE;
        return;
      }
      this.word += char;
      return;
    };
    Parser.prototype.keyword = function(char) {
      if (keyword.test(char)) {
        this.word += char;
        return;
      }
      if (char === "[") {
        var newObjects = [];
        newObjects.push(this.word);
        this.level++;
        if (this.root === null) {
          this.root = newObjects;
        } else {
          this.currentObject.push(newObjects);
        }
        this.stack.push(this.currentObject);
        this.currentObject = newObjects;
        this.state = NEUTRAL;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
    };
    Parser.prototype.neutral = function(char) {
      if (latin.test(char)) {
        this.word = char;
        this.state = KEYWORD;
        return;
      }
      if (char === '"') {
        this.word = "";
        this.state = QUOTED;
        return;
      }
      if (digets.test(char)) {
        this.word = char;
        this.state = NUMBER;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
    };
    Parser.prototype.output = function() {
      while (this.place < this.text.length) {
        this.readCharicter();
      }
      if (this.state === ENDED) {
        return this.root;
      }
      throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
    };
  }
});

// node_modules/wkt-parser/process.js
function mapit(obj, key2, value) {
  if (Array.isArray(key2)) {
    value.unshift(key2);
    key2 = null;
  }
  var thing = key2 ? {} : obj;
  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key2) {
    obj[key2] = out;
  }
}
function sExpr(v2, obj) {
  if (!Array.isArray(v2)) {
    obj[v2] = true;
    return;
  }
  var key2 = v2.shift();
  if (key2 === "PARAMETER") {
    key2 = v2.shift();
  }
  if (v2.length === 1) {
    if (Array.isArray(v2[0])) {
      obj[key2] = {};
      sExpr(v2[0], obj[key2]);
      return;
    }
    obj[key2] = v2[0];
    return;
  }
  if (!v2.length) {
    obj[key2] = true;
    return;
  }
  if (key2 === "TOWGS84") {
    obj[key2] = v2;
    return;
  }
  if (key2 === "AXIS") {
    if (!(key2 in obj)) {
      obj[key2] = [];
    }
    obj[key2].push(v2);
    return;
  }
  if (!Array.isArray(key2)) {
    obj[key2] = {};
  }
  var i;
  switch (key2) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key2] = {
        name: v2[0].toLowerCase(),
        convert: v2[1]
      };
      if (v2.length === 3) {
        sExpr(v2[2], obj[key2]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key2] = {
        name: v2[0],
        a: v2[1],
        rf: v2[2]
      };
      if (v2.length === 4) {
        sExpr(v2[3], obj[key2]);
      }
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      v2[0] = ["name", v2[0]];
      mapit(obj, key2, v2);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      v2[0] = ["name", v2[0]];
      mapit(obj, key2, v2);
      obj[key2].type = key2;
      return;
    default:
      i = -1;
      while (++i < v2.length) {
        if (!Array.isArray(v2[i])) {
          return sExpr(v2, obj[key2]);
        }
      }
      return mapit(obj, key2, v2);
  }
}
var init_process = __esm({
  "node_modules/wkt-parser/process.js"() {
  }
});

// node_modules/wkt-parser/util.js
function d2r(input) {
  return input * D2R2;
}
function applyProjectionDefaults(wkt) {
  const normalizedProjName = (wkt.projName || "").toLowerCase().replace(/_/g, " ");
  if (!wkt.long0 && wkt.longc && (normalizedProjName === "albers conic equal area" || normalizedProjName === "lambert azimuthal equal area")) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (normalizedProjName === "stereographic south pole" || normalizedProjName === "polar stereographic (variant b)")) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
    delete wkt.lat1;
  } else if (!wkt.lat_ts && wkt.lat0 && (normalizedProjName === "polar stereographic" || normalizedProjName === "polar stereographic (variant a)")) {
    wkt.lat_ts = wkt.lat0;
    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
    delete wkt.lat1;
  }
}
var D2R2;
var init_util3 = __esm({
  "node_modules/wkt-parser/util.js"() {
    D2R2 = 0.017453292519943295;
  }
});

// node_modules/wkt-parser/transformPROJJSON.js
function processUnit(unit) {
  let result = { units: null, to_meter: void 0 };
  if (typeof unit === "string") {
    result.units = unit.toLowerCase();
    if (result.units === "metre") {
      result.units = "meter";
    }
    if (result.units === "meter") {
      result.to_meter = 1;
    }
  } else if (unit && unit.name) {
    result.units = unit.name.toLowerCase();
    if (result.units === "metre") {
      result.units = "meter";
    }
    result.to_meter = unit.conversion_factor;
  }
  return result;
}
function toValue(valueOrObject) {
  if (typeof valueOrObject === "object") {
    return valueOrObject.value * valueOrObject.unit.conversion_factor;
  }
  return valueOrObject;
}
function calculateEllipsoid(value, result) {
  if (value.ellipsoid.radius) {
    result.a = value.ellipsoid.radius;
    result.rf = 0;
  } else {
    result.a = toValue(value.ellipsoid.semi_major_axis);
    if (value.ellipsoid.inverse_flattening !== void 0) {
      result.rf = value.ellipsoid.inverse_flattening;
    } else if (value.ellipsoid.semi_major_axis !== void 0 && value.ellipsoid.semi_minor_axis !== void 0) {
      result.rf = result.a / (result.a - toValue(value.ellipsoid.semi_minor_axis));
    }
  }
}
function transformPROJJSON(projjson, result = {}) {
  if (!projjson || typeof projjson !== "object") {
    return projjson;
  }
  if (projjson.type === "BoundCRS") {
    transformPROJJSON(projjson.source_crs, result);
    if (projjson.transformation) {
      if (projjson.transformation.method && projjson.transformation.method.name === "NTv2") {
        result.nadgrids = projjson.transformation.parameters[0].value;
      } else {
        result.datum_params = projjson.transformation.parameters.map((param) => param.value);
      }
    }
    return result;
  }
  Object.keys(projjson).forEach((key2) => {
    const value = projjson[key2];
    if (value === null) {
      return;
    }
    switch (key2) {
      case "name":
        if (result.srsCode) {
          break;
        }
        result.name = value;
        result.srsCode = value;
        break;
      case "type":
        if (value === "GeographicCRS") {
          result.projName = "longlat";
        } else if (value === "ProjectedCRS" && projjson.conversion && projjson.conversion.method) {
          result.projName = projjson.conversion.method.name;
        }
        break;
      case "datum":
      case "datum_ensemble":
        if (value.ellipsoid) {
          result.ellps = value.ellipsoid.name;
          calculateEllipsoid(value, result);
        }
        if (value.prime_meridian) {
          result.from_greenwich = value.prime_meridian.longitude * Math.PI / 180;
        }
        break;
      case "ellipsoid":
        result.ellps = value.name;
        calculateEllipsoid(value, result);
        break;
      case "prime_meridian":
        result.long0 = (value.longitude || 0) * Math.PI / 180;
        break;
      case "coordinate_system":
        if (value.axis) {
          result.axis = value.axis.map((axis) => {
            const direction = axis.direction;
            if (direction === "east") return "e";
            if (direction === "north") return "n";
            if (direction === "west") return "w";
            if (direction === "south") return "s";
            throw new Error(`Unknown axis direction: ${direction}`);
          }).join("") + "u";
          if (value.unit) {
            const { units, to_meter } = processUnit(value.unit);
            result.units = units;
            result.to_meter = to_meter;
          } else if (value.axis[0] && value.axis[0].unit) {
            const { units, to_meter } = processUnit(value.axis[0].unit);
            result.units = units;
            result.to_meter = to_meter;
          }
        }
        break;
      case "id":
        if (value.authority && value.code) {
          result.title = value.authority + ":" + value.code;
        }
        break;
      case "conversion":
        if (value.method && value.method.name) {
          result.projName = value.method.name;
        }
        if (value.parameters) {
          value.parameters.forEach((param) => {
            const paramName = param.name.toLowerCase().replace(/\s+/g, "_");
            const paramValue = param.value;
            if (param.unit && param.unit.conversion_factor) {
              result[paramName] = paramValue * param.unit.conversion_factor;
            } else if (param.unit === "degree") {
              result[paramName] = paramValue * Math.PI / 180;
            } else {
              result[paramName] = paramValue;
            }
          });
        }
        break;
      case "unit":
        if (value.name) {
          result.units = value.name.toLowerCase();
          if (result.units === "metre") {
            result.units = "meter";
          }
        }
        if (value.conversion_factor) {
          result.to_meter = value.conversion_factor;
        }
        break;
      case "base_crs":
        transformPROJJSON(value, result);
        result.datumCode = value.id ? value.id.authority + "_" + value.id.code : value.name;
        break;
      default:
        break;
    }
  });
  if (result.latitude_of_false_origin !== void 0) {
    result.lat0 = result.latitude_of_false_origin;
  }
  if (result.longitude_of_false_origin !== void 0) {
    result.long0 = result.longitude_of_false_origin;
  }
  if (result.latitude_of_standard_parallel !== void 0) {
    result.lat0 = result.latitude_of_standard_parallel;
    result.lat1 = result.latitude_of_standard_parallel;
  }
  if (result.latitude_of_1st_standard_parallel !== void 0) {
    result.lat1 = result.latitude_of_1st_standard_parallel;
  }
  if (result.latitude_of_2nd_standard_parallel !== void 0) {
    result.lat2 = result.latitude_of_2nd_standard_parallel;
  }
  if (result.latitude_of_projection_centre !== void 0) {
    result.lat0 = result.latitude_of_projection_centre;
  }
  if (result.longitude_of_projection_centre !== void 0) {
    result.longc = result.longitude_of_projection_centre;
  }
  if (result.easting_at_false_origin !== void 0) {
    result.x0 = result.easting_at_false_origin;
  }
  if (result.northing_at_false_origin !== void 0) {
    result.y0 = result.northing_at_false_origin;
  }
  if (result.latitude_of_natural_origin !== void 0) {
    result.lat0 = result.latitude_of_natural_origin;
  }
  if (result.longitude_of_natural_origin !== void 0) {
    result.long0 = result.longitude_of_natural_origin;
  }
  if (result.longitude_of_origin !== void 0) {
    result.long0 = result.longitude_of_origin;
  }
  if (result.false_easting !== void 0) {
    result.x0 = result.false_easting;
  }
  if (result.easting_at_projection_centre) {
    result.x0 = result.easting_at_projection_centre;
  }
  if (result.false_northing !== void 0) {
    result.y0 = result.false_northing;
  }
  if (result.northing_at_projection_centre) {
    result.y0 = result.northing_at_projection_centre;
  }
  if (result.standard_parallel_1 !== void 0) {
    result.lat1 = result.standard_parallel_1;
  }
  if (result.standard_parallel_2 !== void 0) {
    result.lat2 = result.standard_parallel_2;
  }
  if (result.scale_factor_at_natural_origin !== void 0) {
    result.k0 = result.scale_factor_at_natural_origin;
  }
  if (result.scale_factor_at_projection_centre !== void 0) {
    result.k0 = result.scale_factor_at_projection_centre;
  }
  if (result.scale_factor_on_pseudo_standard_parallel !== void 0) {
    result.k0 = result.scale_factor_on_pseudo_standard_parallel;
  }
  if (result.azimuth !== void 0) {
    result.alpha = result.azimuth;
  }
  if (result.azimuth_at_projection_centre !== void 0) {
    result.alpha = result.azimuth_at_projection_centre;
  }
  if (result.angle_from_rectified_to_skew_grid) {
    result.rectified_grid_angle = result.angle_from_rectified_to_skew_grid;
  }
  applyProjectionDefaults(result);
  return result;
}
var init_transformPROJJSON = __esm({
  "node_modules/wkt-parser/transformPROJJSON.js"() {
    init_util3();
  }
});

// node_modules/wkt-parser/index.js
function rename(obj, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params2.length === 3) {
      obj[outName] = params2[2](obj[outName]);
    }
  }
}
function cleanWKT(wkt) {
  var keys = Object.keys(wkt);
  for (var i = 0, ii = keys.length; i < ii; ++i) {
    var key2 = keys[i];
    if (knownTypes.indexOf(key2) !== -1) {
      setPropertiesFromWkt(wkt[key2]);
    }
    if (typeof wkt[key2] === "object") {
      cleanWKT(wkt[key2]);
    }
  }
}
function setPropertiesFromWkt(wkt) {
  if (wkt.AUTHORITY) {
    var authority = Object.keys(wkt.AUTHORITY)[0];
    if (authority && authority in wkt.AUTHORITY) {
      wkt.title = authority + ":" + wkt.AUTHORITY[authority];
    }
  }
  if (wkt.type === "GEOGCS") {
    wkt.projName = "longlat";
  } else if (wkt.type === "LOCAL_CS") {
    wkt.projName = "identity";
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = "";
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === "metre") {
      wkt.units = "meter";
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === "GEOGCS") {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === "GEOGCS") {
    geogcs = wkt;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === "d_") {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === "new_zealand_1949") {
      wkt.datumCode = "nzgd49";
    }
    if (wkt.datumCode === "wgs_1984" || wkt.datumCode === "world_geodetic_system_1984") {
      if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt.sphere = true;
      }
      wkt.datumCode = "wgs84";
    }
    if (wkt.datumCode === "belge_1972") {
      wkt.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = "intl";
      }
      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf("osgb_1936")) {
      wkt.datumCode = "osgb36";
    }
    if (~wkt.datumCode.indexOf("osni_1952")) {
      wkt.datumCode = "osni52";
    }
    if (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt.datumCode = "ire65";
    }
    if (wkt.datumCode === "ch1903+") {
      wkt.datumCode = "ch1903";
    }
    if (~wkt.datumCode.indexOf("israel")) {
      wkt.datumCode = "isr93";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }
  if (wkt.rectified_grid_angle) {
    wkt.rectified_grid_angle = d2r(wkt.rectified_grid_angle);
  }
  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  applyProjectionDefaults(wkt);
}
function wkt_parser_default(wkt) {
  if (typeof wkt === "object") {
    return transformPROJJSON(wkt);
  }
  const version = detectWKTVersion(wkt);
  var lisp = parser_default(wkt);
  if (version === "WKT2") {
    const projjson = buildPROJJSON(lisp);
    return transformPROJJSON(projjson);
  }
  var type = lisp[0];
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj[type];
}
var knownTypes;
var init_wkt_parser = __esm({
  "node_modules/wkt-parser/index.js"() {
    init_buildPROJJSON();
    init_detectWKTVersion();
    init_parser2();
    init_process();
    init_transformPROJJSON();
    init_util3();
    knownTypes = [
      "PROJECTEDCRS",
      "PROJCRS",
      "GEOGCS",
      "GEOCCS",
      "PROJCS",
      "LOCAL_CS",
      "GEODCRS",
      "GEODETICCRS",
      "GEODETICDATUM",
      "ENGCRS",
      "ENGINEERINGCRS"
    ];
  }
});

// node_modules/proj4/lib/defs.js
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[
          /** @type {string} */
          name
        ] = projString_default(arguments[1]);
      } else {
        defs[
          /** @type {string} */
          name
        ] = wkt_parser_default(arguments[1]);
      }
    } else {
      defs[
        /** @type {string} */
        name
      ] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v2) {
        if (Array.isArray(v2)) {
          return defs.apply(that, v2);
        } else {
          return defs(v2);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
var defs_default;
var init_defs = __esm({
  "node_modules/proj4/lib/defs.js"() {
    init_global();
    init_projString();
    init_wkt_parser();
    global_default(defs);
    defs_default = defs;
  }
});

// node_modules/proj4/lib/parseCode.js
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs_default;
}
function testWKT(code) {
  return code.indexOf("+") !== 0 && code.indexOf("[") !== -1 || typeof code === "object" && !("srsCode" in code);
}
function checkMercator(item) {
  var auth = match(item, "authority");
  if (!auth) {
    return;
  }
  var code = match(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, "extension");
  if (!ext) {
    return;
  }
  return match(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse4(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs_default[code];
    }
    if (testWKT(code)) {
      var out = wkt_parser_default(code);
      if (checkMercator(out)) {
        return defs_default["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString_default(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projString_default(code);
    }
  } else if (!("projName" in code)) {
    return wkt_parser_default(code);
  } else {
    return code;
  }
}
var codes, parseCode_default;
var init_parseCode = __esm({
  "node_modules/proj4/lib/parseCode.js"() {
    init_defs();
    init_wkt_parser();
    init_projString();
    init_match();
    codes = ["3857", "900913", "3785", "102113"];
    parseCode_default = parse4;
  }
});

// node_modules/proj4/lib/extend.js
function extend_default(destination, source2) {
  destination = destination || {};
  var value, property;
  if (!source2) {
    return destination;
  }
  for (property in source2) {
    value = source2[property];
    if (value !== void 0) {
      destination[property] = value;
    }
  }
  return destination;
}
var init_extend = __esm({
  "node_modules/proj4/lib/extend.js"() {
  }
});

// node_modules/proj4/lib/common/msfnz.js
function msfnz_default(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}
var init_msfnz = __esm({
  "node_modules/proj4/lib/common/msfnz.js"() {
  }
});

// node_modules/proj4/lib/common/sign.js
function sign_default(x) {
  return x < 0 ? -1 : 1;
}
var init_sign = __esm({
  "node_modules/proj4/lib/common/sign.js"() {
  }
});

// node_modules/proj4/lib/common/adjust_lon.js
function adjust_lon_default(x) {
  return Math.abs(x) <= SPI ? x : x - sign_default(x) * TWO_PI;
}
var init_adjust_lon = __esm({
  "node_modules/proj4/lib/common/adjust_lon.js"() {
    init_values();
    init_sign();
  }
});

// node_modules/proj4/lib/common/tsfnz.js
function tsfnz_default(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}
var init_tsfnz = __esm({
  "node_modules/proj4/lib/common/tsfnz.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/common/phi2z.js
function phi2z_default(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}
var init_phi2z = __esm({
  "node_modules/proj4/lib/common/phi2z.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/projections/merc.js
function init2() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz_default(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}
function inverse(p) {
  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon_default(this.long0 + x / (this.a * this.k0));
  p.x = lon;
  p.y = lat;
  return p;
}
var names, merc_default;
var init_merc = __esm({
  "node_modules/proj4/lib/projections/merc.js"() {
    init_msfnz();
    init_adjust_lon();
    init_tsfnz();
    init_phi2z();
    init_values();
    names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "Mercator_Variant_A", "merc"];
    merc_default = {
      init: init2,
      forward,
      inverse,
      names
    };
  }
});

// node_modules/proj4/lib/projections/longlat.js
function init3() {
}
function identity(pt) {
  return pt;
}
var names2, longlat_default;
var init_longlat = __esm({
  "node_modules/proj4/lib/projections/longlat.js"() {
    names2 = ["longlat", "identity"];
    longlat_default = {
      init: init3,
      forward: identity,
      inverse: identity,
      names: names2
    };
  }
});

// node_modules/proj4/lib/projections.js
function add4(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n2) {
    names3[n2.toLowerCase()] = len;
  });
  return this;
}
function getNormalizedProjName(n2) {
  return n2.replace(/[-\(\)\s]+/g, " ").trim().replace(/ /g, "_");
}
function get5(name) {
  if (!name) {
    return false;
  }
  var n2 = name.toLowerCase();
  if (typeof names3[n2] !== "undefined" && projStore[names3[n2]]) {
    return projStore[names3[n2]];
  }
  n2 = getNormalizedProjName(n2);
  if (n2 in names3 && projStore[names3[n2]]) {
    return projStore[names3[n2]];
  }
}
function start() {
  projs.forEach(add4);
}
var projs, names3, projStore, projections_default;
var init_projections2 = __esm({
  "node_modules/proj4/lib/projections.js"() {
    init_merc();
    init_longlat();
    projs = [merc_default, longlat_default];
    names3 = {};
    projStore = [];
    projections_default = {
      start,
      add: add4,
      get: get5
    };
  }
});

// node_modules/proj4/lib/constants/Ellipsoid.js
var ellipsoids, Ellipsoid_default;
var init_Ellipsoid = __esm({
  "node_modules/proj4/lib/constants/Ellipsoid.js"() {
    ellipsoids = {
      MERIT: {
        a: 6378137,
        rf: 298.257,
        ellipseName: "MERIT 1983"
      },
      SGS85: {
        a: 6378136,
        rf: 298.257,
        ellipseName: "Soviet Geodetic System 85"
      },
      GRS80: {
        a: 6378137,
        rf: 298.257222101,
        ellipseName: "GRS 1980(IUGG, 1980)"
      },
      IAU76: {
        a: 6378140,
        rf: 298.257,
        ellipseName: "IAU 1976"
      },
      airy: {
        a: 6377563396e-3,
        b: 635625691e-2,
        ellipseName: "Airy 1830"
      },
      APL4: {
        a: 6378137,
        rf: 298.25,
        ellipseName: "Appl. Physics. 1965"
      },
      NWL9D: {
        a: 6378145,
        rf: 298.25,
        ellipseName: "Naval Weapons Lab., 1965"
      },
      mod_airy: {
        a: 6377340189e-3,
        b: 6356034446e-3,
        ellipseName: "Modified Airy"
      },
      andrae: {
        a: 637710443e-2,
        rf: 300,
        ellipseName: "Andrae 1876 (Den., Iclnd.)"
      },
      aust_SA: {
        a: 6378160,
        rf: 298.25,
        ellipseName: "Australian Natl & S. Amer. 1969"
      },
      GRS67: {
        a: 6378160,
        rf: 298.247167427,
        ellipseName: "GRS 67(IUGG 1967)"
      },
      bessel: {
        a: 6377397155e-3,
        rf: 299.1528128,
        ellipseName: "Bessel 1841"
      },
      bess_nam: {
        a: 6377483865e-3,
        rf: 299.1528128,
        ellipseName: "Bessel 1841 (Namibia)"
      },
      clrk66: {
        a: 63782064e-1,
        b: 63565838e-1,
        ellipseName: "Clarke 1866"
      },
      clrk80: {
        a: 6378249145e-3,
        rf: 293.4663,
        ellipseName: "Clarke 1880 mod."
      },
      clrk80ign: {
        a: 63782492e-1,
        b: 6356515,
        rf: 293.4660213,
        ellipseName: "Clarke 1880 (IGN)"
      },
      clrk58: {
        a: 6378293645208759e-9,
        rf: 294.2606763692654,
        ellipseName: "Clarke 1858"
      },
      CPM: {
        a: 63757387e-1,
        rf: 334.29,
        ellipseName: "Comm. des Poids et Mesures 1799"
      },
      delmbr: {
        a: 6376428,
        rf: 311.5,
        ellipseName: "Delambre 1810 (Belgium)"
      },
      engelis: {
        a: 637813605e-2,
        rf: 298.2566,
        ellipseName: "Engelis 1985"
      },
      evrst30: {
        a: 6377276345e-3,
        rf: 300.8017,
        ellipseName: "Everest 1830"
      },
      evrst48: {
        a: 6377304063e-3,
        rf: 300.8017,
        ellipseName: "Everest 1948"
      },
      evrst56: {
        a: 6377301243e-3,
        rf: 300.8017,
        ellipseName: "Everest 1956"
      },
      evrst69: {
        a: 6377295664e-3,
        rf: 300.8017,
        ellipseName: "Everest 1969"
      },
      evrstSS: {
        a: 6377298556e-3,
        rf: 300.8017,
        ellipseName: "Everest (Sabah & Sarawak)"
      },
      fschr60: {
        a: 6378166,
        rf: 298.3,
        ellipseName: "Fischer (Mercury Datum) 1960"
      },
      fschr60m: {
        a: 6378155,
        rf: 298.3,
        ellipseName: "Fischer 1960"
      },
      fschr68: {
        a: 6378150,
        rf: 298.3,
        ellipseName: "Fischer 1968"
      },
      helmert: {
        a: 6378200,
        rf: 298.3,
        ellipseName: "Helmert 1906"
      },
      hough: {
        a: 6378270,
        rf: 297,
        ellipseName: "Hough"
      },
      intl: {
        a: 6378388,
        rf: 297,
        ellipseName: "International 1909 (Hayford)"
      },
      kaula: {
        a: 6378163,
        rf: 298.24,
        ellipseName: "Kaula 1961"
      },
      lerch: {
        a: 6378139,
        rf: 298.257,
        ellipseName: "Lerch 1979"
      },
      mprts: {
        a: 6397300,
        rf: 191,
        ellipseName: "Maupertius 1738"
      },
      new_intl: {
        a: 63781575e-1,
        b: 63567722e-1,
        ellipseName: "New International 1967"
      },
      plessis: {
        a: 6376523,
        rf: 6355863,
        ellipseName: "Plessis 1817 (France)"
      },
      krass: {
        a: 6378245,
        rf: 298.3,
        ellipseName: "Krassovsky, 1942"
      },
      SEasia: {
        a: 6378155,
        b: 63567733205e-4,
        ellipseName: "Southeast Asia"
      },
      walbeck: {
        a: 6376896,
        b: 63558348467e-4,
        ellipseName: "Walbeck"
      },
      WGS60: {
        a: 6378165,
        rf: 298.3,
        ellipseName: "WGS 60"
      },
      WGS66: {
        a: 6378145,
        rf: 298.25,
        ellipseName: "WGS 66"
      },
      WGS7: {
        a: 6378135,
        rf: 298.26,
        ellipseName: "WGS 72"
      },
      WGS84: {
        a: 6378137,
        rf: 298.257223563,
        ellipseName: "WGS 84"
      },
      sphere: {
        a: 6370997,
        b: 6370997,
        ellipseName: "Normal Sphere (r=6370997)"
      }
    };
    Ellipsoid_default = ellipsoids;
  }
});

// node_modules/proj4/lib/deriveConstants.js
function eccentricity(a, b, rf, R_A) {
  var a2 = a * a;
  var b2 = b * b;
  var es = (a2 - b2) / a2;
  var e3 = 0;
  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e3 = Math.sqrt(es);
  }
  var ep2 = (a2 - b2) / b2;
  return {
    es,
    e: e3,
    ep2
  };
}
function sphere(a, b, rf, ellps, sphere2) {
  if (!a) {
    var ellipse = match(Ellipsoid_default, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b) {
    b = (1 - 1 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere2 = true;
    b = a;
  }
  return {
    a,
    b,
    rf,
    sphere: sphere2
  };
}
var WGS84;
var init_deriveConstants = __esm({
  "node_modules/proj4/lib/deriveConstants.js"() {
    init_values();
    init_Ellipsoid();
    init_match();
    WGS84 = Ellipsoid_default.WGS84;
  }
});

// node_modules/proj4/lib/constants/Datum.js
var datums, datum2, key2, Datum_default;
var init_Datum = __esm({
  "node_modules/proj4/lib/constants/Datum.js"() {
    datums = {
      wgs84: {
        towgs84: "0,0,0",
        ellipse: "WGS84",
        datumName: "WGS84"
      },
      ch1903: {
        towgs84: "674.374,15.056,405.346",
        ellipse: "bessel",
        datumName: "swiss"
      },
      ggrs87: {
        towgs84: "-199.87,74.79,246.62",
        ellipse: "GRS80",
        datumName: "Greek_Geodetic_Reference_System_1987"
      },
      nad83: {
        towgs84: "0,0,0",
        ellipse: "GRS80",
        datumName: "North_American_Datum_1983"
      },
      nad27: {
        nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
        ellipse: "clrk66",
        datumName: "North_American_Datum_1927"
      },
      potsdam: {
        towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
        ellipse: "bessel",
        datumName: "Potsdam Rauenberg 1950 DHDN"
      },
      carthage: {
        towgs84: "-263.0,6.0,431.0",
        ellipse: "clark80",
        datumName: "Carthage 1934 Tunisia"
      },
      hermannskogel: {
        towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
        ellipse: "bessel",
        datumName: "Hermannskogel"
      },
      mgi: {
        towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
        ellipse: "bessel",
        datumName: "Militar-Geographische Institut"
      },
      osni52: {
        towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
        ellipse: "airy",
        datumName: "Irish National"
      },
      ire65: {
        towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
        ellipse: "mod_airy",
        datumName: "Ireland 1965"
      },
      rassadiran: {
        towgs84: "-133.63,-157.5,-158.62",
        ellipse: "intl",
        datumName: "Rassadiran"
      },
      nzgd49: {
        towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
        ellipse: "intl",
        datumName: "New Zealand Geodetic Datum 1949"
      },
      osgb36: {
        towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
        ellipse: "airy",
        datumName: "Ordnance Survey of Great Britain 1936"
      },
      s_jtsk: {
        towgs84: "589,76,480",
        ellipse: "bessel",
        datumName: "S-JTSK (Ferro)"
      },
      beduaram: {
        towgs84: "-106,-87,188",
        ellipse: "clrk80",
        datumName: "Beduaram"
      },
      gunung_segara: {
        towgs84: "-403,684,41",
        ellipse: "bessel",
        datumName: "Gunung Segara Jakarta"
      },
      rnb72: {
        towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
        ellipse: "intl",
        datumName: "Reseau National Belge 1972"
      },
      EPSG_5451: {
        towgs84: "6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649"
      },
      IGNF_LURESG: {
        towgs84: "-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43"
      },
      EPSG_4614: {
        towgs84: "-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065"
      },
      EPSG_4615: {
        towgs84: "-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748"
      },
      ESRI_37241: {
        towgs84: "-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031"
      },
      ESRI_37249: {
        towgs84: "-440.296,58.548,296.265,1.128,10.202,4.559,-0.438"
      },
      ESRI_37245: {
        towgs84: "-511.151,-181.269,139.609,1.05,2.703,1.798,3.071"
      },
      EPSG_4178: {
        towgs84: "24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01"
      },
      EPSG_4622: {
        towgs84: "-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984"
      },
      EPSG_4625: {
        towgs84: "126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227"
      },
      EPSG_5252: {
        towgs84: "0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439"
      },
      EPSG_4314: {
        towgs84: "597.1,71.4,412.1,0.894,0.068,-1.563,7.58"
      },
      EPSG_4282: {
        towgs84: "-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166"
      },
      EPSG_4231: {
        towgs84: "-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218"
      },
      EPSG_4274: {
        towgs84: "-230.994,102.591,25.199,0.633,-0.239,0.9,1.95"
      },
      EPSG_4134: {
        towgs84: "-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006"
      },
      EPSG_4254: {
        towgs84: "18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013"
      },
      EPSG_4159: {
        towgs84: "-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175"
      },
      EPSG_4687: {
        towgs84: "0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093"
      },
      EPSG_4227: {
        towgs84: "-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225"
      },
      EPSG_4746: {
        towgs84: "599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46"
      },
      EPSG_4745: {
        towgs84: "612.4,77,440.2,-0.054,0.057,-2.797,2.55"
      },
      EPSG_6311: {
        towgs84: "8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926"
      },
      EPSG_4289: {
        towgs84: "565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244"
      },
      EPSG_4230: {
        towgs84: "-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4"
      },
      EPSG_4154: {
        towgs84: "-123.02,-158.95,-168.47"
      },
      EPSG_4156: {
        towgs84: "570.8,85.7,462.8,4.998,1.587,5.261,3.56"
      },
      EPSG_4299: {
        towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
      },
      EPSG_4179: {
        towgs84: "33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84"
      },
      EPSG_4313: {
        towgs84: "-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747"
      },
      EPSG_4194: {
        towgs84: "163.511,127.533,-159.789"
      },
      EPSG_4195: {
        towgs84: "105,326,-102.5"
      },
      EPSG_4196: {
        towgs84: "-45,417,-3.5"
      },
      EPSG_4611: {
        towgs84: "-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246"
      },
      EPSG_4633: {
        towgs84: "137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824"
      },
      EPSG_4641: {
        towgs84: "-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993"
      },
      EPSG_4643: {
        towgs84: "-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002"
      },
      EPSG_4300: {
        towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
      },
      EPSG_4188: {
        towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
      },
      EPSG_4660: {
        towgs84: "982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805"
      },
      EPSG_4662: {
        towgs84: "97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259"
      },
      EPSG_3906: {
        towgs84: "577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664"
      },
      EPSG_4307: {
        towgs84: "-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547"
      },
      EPSG_6892: {
        towgs84: "-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686"
      },
      EPSG_4690: {
        towgs84: "221.597,152.441,176.523,2.403,1.3893,0.884,11.4648"
      },
      EPSG_4691: {
        towgs84: "218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817"
      },
      EPSG_4629: {
        towgs84: "72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653"
      },
      EPSG_4630: {
        towgs84: "165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111"
      },
      EPSG_4692: {
        towgs84: "217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093"
      },
      EPSG_9333: {
        towgs84: "0,0,0,-8.393,0.749,-10.276,0"
      },
      EPSG_9059: {
        towgs84: "0,0,0"
      },
      EPSG_4312: {
        towgs84: "601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887"
      },
      EPSG_4123: {
        towgs84: "-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496"
      },
      EPSG_4309: {
        towgs84: "-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365"
      },
      ESRI_104106: {
        towgs84: "-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058"
      },
      EPSG_4281: {
        towgs84: "-219.247,-73.802,269.529"
      },
      EPSG_4322: {
        towgs84: "0,0,4.5"
      },
      EPSG_4324: {
        towgs84: "0,0,1.9"
      },
      EPSG_4284: {
        towgs84: "43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549"
      },
      EPSG_4277: {
        towgs84: "446.448,-125.157,542.06,0.15,0.247,0.842,-20.489"
      },
      EPSG_4207: {
        towgs84: "-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46"
      },
      EPSG_4688: {
        towgs84: "347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647"
      },
      EPSG_4689: {
        towgs84: "410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218"
      },
      EPSG_4720: {
        towgs84: "0,0,4.5"
      },
      EPSG_4273: {
        towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
      },
      EPSG_4240: {
        towgs84: "204.64,834.74,293.8"
      },
      EPSG_4817: {
        towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
      },
      ESRI_104131: {
        towgs84: "426.62,142.62,460.09,4.98,4.49,-12.42,-17.1"
      },
      EPSG_4265: {
        towgs84: "-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68"
      },
      EPSG_4263: {
        towgs84: "-111.92,-87.85,114.5,1.875,0.202,0.219,0.032"
      },
      EPSG_4298: {
        towgs84: "-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536"
      },
      EPSG_4270: {
        towgs84: "-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424"
      },
      EPSG_4229: {
        towgs84: "-121.8,98.1,-10.7"
      },
      EPSG_4220: {
        towgs84: "-55.5,-348,-229.2"
      },
      EPSG_4214: {
        towgs84: "12.646,-155.176,-80.863"
      },
      EPSG_4232: {
        towgs84: "-345,3,223"
      },
      EPSG_4238: {
        towgs84: "-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037"
      },
      EPSG_4168: {
        towgs84: "-170,33,326"
      },
      EPSG_4131: {
        towgs84: "199,931,318.9"
      },
      EPSG_4152: {
        towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
      },
      EPSG_5228: {
        towgs84: "572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378"
      },
      EPSG_8351: {
        towgs84: "485.021,169.465,483.839,7.786342,4.397554,4.102655,0"
      },
      EPSG_4683: {
        towgs84: "-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06"
      },
      EPSG_4133: {
        towgs84: "0,0,0"
      },
      EPSG_7373: {
        towgs84: "0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693"
      },
      EPSG_9075: {
        towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
      },
      EPSG_9072: {
        towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
      },
      EPSG_9294: {
        towgs84: "1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388"
      },
      EPSG_4212: {
        towgs84: "-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492"
      },
      EPSG_4191: {
        towgs84: "-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703"
      },
      EPSG_4237: {
        towgs84: "52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191"
      },
      EPSG_4740: {
        towgs84: "-1.08,-0.27,-0.9"
      },
      EPSG_4124: {
        towgs84: "419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496"
      },
      EPSG_5681: {
        towgs84: "584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922"
      },
      EPSG_4141: {
        towgs84: "23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262"
      },
      EPSG_4204: {
        towgs84: "-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194"
      },
      EPSG_4319: {
        towgs84: "226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798"
      },
      EPSG_4200: {
        towgs84: "24.82,-131.21,-82.66"
      },
      EPSG_4130: {
        towgs84: "0,0,0"
      },
      EPSG_4127: {
        towgs84: "-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359"
      },
      EPSG_4149: {
        towgs84: "674.374,15.056,405.346"
      },
      EPSG_4617: {
        towgs84: "-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0"
      },
      EPSG_4663: {
        towgs84: "-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485"
      },
      EPSG_4664: {
        towgs84: "-211.939,137.626,58.3,-0.089,0.251,0.079,0.384"
      },
      EPSG_4665: {
        towgs84: "-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048"
      },
      EPSG_4666: {
        towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
      },
      EPSG_4756: {
        towgs84: "-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188"
      },
      EPSG_4723: {
        towgs84: "-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925"
      },
      EPSG_4726: {
        towgs84: "8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081"
      },
      EPSG_4267: {
        towgs84: "-8.0,160.0,176.0"
      },
      EPSG_5365: {
        towgs84: "-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693"
      },
      EPSG_4218: {
        towgs84: "304.5,306.5,-318.1"
      },
      EPSG_4242: {
        towgs84: "-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95"
      },
      EPSG_4216: {
        towgs84: "-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289"
      },
      ESRI_104105: {
        towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
      },
      ESRI_104129: {
        towgs84: "0,0,0"
      },
      EPSG_4673: {
        towgs84: "174.05,-25.49,112.57"
      },
      EPSG_4202: {
        towgs84: "-124,-60,154"
      },
      EPSG_4203: {
        towgs84: "-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191"
      },
      EPSG_3819: {
        towgs84: "595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408"
      },
      EPSG_8694: {
        towgs84: "-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169"
      },
      EPSG_4145: {
        towgs84: "275.57,676.78,229.6"
      },
      EPSG_4283: {
        towgs84: "61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994"
      },
      EPSG_4317: {
        towgs84: "2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266"
      },
      EPSG_4272: {
        towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993"
      },
      EPSG_4248: {
        towgs84: "-307.7,265.3,-363.5"
      },
      EPSG_5561: {
        towgs84: "24,-121,-76"
      },
      EPSG_5233: {
        towgs84: "-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338"
      },
      ESRI_104130: {
        towgs84: "-86,-98,-119"
      },
      ESRI_104102: {
        towgs84: "682,-203,480"
      },
      ESRI_37207: {
        towgs84: "7,-10,-26"
      },
      EPSG_4675: {
        towgs84: "59.935,118.4,-10.871"
      },
      ESRI_104109: {
        towgs84: "-89.121,-348.182,260.871"
      },
      ESRI_104112: {
        towgs84: "-185.583,-230.096,281.361"
      },
      ESRI_104113: {
        towgs84: "25.1,-275.6,222.6"
      },
      IGNF_WGS72G: {
        towgs84: "0,12,6"
      },
      IGNF_NTFG: {
        towgs84: "-168,-60,320"
      },
      IGNF_EFATE57G: {
        towgs84: "-127,-769,472"
      },
      IGNF_PGP50G: {
        towgs84: "324.8,153.6,172.1"
      },
      IGNF_REUN47G: {
        towgs84: "94,-948,-1262"
      },
      IGNF_CSG67G: {
        towgs84: "-186,230,110"
      },
      IGNF_GUAD48G: {
        towgs84: "-467,-16,-300"
      },
      IGNF_TAHI51G: {
        towgs84: "162,117,154"
      },
      IGNF_TAHAAG: {
        towgs84: "65,342,77"
      },
      IGNF_NUKU72G: {
        towgs84: "84,274,65"
      },
      IGNF_PETRELS72G: {
        towgs84: "365,194,166"
      },
      IGNF_WALL78G: {
        towgs84: "253,-133,-127"
      },
      IGNF_MAYO50G: {
        towgs84: "-382,-59,-262"
      },
      IGNF_TANNAG: {
        towgs84: "-139,-967,436"
      },
      IGNF_IGN72G: {
        towgs84: "-13,-348,292"
      },
      IGNF_ATIGG: {
        towgs84: "1118,23,66"
      },
      IGNF_FANGA84G: {
        towgs84: "150.57,158.33,118.32"
      },
      IGNF_RUSAT84G: {
        towgs84: "202.13,174.6,-15.74"
      },
      IGNF_KAUE70G: {
        towgs84: "126.74,300.1,-75.49"
      },
      IGNF_MOP90G: {
        towgs84: "-10.8,-1.8,12.77"
      },
      IGNF_MHPF67G: {
        towgs84: "338.08,212.58,-296.17"
      },
      IGNF_TAHI79G: {
        towgs84: "160.61,116.05,153.69"
      },
      IGNF_ANAA92G: {
        towgs84: "1.5,3.84,4.81"
      },
      IGNF_MARQUI72G: {
        towgs84: "330.91,-13.92,58.56"
      },
      IGNF_APAT86G: {
        towgs84: "143.6,197.82,74.05"
      },
      IGNF_TUBU69G: {
        towgs84: "237.17,171.61,-77.84"
      },
      IGNF_STPM50G: {
        towgs84: "11.363,424.148,373.13"
      },
      EPSG_4150: {
        towgs84: "674.374,15.056,405.346"
      },
      EPSG_4754: {
        towgs84: "-208.4058,-109.8777,-2.5764"
      },
      ESRI_104101: {
        towgs84: "374,150,588"
      },
      EPSG_4693: {
        towgs84: "0,-0.15,0.68"
      },
      EPSG_6207: {
        towgs84: "293.17,726.18,245.36"
      },
      EPSG_4153: {
        towgs84: "-133.63,-157.5,-158.62"
      },
      EPSG_4132: {
        towgs84: "-241.54,-163.64,396.06"
      },
      EPSG_4221: {
        towgs84: "-154.5,150.7,100.4"
      },
      EPSG_4266: {
        towgs84: "-80.7,-132.5,41.1"
      },
      EPSG_4193: {
        towgs84: "-70.9,-151.8,-41.4"
      },
      EPSG_5340: {
        towgs84: "-0.41,0.46,-0.35"
      },
      EPSG_4246: {
        towgs84: "-294.7,-200.1,525.5"
      },
      EPSG_4318: {
        towgs84: "-3.2,-5.7,2.8"
      },
      EPSG_4121: {
        towgs84: "-199.87,74.79,246.62"
      },
      EPSG_4223: {
        towgs84: "-260.1,5.5,432.2"
      },
      EPSG_4158: {
        towgs84: "-0.465,372.095,171.736"
      },
      EPSG_4285: {
        towgs84: "-128.16,-282.42,21.93"
      },
      EPSG_4613: {
        towgs84: "-404.78,685.68,45.47"
      },
      EPSG_4607: {
        towgs84: "195.671,332.517,274.607"
      },
      EPSG_4475: {
        towgs84: "-381.788,-57.501,-256.673"
      },
      EPSG_4208: {
        towgs84: "-157.84,308.54,-146.6"
      },
      EPSG_4743: {
        towgs84: "70.995,-335.916,262.898"
      },
      EPSG_4710: {
        towgs84: "-323.65,551.39,-491.22"
      },
      EPSG_7881: {
        towgs84: "-0.077,0.079,0.086"
      },
      EPSG_4682: {
        towgs84: "283.729,735.942,261.143"
      },
      EPSG_4739: {
        towgs84: "-156,-271,-189"
      },
      EPSG_4679: {
        towgs84: "-80.01,253.26,291.19"
      },
      EPSG_4750: {
        towgs84: "-56.263,16.136,-22.856"
      },
      EPSG_4644: {
        towgs84: "-10.18,-350.43,291.37"
      },
      EPSG_4695: {
        towgs84: "-103.746,-9.614,-255.95"
      },
      EPSG_4292: {
        towgs84: "-355,21,72"
      },
      EPSG_4302: {
        towgs84: "-61.702,284.488,472.052"
      },
      EPSG_4143: {
        towgs84: "-124.76,53,466.79"
      },
      EPSG_4606: {
        towgs84: "-153,153,307"
      },
      EPSG_4699: {
        towgs84: "-770.1,158.4,-498.2"
      },
      EPSG_4247: {
        towgs84: "-273.5,110.6,-357.9"
      },
      EPSG_4160: {
        towgs84: "8.88,184.86,106.69"
      },
      EPSG_4161: {
        towgs84: "-233.43,6.65,173.64"
      },
      EPSG_9251: {
        towgs84: "-9.5,122.9,138.2"
      },
      EPSG_9253: {
        towgs84: "-78.1,101.6,133.3"
      },
      EPSG_4297: {
        towgs84: "-198.383,-240.517,-107.909"
      },
      EPSG_4269: {
        towgs84: "0,0,0"
      },
      EPSG_4301: {
        towgs84: "-147,506,687"
      },
      EPSG_4618: {
        towgs84: "-59,-11,-52"
      },
      EPSG_4612: {
        towgs84: "0,0,0"
      },
      EPSG_4678: {
        towgs84: "44.585,-131.212,-39.544"
      },
      EPSG_4250: {
        towgs84: "-130,29,364"
      },
      EPSG_4144: {
        towgs84: "214,804,268"
      },
      EPSG_4147: {
        towgs84: "-17.51,-108.32,-62.39"
      },
      EPSG_4259: {
        towgs84: "-254.1,-5.36,-100.29"
      },
      EPSG_4164: {
        towgs84: "-76,-138,67"
      },
      EPSG_4211: {
        towgs84: "-378.873,676.002,-46.255"
      },
      EPSG_4182: {
        towgs84: "-422.651,-172.995,84.02"
      },
      EPSG_4224: {
        towgs84: "-143.87,243.37,-33.52"
      },
      EPSG_4225: {
        towgs84: "-205.57,168.77,-4.12"
      },
      EPSG_5527: {
        towgs84: "-67.35,3.88,-38.22"
      },
      EPSG_4752: {
        towgs84: "98,390,-22"
      },
      EPSG_4310: {
        towgs84: "-30,190,89"
      },
      EPSG_9248: {
        towgs84: "-192.26,65.72,132.08"
      },
      EPSG_4680: {
        towgs84: "124.5,-63.5,-281"
      },
      EPSG_4701: {
        towgs84: "-79.9,-158,-168.9"
      },
      EPSG_4706: {
        towgs84: "-146.21,112.63,4.05"
      },
      EPSG_4805: {
        towgs84: "682,-203,480"
      },
      EPSG_4201: {
        towgs84: "-165,-11,206"
      },
      EPSG_4210: {
        towgs84: "-157,-2,-299"
      },
      EPSG_4183: {
        towgs84: "-104,167,-38"
      },
      EPSG_4139: {
        towgs84: "11,72,-101"
      },
      EPSG_4668: {
        towgs84: "-86,-98,-119"
      },
      EPSG_4717: {
        towgs84: "-2,151,181"
      },
      EPSG_4732: {
        towgs84: "102,52,-38"
      },
      EPSG_4280: {
        towgs84: "-377,681,-50"
      },
      EPSG_4209: {
        towgs84: "-138,-105,-289"
      },
      EPSG_4261: {
        towgs84: "31,146,47"
      },
      EPSG_4658: {
        towgs84: "-73,46,-86"
      },
      EPSG_4721: {
        towgs84: "265.025,384.929,-194.046"
      },
      EPSG_4222: {
        towgs84: "-136,-108,-292"
      },
      EPSG_4601: {
        towgs84: "-255,-15,71"
      },
      EPSG_4602: {
        towgs84: "725,685,536"
      },
      EPSG_4603: {
        towgs84: "72,213.7,93"
      },
      EPSG_4605: {
        towgs84: "9,183,236"
      },
      EPSG_4621: {
        towgs84: "137,248,-430"
      },
      EPSG_4657: {
        towgs84: "-28,199,5"
      },
      EPSG_4316: {
        towgs84: "103.25,-100.4,-307.19"
      },
      EPSG_4642: {
        towgs84: "-13,-348,292"
      },
      EPSG_4698: {
        towgs84: "145,-187,103"
      },
      EPSG_4192: {
        towgs84: "-206.1,-174.7,-87.7"
      },
      EPSG_4311: {
        towgs84: "-265,120,-358"
      },
      EPSG_4135: {
        towgs84: "58,-283,-182"
      },
      ESRI_104138: {
        towgs84: "198,-226,-347"
      },
      EPSG_4245: {
        towgs84: "-11,851,5"
      },
      EPSG_4142: {
        towgs84: "-125,53,467"
      },
      EPSG_4213: {
        towgs84: "-106,-87,188"
      },
      EPSG_4253: {
        towgs84: "-133,-77,-51"
      },
      EPSG_4129: {
        towgs84: "-132,-110,-335"
      },
      EPSG_4713: {
        towgs84: "-77,-128,142"
      },
      EPSG_4239: {
        towgs84: "217,823,299"
      },
      EPSG_4146: {
        towgs84: "295,736,257"
      },
      EPSG_4155: {
        towgs84: "-83,37,124"
      },
      EPSG_4165: {
        towgs84: "-173,253,27"
      },
      EPSG_4672: {
        towgs84: "175,-38,113"
      },
      EPSG_4236: {
        towgs84: "-637,-549,-203"
      },
      EPSG_4251: {
        towgs84: "-90,40,88"
      },
      EPSG_4271: {
        towgs84: "-2,374,172"
      },
      EPSG_4175: {
        towgs84: "-88,4,101"
      },
      EPSG_4716: {
        towgs84: "298,-304,-375"
      },
      EPSG_4315: {
        towgs84: "-23,259,-9"
      },
      EPSG_4744: {
        towgs84: "-242.2,-144.9,370.3"
      },
      EPSG_4244: {
        towgs84: "-97,787,86"
      },
      EPSG_4293: {
        towgs84: "616,97,-251"
      },
      EPSG_4714: {
        towgs84: "-127,-769,472"
      },
      EPSG_4736: {
        towgs84: "260,12,-147"
      },
      EPSG_6883: {
        towgs84: "-235,-110,393"
      },
      EPSG_6894: {
        towgs84: "-63,176,185"
      },
      EPSG_4205: {
        towgs84: "-43,-163,45"
      },
      EPSG_4256: {
        towgs84: "41,-220,-134"
      },
      EPSG_4262: {
        towgs84: "639,405,60"
      },
      EPSG_4604: {
        towgs84: "174,359,365"
      },
      EPSG_4169: {
        towgs84: "-115,118,426"
      },
      EPSG_4620: {
        towgs84: "-106,-129,165"
      },
      EPSG_4184: {
        towgs84: "-203,141,53"
      },
      EPSG_4616: {
        towgs84: "-289,-124,60"
      },
      EPSG_9403: {
        towgs84: "-307,-92,127"
      },
      EPSG_4684: {
        towgs84: "-133,-321,50"
      },
      EPSG_4708: {
        towgs84: "-491,-22,435"
      },
      EPSG_4707: {
        towgs84: "114,-116,-333"
      },
      EPSG_4709: {
        towgs84: "145,75,-272"
      },
      EPSG_4712: {
        towgs84: "-205,107,53"
      },
      EPSG_4711: {
        towgs84: "124,-234,-25"
      },
      EPSG_4718: {
        towgs84: "230,-199,-752"
      },
      EPSG_4719: {
        towgs84: "211,147,111"
      },
      EPSG_4724: {
        towgs84: "208,-435,-229"
      },
      EPSG_4725: {
        towgs84: "189,-79,-202"
      },
      EPSG_4735: {
        towgs84: "647,1777,-1124"
      },
      EPSG_4722: {
        towgs84: "-794,119,-298"
      },
      EPSG_4728: {
        towgs84: "-307,-92,127"
      },
      EPSG_4734: {
        towgs84: "-632,438,-609"
      },
      EPSG_4727: {
        towgs84: "912,-58,1227"
      },
      EPSG_4729: {
        towgs84: "185,165,42"
      },
      EPSG_4730: {
        towgs84: "170,42,84"
      },
      EPSG_4733: {
        towgs84: "276,-57,149"
      },
      ESRI_37218: {
        towgs84: "230,-199,-752"
      },
      ESRI_37240: {
        towgs84: "-7,215,225"
      },
      ESRI_37221: {
        towgs84: "252,-209,-751"
      },
      ESRI_4305: {
        towgs84: "-123,-206,219"
      },
      ESRI_104139: {
        towgs84: "-73,-247,227"
      },
      EPSG_4748: {
        towgs84: "51,391,-36"
      },
      EPSG_4219: {
        towgs84: "-384,664,-48"
      },
      EPSG_4255: {
        towgs84: "-333,-222,114"
      },
      EPSG_4257: {
        towgs84: "-587.8,519.75,145.76"
      },
      EPSG_4646: {
        towgs84: "-963,510,-359"
      },
      EPSG_6881: {
        towgs84: "-24,-203,268"
      },
      EPSG_6882: {
        towgs84: "-183,-15,273"
      },
      EPSG_4715: {
        towgs84: "-104,-129,239"
      },
      IGNF_RGF93GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGM04GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGSPM06GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGTAAF07GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGFG95GDD: {
        towgs84: "0,0,0"
      },
      IGNF_RGNCG: {
        towgs84: "0,0,0"
      },
      IGNF_RGPFGDD: {
        towgs84: "0,0,0"
      },
      IGNF_ETRS89G: {
        towgs84: "0,0,0"
      },
      IGNF_RGR92GDD: {
        towgs84: "0,0,0"
      },
      EPSG_4173: {
        towgs84: "0,0,0"
      },
      EPSG_4180: {
        towgs84: "0,0,0"
      },
      EPSG_4619: {
        towgs84: "0,0,0"
      },
      EPSG_4667: {
        towgs84: "0,0,0"
      },
      EPSG_4075: {
        towgs84: "0,0,0"
      },
      EPSG_6706: {
        towgs84: "0,0,0"
      },
      EPSG_7798: {
        towgs84: "0,0,0"
      },
      EPSG_4661: {
        towgs84: "0,0,0"
      },
      EPSG_4669: {
        towgs84: "0,0,0"
      },
      EPSG_8685: {
        towgs84: "0,0,0"
      },
      EPSG_4151: {
        towgs84: "0,0,0"
      },
      EPSG_9702: {
        towgs84: "0,0,0"
      },
      EPSG_4758: {
        towgs84: "0,0,0"
      },
      EPSG_4761: {
        towgs84: "0,0,0"
      },
      EPSG_4765: {
        towgs84: "0,0,0"
      },
      EPSG_8997: {
        towgs84: "0,0,0"
      },
      EPSG_4023: {
        towgs84: "0,0,0"
      },
      EPSG_4670: {
        towgs84: "0,0,0"
      },
      EPSG_4694: {
        towgs84: "0,0,0"
      },
      EPSG_4148: {
        towgs84: "0,0,0"
      },
      EPSG_4163: {
        towgs84: "0,0,0"
      },
      EPSG_4167: {
        towgs84: "0,0,0"
      },
      EPSG_4189: {
        towgs84: "0,0,0"
      },
      EPSG_4190: {
        towgs84: "0,0,0"
      },
      EPSG_4176: {
        towgs84: "0,0,0"
      },
      EPSG_4659: {
        towgs84: "0,0,0"
      },
      EPSG_3824: {
        towgs84: "0,0,0"
      },
      EPSG_3889: {
        towgs84: "0,0,0"
      },
      EPSG_4046: {
        towgs84: "0,0,0"
      },
      EPSG_4081: {
        towgs84: "0,0,0"
      },
      EPSG_4558: {
        towgs84: "0,0,0"
      },
      EPSG_4483: {
        towgs84: "0,0,0"
      },
      EPSG_5013: {
        towgs84: "0,0,0"
      },
      EPSG_5264: {
        towgs84: "0,0,0"
      },
      EPSG_5324: {
        towgs84: "0,0,0"
      },
      EPSG_5354: {
        towgs84: "0,0,0"
      },
      EPSG_5371: {
        towgs84: "0,0,0"
      },
      EPSG_5373: {
        towgs84: "0,0,0"
      },
      EPSG_5381: {
        towgs84: "0,0,0"
      },
      EPSG_5393: {
        towgs84: "0,0,0"
      },
      EPSG_5489: {
        towgs84: "0,0,0"
      },
      EPSG_5593: {
        towgs84: "0,0,0"
      },
      EPSG_6135: {
        towgs84: "0,0,0"
      },
      EPSG_6365: {
        towgs84: "0,0,0"
      },
      EPSG_5246: {
        towgs84: "0,0,0"
      },
      EPSG_7886: {
        towgs84: "0,0,0"
      },
      EPSG_8431: {
        towgs84: "0,0,0"
      },
      EPSG_8427: {
        towgs84: "0,0,0"
      },
      EPSG_8699: {
        towgs84: "0,0,0"
      },
      EPSG_8818: {
        towgs84: "0,0,0"
      },
      EPSG_4757: {
        towgs84: "0,0,0"
      },
      EPSG_9140: {
        towgs84: "0,0,0"
      },
      EPSG_8086: {
        towgs84: "0,0,0"
      },
      EPSG_4686: {
        towgs84: "0,0,0"
      },
      EPSG_4737: {
        towgs84: "0,0,0"
      },
      EPSG_4702: {
        towgs84: "0,0,0"
      },
      EPSG_4747: {
        towgs84: "0,0,0"
      },
      EPSG_4749: {
        towgs84: "0,0,0"
      },
      EPSG_4674: {
        towgs84: "0,0,0"
      },
      EPSG_4755: {
        towgs84: "0,0,0"
      },
      EPSG_4759: {
        towgs84: "0,0,0"
      },
      EPSG_4762: {
        towgs84: "0,0,0"
      },
      EPSG_4763: {
        towgs84: "0,0,0"
      },
      EPSG_4764: {
        towgs84: "0,0,0"
      },
      EPSG_4166: {
        towgs84: "0,0,0"
      },
      EPSG_4170: {
        towgs84: "0,0,0"
      },
      EPSG_5546: {
        towgs84: "0,0,0"
      },
      EPSG_7844: {
        towgs84: "0,0,0"
      },
      EPSG_4818: {
        towgs84: "589,76,480"
      }
    };
    for (key2 in datums) {
      datum2 = datums[key2];
      if (!datum2.datumName) {
        continue;
      }
      datums[datum2.datumName] = datum2;
    }
    Datum_default = datums;
  }
});

// node_modules/proj4/lib/datum.js
function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a;
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var datum_default;
var init_datum = __esm({
  "node_modules/proj4/lib/datum.js"() {
    init_values();
    datum_default = datum;
  }
});

// node_modules/proj4/lib/nadgrid.js
function nadgrid(key2, data, options2) {
  if (data instanceof ArrayBuffer) {
    return readNTV2Grid(key2, data, options2);
  }
  return { ready: readGeotiffGrid(key2, data) };
}
function readNTV2Grid(key2, data, options2) {
  var includeErrorFields = true;
  if (options2 !== void 0 && options2.includeErrorFields === false) {
    includeErrorFields = false;
  }
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  var subgrids = readSubgrids(view, header, isLittleEndian, includeErrorFields);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key2] = nadgrid2;
  return nadgrid2;
}
async function readGeotiffGrid(key2, tiff) {
  var subgrids = [];
  var subGridCount = await tiff.getImageCount();
  for (var subgridIndex = subGridCount - 1; subgridIndex >= 0; subgridIndex--) {
    var image = await tiff.getImage(subgridIndex);
    var rasters = await image.readRasters();
    var data = rasters;
    var lim = [image.getWidth(), image.getHeight()];
    var imageBBoxRadians = image.getBoundingBox().map(degreesToRadians2);
    var del = [image.fileDirectory.ModelPixelScale[0], image.fileDirectory.ModelPixelScale[1]].map(degreesToRadians2);
    var maxX = imageBBoxRadians[0] + (lim[0] - 1) * del[0];
    var minY = imageBBoxRadians[3] - (lim[1] - 1) * del[1];
    var latitudeOffsetBand = data[0];
    var longitudeOffsetBand = data[1];
    var nodes = [];
    for (let i = lim[1] - 1; i >= 0; i--) {
      for (let j = lim[0] - 1; j >= 0; j--) {
        var index8 = i * lim[0] + j;
        nodes.push([-secondsToRadians(longitudeOffsetBand[index8]), secondsToRadians(latitudeOffsetBand[index8])]);
      }
    }
    subgrids.push({
      del,
      lim,
      ll: [-maxX, minY],
      cvs: nodes
    });
  }
  var tifGrid = {
    header: {
      nSubgrids: subGridCount
    },
    subgrids
  };
  loadedNadgrids[key2] = tifGrid;
  return tifGrid;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === "@";
  if (optional) {
    value = value.slice(1);
  }
  if (value === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function degreesToRadians2(degrees) {
  return degrees * Math.PI / 180;
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian, includeErrorFields) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian, includeErrorFields);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
    );
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
    );
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
    var rowSize = 16;
    if (includeErrorFields === false) {
      rowSize = 8;
    }
    gridOffset += 176 + subHeader.gridNodeCount * rowSize;
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r3) {
    return [secondsToRadians(r3.longitudeShift), secondsToRadians(r3.latitudeShift)];
  });
}
function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset, gridHeader, isLittleEndian, includeErrorFields) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  if (includeErrorFields === false) {
    gridRecordLength = 8;
  }
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian)
    };
    if (includeErrorFields !== false) {
      record.latitudeAccuracy = view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian);
      record.longitudeAccuracy = view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian);
    }
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}
var loadedNadgrids;
var init_nadgrid = __esm({
  "node_modules/proj4/lib/nadgrid.js"() {
    loadedNadgrids = {};
  }
});

// node_modules/proj4/lib/Proj.js
function Projection2(srsCode, callback) {
  if (!(this instanceof Projection2)) {
    return new Projection2(srsCode);
  }
  this.forward = null;
  this.inverse = null;
  this.init = null;
  this.name;
  this.names = null;
  this.title;
  callback = callback || function(error2) {
    if (error2) {
      throw error2;
    }
  };
  var json2 = parseCode_default(srsCode);
  if (typeof json2 !== "object") {
    callback("Could not parse to valid json: " + srsCode);
    return;
  }
  var ourProj = Projection2.projections.get(json2.projName);
  if (!ourProj) {
    callback("Could not get projection name from: " + srsCode);
    return;
  }
  if (json2.datumCode && json2.datumCode !== "none") {
    var datumDef = match(Datum_default, json2.datumCode);
    if (datumDef) {
      json2.datum_params = json2.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json2.ellps = datumDef.ellipse;
      json2.datumName = datumDef.datumName ? datumDef.datumName : json2.datumCode;
    }
  }
  json2.k0 = json2.k0 || 1;
  json2.axis = json2.axis || "enu";
  json2.ellps = json2.ellps || "wgs84";
  json2.lat1 = json2.lat1 || json2.lat0;
  var sphere_ = sphere(json2.a, json2.b, json2.rf, json2.ellps, json2.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json2.R_A);
  var nadgrids = getNadgrids(json2.nadgrids);
  var datumObj = json2.datum || datum_default(
    json2.datumCode,
    json2.datum_params,
    sphere_.a,
    sphere_.b,
    ecc.es,
    ecc.ep2,
    nadgrids
  );
  extend_default(this, json2);
  extend_default(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  if ("init" in this && typeof this.init === "function") {
    this.init();
  }
  callback(null, this);
}
var Proj_default;
var init_Proj = __esm({
  "node_modules/proj4/lib/Proj.js"() {
    init_parseCode();
    init_extend();
    init_projections2();
    init_deriveConstants();
    init_Datum();
    init_datum();
    init_match();
    init_nadgrid();
    Projection2.projections = projections_default;
    Projection2.projections.start();
    Proj_default = Projection2;
  }
});

// node_modules/proj4/lib/datumUtils.js
function compareDatums(source2, dest) {
  if (source2.datum_type !== dest.datum_type) {
    return false;
  } else if (source2.a !== dest.a || Math.abs(source2.es - dest.es) > 5e-11) {
    return false;
  } else if (source2.datum_type === PJD_3PARAM) {
    return source2.datum_params[0] === dest.datum_params[0] && source2.datum_params[1] === dest.datum_params[1] && source2.datum_params[2] === dest.datum_params[2];
  } else if (source2.datum_type === PJD_7PARAM) {
    return source2.datum_params[0] === dest.datum_params[0] && source2.datum_params[1] === dest.datum_params[1] && source2.datum_params[2] === dest.datum_params[2] && source2.datum_params[3] === dest.datum_params[3] && source2.datum_params[4] === dest.datum_params[4] && source2.datum_params[5] === dest.datum_params[5] && source2.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0;
  var Rn;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p, es, a, b) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X = p.x;
  var Y = p.y;
  var Z2 = p.z ? p.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z2 * Z2);
  if (P / a < genau) {
    Longitude = 0;
    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    Longitude = Math.atan2(Y, X);
  }
  CT = Z2 / RR;
  ST = P / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}
var init_datumUtils = __esm({
  "node_modules/proj4/lib/datumUtils.js"() {
    "use strict";
    init_values();
  }
});

// node_modules/proj4/lib/datum_transform.js
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform_default(source2, dest, point) {
  if (compareDatums(source2, dest)) {
    return point;
  }
  if (source2.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }
  var source_a = source2.a;
  var source_es = source2.es;
  if (source2.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source2, false, point);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source2.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }
  point = geodeticToGeocentric(point, source_es, source_a);
  if (checkParams(source2.datum_type)) {
    point = geocentricToWgs84(point, source2.datum_type, source2.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point;
}
function applyGridShift(source2, inverse33, point) {
  if (source2.grids === null || source2.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point.x, y: point.y };
  var output = { x: Number.NaN, y: Number.NaN };
  var attemptedGrids = [];
  outer:
    for (var i = 0; i < source2.grids.length; i++) {
      var grid = source2.grids[i];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrids = grid.grid.subgrids;
      for (var j = 0, jj = subgrids.length; j < jj; j++) {
        var subgrid = subgrids[j];
        var epsilon2 = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
        var minX = subgrid.ll[0] - epsilon2;
        var minY = subgrid.ll[1] - epsilon2;
        var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon2;
        var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon2;
        if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
          continue;
        }
        output = applySubgridShift(input, inverse33, subgrid);
        if (!isNaN(output.x)) {
          break outer;
        }
      }
    }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse33, ct) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon_default(tb.x - Math.PI) + Math.PI;
  var t2 = nadInterpolate(tb, ct);
  if (inverse33) {
    if (isNaN(t2.x)) {
      return val;
    }
    t2.x = tb.x - t2.x;
    t2.y = tb.y - t2.y;
    var i = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t2, ct);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del.x + t2.x), y: tb.y - (del.y + t2.y) };
      t2.x += dif.x;
      t2.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon_default(t2.x + ct.ll[0]);
    val.y = t2.y + ct.ll[1];
  } else {
    if (!isNaN(t2.x)) {
      val.x = pin.x + t2.x;
      val.y = pin.y + t2.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct) {
  var t2 = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
  var indx = { x: Math.floor(t2.x), y: Math.floor(t2.y) };
  var frct = { x: t2.x - 1 * indx.x, y: t2.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = indx.y * ct.lim[0] + indx.x;
  var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx++;
  var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx += ct.lim[0];
  var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx--;
  var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
var init_datum_transform = __esm({
  "node_modules/proj4/lib/datum_transform.js"() {
    init_values();
    init_datumUtils();
    init_adjust_lon();
  }
});

// node_modules/proj4/lib/adjust_axis.js
function adjust_axis_default(crs, denorm, point) {
  var xin = point.x, yin = point.y, zin = point.z || 0;
  var v2, t2, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === void 0) {
      continue;
    }
    if (i === 0) {
      v2 = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t2 = "x";
      } else {
        t2 = "y";
      }
    } else if (i === 1) {
      v2 = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t2 = "y";
      } else {
        t2 = "x";
      }
    } else {
      v2 = zin;
      t2 = "z";
    }
    switch (crs.axis[i]) {
      case "e":
        out[t2] = v2;
        break;
      case "w":
        out[t2] = -v2;
        break;
      case "n":
        out[t2] = v2;
        break;
      case "s":
        out[t2] = -v2;
        break;
      case "u":
        if (point[t2] !== void 0) {
          out.z = v2;
        }
        break;
      case "d":
        if (point[t2] !== void 0) {
          out.z = -v2;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}
var init_adjust_axis = __esm({
  "node_modules/proj4/lib/adjust_axis.js"() {
  }
});

// node_modules/proj4/lib/common/toPoint.js
function toPoint_default(array2) {
  var out = {
    x: array2[0],
    y: array2[1]
  };
  if (array2.length > 2) {
    out.z = array2[2];
  }
  if (array2.length > 3) {
    out.m = array2[3];
  }
  return out;
}
var init_toPoint = __esm({
  "node_modules/proj4/lib/common/toPoint.js"() {
  }
});

// node_modules/proj4/lib/checkSanity.js
function checkSanity_default(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}
var init_checkSanity = __esm({
  "node_modules/proj4/lib/checkSanity.js"() {
  }
});

// node_modules/proj4/lib/transform.js
function checkNotWGS(source2, dest) {
  return (source2.datum.datum_type === PJD_3PARAM || source2.datum.datum_type === PJD_7PARAM || source2.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source2.datumCode !== "WGS84";
}
function transform2(source2, dest, point, enforceAxis) {
  var wgs842;
  if (Array.isArray(point)) {
    point = toPoint_default(point);
  } else {
    point = {
      x: point.x,
      y: point.y,
      z: point.z,
      m: point.m
    };
  }
  var hasZ = point.z !== void 0;
  checkSanity_default(point);
  if (source2.datum && dest.datum && checkNotWGS(source2, dest)) {
    wgs842 = new Proj_default("WGS84");
    point = transform2(source2, wgs842, point, enforceAxis);
    source2 = wgs842;
  }
  if (enforceAxis && source2.axis !== "enu") {
    point = adjust_axis_default(source2, false, point);
  }
  if (source2.projName === "longlat") {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source2.to_meter) {
      point = {
        x: point.x * source2.to_meter,
        y: point.y * source2.to_meter,
        z: point.z || 0
      };
    }
    point = source2.inverse(point);
    if (!point) {
      return;
    }
  }
  if (source2.from_greenwich) {
    point.x += source2.from_greenwich;
  }
  point = datum_transform_default(source2.datum, dest.datum, point);
  if (!point) {
    return;
  }
  point = /** @type {import('./core').InterfaceCoordinates} */
  point;
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis_default(dest, true, point);
  }
  if (point && !hasZ) {
    delete point.z;
  }
  return point;
}
var init_transform3 = __esm({
  "node_modules/proj4/lib/transform.js"() {
    init_values();
    init_datum_transform();
    init_adjust_axis();
    init_Proj();
    init_toPoint();
    init_checkSanity();
  }
});

// node_modules/proj4/lib/core.js
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform2(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return (
            /** @type {T} */
            [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.slice(3))
          );
        } else {
          return (
            /** @type {T} */
            [transformedArray.x, transformedArray.y, coords[2]].concat(coords.slice(3))
          );
        }
      } else {
        return (
          /** @type {T} */
          [transformedArray.x, transformedArray.y].concat(coords.slice(2))
        );
      }
    } else {
      return (
        /** @type {T} */
        [transformedArray.x, transformedArray.y]
      );
    }
  } else {
    out = transform2(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return (
        /** @type {T} */
        out
      );
    }
    keys.forEach(function(key2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key2 === "x" || key2 === "y" || key2 === "z") {
          return;
        }
      } else {
        if (key2 === "x" || key2 === "y") {
          return;
        }
      }
      out[key2] = coords[key2];
    });
    return (
      /** @type {T} */
      out
    );
  }
}
function checkProj(item) {
  if (item instanceof Proj_default) {
    return item;
  }
  if (typeof item === "object" && "oProj" in item) {
    return item.oProj;
  }
  return Proj_default(
    /** @type {string | PROJJSONDefinition} */
    item
  );
}
function proj4(fromProjOrToProj, toProjOrCoord, coord) {
  var fromProj;
  var toProj;
  var single = false;
  var obj;
  if (typeof toProjOrCoord === "undefined") {
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  } else if (typeof /** @type {?} */
  toProjOrCoord.x !== "undefined" || Array.isArray(toProjOrCoord)) {
    coord = /** @type {T} */
    /** @type {?} */
    toProjOrCoord;
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  }
  if (!fromProj) {
    fromProj = checkProj(fromProjOrToProj);
  }
  if (!toProj) {
    toProj = checkProj(
      /** @type {string | PROJJSONDefinition | proj } */
      toProjOrCoord
    );
  }
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var wgs84, core_default;
var init_core = __esm({
  "node_modules/proj4/lib/core.js"() {
    init_Proj();
    init_transform3();
    wgs84 = Proj_default("WGS84");
    core_default = proj4;
  }
});

// node_modules/mgrs/mgrs.js
function forward2(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode2(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse2(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
function toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A5, M5;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A5 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M5 = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N * (A5 + (1 - T + C) * A5 * A5 * A5 / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 / 120) + 5e5;
  var UTMNorthing = k0 * (M5 + N * Math.tan(LatRad) * (A5 * A5 / 2 + (5 - T + 9 * C + 4 * C * C) * A5 * A5 * A5 * A5 / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 * A5 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm) {
  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C13, R1, D2, M5;
  var LongOrigin;
  var mu, phi1Rad;
  var x = UTMEasting - 5e5;
  var y = UTMNorthing;
  if (zoneLetter < "N") {
    y -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M5 = y / k0;
  mu = M5 / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C13 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D2 = x / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D2 * D2 / 2 - (5 + 3 * T1 + 10 * C13 - 4 * C13 * C13 - 9 * eccPrimeSquared) * D2 * D2 * D2 * D2 / 24 + (61 + 90 * T1 + 298 * C13 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C13 * C13) * D2 * D2 * D2 * D2 * D2 * D2 / 720);
  lat = radToDeg(lat);
  var lon = (D2 - (1 + 2 * T1 + C13) * D2 * D2 * D2 / 6 + (5 - 2 * C13 + 28 * T1 - 3 * C13 * C13 + 8 * eccPrimeSquared + 24 * T1 * T1) * D2 * D2 * D2 * D2 * D2 / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat,
      lon
    };
  }
  return result;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode2(utm, accuracy) {
  var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index8 = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index8);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index8);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }
  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }
  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;
    if (colInt === I) {
      colInt++;
    }
  }
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }
  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;
    if (rowInt === I) {
      rowInt++;
    }
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i === 0 || i + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i, i += 2);
  var set2 = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set2);
  var north100k = getNorthingFromChar(hunK.charAt(1), set2);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e3, set2) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set2 - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e3.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e3;
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n2, set2) {
  if (n2 > "V") {
    throw "MGRSPoint given invalid Northing " + n2;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set2 - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n2.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    if (curRow > V) {
      if (rewindMarker) {
        throw "Bad character: " + n2;
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
var NUM_100K_SETS, SET_ORIGIN_COLUMN_LETTERS, SET_ORIGIN_ROW_LETTERS, A, I, O, V, Z, mgrs_default;
var init_mgrs = __esm({
  "node_modules/mgrs/mgrs.js"() {
    NUM_100K_SETS = 6;
    SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
    SET_ORIGIN_ROW_LETTERS = "AFAFAF";
    A = 65;
    I = 73;
    O = 79;
    V = 86;
    Z = 90;
    mgrs_default = {
      forward: forward2,
      inverse: inverse2,
      toPoint
    };
  }
});

// node_modules/proj4/lib/Point.js
function Point2(x, y, z) {
  if (!(this instanceof Point2)) {
    return new Point2(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0;
  } else if (typeof x === "object") {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0;
  } else if (typeof x === "string" && typeof y === "undefined") {
    var coords = x.split(",");
    this.x = parseFloat(coords[0]);
    this.y = parseFloat(coords[1]);
    this.z = parseFloat(coords[2]) || 0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
var Point_default2;
var init_Point2 = __esm({
  "node_modules/proj4/lib/Point.js"() {
    init_mgrs();
    Point2.fromMGRS = function(mgrsStr) {
      return new Point2(toPoint(mgrsStr));
    };
    Point2.prototype.toMGRS = function(accuracy) {
      return forward2([this.x, this.y], accuracy);
    };
    Point_default2 = Point2;
  }
});

// node_modules/proj4/lib/common/pj_enfn.js
function pj_enfn_default(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t2 = es * es;
  en[2] = t2 * (C44 - es * (C46 + es * C48));
  t2 *= es;
  en[3] = t2 * (C66 - es * C68);
  en[4] = t2 * es * C88;
  return en;
}
var C00, C02, C04, C06, C08, C22, C44, C46, C48, C66, C68, C88;
var init_pj_enfn = __esm({
  "node_modules/proj4/lib/common/pj_enfn.js"() {
    C00 = 1;
    C02 = 0.25;
    C04 = 0.046875;
    C06 = 0.01953125;
    C08 = 0.01068115234375;
    C22 = 0.75;
    C44 = 0.46875;
    C46 = 0.013020833333333334;
    C48 = 0.007120768229166667;
    C66 = 0.3645833333333333;
    C68 = 0.005696614583333333;
    C88 = 0.3076171875;
  }
});

// node_modules/proj4/lib/common/pj_mlfn.js
function pj_mlfn_default(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}
var init_pj_mlfn = __esm({
  "node_modules/proj4/lib/common/pj_mlfn.js"() {
  }
});

// node_modules/proj4/lib/common/pj_inv_mlfn.js
function pj_inv_mlfn_default(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) {
    var s3 = Math.sin(phi);
    var t2 = 1 - es * s3 * s3;
    t2 = (pj_mlfn_default(phi, s3, Math.cos(phi), en) - arg) * (t2 * Math.sqrt(t2)) * k;
    phi -= t2;
    if (Math.abs(t2) < EPSLN) {
      return phi;
    }
  }
  return phi;
}
var MAX_ITER;
var init_pj_inv_mlfn = __esm({
  "node_modules/proj4/lib/common/pj_inv_mlfn.js"() {
    init_pj_mlfn();
    init_values();
    MAX_ITER = 20;
  }
});

// node_modules/proj4/lib/projections/tmerc.js
function init4() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.ml0 = pj_mlfn_default(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward3(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b) - 1) < EPSLN) {
      return 93;
    } else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);
      if (b >= 1) {
        if (b - 1 > EPSLN) {
          return 93;
        } else {
          y = 0;
        }
      } else {
        y = Math.acos(y);
      }
      if (lat < 0) {
        y = -y;
      }
      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als2 = Math.pow(al, 2);
    var c2 = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c2, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t2 = Math.pow(tq, 2);
    var ts = Math.pow(t2, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn_default(lat, sin_phi, cos_phi, this.en);
    x = this.a * (this.k0 * al * (1 + als2 / 6 * (1 - t2 + c2 + als2 / 20 * (5 - 18 * t2 + ts + 14 * c2 - 58 * t2 * c2 + als2 / 42 * (61 + 179 * ts - ts * t2 - 479 * t2))))) + this.x0;
    y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als2 / 12 * (5 - t2 + 9 * c2 + 4 * cs + als2 / 30 * (61 + ts - 58 * t2 + 270 * c2 - 330 * t2 * c2 + als2 / 56 * (1385 + 543 * ts - ts * t2 - 3111 * t2)))))) + this.y0;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse3(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);
    if (y < 0) {
      lat = -lat;
    }
    if (g === 0 && h === 0) {
      lon = 0;
    } else {
      lon = adjust_lon_default(Math.atan2(g, h) + this.long0);
    }
  } else {
    con = this.ml0 + y / this.k0;
    phi = pj_inv_mlfn_default(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c2 = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c2, 2);
      var t2 = Math.pow(tan_phi, 2);
      var ts = Math.pow(t2, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t2 - 9 * c2 * t2 + c2 - 4 * cs - ds / 30 * (61 + 90 * t2 - 252 * c2 * t2 + 45 * ts + 46 * c2 - ds / 56 * (1385 + 3633 * t2 + 4095 * ts + 1574 * ts * t2))));
      lon = adjust_lon_default(this.long0 + d * (1 - ds / 6 * (1 + 2 * t2 + c2 - ds / 20 * (5 + 28 * t2 + 24 * ts + 8 * c2 * t2 + 6 * c2 - ds / 42 * (61 + 662 * t2 + 1320 * ts + 720 * ts * t2)))) / cos_phi);
    } else {
      lat = HALF_PI * sign_default(y);
      lon = 0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names4, tmerc_default;
var init_tmerc = __esm({
  "node_modules/proj4/lib/projections/tmerc.js"() {
    init_pj_enfn();
    init_pj_mlfn();
    init_pj_inv_mlfn();
    init_adjust_lon();
    init_values();
    init_sign();
    names4 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
    tmerc_default = {
      init: init4,
      forward: forward3,
      inverse: inverse3,
      names: names4
    };
  }
});

// node_modules/proj4/lib/common/sinh.js
function sinh_default(x) {
  var r3 = Math.exp(x);
  r3 = (r3 - 1 / r3) / 2;
  return r3;
}
var init_sinh = __esm({
  "node_modules/proj4/lib/common/sinh.js"() {
  }
});

// node_modules/proj4/lib/common/hypot.js
function hypot_default(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);
  return a * Math.sqrt(1 + Math.pow(b, 2));
}
var init_hypot = __esm({
  "node_modules/proj4/lib/common/hypot.js"() {
  }
});

// node_modules/proj4/lib/common/log1py.js
function log1py_default(x) {
  var y = 1 + x;
  var z = y - 1;
  return z === 0 ? x : x * Math.log(y) / z;
}
var init_log1py = __esm({
  "node_modules/proj4/lib/common/log1py.js"() {
  }
});

// node_modules/proj4/lib/common/asinhy.js
function asinhy_default(x) {
  var y = Math.abs(x);
  y = log1py_default(y * (1 + y / (hypot_default(1, y) + 1)));
  return x < 0 ? -y : y;
}
var init_asinhy = __esm({
  "node_modules/proj4/lib/common/asinhy.js"() {
    init_hypot();
    init_log1py();
  }
});

// node_modules/proj4/lib/common/gatg.js
function gatg_default(pp, B2) {
  var cos_2B = 2 * Math.cos(2 * B2);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;
  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }
  return B2 + h * Math.sin(2 * B2);
}
var init_gatg = __esm({
  "node_modules/proj4/lib/common/gatg.js"() {
  }
});

// node_modules/proj4/lib/common/clens.js
function clens_default(pp, arg_r) {
  var r3 = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;
  while (--i >= 0) {
    hr = -hr2 + r3 * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }
  return Math.sin(arg_r) * hr;
}
var init_clens = __esm({
  "node_modules/proj4/lib/common/clens.js"() {
  }
});

// node_modules/proj4/lib/common/cosh.js
function cosh_default(x) {
  var r3 = Math.exp(x);
  r3 = (r3 + 1 / r3) / 2;
  return r3;
}
var init_cosh = __esm({
  "node_modules/proj4/lib/common/cosh.js"() {
  }
});

// node_modules/proj4/lib/common/clens_cmplx.js
function clens_cmplx_default(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh_default(arg_i);
  var cosh_arg_i = cosh_default(arg_i);
  var r3 = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;
  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r3 * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r3 * hi1;
  }
  r3 = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r3 * hr - i * hi, r3 * hi + i * hr];
}
var init_clens_cmplx = __esm({
  "node_modules/proj4/lib/common/clens_cmplx.js"() {
    init_sinh();
    init_cosh();
  }
});

// node_modules/proj4/lib/projections/etmerc.js
function init5() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc_default.init.apply(this);
    this.forward = tmerc_default.forward;
    this.inverse = tmerc_default.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n2 = f / (2 - f);
  var np = n2;
  this.cgb[0] = n2 * (2 + n2 * (-2 / 3 + n2 * (-2 + n2 * (116 / 45 + n2 * (26 / 45 + n2 * (-2854 / 675))))));
  this.cbg[0] = n2 * (-2 + n2 * (2 / 3 + n2 * (4 / 3 + n2 * (-82 / 45 + n2 * (32 / 45 + n2 * (4642 / 4725))))));
  np = np * n2;
  this.cgb[1] = np * (7 / 3 + n2 * (-8 / 5 + n2 * (-227 / 45 + n2 * (2704 / 315 + n2 * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n2 * (-16 / 15 + n2 * (-13 / 9 + n2 * (904 / 315 + n2 * (-1522 / 945)))));
  np = np * n2;
  this.cgb[2] = np * (56 / 15 + n2 * (-136 / 35 + n2 * (-1262 / 105 + n2 * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n2 * (34 / 21 + n2 * (8 / 5 + n2 * (-12686 / 2835))));
  np = np * n2;
  this.cgb[3] = np * (4279 / 630 + n2 * (-332 / 35 + n2 * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n2 * (-12 / 5 + n2 * (-24832 / 14175)));
  np = np * n2;
  this.cgb[4] = np * (4174 / 315 + n2 * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n2 * (109598 / 31185));
  np = np * n2;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n2, 2);
  this.Qn = this.k0 / (1 + n2) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n2 * (-0.5 + n2 * (2 / 3 + n2 * (-37 / 96 + n2 * (1 / 360 + n2 * (81 / 512 + n2 * (-96199 / 604800))))));
  this.gtu[0] = n2 * (0.5 + n2 * (-2 / 3 + n2 * (5 / 16 + n2 * (41 / 180 + n2 * (-127 / 288 + n2 * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n2 * (-1 / 15 + n2 * (437 / 1440 + n2 * (-46 / 105 + n2 * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n2 * (-3 / 5 + n2 * (557 / 1440 + n2 * (281 / 630 + n2 * (-1983433 / 1935360)))));
  np = np * n2;
  this.utg[2] = np * (-17 / 480 + n2 * (37 / 840 + n2 * (209 / 4480 + n2 * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n2 * (-103 / 140 + n2 * (15061 / 26880 + n2 * (167603 / 181440))));
  np = np * n2;
  this.utg[3] = np * (-4397 / 161280 + n2 * (11 / 504 + n2 * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n2 * (-179 / 168 + n2 * (6601661 / 7257600)));
  np = np * n2;
  this.utg[4] = np * (-4583 / 161280 + n2 * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n2 * (-3418889 / 1995840));
  np = np * n2;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z2 = gatg_default(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z2 + clens_default(this.gtu, 2 * Z2));
}
function forward4(p) {
  var Ce = adjust_lon_default(p.x - this.long0);
  var Cn = p.y;
  Cn = gatg_default(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot_default(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy_default(Math.tan(Ce));
  var tmp = clens_cmplx_default(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x;
  var y;
  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x = Infinity;
    y = Infinity;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse4(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx_default(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh_default(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot_default(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon_default(Ce + this.long0);
    lat = gatg_default(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names5, etmerc_default;
var init_etmerc = __esm({
  "node_modules/proj4/lib/projections/etmerc.js"() {
    init_tmerc();
    init_sinh();
    init_hypot();
    init_asinhy();
    init_gatg();
    init_clens();
    init_clens_cmplx();
    init_adjust_lon();
    names5 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
    etmerc_default = {
      init: init5,
      forward: forward4,
      inverse: inverse4,
      names: names5
    };
  }
});

// node_modules/proj4/lib/common/adjust_zone.js
function adjust_zone_default(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon_default(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}
var init_adjust_zone = __esm({
  "node_modules/proj4/lib/common/adjust_zone.js"() {
    init_adjust_lon();
  }
});

// node_modules/proj4/lib/projections/utm.js
function init6() {
  var zone = adjust_zone_default(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc_default.init.apply(this);
  this.forward = etmerc_default.forward;
  this.inverse = etmerc_default.inverse;
}
var dependsOn, names6, utm_default;
var init_utm2 = __esm({
  "node_modules/proj4/lib/projections/utm.js"() {
    init_adjust_zone();
    init_etmerc();
    init_values();
    dependsOn = "etmerc";
    names6 = ["Universal Transverse Mercator System", "utm"];
    utm_default = {
      init: init6,
      names: names6,
      dependsOn
    };
  }
});

// node_modules/proj4/lib/common/srat.js
function srat_default(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
var init_srat = __esm({
  "node_modules/proj4/lib/common/srat.js"() {
  }
});

// node_modules/proj4/lib/projections/gauss.js
function init7() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat_default(this.e * sphi, this.ratexp));
}
function forward5(p) {
  var lon = p.x;
  var lat = p.y;
  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat_default(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
}
function inverse5(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = MAX_ITER2; i > 0; --i) {
    lat = 2 * Math.atan(num * srat_default(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var MAX_ITER2, names7, gauss_default;
var init_gauss = __esm({
  "node_modules/proj4/lib/projections/gauss.js"() {
    init_srat();
    init_values();
    MAX_ITER2 = 20;
    names7 = ["gauss"];
    gauss_default = {
      init: init7,
      forward: forward5,
      inverse: inverse5,
      names: names7
    };
  }
});

// node_modules/proj4/lib/projections/sterea.js
function init8() {
  gauss_default.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward6(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon_default(p.x - this.long0);
  gauss_default.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function inverse6(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rho = hypot_default(p.x, p.y)) {
    var c2 = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c2);
    cosc = Math.cos(c2);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  gauss_default.inverse.apply(this, [p]);
  p.x = adjust_lon_default(p.x + this.long0);
  return p;
}
var names8, sterea_default;
var init_sterea = __esm({
  "node_modules/proj4/lib/projections/sterea.js"() {
    init_gauss();
    init_adjust_lon();
    init_hypot();
    names8 = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
    sterea_default = {
      init: init8,
      forward: forward6,
      inverse: inverse6,
      names: names8
    };
  }
});

// node_modules/proj4/lib/projections/stere.js
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init9() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign_default(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && Math.abs(Math.cos(this.lat_ts)) > EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz_default(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz_default(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward7(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A5, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon_default(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    A5 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A5 * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A5 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  } else {
    X = 2 * Math.atan(ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz_default(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A5 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A5 * sinX;
    } else {
      A5 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A5 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A5 * cosX * Math.sin(dlon) + this.x0;
  }
  return p;
}
function inverse7(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce2, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c2 = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c2) * this.sinlat0 + p.y * Math.sin(c2) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -1 * p.y));
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x, p.y));
      }
    } else {
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x * Math.sin(c2), rh * this.coslat0 * Math.cos(c2) - p.y * this.sinlat0 * Math.sin(c2)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z_default(this.e, ts);
      lon = this.con * adjust_lon_default(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
    } else {
      ce2 = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce2) * this.sinX0 + p.y * Math.sin(ce2) * this.cosX0 / rh);
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x * Math.sin(ce2), rh * this.cosX0 * Math.cos(ce2) - p.y * this.sinX0 * Math.sin(ce2)));
      }
      lat = -1 * phi2z_default(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names9, stere_default;
var init_stere = __esm({
  "node_modules/proj4/lib/projections/stere.js"() {
    init_values();
    init_sign();
    init_msfnz();
    init_tsfnz();
    init_phi2z();
    init_adjust_lon();
    names9 = ["stere", "Stereographic_South_Pole", "Polar_Stereographic_variant_A", "Polar_Stereographic_variant_B", "Polar_Stereographic"];
    stere_default = {
      init: init9,
      forward: forward7,
      inverse: inverse7,
      names: names9,
      ssfn_
    };
  }
});

// node_modules/proj4/lib/projections/somerc.js
function init10() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e22 = 2 * flattening - Math.pow(flattening, 2);
  var e3 = this.e = Math.sqrt(e22);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e22) / (1 - e22 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e22 / (1 - e22) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e3 * sinPhy0) / (1 - e3 * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e3 / 2 * k3;
}
function forward8(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
  var I2 = this.alpha * (p.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I2)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I2));
  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}
function inverse8(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I2 / this.alpha;
  var S = 0;
  var phy = b;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }
  p.x = lambda;
  p.y = phy;
  return p;
}
var names10, somerc_default;
var init_somerc = __esm({
  "node_modules/proj4/lib/projections/somerc.js"() {
    names10 = ["somerc"];
    somerc_default = {
      init: init10,
      forward: forward8,
      inverse: inverse8,
      names: names10
    };
  }
});

// node_modules/proj4/lib/projections/omerc.js
function isTypeA(P) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P.projName === "object" ? Object.keys(P.projName)[0] : P.projName;
  return "no_uoff" in P || "no_off" in P || typeAProjections.indexOf(projectionName) !== -1 || typeAProjections.indexOf(getNormalizedProjName(projectionName)) !== -1;
}
function init11() {
  var con, com, cosph0, D2, F, H, L, sinph0, p, J, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D2 = this.B * com / (cosph0 * Math.sqrt(con));
    F = D2 * D2 - 1;
    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);
      if (this.lat0 < 0) {
        F = -F;
      }
    }
    this.E = F += D2;
    this.E *= Math.pow(tsfnz_default(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D2 = F = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D2);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D2 * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz_default(this.e, phi1, Math.sin(phi1)), this.B);
    L = Math.pow(tsfnz_default(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p = (L - H) / (L + H);
    J = this.E * this.E;
    J = (J - L * H) / (J + L * H);
    con = lam1 - lam2;
    if (con < -Math.PI) {
      lam2 -= TWO_PI;
    } else if (con > Math.PI) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon_default(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon_default(lam1 - this.lam0)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D2 * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D2 * D2 - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
}
function forward9(p) {
  var coords = {};
  var S, T, U, V2, W, temp, u4, v2;
  p.x = p.x - this.lam0;
  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
    W = this.E / Math.pow(tsfnz_default(this.e, p.y, Math.sin(p.y)), this.B);
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V2 = Math.sin(this.B * p.x);
    U = (S * this.singam - V2 * this.cosgam) / T;
    if (Math.abs(Math.abs(U) - 1) < EPSLN) {
      throw new Error();
    }
    v2 = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
    temp = Math.cos(this.B * p.x);
    if (Math.abs(temp) < TOL) {
      u4 = this.A * p.x;
    } else {
      u4 = this.ArB * Math.atan2(S * this.cosgam + V2 * this.singam, temp);
    }
  } else {
    v2 = p.y > 0 ? this.v_pole_n : this.v_pole_s;
    u4 = this.ArB * p.y;
  }
  if (this.no_rot) {
    coords.x = u4;
    coords.y = v2;
  } else {
    u4 -= this.u_0;
    coords.x = v2 * this.cosrot + u4 * this.sinrot;
    coords.y = u4 * this.cosrot - v2 * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse9(p) {
  var u4, v2, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p.x = (p.x - this.x0) * (1 / this.a);
  p.y = (p.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v2 = p.y;
    u4 = p.x;
  } else {
    v2 = p.x * this.cosrot - p.y * this.sinrot;
    u4 = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v2);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u4);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z_default(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u4));
  }
  coords.x += this.lam0;
  return coords;
}
var TOL, names11, omerc_default;
var init_omerc = __esm({
  "node_modules/proj4/lib/projections/omerc.js"() {
    init_tsfnz();
    init_adjust_lon();
    init_phi2z();
    init_values();
    init_projections2();
    TOL = 1e-7;
    names11 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Variant_B", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
    omerc_default = {
      init: init11,
      forward: forward9,
      inverse: inverse9,
      names: names11
    };
  }
});

// node_modules/proj4/lib/projections/lcc.js
function init12() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz_default(this.e, sin1, cos1);
  var ts1 = tsfnz_default(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz_default(this.e, sin2, cos2);
  var ts2 = tsfnz_default(this.e, this.lat2, sin2);
  var ts0 = Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN ? 0 : tsfnz_default(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward10(p) {
  var lon = p.x;
  var lat = p.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign_default(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz_default(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p;
}
function inverse10(p) {
  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = this.rh - (p.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x, con * y);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon_default(theta / this.ns + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
var names12, lcc_default;
var init_lcc = __esm({
  "node_modules/proj4/lib/projections/lcc.js"() {
    init_msfnz();
    init_tsfnz();
    init_sign();
    init_adjust_lon();
    init_phi2z();
    init_values();
    names12 = [
      "Lambert Tangential Conformal Conic Projection",
      "Lambert_Conformal_Conic",
      "Lambert_Conformal_Conic_1SP",
      "Lambert_Conformal_Conic_2SP",
      "lcc",
      "Lambert Conic Conformal (1SP)",
      "Lambert Conic Conformal (2SP)"
    ];
    lcc_default = {
      init: init12,
      forward: forward10,
      inverse: inverse10,
      names: names12
    };
  }
});

// node_modules/proj4/lib/projections/krovak.js
function init13() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward11(p) {
  var gfi, u4, deltav, s3, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u4 = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s3 = Math.asin(Math.cos(this.ad) * Math.sin(u4) + Math.sin(this.ad) * Math.cos(u4) * Math.cos(deltav));
  d = Math.asin(Math.cos(u4) * Math.sin(deltav) / Math.cos(s3));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s3 / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return p;
}
function inverse11(p) {
  var u4, deltav, s3, d, eps, ro, fi1;
  var ok;
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s3 = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u4 = Math.asin(Math.cos(this.ad) * Math.sin(s3) - Math.sin(this.ad) * Math.cos(s3) * Math.cos(d));
  deltav = Math.asin(Math.cos(s3) * Math.sin(d) / Math.cos(u4));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u4;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u4 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p;
}
var names13, krovak_default;
var init_krovak = __esm({
  "node_modules/proj4/lib/projections/krovak.js"() {
    init_adjust_lon();
    names13 = ["Krovak", "krovak"];
    krovak_default = {
      init: init13,
      forward: forward11,
      inverse: inverse11,
      names: names13
    };
  }
});

// node_modules/proj4/lib/common/mlfn.js
function mlfn_default(e0, e1, e22, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e22 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}
var init_mlfn = __esm({
  "node_modules/proj4/lib/common/mlfn.js"() {
  }
});

// node_modules/proj4/lib/common/e0fn.js
function e0fn_default(x) {
  return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
}
var init_e0fn = __esm({
  "node_modules/proj4/lib/common/e0fn.js"() {
  }
});

// node_modules/proj4/lib/common/e1fn.js
function e1fn_default(x) {
  return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
}
var init_e1fn = __esm({
  "node_modules/proj4/lib/common/e1fn.js"() {
  }
});

// node_modules/proj4/lib/common/e2fn.js
function e2fn_default(x) {
  return 0.05859375 * x * x * (1 + 0.75 * x);
}
var init_e2fn = __esm({
  "node_modules/proj4/lib/common/e2fn.js"() {
  }
});

// node_modules/proj4/lib/common/e3fn.js
function e3fn_default(x) {
  return x * x * x * (35 / 3072);
}
var init_e3fn = __esm({
  "node_modules/proj4/lib/common/e3fn.js"() {
  }
});

// node_modules/proj4/lib/common/gN.js
function gN_default(a, e3, sinphi) {
  var temp = e3 * sinphi;
  return a / Math.sqrt(1 - temp * temp);
}
var init_gN = __esm({
  "node_modules/proj4/lib/common/gN.js"() {
  }
});

// node_modules/proj4/lib/common/adjust_lat.js
function adjust_lat_default(x) {
  return Math.abs(x) < HALF_PI ? x : x - sign_default(x) * Math.PI;
}
var init_adjust_lat = __esm({
  "node_modules/proj4/lib/common/adjust_lat.js"() {
    init_values();
    init_sign();
  }
});

// node_modules/proj4/lib/common/imlfn.js
function imlfn_default(ml, e0, e1, e22, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e22 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e22 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
var init_imlfn = __esm({
  "node_modules/proj4/lib/common/imlfn.js"() {
  }
});

// node_modules/proj4/lib/projections/cass.js
function init14() {
  if (!this.sphere) {
    this.e0 = e0fn_default(this.es);
    this.e1 = e1fn_default(this.es);
    this.e2 = e2fn_default(this.es);
    this.e3 = e3fn_default(this.es);
    this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward12(p) {
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN_default(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
function inverse12(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn_default(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN_default(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p.x = adjust_lon_default(lam + this.long0);
  p.y = adjust_lat_default(phi);
  return p;
}
var names14, cass_default;
var init_cass = __esm({
  "node_modules/proj4/lib/projections/cass.js"() {
    init_mlfn();
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_gN();
    init_adjust_lon();
    init_adjust_lat();
    init_imlfn();
    init_values();
    names14 = ["Cassini", "Cassini_Soldner", "cass"];
    cass_default = {
      init: init14,
      forward: forward12,
      inverse: inverse12,
      names: names14
    };
  }
});

// node_modules/proj4/lib/common/qsfnz.js
function qsfnz_default(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}
var init_qsfnz = __esm({
  "node_modules/proj4/lib/common/qsfnz.js"() {
  }
});

// node_modules/proj4/lib/projections/laea.js
function init15() {
  var t2 = Math.abs(this.lat0);
  if (Math.abs(t2 - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? S_POLE : N_POLE;
  } else if (Math.abs(t2) < EPSLN) {
    this.mode = EQUIT;
  } else {
    this.mode = OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz_default(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case N_POLE:
        this.dd = 1;
        break;
      case S_POLE:
        this.dd = 1;
        break;
      case EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz_default(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward13(p) {
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz_default(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * (this.mode === this.S_POLE ? b : -b);
        } else {
          x = y = 0;
        }
        break;
    }
  }
  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}
function inverse13(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab4;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
  } else {
    ab4 = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab4 = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab4;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      } else {
        ab4 = y * sCe / rho;
        q = this.qp * ab4;
        y = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = x * x + y * y;
      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      ab4 = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab4 = -ab4;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab4), this.apa);
  }
  p.x = adjust_lon_default(this.long0 + lam);
  p.y = phi;
  return p;
}
function authset(es) {
  var t2;
  var APA = [];
  APA[0] = es * P00;
  t2 = es * es;
  APA[0] += t2 * P01;
  APA[1] = t2 * P10;
  t2 *= es;
  APA[0] += t2 * P02;
  APA[1] += t2 * P11;
  APA[2] = t2 * P20;
  return APA;
}
function authlat(beta, APA) {
  var t2 = beta + beta;
  return beta + APA[0] * Math.sin(t2) + APA[1] * Math.sin(t2 + t2) + APA[2] * Math.sin(t2 + t2 + t2);
}
var S_POLE, N_POLE, EQUIT, OBLIQ, P00, P01, P02, P10, P11, P20, names15, laea_default;
var init_laea = __esm({
  "node_modules/proj4/lib/projections/laea.js"() {
    init_values();
    init_qsfnz();
    init_adjust_lon();
    S_POLE = 1;
    N_POLE = 2;
    EQUIT = 3;
    OBLIQ = 4;
    P00 = 0.3333333333333333;
    P01 = 0.17222222222222222;
    P02 = 0.10257936507936508;
    P10 = 0.06388888888888888;
    P11 = 0.0664021164021164;
    P20 = 0.016415012942191543;
    names15 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
    laea_default = {
      init: init15,
      forward: forward13,
      inverse: inverse13,
      names: names15,
      S_POLE,
      N_POLE,
      EQUIT,
      OBLIQ
    };
  }
});

// node_modules/proj4/lib/common/asinz.js
function asinz_default(x) {
  if (Math.abs(x) > 1) {
    x = x > 1 ? 1 : -1;
  }
  return Math.asin(x);
}
var init_asinz = __esm({
  "node_modules/proj4/lib/common/asinz.js"() {
  }
});

// node_modules/proj4/lib/projections/aea.js
function init16() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz_default(this.e3, this.sin_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward14(p) {
  var lon = p.x;
  var lat = p.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz_default(this.e3, this.sin_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon_default(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse14(p) {
  var rh1, qs, con, theta, lon, lat;
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon_default(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz_default(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names16, aea_default;
var init_aea = __esm({
  "node_modules/proj4/lib/projections/aea.js"() {
    init_msfnz();
    init_qsfnz();
    init_adjust_lon();
    init_asinz();
    init_values();
    names16 = ["Albers_Conic_Equal_Area", "Albers_Equal_Area", "Albers", "aea"];
    aea_default = {
      init: init16,
      forward: forward14,
      inverse: inverse14,
      names: names16,
      phi1z
    };
  }
});

// node_modules/proj4/lib/projections/gnom.js
function init17() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward15(p) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse15(p) {
  var rh;
  var sinc, cosc;
  var c2;
  var lon, lat;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
    c2 = Math.atan2(rh, this.rc);
    sinc = Math.sin(c2);
    cosc = Math.cos(c2);
    lat = asinz_default(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon_default(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names17, gnom_default;
var init_gnom = __esm({
  "node_modules/proj4/lib/projections/gnom.js"() {
    init_adjust_lon();
    init_asinz();
    init_values();
    names17 = ["gnom"];
    gnom_default = {
      init: init17,
      forward: forward15,
      inverse: inverse15,
      names: names17
    };
  }
});

// node_modules/proj4/lib/common/iqsfnz.js
function iqsfnz_default(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1e-6) {
    if (q < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
var init_iqsfnz = __esm({
  "node_modules/proj4/lib/common/iqsfnz.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/projections/cea.js
function init18() {
  if (!this.sphere) {
    this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward16(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  var dlon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz_default(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse16(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz_default(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon_default(this.long0 + p.x / (this.a * this.k0));
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names18, cea_default;
var init_cea = __esm({
  "node_modules/proj4/lib/projections/cea.js"() {
    init_adjust_lon();
    init_qsfnz();
    init_msfnz();
    init_iqsfnz();
    names18 = ["cea"];
    cea_default = {
      init: init18,
      forward: forward16,
      inverse: inverse16,
      names: names18
    };
  }
});

// node_modules/proj4/lib/projections/eqc.js
function init19() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward17(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var dlat = adjust_lat_default(lat - this.lat0);
  p.x = this.x0 + this.a * dlon * this.rc;
  p.y = this.y0 + this.a * dlat;
  return p;
}
function inverse17(p) {
  var x = p.x;
  var y = p.y;
  p.x = adjust_lon_default(this.long0 + (x - this.x0) / (this.a * this.rc));
  p.y = adjust_lat_default(this.lat0 + (y - this.y0) / this.a);
  return p;
}
var names19, eqc_default;
var init_eqc = __esm({
  "node_modules/proj4/lib/projections/eqc.js"() {
    init_adjust_lon();
    init_adjust_lat();
    names19 = ["Equirectangular", "Equidistant_Cylindrical", "Equidistant_Cylindrical_Spherical", "eqc"];
    eqc_default = {
      init: init19,
      forward: forward17,
      inverse: inverse17,
      names: names19
    };
  }
});

// node_modules/proj4/lib/projections/poly.js
function init20() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward18(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon_default(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    } else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat_default(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    } else {
      var nl = gN_default(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
function inverse18(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon_default(x / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER3; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon_default(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon_default(this.long0 + x / this.a);
    } else {
      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER3; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon_default(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var MAX_ITER3, names20, poly_default;
var init_poly = __esm({
  "node_modules/proj4/lib/projections/poly.js"() {
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_adjust_lon();
    init_adjust_lat();
    init_mlfn();
    init_values();
    init_gN();
    MAX_ITER3 = 20;
    names20 = ["Polyconic", "American_Polyconic", "poly"];
    poly_default = {
      init: init20,
      forward: forward18,
      inverse: inverse18,
      names: names20
    };
  }
});

// node_modules/proj4/lib/projections/nzmg.js
function init21() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward19(p) {
  var n2;
  var lon = p.x;
  var lat = p.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n2 = 1; n2 <= 10; n2++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n2] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n2 = 1; n2 <= 6; n2++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im;
    z_im = z_im + this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im;
  }
  p.x = z_im * this.a + this.x0;
  p.y = z_re * this.a + this.y0;
  return p;
}
function inverse19(p) {
  var n2;
  var x = p.x;
  var y = p.y;
  var delta_x = x - this.x0;
  var delta_y = y - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n2 = 1; n2 <= 6; n2++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n2] * z_n_re - this.C_im[n2] * z_n_im;
    th_im = th_im + this.C_im[n2] * z_n_re + this.C_re[n2] * z_n_im;
  }
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n2 = 2; n2 <= 6; n2++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n2 - 1) * (this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im);
      num_im = num_im + (n2 - 1) * (this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n2 = 2; n2 <= 6; n2++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n2 * (this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im);
      den_im = den_im + n2 * (this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n2 = 1; n2 <= 9; n2++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n2] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p.x = lon;
  p.y = lat;
  return p;
}
var names21, nzmg_default;
var init_nzmg = __esm({
  "node_modules/proj4/lib/projections/nzmg.js"() {
    init_values();
    names21 = ["New_Zealand_Map_Grid", "nzmg"];
    nzmg_default = {
      init: init21,
      forward: forward19,
      inverse: inverse19,
      names: names21
    };
  }
});

// node_modules/proj4/lib/projections/mill.js
function init22() {
}
function forward20(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p.x = x;
  p.y = y;
  return p;
}
function inverse20(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon = adjust_lon_default(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
  p.x = lon;
  p.y = lat;
  return p;
}
var names22, mill_default;
var init_mill = __esm({
  "node_modules/proj4/lib/projections/mill.js"() {
    init_adjust_lon();
    names22 = ["Miller_Cylindrical", "mill"];
    mill_default = {
      init: init22,
      forward: forward20,
      inverse: inverse20,
      names: names22
    };
  }
});

// node_modules/proj4/lib/projections/sinu.js
function init23() {
  if (!this.sphere) {
    this.en = pj_enfn_default(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward21(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  lon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER4; i; --i) {
        var V2 = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V2;
        if (Math.abs(V2) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;
  } else {
    var s3 = Math.sin(lat);
    var c2 = Math.cos(lat);
    y = this.a * pj_mlfn_default(lat, s3, c2, this.en);
    x = this.a * lon * c2 / Math.sqrt(1 - this.es * s3 * s3);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse21(p) {
  var lat, temp, lon, s3;
  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz_default((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz_default(Math.sin(lat) / this.n);
    }
    lon = adjust_lon_default(lon + this.long0);
    lat = adjust_lat_default(lat);
  } else {
    lat = pj_inv_mlfn_default(p.y / this.a, this.es, this.en);
    s3 = Math.abs(lat);
    if (s3 < HALF_PI) {
      s3 = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s3 * s3) / (this.a * Math.cos(lat));
      lon = adjust_lon_default(temp);
    } else if (s3 - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var MAX_ITER4, names23, sinu_default;
var init_sinu = __esm({
  "node_modules/proj4/lib/projections/sinu.js"() {
    init_adjust_lon();
    init_adjust_lat();
    init_pj_enfn();
    init_pj_mlfn();
    init_pj_inv_mlfn();
    init_values();
    init_asinz();
    MAX_ITER4 = 20;
    names23 = ["Sinusoidal", "sinu"];
    sinu_default = {
      init: init23,
      forward: forward21,
      inverse: inverse21,
      names: names23
    };
  }
});

// node_modules/proj4/lib/projections/moll.js
function init24() {
}
function forward22(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse22(p) {
  var theta;
  var arg;
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon_default(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p.x = lon;
  p.y = lat;
  return p;
}
var names24, moll_default;
var init_moll = __esm({
  "node_modules/proj4/lib/projections/moll.js"() {
    init_adjust_lon();
    init_values();
    names24 = ["Mollweide", "moll"];
    moll_default = {
      init: init24,
      forward: forward22,
      inverse: inverse22,
      names: names24
    };
  }
});

// node_modules/proj4/lib/projections/eqdc.js
function init25() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.sin_phi = Math.sin(this.lat1);
  this.cos_phi = Math.cos(this.lat1);
  this.ms1 = msfnz_default(this.e, this.sin_phi, this.cos_phi);
  this.ml1 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sin_phi;
  } else {
    this.sin_phi = Math.sin(this.lat2);
    this.cos_phi = Math.cos(this.lat2);
    this.ms2 = msfnz_default(this.e, this.sin_phi, this.cos_phi);
    this.ml2 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward23(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn_default(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}
function inverse23(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    lat = adjust_lat_default(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn_default(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }
}
var names25, eqdc_default;
var init_eqdc = __esm({
  "node_modules/proj4/lib/projections/eqdc.js"() {
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_msfnz();
    init_mlfn();
    init_adjust_lon();
    init_adjust_lat();
    init_imlfn();
    init_values();
    names25 = ["Equidistant_Conic", "eqdc"];
    eqdc_default = {
      init: init25,
      forward: forward23,
      inverse: inverse23,
      names: names25
    };
  }
});

// node_modules/proj4/lib/projections/vandg.js
function init26() {
  this.R = this.a;
}
function forward24(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x, y;
  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz_default(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    y = this.y0 + con;
  } else {
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse24(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon_default(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names26, vandg_default;
var init_vandg = __esm({
  "node_modules/proj4/lib/projections/vandg.js"() {
    init_adjust_lon();
    init_values();
    init_asinz();
    names26 = ["Van_der_Grinten_I", "VanDerGrinten", "Van_der_Grinten", "vandg"];
    vandg_default = {
      init: init26,
      forward: forward24,
      inverse: inverse24,
      names: names26
    };
  }
});

// node_modules/proj4/lib/common/vincenty.js
function vincentyInverse(lat1, lon1, lat2, lon2, a, f) {
  const L = lon2 - lon1;
  const U1 = Math.atan((1 - f) * Math.tan(lat1));
  const U2 = Math.atan((1 - f) * Math.tan(lat2));
  const sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
  const sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);
  let lambda = L, lambdaP, iterLimit = 100;
  let sinLambda, cosLambda, sinSigma, cosSigma, sigma, sinAlpha, cos2Alpha, cos2SigmaM, C;
  let uSq, A5, B2, deltaSigma, s3;
  do {
    sinLambda = Math.sin(lambda);
    cosLambda = Math.cos(lambda);
    sinSigma = Math.sqrt(
      cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)
    );
    if (sinSigma === 0) {
      return { azi1: 0, s12: 0 };
    }
    cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
    sigma = Math.atan2(sinSigma, cosSigma);
    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
    cos2Alpha = 1 - sinAlpha * sinAlpha;
    cos2SigmaM = cos2Alpha !== 0 ? cosSigma - 2 * sinU1 * sinU2 / cos2Alpha : 0;
    C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
    lambdaP = lambda;
    lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return { azi1: NaN, s12: NaN };
  }
  uSq = cos2Alpha * (a * a - a * (1 - f) * (a * (1 - f))) / (a * (1 - f) * (a * (1 - f)));
  A5 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  B2 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  deltaSigma = B2 * sinSigma * (cos2SigmaM + B2 / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B2 / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
  s3 = a * (1 - f) * A5 * (sigma - deltaSigma);
  const azi1 = Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
  return { azi1, s12: s3 };
}
function vincentyDirect(lat1, lon1, azi1, s12, a, f) {
  const U1 = Math.atan((1 - f) * Math.tan(lat1));
  const sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
  const sinAlpha1 = Math.sin(azi1), cosAlpha1 = Math.cos(azi1);
  const sigma1 = Math.atan2(sinU1, cosU1 * cosAlpha1);
  const sinAlpha = cosU1 * sinAlpha1;
  const cos2Alpha = 1 - sinAlpha * sinAlpha;
  const uSq = cos2Alpha * (a * a - a * (1 - f) * (a * (1 - f))) / (a * (1 - f) * (a * (1 - f)));
  const A5 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  const B2 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  let sigma = s12 / (a * (1 - f) * A5), sigmaP, iterLimit = 100;
  let cos2SigmaM, sinSigma, cosSigma, deltaSigma;
  do {
    cos2SigmaM = Math.cos(2 * sigma1 + sigma);
    sinSigma = Math.sin(sigma);
    cosSigma = Math.cos(sigma);
    deltaSigma = B2 * sinSigma * (cos2SigmaM + B2 / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B2 / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
    sigmaP = sigma;
    sigma = s12 / (a * (1 - f) * A5) + deltaSigma;
  } while (Math.abs(sigma - sigmaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return { lat2: NaN, lon2: NaN };
  }
  const tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;
  const lat2 = Math.atan2(
    sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1,
    (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp)
  );
  const lambda = Math.atan2(
    sinSigma * sinAlpha1,
    cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1
  );
  const C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
  const L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  const lon2 = lon1 + L;
  return { lat2, lon2 };
}
var init_vincenty = __esm({
  "node_modules/proj4/lib/common/vincenty.js"() {
  }
});

// node_modules/proj4/lib/projections/aeqd.js
function init27() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
  this.f = this.es / (1 + Math.sqrt(1 - this.es));
}
function forward25(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon_default(lon - this.long0);
  var e0, e1, e22, e3, Mlp, Ml, c2, kp, cos_c, vars, azi1;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c2 = Math.acos(cos_c);
      kp = c2 ? c2 / Math.sin(c2) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e22 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e22, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e22, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e22, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e22, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    } else {
      if (Math.abs(lon) < EPSLN && Math.abs(lat - this.lat0) < EPSLN) {
        p.x = p.y = 0;
        return p;
      }
      vars = vincentyInverse(this.lat0, this.long0, lat, lon, this.a, this.f);
      azi1 = vars.azi1;
      p.x = vars.s12 * Math.sin(azi1);
      p.y = vars.s12 * Math.cos(azi1);
      return p;
    }
  }
}
function inverse25(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e22, e3, Mlp, M5, azi1, s12, vars;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z = rh / this.a;
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz_default(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -p.y));
        } else {
          lon = adjust_lon_default(this.long0 - Math.atan2(-p.x, p.y));
        }
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e22 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e22, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M5 = Mlp - rh;
      lat = imlfn_default(M5 / this.a, e0, e1, e22, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e22, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M5 = rh - Mlp;
      lat = imlfn_default(M5 / this.a, e0, e1, e22, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      azi1 = Math.atan2(p.x, p.y);
      s12 = Math.sqrt(p.x * p.x + p.y * p.y);
      vars = vincentyDirect(this.lat0, this.long0, azi1, s12, this.a, this.f);
      p.x = vars.lon2;
      p.y = vars.lat2;
      return p;
    }
  }
}
var names27, aeqd_default;
var init_aeqd = __esm({
  "node_modules/proj4/lib/projections/aeqd.js"() {
    init_adjust_lon();
    init_values();
    init_mlfn();
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_asinz();
    init_imlfn();
    init_vincenty();
    names27 = ["Azimuthal_Equidistant", "aeqd"];
    aeqd_default = {
      init: init27,
      forward: forward25,
      inverse: inverse25,
      names: names27
    };
  }
});

// node_modules/proj4/lib/projections/ortho.js
function init28() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward26(p) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse26(p) {
  var rh;
  var z;
  var sinz, cosz;
  var con;
  var lon, lat;
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = asinz_default(rh / this.a);
  sinz = Math.sin(z);
  cosz = Math.cos(z);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = asinz_default(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -p.y));
    } else {
      lon = adjust_lon_default(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = adjust_lon_default(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}
var names28, ortho_default;
var init_ortho = __esm({
  "node_modules/proj4/lib/projections/ortho.js"() {
    init_adjust_lon();
    init_asinz();
    init_values();
    names28 = ["ortho"];
    ortho_default = {
      init: init28,
      forward: forward26,
      inverse: inverse26,
      names: names28
    };
  }
});

// node_modules/proj4/lib/projections/qsc.js
function init29() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward27(p) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t2, mu;
  var area = { value: 0 };
  p.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }
  lon = p.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q, r3, s3;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r3 = coslat * sinlon;
    s3 = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s3, r3, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r3);
      theta = qsc_fwd_equat_face_theta(phi, s3, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s3, -r3, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r3);
      theta = qsc_fwd_equat_face_theta(phi, s3, q, area);
    } else {
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t2 = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t2 * Math.cos(mu);
  xy.y = t2 * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p.x = xy.x;
  p.y = xy.y;
  return p;
}
function inverse27(p) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t2;
  var area = { value: 0 };
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p.x < 0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t2 = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t2) / (Math.cos(t2) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q, r3, s3;
    q = cosphi;
    t2 = q * q;
    if (t2 >= 1) {
      s3 = 0;
    } else {
      s3 = Math.sqrt(1 - t2) * Math.sin(theta);
    }
    t2 += s3 * s3;
    if (t2 >= 1) {
      r3 = 0;
    } else {
      r3 = Math.sqrt(1 - t2);
    }
    if (area.value === AREA_ENUM.AREA_1) {
      t2 = r3;
      r3 = -s3;
      s3 = t2;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r3 = -r3;
      s3 = -s3;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t2 = r3;
      r3 = s3;
      s3 = -t2;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t2 = q;
      q = -r3;
      r3 = t2;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r3 = -r3;
    } else if (this.face === FACE_ENUM.LEFT) {
      t2 = q;
      q = r3;
      r3 = -t2;
    }
    lp.phi = Math.acos(-s3) - HALF_PI;
    lp.lam = Math.atan2(r3, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var FACE_ENUM, AREA_ENUM, names29, qsc_default;
var init_qsc = __esm({
  "node_modules/proj4/lib/projections/qsc.js"() {
    init_values();
    FACE_ENUM = {
      FRONT: 1,
      RIGHT: 2,
      BACK: 3,
      LEFT: 4,
      TOP: 5,
      BOTTOM: 6
    };
    AREA_ENUM = {
      AREA_0: 1,
      AREA_1: 2,
      AREA_2: 3,
      AREA_3: 4
    };
    names29 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
    qsc_default = {
      init: init29,
      forward: forward27,
      inverse: inverse27,
      names: names29
    };
  }
});

// node_modules/proj4/lib/projections/robin.js
function newton_rapshon(f_df, start2, max_err, iters) {
  var x = start2;
  for (; iters; --iters) {
    var upd = f_df(x);
    x -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x;
}
function init30() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward28(ll) {
  var lon = adjust_lon_default(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);
  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse28(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i = Math.floor(ll.y * NODES);
    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i];
    var t2 = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
    t2 = newton_rapshon(function(x) {
      return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
    }, t2, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i], t2);
    ll.y = (5 * i + t2) * D2R;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon_default(ll.x + this.long0);
  return ll;
}
var COEFS_X, COEFS_Y, FXC, FYC, C1, RC1, NODES, poly3_val, poly3_der, names30, robin_default;
var init_robin = __esm({
  "node_modules/proj4/lib/projections/robin.js"() {
    init_values();
    init_adjust_lon();
    COEFS_X = [
      [1, 22199e-21, -715515e-10, 31103e-10],
      [0.9986, -482243e-9, -24897e-9, -13309e-10],
      [0.9954, -83103e-8, -448605e-10, -986701e-12],
      [0.99, -135364e-8, -59661e-9, 36777e-10],
      [0.9822, -167442e-8, -449547e-11, -572411e-11],
      [0.973, -214868e-8, -903571e-10, 18736e-12],
      [0.96, -305085e-8, -900761e-10, 164917e-11],
      [0.9427, -382792e-8, -653386e-10, -26154e-10],
      [0.9216, -467746e-8, -10457e-8, 481243e-11],
      [0.8962, -536223e-8, -323831e-10, -543432e-11],
      [0.8679, -609363e-8, -113898e-9, 332484e-11],
      [0.835, -698325e-8, -640253e-10, 934959e-12],
      [0.7986, -755338e-8, -500009e-10, 935324e-12],
      [0.7597, -798324e-8, -35971e-9, -227626e-11],
      [0.7186, -851367e-8, -701149e-10, -86303e-10],
      [0.6732, -986209e-8, -199569e-9, 191974e-10],
      [0.6213, -0.010418, 883923e-10, 624051e-11],
      [0.5722, -906601e-8, 182e-6, 624051e-11],
      [0.5322, -677797e-8, 275608e-9, 624051e-11]
    ];
    COEFS_Y = [
      [-520417e-23, 0.0124, 121431e-23, -845284e-16],
      [0.062, 0.0124, -126793e-14, 422642e-15],
      [0.124, 0.0124, 507171e-14, -160604e-14],
      [0.186, 0.0123999, -190189e-13, 600152e-14],
      [0.248, 0.0124002, 710039e-13, -224e-10],
      [0.31, 0.0123992, -264997e-12, 835986e-13],
      [0.372, 0.0124029, 988983e-12, -311994e-12],
      [0.434, 0.0123893, -369093e-11, -435621e-12],
      [0.4958, 0.0123198, -102252e-10, -345523e-12],
      [0.5571, 0.0121916, -154081e-10, -582288e-12],
      [0.6176, 0.0119938, -241424e-10, -525327e-12],
      [0.6769, 0.011713, -320223e-10, -516405e-12],
      [0.7346, 0.0113541, -397684e-10, -609052e-12],
      [0.7903, 0.0109107, -489042e-10, -104739e-11],
      [0.8435, 0.0103431, -64615e-9, -140374e-14],
      [0.8936, 969686e-8, -64636e-9, -8547e-9],
      [0.9394, 840947e-8, -192841e-9, -42106e-10],
      [0.9761, 616527e-8, -256e-6, -42106e-10],
      [1, 328947e-8, -319159e-9, -42106e-10]
    ];
    FXC = 0.8487;
    FYC = 1.3523;
    C1 = R2D / 5;
    RC1 = 1 / C1;
    NODES = 18;
    poly3_val = function(coefs, x) {
      return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
    };
    poly3_der = function(coefs, x) {
      return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
    };
    names30 = ["Robinson", "robin"];
    robin_default = {
      init: init30,
      forward: forward28,
      inverse: inverse28,
      names: names30
    };
  }
});

// node_modules/proj4/lib/projections/geocent.js
function init31() {
  this.name = "geocent";
}
function forward29(p) {
  var point = geodeticToGeocentric(p, this.es, this.a);
  return point;
}
function inverse29(p) {
  var point = geocentricToGeodetic(p, this.es, this.a, this.b);
  return point;
}
var names31, geocent_default;
var init_geocent = __esm({
  "node_modules/proj4/lib/projections/geocent.js"() {
    init_datumUtils();
    names31 = ["Geocentric", "geocentric", "geocent", "Geocent"];
    geocent_default = {
      init: init31,
      forward: forward29,
      inverse: inverse29,
      names: names31
    };
  }
});

// node_modules/proj4/lib/projections/tpers.js
function init32() {
  Object.keys(params).forEach(function(p) {
    if (typeof this[p] === "undefined") {
      this[p] = params[p].def;
    } else if (params[p].num && isNaN(this[p])) {
      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
    } else if (params[p].num) {
      this[p] = parseFloat(this[p]);
    }
    if (params[p].degrees) {
      this[p] = this[p] * D2R;
    }
  }.bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward30(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;
  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y = cosphi * coslam;
      break;
    case mode.S_POLE:
      y = -sinphi;
      break;
    case mode.N_POLE:
      y = sinphi;
      break;
  }
  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y *= sinphi;
      break;
    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  }
  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;
  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}
function inverse30(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r3 = { x: p.x, y: p.y };
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;
  var rh = hypot_default(p.x, p.y);
  if (Math.abs(rh) < EPSLN) {
    r3.x = 0;
    r3.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r3.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r3.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r3.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;
      case mode.N_POLE:
        r3.y = Math.asin(cosz);
        p.y = -p.y;
        break;
      case mode.S_POLE:
        r3.y = -Math.asin(cosz);
        break;
    }
    r3.x = Math.atan2(p.x, p.y);
  }
  p.x = r3.x + this.long0;
  p.y = r3.y;
  return p;
}
var mode, params, names32, tpers_default;
var init_tpers = __esm({
  "node_modules/proj4/lib/projections/tpers.js"() {
    init_values();
    init_hypot();
    mode = {
      N_POLE: 0,
      S_POLE: 1,
      EQUIT: 2,
      OBLIQ: 3
    };
    params = {
      h: { def: 1e5, num: true },
      // default is Karman line, no default in PROJ.7
      azi: { def: 0, num: true, degrees: true },
      // default is North
      tilt: { def: 0, num: true, degrees: true },
      // default is Nadir
      long0: { def: 0, num: true },
      // default is Greenwich, conversion to rad is automatic
      lat0: { def: 0, num: true }
      // default is Equator, conversion to rad is automatic
    };
    names32 = ["Tilted_Perspective", "tpers"];
    tpers_default = {
      init: init32,
      forward: forward30,
      inverse: inverse30,
      names: names32
    };
  }
});

// node_modules/proj4/lib/projections/geos.js
function init33() {
  this.flip_axis = this.sweep === "x" ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;
  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }
  this.radius_g = 1 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1;
  if (this.es !== 0) {
    var one_es = 1 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = "ellipse";
  } else {
    this.radius_p = 1;
    this.radius_p2 = 1;
    this.radius_p_inv2 = 1;
    this.shape = "sphere";
  }
  if (!this.title) {
    this.title = "Geostationary Satellite View";
  }
}
function forward31(p) {
  var lon = p.x;
  var lat = p.y;
  var tmp, v_x, v_y, v_z;
  lon = lon - this.long0;
  if (this.shape === "ellipse") {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r3 = this.radius_p / hypot_default(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r3 * Math.cos(lon) * Math.cos(lat);
    v_y = r3 * Math.sin(lon) * Math.cos(lat);
    v_z = r3 * Math.sin(lat);
    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  } else if (this.shape === "sphere") {
    tmp = Math.cos(lat);
    v_x = Math.cos(lon) * tmp;
    v_y = Math.sin(lon) * tmp;
    v_z = Math.sin(lat);
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  }
  p.x = p.x * this.a;
  p.y = p.y * this.a;
  return p;
}
function inverse31(p) {
  var v_x = -1;
  var v_y = 0;
  var v_z = 0;
  var a, b, det, k;
  p.x = p.x / this.a;
  p.y = p.y / this.a;
  if (this.shape === "ellipse") {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * hypot_default(1, v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * hypot_default(1, v_y);
    }
    var v_zp = v_z / this.radius_p;
    a = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
    p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
    }
    a = v_y * v_y + v_z * v_z + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
  }
  p.x = p.x + this.long0;
  return p;
}
var names33, geos_default;
var init_geos = __esm({
  "node_modules/proj4/lib/projections/geos.js"() {
    init_hypot();
    names33 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
    geos_default = {
      init: init33,
      forward: forward31,
      inverse: inverse31,
      names: names33
    };
  }
});

// node_modules/proj4/lib/projections/eqearth.js
function init34() {
  this.es = 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function forward32(p) {
  var lam = adjust_lon_default(p.x - this.long0);
  var phi = p.y;
  var paramLat = Math.asin(M * Math.sin(phi)), paramLatSq = paramLat * paramLat, paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p.x = lam * Math.cos(paramLat) / (M * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)));
  p.y = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq));
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function inverse32(p) {
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  var EPS = 1e-9, NITER = 12, paramLat = p.y, paramLatSq, paramLatPow6, fy, fpy, dlat, i;
  for (i = 0; i < NITER; ++i) {
    paramLatSq = paramLat * paramLat;
    paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
    fy = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq)) - p.y;
    fpy = A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq);
    paramLat -= dlat = fy / fpy;
    if (Math.abs(dlat) < EPS) {
      break;
    }
  }
  paramLatSq = paramLat * paramLat;
  paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p.x = M * p.x * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)) / Math.cos(paramLat);
  p.y = Math.asin(Math.sin(paramLat) / M);
  p.x = adjust_lon_default(p.x + this.long0);
  return p;
}
var A1, A2, A3, A4, M, names34, eqearth_default;
var init_eqearth = __esm({
  "node_modules/proj4/lib/projections/eqearth.js"() {
    init_adjust_lon();
    A1 = 1.340264;
    A2 = -0.081106;
    A3 = 893e-6;
    A4 = 3796e-6;
    M = Math.sqrt(3) / 2;
    names34 = ["eqearth", "Equal Earth", "Equal_Earth"];
    eqearth_default = {
      init: init34,
      forward: forward32,
      inverse: inverse32,
      names: names34
    };
  }
});

// node_modules/proj4/lib/projections/bonne.js
function init35() {
  var c2;
  this.phi1 = this.lat1;
  if (Math.abs(this.phi1) < EPS10) {
    throw new Error();
  }
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.m1 = pj_mlfn_default(
      this.phi1,
      this.am1 = Math.sin(this.phi1),
      c2 = Math.cos(this.phi1),
      this.en
    );
    this.am1 = c2 / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1);
    this.inverse = e_inv;
    this.forward = e_fwd;
  } else {
    if (Math.abs(this.phi1) + EPS10 >= HALF_PI) {
      this.cphi1 = 0;
    } else {
      this.cphi1 = 1 / Math.tan(this.phi1);
    }
    this.inverse = s_inv;
    this.forward = s_fwd;
  }
}
function e_fwd(p) {
  var lam = adjust_lon_default(p.x - (this.long0 || 0));
  var phi = p.y;
  var rh, E4, c2;
  rh = this.am1 + this.m1 - pj_mlfn_default(phi, E4 = Math.sin(phi), c2 = Math.cos(phi), this.en);
  E4 = c2 * lam / (rh * Math.sqrt(1 - this.es * E4 * E4));
  p.x = rh * Math.sin(E4);
  p.y = this.am1 - rh * Math.cos(E4);
  p.x = this.a * p.x + (this.x0 || 0);
  p.y = this.a * p.y + (this.y0 || 0);
  return p;
}
function e_inv(p) {
  p.x = (p.x - (this.x0 || 0)) / this.a;
  p.y = (p.y - (this.y0 || 0)) / this.a;
  var s3, rh, lam, phi;
  rh = hypot_default(p.x, p.y = this.am1 - p.y);
  phi = pj_inv_mlfn_default(this.am1 + this.m1 - rh, this.es, this.en);
  if ((s3 = Math.abs(phi)) < HALF_PI) {
    s3 = Math.sin(phi);
    lam = rh * Math.atan2(p.x, p.y) * Math.sqrt(1 - this.es * s3 * s3) / Math.cos(phi);
  } else if (Math.abs(s3 - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    throw new Error();
  }
  p.x = adjust_lon_default(lam + (this.long0 || 0));
  p.y = adjust_lat_default(phi);
  return p;
}
function s_fwd(p) {
  var lam = adjust_lon_default(p.x - (this.long0 || 0));
  var phi = p.y;
  var E4, rh;
  rh = this.cphi1 + this.phi1 - phi;
  if (Math.abs(rh) > EPS10) {
    p.x = rh * Math.sin(E4 = lam * Math.cos(phi) / rh);
    p.y = this.cphi1 - rh * Math.cos(E4);
  } else {
    p.x = p.y = 0;
  }
  p.x = this.a * p.x + (this.x0 || 0);
  p.y = this.a * p.y + (this.y0 || 0);
  return p;
}
function s_inv(p) {
  p.x = (p.x - (this.x0 || 0)) / this.a;
  p.y = (p.y - (this.y0 || 0)) / this.a;
  var lam, phi;
  var rh = hypot_default(p.x, p.y = this.cphi1 - p.y);
  phi = this.cphi1 + this.phi1 - rh;
  if (Math.abs(phi) > HALF_PI) {
    throw new Error();
  }
  if (Math.abs(Math.abs(phi) - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    lam = rh * Math.atan2(p.x, p.y) / Math.cos(phi);
  }
  p.x = adjust_lon_default(lam + (this.long0 || 0));
  p.y = adjust_lat_default(phi);
  return p;
}
var EPS10, names35, bonne_default;
var init_bonne = __esm({
  "node_modules/proj4/lib/projections/bonne.js"() {
    init_adjust_lat();
    init_adjust_lon();
    init_hypot();
    init_pj_enfn();
    init_pj_inv_mlfn();
    init_pj_mlfn();
    init_values();
    EPS10 = 1e-10;
    names35 = ["bonne", "Bonne (Werner lat_1=90)"];
    bonne_default = {
      init: init35,
      names: names35
    };
  }
});

// node_modules/proj4/projs.js
function projs_default(proj43) {
  proj43.Proj.projections.add(tmerc_default);
  proj43.Proj.projections.add(etmerc_default);
  proj43.Proj.projections.add(utm_default);
  proj43.Proj.projections.add(sterea_default);
  proj43.Proj.projections.add(stere_default);
  proj43.Proj.projections.add(somerc_default);
  proj43.Proj.projections.add(omerc_default);
  proj43.Proj.projections.add(lcc_default);
  proj43.Proj.projections.add(krovak_default);
  proj43.Proj.projections.add(cass_default);
  proj43.Proj.projections.add(laea_default);
  proj43.Proj.projections.add(aea_default);
  proj43.Proj.projections.add(gnom_default);
  proj43.Proj.projections.add(cea_default);
  proj43.Proj.projections.add(eqc_default);
  proj43.Proj.projections.add(poly_default);
  proj43.Proj.projections.add(nzmg_default);
  proj43.Proj.projections.add(mill_default);
  proj43.Proj.projections.add(sinu_default);
  proj43.Proj.projections.add(moll_default);
  proj43.Proj.projections.add(eqdc_default);
  proj43.Proj.projections.add(vandg_default);
  proj43.Proj.projections.add(aeqd_default);
  proj43.Proj.projections.add(ortho_default);
  proj43.Proj.projections.add(qsc_default);
  proj43.Proj.projections.add(robin_default);
  proj43.Proj.projections.add(geocent_default);
  proj43.Proj.projections.add(tpers_default);
  proj43.Proj.projections.add(geos_default);
  proj43.Proj.projections.add(eqearth_default);
  proj43.Proj.projections.add(bonne_default);
}
var init_projs = __esm({
  "node_modules/proj4/projs.js"() {
    init_tmerc();
    init_etmerc();
    init_utm2();
    init_sterea();
    init_stere();
    init_somerc();
    init_omerc();
    init_lcc();
    init_krovak();
    init_cass();
    init_laea();
    init_aea();
    init_gnom();
    init_cea();
    init_eqc();
    init_poly();
    init_nzmg();
    init_mill();
    init_sinu();
    init_moll();
    init_eqdc();
    init_vandg();
    init_aeqd();
    init_ortho();
    init_qsc();
    init_robin();
    init_geocent();
    init_tpers();
    init_geos();
    init_eqearth();
    init_bonne();
  }
});

// node_modules/proj4/lib/index.js
var proj42, lib_default;
var init_lib = __esm({
  "node_modules/proj4/lib/index.js"() {
    init_core();
    init_Proj();
    init_Point2();
    init_toPoint();
    init_defs();
    init_nadgrid();
    init_transform3();
    init_mgrs();
    init_projs();
    proj42 = Object.assign(core_default, {
      defaultDatum: "WGS84",
      Proj: Proj_default,
      WGS84: new Proj_default("WGS84"),
      Point: Point_default2,
      toPoint: toPoint_default,
      defs: defs_default,
      nadgrid,
      transform: transform2,
      mgrs: mgrs_default,
      version: "__VERSION__"
    });
    projs_default(proj42);
    lib_default = proj42;
  }
});

// node_modules/@allmaps/project/dist/shared/project-functions.js
var lonLatEquivalentDefinitions, webMercatorEquivalentDefinitions, lonLatProjection, webMercatorProjection, defaultProjectedGcpTransformerOptions, defaultProjectedGcpTransformOptions, lonLatProjectionToWebMecatorProjectionConverter, lonLatToWebMercator, webMercatorToLonLat;
var init_project_functions = __esm({
  "node_modules/@allmaps/project/dist/shared/project-functions.js"() {
    init_lib();
    init_dist2();
    lonLatEquivalentDefinitions = [
      "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees",
      "+proj=longlat +datum=WGS84 +no_defs +type=crs",
      "EPSG:4326",
      "WGS84"
    ];
    webMercatorEquivalentDefinitions = [
      "+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs +type=crs",
      "EPSG:3857",
      "EPSG:3785",
      "GOOGLE",
      "EPSG:900913",
      "EPSG:102113"
    ];
    lonLatProjection = {
      name: "EPSG:4326",
      definition: lonLatEquivalentDefinitions[0]
    };
    webMercatorProjection = {
      name: "EPSG:3857",
      definition: webMercatorEquivalentDefinitions[0]
    };
    defaultProjectedGcpTransformerOptions = {
      internalProjection: webMercatorProjection,
      projection: webMercatorProjection,
      ...defaultGcpTransformerOptions
    };
    defaultProjectedGcpTransformOptions = {
      projection: webMercatorProjection,
      ...defaultGcpTransformerOptions
    };
    lonLatProjectionToWebMecatorProjectionConverter = lib_default(lonLatProjection.definition, webMercatorProjection.definition);
    lonLatToWebMercator = lonLatProjectionToWebMecatorProjectionConverter.forward;
    webMercatorToLonLat = lonLatProjectionToWebMecatorProjectionConverter.inverse;
  }
});

// node_modules/@allmaps/project/dist/projected-transformers/ProjectedGcpTransformer.js
var init_ProjectedGcpTransformer = __esm({
  "node_modules/@allmaps/project/dist/projected-transformers/ProjectedGcpTransformer.js"() {
    init_lib();
    init_dist();
    init_dist2();
    init_project_functions();
  }
});

// node_modules/@allmaps/project/dist/index.js
var init_dist6 = __esm({
  "node_modules/@allmaps/project/dist/index.js"() {
    init_lib();
    init_ProjectedGcpTransformer();
    init_project_functions();
  }
});

// node_modules/quickselect/index.js
var init_quickselect = __esm({
  "node_modules/quickselect/index.js"() {
  }
});

// node_modules/rbush/index.js
var init_rbush = __esm({
  "node_modules/rbush/index.js"() {
    init_quickselect();
  }
});

// node_modules/robust-predicates/esm/util.js
function sum(elen, e3, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e3[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e3[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e3[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e3[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e3[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function sum_three(alen, a, blen, b, clen, c2, tmp, out) {
  return sum(sum(alen, a, blen, b, tmp), tmp, clen, c2, out);
}
function scale2(elen, e3, b, h) {
  let Q, sum2, hh, product1, product0;
  let bvirt, c2, ahi, alo, bhi, blo;
  c2 = splitter * b;
  bhi = c2 - (c2 - b);
  blo = b - bhi;
  let enow = e3[0];
  Q = enow * b;
  c2 = splitter * enow;
  ahi = c2 - (c2 - enow);
  alo = enow - ahi;
  hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);
  let hindex = 0;
  if (hh !== 0) {
    h[hindex++] = hh;
  }
  for (let i = 1; i < elen; i++) {
    enow = e3[i];
    product1 = enow * b;
    c2 = splitter * enow;
    ahi = c2 - (c2 - enow);
    alo = enow - ahi;
    product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);
    sum2 = Q + product0;
    bvirt = sum2 - Q;
    hh = Q - (sum2 - bvirt) + (product0 - bvirt);
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    Q = product1 + sum2;
    hh = sum2 - (Q - product1);
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e3) {
  let Q = e3[0];
  for (let i = 1; i < elen; i++) Q += e3[i];
  return Q;
}
function vec(n2) {
  return new Float64Array(n2);
}
var epsilon, splitter, resulterrbound;
var init_util4 = __esm({
  "node_modules/robust-predicates/esm/util.js"() {
    epsilon = 11102230246251565e-32;
    splitter = 134217729;
    resulterrbound = (3 + 8 * epsilon) * epsilon;
  }
});

// node_modules/robust-predicates/esm/orient2d.js
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c2, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c2 = splitter * acx;
  ahi = c2 - (c2 - acx);
  alo = acx - ahi;
  c2 = splitter * bcy;
  bhi = c2 - (c2 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c2 = splitter * acy;
  ahi = c2 - (c2 - acy);
  alo = acy - ahi;
  c2 = splitter * bcx;
  bhi = c2 - (c2 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B[3] = u32;
  let det = estimate(4, B);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c2 = splitter * acxtail;
  ahi = c2 - (c2 - acxtail);
  alo = acxtail - ahi;
  c2 = splitter * bcy;
  bhi = c2 - (c2 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c2 = splitter * acytail;
  ahi = c2 - (c2 - acytail);
  alo = acytail - ahi;
  c2 = splitter * bcx;
  bhi = c2 - (c2 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum(4, B, 4, u, C12);
  s1 = acx * bcytail;
  c2 = splitter * acx;
  ahi = c2 - (c2 - acx);
  alo = acx - ahi;
  c2 = splitter * bcytail;
  bhi = c2 - (c2 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c2 = splitter * acy;
  ahi = c2 - (c2 - acy);
  alo = acy - ahi;
  c2 = splitter * bcxtail;
  bhi = c2 - (c2 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum(C1len, C12, 4, u, C2);
  s1 = acxtail * bcytail;
  c2 = splitter * acxtail;
  ahi = c2 - (c2 - acxtail);
  alo = acxtail - ahi;
  c2 = splitter * bcytail;
  bhi = c2 - (c2 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c2 = splitter * acytail;
  ahi = c2 - (c2 - acytail);
  alo = acytail - ahi;
  c2 = splitter * bcxtail;
  bhi = c2 - (c2 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
var ccwerrboundA, ccwerrboundB, ccwerrboundC, B, C12, C2, D, u;
var init_orient2d = __esm({
  "node_modules/robust-predicates/esm/orient2d.js"() {
    init_util4();
    ccwerrboundA = (3 + 16 * epsilon) * epsilon;
    ccwerrboundB = (2 + 12 * epsilon) * epsilon;
    ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
    B = vec(4);
    C12 = vec(8);
    C2 = vec(12);
    D = vec(16);
    u = vec(4);
  }
});

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA, o3derrboundB, o3derrboundC, bc, ca, ab, at_b, at_c, bt_c, bt_a, ct_a, ct_b, bct, cat, abt, u2, _8, _8b, _16, _12, fin, fin2;
var init_orient3d = __esm({
  "node_modules/robust-predicates/esm/orient3d.js"() {
    init_util4();
    o3derrboundA = (7 + 56 * epsilon) * epsilon;
    o3derrboundB = (3 + 28 * epsilon) * epsilon;
    o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
    bc = vec(4);
    ca = vec(4);
    ab = vec(4);
    at_b = vec(4);
    at_c = vec(4);
    bt_c = vec(4);
    bt_a = vec(4);
    ct_a = vec(4);
    ct_b = vec(4);
    bct = vec(8);
    cat = vec(8);
    abt = vec(8);
    u2 = vec(4);
    _8 = vec(8);
    _8b = vec(8);
    _16 = vec(8);
    _12 = vec(12);
    fin = vec(192);
    fin2 = vec(192);
  }
});

// node_modules/robust-predicates/esm/incircle.js
function finadd(finlen, a, alen) {
  finlen = sum(finlen, fin3, a, alen, fin22);
  const tmp = fin3;
  fin3 = fin22;
  fin22 = tmp;
  return finlen;
}
function incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {
  let finlen;
  let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;
  let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;
  let abtlen, bctlen, catlen;
  let abttlen, bcttlen, cattlen;
  let n1, n0;
  let bvirt, c2, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  s1 = bdx * cdy;
  c2 = splitter * bdx;
  ahi = c2 - (c2 - bdx);
  alo = bdx - ahi;
  c2 = splitter * cdy;
  bhi = c2 - (c2 - cdy);
  blo = cdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cdx * bdy;
  c2 = splitter * cdx;
  ahi = c2 - (c2 - cdx);
  alo = cdx - ahi;
  c2 = splitter * bdy;
  bhi = c2 - (c2 - bdy);
  blo = bdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bc2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bc2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  bc2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  bc2[3] = u32;
  s1 = cdx * ady;
  c2 = splitter * cdx;
  ahi = c2 - (c2 - cdx);
  alo = cdx - ahi;
  c2 = splitter * ady;
  bhi = c2 - (c2 - ady);
  blo = ady - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = adx * cdy;
  c2 = splitter * adx;
  ahi = c2 - (c2 - adx);
  alo = adx - ahi;
  c2 = splitter * cdy;
  bhi = c2 - (c2 - cdy);
  blo = cdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ca2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ca2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  ca2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  ca2[3] = u32;
  s1 = adx * bdy;
  c2 = splitter * adx;
  ahi = c2 - (c2 - adx);
  alo = adx - ahi;
  c2 = splitter * bdy;
  bhi = c2 - (c2 - bdy);
  blo = bdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = bdx * ady;
  c2 = splitter * bdx;
  ahi = c2 - (c2 - bdx);
  alo = bdx - ahi;
  c2 = splitter * ady;
  bhi = c2 - (c2 - ady);
  blo = ady - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ab2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ab2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  ab2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  ab2[3] = u32;
  finlen = sum(
    sum(
      sum(
        scale2(scale2(4, bc2, adx, _82), _82, adx, _162),
        _162,
        scale2(scale2(4, bc2, ady, _82), _82, ady, _16b),
        _16b,
        _32
      ),
      _32,
      sum(
        scale2(scale2(4, ca2, bdx, _82), _82, bdx, _162),
        _162,
        scale2(scale2(4, ca2, bdy, _82), _82, bdy, _16b),
        _16b,
        _32b
      ),
      _32b,
      _64
    ),
    _64,
    sum(
      scale2(scale2(4, ab2, cdx, _82), _82, cdx, _162),
      _162,
      scale2(scale2(4, ab2, cdy, _82), _82, cdy, _16b),
      _16b,
      _32
    ),
    _32,
    fin3
  );
  let det = estimate(finlen, fin3);
  let errbound = iccerrboundB * permanent;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - adx;
  adxtail = ax - (adx + bvirt) + (bvirt - dx);
  bvirt = ay - ady;
  adytail = ay - (ady + bvirt) + (bvirt - dy);
  bvirt = bx - bdx;
  bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
  bvirt = by - bdy;
  bdytail = by - (bdy + bvirt) + (bvirt - dy);
  bvirt = cx - cdx;
  cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
  bvirt = cy - cdy;
  cdytail = cy - (cdy + bvirt) + (bvirt - dy);
  if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) {
    return det;
  }
  errbound = iccerrboundC * permanent + resulterrbound * Math.abs(det);
  det += (adx * adx + ady * ady) * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + 2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx) + ((bdx * bdx + bdy * bdy) * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + 2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) + ((cdx * cdx + cdy * cdy) * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + 2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
    s1 = adx * adx;
    c2 = splitter * adx;
    ahi = c2 - (c2 - adx);
    alo = adx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = ady * ady;
    c2 = splitter * ady;
    ahi = c2 - (c2 - ady);
    alo = ady - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    aa[2] = _j - (u32 - bvirt) + (_i - bvirt);
    aa[3] = u32;
  }
  if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
    s1 = bdx * bdx;
    c2 = splitter * bdx;
    ahi = c2 - (c2 - bdx);
    alo = bdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = bdy * bdy;
    c2 = splitter * bdy;
    ahi = c2 - (c2 - bdy);
    alo = bdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    bb[2] = _j - (u32 - bvirt) + (_i - bvirt);
    bb[3] = u32;
  }
  if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
    s1 = cdx * cdx;
    c2 = splitter * cdx;
    ahi = c2 - (c2 - cdx);
    alo = cdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = cdy * cdy;
    c2 = splitter * cdy;
    ahi = c2 - (c2 - cdy);
    alo = cdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u32 = _j + _i;
    bvirt = u32 - _j;
    cc[2] = _j - (u32 - bvirt) + (_i - bvirt);
    cc[3] = u32;
  }
  if (adxtail !== 0) {
    axtbclen = scale2(4, bc2, adxtail, axtbc);
    finlen = finadd(finlen, sum_three(
      scale2(axtbclen, axtbc, 2 * adx, _162),
      _162,
      scale2(scale2(4, cc, adxtail, _82), _82, bdy, _16b),
      _16b,
      scale2(scale2(4, bb, adxtail, _82), _82, -cdy, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (adytail !== 0) {
    aytbclen = scale2(4, bc2, adytail, aytbc);
    finlen = finadd(finlen, sum_three(
      scale2(aytbclen, aytbc, 2 * ady, _162),
      _162,
      scale2(scale2(4, bb, adytail, _82), _82, cdx, _16b),
      _16b,
      scale2(scale2(4, cc, adytail, _82), _82, -bdx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (bdxtail !== 0) {
    bxtcalen = scale2(4, ca2, bdxtail, bxtca);
    finlen = finadd(finlen, sum_three(
      scale2(bxtcalen, bxtca, 2 * bdx, _162),
      _162,
      scale2(scale2(4, aa, bdxtail, _82), _82, cdy, _16b),
      _16b,
      scale2(scale2(4, cc, bdxtail, _82), _82, -ady, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (bdytail !== 0) {
    bytcalen = scale2(4, ca2, bdytail, bytca);
    finlen = finadd(finlen, sum_three(
      scale2(bytcalen, bytca, 2 * bdy, _162),
      _162,
      scale2(scale2(4, cc, bdytail, _82), _82, adx, _16b),
      _16b,
      scale2(scale2(4, aa, bdytail, _82), _82, -cdx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (cdxtail !== 0) {
    cxtablen = scale2(4, ab2, cdxtail, cxtab);
    finlen = finadd(finlen, sum_three(
      scale2(cxtablen, cxtab, 2 * cdx, _162),
      _162,
      scale2(scale2(4, bb, cdxtail, _82), _82, ady, _16b),
      _16b,
      scale2(scale2(4, aa, cdxtail, _82), _82, -bdy, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (cdytail !== 0) {
    cytablen = scale2(4, ab2, cdytail, cytab);
    finlen = finadd(finlen, sum_three(
      scale2(cytablen, cytab, 2 * cdy, _162),
      _162,
      scale2(scale2(4, aa, cdytail, _82), _82, bdx, _16b),
      _16b,
      scale2(scale2(4, bb, cdytail, _82), _82, -adx, _16c),
      _16c,
      _32,
      _48
    ), _48);
  }
  if (adxtail !== 0 || adytail !== 0) {
    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
      s1 = bdxtail * cdy;
      c2 = splitter * bdxtail;
      ahi = c2 - (c2 - bdxtail);
      alo = bdxtail - ahi;
      c2 = splitter * cdy;
      bhi = c2 - (c2 - cdy);
      blo = cdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * cdytail;
      c2 = splitter * bdx;
      ahi = c2 - (c2 - bdx);
      alo = bdx - ahi;
      c2 = splitter * cdytail;
      bhi = c2 - (c2 - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u3[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u3[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u3[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u3[3] = u32;
      s1 = cdxtail * -bdy;
      c2 = splitter * cdxtail;
      ahi = c2 - (c2 - cdxtail);
      alo = cdxtail - ahi;
      c2 = splitter * -bdy;
      bhi = c2 - (c2 - -bdy);
      blo = -bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * -bdytail;
      c2 = splitter * cdx;
      ahi = c2 - (c2 - cdx);
      alo = cdx - ahi;
      c2 = splitter * -bdytail;
      bhi = c2 - (c2 - -bdytail);
      blo = -bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v[3] = u32;
      bctlen = sum(4, u3, 4, v, bct2);
      s1 = bdxtail * cdytail;
      c2 = splitter * bdxtail;
      ahi = c2 - (c2 - bdxtail);
      alo = bdxtail - ahi;
      c2 = splitter * cdytail;
      bhi = c2 - (c2 - cdytail);
      blo = cdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdxtail * bdytail;
      c2 = splitter * cdxtail;
      ahi = c2 - (c2 - cdxtail);
      alo = cdxtail - ahi;
      c2 = splitter * bdytail;
      bhi = c2 - (c2 - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      bctt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      bctt[3] = u32;
      bcttlen = 4;
    } else {
      bct2[0] = 0;
      bctlen = 1;
      bctt[0] = 0;
      bcttlen = 1;
    }
    if (adxtail !== 0) {
      const len = scale2(bctlen, bct2, adxtail, _16c);
      finlen = finadd(finlen, sum(
        scale2(axtbclen, axtbc, adxtail, _162),
        _162,
        scale2(len, _16c, 2 * adx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(bcttlen, bctt, adxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * adx, _162),
        _162,
        scale2(len2, _82, adxtail, _16b),
        _16b,
        scale2(len, _16c, adxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (bdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, cc, adxtail, _82), _82, bdytail, _162), _162);
      }
      if (cdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, bb, -adxtail, _82), _82, cdytail, _162), _162);
      }
    }
    if (adytail !== 0) {
      const len = scale2(bctlen, bct2, adytail, _16c);
      finlen = finadd(finlen, sum(
        scale2(aytbclen, aytbc, adytail, _162),
        _162,
        scale2(len, _16c, 2 * ady, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(bcttlen, bctt, adytail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * ady, _162),
        _162,
        scale2(len2, _82, adytail, _16b),
        _16b,
        scale2(len, _16c, adytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  if (bdxtail !== 0 || bdytail !== 0) {
    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
      s1 = cdxtail * ady;
      c2 = splitter * cdxtail;
      ahi = c2 - (c2 - cdxtail);
      alo = cdxtail - ahi;
      c2 = splitter * ady;
      bhi = c2 - (c2 - ady);
      blo = ady - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * adytail;
      c2 = splitter * cdx;
      ahi = c2 - (c2 - cdx);
      alo = cdx - ahi;
      c2 = splitter * adytail;
      bhi = c2 - (c2 - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u3[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u3[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u3[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u3[3] = u32;
      n1 = -cdy;
      n0 = -cdytail;
      s1 = adxtail * n1;
      c2 = splitter * adxtail;
      ahi = c2 - (c2 - adxtail);
      alo = adxtail - ahi;
      c2 = splitter * n1;
      bhi = c2 - (c2 - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * n0;
      c2 = splitter * adx;
      ahi = c2 - (c2 - adx);
      alo = adx - ahi;
      c2 = splitter * n0;
      bhi = c2 - (c2 - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v[3] = u32;
      catlen = sum(4, u3, 4, v, cat2);
      s1 = cdxtail * adytail;
      c2 = splitter * cdxtail;
      ahi = c2 - (c2 - cdxtail);
      alo = cdxtail - ahi;
      c2 = splitter * adytail;
      bhi = c2 - (c2 - adytail);
      blo = adytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adxtail * cdytail;
      c2 = splitter * adxtail;
      ahi = c2 - (c2 - adxtail);
      alo = adxtail - ahi;
      c2 = splitter * cdytail;
      bhi = c2 - (c2 - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      catt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      catt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      catt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      catt[3] = u32;
      cattlen = 4;
    } else {
      cat2[0] = 0;
      catlen = 1;
      catt[0] = 0;
      cattlen = 1;
    }
    if (bdxtail !== 0) {
      const len = scale2(catlen, cat2, bdxtail, _16c);
      finlen = finadd(finlen, sum(
        scale2(bxtcalen, bxtca, bdxtail, _162),
        _162,
        scale2(len, _16c, 2 * bdx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(cattlen, catt, bdxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * bdx, _162),
        _162,
        scale2(len2, _82, bdxtail, _16b),
        _16b,
        scale2(len, _16c, bdxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (cdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, aa, bdxtail, _82), _82, cdytail, _162), _162);
      }
      if (adytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, cc, -bdxtail, _82), _82, adytail, _162), _162);
      }
    }
    if (bdytail !== 0) {
      const len = scale2(catlen, cat2, bdytail, _16c);
      finlen = finadd(finlen, sum(
        scale2(bytcalen, bytca, bdytail, _162),
        _162,
        scale2(len, _16c, 2 * bdy, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(cattlen, catt, bdytail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * bdy, _162),
        _162,
        scale2(len2, _82, bdytail, _16b),
        _16b,
        scale2(len, _16c, bdytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  if (cdxtail !== 0 || cdytail !== 0) {
    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
      s1 = adxtail * bdy;
      c2 = splitter * adxtail;
      ahi = c2 - (c2 - adxtail);
      alo = adxtail - ahi;
      c2 = splitter * bdy;
      bhi = c2 - (c2 - bdy);
      blo = bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * bdytail;
      c2 = splitter * adx;
      ahi = c2 - (c2 - adx);
      alo = adx - ahi;
      c2 = splitter * bdytail;
      bhi = c2 - (c2 - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u3[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u3[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      u3[2] = _j - (u32 - bvirt) + (_i - bvirt);
      u3[3] = u32;
      n1 = -ady;
      n0 = -adytail;
      s1 = bdxtail * n1;
      c2 = splitter * bdxtail;
      ahi = c2 - (c2 - bdxtail);
      alo = bdxtail - ahi;
      c2 = splitter * n1;
      bhi = c2 - (c2 - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * n0;
      c2 = splitter * bdx;
      ahi = c2 - (c2 - bdx);
      alo = bdx - ahi;
      c2 = splitter * n0;
      bhi = c2 - (c2 - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u32 = _j + _i;
      bvirt = u32 - _j;
      v[2] = _j - (u32 - bvirt) + (_i - bvirt);
      v[3] = u32;
      abtlen = sum(4, u3, 4, v, abt2);
      s1 = adxtail * bdytail;
      c2 = splitter * adxtail;
      ahi = c2 - (c2 - adxtail);
      alo = adxtail - ahi;
      c2 = splitter * bdytail;
      bhi = c2 - (c2 - bdytail);
      blo = bdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdxtail * adytail;
      c2 = splitter * bdxtail;
      ahi = c2 - (c2 - bdxtail);
      alo = bdxtail - ahi;
      c2 = splitter * adytail;
      bhi = c2 - (c2 - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u32 = _j + _i;
      bvirt = u32 - _j;
      abtt[2] = _j - (u32 - bvirt) + (_i - bvirt);
      abtt[3] = u32;
      abttlen = 4;
    } else {
      abt2[0] = 0;
      abtlen = 1;
      abtt[0] = 0;
      abttlen = 1;
    }
    if (cdxtail !== 0) {
      const len = scale2(abtlen, abt2, cdxtail, _16c);
      finlen = finadd(finlen, sum(
        scale2(cxtablen, cxtab, cdxtail, _162),
        _162,
        scale2(len, _16c, 2 * cdx, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(abttlen, abtt, cdxtail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * cdx, _162),
        _162,
        scale2(len2, _82, cdxtail, _16b),
        _16b,
        scale2(len, _16c, cdxtail, _32),
        _32,
        _32b,
        _64
      ), _64);
      if (adytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, bb, cdxtail, _82), _82, adytail, _162), _162);
      }
      if (bdytail !== 0) {
        finlen = finadd(finlen, scale2(scale2(4, aa, -cdxtail, _82), _82, bdytail, _162), _162);
      }
    }
    if (cdytail !== 0) {
      const len = scale2(abtlen, abt2, cdytail, _16c);
      finlen = finadd(finlen, sum(
        scale2(cytablen, cytab, cdytail, _162),
        _162,
        scale2(len, _16c, 2 * cdy, _32),
        _32,
        _48
      ), _48);
      const len2 = scale2(abttlen, abtt, cdytail, _82);
      finlen = finadd(finlen, sum_three(
        scale2(len2, _82, 2 * cdy, _162),
        _162,
        scale2(len2, _82, cdytail, _16b),
        _16b,
        scale2(len, _16c, cdytail, _32),
        _32,
        _32b,
        _64
      ), _64);
    }
  }
  return fin3[finlen - 1];
}
function incircle(ax, ay, bx, by, cx, cy, dx, dy) {
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  const bdxcdy = bdx * cdy;
  const cdxbdy = cdx * bdy;
  const alift = adx * adx + ady * ady;
  const cdxady = cdx * ady;
  const adxcdy = adx * cdy;
  const blift = bdx * bdx + bdy * bdy;
  const adxbdy = adx * bdy;
  const bdxady = bdx * ady;
  const clift = cdx * cdx + cdy * cdy;
  const det = alift * (bdxcdy - cdxbdy) + blift * (cdxady - adxcdy) + clift * (adxbdy - bdxady);
  const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift + (Math.abs(cdxady) + Math.abs(adxcdy)) * blift + (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;
  const errbound = iccerrboundA * permanent;
  if (det > errbound || -det > errbound) {
    return det;
  }
  return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);
}
var iccerrboundA, iccerrboundB, iccerrboundC, bc2, ca2, ab2, aa, bb, cc, u3, v, axtbc, aytbc, bxtca, bytca, cxtab, cytab, abt2, bct2, cat2, abtt, bctt, catt, _82, _162, _16b, _16c, _32, _32b, _48, _64, fin3, fin22;
var init_incircle = __esm({
  "node_modules/robust-predicates/esm/incircle.js"() {
    init_util4();
    iccerrboundA = (10 + 96 * epsilon) * epsilon;
    iccerrboundB = (4 + 48 * epsilon) * epsilon;
    iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
    bc2 = vec(4);
    ca2 = vec(4);
    ab2 = vec(4);
    aa = vec(4);
    bb = vec(4);
    cc = vec(4);
    u3 = vec(4);
    v = vec(4);
    axtbc = vec(8);
    aytbc = vec(8);
    bxtca = vec(8);
    bytca = vec(8);
    cxtab = vec(8);
    cytab = vec(8);
    abt2 = vec(8);
    bct2 = vec(8);
    cat2 = vec(8);
    abtt = vec(4);
    bctt = vec(4);
    catt = vec(4);
    _82 = vec(8);
    _162 = vec(16);
    _16b = vec(16);
    _16c = vec(16);
    _32 = vec(32);
    _32b = vec(32);
    _48 = vec(48);
    _64 = vec(64);
    fin3 = vec(1152);
    fin22 = vec(1152);
  }
});

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA, isperrboundB, isperrboundC, ab3, bc3, cd, de, ea, ac, bd, ce, da, eb, abc, bcd, cde, dea, eab, abd, bce, cda, deb, eac, adet, bdet, cdet, ddet, edet, abdet, cddet, cdedet, deter, _83, _8b2, _8c, _163, _24, _482, _48b, _96, _192, _384x, _384y, _384z, _768, xdet, ydet, zdet, fin4;
var init_insphere = __esm({
  "node_modules/robust-predicates/esm/insphere.js"() {
    init_util4();
    isperrboundA = (16 + 224 * epsilon) * epsilon;
    isperrboundB = (5 + 72 * epsilon) * epsilon;
    isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
    ab3 = vec(4);
    bc3 = vec(4);
    cd = vec(4);
    de = vec(4);
    ea = vec(4);
    ac = vec(4);
    bd = vec(4);
    ce = vec(4);
    da = vec(4);
    eb = vec(4);
    abc = vec(24);
    bcd = vec(24);
    cde = vec(24);
    dea = vec(24);
    eab = vec(24);
    abd = vec(24);
    bce = vec(24);
    cda = vec(24);
    deb = vec(24);
    eac = vec(24);
    adet = vec(1152);
    bdet = vec(1152);
    cdet = vec(1152);
    ddet = vec(1152);
    edet = vec(1152);
    abdet = vec(2304);
    cddet = vec(2304);
    cdedet = vec(3456);
    deter = vec(5760);
    _83 = vec(8);
    _8b2 = vec(8);
    _8c = vec(8);
    _163 = vec(16);
    _24 = vec(24);
    _482 = vec(48);
    _48b = vec(48);
    _96 = vec(96);
    _192 = vec(192);
    _384x = vec(384);
    _384y = vec(384);
    _384z = vec(384);
    _768 = vec(768);
    xdet = vec(96);
    ydet = vec(96);
    zdet = vec(96);
    fin4 = vec(1152);
  }
});

// node_modules/robust-predicates/index.js
var init_robust_predicates = __esm({
  "node_modules/robust-predicates/index.js"() {
    init_orient2d();
    init_orient3d();
    init_incircle();
    init_insphere();
  }
});

// node_modules/point-in-polygon-hao/dist/esm/index.js
var init_esm = __esm({
  "node_modules/point-in-polygon-hao/dist/esm/index.js"() {
    init_robust_predicates();
  }
});

// node_modules/@allmaps/render/dist/maps/RTree.js
var init_RTree = __esm({
  "node_modules/@allmaps/render/dist/maps/RTree.js"() {
    init_rbush();
    init_esm();
    init_dist();
  }
});

// node_modules/@allmaps/render/dist/maps/WarpedMapList.js
var init_WarpedMapList = __esm({
  "node_modules/@allmaps/render/dist/maps/WarpedMapList.js"() {
    init_dist4();
    init_dist5();
    init_dist6();
    init_RTree();
    init_dist();
    init_events2();
  }
});

// node_modules/@allmaps/render/dist/tilecache/FetchableTile.js
var init_FetchableTile = __esm({
  "node_modules/@allmaps/render/dist/tilecache/FetchableTile.js"() {
    init_tiles();
  }
});

// node_modules/@allmaps/render/dist/renderers/BaseRenderer.js
var MAX_MAP_OVERVIEW_RESOLUTION;
var init_BaseRenderer = __esm({
  "node_modules/@allmaps/render/dist/renderers/BaseRenderer.js"() {
    init_TileCache();
    init_WarpedMapList();
    init_FetchableTile();
    init_events2();
    init_tiles();
    init_dist();
    init_dist6();
    MAX_MAP_OVERVIEW_RESOLUTION = 1024 * 1024;
  }
});

// node_modules/@allmaps/triangulate/dist/shared.js
var init_shared2 = __esm({
  "node_modules/@allmaps/triangulate/dist/shared.js"() {
    init_esm();
    init_dist();
  }
});

// node_modules/@kninnug/constrainautor/lib/Constrainautor.mjs
function nextEdge(e3) {
  return e3 % 3 === 2 ? e3 - 2 : e3 + 1;
}
function prevEdge(e3) {
  return e3 % 3 === 0 ? e3 + 2 : e3 - 1;
}
function intersectSegments(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
  const x0 = orient2d(p1x, p1y, p3x, p3y, p4x, p4y), y0 = orient2d(p2x, p2y, p3x, p3y, p4x, p4y);
  if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0) {
    return false;
  }
  const x1 = orient2d(p3x, p3y, p1x, p1y, p2x, p2y), y1 = orient2d(p4x, p4y, p1x, p1y, p2x, p2y);
  if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0) {
    return false;
  }
  if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return !(Math.max(p3x, p4x) < Math.min(p1x, p2x) || Math.max(p1x, p2x) < Math.min(p3x, p4x) || Math.max(p3y, p4y) < Math.min(p1y, p2y) || Math.max(p1y, p2y) < Math.min(p3y, p4y));
  }
  return true;
}
var BitSet, BitSet8, Constrainautor;
var init_Constrainautor = __esm({
  "node_modules/@kninnug/constrainautor/lib/Constrainautor.mjs"() {
    init_robust_predicates();
    BitSet = class {
      constructor(W, bs) {
        this.W = W;
        this.bs = bs;
      }
      /**
       * Add a number to the set.
       *
       * @param idx The number to add. Must be 0 <= idx < len.
       * @return this.
       */
      add(idx) {
        const W = this.W, byte = idx / W | 0, bit = idx % W;
        this.bs[byte] |= 1 << bit;
        return this;
      }
      /**
       * Delete a number from the set.
       *
       * @param idx The number to delete. Must be 0 <= idx < len.
       * @return this.
       */
      delete(idx) {
        const W = this.W, byte = idx / W | 0, bit = idx % W;
        this.bs[byte] &= ~(1 << bit);
        return this;
      }
      /**
       * Add or delete a number in the set, depending on the second argument.
       *
       * @param idx The number to add or delete. Must be 0 <= idx < len.
       * @param val If true, add the number, otherwise delete.
       * @return val.
       */
      set(idx, val) {
        const W = this.W, byte = idx / W | 0, bit = idx % W, m = 1 << bit;
        this.bs[byte] ^= (-val ^ this.bs[byte]) & m;
        return val;
      }
      /**
       * Whether the number is in the set.
       *
       * @param idx The number to test. Must be 0 <= idx < len.
       * @return True if the number is in the set.
       */
      has(idx) {
        const W = this.W, byte = idx / W | 0, bit = idx % W;
        return !!(this.bs[byte] & 1 << bit);
      }
      /**
       * Iterate over the numbers that are in the set. The callback is invoked
       * with each number that is set. It is allowed to change the BitSet during
       * iteration. If it deletes a number that has not been iterated over, that
       * number will not show up in a later call. If it adds a number during
       * iteration, that number may or may not show up in a later call.
       *
       * @param fn The function to call for each number.
       * @return this.
       */
      forEach(fn) {
        const W = this.W, bs = this.bs, len = bs.length;
        for (let byte = 0; byte < len; byte++) {
          let bit = 0;
          while (bs[byte] && bit < W) {
            if (bs[byte] & 1 << bit) {
              fn(byte * W + bit);
            }
            bit++;
          }
        }
        return this;
      }
    };
    BitSet8 = class extends BitSet {
      /**
       * Create a bit set.
       *
       * @param len The length of the bit set, limiting the maximum value that
       *        can be stored in it to len - 1.
       */
      constructor(len) {
        const W = 8, bs = new Uint8Array(Math.ceil(len / W)).fill(0);
        super(W, bs);
      }
    };
    Constrainautor = class {
      /**
       * Make a Constrainautor.
       *
       * @param del The triangulation output from Delaunator.
       * @param edges If provided, constrain these edges as by constrainAll.
       */
      constructor(del, edges) {
        if (!del || typeof del !== "object" || !del.triangles || !del.halfedges || !del.coords) {
          throw new Error("Expected an object with Delaunator output");
        }
        if (del.triangles.length % 3 || del.halfedges.length !== del.triangles.length || del.coords.length % 2) {
          throw new Error("Delaunator output appears inconsistent");
        }
        if (del.triangles.length < 3) {
          throw new Error("No edges in triangulation");
        }
        this.del = del;
        const U32NIL = 2 ** 32 - 1, numPoints = del.coords.length >> 1, numEdges = del.triangles.length;
        this.vertMap = new Uint32Array(numPoints).fill(U32NIL);
        this.flips = new BitSet8(numEdges);
        this.consd = new BitSet8(numEdges);
        for (let e3 = 0; e3 < numEdges; e3++) {
          const v2 = del.triangles[e3];
          if (this.vertMap[v2] === U32NIL) {
            this.updateVert(e3);
          }
        }
        if (edges) {
          this.constrainAll(edges);
        }
      }
      /**
       * Constrain the triangulation such that there is an edge between p1 and p2.
       *
       * @param segP1 The index of one segment end-point in the coords array.
       * @param segP2 The index of the other segment end-point in the coords array.
       * @return The id of the edge that points from p1 to p2. If the
       *         constrained edge lies on the hull and points in the opposite
       *         direction (p2 to p1), the negative of its id is returned.
       */
      constrainOne(segP1, segP2) {
        const { triangles, halfedges } = this.del, vm = this.vertMap, consd = this.consd, start2 = vm[segP1];
        let edg = start2;
        do {
          const p4 = triangles[edg], nxt = nextEdge(edg);
          if (p4 === segP2) {
            return this.protect(edg);
          }
          const opp = prevEdge(edg), p3 = triangles[opp];
          if (p3 === segP2) {
            this.protect(nxt);
            return nxt;
          }
          if (this.intersectSegments(segP1, segP2, p3, p4)) {
            edg = opp;
            break;
          }
          const adj = halfedges[nxt];
          edg = adj;
        } while (edg !== -1 && edg !== start2);
        let conEdge = edg;
        let rescan = -1;
        while (edg !== -1) {
          const adj = halfedges[edg], bot = prevEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj);
          if (adj === -1) {
            throw new Error("Constraining edge exited the hull");
          }
          if (consd.has(edg)) {
            throw new Error("Edge intersects already constrained edge");
          }
          if (this.isCollinear(segP1, segP2, triangles[edg]) || this.isCollinear(segP1, segP2, triangles[adj])) {
            throw new Error("Constraining edge intersects point");
          }
          const convex = this.intersectSegments(triangles[edg], triangles[adj], triangles[bot], triangles[top]);
          if (!convex) {
            if (rescan === -1) {
              rescan = edg;
            }
            if (triangles[top] === segP2) {
              if (edg === rescan) {
                throw new Error("Infinite loop: non-convex quadrilateral");
              }
              edg = rescan;
              rescan = -1;
              continue;
            }
            if (this.intersectSegments(segP1, segP2, triangles[top], triangles[adj])) {
              edg = top;
            } else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {
              edg = rgt;
            } else if (rescan === edg) {
              throw new Error("Infinite loop: no further intersect after non-convex");
            }
            continue;
          }
          this.flipDiagonal(edg);
          if (this.intersectSegments(segP1, segP2, triangles[bot], triangles[top])) {
            if (rescan === -1) {
              rescan = bot;
            }
            if (rescan === bot) {
              throw new Error("Infinite loop: flipped diagonal still intersects");
            }
          }
          if (triangles[top] === segP2) {
            conEdge = top;
            edg = rescan;
            rescan = -1;
          } else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {
            edg = rgt;
          }
        }
        const flips = this.flips;
        this.protect(conEdge);
        do {
          var flipped = 0;
          flips.forEach((edg2) => {
            flips.delete(edg2);
            const adj = halfedges[edg2];
            if (adj === -1) {
              return;
            }
            flips.delete(adj);
            if (!this.isDelaunay(edg2)) {
              this.flipDiagonal(edg2);
              flipped++;
            }
          });
        } while (flipped > 0);
        return this.findEdge(segP1, segP2);
      }
      /**
       * Fix the Delaunay condition. It is no longer necessary to call this
       * method after constraining (many) edges, since constrainOne will do it
       * after each.
       *
       * @param deep If true, keep checking & flipping edges until all
       *        edges are Delaunay, otherwise only check the edges once.
       * @return The triangulation object.
       */
      delaunify(deep = false) {
        const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd, len = halfedges.length;
        do {
          var flipped = 0;
          for (let edg = 0; edg < len; edg++) {
            if (consd.has(edg)) {
              continue;
            }
            flips.delete(edg);
            const adj = halfedges[edg];
            if (adj === -1) {
              continue;
            }
            flips.delete(adj);
            if (!this.isDelaunay(edg)) {
              this.flipDiagonal(edg);
              flipped++;
            }
          }
        } while (deep && flipped > 0);
        return this;
      }
      /**
       * Call constrainOne on each edge, and delaunify afterwards.
       *
       * @param edges The edges to constrain: each element is an array with
       *        [p1, p2] which are indices into the points array originally
       *        supplied to Delaunator.
       * @return The triangulation object.
       */
      constrainAll(edges) {
        const len = edges.length;
        for (let i = 0; i < len; i++) {
          const e3 = edges[i];
          this.constrainOne(e3[0], e3[1]);
        }
        return this;
      }
      /**
       * Whether an edge is a constrained edge.
       *
       * @param edg The edge id.
       * @return True if the edge is constrained.
       */
      isConstrained(edg) {
        return this.consd.has(edg);
      }
      /**
       * Find the edge that points from p1 -> p2. If there is only an edge from
       * p2 -> p1 (i.e. it is on the hull), returns the negative id of it.
       *
       * @param p1 The index of the first point into the points array.
       * @param p2 The index of the second point into the points array.
       * @return The id of the edge that points from p1 -> p2, or the negative
       *         id of the edge that goes from p2 -> p1, or Infinity if there is
       *         no edge between p1 and p2.
       */
      findEdge(p1, p2) {
        const start1 = this.vertMap[p2], { triangles, halfedges } = this.del;
        let edg = start1, prv = -1;
        do {
          if (triangles[edg] === p1) {
            return edg;
          }
          prv = nextEdge(edg);
          edg = halfedges[prv];
        } while (edg !== -1 && edg !== start1);
        if (triangles[nextEdge(prv)] === p1) {
          return -prv;
        }
        return Infinity;
      }
      /**
       * Mark an edge as constrained, i.e. should not be touched by `delaunify`.
       *
       * @private
       * @param edg The edge id.
       * @return If edg has an adjacent, returns that, otherwise -edg.
       */
      protect(edg) {
        const adj = this.del.halfedges[edg], flips = this.flips, consd = this.consd;
        flips.delete(edg);
        consd.add(edg);
        if (adj !== -1) {
          flips.delete(adj);
          consd.add(adj);
          return adj;
        }
        return -edg;
      }
      /**
       * Mark an edge as flipped, unless it is already marked as constrained.
       *
       * @private
       * @param edg The edge id.
       * @return True if edg was not constrained.
       */
      markFlip(edg) {
        const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd;
        if (consd.has(edg)) {
          return false;
        }
        const adj = halfedges[edg];
        if (adj !== -1) {
          flips.add(edg);
          flips.add(adj);
        }
        return true;
      }
      /**
       * Flip the edge shared by two triangles.
       *
       * @private
       * @param edg The edge shared by the two triangles, must have an
       *        adjacent half-edge.
       * @return The new diagonal.
       */
      flipDiagonal(edg) {
        const { triangles, halfedges } = this.del, flips = this.flips, consd = this.consd, adj = halfedges[edg], bot = prevEdge(edg), lft = nextEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj), adjBot = halfedges[bot], adjTop = halfedges[top];
        if (consd.has(edg)) {
          throw new Error("Trying to flip a constrained edge");
        }
        triangles[edg] = triangles[top];
        halfedges[edg] = adjTop;
        if (!flips.set(edg, flips.has(top))) {
          consd.set(edg, consd.has(top));
        }
        if (adjTop !== -1) {
          halfedges[adjTop] = edg;
        }
        halfedges[bot] = top;
        triangles[adj] = triangles[bot];
        halfedges[adj] = adjBot;
        if (!flips.set(adj, flips.has(bot))) {
          consd.set(adj, consd.has(bot));
        }
        if (adjBot !== -1) {
          halfedges[adjBot] = adj;
        }
        halfedges[top] = bot;
        this.markFlip(edg);
        this.markFlip(lft);
        this.markFlip(adj);
        this.markFlip(rgt);
        flips.add(bot);
        consd.delete(bot);
        flips.add(top);
        consd.delete(top);
        this.updateVert(edg);
        this.updateVert(lft);
        this.updateVert(adj);
        this.updateVert(rgt);
        return bot;
      }
      /**
       * Whether the two triangles sharing edg conform to the Delaunay condition.
       * As a shortcut, if the given edge has no adjacent (is on the hull), it is
       * certainly Delaunay.
       *
       * @private
       * @param edg The edge shared by the triangles to test.
       * @return True if they are Delaunay.
       */
      isDelaunay(edg) {
        const { triangles, halfedges } = this.del, adj = halfedges[edg];
        if (adj === -1) {
          return true;
        }
        const p1 = triangles[prevEdge(edg)], p2 = triangles[edg], p3 = triangles[nextEdge(edg)], px = triangles[prevEdge(adj)];
        return !this.inCircle(p1, p2, p3, px);
      }
      /**
       * Update the vertex -> incoming edge map.
       *
       * @private
       * @param start The id of an *outgoing* edge.
       * @return The id of the right-most incoming edge.
       */
      updateVert(start2) {
        const { triangles, halfedges } = this.del, vm = this.vertMap, v2 = triangles[start2];
        let inc = prevEdge(start2), adj = halfedges[inc];
        while (adj !== -1 && adj !== start2) {
          inc = prevEdge(adj);
          adj = halfedges[inc];
        }
        vm[v2] = inc;
        return inc;
      }
      /**
       * Whether the segment between [p1, p2] intersects with [p3, p4]. When the
       * segments share an end-point (e.g. p1 == p3 etc.), they are not considered
       * intersecting.
       *
       * @private
       * @param p1 The index of point 1 into this.del.coords.
       * @param p2 The index of point 2 into this.del.coords.
       * @param p3 The index of point 3 into this.del.coords.
       * @param p4 The index of point 4 into this.del.coords.
       * @return True if the segments intersect.
       */
      intersectSegments(p1, p2, p3, p4) {
        const pts = this.del.coords;
        if (p1 === p3 || p1 === p4 || p2 === p3 || p2 === p4) {
          return false;
        }
        return intersectSegments(pts[p1 * 2], pts[p1 * 2 + 1], pts[p2 * 2], pts[p2 * 2 + 1], pts[p3 * 2], pts[p3 * 2 + 1], pts[p4 * 2], pts[p4 * 2 + 1]);
      }
      /**
       * Whether point px is in the circumcircle of the triangle formed by p1, p2,
       * and p3 (which are in counter-clockwise order).
       *
       * @param p1 The index of point 1 into this.del.coords.
       * @param p2 The index of point 2 into this.del.coords.
       * @param p3 The index of point 3 into this.del.coords.
       * @param px The index of point x into this.del.coords.
       * @return True if (px, py) is in the circumcircle.
       */
      inCircle(p1, p2, p3, px) {
        const pts = this.del.coords;
        return incircle(pts[p1 * 2], pts[p1 * 2 + 1], pts[p2 * 2], pts[p2 * 2 + 1], pts[p3 * 2], pts[p3 * 2 + 1], pts[px * 2], pts[px * 2 + 1]) < 0;
      }
      /**
       * Whether point p1, p2, and p are collinear.
       *
       * @private
       * @param p1 The index of segment point 1 into this.del.coords.
       * @param p2 The index of segment point 2 into this.del.coords.
       * @param p The index of the point p into this.del.coords.
       * @return True if the points are collinear.
       */
      isCollinear(p1, p2, p) {
        const pts = this.del.coords;
        return orient2d(pts[p1 * 2], pts[p1 * 2 + 1], pts[p2 * 2], pts[p2 * 2 + 1], pts[p * 2], pts[p * 2 + 1]) === 0;
      }
    };
    Constrainautor.intersectSegments = intersectSegments;
  }
});

// node_modules/@allmaps/triangulate/dist/index.js
var init_dist7 = __esm({
  "node_modules/@allmaps/triangulate/dist/index.js"() {
    init_shared2();
    init_dist();
    init_Constrainautor();
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image.1.js
var image1ProfileUriRegex, Image1ProfileUri, Image1ProfileSchema, Image1ContextString, Image1Context, Image1Schema;
var init_image_1 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image.1.js"() {
    init_zod();
    image1ProfileUriRegex = /^https?:\/\/library.stanford.edu\/iiif\/image-api\/1.1\/compliance.html#level(?<level>[012])$/;
    Image1ProfileUri = external_exports.string().regex(image1ProfileUriRegex);
    Image1ProfileSchema = Image1ProfileUri;
    Image1ContextString = "http://library.stanford.edu/iiif/image-api/1.1/context.json";
    Image1Context = external_exports.literal(Image1ContextString);
    Image1Schema = external_exports.object({
      "@context": Image1Context,
      "@id": external_exports.string().url(),
      profile: Image1ProfileUri.optional(),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      scale_factors: external_exports.number().array().optional(),
      tile_width: external_exports.number().optional(),
      tile_height: external_exports.number().optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/shared.js
var SizeSchema, TilesetSchema, imageServiceTypes, ImageServiceTypesSchema, ValidNavDateSchema, NavDateSchema, NavPlaceSchema;
var init_shared3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/shared.js"() {
    init_zod();
    SizeSchema = external_exports.object({
      width: external_exports.number().int(),
      height: external_exports.number().int()
    });
    TilesetSchema = external_exports.object({
      width: external_exports.number().int(),
      height: external_exports.number().int().optional(),
      scaleFactors: external_exports.array(external_exports.number().int())
    });
    imageServiceTypes = [
      "ImageService1",
      "ImageService2",
      "ImageService3"
    ];
    ImageServiceTypesSchema = external_exports.enum(imageServiceTypes);
    ValidNavDateSchema = external_exports.coerce.date();
    NavDateSchema = external_exports.union([
      ValidNavDateSchema,
      // Catchall for incorrect values
      external_exports.any()
    ]).transform((val) => {
      const { success, data } = ValidNavDateSchema.safeParse(val);
      if (success) {
        return data;
      }
    });
    NavPlaceSchema = external_exports.object({}).passthrough();
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image.2.js
function isValidImage2ProfileArrayItem(item) {
  return item !== void 0;
}
var image2ProfileUriRegex, Image2ProfileUri, Image2ProfileDescriptionSchema, ValidImage2ProfileArrayItemSchema, Image2ProfileSchema, Image2ContextString, Image2Context, Image2Schema;
var init_image_2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image.2.js"() {
    init_zod();
    init_shared3();
    image2ProfileUriRegex = /^https?:\/\/iiif.io\/api\/image\/2.*level(?<level>[012])(.json)?$/;
    Image2ProfileUri = external_exports.string().regex(image2ProfileUriRegex);
    Image2ProfileDescriptionSchema = external_exports.object({
      formats: external_exports.string().array().optional(),
      maxArea: external_exports.number().int().optional(),
      maxHeight: external_exports.number().int().optional(),
      maxWidth: external_exports.number().int().optional(),
      qualities: external_exports.string().array().optional(),
      supports: external_exports.string().array().optional()
    });
    ValidImage2ProfileArrayItemSchema = external_exports.union([
      Image2ProfileUri,
      Image2ProfileDescriptionSchema
    ]);
    Image2ProfileSchema = external_exports.union([
      Image2ProfileUri,
      external_exports.array(external_exports.union([
        ValidImage2ProfileArrayItemSchema,
        // Catchall for incorrect profiles
        external_exports.unknown()
      ]).transform((val) => {
        const { success, data } = ValidImage2ProfileArrayItemSchema.safeParse(val);
        if (success) {
          return data;
        }
      }))
    ]).transform((val) => {
      if (val && Array.isArray(val)) {
        const firstProfile = val[0];
        if (typeof firstProfile !== "string") {
          throw new Error("First profile must be a string");
        }
        return [
          firstProfile,
          ...val.slice(1).filter(isValidImage2ProfileArrayItem)
        ];
      }
      return val;
    });
    Image2ContextString = "http://iiif.io/api/image/2/context.json";
    Image2Context = external_exports.union([
      external_exports.literal(Image2ContextString),
      // Invalid, but used by https://iiif.archivelab.org
      external_exports.literal("https://iiif.io/api/image/2/context.json"),
      external_exports.string().url()
    ]);
    Image2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.union([external_exports.literal("iiif:Image"), external_exports.literal("ImageService2")]).optional(),
      "@context": Image2Context,
      protocol: external_exports.literal("http://iiif.io/api/image"),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      profile: Image2ProfileSchema,
      sizes: SizeSchema.array().optional(),
      tiles: TilesetSchema.array().optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image.3.js
var image3Profiles, Image3ProfileSchema, Image3Schema;
var init_image_3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image.3.js"() {
    init_zod();
    init_shared3();
    image3Profiles = ["level0", "level1", "level2"];
    Image3ProfileSchema = external_exports.enum(image3Profiles);
    Image3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("ImageService3"),
      protocol: external_exports.literal("http://iiif.io/api/image"),
      profile: Image3ProfileSchema,
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      maxWidth: external_exports.number().int().optional(),
      maxHeight: external_exports.number().int().optional(),
      maxArea: external_exports.number().int().optional(),
      sizes: SizeSchema.array().optional(),
      tiles: TilesetSchema.array().optional(),
      extraFeatures: external_exports.string().array().optional()
      // TODO: add partOf, seeAlso, and service
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image-service.2.js
var ImageService2Schema;
var init_image_service_2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image-service.2.js"() {
    init_zod();
    init_image_1();
    init_image_2();
    init_image_3();
    init_shared3();
    ImageService2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": ImageServiceTypesSchema.optional(),
      profile: external_exports.union([
        Image1ProfileSchema,
        Image2ProfileSchema,
        Image3ProfileSchema
      ]),
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional(),
      "@context": external_exports.union([
        Image1Context,
        external_exports.literal("http://iiif.io/api/image/1/context.json"),
        Image2Context
      ]).optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image-service.3.js
var complianceLevels, Presentation3ImageService2Schema, Presentation3ImageService3Schema, ImageService3Schema;
var init_image_service_3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image-service.3.js"() {
    init_zod();
    init_image_2();
    init_shared3();
    complianceLevels = ["level0", "level1", "level2"];
    Presentation3ImageService2Schema = external_exports.union([
      external_exports.object({
        id: external_exports.string().url(),
        type: external_exports.literal("ImageService2"),
        profile: Image2ProfileSchema
      }),
      external_exports.object({
        "@id": external_exports.string().url(),
        "@type": external_exports.literal("ImageService2"),
        profile: Image2ProfileSchema
      })
    ]);
    Presentation3ImageService3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: ImageServiceTypesSchema,
      profile: external_exports.enum(complianceLevels)
    });
    ImageService3Schema = external_exports.union([
      Presentation3ImageService2Schema,
      Presentation3ImageService3Schema
    ]);
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/image-service.js
var ImageServiceSchema2;
var init_image_service = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/image-service.js"() {
    init_zod();
    init_image_service_2();
    init_image_service_3();
    ImageServiceSchema2 = external_exports.union([
      ImageService2Schema,
      ImageService3Schema
    ]);
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/convert.js
function ensureArray2(val) {
  if (val) {
    return Array.isArray(val) ? val : [val];
  }
}
var LanguageString3Schema, MetadataStringItem3Schema;
var init_convert2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/convert.js"() {
    init_zod();
    LanguageString3Schema = external_exports.record(external_exports.string(), external_exports.string().array());
    MetadataStringItem3Schema = external_exports.object({
      label: LanguageString3Schema.optional(),
      value: LanguageString3Schema.optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/presentation.2.js
var SingleValue2Schema, Value2Schema, RelatedItem2Schema, Related2Schema, ThumbnailItem2Schema, Thumbnail2Schema, RenderingItem2Schema, Rendering2Schema, ValidLanguageValue2Schema, LanguageValue2Schema, PossibleLanguageValue2Schema, Attribution2Schema, ValidMetadataItem2Schema, MetadataItem2Schema, Metadata2Schema, ImageResource2Schema, Annotation2Schema, Canvas2Schema, Sequence2Schema, Manifest2Schema, EmbeddedManifest2Schema, Collection2Schema, EmbeddedCollection2Schema;
var init_presentation_2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/presentation.2.js"() {
    init_zod();
    init_image_service();
    init_shared3();
    init_convert2();
    SingleValue2Schema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]).transform((val) => String(val));
    Value2Schema = external_exports.union([
      SingleValue2Schema.array(),
      SingleValue2Schema
    ]);
    RelatedItem2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      format: external_exports.string().optional(),
      label: Value2Schema.optional()
    });
    Related2Schema = external_exports.union([
      RelatedItem2Schema.array(),
      RelatedItem2Schema,
      SingleValue2Schema
    ]);
    ThumbnailItem2Schema = external_exports.union([
      external_exports.string(),
      external_exports.object({
        "@id": external_exports.string().url(),
        "@type": external_exports.string().optional(),
        format: external_exports.string().optional(),
        height: external_exports.number().optional(),
        width: external_exports.number().optional()
      })
    ]);
    Thumbnail2Schema = external_exports.union([ThumbnailItem2Schema.array(), ThumbnailItem2Schema]).transform(ensureArray2);
    RenderingItem2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.string().optional(),
      label: Value2Schema.optional(),
      format: external_exports.string().optional()
    });
    Rendering2Schema = external_exports.union([RenderingItem2Schema.array(), RenderingItem2Schema]).transform(ensureArray2);
    ValidLanguageValue2Schema = external_exports.union([
      external_exports.object({ "@value": Value2Schema, "@language": external_exports.string().optional() }),
      // This is invalid but some IIIF manifests use this incorrect format
      external_exports.object({ value: Value2Schema, language: external_exports.string().optional() })
    ]).transform((val) => {
      if ("value" in val) {
        return {
          "@value": val.value,
          "@language": val.language
        };
      } else {
        return val;
      }
    });
    LanguageValue2Schema = ValidLanguageValue2Schema;
    PossibleLanguageValue2Schema = external_exports.union([
      LanguageValue2Schema.array(),
      LanguageValue2Schema,
      Value2Schema
    ]);
    Attribution2Schema = external_exports.union([
      external_exports.string(),
      PossibleLanguageValue2Schema
    ]);
    ValidMetadataItem2Schema = external_exports.object({
      label: PossibleLanguageValue2Schema.optional(),
      value: PossibleLanguageValue2Schema.optional()
    });
    MetadataItem2Schema = external_exports.union([
      ValidMetadataItem2Schema,
      // Catchall for incorrect values
      external_exports.any()
    ]).transform((val) => {
      const { success, data } = ValidMetadataItem2Schema.safeParse(val);
      if (success) {
        return data;
      }
    });
    Metadata2Schema = MetadataItem2Schema.array();
    ImageResource2Schema = external_exports.object({
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional(),
      service: ImageServiceSchema2
    });
    Annotation2Schema = external_exports.object({
      resource: ImageResource2Schema
    });
    Canvas2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Canvas"),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      images: Annotation2Schema.array().length(1),
      label: PossibleLanguageValue2Schema.optional(),
      description: PossibleLanguageValue2Schema.optional(),
      related: Related2Schema.optional(),
      attribution: Attribution2Schema.optional(),
      thumbnail: Thumbnail2Schema.optional(),
      rendering: Rendering2Schema.optional(),
      metadata: Metadata2Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional()
    });
    Sequence2Schema = external_exports.object({
      canvases: Canvas2Schema.array().nonempty()
    });
    Manifest2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Manifest"),
      sequences: Sequence2Schema.array().length(1),
      label: PossibleLanguageValue2Schema.optional(),
      description: PossibleLanguageValue2Schema.optional(),
      metadata: Metadata2Schema.optional(),
      related: Related2Schema.optional(),
      attribution: Attribution2Schema.optional(),
      rendering: Rendering2Schema.optional(),
      thumbnail: Thumbnail2Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional()
    });
    EmbeddedManifest2Schema = external_exports.lazy(() => external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Manifest"),
      label: PossibleLanguageValue2Schema.optional()
    }));
    Collection2Schema = external_exports.lazy(() => external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Collection"),
      manifests: EmbeddedManifest2Schema.array().optional(),
      collections: Collection2Schema.array().optional(),
      members: external_exports.union([
        EmbeddedManifest2Schema,
        Collection2Schema,
        EmbeddedCollection2Schema
      ]).array().optional(),
      label: PossibleLanguageValue2Schema.optional(),
      description: PossibleLanguageValue2Schema.optional(),
      metadata: Metadata2Schema.optional(),
      related: Related2Schema.optional(),
      attribution: Attribution2Schema.optional(),
      thumbnail: Thumbnail2Schema.optional(),
      rendering: Rendering2Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional()
    }));
    EmbeddedCollection2Schema = external_exports.object({
      "@id": external_exports.string().url(),
      "@type": external_exports.literal("sc:Collection"),
      label: PossibleLanguageValue2Schema.optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/presentation.3.js
var SingleValue3Schema, LanguageValue3Schema, Summary3Schema, HomepageItem3Schema, Rendering3ItemSchema, Rendering3Schema, Homepage3Schema, ThumbnailItem3Schema, Thumbnail3Schema, SeeAlsoItem3Schema, SeeAlso3Schema, NonPaintingAnnotations3, ValidMetadataItem3Schema, MetadataItem3Schema, Metadata3Schema, RequiredStatement3Schema, AnnotationBody3Schema, Choice3Schema, Annotation3Schema, AnnotationPage3Schema, Canvas3Schema2, Manifest3Schema, EmbeddedManifest3Schema, Collection3Schema, EmbeddedCollection3Schema;
var init_presentation_3 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/presentation.3.js"() {
    init_zod();
    init_image_service();
    init_shared3();
    init_convert2();
    SingleValue3Schema = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()]).transform((val) => String(val));
    LanguageValue3Schema = external_exports.record(external_exports.string(), SingleValue3Schema.array());
    Summary3Schema = LanguageValue3Schema;
    HomepageItem3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      label: LanguageValue3Schema,
      format: external_exports.string().optional(),
      language: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional()
    });
    Rendering3ItemSchema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      label: LanguageValue3Schema,
      format: external_exports.string().optional()
    });
    Rendering3Schema = external_exports.union([Rendering3ItemSchema.array(), Rendering3ItemSchema]).transform(ensureArray2);
    Homepage3Schema = external_exports.union([HomepageItem3Schema.array(), HomepageItem3Schema]).transform(ensureArray2);
    ThumbnailItem3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      format: external_exports.string().optional(),
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional()
    });
    Thumbnail3Schema = external_exports.union([ThumbnailItem3Schema.array(), ThumbnailItem3Schema]).transform(ensureArray2);
    SeeAlsoItem3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.string().optional(),
      format: external_exports.string().optional(),
      profile: external_exports.string().optional()
    });
    SeeAlso3Schema = external_exports.union([SeeAlsoItem3Schema.array(), SeeAlsoItem3Schema]).transform(ensureArray2);
    NonPaintingAnnotations3 = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("AnnotationPage"),
      items: external_exports.object({}).passthrough().array().optional()
    }).array();
    ValidMetadataItem3Schema = external_exports.object({
      label: LanguageValue3Schema,
      value: LanguageValue3Schema
    });
    MetadataItem3Schema = external_exports.union([
      ValidMetadataItem3Schema,
      // Catchall for incorrect values
      external_exports.any()
    ]).transform((val) => {
      const { success, data } = ValidMetadataItem3Schema.safeParse(val);
      if (success) {
        return data;
      }
    });
    Metadata3Schema = MetadataItem3Schema.array();
    RequiredStatement3Schema = MetadataItem3Schema;
    AnnotationBody3Schema = external_exports.object({
      type: external_exports.literal("Image"),
      width: external_exports.number().int().optional(),
      height: external_exports.number().int().optional(),
      service: ImageServiceSchema2.array()
    });
    Choice3Schema = external_exports.object({
      type: external_exports.literal("Choice"),
      items: AnnotationBody3Schema.array()
    });
    Annotation3Schema = external_exports.object({
      type: external_exports.literal("Annotation"),
      body: external_exports.union([
        AnnotationBody3Schema,
        AnnotationBody3Schema.array().length(1),
        Choice3Schema
      ])
    });
    AnnotationPage3Schema = external_exports.object({
      type: external_exports.literal("AnnotationPage"),
      items: Annotation3Schema.array().length(1)
    });
    Canvas3Schema2 = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Canvas"),
      width: external_exports.number().int(),
      height: external_exports.number().int(),
      items: AnnotationPage3Schema.array().length(1),
      label: LanguageValue3Schema.optional(),
      description: LanguageValue3Schema.optional(),
      metadata: Metadata3Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional(),
      homepage: Homepage3Schema.optional(),
      thumbnail: Thumbnail3Schema.optional(),
      rendering: Rendering3Schema.optional(),
      seeAlso: SeeAlso3Schema.optional(),
      summary: Summary3Schema.optional(),
      requiredStatement: RequiredStatement3Schema.optional(),
      annotations: NonPaintingAnnotations3.optional()
    });
    Manifest3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Manifest"),
      items: Canvas3Schema2.array().nonempty(),
      label: LanguageValue3Schema.optional(),
      description: LanguageValue3Schema.optional(),
      metadata: Metadata3Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional(),
      homepage: Homepage3Schema.optional(),
      thumbnail: Thumbnail3Schema.optional(),
      rendering: Rendering3Schema.optional(),
      seeAlso: SeeAlso3Schema.optional(),
      summary: Summary3Schema.optional(),
      requiredStatement: RequiredStatement3Schema.optional(),
      annotations: NonPaintingAnnotations3.optional()
    });
    EmbeddedManifest3Schema = external_exports.lazy(() => external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Manifest"),
      label: LanguageValue3Schema.optional()
    }));
    Collection3Schema = external_exports.lazy(() => external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Collection"),
      items: external_exports.union([
        EmbeddedManifest3Schema,
        Collection3Schema,
        EmbeddedCollection3Schema
      ]).array(),
      label: LanguageValue3Schema.optional(),
      description: LanguageValue3Schema.optional(),
      metadata: Metadata3Schema.optional(),
      navDate: NavDateSchema.optional(),
      navPlace: NavPlaceSchema.optional(),
      homepage: Homepage3Schema.optional(),
      thumbnail: Thumbnail3Schema.optional(),
      rendering: Rendering3Schema.optional(),
      seeAlso: SeeAlso3Schema.optional(),
      summary: Summary3Schema.optional(),
      requiredStatement: RequiredStatement3Schema.optional(),
      annotations: NonPaintingAnnotations3.optional()
    }));
    EmbeddedCollection3Schema = external_exports.object({
      id: external_exports.string().url(),
      type: external_exports.literal("Collection"),
      label: LanguageValue3Schema.optional()
    });
  }
});

// node_modules/@allmaps/iiif-parser/dist/schemas/iiif.js
var ImageSchema2, CanvasSchema, ManifestSchema, CollectionSchema, IIIF1Schema, IIIF2Schema, IIIF3Schema, IIIFSchema;
var init_iiif = __esm({
  "node_modules/@allmaps/iiif-parser/dist/schemas/iiif.js"() {
    init_zod();
    init_image_1();
    init_image_2();
    init_image_3();
    init_presentation_2();
    init_presentation_3();
    ImageSchema2 = external_exports.union([Image1Schema, Image2Schema, Image3Schema]);
    CanvasSchema = external_exports.union([Canvas2Schema, Canvas3Schema2]);
    ManifestSchema = external_exports.union([Manifest2Schema, Manifest3Schema]);
    CollectionSchema = external_exports.union([Collection2Schema, Collection3Schema]);
    IIIF1Schema = Image1Schema;
    IIIF2Schema = external_exports.union([
      Collection2Schema,
      Manifest2Schema,
      Canvas2Schema,
      Image2Schema
    ]);
    IIIF3Schema = external_exports.union([
      Collection3Schema,
      Manifest3Schema,
      Canvas3Schema2,
      Image3Schema
    ]);
    IIIFSchema = external_exports.union([IIIF1Schema, IIIF2Schema, IIIF3Schema]);
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/tiles.js
var init_tiles2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/tiles.js"() {
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/image-requests.js
var init_image_requests = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/image-requests.js"() {
    init_tiles2();
  }
});

// node_modules/@allmaps/iiif-parser/dist/lib/profile.js
var init_profile = __esm({
  "node_modules/@allmaps/iiif-parser/dist/lib/profile.js"() {
    init_image_1();
    init_image_2();
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/image.js
var init_image = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/image.js"() {
    init_iiif();
    init_image_1();
    init_image_2();
    init_tiles2();
    init_image_requests();
    init_profile();
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/canvas.js
var init_canvas = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/canvas.js"() {
    init_image();
    init_convert2();
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/manifest.js
var init_manifest = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/manifest.js"() {
    init_iiif();
    init_image();
    init_canvas();
    init_convert2();
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/collection.js
var defaulfFetchNextOptions;
var init_collection = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/collection.js"() {
    init_iiif();
    init_manifest();
    init_convert2();
    defaulfFetchNextOptions = {
      maxDepth: Number.POSITIVE_INFINITY,
      fetchCollections: true,
      fetchManifests: true,
      fetchImages: false,
      fetchFn: globalThis.fetch
    };
  }
});

// node_modules/@allmaps/iiif-parser/dist/classes/iiif.js
var init_iiif2 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/classes/iiif.js"() {
    init_iiif();
    init_image_1();
    init_image();
    init_manifest();
    init_collection();
  }
});

// node_modules/@allmaps/iiif-parser/dist/index.js
var init_dist8 = __esm({
  "node_modules/@allmaps/iiif-parser/dist/index.js"() {
    init_iiif2();
    init_collection();
    init_manifest();
    init_canvas();
    init_image();
  }
});

// node_modules/@allmaps/render/dist/shared/homogeneous-transform.js
var init_homogeneous_transform = __esm({
  "node_modules/@allmaps/render/dist/shared/homogeneous-transform.js"() {
  }
});

// node_modules/@allmaps/render/dist/maps/WarpedMap.js
var init_WarpedMap = __esm({
  "node_modules/@allmaps/render/dist/maps/WarpedMap.js"() {
    init_dist8();
    init_dist6();
    init_dist();
    init_homogeneous_transform();
    init_events2();
  }
});

// node_modules/@allmaps/render/dist/maps/TriangulatedWarpedMap.js
var init_TriangulatedWarpedMap = __esm({
  "node_modules/@allmaps/render/dist/maps/TriangulatedWarpedMap.js"() {
    init_dist7();
    init_dist();
    init_WarpedMap();
  }
});

// node_modules/@allmaps/render/dist/shared/webgl2.js
var init_webgl2 = __esm({
  "node_modules/@allmaps/render/dist/shared/webgl2.js"() {
  }
});

// node_modules/@allmaps/render/dist/maps/WebGL2WarpedMap.js
var init_WebGL2WarpedMap = __esm({
  "node_modules/@allmaps/render/dist/maps/WebGL2WarpedMap.js"() {
    init_dist();
    init_dist3();
    init_TriangulatedWarpedMap();
    init_events2();
    init_homogeneous_transform();
    init_webgl2();
    init_tiles();
  }
});

// node_modules/@allmaps/render/dist/tilecache/CacheableTile.js
var init_CacheableTile = __esm({
  "node_modules/@allmaps/render/dist/tilecache/CacheableTile.js"() {
  }
});

// node_modules/@allmaps/render/dist/tilecache/CacheableWorkerImageDataTile.js
var init_CacheableWorkerImageDataTile = __esm({
  "node_modules/@allmaps/render/dist/tilecache/CacheableWorkerImageDataTile.js"() {
    init_CacheableTile();
    init_events2();
  }
});

// node_modules/@allmaps/render/dist/viewport/Viewport.js
var init_Viewport = __esm({
  "node_modules/@allmaps/render/dist/viewport/Viewport.js"() {
    init_dist();
    init_dist6();
    init_homogeneous_transform();
  }
});

// node_modules/@allmaps/render/dist/shaders/map/vertex-shader.glsl.js
var init_vertex_shader_glsl = __esm({
  "node_modules/@allmaps/render/dist/shaders/map/vertex-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/map/fragment-shader.glsl.js
var init_fragment_shader_glsl = __esm({
  "node_modules/@allmaps/render/dist/shaders/map/fragment-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/lines/vertex-shader.glsl.js
var init_vertex_shader_glsl2 = __esm({
  "node_modules/@allmaps/render/dist/shaders/lines/vertex-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/lines/fragment-shader.glsl.js
var init_fragment_shader_glsl2 = __esm({
  "node_modules/@allmaps/render/dist/shaders/lines/fragment-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/points/vertex-shader.glsl.js
var init_vertex_shader_glsl3 = __esm({
  "node_modules/@allmaps/render/dist/shaders/points/vertex-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/shaders/points/fragment-shader.glsl.js
var init_fragment_shader_glsl3 = __esm({
  "node_modules/@allmaps/render/dist/shaders/points/fragment-shader.glsl.js"() {
  }
});

// node_modules/@allmaps/render/dist/workers/fetch-and-get-image-data.js
var encodedJs, decodeBase64, blob;
var init_fetch_and_get_image_data = __esm({
  "node_modules/@allmaps/render/dist/workers/fetch-and-get-image-data.js"() {
    encodedJs = "LyoqCiAqIEBsaWNlbnNlCiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAKICovCmNvbnN0IHByb3h5TWFya2VyID0gU3ltYm9sKCJDb21saW5rLnByb3h5Iik7CmNvbnN0IGNyZWF0ZUVuZHBvaW50ID0gU3ltYm9sKCJDb21saW5rLmVuZHBvaW50Iik7CmNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbCgiQ29tbGluay5yZWxlYXNlUHJveHkiKTsKY29uc3QgZmluYWxpemVyID0gU3ltYm9sKCJDb21saW5rLmZpbmFsaXplciIpOwpjb25zdCB0aHJvd01hcmtlciA9IFN5bWJvbCgiQ29tbGluay50aHJvd24iKTsKY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAib2JqZWN0IiAmJiB2YWwgIT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gImZ1bmN0aW9uIjsKY29uc3QgcHJveHlUcmFuc2ZlckhhbmRsZXIgPSB7CiAgY2FuSGFuZGxlOiAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIHZhbFtwcm94eU1hcmtlcl0sCiAgc2VyaWFsaXplKG9iaikgewogICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpOwogICAgZXhwb3NlKG9iaiwgcG9ydDEpOwogICAgcmV0dXJuIFtwb3J0MiwgW3BvcnQyXV07CiAgfSwKICBkZXNlcmlhbGl6ZShwb3J0KSB7CiAgICBwb3J0LnN0YXJ0KCk7CiAgICByZXR1cm4gd3JhcChwb3J0KTsKICB9Cn07CmNvbnN0IHRocm93VHJhbnNmZXJIYW5kbGVyID0gewogIGNhbkhhbmRsZTogKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgdGhyb3dNYXJrZXIgaW4gdmFsdWUsCiAgc2VyaWFsaXplKHsgdmFsdWUgfSkgewogICAgbGV0IHNlcmlhbGl6ZWQ7CiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikgewogICAgICBzZXJpYWxpemVkID0gewogICAgICAgIGlzRXJyb3I6IHRydWUsCiAgICAgICAgdmFsdWU6IHsKICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsCiAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lLAogICAgICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrCiAgICAgICAgfQogICAgICB9OwogICAgfSBlbHNlIHsKICAgICAgc2VyaWFsaXplZCA9IHsgaXNFcnJvcjogZmFsc2UsIHZhbHVlIH07CiAgICB9CiAgICByZXR1cm4gW3NlcmlhbGl6ZWQsIFtdXTsKICB9LAogIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHsKICAgIGlmIChzZXJpYWxpemVkLmlzRXJyb3IpIHsKICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3Ioc2VyaWFsaXplZC52YWx1ZS5tZXNzYWdlKSwgc2VyaWFsaXplZC52YWx1ZSk7CiAgICB9CiAgICB0aHJvdyBzZXJpYWxpemVkLnZhbHVlOwogIH0KfTsKY29uc3QgdHJhbnNmZXJIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFsKICBbInByb3h5IiwgcHJveHlUcmFuc2ZlckhhbmRsZXJdLAogIFsidGhyb3ciLCB0aHJvd1RyYW5zZmVySGFuZGxlcl0KXSk7CmZ1bmN0aW9uIGlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgb3JpZ2luKSB7CiAgZm9yIChjb25zdCBhbGxvd2VkT3JpZ2luIG9mIGFsbG93ZWRPcmlnaW5zKSB7CiAgICBpZiAob3JpZ2luID09PSBhbGxvd2VkT3JpZ2luIHx8IGFsbG93ZWRPcmlnaW4gPT09ICIqIikgewogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIGlmIChhbGxvd2VkT3JpZ2luIGluc3RhbmNlb2YgUmVnRXhwICYmIGFsbG93ZWRPcmlnaW4udGVzdChvcmlnaW4pKSB7CiAgICAgIHJldHVybiB0cnVlOwogICAgfQogIH0KICByZXR1cm4gZmFsc2U7Cn0KZnVuY3Rpb24gZXhwb3NlKG9iaiwgZXAgPSBnbG9iYWxUaGlzLCBhbGxvd2VkT3JpZ2lucyA9IFsiKiJdKSB7CiAgZXAuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGZ1bmN0aW9uIGNhbGxiYWNrKGV2KSB7CiAgICBpZiAoIWV2IHx8ICFldi5kYXRhKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICghaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBldi5vcmlnaW4pKSB7CiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBvcmlnaW4gJyR7ZXYub3JpZ2lufScgZm9yIGNvbWxpbmsgcHJveHlgKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgeyBpZCwgdHlwZSwgcGF0aCB9ID0gT2JqZWN0LmFzc2lnbih7IHBhdGg6IFtdIH0sIGV2LmRhdGEpOwogICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7CiAgICBsZXQgcmV0dXJuVmFsdWU7CiAgICB0cnkgewogICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iajIsIHByb3ApID0+IG9iajJbcHJvcF0sIG9iaik7CiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcGF0aC5yZWR1Y2UoKG9iajIsIHByb3ApID0+IG9iajJbcHJvcF0sIG9iaik7CiAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgIGNhc2UgIkdFVCI6CiAgICAgICAgICB7CiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJTRVQiOgogICAgICAgICAgewogICAgICAgICAgICBwYXJlbnRbcGF0aC5zbGljZSgtMSlbMF1dID0gZnJvbVdpcmVWYWx1ZShldi5kYXRhLnZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiQVBQTFkiOgogICAgICAgICAgewogICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlLmFwcGx5KHBhcmVudCwgYXJndW1lbnRMaXN0KTsKICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgIkNPTlNUUlVDVCI6CiAgICAgICAgICB7CiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7CiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcHJveHkodmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiRU5EUE9JTlQiOgogICAgICAgICAgewogICAgICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7CiAgICAgICAgICAgIGV4cG9zZShvYmosIHBvcnQyKTsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cmFuc2Zlcihwb3J0MSwgW3BvcnQxXSk7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJSRUxFQVNFIjoKICAgICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICB9IGNhdGNoICh2YWx1ZSkgewogICAgICByZXR1cm5WYWx1ZSA9IHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTsKICAgIH0KICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkuY2F0Y2goKHZhbHVlKSA9PiB7CiAgICAgIHJldHVybiB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07CiAgICB9KS50aGVuKChyZXR1cm5WYWx1ZTIpID0+IHsKICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyZXR1cm5WYWx1ZTIpOwogICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpOwogICAgICBpZiAodHlwZSA9PT0gIlJFTEVBU0UiKSB7CiAgICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGNhbGxiYWNrKTsKICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTsKICAgICAgICBpZiAoZmluYWxpemVyIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpbmFsaXplcl0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIG9ialtmaW5hbGl6ZXJdKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsKICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZSh7CiAgICAgICAgdmFsdWU6IG5ldyBUeXBlRXJyb3IoIlVuc2VyaWFsaXphYmxlIHJldHVybiB2YWx1ZSIpLAogICAgICAgIFt0aHJvd01hcmtlcl06IDAKICAgICAgfSk7CiAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7CiAgICB9KTsKICB9KTsKICBpZiAoZXAuc3RhcnQpIHsKICAgIGVwLnN0YXJ0KCk7CiAgfQp9CmZ1bmN0aW9uIGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpIHsKICByZXR1cm4gZW5kcG9pbnQuY29uc3RydWN0b3IubmFtZSA9PT0gIk1lc3NhZ2VQb3J0IjsKfQpmdW5jdGlvbiBjbG9zZUVuZFBvaW50KGVuZHBvaW50KSB7CiAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKQogICAgZW5kcG9pbnQuY2xvc2UoKTsKfQpmdW5jdGlvbiB3cmFwKGVwLCB0YXJnZXQpIHsKICBjb25zdCBwZW5kaW5nTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBlcC5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldikgewogICAgY29uc3QgeyBkYXRhIH0gPSBldjsKICAgIGlmICghZGF0YSB8fCAhZGF0YS5pZCkgewogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCByZXNvbHZlciA9IHBlbmRpbmdMaXN0ZW5lcnMuZ2V0KGRhdGEuaWQpOwogICAgaWYgKCFyZXNvbHZlcikgewogICAgICByZXR1cm47CiAgICB9CiAgICB0cnkgewogICAgICByZXNvbHZlcihkYXRhKTsKICAgIH0gZmluYWxseSB7CiAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuZGVsZXRlKGRhdGEuaWQpOwogICAgfQogIH0pOwogIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgW10sIHRhcmdldCk7Cn0KZnVuY3Rpb24gdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNSZWxlYXNlZCkgewogIGlmIChpc1JlbGVhc2VkKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZSIpOwogIH0KfQpmdW5jdGlvbiByZWxlYXNlRW5kcG9pbnQoZXApIHsKICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgewogICAgdHlwZTogIlJFTEVBU0UiCiAgfSkudGhlbigoKSA9PiB7CiAgICBjbG9zZUVuZFBvaW50KGVwKTsKICB9KTsKfQpjb25zdCBwcm94eUNvdW50ZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTsKY29uc3QgcHJveHlGaW5hbGl6ZXJzID0gIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiBpbiBnbG9iYWxUaGlzICYmIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoZXApID0+IHsKICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSAtIDE7CiAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpOwogIGlmIChuZXdDb3VudCA9PT0gMCkgewogICAgcmVsZWFzZUVuZHBvaW50KGVwKTsKICB9Cn0pOwpmdW5jdGlvbiByZWdpc3RlclByb3h5KHByb3h5MiwgZXApIHsKICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSArIDE7CiAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpOwogIGlmIChwcm94eUZpbmFsaXplcnMpIHsKICAgIHByb3h5RmluYWxpemVycy5yZWdpc3Rlcihwcm94eTIsIGVwLCBwcm94eTIpOwogIH0KfQpmdW5jdGlvbiB1bnJlZ2lzdGVyUHJveHkocHJveHkyKSB7CiAgaWYgKHByb3h5RmluYWxpemVycykgewogICAgcHJveHlGaW5hbGl6ZXJzLnVucmVnaXN0ZXIocHJveHkyKTsKICB9Cn0KZnVuY3Rpb24gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHBhdGggPSBbXSwgdGFyZ2V0ID0gZnVuY3Rpb24oKSB7Cn0pIHsKICBsZXQgaXNQcm94eVJlbGVhc2VkID0gZmFsc2U7CiAgY29uc3QgcHJveHkyID0gbmV3IFByb3h5KHRhcmdldCwgewogICAgZ2V0KF90YXJnZXQsIHByb3ApIHsKICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTsKICAgICAgaWYgKHByb3AgPT09IHJlbGVhc2VQcm94eSkgewogICAgICAgIHJldHVybiAoKSA9PiB7CiAgICAgICAgICB1bnJlZ2lzdGVyUHJveHkocHJveHkyKTsKICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7CiAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmNsZWFyKCk7CiAgICAgICAgICBpc1Byb3h5UmVsZWFzZWQgPSB0cnVlOwogICAgICAgIH07CiAgICAgIH0KICAgICAgaWYgKHByb3AgPT09ICJ0aGVuIikgewogICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gcHJveHkyIH07CiAgICAgICAgfQogICAgICAgIGNvbnN0IHIgPSByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgICB0eXBlOiAiR0VUIiwKICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpCiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgICAgICByZXR1cm4gci50aGVuLmJpbmQocik7CiAgICAgIH0KICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBbLi4ucGF0aCwgcHJvcF0pOwogICAgfSwKICAgIHNldChfdGFyZ2V0LCBwcm9wLCByYXdWYWx1ZSkgewogICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpOwogICAgICBjb25zdCBbdmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmF3VmFsdWUpOwogICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgewogICAgICAgIHR5cGU6ICJTRVQiLAogICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksCiAgICAgICAgdmFsdWUKICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgIH0sCiAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgcmF3QXJndW1lbnRMaXN0KSB7CiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7CiAgICAgIGNvbnN0IGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07CiAgICAgIGlmIChsYXN0ID09PSBjcmVhdGVFbmRwb2ludCkgewogICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgICB0eXBlOiAiRU5EUE9JTlQiCiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgICAgfQogICAgICBpZiAobGFzdCA9PT0gImJpbmQiKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBwYXRoLnNsaWNlKDAsIC0xKSk7CiAgICAgIH0KICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7CiAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7CiAgICAgICAgdHlwZTogIkFQUExZIiwKICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSwKICAgICAgICBhcmd1bWVudExpc3QKICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgIH0sCiAgICBjb25zdHJ1Y3QoX3RhcmdldCwgcmF3QXJndW1lbnRMaXN0KSB7CiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7CiAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpOwogICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgewogICAgICAgIHR5cGU6ICJDT05TVFJVQ1QiLAogICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLAogICAgICAgIGFyZ3VtZW50TGlzdAogICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpOwogICAgfQogIH0pOwogIHJlZ2lzdGVyUHJveHkocHJveHkyLCBlcCk7CiAgcmV0dXJuIHByb3h5MjsKfQpmdW5jdGlvbiBteUZsYXQoYXJyKSB7CiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7Cn0KZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3QpIHsKICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTsKICByZXR1cm4gW3Byb2Nlc3NlZC5tYXAoKHYpID0+IHZbMF0pLCBteUZsYXQocHJvY2Vzc2VkLm1hcCgodikgPT4gdlsxXSkpXTsKfQpjb25zdCB0cmFuc2ZlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7CmZ1bmN0aW9uIHRyYW5zZmVyKG9iaiwgdHJhbnNmZXJzKSB7CiAgdHJhbnNmZXJDYWNoZS5zZXQob2JqLCB0cmFuc2ZlcnMpOwogIHJldHVybiBvYmo7Cn0KZnVuY3Rpb24gcHJveHkob2JqKSB7CiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCB7IFtwcm94eU1hcmtlcl06IHRydWUgfSk7Cn0KZnVuY3Rpb24gdG9XaXJlVmFsdWUodmFsdWUpIHsKICBmb3IgKGNvbnN0IFtuYW1lLCBoYW5kbGVyXSBvZiB0cmFuc2ZlckhhbmRsZXJzKSB7CiAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodmFsdWUpKSB7CiAgICAgIGNvbnN0IFtzZXJpYWxpemVkVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gaGFuZGxlci5zZXJpYWxpemUodmFsdWUpOwogICAgICByZXR1cm4gWwogICAgICAgIHsKICAgICAgICAgIHR5cGU6ICJIQU5ETEVSIiwKICAgICAgICAgIG5hbWUsCiAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFZhbHVlCiAgICAgICAgfSwKICAgICAgICB0cmFuc2ZlcmFibGVzCiAgICAgIF07CiAgICB9CiAgfQogIHJldHVybiBbCiAgICB7CiAgICAgIHR5cGU6ICJSQVciLAogICAgICB2YWx1ZQogICAgfSwKICAgIHRyYW5zZmVyQ2FjaGUuZ2V0KHZhbHVlKSB8fCBbXQogIF07Cn0KZnVuY3Rpb24gZnJvbVdpcmVWYWx1ZSh2YWx1ZSkgewogIHN3aXRjaCAodmFsdWUudHlwZSkgewogICAgY2FzZSAiSEFORExFUiI6CiAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7CiAgICBjYXNlICJSQVciOgogICAgICByZXR1cm4gdmFsdWUudmFsdWU7CiAgfQp9CmZ1bmN0aW9uIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIG1zZywgdHJhbnNmZXJzKSB7CiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpOwogICAgcGVuZGluZ0xpc3RlbmVycy5zZXQoaWQsIHJlc29sdmUpOwogICAgaWYgKGVwLnN0YXJ0KSB7CiAgICAgIGVwLnN0YXJ0KCk7CiAgICB9CiAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKHsgaWQgfSwgbXNnKSwgdHJhbnNmZXJzKTsKICB9KTsKfQpmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7CiAgcmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKDApLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikudG9TdHJpbmcoMTYpKS5qb2luKCItIik7Cn0KYXN5bmMgZnVuY3Rpb24gZmV0Y2hVcmwoaW5wdXQsIGluaXQsIGZldGNoRm4pIHsKICBsZXQgcmVzcG9uc2U7CiAgaWYgKHR5cGVvZiBmZXRjaEZuID09PSAiZnVuY3Rpb24iKSB7CiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoRm4oaW5wdXQsIGluaXQpOwogIH0gZWxzZSB7CiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKGlucHV0LCBpbml0KTsKICB9CiAgaWYgKCFyZXNwb25zZS5vaykgewogICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTsKICAgIGlmIChqc29uICYmIGpzb24uZXJyb3IpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKGpzb24uZXJyb3IpOwogICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNUZXh0KSB7CiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTsKICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgZm91bmQ6ICR7aW5wdXR9ICg0MDQpYCk7CiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAwKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiSW50ZXJuYWwgc2VydmVyIGVycm9yICg1MDApIik7CiAgICB9IGVsc2UgewogICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaDogJHtpbnB1dH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSlgKTsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3BvbnNlOwp9CmNvbnN0IGZldGNoQW5kR2V0SW1hZ2VEYXRhV29ya2VyID0gewogIGFzeW5jIGdldEltYWdlRGF0YSh0aWxlVXJsLCBvbkFib3J0LCBmZXRjaEZuLCB3aWR0aCwgaGVpZ2h0KSB7CiAgICBjb25zdCB3b3JrZXJBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7CiAgICBvbkFib3J0KCk7CiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoVXJsKAogICAgICB0aWxlVXJsLAogICAgICB7CiAgICAgICAgc2lnbmFsOiB3b3JrZXJBYm9ydENvbnRyb2xsZXIuc2lnbmFsCiAgICAgIH0sCiAgICAgIGZldGNoRm4KICAgICk7CiAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpOwogICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7CiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICBpZiAoIWNvbnRleHQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJDb3VsZCBub3QgY3JlYXRlIE9mZnNjcmVlbkNhbnZhcyBjb250ZXh0Iik7CiAgICB9CiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZUJpdG1hcCwgMCwgMCk7CiAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgIHJldHVybiB0cmFuc2ZlcihpbWFnZURhdGEsIFtpbWFnZURhdGEuZGF0YS5idWZmZXJdKTsKICB9Cn07CmV4cG9zZShmZXRjaEFuZEdldEltYWdlRGF0YVdvcmtlcik7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLWFuZC1nZXQtaW1hZ2UtZGF0YS1CQzRZc0lHNy5qcy5tYXAK";
    decodeBase64 = (base64) => Uint8Array.from(atob(base64), (c2) => c2.charCodeAt(0));
    blob = typeof self !== "undefined" && self.Blob && new Blob(["URL.revokeObjectURL(import.meta.url);", decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
  }
});

// node_modules/@allmaps/render/dist/renderers/WebGL2Renderer.js
var SIGNIFICANT_VIEWPORT_EPSILON;
var init_WebGL2Renderer = __esm({
  "node_modules/@allmaps/render/dist/renderers/WebGL2Renderer.js"() {
    init_dist();
    init_dist2();
    init_dist3();
    init_BaseRenderer();
    init_WebGL2WarpedMap();
    init_CacheableWorkerImageDataTile();
    init_events2();
    init_homogeneous_transform();
    init_webgl2();
    init_Viewport();
    init_vertex_shader_glsl();
    init_fragment_shader_glsl();
    init_vertex_shader_glsl2();
    init_fragment_shader_glsl2();
    init_vertex_shader_glsl3();
    init_fragment_shader_glsl3();
    init_fetch_and_get_image_data();
    SIGNIFICANT_VIEWPORT_EPSILON = 100 * Number.EPSILON;
  }
});

// node_modules/@allmaps/render/dist/webgl2.js
var init_webgl22 = __esm({
  "node_modules/@allmaps/render/dist/webgl2.js"() {
    init_WebGL2Renderer();
    init_WebGL2WarpedMap();
  }
});

// node_modules/@allmaps/render/dist/index.js
var init_dist9 = __esm({
  "node_modules/@allmaps/render/dist/index.js"() {
    init_Viewport();
    init_WarpedMapList();
    init_WarpedMap();
    init_TriangulatedWarpedMap();
    init_events2();
  }
});

// node_modules/@allmaps/openlayers/dist/OLWarpedMapEvent.js
var init_OLWarpedMapEvent = __esm({
  "node_modules/@allmaps/openlayers/dist/OLWarpedMapEvent.js"() {
  }
});

// node_modules/@allmaps/openlayers/dist/WarpedMapLayer.js
var init_WarpedMapLayer = __esm({
  "node_modules/@allmaps/openlayers/dist/WarpedMapLayer.js"() {
    init_webgl22();
    init_dist9();
    init_dist();
    init_OLWarpedMapEvent();
  }
});

// node_modules/@allmaps/openlayers/dist/index.js
var init_dist10 = __esm({
  "node_modules/@allmaps/openlayers/dist/index.js"() {
    init_WarpedMapLayer();
    init_OLWarpedMapEvent();
    init_dist9();
  }
});

// node_modules/ol/TileState.js
var TileState_default;
var init_TileState = __esm({
  "node_modules/ol/TileState.js"() {
    TileState_default = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      /**
       * Indicates that tile loading failed
       * @type {number}
       */
      ERROR: 3,
      EMPTY: 4
    };
  }
});

// node_modules/ol/easing.js
function easeIn(t2) {
  return Math.pow(t2, 3);
}
function easeOut(t2) {
  return 1 - easeIn(1 - t2);
}
function inAndOut(t2) {
  return 3 * t2 * t2 - 2 * t2 * t2 * t2;
}
var init_easing = __esm({
  "node_modules/ol/easing.js"() {
  }
});

// node_modules/ol/Tile.js
var Tile, Tile_default;
var init_Tile = __esm({
  "node_modules/ol/Tile.js"() {
    init_TileState();
    init_easing();
    init_EventType();
    init_Target();
    init_util();
    Tile = class extends Target_default {
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("./TileState.js").default} state State.
       * @param {Options} [options] Tile options.
       */
      constructor(tileCoord, state2, options2) {
        super();
        options2 = options2 ? options2 : {};
        this.tileCoord = tileCoord;
        this.state = state2;
        this.key = "";
        this.transition_ = options2.transition === void 0 ? 250 : options2.transition;
        this.transitionStarts_ = {};
        this.interpolate = !!options2.interpolate;
      }
      /**
       * @protected
       */
      changed() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * Called by the tile cache when the tile is removed from the cache due to expiry
       */
      release() {
        this.setState(TileState_default.EMPTY);
      }
      /**
       * @return {string} Key.
       */
      getKey() {
        return this.key + "/" + this.tileCoord;
      }
      /**
       * Get the tile coordinate for this tile.
       * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
       * @api
       */
      getTileCoord() {
        return this.tileCoord;
      }
      /**
       * @return {import("./TileState.js").default} State.
       */
      getState() {
        return this.state;
      }
      /**
       * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
       * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
       * when the tile cannot be loaded. Otherwise the tile cannot be removed from
       * the tile queue and will block other requests.
       * @param {import("./TileState.js").default} state State.
       * @api
       */
      setState(state2) {
        if (this.state === TileState_default.EMPTY) {
          return;
        }
        if (this.state !== TileState_default.ERROR && this.state > state2) {
          throw new Error("Tile load sequence violation");
        }
        this.state = state2;
        this.changed();
      }
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @abstract
       * @api
       */
      load() {
        abstract();
      }
      /**
       * Get the alpha value for rendering.
       * @param {string} id An id for the renderer.
       * @param {number} time The render frame time.
       * @return {number} A number between 0 and 1.
       */
      getAlpha(id, time) {
        if (!this.transition_) {
          return 1;
        }
        let start2 = this.transitionStarts_[id];
        if (!start2) {
          start2 = time;
          this.transitionStarts_[id] = start2;
        } else if (start2 === -1) {
          return 1;
        }
        const delta = time - start2 + 1e3 / 60;
        if (delta >= this.transition_) {
          return 1;
        }
        return easeIn(delta / this.transition_);
      }
      /**
       * Determine if a tile is in an alpha transition.  A tile is considered in
       * transition if tile.getAlpha() has not yet been called or has been called
       * and returned 1.
       * @param {string} id An id for the renderer.
       * @return {boolean} The tile is in transition.
       */
      inTransition(id) {
        if (!this.transition_) {
          return false;
        }
        return this.transitionStarts_[id] !== -1;
      }
      /**
       * Mark a transition as complete.
       * @param {string} id An id for the renderer.
       */
      endTransition(id) {
        if (this.transition_) {
          this.transitionStarts_[id] = -1;
        }
      }
      /**
       * @override
       */
      disposeInternal() {
        this.release();
        super.disposeInternal();
      }
    };
    Tile_default = Tile;
  }
});

// node_modules/ol/has.js
var ua, SAFARI, SAFARI_BUG_237906, WEBKIT, MAC, WORKER_OFFSCREEN_CANVAS, IMAGE_DECODE, PASSIVE_EVENT_LISTENERS;
var init_has = __esm({
  "node_modules/ol/has.js"() {
    ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
    SAFARI = ua.includes("safari") && !ua.includes("chrom");
    SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
    WEBKIT = ua.includes("webkit") && !ua.includes("edge");
    MAC = ua.includes("macintosh");
    WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
    IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
    PASSIVE_EVENT_LISTENERS = function() {
      let passive = false;
      try {
        const options2 = Object.defineProperty({}, "passive", {
          get: function() {
            passive = true;
          }
        });
        window.addEventListener("_", null, options2);
        window.removeEventListener("_", null, options2);
      } catch {
      }
      return passive;
    }();
  }
});

// node_modules/ol/dom.js
function createCanvasContext2D(width, height, canvasPool2, settings) {
  let canvas;
  if (canvasPool2 && canvasPool2.length) {
    canvas = /** @type {HTMLCanvasElement} */
    canvasPool2.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", settings)
  );
}
function getSharedCanvasContext2D() {
  if (!sharedCanvasContext) {
    sharedCanvasContext = createCanvasContext2D(1, 1);
  }
  return sharedCanvasContext;
}
function releaseCanvas(context2) {
  const canvas = context2.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context2.clearRect(0, 0, 1, 1);
}
var sharedCanvasContext;
var init_dom = __esm({
  "node_modules/ol/dom.js"() {
    init_has();
  }
});

// node_modules/ol/DataTile.js
function asImageLike(data) {
  return data instanceof Image || data instanceof HTMLCanvasElement || data instanceof HTMLVideoElement || data instanceof ImageBitmap ? data : null;
}
var disposedError, defaultSize, DataTile, DataTile_default;
var init_DataTile = __esm({
  "node_modules/ol/DataTile.js"() {
    init_Tile();
    init_TileState();
    disposedError = new Error("disposed");
    defaultSize = [256, 256];
    DataTile = class extends Tile_default {
      /**
       * @param {Options} options Tile options.
       */
      constructor(options2) {
        const state2 = TileState_default.IDLE;
        super(options2.tileCoord, state2, {
          transition: options2.transition,
          interpolate: options2.interpolate
        });
        this.loader_ = options2.loader;
        this.data_ = null;
        this.error_ = null;
        this.size_ = options2.size || null;
        this.controller_ = options2.controller || null;
      }
      /**
       * Get the tile size.
       * @return {import('./size.js').Size} Tile size.
       */
      getSize() {
        if (this.size_) {
          return this.size_;
        }
        const imageData = asImageLike(this.data_);
        if (imageData) {
          return [imageData.width, imageData.height];
        }
        return defaultSize;
      }
      /**
       * Get the data for the tile.
       * @return {Data} Tile data.
       * @api
       */
      getData() {
        return this.data_;
      }
      /**
       * Get any loading error.
       * @return {Error} Loading error.
       * @api
       */
      getError() {
        return this.error_;
      }
      /**
       * Load the tile data.
       * @api
       * @override
       */
      load() {
        if (this.state !== TileState_default.IDLE && this.state !== TileState_default.ERROR) {
          return;
        }
        this.state = TileState_default.LOADING;
        this.changed();
        const self2 = this;
        this.loader_().then(function(data) {
          self2.data_ = data;
          self2.state = TileState_default.LOADED;
          self2.changed();
        }).catch(function(error2) {
          self2.error_ = error2;
          self2.state = TileState_default.ERROR;
          self2.changed();
        });
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        if (this.controller_) {
          this.controller_.abort(disposedError);
          this.controller_ = null;
        }
        super.disposeInternal();
      }
    };
    DataTile_default = DataTile;
  }
});

// node_modules/ol/ImageState.js
var ImageState_default;
var init_ImageState = __esm({
  "node_modules/ol/ImageState.js"() {
    ImageState_default = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4
    };
  }
});

// node_modules/ol/Image.js
function listenImage(image, loadHandler, errorHandler) {
  const img = (
    /** @type {HTMLImageElement} */
    image
  );
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType_default.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error2) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType_default.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
function load(image, src) {
  return new Promise((resolve2, reject) => {
    function handleLoad() {
      unlisten();
      resolve2(image);
    }
    function handleError() {
      unlisten();
      reject(new Error("Image load error"));
    }
    function unlisten() {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    }
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (src) {
      image.src = src;
    }
  });
}
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE ? new Promise(
    (resolve2, reject) => image.decode().then(() => resolve2(image)).catch(
      (e3) => image.complete && image.width ? resolve2(image) : reject(e3)
    )
  ) : load(image);
}
var init_Image = __esm({
  "node_modules/ol/Image.js"() {
    init_EventType();
    init_events();
    init_has();
  }
});

// node_modules/ol/ImageTile.js
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var ImageTile, ImageTile_default;
var init_ImageTile = __esm({
  "node_modules/ol/ImageTile.js"() {
    init_Image();
    init_Tile();
    init_TileState();
    init_dom();
    ImageTile = class extends Tile_default {
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("./TileState.js").default} state State.
       * @param {string} src Image source URI.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
       * @param {import("./Tile.js").Options} [options] Tile options.
       */
      constructor(tileCoord, state2, src, crossOrigin, tileLoadFunction, options2) {
        super(tileCoord, state2, options2);
        this.crossOrigin_ = crossOrigin;
        this.src_ = src;
        this.key = src;
        this.image_ = new Image();
        if (crossOrigin !== null) {
          this.image_.crossOrigin = crossOrigin;
        }
        this.unlisten_ = null;
        this.tileLoadFunction_ = tileLoadFunction;
      }
      /**
       * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @api
       */
      getImage() {
        return this.image_;
      }
      /**
       * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
       * @param {HTMLCanvasElement|HTMLImageElement} element Element.
       */
      setImage(element2) {
        this.image_ = element2;
        this.state = TileState_default.LOADED;
        this.unlistenImage_();
        this.changed();
      }
      /**
       * Tracks loading or read errors.
       *
       * @private
       */
      handleImageError_() {
        this.state = TileState_default.ERROR;
        this.unlistenImage_();
        this.image_ = getBlankImage();
        this.changed();
      }
      /**
       * Tracks successful image load.
       *
       * @private
       */
      handleImageLoad_() {
        const image = (
          /** @type {HTMLImageElement} */
          this.image_
        );
        if (image.naturalWidth && image.naturalHeight) {
          this.state = TileState_default.LOADED;
        } else {
          this.state = TileState_default.EMPTY;
        }
        this.unlistenImage_();
        this.changed();
      }
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       *
       * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
       * that checks for error status codes and reloads only when the status code is
       * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
       * made already:
       *
       * ```js
       * const retryCodes = [408, 429, 500, 502, 503, 504];
       * const retries = {};
       * source.setTileLoadFunction((tile, src) => {
       *   const image = tile.getImage();
       *   fetch(src)
       *     .then((response) => {
       *       if (retryCodes.includes(response.status)) {
       *         retries[src] = (retries[src] || 0) + 1;
       *         if (retries[src] <= 3) {
       *           setTimeout(() => tile.load(), retries[src] * 1000);
       *         }
       *         return Promise.reject();
       *       }
       *       return response.blob();
       *     })
       *     .then((blob) => {
       *       const imageUrl = URL.createObjectURL(blob);
       *       image.src = imageUrl;
       *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
       *     })
       *     .catch(() => tile.setState(3)); // error
       * });
       * ```
       * @api
       * @override
       */
      load() {
        if (this.state == TileState_default.ERROR) {
          this.state = TileState_default.IDLE;
          this.image_ = new Image();
          if (this.crossOrigin_ !== null) {
            this.image_.crossOrigin = this.crossOrigin_;
          }
        }
        if (this.state == TileState_default.IDLE) {
          this.state = TileState_default.LOADING;
          this.changed();
          this.tileLoadFunction_(this, this.src_);
          this.unlisten_ = listenImage(
            this.image_,
            this.handleImageLoad_.bind(this),
            this.handleImageError_.bind(this)
          );
        }
      }
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      unlistenImage_() {
        if (this.unlisten_) {
          this.unlisten_();
          this.unlisten_ = null;
        }
      }
      /**
       * @override
       */
      disposeInternal() {
        this.unlistenImage_();
        this.image_ = null;
        super.disposeInternal();
      }
    };
    ImageTile_default = ImageTile;
  }
});

// node_modules/ol/TileRange.js
function createOrUpdate2(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
var TileRange, TileRange_default;
var init_TileRange = __esm({
  "node_modules/ol/TileRange.js"() {
    TileRange = class {
      /**
       * @param {number} minX Minimum X.
       * @param {number} maxX Maximum X.
       * @param {number} minY Minimum Y.
       * @param {number} maxY Maximum Y.
       */
      constructor(minX, maxX, minY, maxY) {
        this.minX = minX;
        this.maxX = maxX;
        this.minY = minY;
        this.maxY = maxY;
      }
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {boolean} Contains tile coordinate.
       */
      contains(tileCoord) {
        return this.containsXY(tileCoord[1], tileCoord[2]);
      }
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Contains.
       */
      containsTileRange(tileRange) {
        return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
      }
      /**
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @return {boolean} Contains coordinate.
       */
      containsXY(x, y) {
        return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
      }
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Equals.
       */
      equals(tileRange) {
        return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
      }
      /**
       * @param {TileRange} tileRange Tile range.
       */
      extend(tileRange) {
        if (tileRange.minX < this.minX) {
          this.minX = tileRange.minX;
        }
        if (tileRange.maxX > this.maxX) {
          this.maxX = tileRange.maxX;
        }
        if (tileRange.minY < this.minY) {
          this.minY = tileRange.minY;
        }
        if (tileRange.maxY > this.maxY) {
          this.maxY = tileRange.maxY;
        }
      }
      /**
       * @return {number} Height.
       */
      getHeight() {
        return this.maxY - this.minY + 1;
      }
      /**
       * @return {import("./size.js").Size} Size.
       */
      getSize() {
        return [this.getWidth(), this.getHeight()];
      }
      /**
       * @return {number} Width.
       */
      getWidth() {
        return this.maxX - this.minX + 1;
      }
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Intersects.
       */
      intersects(tileRange) {
        return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
      }
    };
    TileRange_default = TileRange;
  }
});

// node_modules/ol/reproj.js
function drawTestTriangle(ctx, u1, v1, u22, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u22, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u22) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset) {
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    releaseCanvas(ctx);
    canvasPool.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(
    targetProj,
    targetResolution,
    targetCenter
  );
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render2(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle, clipExtent) {
  const context2 = createCanvasContext2D(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool
  );
  if (!interpolate) {
    context2.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context2.canvas;
  }
  context2.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context2.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i, arr) {
    extend(sourceDataExtent, src.extent);
  });
  let stitchContext;
  const stitchScale = pixelRatio / sourceResolution;
  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;
  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    stitchContext = createCanvasContext2D(
      Math.round(getWidth(sourceDataExtent) * stitchScale),
      Math.round(getHeight(sourceDataExtent) * stitchScale),
      canvasPool
    );
    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    if (sourceExtent && clipExtent) {
      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;
      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;
      const width2 = getWidth(sourceExtent) * stitchScale;
      const height2 = getHeight(sourceExtent) * stitchScale;
      stitchContext.rect(xPos, yPos, width2, height2);
      stitchContext.clip();
    }
    sources.forEach(function(src, i, arr) {
      if (src.image.width > 0 && src.image.height > 0) {
        if (src.clipExtent) {
          stitchContext.save();
          const xPos2 = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;
          const yPos2 = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;
          const width2 = getWidth(src.clipExtent) * stitchScale;
          const height2 = getHeight(src.clipExtent) * stitchScale;
          stitchContext.rect(
            interpolate ? xPos2 : Math.round(xPos2),
            interpolate ? yPos2 : Math.round(yPos2),
            interpolate ? width2 : Math.round(xPos2 + width2) - Math.round(xPos2),
            interpolate ? height2 : Math.round(yPos2 + height2) - Math.round(yPos2)
          );
          stitchContext.clip();
        }
        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;
        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;
        const srcWidth = getWidth(src.extent) * stitchScale;
        const srcHeight = getHeight(src.extent) * stitchScale;
        stitchContext.drawImage(
          src.image,
          gutter,
          gutter,
          src.image.width - 2 * gutter,
          src.image.height - 2 * gutter,
          interpolate ? xPos : Math.round(xPos),
          interpolate ? yPos : Math.round(yPos),
          interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),
          interpolate ? srcHeight : Math.round(yPos + srcHeight) - Math.round(yPos)
        );
        if (src.clipExtent) {
          stitchContext.restore();
        }
      }
    });
  }
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    const source2 = triangle.source;
    const target = triangle.target;
    let x0 = source2[0][0], y0 = source2[0][1];
    let x1 = source2[1][0], y1 = source2[1][1];
    let x2 = source2[2][0], y2 = source2[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u22 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u22 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context2.save();
    context2.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context2.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context2.lineTo(
          u1 + pixelRound((step + 1) * ud / steps),
          v1 + pixelRound(step * vd / (steps - 1))
        );
        if (step != steps - 1) {
          context2.lineTo(
            u1 + pixelRound((step + 1) * ud / steps),
            v1 + pixelRound((step + 1) * vd / (steps - 1))
          );
        }
      }
      context2.lineTo(u22, v2);
    } else {
      context2.moveTo(u1, v1);
      context2.lineTo(u0, v0);
      context2.lineTo(u22, v2);
    }
    context2.clip();
    context2.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );
    context2.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );
    let image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context2.scale(inverseScale, -inverseScale);
    } else {
      const source3 = sources[0];
      const extent = source3.extent;
      image = source3.image;
      context2.scale(
        getWidth(extent) / image.width,
        -getHeight(extent) / image.height
      );
    }
    context2.drawImage(image, 0, 0);
    context2.restore();
  });
  if (stitchContext) {
    releaseCanvas(stitchContext);
    canvasPool.push(stitchContext.canvas);
  }
  if (renderEdges) {
    context2.save();
    context2.globalCompositeOperation = "source-over";
    context2.strokeStyle = "black";
    context2.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u22 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context2.beginPath();
      context2.moveTo(u1, v1);
      context2.lineTo(u0, v0);
      context2.lineTo(u22, v2);
      context2.closePath();
      context2.stroke();
    });
    context2.restore();
  }
  return context2.canvas;
}
var brokenDiagonalRendering_, canvasPool;
var init_reproj = __esm({
  "node_modules/ol/reproj.js"() {
    init_dom();
    init_extent();
    init_math();
    init_proj();
    canvasPool = [];
  }
});

// node_modules/ol/reproj/Triangulation.js
var MAX_SUBDIVISION, MAX_TRIANGLE_WIDTH, Triangulation, Triangulation_default;
var init_Triangulation = __esm({
  "node_modules/ol/reproj/Triangulation.js"() {
    init_extent();
    init_math();
    init_proj();
    init_transform();
    MAX_SUBDIVISION = 10;
    MAX_TRIANGLE_WIDTH = 0.25;
    Triangulation = class {
      /**
       * @param {import("../proj/Projection.js").default} sourceProj Source projection.
       * @param {import("../proj/Projection.js").default} targetProj Target projection.
       * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
       * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
       * @param {number} errorThreshold Acceptable error (in source units).
       * @param {?number} destinationResolution The (optional) resolution of the destination.
       * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
       */
      constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution, sourceMatrix) {
        this.sourceProj_ = sourceProj;
        this.targetProj_ = targetProj;
        let transformInvCache = {};
        const transformInv = sourceMatrix ? createTransformFromCoordinateTransform(
          (input) => apply(
            sourceMatrix,
            transform(input, this.targetProj_, this.sourceProj_)
          )
        ) : getTransform(this.targetProj_, this.sourceProj_);
        this.transformInv_ = function(c2) {
          const key2 = c2[0] + "/" + c2[1];
          if (!transformInvCache[key2]) {
            transformInvCache[key2] = transformInv(c2);
          }
          return transformInvCache[key2];
        };
        this.maxSourceExtent_ = maxSourceExtent;
        this.errorThresholdSquared_ = errorThreshold * errorThreshold;
        this.triangles_ = [];
        this.wrapsXInSource_ = false;
        this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());
        this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
        this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
        const destinationTopLeft = getTopLeft(targetExtent);
        const destinationTopRight = getTopRight(targetExtent);
        const destinationBottomRight = getBottomRight(targetExtent);
        const destinationBottomLeft = getBottomLeft(targetExtent);
        const sourceTopLeft = this.transformInv_(destinationTopLeft);
        const sourceTopRight = this.transformInv_(destinationTopRight);
        const sourceBottomRight = this.transformInv_(destinationBottomRight);
        const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
        const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(
          0,
          Math.ceil(
            Math.log2(
              getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)
            )
          )
        ) : 0);
        this.addQuad_(
          destinationTopLeft,
          destinationTopRight,
          destinationBottomRight,
          destinationBottomLeft,
          sourceTopLeft,
          sourceTopRight,
          sourceBottomRight,
          sourceBottomLeft,
          maxSubdivision
        );
        if (this.wrapsXInSource_) {
          let leftBound = Infinity;
          this.triangles_.forEach(function(triangle, i, arr) {
            leftBound = Math.min(
              leftBound,
              triangle.source[0][0],
              triangle.source[1][0],
              triangle.source[2][0]
            );
          });
          this.triangles_.forEach((triangle) => {
            if (Math.max(
              triangle.source[0][0],
              triangle.source[1][0],
              triangle.source[2][0]
            ) - leftBound > this.sourceWorldWidth_ / 2) {
              const newTriangle = [
                [triangle.source[0][0], triangle.source[0][1]],
                [triangle.source[1][0], triangle.source[1][1]],
                [triangle.source[2][0], triangle.source[2][1]]
              ];
              if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
                newTriangle[0][0] -= this.sourceWorldWidth_;
              }
              if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
                newTriangle[1][0] -= this.sourceWorldWidth_;
              }
              if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
                newTriangle[2][0] -= this.sourceWorldWidth_;
              }
              const minX = Math.min(
                newTriangle[0][0],
                newTriangle[1][0],
                newTriangle[2][0]
              );
              const maxX = Math.max(
                newTriangle[0][0],
                newTriangle[1][0],
                newTriangle[2][0]
              );
              if (maxX - minX < this.sourceWorldWidth_ / 2) {
                triangle.source = newTriangle;
              }
            }
          });
        }
        transformInvCache = {};
      }
      /**
       * Adds triangle to the triangulation.
       * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
       * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
       * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
       * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
       * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
       * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
       * @private
       */
      addTriangle_(a, b, c2, aSrc, bSrc, cSrc) {
        this.triangles_.push({
          source: [aSrc, bSrc, cSrc],
          target: [a, b, c2]
        });
      }
      /**
       * Adds quad (points in clock-wise order) to the triangulation
       * (and reprojects the vertices) if valid.
       * Performs quad subdivision if needed to increase precision.
       *
       * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
       * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
       * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
       * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
       * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
       * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
       * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
       * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
       * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
       * @private
       */
      addQuad_(a, b, c2, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
        const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
        const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
        const sourceWorldWidth = (
          /** @type {number} */
          this.sourceWorldWidth_
        );
        const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
        let needsSubdivision = false;
        if (maxSubdivision > 0) {
          if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
            const targetQuadExtent = boundingExtent([a, b, c2, d]);
            const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
            needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
          }
          if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
            needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
          }
        }
        if (!needsSubdivision && this.maxSourceExtent_) {
          if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
            if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
              return;
            }
          }
        }
        let isNotFinite = 0;
        if (!needsSubdivision) {
          if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
            if (maxSubdivision > 0) {
              needsSubdivision = true;
            } else {
              isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
              if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
                return;
              }
            }
          }
        }
        if (maxSubdivision > 0) {
          if (!needsSubdivision) {
            const center = [(a[0] + c2[0]) / 2, (a[1] + c2[1]) / 2];
            const centerSrc = this.transformInv_(center);
            let dx;
            if (wrapsX) {
              const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
              dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
            } else {
              dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
            }
            const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
            const centerSrcErrorSquared = dx * dx + dy * dy;
            needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
          }
          if (needsSubdivision) {
            if (Math.abs(a[0] - c2[0]) <= Math.abs(a[1] - c2[1])) {
              const bc4 = [(b[0] + c2[0]) / 2, (b[1] + c2[1]) / 2];
              const bcSrc = this.transformInv_(bc4);
              const da2 = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
              const daSrc = this.transformInv_(da2);
              this.addQuad_(
                a,
                b,
                bc4,
                da2,
                aSrc,
                bSrc,
                bcSrc,
                daSrc,
                maxSubdivision - 1
              );
              this.addQuad_(
                da2,
                bc4,
                c2,
                d,
                daSrc,
                bcSrc,
                cSrc,
                dSrc,
                maxSubdivision - 1
              );
            } else {
              const ab4 = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
              const abSrc = this.transformInv_(ab4);
              const cd2 = [(c2[0] + d[0]) / 2, (c2[1] + d[1]) / 2];
              const cdSrc = this.transformInv_(cd2);
              this.addQuad_(
                a,
                ab4,
                cd2,
                d,
                aSrc,
                abSrc,
                cdSrc,
                dSrc,
                maxSubdivision - 1
              );
              this.addQuad_(
                ab4,
                b,
                c2,
                cd2,
                abSrc,
                bSrc,
                cSrc,
                cdSrc,
                maxSubdivision - 1
              );
            }
            return;
          }
        }
        if (wrapsX) {
          if (!this.canWrapXInSource_) {
            return;
          }
          this.wrapsXInSource_ = true;
        }
        if ((isNotFinite & 11) == 0) {
          this.addTriangle_(a, c2, d, aSrc, cSrc, dSrc);
        }
        if ((isNotFinite & 14) == 0) {
          this.addTriangle_(a, c2, b, aSrc, cSrc, bSrc);
        }
        if (isNotFinite) {
          if ((isNotFinite & 13) == 0) {
            this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
          }
          if ((isNotFinite & 7) == 0) {
            this.addTriangle_(b, d, c2, bSrc, dSrc, cSrc);
          }
        }
      }
      /**
       * Calculates extent of the `source` coordinates from all the triangles.
       *
       * @return {import("../extent.js").Extent} Calculated extent.
       */
      calculateSourceExtent() {
        const extent = createEmpty();
        this.triangles_.forEach(function(triangle, i, arr) {
          const src = triangle.source;
          extendCoordinate(extent, src[0]);
          extendCoordinate(extent, src[1]);
          extendCoordinate(extent, src[2]);
        });
        return extent;
      }
      /**
       * @return {Array<Triangle>} Array of the calculated triangles.
       */
      getTriangles() {
        return this.triangles_;
      }
    };
    Triangulation_default = Triangulation;
  }
});

// node_modules/ol/reproj/common.js
var ERROR_THRESHOLD;
var init_common = __esm({
  "node_modules/ol/reproj/common.js"() {
    ERROR_THRESHOLD = 0.5;
  }
});

// node_modules/ol/reproj/Tile.js
var ReprojTile, Tile_default2;
var init_Tile2 = __esm({
  "node_modules/ol/reproj/Tile.js"() {
    init_Tile();
    init_TileState();
    init_dom();
    init_EventType();
    init_events();
    init_extent();
    init_math();
    init_reproj();
    init_Triangulation();
    init_common();
    ReprojTile = class extends Tile_default {
      /**
       * @param {import("../proj/Projection.js").default} sourceProj Source projection.
       * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
       * @param {import("../proj/Projection.js").default} targetProj Target projection.
       * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
       * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
       * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} gutter Gutter of the source tiles.
       * @param {FunctionType} getTileFunction
       *     Function returning source tiles (z, x, y, pixelRatio).
       * @param {number} [errorThreshold] Acceptable reprojection error (in px).
       * @param {boolean} [renderEdges] Render reprojection edges.
       * @param {import("../Tile.js").Options} [options] Tile options.
       */
      constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options2) {
        super(tileCoord, TileState_default.IDLE, options2);
        this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
        this.pixelRatio_ = pixelRatio;
        this.gutter_ = gutter;
        this.canvas_ = null;
        this.sourceTileGrid_ = sourceTileGrid;
        this.targetTileGrid_ = targetTileGrid;
        this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
        this.sourceTiles_ = [];
        this.sourcesListenerKeys_ = null;
        this.sourceZ_ = 0;
        this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : void 0;
        const targetExtent = targetTileGrid.getTileCoordExtent(
          this.wrappedTileCoord_
        );
        const maxTargetExtent = this.targetTileGrid_.getExtent();
        let maxSourceExtent = this.sourceTileGrid_.getExtent();
        const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
        if (getArea(limitedTargetExtent) === 0) {
          this.state = TileState_default.EMPTY;
          return;
        }
        const sourceProjExtent = sourceProj.getExtent();
        if (sourceProjExtent) {
          if (!maxSourceExtent) {
            maxSourceExtent = sourceProjExtent;
          } else {
            maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
          }
        }
        const targetResolution = targetTileGrid.getResolution(
          this.wrappedTileCoord_[0]
        );
        const sourceResolution = calculateSourceExtentResolution(
          sourceProj,
          targetProj,
          limitedTargetExtent,
          targetResolution
        );
        if (!isFinite(sourceResolution) || sourceResolution <= 0) {
          this.state = TileState_default.EMPTY;
          return;
        }
        const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
        this.triangulation_ = new Triangulation_default(
          sourceProj,
          targetProj,
          limitedTargetExtent,
          maxSourceExtent,
          sourceResolution * errorThresholdInPixels,
          targetResolution
        );
        if (this.triangulation_.getTriangles().length === 0) {
          this.state = TileState_default.EMPTY;
          return;
        }
        this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
        let sourceExtent = this.triangulation_.calculateSourceExtent();
        if (maxSourceExtent) {
          if (sourceProj.canWrapX()) {
            sourceExtent[1] = clamp(
              sourceExtent[1],
              maxSourceExtent[1],
              maxSourceExtent[3]
            );
            sourceExtent[3] = clamp(
              sourceExtent[3],
              maxSourceExtent[1],
              maxSourceExtent[3]
            );
          } else {
            sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
          }
        }
        if (!getArea(sourceExtent)) {
          this.state = TileState_default.EMPTY;
        } else {
          let worldWidth = 0;
          let worldsAway = 0;
          if (sourceProj.canWrapX()) {
            worldWidth = getWidth(sourceProjExtent);
            worldsAway = Math.floor(
              (sourceExtent[0] - sourceProjExtent[0]) / worldWidth
            );
          }
          const sourceExtents = wrapAndSliceX(
            sourceExtent.slice(),
            sourceProj,
            true
          );
          sourceExtents.forEach((extent) => {
            const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
              extent,
              this.sourceZ_
            );
            for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
              for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
                const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
                if (tile) {
                  const offset = worldsAway * worldWidth;
                  this.sourceTiles_.push({ tile, offset });
                }
              }
            }
            ++worldsAway;
          });
          if (this.sourceTiles_.length === 0) {
            this.state = TileState_default.EMPTY;
          }
        }
      }
      /**
       * Get the HTML Canvas element for this tile.
       * @return {HTMLCanvasElement} Canvas.
       */
      getImage() {
        return this.canvas_;
      }
      /**
       * @private
       */
      reproject_() {
        const sources = [];
        this.sourceTiles_.forEach((source2) => {
          const tile = source2.tile;
          if (tile && tile.getState() == TileState_default.LOADED) {
            const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
            extent[0] += source2.offset;
            extent[2] += source2.offset;
            const clipExtent = this.clipExtent_?.slice();
            if (clipExtent) {
              clipExtent[0] += source2.offset;
              clipExtent[2] += source2.offset;
            }
            sources.push({
              extent,
              clipExtent,
              image: tile.getImage()
            });
          }
        });
        this.sourceTiles_.length = 0;
        if (sources.length === 0) {
          this.state = TileState_default.ERROR;
        } else {
          const z = this.wrappedTileCoord_[0];
          const size = this.targetTileGrid_.getTileSize(z);
          const width = typeof size === "number" ? size : size[0];
          const height = typeof size === "number" ? size : size[1];
          const targetResolution = this.targetTileGrid_.getResolution(z);
          const sourceResolution = this.sourceTileGrid_.getResolution(
            this.sourceZ_
          );
          const targetExtent = this.targetTileGrid_.getTileCoordExtent(
            this.wrappedTileCoord_
          );
          this.canvas_ = render2(
            width,
            height,
            this.pixelRatio_,
            sourceResolution,
            this.sourceTileGrid_.getExtent(),
            targetResolution,
            targetExtent,
            this.triangulation_,
            sources,
            this.gutter_,
            this.renderEdges_,
            this.interpolate
          );
          this.state = TileState_default.LOADED;
        }
        this.changed();
      }
      /**
       * Load not yet loaded URI.
       * @override
       */
      load() {
        if (this.state == TileState_default.IDLE) {
          this.state = TileState_default.LOADING;
          this.changed();
          let leftToLoad = 0;
          this.sourcesListenerKeys_ = [];
          this.sourceTiles_.forEach(({ tile }) => {
            const state2 = tile.getState();
            if (state2 == TileState_default.IDLE || state2 == TileState_default.LOADING) {
              leftToLoad++;
              const sourceListenKey = listen(tile, EventType_default.CHANGE, (e3) => {
                const state3 = tile.getState();
                if (state3 == TileState_default.LOADED || state3 == TileState_default.ERROR || state3 == TileState_default.EMPTY) {
                  unlistenByKey(sourceListenKey);
                  leftToLoad--;
                  if (leftToLoad === 0) {
                    this.unlistenSources_();
                    this.reproject_();
                  }
                }
              });
              this.sourcesListenerKeys_.push(sourceListenKey);
            }
          });
          if (leftToLoad === 0) {
            setTimeout(this.reproject_.bind(this), 0);
          } else {
            this.sourceTiles_.forEach(function({ tile }, i, arr) {
              const state2 = tile.getState();
              if (state2 == TileState_default.IDLE) {
                tile.load();
              }
            });
          }
        }
      }
      /**
       * @private
       */
      unlistenSources_() {
        this.sourcesListenerKeys_.forEach(unlistenByKey);
        this.sourcesListenerKeys_ = null;
      }
      /**
       * Remove from the cache due to expiry
       * @override
       */
      release() {
        if (this.canvas_) {
          releaseCanvas(this.canvas_.getContext("2d"));
          canvasPool.push(this.canvas_);
          this.canvas_ = null;
        }
        super.release();
      }
    };
    Tile_default2 = ReprojTile;
  }
});

// node_modules/ol/size.js
function scale3(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}
var init_size = __esm({
  "node_modules/ol/size.js"() {
  }
});

// node_modules/ol/structs/LRUCache.js
var LRUCache, LRUCache_default;
var init_LRUCache = __esm({
  "node_modules/ol/structs/LRUCache.js"() {
    init_Disposable();
    init_asserts();
    LRUCache = class {
      /**
       * @param {number} [highWaterMark] High water mark.
       */
      constructor(highWaterMark) {
        this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
        this.count_ = 0;
        this.entries_ = {};
        this.oldest_ = null;
        this.newest_ = null;
      }
      deleteOldest() {
        const entry = this.pop();
        if (entry instanceof Disposable_default) {
          entry.dispose();
        }
      }
      /**
       * @return {boolean} Can expire cache.
       */
      canExpireCache() {
        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
      }
      /**
       * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
       * the entry will be disposed.
       * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
       */
      expireCache(keep) {
        while (this.canExpireCache()) {
          this.deleteOldest();
        }
      }
      /**
       * FIXME empty description for jsdoc
       */
      clear() {
        while (this.oldest_) {
          this.deleteOldest();
        }
      }
      /**
       * @param {string} key Key.
       * @return {boolean} Contains key.
       */
      containsKey(key2) {
        return this.entries_.hasOwnProperty(key2);
      }
      /**
       * @param {function(T, string, LRUCache<T>): ?} f The function
       *     to call for every entry from the oldest to the newer. This function takes
       *     3 arguments (the entry value, the entry key and the LRUCache object).
       *     The return value is ignored.
       */
      forEach(f) {
        let entry = this.oldest_;
        while (entry) {
          f(entry.value_, entry.key_, this);
          entry = entry.newer;
        }
      }
      /**
       * @param {string} key Key.
       * @param {*} [options] Options (reserved for subclasses).
       * @return {T} Value.
       */
      get(key2, options2) {
        const entry = this.entries_[key2];
        assert(
          entry !== void 0,
          "Tried to get a value for a key that does not exist in the cache"
        );
        if (entry === this.newest_) {
          return entry.value_;
        }
        if (entry === this.oldest_) {
          this.oldest_ = /** @type {Entry} */
          this.oldest_.newer;
          this.oldest_.older = null;
        } else {
          entry.newer.older = entry.older;
          entry.older.newer = entry.newer;
        }
        entry.newer = null;
        entry.older = this.newest_;
        this.newest_.newer = entry;
        this.newest_ = entry;
        return entry.value_;
      }
      /**
       * Remove an entry from the cache.
       * @param {string} key The entry key.
       * @return {T} The removed entry.
       */
      remove(key2) {
        const entry = this.entries_[key2];
        assert(
          entry !== void 0,
          "Tried to get a value for a key that does not exist in the cache"
        );
        if (entry === this.newest_) {
          this.newest_ = /** @type {Entry} */
          entry.older;
          if (this.newest_) {
            this.newest_.newer = null;
          }
        } else if (entry === this.oldest_) {
          this.oldest_ = /** @type {Entry} */
          entry.newer;
          if (this.oldest_) {
            this.oldest_.older = null;
          }
        } else {
          entry.newer.older = entry.older;
          entry.older.newer = entry.newer;
        }
        delete this.entries_[key2];
        --this.count_;
        return entry.value_;
      }
      /**
       * @return {number} Count.
       */
      getCount() {
        return this.count_;
      }
      /**
       * @return {Array<string>} Keys.
       */
      getKeys() {
        const keys = new Array(this.count_);
        let i = 0;
        let entry;
        for (entry = this.newest_; entry; entry = entry.older) {
          keys[i++] = entry.key_;
        }
        return keys;
      }
      /**
       * @return {Array<T>} Values.
       */
      getValues() {
        const values = new Array(this.count_);
        let i = 0;
        let entry;
        for (entry = this.newest_; entry; entry = entry.older) {
          values[i++] = entry.value_;
        }
        return values;
      }
      /**
       * @return {T} Last value.
       */
      peekLast() {
        return this.oldest_.value_;
      }
      /**
       * @return {string} Last key.
       */
      peekLastKey() {
        return this.oldest_.key_;
      }
      /**
       * Get the key of the newest item in the cache.  Throws if the cache is empty.
       * @return {string} The newest key.
       */
      peekFirstKey() {
        return this.newest_.key_;
      }
      /**
       * Return an entry without updating least recently used time.
       * @param {string} key Key.
       * @return {T|undefined} Value.
       */
      peek(key2) {
        return this.entries_[key2]?.value_;
      }
      /**
       * @return {T} value Value.
       */
      pop() {
        const entry = this.oldest_;
        delete this.entries_[entry.key_];
        if (entry.newer) {
          entry.newer.older = null;
        }
        this.oldest_ = /** @type {Entry} */
        entry.newer;
        if (!this.oldest_) {
          this.newest_ = null;
        }
        --this.count_;
        return entry.value_;
      }
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      replace(key2, value) {
        this.get(key2);
        this.entries_[key2].value_ = value;
      }
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      set(key2, value) {
        assert(
          !(key2 in this.entries_),
          "Tried to set a value for a key that is used already"
        );
        const entry = {
          key_: key2,
          newer: null,
          older: this.newest_,
          value_: value
        };
        if (!this.newest_) {
          this.oldest_ = entry;
        } else {
          this.newest_.newer = entry;
        }
        this.newest_ = entry;
        this.entries_[key2] = entry;
        ++this.count_;
      }
      /**
       * Set a maximum number of entries for the cache.
       * @param {number} size Cache size.
       * @api
       */
      setSize(size) {
        this.highWaterMark = size;
      }
    };
    LRUCache_default = LRUCache;
  }
});

// node_modules/ol/tilecoord.js
function createOrUpdate3(z, x, y, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}
function getKeyZXY(z, x, y) {
  return z + "/" + x + "/" + y;
}
function hash2(tileCoord) {
  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function hashZXY(z, x, y) {
  return (x << z) + y;
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}
var init_tilecoord = __esm({
  "node_modules/ol/tilecoord.js"() {
  }
});

// node_modules/ol/color.js
function getColorParseContext() {
  if (!colorParseContext) {
    colorParseContext = createCanvasContext2D(1, 1, void 0, {
      willReadFrequently: true,
      desynchronized: true
    });
  }
  return colorParseContext;
}
function toColorComponent(s3, divider) {
  return s3.endsWith("%") ? Number(s3.substring(0, s3.length - 1)) / divider : Number(s3);
}
function throwInvalidColor(color) {
  throw new Error('failed to parse "' + color + '" as color');
}
function parseRgba(color) {
  if (color.toLowerCase().startsWith("rgb")) {
    const rgb = color.match(rgbLegacyAbsoluteRegEx) || color.match(rgbModernRegEx) || color.match(rgbLegacyPercentageRegEx);
    if (rgb) {
      const alpha = rgb[4];
      const rgbDivider = 100 / 255;
      return [
        clamp(toColorComponent(rgb[1], rgbDivider) + 0.5 | 0, 0, 255),
        clamp(toColorComponent(rgb[2], rgbDivider) + 0.5 | 0, 0, 255),
        clamp(toColorComponent(rgb[3], rgbDivider) + 0.5 | 0, 0, 255),
        alpha !== void 0 ? clamp(toColorComponent(alpha, 100), 0, 1) : 1
      ];
    }
    throwInvalidColor(color);
  }
  if (color.startsWith("#")) {
    if (hexRegEx.test(color)) {
      const hex = color.substring(1);
      const step = hex.length <= 4 ? 1 : 2;
      const colorFromHex = [0, 0, 0, 255];
      for (let i = 0, ii = hex.length; i < ii; i += step) {
        let colorComponent = parseInt(hex.substring(i, i + step), 16);
        if (step === 1) {
          colorComponent += colorComponent << 4;
        }
        colorFromHex[i / step] = colorComponent;
      }
      colorFromHex[3] = colorFromHex[3] / 255;
      return colorFromHex;
    }
    throwInvalidColor(color);
  }
  const context2 = getColorParseContext();
  context2.fillStyle = "#abcdef";
  let invalidCheckFillStyle = context2.fillStyle;
  context2.fillStyle = color;
  if (context2.fillStyle === invalidCheckFillStyle) {
    context2.fillStyle = "#fedcba";
    invalidCheckFillStyle = context2.fillStyle;
    context2.fillStyle = color;
    if (context2.fillStyle === invalidCheckFillStyle) {
      throwInvalidColor(color);
    }
  }
  const colorString = context2.fillStyle;
  if (colorString.startsWith("#") || colorString.startsWith("rgba")) {
    return parseRgba(colorString);
  }
  context2.clearRect(0, 0, 1, 1);
  context2.fillRect(0, 0, 1, 1);
  const colorFromImage = Array.from(context2.getImageData(0, 0, 1, 1).data);
  colorFromImage[3] = toFixed(colorFromImage[3] / 255, 3);
  return colorFromImage;
}
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString2(color);
}
function fromString2(s3) {
  if (s3 === "none") {
    return NO_COLOR;
  }
  if (cache2.hasOwnProperty(s3)) {
    return cache2[s3];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i = 0;
    for (const key2 in cache2) {
      if ((i++ & 3) === 0) {
        delete cache2[key2];
        --cacheSize;
      }
    }
  }
  const color = parseRgba(s3);
  if (color.length !== 4) {
    throwInvalidColor(s3);
  }
  for (const c2 of color) {
    if (isNaN(c2)) {
      throwInvalidColor(s3);
    }
  }
  cache2[s3] = color;
  ++cacheSize;
  return color;
}
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString2(color);
}
function toString2(color) {
  let r3 = color[0];
  if (r3 != (r3 | 0)) {
    r3 = r3 + 0.5 | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  const a = color[3] === void 0 ? 1 : Math.round(color[3] * 1e3) / 1e3;
  return "rgba(" + r3 + "," + g + "," + b + "," + a + ")";
}
var NO_COLOR, colorParseContext, rgbModernRegEx, rgbLegacyAbsoluteRegEx, rgbLegacyPercentageRegEx, hexRegEx, MAX_CACHE_SIZE, cache2, cacheSize;
var init_color2 = __esm({
  "node_modules/ol/color.js"() {
    init_dom();
    init_math();
    NO_COLOR = [NaN, NaN, NaN, 0];
    rgbModernRegEx = /^rgba?\(\s*(\d+%?)\s+(\d+%?)\s+(\d+%?)(?:\s*\/\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
    rgbLegacyAbsoluteRegEx = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
    rgbLegacyPercentageRegEx = /^rgba?\(\s*(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
    hexRegEx = /^#([\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;
    MAX_CACHE_SIZE = 1024;
    cache2 = {};
    cacheSize = 0;
  }
});

// node_modules/ol/render/Event.js
var RenderEvent, Event_default2;
var init_Event2 = __esm({
  "node_modules/ol/render/Event.js"() {
    init_Event();
    RenderEvent = class extends Event_default {
      /**
       * @param {import("./EventType.js").default} type Type.
       * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
       *     CSS pixels to rendered pixels.
       * @param {import("../Map.js").FrameState} [frameState] Frame state.
       * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
       */
      constructor(type, inversePixelTransform, frameState, context2) {
        super(type);
        this.inversePixelTransform = inversePixelTransform;
        this.frameState = frameState;
        this.context = context2;
      }
    };
    Event_default2 = RenderEvent;
  }
});

// node_modules/ol/render/EventType.js
var EventType_default2;
var init_EventType2 = __esm({
  "node_modules/ol/render/EventType.js"() {
    EventType_default2 = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: "prerender",
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered before layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: "precompose",
      /**
       * Triggered after layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: "postcompose",
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: "rendercomplete"
    };
  }
});

// node_modules/ol/render/canvas/ZIndexContext.js
var ZIndexContext, ZIndexContext_default;
var init_ZIndexContext = __esm({
  "node_modules/ol/render/canvas/ZIndexContext.js"() {
    init_dom();
    ZIndexContext = class {
      constructor() {
        this.instructions_ = [];
        this.zIndex = 0;
        this.offset_ = 0;
        this.context_ = /** @type {ZIndexContextProxy} */
        new Proxy(getSharedCanvasContext2D(), {
          get: (target, property) => {
            if (typeof /** @type {*} */
            getSharedCanvasContext2D()[property] !== "function") {
              return void 0;
            }
            this.push_(property);
            return this.pushMethodArgs_;
          },
          set: (target, property, value) => {
            this.push_(property, value);
            return true;
          }
        });
      }
      /**
       * @param {...*} args Arguments to push to the instructions array.
       * @private
       */
      push_(...args) {
        const instructions = this.instructions_;
        const index8 = this.zIndex + this.offset_;
        if (!instructions[index8]) {
          instructions[index8] = [];
        }
        instructions[index8].push(...args);
      }
      /**
       * @private
       * @param {...*} args Args.
       * @return {ZIndexContext} This.
       */
      pushMethodArgs_ = (...args) => {
        this.push_(args);
        return this;
      };
      /**
       * Push a function that renders to the context directly.
       * @param {function(CanvasRenderingContext2D): void} render Function.
       */
      pushFunction(render3) {
        this.push_(render3);
      }
      /**
       * Get a proxy for CanvasRenderingContext2D which does not support getting state
       * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
       * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
       * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
       * @return {ZIndexContextProxy} Context.
       */
      getContext() {
        return this.context_;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       */
      draw(context2) {
        this.instructions_.forEach((instructionsAtIndex) => {
          for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {
            const property = instructionsAtIndex[i];
            if (typeof property === "function") {
              property(context2);
              continue;
            }
            const instructionAtIndex = instructionsAtIndex[++i];
            if (typeof /** @type {*} */
            context2[property] === "function") {
              context2[property](...instructionAtIndex);
            } else {
              if (typeof instructionAtIndex === "function") {
                context2[property] = instructionAtIndex(context2);
                continue;
              }
              context2[property] = instructionAtIndex;
            }
          }
        });
      }
      clear() {
        this.instructions_.length = 0;
        this.zIndex = 0;
        this.offset_ = 0;
      }
      /**
       * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
       * avoid conflicting context.clip() or context.save()/restore() calls.
       */
      offset() {
        this.offset_ = this.instructions_.length;
        this.zIndex = 0;
      }
    };
    ZIndexContext_default = ZIndexContext;
  }
});

// node_modules/ol/renderer/Layer.js
var maxStaleKeys, LayerRenderer, Layer_default;
var init_Layer = __esm({
  "node_modules/ol/renderer/Layer.js"() {
    init_ImageState();
    init_Observable();
    init_EventType();
    init_util();
    maxStaleKeys = 5;
    LayerRenderer = class extends Observable_default {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super();
        this.ready = true;
        this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        this.layer_ = layer;
        this.staleKeys_ = new Array();
        this.maxStaleKeys = maxStaleKeys;
      }
      /**
       * @return {Array<string>} Get the list of stale keys.
       */
      getStaleKeys() {
        return this.staleKeys_;
      }
      /**
       * @param {string} key The new stale key.
       */
      prependStaleKey(key2) {
        this.staleKeys_.unshift(key2);
        if (this.staleKeys_.length > this.maxStaleKeys) {
          this.staleKeys_.length = this.maxStaleKeys;
        }
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        return abstract();
      }
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        return null;
      }
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      prepareFrame(frameState) {
        return abstract();
      }
      /**
       * Render the layer.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      renderFrame(frameState, target) {
        return abstract();
      }
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return void 0;
      }
      /**
       * @return {LayerType} Layer.
       */
      getLayer() {
        return this.layer_;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */
      handleFontsChanged() {
      }
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */
      handleImageChange_(event) {
        const image = (
          /** @type {import("../Image.js").default} */
          event.target
        );
        if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
          this.renderIfReadyAndVisible();
        }
      }
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../Image.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      loadImage(image) {
        let imageState = image.getState();
        if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
          image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
        }
        if (imageState == ImageState_default.IDLE) {
          image.load();
          imageState = image.getState();
        }
        return imageState == ImageState_default.LOADED;
      }
      /**
       * @protected
       */
      renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
          layer.changed();
        }
      }
      /**
       * @param {import("../Map.js").FrameState} frameState Frame state.
       */
      renderDeferred(frameState) {
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
      }
    };
    Layer_default = LayerRenderer;
  }
});

// node_modules/ol/renderer/canvas/Layer.js
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
var pixelContext, CanvasLayerRenderer, Layer_default2;
var init_Layer2 = __esm({
  "node_modules/ol/renderer/canvas/Layer.js"() {
    init_array();
    init_color2();
    init_dom();
    init_extent();
    init_Event2();
    init_EventType2();
    init_ZIndexContext();
    init_transform();
    init_Layer();
    pixelContext = null;
    CanvasLayerRenderer = class extends Layer_default {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super(layer);
        this.container = null;
        this.renderedResolution;
        this.tempTransform = create();
        this.pixelTransform = create();
        this.inversePixelTransform = create();
        this.context = null;
        this.deferredContext_ = null;
        this.containerReused = false;
        this.frameState = null;
      }
      /**
       * @param {import('../../DataTile.js').ImageLike} image Image.
       * @param {number} col The column index.
       * @param {number} row The row index.
       * @return {Uint8ClampedArray|null} The image data.
       */
      getImageData(image, col, row) {
        if (!pixelContext) {
          createPixelContext();
        }
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
          pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
          data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch {
          pixelContext = null;
          return null;
        }
        return data;
      }
      /**
       * @param {import('../../Map.js').FrameState} frameState Frame state.
       * @return {string} Background color.
       */
      getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === "function") {
          background = background(frameState.viewState.resolution);
        }
        return background || void 0;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS transform matrix.
       * @param {string} [backgroundColor] Background color.
       */
      useContainer(target, transform3, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context2;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals4(
          asArray(target.style.backgroundColor),
          asArray(backgroundColor)
        ))) {
          const canvas = target.firstElementChild;
          if (canvas instanceof HTMLCanvasElement) {
            context2 = canvas.getContext("2d");
          }
        }
        if (context2 && equivalent2(context2.canvas.style.transform, transform3)) {
          this.container = target;
          this.context = context2;
          this.containerReused = true;
        } else if (this.containerReused) {
          this.container = null;
          this.context = null;
          this.containerReused = false;
        } else if (this.container) {
          this.container.style.backgroundColor = null;
        }
        if (!this.container) {
          container = document.createElement("div");
          container.className = layerClassName;
          let style = container.style;
          style.position = "absolute";
          style.width = "100%";
          style.height = "100%";
          context2 = createCanvasContext2D();
          const canvas = context2.canvas;
          container.appendChild(canvas);
          style = canvas.style;
          style.position = "absolute";
          style.left = "0";
          style.transformOrigin = "top left";
          this.container = container;
          this.context = context2;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
          this.container.style.backgroundColor = backgroundColor;
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      clipUnrotated(context2, frameState, extent) {
        const topLeft = getTopLeft(extent);
        const topRight = getTopRight(extent);
        const bottomRight = getBottomRight(extent);
        const bottomLeft = getBottomLeft(extent);
        apply(frameState.coordinateToPixelTransform, topLeft);
        apply(frameState.coordinateToPixelTransform, topRight);
        apply(frameState.coordinateToPixelTransform, bottomRight);
        apply(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        apply(inverted, topLeft);
        apply(inverted, topRight);
        apply(inverted, bottomRight);
        apply(inverted, bottomLeft);
        context2.save();
        context2.beginPath();
        context2.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context2.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context2.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context2.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context2.clip();
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @protected
       */
      prepareContainer(frameState, target) {
        const extent = frameState.extent;
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const pixelRatio = frameState.pixelRatio;
        const width = Math.round(getWidth(extent) / resolution * pixelRatio);
        const height = Math.round(getHeight(extent) / resolution * pixelRatio);
        compose(
          this.pixelTransform,
          frameState.size[0] / 2,
          frameState.size[1] / 2,
          1 / pixelRatio,
          1 / pixelRatio,
          rotation,
          -width / 2,
          -height / 2
        );
        makeInverse(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = toString(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        if (!this.containerReused) {
          const canvas = this.context.canvas;
          if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
          } else {
            this.context.clearRect(0, 0, width, height);
          }
          if (canvasTransform !== canvas.style.transform) {
            canvas.style.transform = canvasTransform;
          }
        }
      }
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @private
       */
      dispatchRenderEvent_(type, context2, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
          const event = new Event_default2(
            type,
            this.inversePixelTransform,
            frameState,
            context2
          );
          layer.dispatchEvent(event);
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      preRender(context2, frameState) {
        this.frameState = frameState;
        if (frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(EventType_default2.PRERENDER, context2, frameState);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      postRender(context2, frameState) {
        if (frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context2, frameState);
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      renderDeferredInternal(frameState) {
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
       */
      getRenderContext(frameState) {
        if (frameState.declutter && !this.deferredContext_) {
          this.deferredContext_ = new ZIndexContext_default();
        }
        return frameState.declutter ? this.deferredContext_.getContext() : this.context;
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @override
       */
      renderDeferred(frameState) {
        if (!frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(
          EventType_default2.PRERENDER,
          this.context,
          frameState
        );
        if (frameState.declutter && this.deferredContext_) {
          this.deferredContext_.draw(this.context);
          this.deferredContext_.clear();
        }
        this.renderDeferredInternal(frameState);
        this.dispatchRenderEvent_(
          EventType_default2.POSTRENDER,
          this.context,
          frameState
        );
      }
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */
      getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return compose(
          this.tempTransform,
          dx1,
          dy1,
          sx,
          sy,
          -rotation,
          dx2,
          dy2
        );
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
      }
    };
    Layer_default2 = CanvasLayerRenderer;
  }
});

// node_modules/ol/renderer/canvas/TileLayer.js
function getCacheKey(source2, sourceKey, z, x, y) {
  return `${getUid(source2)},${sourceKey},${getKeyZXY(z, x, y)}`;
}
function addTileToLookup(tilesByZ, tile, z) {
  if (!(z in tilesByZ)) {
    tilesByZ[z] = /* @__PURE__ */ new Set([tile]);
    return true;
  }
  const set2 = tilesByZ[z];
  const existing = set2.has(tile);
  if (!existing) {
    set2.add(tile);
  }
  return !existing;
}
function removeTileFromLookup(tilesByZ, tile, z) {
  const set2 = tilesByZ[z];
  if (set2) {
    return set2.delete(tile);
  }
  return false;
}
function getRenderExtent(frameState, extent) {
  const layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent = getIntersection(
      extent,
      fromUserExtent(layerState.extent, frameState.viewState.projection)
    );
  }
  const source2 = (
    /** @type {import("../../source/Tile.js").default} */
    layerState.layer.getRenderSource()
  );
  if (!source2.getWrapX()) {
    const gridExtent = source2.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent = getIntersection(extent, gridExtent);
    }
  }
  return extent;
}
var CanvasTileLayerRenderer, TileLayer_default;
var init_TileLayer = __esm({
  "node_modules/ol/renderer/canvas/TileLayer.js"() {
    init_DataTile();
    init_ImageTile();
    init_TileRange();
    init_TileState();
    init_array();
    init_extent();
    init_proj();
    init_Tile2();
    init_size();
    init_LRUCache();
    init_tilecoord();
    init_transform();
    init_util();
    init_Layer2();
    CanvasTileLayerRenderer = class extends Layer_default2 {
      /**
       * @param {LayerType} tileLayer Tile layer.
       * @param {Options} [options] Options.
       */
      constructor(tileLayer, options2) {
        super(tileLayer);
        options2 = options2 || {};
        this.extentChanged = true;
        this.renderComplete = false;
        this.renderedExtent_ = null;
        this.renderedPixelRatio;
        this.renderedProjection = null;
        this.renderedTiles = [];
        this.renderedSourceKey_;
        this.renderedSourceRevision_;
        this.tempExtent = createEmpty();
        this.tempTileRange_ = new TileRange_default(0, 0, 0, 0);
        this.tempTileCoord_ = createOrUpdate3(0, 0, 0);
        const cacheSize2 = options2.cacheSize !== void 0 ? options2.cacheSize : 512;
        this.tileCache_ = new LRUCache_default(cacheSize2);
        this.maxStaleKeys = cacheSize2 * 0.5;
      }
      /**
       * @return {LRUCache} Tile cache.
       */
      getTileCache() {
        return this.tileCache_;
      }
      /**
       * Get a tile from the cache or create one if needed.
       *
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
       * @protected
       */
      getOrCreateTile(z, x, y, frameState) {
        const tileCache = this.tileCache_;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getSource();
        const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z, x, y);
        let tile;
        if (tileCache.containsKey(cacheKey)) {
          tile = tileCache.get(cacheKey);
        } else {
          tile = tileSource.getTile(
            z,
            x,
            y,
            frameState.pixelRatio,
            frameState.viewState.projection
          );
          if (!tile) {
            return null;
          }
          tileCache.set(cacheKey, tile);
        }
        return tile;
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
       * @protected
       */
      getTile(z, x, y, frameState) {
        const tile = this.getOrCreateTile(z, x, y, frameState);
        if (!tile) {
          return null;
        }
        return tile;
      }
      /**
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray} Data at the pixel location.
       * @override
       */
      getData(pixel) {
        const frameState = this.frameState;
        if (!frameState) {
          return null;
        }
        const layer = this.getLayer();
        const coordinate = apply(
          frameState.pixelToCoordinateTransform,
          pixel.slice()
        );
        const layerExtent = layer.getExtent();
        if (layerExtent) {
          if (!containsCoordinate(layerExtent, coordinate)) {
            return null;
          }
        }
        const viewState = frameState.viewState;
        const source2 = layer.getRenderSource();
        const tileGrid = source2.getTileGridForProjection(viewState.projection);
        const tilePixelRatio = source2.getTilePixelRatio(frameState.pixelRatio);
        for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
          const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
          const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);
          if (!tile || tile.getState() !== TileState_default.LOADED) {
            continue;
          }
          const tileOrigin = tileGrid.getOrigin(z);
          const tileSize = toSize(tileGrid.getTileSize(z));
          const tileResolution = tileGrid.getResolution(z);
          let image;
          if (tile instanceof ImageTile_default || tile instanceof Tile_default2) {
            image = tile.getImage();
          } else if (tile instanceof DataTile_default) {
            image = asImageLike(tile.getData());
            if (!image) {
              continue;
            }
          } else {
            continue;
          }
          const col = Math.floor(
            tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0])
          );
          const row = Math.floor(
            tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1])
          );
          const gutter = Math.round(
            tilePixelRatio * source2.getGutterForProjection(viewState.projection)
          );
          return this.getImageData(image, col + gutter, row + gutter);
        }
        return null;
      }
      /**
       * Determine whether render should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       * @override
       */
      prepareFrame(frameState) {
        if (!this.renderedProjection) {
          this.renderedProjection = frameState.viewState.projection;
        } else if (frameState.viewState.projection !== this.renderedProjection) {
          this.tileCache_.clear();
          this.renderedProjection = frameState.viewState.projection;
        }
        const source2 = this.getLayer().getSource();
        if (!source2) {
          return false;
        }
        const sourceRevision = source2.getRevision();
        if (!this.renderedSourceRevision_) {
          this.renderedSourceRevision_ = sourceRevision;
        } else if (this.renderedSourceRevision_ !== sourceRevision) {
          this.renderedSourceRevision_ = sourceRevision;
          if (this.renderedSourceKey_ === source2.getKey()) {
            this.tileCache_.clear();
          }
        }
        return true;
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent The extent to be rendered.
       * @param {number} initialZ The zoom level.
       * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
       * @param {number} preload Number of additional levels to load.
       */
      enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {
        const viewState = frameState.viewState;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getRenderSource();
        const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
        const tileSourceKey = getUid(tileSource);
        if (!(tileSourceKey in frameState.wantedTiles)) {
          frameState.wantedTiles[tileSourceKey] = {};
        }
        const wantedTiles = frameState.wantedTiles[tileSourceKey];
        const map = tileLayer.getMapInternal();
        const minZ = Math.max(
          initialZ - preload,
          tileGrid.getMinZoom(),
          tileGrid.getZForResolution(
            Math.min(
              tileLayer.getMaxResolution(),
              map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)
            ),
            tileSource.zDirection
          )
        );
        const rotation = viewState.rotation;
        const viewport2 = rotation ? getRotatedViewport(
          viewState.center,
          viewState.resolution,
          rotation,
          frameState.size
        ) : void 0;
        for (let z = initialZ; z >= minZ; --z) {
          const tileRange = tileGrid.getTileRangeForExtentAndZ(
            extent,
            z,
            this.tempTileRange_
          );
          const tileResolution = tileGrid.getResolution(z);
          for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
            for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
              if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport2)) {
                continue;
              }
              const tile = this.getTile(z, x, y, frameState);
              if (!tile) {
                continue;
              }
              const added = addTileToLookup(tilesByZ, tile, z);
              if (!added) {
                continue;
              }
              const tileQueueKey = tile.getKey();
              wantedTiles[tileQueueKey] = true;
              if (tile.getState() === TileState_default.IDLE) {
                if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
                  const tileCoord = createOrUpdate3(z, x, y, this.tempTileCoord_);
                  frameState.tileQueue.enqueue([
                    tile,
                    tileSourceKey,
                    tileGrid.getTileCoordCenter(tileCoord),
                    tileResolution
                  ]);
                }
              }
            }
          }
        }
      }
      /**
       * Look for tiles covering the provided tile coordinate at an alternate
       * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
       * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
       * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
       * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
       * @private
       */
      findStaleTile_(tileCoord, tilesByZ) {
        const tileCache = this.tileCache_;
        const z = tileCoord[0];
        const x = tileCoord[1];
        const y = tileCoord[2];
        const staleKeys = this.getStaleKeys();
        for (let i = 0; i < staleKeys.length; ++i) {
          const cacheKey = getCacheKey(
            this.getLayer().getSource(),
            staleKeys[i],
            z,
            x,
            y
          );
          if (tileCache.containsKey(cacheKey)) {
            const tile = tileCache.peek(cacheKey);
            if (tile.getState() === TileState_default.LOADED) {
              tile.endTransition(getUid(this));
              addTileToLookup(tilesByZ, tile, z);
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Look for tiles covering the provided tile coordinate at an alternate
       * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
       * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
       * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
       * @param {number} altZ The alternate zoom level.
       * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
       * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
       * @private
       */
      findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {
        const tileRange = tileGrid.getTileRangeForTileCoordAndZ(
          tileCoord,
          altZ,
          this.tempTileRange_
        );
        if (!tileRange) {
          return false;
        }
        let covered = true;
        const tileCache = this.tileCache_;
        const source2 = this.getLayer().getRenderSource();
        const sourceKey = source2.getKey();
        for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
          for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
            const cacheKey = getCacheKey(source2, sourceKey, altZ, x, y);
            let loaded = false;
            if (tileCache.containsKey(cacheKey)) {
              const tile = tileCache.peek(cacheKey);
              if (tile.getState() === TileState_default.LOADED) {
                addTileToLookup(tilesByZ, tile, altZ);
                loaded = true;
              }
            }
            if (!loaded) {
              covered = false;
            }
          }
        }
        return covered;
      }
      /**
       * Render the layer.
       *
       * The frame rendering logic has three parts:
       *
       *  1. Enqueue tiles
       *  2. Find alt tiles for those that are not yet loaded
       *  3. Render loaded tiles
       *
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       * @override
       */
      renderFrame(frameState, target) {
        this.renderComplete = true;
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const viewResolution = viewState.resolution;
        const viewCenter = viewState.center;
        const pixelRatio = frameState.pixelRatio;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getSource();
        const tileGrid = tileSource.getTileGridForProjection(projection);
        const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
        const tileResolution = tileGrid.getResolution(z);
        const sourceKey = tileSource.getKey();
        if (!this.renderedSourceKey_) {
          this.renderedSourceKey_ = sourceKey;
        } else if (this.renderedSourceKey_ !== sourceKey) {
          this.prependStaleKey(this.renderedSourceKey_);
          this.renderedSourceKey_ = sourceKey;
        }
        let frameExtent = frameState.extent;
        const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
        this.prepareContainer(frameState, target);
        const width = this.context.canvas.width;
        const height = this.context.canvas.height;
        const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
        if (layerExtent) {
          frameExtent = getIntersection(
            frameExtent,
            fromUserExtent(layerState.extent, projection)
          );
        }
        const dx = tileResolution * width / 2 / tilePixelRatio;
        const dy = tileResolution * height / 2 / tilePixelRatio;
        const canvasExtent = [
          viewCenter[0] - dx,
          viewCenter[1] - dy,
          viewCenter[0] + dx,
          viewCenter[1] + dy
        ];
        const tilesByZ = {};
        this.renderedTiles.length = 0;
        const preload = tileLayer.getPreload();
        if (frameState.nextExtent) {
          const targetZ = tileGrid.getZForResolution(
            viewState.nextResolution,
            tileSource.zDirection
          );
          const nextExtent = getRenderExtent(frameState, frameState.nextExtent);
          this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);
        }
        const renderExtent = getRenderExtent(frameState, frameExtent);
        this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);
        if (preload > 0) {
          setTimeout(() => {
            this.enqueueTiles(
              frameState,
              renderExtent,
              z - 1,
              tilesByZ,
              preload - 1
            );
          }, 0);
        }
        if (!(z in tilesByZ)) {
          return this.container;
        }
        const uid = getUid(this);
        const time = frameState.time;
        for (const tile of tilesByZ[z]) {
          const tileState = tile.getState();
          if (tileState === TileState_default.EMPTY) {
            continue;
          }
          const tileCoord = tile.tileCoord;
          if (tileState === TileState_default.LOADED) {
            const alpha = tile.getAlpha(uid, time);
            if (alpha === 1) {
              tile.endTransition(uid);
              continue;
            }
          }
          if (tileState !== TileState_default.ERROR) {
            this.renderComplete = false;
          }
          const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);
          if (hasStaleTile) {
            removeTileFromLookup(tilesByZ, tile, z);
            frameState.animate = true;
            continue;
          }
          const coveredByChildren = this.findAltTiles_(
            tileGrid,
            tileCoord,
            z + 1,
            tilesByZ
          );
          if (coveredByChildren) {
            continue;
          }
          const minZoom = tileGrid.getMinZoom();
          for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {
            const coveredByParent = this.findAltTiles_(
              tileGrid,
              tileCoord,
              parentZ,
              tilesByZ
            );
            if (coveredByParent) {
              break;
            }
          }
        }
        const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
        const context2 = this.getRenderContext(frameState);
        compose(
          this.tempTransform,
          width / 2,
          height / 2,
          canvasScale,
          canvasScale,
          0,
          -width / 2,
          -height / 2
        );
        if (layerState.extent) {
          this.clipUnrotated(context2, frameState, layerExtent);
        }
        if (!tileSource.getInterpolate()) {
          context2.imageSmoothingEnabled = false;
        }
        this.preRender(context2, frameState);
        const zs = Object.keys(tilesByZ).map(Number);
        zs.sort(ascending);
        let currentClip;
        const clips = [];
        const clipZs = [];
        for (let i = zs.length - 1; i >= 0; --i) {
          const currentZ = zs[i];
          const currentTilePixelSize = tileSource.getTilePixelSize(
            currentZ,
            pixelRatio,
            projection
          );
          const currentResolution = tileGrid.getResolution(currentZ);
          const currentScale = currentResolution / tileResolution;
          const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
          const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
          const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
            getTopLeft(canvasExtent),
            currentZ
          );
          const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
          const origin = apply(this.tempTransform, [
            tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
            tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
          ]);
          const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
          for (const tile of tilesByZ[currentZ]) {
            if (tile.getState() !== TileState_default.LOADED) {
              continue;
            }
            const tileCoord = tile.tileCoord;
            const xIndex = originTileCoord[1] - tileCoord[1];
            const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
            const yIndex = originTileCoord[2] - tileCoord[2];
            const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
            const x = Math.round(origin[0] - xIndex * dx2);
            const y = Math.round(origin[1] - yIndex * dy2);
            const w = nextX - x;
            const h = nextY - y;
            const transition = zs.length === 1;
            let contextSaved = false;
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
            for (let i2 = 0, ii = clips.length; i2 < ii; ++i2) {
              if (!transition && currentZ < clipZs[i2]) {
                const clip = clips[i2];
                if (intersects(
                  [x, y, x + w, y + h],
                  [clip[0], clip[3], clip[4], clip[7]]
                )) {
                  if (!contextSaved) {
                    context2.save();
                    contextSaved = true;
                  }
                  context2.beginPath();
                  context2.moveTo(currentClip[0], currentClip[1]);
                  context2.lineTo(currentClip[2], currentClip[3]);
                  context2.lineTo(currentClip[4], currentClip[5]);
                  context2.lineTo(currentClip[6], currentClip[7]);
                  context2.moveTo(clip[6], clip[7]);
                  context2.lineTo(clip[4], clip[5]);
                  context2.lineTo(clip[2], clip[3]);
                  context2.lineTo(clip[0], clip[1]);
                  context2.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
            this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);
            if (contextSaved) {
              context2.restore();
            }
            this.renderedTiles.unshift(tile);
            this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
          }
        }
        this.renderedResolution = tileResolution;
        this.extentChanged = !this.renderedExtent_ || !equals2(this.renderedExtent_, canvasExtent);
        this.renderedExtent_ = canvasExtent;
        this.renderedPixelRatio = pixelRatio;
        this.postRender(this.context, frameState);
        if (layerState.extent) {
          context2.restore();
        }
        context2.imageSmoothingEnabled = true;
        if (this.renderComplete) {
          const postRenderFunction = (map, frameState2) => {
            const tileSourceKey = getUid(tileSource);
            const wantedTiles = frameState2.wantedTiles[tileSourceKey];
            const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;
            this.updateCacheSize(tilesCount);
            this.tileCache_.expireCache();
          };
          frameState.postRenderFunctions.push(postRenderFunction);
        }
        return this.container;
      }
      /**
       * Increases the cache size if needed
       * @param {number} tileCount Minimum number of tiles needed.
       */
      updateCacheSize(tileCount) {
        this.tileCache_.highWaterMark = Math.max(
          this.tileCache_.highWaterMark,
          tileCount * 2
        );
      }
      /**
       * @param {import("../../Tile.js").default} tile Tile.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {number} x Left of the tile.
       * @param {number} y Top of the tile.
       * @param {number} w Width of the tile.
       * @param {number} h Height of the tile.
       * @param {number} gutter Tile gutter.
       * @param {boolean} transition Apply an alpha transition.
       * @protected
       */
      drawTile(tile, frameState, x, y, w, h, gutter, transition) {
        let image;
        if (tile instanceof DataTile_default) {
          image = asImageLike(tile.getData());
          if (!image) {
            throw new Error("Rendering array data is not yet supported");
          }
        } else {
          image = this.getTileImage(
            /** @type {import("../../ImageTile.js").default} */
            tile
          );
        }
        if (!image) {
          return;
        }
        const context2 = this.getRenderContext(frameState);
        const uid = getUid(this);
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
        const alphaChanged = alpha !== context2.globalAlpha;
        if (alphaChanged) {
          context2.save();
          context2.globalAlpha = alpha;
        }
        context2.drawImage(
          image,
          gutter,
          gutter,
          image.width - 2 * gutter,
          image.height - 2 * gutter,
          x,
          y,
          w,
          h
        );
        if (alphaChanged) {
          context2.restore();
        }
        if (alpha !== layerState.opacity) {
          frameState.animate = true;
        } else if (transition) {
          tile.endTransition(uid);
        }
      }
      /**
       * @return {HTMLCanvasElement} Image
       */
      getImage() {
        const context2 = this.context;
        return context2 ? context2.canvas : null;
      }
      /**
       * Get the image from a tile.
       * @param {import("../../ImageTile.js").default} tile Tile.
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @protected
       */
      getTileImage(tile) {
        return tile.getImage();
      }
      /**
       * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import('../../Tile.js').default} tile Tile.
       * @protected
       */
      updateUsedTiles(usedTiles, tileSource, tile) {
        const tileSourceKey = getUid(tileSource);
        if (!(tileSourceKey in usedTiles)) {
          usedTiles[tileSourceKey] = {};
        }
        usedTiles[tileSourceKey][tile.getKey()] = true;
      }
    };
    TileLayer_default = CanvasTileLayerRenderer;
  }
});

// node_modules/ol/ViewHint.js
var ViewHint_default;
var init_ViewHint = __esm({
  "node_modules/ol/ViewHint.js"() {
    ViewHint_default = {
      ANIMATING: 0,
      INTERACTING: 1
    };
  }
});

// node_modules/ol/ViewProperty.js
var ViewProperty_default;
var init_ViewProperty = __esm({
  "node_modules/ol/ViewProperty.js"() {
    ViewProperty_default = {
      CENTER: "center",
      RESOLUTION: "resolution",
      ROTATION: "rotation"
    };
  }
});

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x = clamp(center[0], minX, maxX);
      let y = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    }
  );
}
function none(center) {
  return center;
}
var init_centerconstraint = __esm({
  "node_modules/ol/centerconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return void 0;
    }
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    }
  );
}
var init_resolutionconstraint = __esm({
  "node_modules/ol/resolutionconstraint.js"() {
    init_array();
    init_extent();
    init_math();
  }
});

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n2) {
  const theta = 2 * Math.PI / n2;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    }
  );
}
function createSnapToZero(tolerance) {
  const t2 = tolerance === void 0 ? toRadians(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t2) {
        return 0;
      }
      return rotation;
    }
  );
}
var init_rotationconstraint = __esm({
  "node_modules/ol/rotationconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/tilegrid/common.js
var DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE;
var init_common2 = __esm({
  "node_modules/ol/tilegrid/common.js"() {
    DEFAULT_MAX_ZOOM = 42;
    DEFAULT_TILE_SIZE = 256;
  }
});

// node_modules/ol/View.js
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options2) {
  if (options2.extent !== void 0) {
    const smooth = options2.smoothExtentConstraint !== void 0 ? options2.smoothExtentConstraint : true;
    return createExtent(options2.extent, options2.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options2.projection, "EPSG:3857");
  if (options2.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options2) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options2.minZoom !== void 0 ? options2.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options2.maxZoom !== void 0 ? options2.maxZoom : defaultMaxZoom;
  const zoomFactor = options2.zoomFactor !== void 0 ? options2.zoomFactor : defaultZoomFactor;
  const multiWorld = options2.multiWorld !== void 0 ? options2.multiWorld : false;
  const smooth = options2.smoothResolutionConstraint !== void 0 ? options2.smoothResolutionConstraint : true;
  const showFullExtent = options2.showFullExtent !== void 0 ? options2.showFullExtent : false;
  const projection = createProjection(options2.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options2.constrainOnlyCenter;
  let extent = options2.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options2.resolutions !== void 0) {
    const resolutions = options2.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options2.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options2.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options2.minResolution;
    if (minResolution === void 0) {
      if (options2.maxZoom !== void 0) {
        if (options2.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options2.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options2) {
  const enableRotation = options2.enableRotation !== void 0 ? options2.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options2.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals3(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var DEFAULT_MIN_ZOOM, View, View_default;
var init_View = __esm({
  "node_modules/ol/View.js"() {
    init_Object();
    init_ViewHint();
    init_ViewProperty();
    init_array();
    init_asserts();
    init_centerconstraint();
    init_coordinate();
    init_easing();
    init_extent();
    init_functions();
    init_Polygon();
    init_math();
    init_proj();
    init_resolutionconstraint();
    init_rotationconstraint();
    init_common2();
    DEFAULT_MIN_ZOOM = 0;
    View = class extends Object_default {
      /**
       * @param {ViewOptions} [options] View options.
       */
      constructor(options2) {
        super();
        this.on;
        this.once;
        this.un;
        options2 = Object.assign({}, options2);
        this.hints_ = [0, 0];
        this.animations_ = [];
        this.updateAnimationKey_;
        this.projection_ = createProjection(options2.projection, "EPSG:3857");
        this.viewportSize_ = [100, 100];
        this.targetCenter_ = null;
        this.targetResolution_;
        this.targetRotation_;
        this.nextCenter_ = null;
        this.nextResolution_;
        this.nextRotation_;
        this.cancelAnchor_ = void 0;
        if (options2.projection) {
          disableCoordinateWarning();
        }
        if (options2.center) {
          options2.center = fromUserCoordinate(options2.center, this.projection_);
        }
        if (options2.extent) {
          options2.extent = fromUserExtent(options2.extent, this.projection_);
        }
        this.applyOptions_(options2);
      }
      /**
       * Set up the view with the given options.
       * @param {ViewOptions} options View options.
       */
      applyOptions_(options2) {
        const properties = Object.assign({}, options2);
        for (const key2 in ViewProperty_default) {
          delete properties[key2];
        }
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options2);
        this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        this.minResolution_ = resolutionConstraintInfo.minResolution;
        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        this.resolutions_ = options2.resolutions;
        this.padding_ = options2.padding;
        this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options2);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options2);
        this.constraints_ = {
          center: centerConstraint,
          resolution: resolutionConstraint,
          rotation: rotationConstraint
        };
        this.setRotation(options2.rotation !== void 0 ? options2.rotation : 0);
        this.setCenterInternal(
          options2.center !== void 0 ? options2.center : null
        );
        if (options2.resolution !== void 0) {
          this.setResolution(options2.resolution);
        } else if (options2.zoom !== void 0) {
          this.setZoom(options2.zoom);
        }
      }
      /**
       * Padding (in css pixels).
       * If the map viewport is partially covered with other content (overlays) along
       * its edges, this setting allows to shift the center of the viewport away from that
       * content. The order of the values in the array is top, right, bottom, left.
       * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
       * @type {Array<number>|undefined}
       * @api
       */
      get padding() {
        return this.padding_;
      }
      set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenterInternal();
        if (center) {
          const newPadding = padding || [0, 0, 0, 0];
          oldPadding = oldPadding || [0, 0, 0, 0];
          const resolution = this.getResolution();
          const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
          const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
          this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
        }
      }
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */
      getUpdatedOptions_(newOptions) {
        const options2 = this.getProperties();
        if (options2.resolution !== void 0) {
          options2.resolution = this.getResolution();
        } else {
          options2.zoom = this.getZoom();
        }
        options2.center = this.getCenterInternal();
        options2.rotation = this.getRotation();
        return Object.assign({}, options2, newOptions);
      }
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      animate(var_args) {
        if (this.isDef() && !this.getAnimating()) {
          this.resolveConstraints(0);
        }
        const args = new Array(arguments.length);
        for (let i = 0; i < args.length; ++i) {
          let options2 = arguments[i];
          if (options2.center) {
            options2 = Object.assign({}, options2);
            options2.center = fromUserCoordinate(
              options2.center,
              this.getProjection()
            );
          }
          if (options2.anchor) {
            options2 = Object.assign({}, options2);
            options2.anchor = fromUserCoordinate(
              options2.anchor,
              this.getProjection()
            );
          }
          args[i] = options2;
        }
        this.animateInternal.apply(this, args);
      }
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */
      animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
          callback = arguments[animationCount - 1];
          --animationCount;
        }
        let i = 0;
        for (; i < animationCount && !this.isDef(); ++i) {
          const state2 = arguments[i];
          if (state2.center) {
            this.setCenterInternal(state2.center);
          }
          if (state2.zoom !== void 0) {
            this.setZoom(state2.zoom);
          } else if (state2.resolution) {
            this.setResolution(state2.resolution);
          }
          if (state2.rotation !== void 0) {
            this.setRotation(state2.rotation);
          }
        }
        if (i === animationCount) {
          if (callback) {
            animationCallback(callback, true);
          }
          return;
        }
        let start2 = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for (; i < animationCount; ++i) {
          const options2 = (
            /** @type {AnimationOptions} */
            arguments[i]
          );
          const animation = {
            start: start2,
            complete: false,
            anchor: options2.anchor,
            duration: options2.duration !== void 0 ? options2.duration : 1e3,
            easing: options2.easing || inAndOut,
            callback
          };
          if (options2.center) {
            animation.sourceCenter = center;
            animation.targetCenter = options2.center.slice();
            center = animation.targetCenter;
          }
          if (options2.zoom !== void 0) {
            animation.sourceResolution = resolution;
            animation.targetResolution = this.getResolutionForZoom(options2.zoom);
            resolution = animation.targetResolution;
          } else if (options2.resolution) {
            animation.sourceResolution = resolution;
            animation.targetResolution = options2.resolution;
            resolution = animation.targetResolution;
          }
          if (options2.rotation !== void 0) {
            animation.sourceRotation = rotation;
            const delta = modulo(options2.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
            animation.targetRotation = rotation + delta;
            rotation = animation.targetRotation;
          }
          if (isNoopAnimation(animation)) {
            animation.complete = true;
          } else {
            start2 += animation.duration;
          }
          series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(ViewHint_default.ANIMATING, 1);
        this.updateAnimations_();
      }
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      getAnimating() {
        return this.hints_[ViewHint_default.ANIMATING] > 0;
      }
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      getInteracting() {
        return this.hints_[ViewHint_default.INTERACTING] > 0;
      }
      /**
       * Cancel any ongoing animations.
       * @api
       */
      cancelAnimations() {
        this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
        let anchor;
        for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
          const series = this.animations_[i];
          if (series[0].callback) {
            animationCallback(series[0].callback, false);
          }
          if (!anchor) {
            for (let j = 0, jj = series.length; j < jj; ++j) {
              const animation = series[j];
              if (!animation.complete) {
                anchor = animation.anchor;
                break;
              }
            }
          }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
      }
      /**
       * Update all animations.
       */
      updateAnimations_() {
        if (this.updateAnimationKey_ !== void 0) {
          cancelAnimationFrame(this.updateAnimationKey_);
          this.updateAnimationKey_ = void 0;
        }
        if (!this.getAnimating()) {
          return;
        }
        const now = Date.now();
        let more = false;
        for (let i = this.animations_.length - 1; i >= 0; --i) {
          const series = this.animations_[i];
          let seriesComplete = true;
          for (let j = 0, jj = series.length; j < jj; ++j) {
            const animation = series[j];
            if (animation.complete) {
              continue;
            }
            const elapsed = now - animation.start;
            let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
            if (fraction >= 1) {
              animation.complete = true;
              fraction = 1;
            } else {
              seriesComplete = false;
            }
            const progress = animation.easing(fraction);
            if (animation.sourceCenter) {
              const x0 = animation.sourceCenter[0];
              const y0 = animation.sourceCenter[1];
              const x1 = animation.targetCenter[0];
              const y1 = animation.targetCenter[1];
              this.nextCenter_ = animation.targetCenter;
              const x = x0 + progress * (x1 - x0);
              const y = y0 + progress * (y1 - y0);
              this.targetCenter_ = [x, y];
            }
            if (animation.sourceResolution && animation.targetResolution) {
              const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
              if (animation.anchor) {
                const size = this.getViewportSize_(this.getRotation());
                const constrainedResolution = this.constraints_.resolution(
                  resolution,
                  0,
                  size,
                  true
                );
                this.targetCenter_ = this.calculateCenterZoom(
                  constrainedResolution,
                  animation.anchor
                );
              }
              this.nextResolution_ = animation.targetResolution;
              this.targetResolution_ = resolution;
              this.applyTargetState_(true);
            }
            if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
              const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
              if (animation.anchor) {
                const constrainedRotation = this.constraints_.rotation(
                  rotation,
                  true
                );
                this.targetCenter_ = this.calculateCenterRotate(
                  constrainedRotation,
                  animation.anchor
                );
              }
              this.nextRotation_ = animation.targetRotation;
              this.targetRotation_ = rotation;
            }
            this.applyTargetState_(true);
            more = true;
            if (!animation.complete) {
              break;
            }
          }
          if (seriesComplete) {
            this.animations_[i] = null;
            this.setHint(ViewHint_default.ANIMATING, -1);
            this.nextCenter_ = null;
            this.nextResolution_ = NaN;
            this.nextRotation_ = NaN;
            const callback = series[0].callback;
            if (callback) {
              animationCallback(callback, true);
            }
          }
        }
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === void 0) {
          this.updateAnimationKey_ = requestAnimationFrame(
            this.updateAnimations_.bind(this)
          );
        }
      }
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */
      calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== void 0) {
          center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
          rotate(center, rotation - this.getRotation());
          add(center, anchor);
        }
        return center;
      }
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */
      calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== void 0 && currentResolution !== void 0) {
          const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
          const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
          center = [x, y];
        }
        return center;
      }
      /**
       * Returns the current viewport size.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
          const w = size[0];
          const h = size[1];
          return [
            Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
            Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
          ];
        }
        return size;
      }
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
       */
      setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
        if (!this.getAnimating()) {
          this.resolveConstraints(0);
        }
      }
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      getCenter() {
        const center = this.getCenterInternal();
        if (!center) {
          return center;
        }
        return toUserCoordinate(center, this.getProjection());
      }
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */
      getCenterInternal() {
        return (
          /** @type {import("./coordinate.js").Coordinate|undefined} */
          this.get(ViewProperty_default.CENTER)
        );
      }
      /**
       * @return {Constraints} Constraints.
       */
      getConstraints() {
        return this.constraints_;
      }
      /**
       * @return {boolean} Resolution constraint is set
       */
      getConstrainResolution() {
        return this.get("constrainResolution");
      }
      /**
       * @param {Array<number>} [hints] Destination array.
       * @return {Array<number>} Hint.
       */
      getHints(hints) {
        if (hints !== void 0) {
          hints[0] = this.hints_[0];
          hints[1] = this.hints_[1];
          return hints;
        }
        return this.hints_.slice();
      }
      /**
       * Calculate the extent for the current view state and the passed box size.
       * @param {import("./size.js").Size} [size] The pixel dimensions of the box
       * into which the calculated extent should fit. Defaults to the size of the
       * map the view is associated with.
       * If no map or multiple maps are connected to the view, provide the desired
       * box size (e.g. `map.getSize()`).
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */
      calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return toUserExtent(extent, this.getProjection());
      }
      /**
       * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
       * the map's last known viewport size will be used.
       * @return {import("./extent.js").Extent} Extent.
       */
      calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = (
          /** @type {!import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        assert(center, "The view center is not defined");
        const resolution = (
          /** @type {!number} */
          this.getResolution()
        );
        assert(resolution !== void 0, "The view resolution is not defined");
        const rotation = (
          /** @type {!number} */
          this.getRotation()
        );
        assert(rotation !== void 0, "The view rotation is not defined");
        return getForViewAndSize(center, resolution, rotation, size);
      }
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      getMaxResolution() {
        return this.maxResolution_;
      }
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      getMinResolution() {
        return this.minResolution_;
      }
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.minResolution_)
        );
      }
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
      }
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.maxResolution_)
        );
      }
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
      }
      /**
       * Set whether the view should allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */
      setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
      }
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */
      getProjection() {
        return this.projection_;
      }
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      getResolution() {
        return (
          /** @type {number|undefined} */
          this.get(ViewProperty_default.RESOLUTION)
        );
      }
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */
      getResolutions() {
        return this.resolutions_;
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal(
          fromUserExtent(extent, this.getProjection()),
          size
        );
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */
      getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = getWidth(extent) / size[0];
        const yResolution = getHeight(extent) / size[1];
        return Math.max(xResolution, yResolution);
      }
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Resolution for value function.
       */
      getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
          }
        );
      }
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      getRotation() {
        return (
          /** @type {number} */
          this.get(ViewProperty_default.ROTATION)
        );
      }
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Value for resolution function.
       */
      getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
          }
        );
      }
      /**
       * Returns the size of the viewport minus padding.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size reduced by the padding.
       */
      getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) {
          size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
          ];
        }
        return size;
      }
      /**
       * @return {State} View state.
       */
      getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = (
          /** @type {import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        const padding = this.padding_;
        if (padding) {
          const reducedSize = this.getViewportSizeMinusPadding_();
          center = calculateCenterOn(
            center,
            this.getViewportSize_(),
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
        }
        return {
          center: center.slice(0),
          projection: projection !== void 0 ? projection : null,
          resolution,
          nextCenter: this.nextCenter_,
          nextResolution: this.nextResolution_,
          nextRotation: this.nextRotation_,
          rotation,
          zoom: this.getZoom()
        };
      }
      /**
       * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
       */
      getViewStateAndExtent() {
        return {
          viewState: this.getState(),
          extent: this.calculateExtent()
        };
      }
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */
      getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== void 0) {
          zoom = this.getZoomForResolution(resolution);
        }
        return zoom;
      }
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      getZoomForResolution(resolution) {
        let offset = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
          const nearest = linearFindNearest(this.resolutions_, resolution, 1);
          offset = nearest;
          max = this.resolutions_[nearest];
          if (nearest == this.resolutions_.length - 1) {
            zoomFactor = 2;
          } else {
            zoomFactor = max / this.resolutions_[nearest + 1];
          }
        } else {
          max = this.maxResolution_;
          zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
      }
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      getResolutionForZoom(zoom) {
        if (this.resolutions_?.length) {
          if (this.resolutions_.length === 1) {
            return this.resolutions_[0];
          }
          const baseLevel = clamp(
            Math.floor(zoom),
            0,
            this.resolutions_.length - 2
          );
          const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
          return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
      }
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions} [options] Options.
       * @api
       */
      fit(geometryOrExtent, options2) {
        let geometry;
        assert(
          Array.isArray(geometryOrExtent) || typeof /** @type {?} */
          geometryOrExtent.getSimplifiedGeometry === "function",
          "Invalid extent or geometry provided as `geometry`"
        );
        if (Array.isArray(geometryOrExtent)) {
          assert(
            !isEmpty(geometryOrExtent),
            "Cannot fit empty extent provided as `geometry`"
          );
          const extent = fromUserExtent(geometryOrExtent, this.getProjection());
          geometry = fromExtent(extent);
        } else if (geometryOrExtent.getType() === "Circle") {
          const extent = fromUserExtent(
            geometryOrExtent.getExtent(),
            this.getProjection()
          );
          geometry = fromExtent(extent);
          geometry.rotate(this.getRotation(), getCenter(extent));
        } else {
          const userProjection2 = getUserProjection();
          if (userProjection2) {
            geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
            geometryOrExtent.clone().transform(userProjection2, this.getProjection());
          } else {
            geometry = geometryOrExtent;
          }
        }
        this.fitInternal(geometry, options2);
      }
      /**
       * Calculate rotated extent
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @return {import("./extent").Extent} The rotated extent for the geometry.
       */
      rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = Infinity;
        let minRotY = Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for (let i = 0, ii = coords.length; i < ii; i += stride) {
          const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
          const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
          minRotX = Math.min(minRotX, rotX);
          minRotY = Math.min(minRotY, rotY);
          maxRotX = Math.max(maxRotX, rotX);
          maxRotY = Math.max(maxRotY, rotY);
        }
        return [minRotX, minRotY, maxRotX, maxRotY];
      }
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions} [options] Options.
       */
      fitInternal(geometry, options2) {
        options2 = options2 || {};
        let size = options2.size;
        if (!size) {
          size = this.getViewportSizeMinusPadding_();
        }
        const padding = options2.padding !== void 0 ? options2.padding : [0, 0, 0, 0];
        const nearest = options2.nearest !== void 0 ? options2.nearest : false;
        let minResolution;
        if (options2.minResolution !== void 0) {
          minResolution = options2.minResolution;
        } else if (options2.maxZoom !== void 0) {
          minResolution = this.getResolutionForZoom(options2.maxZoom);
        } else {
          minResolution = 0;
        }
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
          size[0] - padding[1] - padding[3],
          size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = getCenter(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([centerX, centerY], resolution);
        const callback = options2.callback ? options2.callback : VOID;
        if (options2.duration !== void 0) {
          this.animateInternal(
            {
              resolution,
              center,
              duration: options2.duration,
              easing: options2.easing
            },
            callback
          );
        } else {
          this.targetResolution_ = resolution;
          this.targetCenter_ = center;
          this.applyTargetState_(false, true);
          animationCallback(callback, true);
        }
      }
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */
      centerOn(coordinate, size, position) {
        this.centerOnInternal(
          fromUserCoordinate(coordinate, this.getProjection()),
          size,
          position
        );
      }
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */
      centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(
          calculateCenterOn(
            coordinate,
            size,
            position,
            this.getResolution(),
            this.getRotation()
          )
        );
      }
      /**
       * Calculates the shift between map and viewport center.
       * @param {import("./coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {import("./size.js").Size} size Size.
       * @return {Array<number>|undefined} Center shift.
       */
      calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
          const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
          const shiftedCenter = calculateCenterOn(
            center,
            size,
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
          centerShift = [
            center[0] - shiftedCenter[0],
            center[1] - shiftedCenter[1]
          ];
        }
        return centerShift;
      }
      /**
       * @return {boolean} Is defined.
       */
      isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== void 0;
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */
      adjustCenter(deltaCoordinates) {
        const center = toUserCoordinate(this.targetCenter_, this.getProjection());
        this.setCenter([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */
      adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustResolution(ratio, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(
          this.targetResolution_ * ratio,
          0,
          size,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        }
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
      }
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
      }
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       * @api
       */
      adjustRotation(delta, anchor) {
        if (anchor) {
          anchor = fromUserCoordinate(anchor, this.getProjection());
        }
        this.adjustRotationInternal(delta, anchor);
      }
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       */
      adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(
          this.targetRotation_ + delta,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        }
        this.targetRotation_ += delta;
        this.applyTargetState_();
      }
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      setCenter(center) {
        this.setCenterInternal(
          center ? fromUserCoordinate(center, this.getProjection()) : center
        );
      }
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */
      setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
      }
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
      }
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
      }
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
      }
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */
      setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
      }
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean} [doNotCancelAnims] Do not cancel animations.
       * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
       * @private
       */
      applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        const newRotation = this.constraints_.rotation(
          this.targetRotation_,
          isMoving
        );
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          0,
          size,
          isMoving
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          isMoving,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
          this.set(ViewProperty_default.ROTATION, newRotation);
        }
        if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
          this.set(ViewProperty_default.RESOLUTION, newResolution);
          this.set("zoom", this.getZoom(), true);
        }
        if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
          this.set(ViewProperty_default.CENTER, newCenter);
        }
        if (this.getAnimating() && !doNotCancelAnims) {
          this.cancelAnimations();
        }
        this.cancelAnchor_ = void 0;
      }
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number} [duration] The animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== void 0 ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          direction,
          size
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          false,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (duration === 0 && !this.cancelAnchor_) {
          this.targetResolution_ = newResolution;
          this.targetRotation_ = newRotation;
          this.targetCenter_ = newCenter;
          this.applyTargetState_();
          return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
        this.cancelAnchor_ = void 0;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
          if (this.getAnimating()) {
            this.cancelAnimations();
          }
          this.animateInternal({
            rotation: newRotation,
            center: newCenter,
            resolution: newResolution,
            duration,
            easing: easeOut,
            anchor
          });
        }
      }
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */
      beginInteraction() {
        this.resolveConstraints(0);
        this.setHint(ViewHint_default.INTERACTING, 1);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      endInteractionInternal(duration, resolutionDirection, anchor) {
        if (!this.getInteracting()) {
          return;
        }
        this.setHint(ViewHint_default.INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
      }
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */
      getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(
          targetCenter,
          targetResolution || this.getResolution(),
          size
        );
      }
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number} [direction] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */
      getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(
          this.getConstrainedResolution(targetRes, direction)
        );
      }
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number} [direction] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */
      getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
      }
    };
    View_default = View;
  }
});

// node_modules/ol/layer/Property.js
var Property_default;
var init_Property = __esm({
  "node_modules/ol/layer/Property.js"() {
    Property_default = {
      OPACITY: "opacity",
      VISIBLE: "visible",
      EXTENT: "extent",
      Z_INDEX: "zIndex",
      MAX_RESOLUTION: "maxResolution",
      MIN_RESOLUTION: "minResolution",
      MAX_ZOOM: "maxZoom",
      MIN_ZOOM: "minZoom",
      SOURCE: "source",
      MAP: "map"
    };
  }
});

// node_modules/ol/layer/Base.js
var BaseLayer, Base_default;
var init_Base = __esm({
  "node_modules/ol/layer/Base.js"() {
    init_Object();
    init_asserts();
    init_math();
    init_util();
    init_Property();
    BaseLayer = class extends Object_default {
      /**
       * @param {Options} options Layer options.
       */
      constructor(options2) {
        super();
        this.on;
        this.once;
        this.un;
        this.background_ = options2.background;
        const properties = Object.assign({}, options2);
        if (typeof options2.properties === "object") {
          delete properties.properties;
          Object.assign(properties, options2.properties);
        }
        properties[Property_default.OPACITY] = options2.opacity !== void 0 ? options2.opacity : 1;
        assert(
          typeof properties[Property_default.OPACITY] === "number",
          "Layer opacity must be a number"
        );
        properties[Property_default.VISIBLE] = options2.visible !== void 0 ? options2.visible : true;
        properties[Property_default.Z_INDEX] = options2.zIndex;
        properties[Property_default.MAX_RESOLUTION] = options2.maxResolution !== void 0 ? options2.maxResolution : Infinity;
        properties[Property_default.MIN_RESOLUTION] = options2.minResolution !== void 0 ? options2.minResolution : 0;
        properties[Property_default.MIN_ZOOM] = options2.minZoom !== void 0 ? options2.minZoom : -Infinity;
        properties[Property_default.MAX_ZOOM] = options2.maxZoom !== void 0 ? options2.maxZoom : Infinity;
        this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
        delete properties.className;
        this.setProperties(properties);
        this.state_ = null;
      }
      /**
       * Get the background for this layer.
       * @return {BackgroundColor|false} Layer background.
       */
      getBackground() {
        return this.background_;
      }
      /**
       * @return {string} CSS class name.
       */
      getClassName() {
        return this.className_;
      }
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean} [managed] Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      getLayerState(managed) {
        const state2 = this.state_ || /** @type {?} */
        {
          layer: this,
          managed: managed === void 0 ? true : managed
        };
        const zIndex = this.getZIndex();
        state2.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state2.visible = this.getVisible();
        state2.extent = this.getExtent();
        state2.zIndex = zIndex === void 0 && !state2.managed ? Infinity : zIndex;
        state2.maxResolution = this.getMaxResolution();
        state2.minResolution = Math.max(this.getMinResolution(), 0);
        state2.minZoom = this.getMinZoom();
        state2.maxZoom = this.getMaxZoom();
        this.state_ = state2;
        return state2;
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array2) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        return abstract();
      }
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      getExtent() {
        return (
          /** @type {import("../extent.js").Extent|undefined} */
          this.get(Property_default.EXTENT)
        );
      }
      /**
       * Return the maximum resolution of the layer. Returns Infinity if
       * the layer has no maximum resolution set.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      getMaxResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_RESOLUTION)
        );
      }
      /**
       * Return the minimum resolution of the layer. Returns 0 if
       * the layer has no minimum resolution set.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      getMinResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_RESOLUTION)
        );
      }
      /**
       * Return the minimum zoom level of the layer. Returns -Infinity if
       * the layer has no minimum zoom set.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_ZOOM)
        );
      }
      /**
       * Return the maximum zoom level of the layer. Returns Infinity if
       * the layer has no maximum zoom set.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_ZOOM)
        );
      }
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      getOpacity() {
        return (
          /** @type {number} */
          this.get(Property_default.OPACITY)
        );
      }
      /**
       * @abstract
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        return abstract();
      }
      /**
       * Return the value of this layer's `visible` property. To find out whether the layer
       * is visible on a map, use `isVisible()` instead.
       * @return {boolean} The value of the `visible` property of the layer.
       * @observable
       * @api
       */
      getVisible() {
        return (
          /** @type {boolean} */
          this.get(Property_default.VISIBLE)
        );
      }
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. Returns undefined if the layer is unmanaged.
       * @return {number|undefined} The Z-index of the layer.
       * @observable
       * @api
       */
      getZIndex() {
        return (
          /** @type {number|undefined} */
          this.get(Property_default.Z_INDEX)
        );
      }
      /**
       * Sets the background color.
       * @param {BackgroundColor} [background] Background color.
       */
      setBackground(background) {
        this.background_ = background;
        this.changed();
      }
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      setExtent(extent) {
        this.set(Property_default.EXTENT, extent);
      }
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      setMaxResolution(maxResolution) {
        this.set(Property_default.MAX_RESOLUTION, maxResolution);
      }
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      setMinResolution(minResolution) {
        this.set(Property_default.MIN_RESOLUTION, minResolution);
      }
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      setMaxZoom(maxZoom) {
        this.set(Property_default.MAX_ZOOM, maxZoom);
      }
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      setMinZoom(minZoom) {
        this.set(Property_default.MIN_ZOOM, minZoom);
      }
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      setOpacity(opacity) {
        assert(typeof opacity === "number", "Layer opacity must be a number");
        this.set(Property_default.OPACITY, opacity);
      }
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      setVisible(visible) {
        this.set(Property_default.VISIBLE, visible);
      }
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      setZIndex(zindex) {
        this.set(Property_default.Z_INDEX, zindex);
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        if (this.state_) {
          this.state_.layer = null;
          this.state_ = null;
        }
        super.disposeInternal();
      }
    };
    Base_default = BaseLayer;
  }
});

// node_modules/ol/layer/Layer.js
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer, Layer_default3;
var init_Layer3 = __esm({
  "node_modules/ol/layer/Layer.js"() {
    init_View();
    init_asserts();
    init_EventType();
    init_events();
    init_extent();
    init_EventType2();
    init_Base();
    init_Property();
    Layer = class extends Base_default {
      /**
       * @param {Options<SourceType>} options Layer options.
       */
      constructor(options2) {
        const baseOptions = Object.assign({}, options2);
        delete baseOptions.source;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.mapPrecomposeKey_ = null;
        this.mapRenderKey_ = null;
        this.sourceChangeKey_ = null;
        this.renderer_ = null;
        this.sourceReady_ = false;
        this.rendered = false;
        if (options2.render) {
          this.render = options2.render;
        }
        if (options2.map) {
          this.setMap(options2.map);
        }
        this.addChangeListener(
          Property_default.SOURCE,
          this.handleSourcePropertyChange_
        );
        const source2 = options2.source ? (
          /** @type {SourceType} */
          options2.source
        ) : null;
        this.setSource(source2);
      }
      /**
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       * @override
       */
      getLayersArray(array2) {
        array2 = array2 ? array2 : [];
        array2.push(this);
        return array2;
      }
      /**
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       * @override
       */
      getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
      }
      /**
       * Get the layer source.
       * @return {SourceType|null} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      getSource() {
        return (
          /** @type {SourceType} */
          this.get(Property_default.SOURCE) || null
        );
      }
      /**
       * @return {SourceType|null} The source being rendered.
       */
      getRenderSource() {
        return this.getSource();
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       * @override
       */
      getSourceState() {
        const source2 = this.getSource();
        return !source2 ? "undefined" : source2.getState();
      }
      /**
       * @private
       */
      handleSourceChange_() {
        this.changed();
        if (this.sourceReady_ || this.getSource().getState() !== "ready") {
          return;
        }
        this.sourceReady_ = true;
        this.dispatchEvent("sourceready");
      }
      /**
       * @private
       */
      handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
          unlistenByKey(this.sourceChangeKey_);
          this.sourceChangeKey_ = null;
        }
        this.sourceReady_ = false;
        const source2 = this.getSource();
        if (source2) {
          this.sourceChangeKey_ = listen(
            source2,
            EventType_default.CHANGE,
            this.handleSourceChange_,
            this
          );
          if (source2.getState() === "ready") {
            this.sourceReady_ = true;
            setTimeout(() => {
              this.dispatchEvent("sourceready");
            }, 0);
          }
        }
        this.changed();
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        if (!this.renderer_) {
          return Promise.resolve([]);
        }
        return this.renderer_.getFeatures(pixel);
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        if (!this.renderer_ || !this.rendered) {
          return null;
        }
        return this.renderer_.getData(pixel);
      }
      /**
       * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
       * extent, not set to `visible: false`, and not inside a layer group that is set
       * to `visible: false`.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {boolean} The layer is visible in the map view.
       * @api
       */
      isVisible(view) {
        let frameState;
        const map = this.getMapInternal();
        if (!view && map) {
          view = map.getView();
        }
        if (view instanceof View_default) {
          frameState = {
            viewState: view.getState(),
            extent: view.calculateExtent()
          };
        } else {
          frameState = view;
        }
        if (!frameState.layerStatesArray && map) {
          frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
        }
        let layerState;
        if (frameState.layerStatesArray) {
          layerState = frameState.layerStatesArray.find(
            (layerState2) => layerState2.layer === this
          );
          if (!layerState) {
            return false;
          }
        } else {
          layerState = this.getLayerState();
        }
        const layerExtent = this.getExtent();
        return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
      }
      /**
       * Get the attributions of the source of this layer for the given view.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {Array<string>} Attributions for this layer at the given view.
       * @api
       */
      getAttributions(view) {
        if (!this.isVisible(view)) {
          return [];
        }
        const getAttributions = this.getSource()?.getAttributions();
        if (!getAttributions) {
          return [];
        }
        const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
        let attributions = getAttributions(frameState);
        if (!Array.isArray(attributions)) {
          attributions = [attributions];
        }
        return attributions;
      }
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement|null} The rendered element.
       */
      render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
          this.rendered = true;
          return layerRenderer.renderFrame(frameState, target);
        }
        return null;
      }
      /**
       * Called when a layer is not visible during a map render.
       */
      unrender() {
        this.rendered = false;
      }
      /** @return {string} Declutter */
      getDeclutter() {
        return void 0;
      }
      /**
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {import("../layer/Layer.js").State} layerState Layer state.
       */
      renderDeclutter(frameState, layerState) {
      }
      /**
       * When the renderer follows a layout -> render approach, do the final rendering here.
       * @param {import('../Map.js').FrameState} frameState Frame state
       */
      renderDeferred(frameState) {
        const layerRenderer = this.getRenderer();
        if (!layerRenderer) {
          return;
        }
        layerRenderer.renderDeferred(frameState);
      }
      /**
       * For use inside the library only.
       * @param {import("../Map.js").default|null} map Map.
       */
      setMapInternal(map) {
        if (!map) {
          this.unrender();
        }
        this.set(Property_default.MAP, map);
      }
      /**
       * For use inside the library only.
       * @return {import("../Map.js").default|null} Map.
       */
      getMapInternal() {
        return this.get(Property_default.MAP);
      }
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map~Map#addLayer} instead.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.mapPrecomposeKey_) {
          unlistenByKey(this.mapPrecomposeKey_);
          this.mapPrecomposeKey_ = null;
        }
        if (!map) {
          this.changed();
        }
        if (this.mapRenderKey_) {
          unlistenByKey(this.mapRenderKey_);
          this.mapRenderKey_ = null;
        }
        if (map) {
          this.mapPrecomposeKey_ = listen(
            map,
            EventType_default2.PRECOMPOSE,
            this.handlePrecompose_,
            this
          );
          this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map.render, map);
          this.changed();
        }
      }
      /**
       * @param {import("../events/Event.js").default} renderEvent Render event
       * @private
       */
      handlePrecompose_(renderEvent) {
        const layerStatesArray = (
          /** @type {import("../render/Event.js").default} */
          renderEvent.frameState.layerStatesArray
        );
        const layerState = this.getLayerState(false);
        assert(
          !layerStatesArray.some(
            (arrayLayerState) => arrayLayerState.layer === layerState.layer
          ),
          "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
        );
        layerStatesArray.push(layerState);
      }
      /**
       * Set the layer source.
       * @param {SourceType|null} source The layer source.
       * @observable
       * @api
       */
      setSource(source2) {
        this.set(Property_default.SOURCE, source2);
      }
      /**
       * Get the renderer for this layer.
       * @return {RendererType|null} The layer renderer.
       */
      getRenderer() {
        if (!this.renderer_) {
          this.renderer_ = this.createRenderer();
        }
        return this.renderer_;
      }
      /**
       * @return {boolean} The layer has a renderer.
       */
      hasRenderer() {
        return !!this.renderer_;
      }
      /**
       * Create a renderer for this layer.
       * @return {RendererType} A layer renderer.
       * @protected
       */
      createRenderer() {
        return null;
      }
      /**
       * This will clear the renderer so that a new one can be created next time it is needed
       */
      clearRenderer() {
        if (this.renderer_) {
          this.renderer_.dispose();
          delete this.renderer_;
        }
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        this.clearRenderer();
        this.setSource(null);
        super.disposeInternal();
      }
    };
    Layer_default3 = Layer;
  }
});

// node_modules/ol/layer/TileProperty.js
var TileProperty_default;
var init_TileProperty = __esm({
  "node_modules/ol/layer/TileProperty.js"() {
    TileProperty_default = {
      PRELOAD: "preload",
      USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
    };
  }
});

// node_modules/ol/layer/BaseTile.js
var BaseTileLayer, BaseTile_default;
var init_BaseTile = __esm({
  "node_modules/ol/layer/BaseTile.js"() {
    init_Layer3();
    init_TileProperty();
    BaseTileLayer = class extends Layer_default3 {
      /**
       * @param {Options<TileSourceType>} [options] Tile layer options.
       */
      constructor(options2) {
        options2 = options2 ? options2 : {};
        const baseOptions = Object.assign({}, options2);
        const cacheSize2 = options2.cacheSize;
        delete options2.cacheSize;
        delete baseOptions.preload;
        delete baseOptions.useInterimTilesOnError;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.cacheSize_ = cacheSize2;
        this.setPreload(options2.preload !== void 0 ? options2.preload : 0);
        this.setUseInterimTilesOnError(
          options2.useInterimTilesOnError !== void 0 ? options2.useInterimTilesOnError : true
        );
      }
      /**
       * @return {number|undefined} The suggested cache size
       * @protected
       */
      getCacheSize() {
        return this.cacheSize_;
      }
      /**
       * Return the level as number to which we will preload tiles up to.
       * @return {number} The level to preload tiles up to.
       * @observable
       * @api
       */
      getPreload() {
        return (
          /** @type {number} */
          this.get(TileProperty_default.PRELOAD)
        );
      }
      /**
       * Set the level as number to which we will preload tiles up to.
       * @param {number} preload The level to preload tiles up to.
       * @observable
       * @api
       */
      setPreload(preload) {
        this.set(TileProperty_default.PRELOAD, preload);
      }
      /**
       * Deprecated.  Whether we use interim tiles on error.
       * @return {boolean} Use interim tiles on error.
       * @observable
       * @api
       */
      getUseInterimTilesOnError() {
        return (
          /** @type {boolean} */
          this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR)
        );
      }
      /**
       * Deprecated.  Set whether we use interim tiles on error.
       * @param {boolean} useInterimTilesOnError Use interim tiles on error.
       * @observable
       * @api
       */
      setUseInterimTilesOnError(useInterimTilesOnError) {
        this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
      }
      /**
       * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
       * a four element RGBA array will be returned.  For data tiles, the array length will match the
       * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
       * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
       *
       * ```js
       * // display layer data on every pointer move
       * map.on('pointermove', (event) => {
       *   console.log(layer.getData(event.pixel));
       * });
       * ```
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       * @api
       * @override
       */
      getData(pixel) {
        return super.getData(pixel);
      }
    };
    BaseTile_default = BaseTileLayer;
  }
});

// node_modules/ol/layer/Tile.js
var TileLayer, Tile_default3;
var init_Tile3 = __esm({
  "node_modules/ol/layer/Tile.js"() {
    init_TileLayer();
    init_BaseTile();
    TileLayer = class extends BaseTile_default {
      /**
       * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
       */
      constructor(options2) {
        super(options2);
      }
      /**
       * @override
       */
      createRenderer() {
        return new TileLayer_default(this, {
          cacheSize: this.getCacheSize()
        });
      }
    };
    Tile_default3 = TileLayer;
  }
});

// node_modules/ol/tilegrid/TileGrid.js
var tmpTileCoord, DECIMALS, TileGrid, TileGrid_default;
var init_TileGrid = __esm({
  "node_modules/ol/tilegrid/TileGrid.js"() {
    init_TileRange();
    init_array();
    init_asserts();
    init_extent();
    init_intersectsextent();
    init_math();
    init_size();
    init_tilecoord();
    init_common2();
    tmpTileCoord = [0, 0, 0];
    DECIMALS = 5;
    TileGrid = class {
      /**
       * @param {Options} options Tile grid options.
       */
      constructor(options2) {
        this.minZoom = options2.minZoom !== void 0 ? options2.minZoom : 0;
        this.resolutions_ = options2.resolutions;
        assert(
          isSorted(
            this.resolutions_,
            /**
             * @param {number} a First resolution
             * @param {number} b Second resolution
             * @return {number} Comparison result
             */
            (a, b) => b - a,
            true
          ),
          "`resolutions` must be sorted in descending order"
        );
        let zoomFactor;
        if (!options2.origins) {
          for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
            if (!zoomFactor) {
              zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
            } else {
              if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                zoomFactor = void 0;
                break;
              }
            }
          }
        }
        this.zoomFactor_ = zoomFactor;
        this.maxZoom = this.resolutions_.length - 1;
        this.origin_ = options2.origin !== void 0 ? options2.origin : null;
        this.origins_ = null;
        if (options2.origins !== void 0) {
          this.origins_ = options2.origins;
          assert(
            this.origins_.length == this.resolutions_.length,
            "Number of `origins` and `resolutions` must be equal"
          );
        }
        const extent = options2.extent;
        if (extent !== void 0 && !this.origin_ && !this.origins_) {
          this.origin_ = getTopLeft(extent);
        }
        assert(
          !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
          "Either `origin` or `origins` must be configured, never both"
        );
        this.tileSizes_ = null;
        if (options2.tileSizes !== void 0) {
          this.tileSizes_ = options2.tileSizes;
          assert(
            this.tileSizes_.length == this.resolutions_.length,
            "Number of `tileSizes` and `resolutions` must be equal"
          );
        }
        this.tileSize_ = options2.tileSize !== void 0 ? options2.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
        assert(
          !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
          "Either `tileSize` or `tileSizes` must be configured, never both"
        );
        this.extent_ = extent !== void 0 ? extent : null;
        this.fullTileRanges_ = null;
        this.tmpSize_ = [0, 0];
        this.tmpExtent_ = [0, 0, 0, 0];
        if (options2.sizes !== void 0) {
          this.fullTileRanges_ = options2.sizes.map((size, z) => {
            const tileRange = new TileRange_default(
              Math.min(0, size[0]),
              Math.max(size[0] - 1, -1),
              Math.min(0, size[1]),
              Math.max(size[1] - 1, -1)
            );
            if (extent) {
              const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
              tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
              tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
              tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
              tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
            }
            return tileRange;
          });
        } else if (extent) {
          this.calculateTileRanges_(extent);
        }
      }
      /**
       * Call a function with each tile coordinate for a given extent and zoom level.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} zoom Integer zoom level.
       * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
       * @api
       */
      forEachTileCoord(extent, zoom, callback) {
        const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
        for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
          for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
            callback([zoom, i, j]);
          }
        }
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
       * @return {boolean} Callback succeeded.
       */
      forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
        let tileRange, x, y;
        let tileCoordExtent = null;
        let z = tileCoord[0] - 1;
        if (this.zoomFactor_ === 2) {
          x = tileCoord[1];
          y = tileCoord[2];
        } else {
          tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
        }
        while (z >= this.minZoom) {
          if (x !== void 0 && y !== void 0) {
            x = Math.floor(x / 2);
            y = Math.floor(y / 2);
            tileRange = createOrUpdate2(x, x, y, y, tempTileRange);
          } else {
            tileRange = this.getTileRangeForExtentAndZ(
              tileCoordExtent,
              z,
              tempTileRange
            );
          }
          if (callback(z, tileRange)) {
            return true;
          }
          --z;
        }
        return false;
      }
      /**
       * Get the extent for this tile grid, if it was configured.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        return this.extent_;
      }
      /**
       * Get the maximum zoom level for the grid.
       * @return {number} Max zoom.
       * @api
       */
      getMaxZoom() {
        return this.maxZoom;
      }
      /**
       * Get the minimum zoom level for the grid.
       * @return {number} Min zoom.
       * @api
       */
      getMinZoom() {
        return this.minZoom;
      }
      /**
       * Get the origin for the grid at the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {import("../coordinate.js").Coordinate} Origin.
       * @api
       */
      getOrigin(z) {
        if (this.origin_) {
          return this.origin_;
        }
        return this.origins_[z];
      }
      /**
       * Get the resolution for the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {number} Resolution.
       * @api
       */
      getResolution(z) {
        return this.resolutions_[z];
      }
      /**
       * Get the list of resolutions for the tile grid.
       * @return {Array<number>} Resolutions.
       * @api
       */
      getResolutions() {
        return this.resolutions_;
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
       * @return {import("../TileRange.js").default|null} Tile range.
       */
      getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
        if (tileCoord[0] < this.maxZoom) {
          if (this.zoomFactor_ === 2) {
            const minX = tileCoord[1] * 2;
            const minY = tileCoord[2] * 2;
            return createOrUpdate2(
              minX,
              minX + 1,
              minY,
              minY + 1,
              tempTileRange
            );
          }
          const tileCoordExtent = this.getTileCoordExtent(
            tileCoord,
            tempExtent || this.tmpExtent_
          );
          return this.getTileRangeForExtentAndZ(
            tileCoordExtent,
            tileCoord[0] + 1,
            tempTileRange
          );
        }
        return null;
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
       * @return {import("../TileRange.js").default|null} Tile range.
       */
      getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
        if (z > this.maxZoom || z < this.minZoom) {
          return null;
        }
        const tileCoordZ = tileCoord[0];
        const tileCoordX = tileCoord[1];
        const tileCoordY = tileCoord[2];
        if (z === tileCoordZ) {
          return createOrUpdate2(
            tileCoordX,
            tileCoordY,
            tileCoordX,
            tileCoordY,
            tempTileRange
          );
        }
        if (this.zoomFactor_) {
          const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
          const minX = Math.floor(tileCoordX * factor);
          const minY = Math.floor(tileCoordY * factor);
          if (z < tileCoordZ) {
            return createOrUpdate2(minX, minX, minY, minY, tempTileRange);
          }
          const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
          const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
          return createOrUpdate2(minX, maxX, minY, maxY, tempTileRange);
        }
        const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
      }
      /**
       * Get a tile range for the given extent and integer zoom level.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
       * @return {import("../TileRange.js").default} Tile range.
       */
      getTileRangeForExtentAndZ(extent, z, tempTileRange) {
        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
        const minX = tmpTileCoord[1];
        const minY = tmpTileCoord[2];
        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
        const maxX = tmpTileCoord[1];
        const maxY = tmpTileCoord[2];
        return createOrUpdate2(minX, maxX, minY, maxY, tempTileRange);
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {import("../coordinate.js").Coordinate} Tile center.
       */
      getTileCoordCenter(tileCoord) {
        const origin = this.getOrigin(tileCoord[0]);
        const resolution = this.getResolution(tileCoord[0]);
        const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
        return [
          origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
          origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
        ];
      }
      /**
       * Get the extent of a tile coordinate.
       *
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getTileCoordExtent(tileCoord, tempExtent) {
        const origin = this.getOrigin(tileCoord[0]);
        const resolution = this.getResolution(tileCoord[0]);
        const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
        const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
        const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
        const maxX = minX + tileSize[0] * resolution;
        const maxY = minY + tileSize[1] * resolution;
        return createOrUpdate(minX, minY, maxX, maxY, tempExtent);
      }
      /**
       * Get the tile coordinate for the given map coordinate and resolution.  This
       * method considers that coordinates that intersect tile boundaries should be
       * assigned the higher tile coordinate.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */
      getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
        return this.getTileCoordForXYAndResolution_(
          coordinate[0],
          coordinate[1],
          resolution,
          false,
          opt_tileCoord
        );
      }
      /**
       * Note that this method should not be called for resolutions that correspond
       * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
       * @param {number} x X.
       * @param {number} y Y.
       * @param {number} resolution Resolution (for a non-integer zoom level).
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */
      getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
        const z = this.getZForResolution(resolution);
        const scale4 = resolution / this.getResolution(z);
        const origin = this.getOrigin(z);
        const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
        let tileCoordX = scale4 * (x - origin[0]) / resolution / tileSize[0];
        let tileCoordY = scale4 * (origin[1] - y) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
          tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
          tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
        } else {
          tileCoordX = floor(tileCoordX, DECIMALS);
          tileCoordY = floor(tileCoordY, DECIMALS);
        }
        return createOrUpdate3(z, tileCoordX, tileCoordY, opt_tileCoord);
      }
      /**
       * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
       * they should have separate implementations.  This method is for integer zoom
       * levels.  The other method should only be called for resolutions corresponding
       * to non-integer zoom levels.
       * @param {number} x Map x coordinate.
       * @param {number} y Map y coordinate.
       * @param {number} z Integer zoom level.
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */
      getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
        const origin = this.getOrigin(z);
        const resolution = this.getResolution(z);
        const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
        let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
        let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
          tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
          tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
        } else {
          tileCoordX = floor(tileCoordX, DECIMALS);
          tileCoordY = floor(tileCoordY, DECIMALS);
        }
        return createOrUpdate3(z, tileCoordX, tileCoordY, opt_tileCoord);
      }
      /**
       * Get a tile coordinate given a map coordinate and zoom level.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */
      getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
        return this.getTileCoordForXYAndZ_(
          coordinate[0],
          coordinate[1],
          z,
          false,
          opt_tileCoord
        );
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {number} Tile resolution.
       */
      getTileCoordResolution(tileCoord) {
        return this.resolutions_[tileCoord[0]];
      }
      /**
       * Get the tile size for a zoom level. The type of the return value matches the
       * `tileSize` or `tileSizes` that the tile grid was configured with. To always
       * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
       * @param {number} z Z.
       * @return {number|import("../size.js").Size} Tile size.
       * @api
       */
      getTileSize(z) {
        if (this.tileSize_) {
          return this.tileSize_;
        }
        return this.tileSizes_[z];
      }
      /**
       * @param {number} z Zoom level.
       * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
       */
      getFullTileRange(z) {
        if (!this.fullTileRanges_) {
          return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
        }
        return this.fullTileRanges_[z];
      }
      /**
       * @param {number} resolution Resolution.
       * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
       *     If 0, the nearest resolution will be used.
       *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
       *     nearest lower resolution (higher Z) will be used. Default is 0.
       *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
       *
       * For example to change tile Z at the midpoint of zoom levels
       * ```js
       * function(value, high, low) {
       *   return value - low * Math.sqrt(high / low);
       * }
       * ```
       * @return {number} Z.
       * @api
       */
      getZForResolution(resolution, opt_direction) {
        const z = linearFindNearest(
          this.resolutions_,
          resolution,
          opt_direction || 0
        );
        return clamp(z, this.minZoom, this.maxZoom);
      }
      /**
       * The tile with the provided tile coordinate intersects the given viewport.
       * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
       * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
       * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
       */
      tileCoordIntersectsViewport(tileCoord, viewport2) {
        return intersectsLinearRing(
          viewport2,
          0,
          viewport2.length,
          2,
          this.getTileCoordExtent(tileCoord)
        );
      }
      /**
       * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
       * @private
       */
      calculateTileRanges_(extent) {
        const length = this.resolutions_.length;
        const fullTileRanges = new Array(length);
        for (let z = this.minZoom; z < length; ++z) {
          fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
        }
        this.fullTileRanges_ = fullTileRanges;
      }
    };
    TileGrid_default = TileGrid;
  }
});

// node_modules/ol/tilegrid.js
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX2(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new TileGrid_default({
    extent,
    origin: getCorner(extent, corner),
    resolutions,
    tileSize
  });
}
function createXYZ(options2) {
  const xyzOptions = options2 || {};
  const extent = xyzOptions.extent || get4("EPSG:3857").getExtent();
  const gridOptions = {
    extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution
    )
  };
  return new TileGrid_default(gridOptions);
}
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent);
  const width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get4(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half = 180 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }
  return extent;
}
var init_tilegrid = __esm({
  "node_modules/ol/tilegrid.js"() {
    init_extent();
    init_proj();
    init_size();
    init_TileGrid();
    init_common2();
  }
});

// node_modules/ol/uri.js
function renderXYZTemplate(template, z, x, y, maxY) {
  return template.replace(zRegEx, z.toString()).replace(xRegEx, x.toString()).replace(yRegEx, y.toString()).replace(dashYRegEx, function() {
    if (maxY === void 0) {
      throw new Error(
        "If the URL template has a {-y} placeholder, the grid extent must be known"
      );
    }
    return (maxY - y).toString();
  });
}
function expandUrl(url) {
  const urls = [];
  let match2 = /\{([a-z])-([a-z])\}/.exec(url);
  if (match2) {
    const startCharCode = match2[1].charCodeAt(0);
    const stopCharCode = match2[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match2[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match2 = /\{(\d+)-(\d+)\}/.exec(url);
  if (match2) {
    const stop = parseInt(match2[2], 10);
    for (let i = parseInt(match2[1], 10); i <= stop; i++) {
      urls.push(url.replace(match2[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}
var zRegEx, xRegEx, yRegEx, dashYRegEx;
var init_uri = __esm({
  "node_modules/ol/uri.js"() {
    zRegEx = /\{z\}/g;
    xRegEx = /\{x\}/g;
    yRegEx = /\{y\}/g;
    dashYRegEx = /\{-y\}/g;
  }
});

// node_modules/ol/tileurlfunction.js
function createFromTemplate(template, tileGrid) {
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      let maxY;
      const z = tileCoord[0];
      if (tileGrid) {
        const range = tileGrid.getFullTileRange(z);
        if (range) {
          maxY = range.getHeight() - 1;
        }
      }
      return renderXYZTemplate(template, z, tileCoord[1], tileCoord[2], maxY);
    }
  );
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const h = hash2(tileCoord);
      const index8 = modulo(h, tileUrlFunctions.length);
      return tileUrlFunctions[index8](tileCoord, pixelRatio, projection);
    }
  );
}
var init_tileurlfunction = __esm({
  "node_modules/ol/tileurlfunction.js"() {
    init_math();
    init_tilecoord();
    init_uri();
  }
});

// node_modules/ol/source/Source.js
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  if (!Array.isArray(attributionLike)) {
    attributionLike = [attributionLike];
  }
  return (frameState) => attributionLike;
}
var Source, Source_default;
var init_Source = __esm({
  "node_modules/ol/source/Source.js"() {
    init_Object();
    init_proj();
    Source = class extends Object_default {
      /**
       * @param {Options} options Source options.
       */
      constructor(options2) {
        super();
        this.projection = get4(options2.projection);
        this.attributions_ = adaptAttributions(options2.attributions);
        this.attributionsCollapsible_ = options2.attributionsCollapsible ?? true;
        this.loading = false;
        this.state_ = options2.state !== void 0 ? options2.state : "ready";
        this.wrapX_ = options2.wrapX !== void 0 ? options2.wrapX : false;
        this.interpolate_ = !!options2.interpolate;
        this.viewResolver = null;
        this.viewRejector = null;
        const self2 = this;
        this.viewPromise_ = new Promise(function(resolve2, reject) {
          self2.viewResolver = resolve2;
          self2.viewRejector = reject;
        });
      }
      /**
       * Get the attribution function for the source.
       * @return {?Attribution} Attribution function.
       * @api
       */
      getAttributions() {
        return this.attributions_;
      }
      /**
       * @return {boolean} Attributions are collapsible.
       * @api
       */
      getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
      }
      /**
       * Get the projection of the source.
       * @return {import("../proj/Projection.js").default|null} Projection.
       * @api
       */
      getProjection() {
        return this.projection;
      }
      /**
       * @param {import("../proj/Projection").default} [projection] Projection.
       * @return {Array<number>|null} Resolutions.
       */
      getResolutions(projection) {
        return null;
      }
      /**
       * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
       */
      getView() {
        return this.viewPromise_;
      }
      /**
       * Get the state of the source, see {@link import("./Source.js").State} for possible states.
       * @return {import("./Source.js").State} State.
       * @api
       */
      getState() {
        return this.state_;
      }
      /**
       * @return {boolean|undefined} Wrap X.
       */
      getWrapX() {
        return this.wrapX_;
      }
      /**
       * @return {boolean} Use linear interpolation when resampling.
       */
      getInterpolate() {
        return this.interpolate_;
      }
      /**
       * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
       * @api
       */
      refresh() {
        this.changed();
      }
      /**
       * Set the attributions of the source.
       * @param {AttributionLike|undefined} attributions Attributions.
       *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
       *     or `undefined`.
       * @api
       */
      setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
      }
      /**
       * Set the state of the source.
       * @param {import("./Source.js").State} state State.
       */
      setState(state2) {
        this.state_ = state2;
        this.changed();
      }
    };
    Source_default = Source;
  }
});

// node_modules/ol/source/Tile.js
var TileSource, TileSourceEvent, Tile_default4;
var init_Tile4 = __esm({
  "node_modules/ol/source/Tile.js"() {
    init_Event();
    init_size();
    init_tilecoord();
    init_tilegrid();
    init_util();
    init_Source();
    TileSource = class extends Source_default {
      /**
       * @param {Options} options SourceTile source options.
       */
      constructor(options2) {
        super({
          attributions: options2.attributions,
          attributionsCollapsible: options2.attributionsCollapsible,
          projection: options2.projection,
          state: options2.state,
          wrapX: options2.wrapX,
          interpolate: options2.interpolate
        });
        this.on;
        this.once;
        this.un;
        this.tilePixelRatio_ = options2.tilePixelRatio !== void 0 ? options2.tilePixelRatio : 1;
        this.tileGrid = options2.tileGrid !== void 0 ? options2.tileGrid : null;
        const tileSize = [256, 256];
        if (this.tileGrid) {
          toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
        }
        this.tmpSize = [0, 0];
        this.key_ = options2.key || getUid(this);
        this.tileOptions = {
          transition: options2.transition,
          interpolate: options2.interpolate
        };
        this.zDirection = options2.zDirection ? options2.zDirection : 0;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       */
      getGutterForProjection(projection) {
        return 0;
      }
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       */
      getKey() {
        return this.key_;
      }
      /**
       * Set the value to be used as the key for all tiles in the source.
       * @param {string} key The key for tiles.
       * @protected
       */
      setKey(key2) {
        if (this.key_ !== key2) {
          this.key_ = key2;
          this.changed();
        }
      }
      /**
       * @param {import("../proj/Projection").default} [projection] Projection.
       * @return {Array<number>|null} Resolutions.
       * @override
       */
      getResolutions(projection) {
        const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
        if (!tileGrid) {
          return null;
        }
        return tileGrid.getResolutions();
      }
      /**
       * @abstract
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {TileType|null} Tile.
       */
      getTile(z, x, y, pixelRatio, projection) {
        return abstract();
      }
      /**
       * Return the tile grid of the tile source.
       * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
       * @api
       */
      getTileGrid() {
        return this.tileGrid;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       */
      getTileGridForProjection(projection) {
        if (!this.tileGrid) {
          return getForProjection(projection);
        }
        return this.tileGrid;
      }
      /**
       * Get the tile pixel ratio for this source. Subclasses may override this
       * method, which is meant to return a supported pixel ratio that matches the
       * provided `pixelRatio` as close as possible.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Tile pixel ratio.
       */
      getTilePixelRatio(pixelRatio) {
        return this.tilePixelRatio_;
      }
      /**
       * @param {number} z Z.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../size.js").Size} Tile size.
       */
      getTilePixelSize(z, pixelRatio, projection) {
        const tileGrid = this.getTileGridForProjection(projection);
        const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
        const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
        if (tilePixelRatio == 1) {
          return tileSize;
        }
        return scale3(tileSize, tilePixelRatio, this.tmpSize);
      }
      /**
       * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
       * is outside the resolution and extent range of the tile grid, `null` will be
       * returned.
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../proj/Projection.js").default} [projection] Projection.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
       *     null if no tile URL should be created for the passed `tileCoord`.
       */
      getTileCoordForTileUrlFunction(tileCoord, projection) {
        const gridProjection = projection !== void 0 ? projection : this.getProjection();
        const tileGrid = projection !== void 0 ? this.getTileGridForProjection(gridProjection) : this.tileGrid || this.getTileGridForProjection(gridProjection);
        if (this.getWrapX() && gridProjection.isGlobal()) {
          tileCoord = wrapX2(tileGrid, tileCoord, gridProjection);
        }
        return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
      }
      /**
       * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
       * @api
       */
      clear() {
      }
      /**
       * @override
       */
      refresh() {
        this.clear();
        super.refresh();
      }
    };
    TileSourceEvent = class extends Event_default {
      /**
       * @param {string} type Type.
       * @param {import("../Tile.js").default} tile The tile.
       */
      constructor(type, tile) {
        super(type);
        this.tile = tile;
      }
    };
    Tile_default4 = TileSource;
  }
});

// node_modules/ol/source/TileEventType.js
var TileEventType_default;
var init_TileEventType = __esm({
  "node_modules/ol/source/TileEventType.js"() {
    TileEventType_default = {
      /**
       * Triggered when a tile starts loading.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
       * @api
       */
      TILELOADSTART: "tileloadstart",
      /**
       * Triggered when a tile finishes loading, either when its data is loaded,
       * or when loading was aborted because the tile is no longer needed.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadend
       * @api
       */
      TILELOADEND: "tileloadend",
      /**
       * Triggered if tile loading results in an error. Note that this is not the
       * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
       * for details.
       * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
       * @api
       */
      TILELOADERROR: "tileloaderror"
    };
  }
});

// node_modules/ol/source/UrlTile.js
var UrlTile, UrlTile_default;
var init_UrlTile = __esm({
  "node_modules/ol/source/UrlTile.js"() {
    init_TileState();
    init_tileurlfunction();
    init_uri();
    init_util();
    init_Tile4();
    init_TileEventType();
    UrlTile = class _UrlTile extends Tile_default4 {
      /**
       * @param {Options} options Image tile options.
       */
      constructor(options2) {
        super({
          attributions: options2.attributions,
          cacheSize: options2.cacheSize,
          projection: options2.projection,
          state: options2.state,
          tileGrid: options2.tileGrid,
          tilePixelRatio: options2.tilePixelRatio,
          wrapX: options2.wrapX,
          transition: options2.transition,
          interpolate: options2.interpolate,
          key: options2.key,
          attributionsCollapsible: options2.attributionsCollapsible,
          zDirection: options2.zDirection
        });
        this.generateTileUrlFunction_ = this.tileUrlFunction === _UrlTile.prototype.tileUrlFunction;
        this.tileLoadFunction = options2.tileLoadFunction;
        if (options2.tileUrlFunction) {
          this.tileUrlFunction = options2.tileUrlFunction;
        }
        this.urls = null;
        if (options2.urls) {
          this.setUrls(options2.urls);
        } else if (options2.url) {
          this.setUrl(options2.url);
        }
        this.tileLoadingKeys_ = {};
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Return the tile load function of the source.
       * @return {import("../Tile.js").LoadFunction} TileLoadFunction
       * @api
       */
      getTileLoadFunction() {
        return this.tileLoadFunction;
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Return the tile URL function of the source.
       * @return {import("../Tile.js").UrlFunction} TileUrlFunction
       * @api
       */
      getTileUrlFunction() {
        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Return the URLs used for this source.
       * When a tileUrlFunction is used instead of url or urls,
       * null will be returned.
       * @return {!Array<string>|null} URLs.
       * @api
       */
      getUrls() {
        return this.urls;
      }
      /**
       * Handle tile change events.
       * @param {import("../events/Event.js").default} event Event.
       * @protected
       */
      handleTileChange(event) {
        const tile = (
          /** @type {import("../Tile.js").default} */
          event.target
        );
        const uid = getUid(tile);
        const tileState = tile.getState();
        let type;
        if (tileState == TileState_default.LOADING) {
          this.tileLoadingKeys_[uid] = true;
          type = TileEventType_default.TILELOADSTART;
        } else if (uid in this.tileLoadingKeys_) {
          delete this.tileLoadingKeys_[uid];
          type = tileState == TileState_default.ERROR ? TileEventType_default.TILELOADERROR : tileState == TileState_default.LOADED ? TileEventType_default.TILELOADEND : void 0;
        }
        if (type != void 0) {
          this.dispatchEvent(new TileSourceEvent(type, tile));
        }
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Set the tile load function of the source.
       * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
       * @api
       */
      setTileLoadFunction(tileLoadFunction) {
        this.tileLoadFunction = tileLoadFunction;
        this.changed();
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Set the tile URL function of the source.
       * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
       * @param {string} [key] Optional new tile key for the source.
       * @api
       */
      setTileUrlFunction(tileUrlFunction, key2) {
        this.tileUrlFunction = tileUrlFunction;
        if (typeof key2 !== "undefined") {
          this.setKey(key2);
        } else {
          this.changed();
        }
      }
      /**
       * Set the URL to use for requests.
       * @param {string} url URL.
       * @api
       */
      setUrl(url) {
        const urls = expandUrl(url);
        this.urls = urls;
        this.setUrls(urls);
      }
      /**
       * Deprecated.  Use an ImageTile source instead.
       * Set the URLs to use for requests.
       * @param {Array<string>} urls URLs.
       * @api
       */
      setUrls(urls) {
        this.urls = urls;
        const key2 = urls.join("\n");
        if (this.generateTileUrlFunction_) {
          this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key2);
        } else {
          this.setKey(key2);
        }
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      tileUrlFunction(tileCoord, pixelRatio, projection) {
        return void 0;
      }
    };
    UrlTile_default = UrlTile;
  }
});

// node_modules/ol/source/TileImage.js
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
var TileImage, TileImage_default;
var init_TileImage = __esm({
  "node_modules/ol/source/TileImage.js"() {
    init_ImageTile();
    init_TileState();
    init_EventType();
    init_proj();
    init_Tile2();
    init_tilegrid();
    init_util();
    init_UrlTile();
    TileImage = class extends UrlTile_default {
      /**
       * @param {!Options} options Image tile options.
       */
      constructor(options2) {
        super({
          attributions: options2.attributions,
          cacheSize: options2.cacheSize,
          projection: options2.projection,
          state: options2.state,
          tileGrid: options2.tileGrid,
          tileLoadFunction: options2.tileLoadFunction ? options2.tileLoadFunction : defaultTileLoadFunction,
          tilePixelRatio: options2.tilePixelRatio,
          tileUrlFunction: options2.tileUrlFunction,
          url: options2.url,
          urls: options2.urls,
          wrapX: options2.wrapX,
          transition: options2.transition,
          interpolate: options2.interpolate !== void 0 ? options2.interpolate : true,
          key: options2.key,
          attributionsCollapsible: options2.attributionsCollapsible,
          zDirection: options2.zDirection
        });
        this.crossOrigin = options2.crossOrigin !== void 0 ? options2.crossOrigin : null;
        this.tileClass = options2.tileClass !== void 0 ? options2.tileClass : ImageTile_default;
        this.tileGridForProjection = {};
        this.reprojectionErrorThreshold_ = options2.reprojectionErrorThreshold;
        this.renderReprojectionEdges_ = false;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       * @override
       */
      getGutterForProjection(projection) {
        if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
          return 0;
        }
        return this.getGutter();
      }
      /**
       * @return {number} Gutter.
       */
      getGutter() {
        return 0;
      }
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       * @override
       */
      getKey() {
        let key2 = super.getKey();
        if (!this.getInterpolate()) {
          key2 += ":disable-interpolation";
        }
        return key2;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       * @override
       */
      getTileGridForProjection(projection) {
        const thisProj = this.getProjection();
        if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
          return this.tileGrid;
        }
        const projKey = getUid(projection);
        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = getForProjection(projection);
        }
        return this.tileGridForProjection[projKey];
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {string} key The key set on the tile.
       * @return {!ImageTile} Tile.
       * @private
       */
      createTile_(z, x, y, pixelRatio, projection, key2) {
        const tileCoord = [z, x, y];
        const urlTileCoord = this.getTileCoordForTileUrlFunction(
          tileCoord,
          projection
        );
        const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
        const tile = new this.tileClass(
          tileCoord,
          tileUrl !== void 0 ? TileState_default.IDLE : TileState_default.EMPTY,
          tileUrl !== void 0 ? tileUrl : "",
          this.crossOrigin,
          this.tileLoadFunction,
          this.tileOptions
        );
        tile.key = key2;
        tile.addEventListener(EventType_default.CHANGE, this.handleTileChange.bind(this));
        return tile;
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!(ImageTile|ReprojTile)} Tile.
       * @override
       */
      getTile(z, x, y, pixelRatio, projection) {
        const sourceProjection = this.getProjection();
        if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
          return this.getTileInternal(
            z,
            x,
            y,
            pixelRatio,
            sourceProjection || projection
          );
        }
        const tileCoord = [z, x, y];
        const key2 = this.getKey();
        const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        const targetTileGrid = this.getTileGridForProjection(projection);
        const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
          tileCoord,
          projection
        );
        const tile = new Tile_default2(
          sourceProjection,
          sourceTileGrid,
          projection,
          targetTileGrid,
          tileCoord,
          wrappedTileCoord,
          this.getTilePixelRatio(pixelRatio),
          this.getGutter(),
          (z2, x2, y2, pixelRatio2) => this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection),
          this.reprojectionErrorThreshold_,
          this.renderReprojectionEdges_,
          this.tileOptions
        );
        tile.key = key2;
        return tile;
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {!import("../proj/Projection.js").default} projection Projection.
       * @return {!ImageTile} Tile.
       * @protected
       */
      getTileInternal(z, x, y, pixelRatio, projection) {
        const key2 = this.getKey();
        return this.createTile_(z, x, y, pixelRatio, projection, key2);
      }
      /**
       * Sets whether to render reprojection edges or not (usually for debugging).
       * @param {boolean} render Render the edges.
       * @api
       */
      setRenderReprojectionEdges(render3) {
        if (this.renderReprojectionEdges_ == render3) {
          return;
        }
        this.renderReprojectionEdges_ = render3;
        this.changed();
      }
      /**
       * Sets the tile grid to use when reprojecting the tiles to the given
       * projection instead of the default tile grid for the projection.
       *
       * This can be useful when the default tile grid cannot be created
       * (e.g. projection has no extent defined) or
       * for optimization reasons (custom tile size, resolutions, ...).
       *
       * @param {import("../proj.js").ProjectionLike} projection Projection.
       * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
       * @api
       */
      setTileGridForProjection(projection, tilegrid) {
        const proj = get4(projection);
        if (proj) {
          const projKey = getUid(proj);
          if (!(projKey in this.tileGridForProjection)) {
            this.tileGridForProjection[projKey] = tilegrid;
          }
        }
      }
    };
    TileImage_default = TileImage;
  }
});

// node_modules/ol/source/XYZ.js
var XYZ, XYZ_default;
var init_XYZ = __esm({
  "node_modules/ol/source/XYZ.js"() {
    init_tilegrid();
    init_TileImage();
    XYZ = class extends TileImage_default {
      /**
       * @param {Options} [options] XYZ options.
       */
      constructor(options2) {
        options2 = options2 || {};
        const projection = options2.projection !== void 0 ? options2.projection : "EPSG:3857";
        const tileGrid = options2.tileGrid !== void 0 ? options2.tileGrid : createXYZ({
          extent: extentFromProjection(projection),
          maxResolution: options2.maxResolution,
          maxZoom: options2.maxZoom,
          minZoom: options2.minZoom,
          tileSize: options2.tileSize
        });
        super({
          attributions: options2.attributions,
          cacheSize: options2.cacheSize,
          crossOrigin: options2.crossOrigin,
          interpolate: options2.interpolate,
          projection,
          reprojectionErrorThreshold: options2.reprojectionErrorThreshold,
          tileGrid,
          tileLoadFunction: options2.tileLoadFunction,
          tilePixelRatio: options2.tilePixelRatio,
          tileUrlFunction: options2.tileUrlFunction,
          url: options2.url,
          urls: options2.urls,
          wrapX: options2.wrapX !== void 0 ? options2.wrapX : true,
          transition: options2.transition,
          attributionsCollapsible: options2.attributionsCollapsible,
          zDirection: options2.zDirection
        });
        this.gutter_ = options2.gutter !== void 0 ? options2.gutter : 0;
      }
      /**
       * @return {number} Gutter.
       * @override
       */
      getGutter() {
        return this.gutter_;
      }
    };
    XYZ_default = XYZ;
  }
});

// node_modules/ol/style/IconImageCache.js
function getCacheKey2(src, crossOrigin, color) {
  const colorString = color ? asArray(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var IconImageCache, shared;
var init_IconImageCache = __esm({
  "node_modules/ol/style/IconImageCache.js"() {
    init_ImageState();
    init_color2();
    init_dom();
    IconImageCache = class {
      constructor() {
        this.cache_ = {};
        this.patternCache_ = {};
        this.cacheSize_ = 0;
        this.maxCacheSize_ = 1024;
      }
      /**
       * FIXME empty description for jsdoc
       */
      clear() {
        this.cache_ = {};
        this.patternCache_ = {};
        this.cacheSize_ = 0;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
      }
      /**
       * FIXME empty description for jsdoc
       */
      expire() {
        if (this.canExpireCache()) {
          let i = 0;
          for (const key2 in this.cache_) {
            const iconImage = this.cache_[key2];
            if ((i++ & 3) === 0 && !iconImage.hasListener()) {
              delete this.cache_[key2];
              delete this.patternCache_[key2];
              --this.cacheSize_;
            }
          }
        }
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */
      get(src, crossOrigin, color) {
        const key2 = getCacheKey2(src, crossOrigin, color);
        return key2 in this.cache_ ? this.cache_[key2] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @return {CanvasPattern} Icon image.
       */
      getPattern(src, crossOrigin, color) {
        const key2 = getCacheKey2(src, crossOrigin, color);
        return key2 in this.patternCache_ ? this.patternCache_[key2] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @param {import("./IconImage.js").default|null} iconImage Icon image.
       * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
       */
      set(src, crossOrigin, color, iconImage, pattern2) {
        const key2 = getCacheKey2(src, crossOrigin, color);
        const update = key2 in this.cache_;
        this.cache_[key2] = iconImage;
        if (pattern2) {
          if (iconImage.getImageState() === ImageState_default.IDLE) {
            iconImage.load();
          }
          if (iconImage.getImageState() === ImageState_default.LOADING) {
            iconImage.ready().then(() => {
              this.patternCache_[key2] = getSharedCanvasContext2D().createPattern(
                iconImage.getImage(1),
                "repeat"
              );
            });
          } else {
            this.patternCache_[key2] = getSharedCanvasContext2D().createPattern(
              iconImage.getImage(1),
              "repeat"
            );
          }
        }
        if (!update) {
          ++this.cacheSize_;
        }
      }
      /**
       * Set the cache size of the icon cache. Default is `1024`. Change this value when
       * your map uses more than 1024 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */
      setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
      }
    };
    shared = new IconImageCache();
  }
});

// node_modules/ol/style/IconImage.js
function get6(image, cacheKey, crossOrigin, imageState, color, pattern2) {
  let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image && "src" in image ? image.src || void 0 : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern2);
  }
  if (pattern2 && iconImage && !shared.getPattern(cacheKey, crossOrigin, color)) {
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern2);
  }
  return iconImage;
}
var taintedTestContext, IconImage, IconImage_default;
var init_IconImage = __esm({
  "node_modules/ol/style/IconImage.js"() {
    init_Image();
    init_ImageState();
    init_color2();
    init_dom();
    init_EventType();
    init_Target();
    init_IconImageCache();
    taintedTestContext = null;
    IconImage = class extends Target_default {
      /**
       * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
       * @param {string|undefined} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../ImageState.js").default|undefined} imageState Image state.
       * @param {import("../color.js").Color|string|null} color Color.
       */
      constructor(image, src, crossOrigin, imageState, color) {
        super();
        this.hitDetectionImage_ = null;
        this.image_ = image;
        this.crossOrigin_ = crossOrigin;
        this.canvas_ = {};
        this.color_ = color;
        this.imageState_ = imageState === void 0 ? ImageState_default.IDLE : imageState;
        this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
        this.src_ = src;
        this.tainted_;
        this.ready_ = null;
      }
      /**
       * @private
       */
      initializeImage_() {
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) {
          this.image_.crossOrigin = this.crossOrigin_;
        }
      }
      /**
       * @private
       * @return {boolean} The image canvas is tainted.
       */
      isTainted_() {
        if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
          if (!taintedTestContext) {
            taintedTestContext = createCanvasContext2D(1, 1, void 0, {
              willReadFrequently: true
            });
          }
          taintedTestContext.drawImage(this.image_, 0, 0);
          try {
            taintedTestContext.getImageData(0, 0, 1, 1);
            this.tainted_ = false;
          } catch {
            taintedTestContext = null;
            this.tainted_ = true;
          }
        }
        return this.tainted_ === true;
      }
      /**
       * @private
       */
      dispatchChangeEvent_() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * @private
       */
      handleImageError_() {
        this.imageState_ = ImageState_default.ERROR;
        this.dispatchChangeEvent_();
      }
      /**
       * @private
       */
      handleImageLoad_() {
        this.imageState_ = ImageState_default.LOADED;
        this.size_ = [this.image_.width, this.image_.height];
        this.dispatchChangeEvent_();
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
       */
      getImage(pixelRatio) {
        if (!this.image_) {
          this.initializeImage_();
        }
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Image or Canvas element.
       */
      getPixelRatio(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       */
      getHitDetectionImage() {
        if (!this.image_) {
          this.initializeImage_();
        }
        if (!this.hitDetectionImage_) {
          if (this.isTainted_()) {
            const width = this.size_[0];
            const height = this.size_[1];
            const context2 = createCanvasContext2D(width, height);
            context2.fillRect(0, 0, width, height);
            this.hitDetectionImage_ = context2.canvas;
          } else {
            this.hitDetectionImage_ = this.image_;
          }
        }
        return this.hitDetectionImage_;
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       */
      getSize() {
        return this.size_;
      }
      /**
       * @return {string|undefined} Image src.
       */
      getSrc() {
        return this.src_;
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
        if (this.imageState_ !== ImageState_default.IDLE) {
          return;
        }
        if (!this.image_) {
          this.initializeImage_();
        }
        this.imageState_ = ImageState_default.LOADING;
        try {
          if (this.src_ !== void 0) {
            this.image_.src = this.src_;
          }
        } catch {
          this.handleImageError_();
        }
        if (this.image_ instanceof HTMLImageElement) {
          decodeFallback(this.image_, this.src_).then((image) => {
            this.image_ = image;
            this.handleImageLoad_();
          }).catch(this.handleImageError_.bind(this));
        }
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @private
       */
      replaceColor_(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
          return;
        }
        const image = this.image_;
        const ctx = createCanvasContext2D(
          Math.ceil(image.width * pixelRatio),
          Math.ceil(image.height * pixelRatio)
        );
        const canvas = ctx.canvas;
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(image, 0, 0);
        ctx.globalCompositeOperation = "multiply";
        ctx.fillStyle = asString(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(image, 0, 0);
        this.canvas_[pixelRatio] = canvas;
      }
      /**
       * @return {Promise<void>} Promise that resolves when the image is loaded.
       */
      ready() {
        if (!this.ready_) {
          this.ready_ = new Promise((resolve2) => {
            if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
              resolve2();
            } else {
              const onChange = () => {
                if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
                  this.removeEventListener(EventType_default.CHANGE, onChange);
                  resolve2();
                }
              };
              this.addEventListener(EventType_default.CHANGE, onChange);
            }
          });
        }
        return this.ready_;
      }
    };
    IconImage_default = IconImage;
  }
});

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (!color) {
    return null;
  }
  if (Array.isArray(color)) {
    return toString2(color);
  }
  if (typeof color === "object" && "src" in color) {
    return asCanvasPattern(color);
  }
  return color;
}
function asCanvasPattern(pattern2) {
  if (!pattern2.offset || !pattern2.size) {
    return shared.getPattern(pattern2.src, "anonymous", pattern2.color);
  }
  const cacheKey = pattern2.src + ":" + pattern2.offset;
  const canvasPattern = shared.getPattern(
    cacheKey,
    void 0,
    pattern2.color
  );
  if (canvasPattern) {
    return canvasPattern;
  }
  const iconImage = shared.get(pattern2.src, "anonymous", null);
  if (iconImage.getImageState() !== ImageState_default.LOADED) {
    return null;
  }
  const patternCanvasContext = createCanvasContext2D(
    pattern2.size[0],
    pattern2.size[1]
  );
  patternCanvasContext.drawImage(
    iconImage.getImage(1),
    pattern2.offset[0],
    pattern2.offset[1],
    pattern2.size[0],
    pattern2.size[1],
    0,
    0,
    pattern2.size[0],
    pattern2.size[1]
  );
  get6(
    patternCanvasContext.canvas,
    cacheKey,
    void 0,
    ImageState_default.LOADED,
    pattern2.color,
    true
  );
  return shared.getPattern(cacheKey, void 0, pattern2.color);
}
var init_colorlike = __esm({
  "node_modules/ol/colorlike.js"() {
    init_ImageState();
    init_color2();
    init_dom();
    init_IconImage();
    init_IconImageCache();
  }
});

// node_modules/ol/render/canvas.js
var defaultFillStyle, defaultLineCap, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultLineWidth, checkedFonts;
var init_canvas2 = __esm({
  "node_modules/ol/render/canvas.js"() {
    init_Object();
    defaultFillStyle = "#000";
    defaultLineCap = "round";
    defaultLineJoin = "round";
    defaultMiterLimit = 10;
    defaultStrokeStyle = "#000";
    defaultLineWidth = 1;
    checkedFonts = new Object_default();
  }
});

// node_modules/ol/style/Image.js
var ImageStyle, Image_default;
var init_Image2 = __esm({
  "node_modules/ol/style/Image.js"() {
    init_size();
    init_util();
    ImageStyle = class _ImageStyle {
      /**
       * @param {Options} options Options.
       */
      constructor(options2) {
        this.opacity_ = options2.opacity;
        this.rotateWithView_ = options2.rotateWithView;
        this.rotation_ = options2.rotation;
        this.scale_ = options2.scale;
        this.scaleArray_ = toSize(options2.scale);
        this.displacement_ = options2.displacement;
        this.declutterMode_ = options2.declutterMode;
      }
      /**
       * Clones the style.
       * @return {ImageStyle} The cloned style.
       * @api
       */
      clone() {
        const scale4 = this.getScale();
        return new _ImageStyle({
          opacity: this.getOpacity(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the symbolizer opacity.
       * @return {number} Opacity.
       * @api
       */
      getOpacity() {
        return this.opacity_;
      }
      /**
       * Determine whether the symbolizer rotates with the map.
       * @return {boolean} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Get the symoblizer rotation.
       * @return {number} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the symbolizer scale.
       * @return {number|import("../size.js").Size} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the displacement of the shape
       * @return {Array<number>} Shape's center displacement
       * @api
       */
      getDisplacement() {
        return this.displacement_;
      }
      /**
       * Get the declutter mode of the shape
       * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
       * @api
       */
      getDeclutterMode() {
        return this.declutterMode_;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @abstract
       * @return {Array<number>} Anchor.
       */
      getAnchor() {
        return abstract();
      }
      /**
       * Get the image element for the symbolizer.
       * @abstract
       * @param {number} pixelRatio Pixel ratio.
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getImage(pixelRatio) {
        return abstract();
      }
      /**
       * @abstract
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getHitDetectionImage() {
        return abstract();
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       */
      getPixelRatio(pixelRatio) {
        return 1;
      }
      /**
       * @abstract
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return abstract();
      }
      /**
       * @abstract
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return abstract();
      }
      /**
       * Get the origin of the symbolizer.
       * @abstract
       * @return {Array<number>} Origin.
       */
      getOrigin() {
        return abstract();
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @abstract
       * @return {import("../size.js").Size} Size.
       */
      getSize() {
        return abstract();
      }
      /**
       * Set the displacement.
       *
       * @param {Array<number>} displacement Displacement.
       * @api
       */
      setDisplacement(displacement) {
        this.displacement_ = displacement;
      }
      /**
       * Set the opacity.
       *
       * @param {number} opacity Opacity.
       * @api
       */
      setOpacity(opacity) {
        this.opacity_ = opacity;
      }
      /**
       * Set whether to rotate the style with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set the rotation.
       *
       * @param {number} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      setScale(scale4) {
        this.scale_ = scale4;
        this.scaleArray_ = toSize(scale4);
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
        abstract();
      }
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      load() {
        abstract();
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
        abstract();
      }
      /**
       * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
       */
      ready() {
        return Promise.resolve();
      }
    };
    Image_default = ImageStyle;
  }
});

// node_modules/ol/style/RegularShape.js
var RegularShape, RegularShape_default;
var init_RegularShape = __esm({
  "node_modules/ol/style/RegularShape.js"() {
    init_ImageState();
    init_color2();
    init_colorlike();
    init_dom();
    init_canvas2();
    init_IconImage();
    init_IconImageCache();
    init_Image2();
    RegularShape = class _RegularShape extends Image_default {
      /**
       * @param {Options} options Options.
       */
      constructor(options2) {
        super({
          opacity: 1,
          rotateWithView: options2.rotateWithView !== void 0 ? options2.rotateWithView : false,
          rotation: options2.rotation !== void 0 ? options2.rotation : 0,
          scale: options2.scale !== void 0 ? options2.scale : 1,
          displacement: options2.displacement !== void 0 ? options2.displacement : [0, 0],
          declutterMode: options2.declutterMode
        });
        this.hitDetectionCanvas_ = null;
        this.fill_ = options2.fill !== void 0 ? options2.fill : null;
        this.origin_ = [0, 0];
        this.points_ = options2.points;
        this.radius = options2.radius;
        this.radius2_ = options2.radius2;
        this.angle_ = options2.angle !== void 0 ? options2.angle : 0;
        this.stroke_ = options2.stroke !== void 0 ? options2.stroke : null;
        this.size_;
        this.renderOptions_;
        this.imageState_ = this.fill_ && this.fill_.loading() ? ImageState_default.LOADING : ImageState_default.LOADED;
        if (this.imageState_ === ImageState_default.LOADING) {
          this.ready().then(() => this.imageState_ = ImageState_default.LOADED);
        }
        this.render();
      }
      /**
       * Clones the style.
       * @return {RegularShape} The cloned style.
       * @api
       * @override
       */
      clone() {
        const scale4 = this.getScale();
        const style = new _RegularShape({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          points: this.getPoints(),
          radius: this.getRadius(),
          radius2: this.getRadius2(),
          angle: this.getAngle(),
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       * @override
       */
      getAnchor() {
        const size = this.size_;
        const displacement = this.getDisplacement();
        const scale4 = this.getScaleArray();
        return [
          size[0] / 2 - displacement[0] / scale4[0],
          size[1] / 2 + displacement[1] / scale4[1]
        ];
      }
      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      getAngle() {
        return this.angle_;
      }
      /**
       * Get the fill style for the shape.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
        this.render();
      }
      /**
       * @return {HTMLCanvasElement} Image element.
       * @override
       */
      getHitDetectionImage() {
        if (!this.hitDetectionCanvas_) {
          this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
            this.renderOptions_
          );
        }
        return this.hitDetectionCanvas_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement} Image or Canvas element.
       * @api
       * @override
       */
      getImage(pixelRatio) {
        const fillKey = this.fill_?.getKey();
        const cacheKey = `${pixelRatio},${this.angle_},${this.radius},${this.radius2_},${this.points_},${fillKey}` + Object.values(this.renderOptions_).join(",");
        let image = (
          /** @type {HTMLCanvasElement} */
          shared.get(cacheKey, null, null)?.getImage(1)
        );
        if (!image) {
          const renderOptions = this.renderOptions_;
          const size = Math.ceil(renderOptions.size * pixelRatio);
          const context2 = createCanvasContext2D(size, size);
          this.draw_(renderOptions, context2, pixelRatio);
          image = context2.canvas;
          shared.set(
            cacheKey,
            null,
            null,
            new IconImage_default(image, void 0, null, ImageState_default.LOADED, null)
          );
        }
        return image;
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       * @override
       */
      getPixelRatio(pixelRatio) {
        return pixelRatio;
      }
      /**
       * @return {import("../size.js").Size} Image size.
       * @override
       */
      getImageSize() {
        return this.size_;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       * @override
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       * @override
       */
      getOrigin() {
        return this.origin_;
      }
      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      getPoints() {
        return this.points_;
      }
      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      getRadius() {
        return this.radius;
      }
      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      getRadius2() {
        return this.radius2_;
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @return {import("../size.js").Size} Size.
       * @api
       * @override
       */
      getSize() {
        return this.size_;
      }
      /**
       * Get the stroke style for the shape.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
        this.render();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       * @override
       */
      listenImageChange(listener) {
      }
      /**
       * Load not yet loaded URI.
       * @override
       */
      load() {
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       * @override
       */
      unlistenImageChange(listener) {
      }
      /**
       * Calculate additional canvas size needed for the miter.
       * @param {string} lineJoin Line join
       * @param {number} strokeWidth Stroke width
       * @param {number} miterLimit Miter limit
       * @return {number} Additional canvas size needed
       * @private
       */
      calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
          return strokeWidth;
        }
        let r1 = this.radius;
        let r23 = this.radius2_ === void 0 ? r1 : this.radius2_;
        if (r1 < r23) {
          const tmp = r1;
          r1 = r23;
          r23 = tmp;
        }
        const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
        const alpha = 2 * Math.PI / points;
        const a = r23 * Math.sin(alpha);
        const b = Math.sqrt(r23 * r23 - a * a);
        const d = r1 - b;
        const e3 = Math.sqrt(a * a + d * d);
        const miterRatio = e3 / a;
        if (lineJoin === "miter" && miterRatio <= miterLimit) {
          return miterRatio * strokeWidth;
        }
        const k = strokeWidth / 2 / miterRatio;
        const l = strokeWidth / 2 * (d / e3);
        const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
        const bevelAdd = maxr - r1;
        if (this.radius2_ === void 0 || lineJoin === "bevel") {
          return bevelAdd * 2;
        }
        const aa2 = r1 * Math.sin(alpha);
        const bb2 = Math.sqrt(r1 * r1 - aa2 * aa2);
        const dd = r23 - bb2;
        const ee = Math.sqrt(aa2 * aa2 + dd * dd);
        const innerMiterRatio = ee / aa2;
        if (innerMiterRatio <= miterLimit) {
          const innerLength = innerMiterRatio * strokeWidth / 2 - r23 - r1;
          return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
      }
      /**
       * @return {RenderOptions}  The render options
       * @protected
       */
      createRenderOptions() {
        let lineCap = defaultLineCap;
        let lineJoin = defaultLineJoin;
        let miterLimit = 0;
        let lineDash = null;
        let lineDashOffset = 0;
        let strokeStyle;
        let strokeWidth = 0;
        if (this.stroke_) {
          strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);
          strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;
          lineDash = this.stroke_.getLineDash();
          lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
          lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;
          lineCap = this.stroke_.getLineCap() ?? defaultLineCap;
          miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;
        }
        const add5 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        const maxRadius = Math.max(this.radius, this.radius2_ || 0);
        const size = Math.ceil(2 * maxRadius + add5);
        return {
          strokeStyle,
          strokeWidth,
          size,
          lineCap,
          lineDash,
          lineDashOffset,
          lineJoin,
          miterLimit
        };
      }
      /**
       * @protected
       */
      render() {
        this.renderOptions_ = this.createRenderOptions();
        const size = this.renderOptions_.size;
        this.hitDetectionCanvas_ = null;
        this.size_ = [size, size];
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} pixelRatio The pixel ratio.
       */
      draw_(renderOptions, context2, pixelRatio) {
        context2.scale(pixelRatio, pixelRatio);
        context2.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context2);
        if (this.fill_) {
          let color = this.fill_.getColor();
          if (color === null) {
            color = defaultFillStyle;
          }
          context2.fillStyle = asColorLike(color);
          context2.fill();
        }
        if (renderOptions.strokeStyle) {
          context2.strokeStyle = renderOptions.strokeStyle;
          context2.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context2.setLineDash(renderOptions.lineDash);
            context2.lineDashOffset = renderOptions.lineDashOffset;
          }
          context2.lineCap = renderOptions.lineCap;
          context2.lineJoin = renderOptions.lineJoin;
          context2.miterLimit = renderOptions.miterLimit;
          context2.stroke();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @return {HTMLCanvasElement} Canvas containing the icon
       */
      createHitDetectionCanvas_(renderOptions) {
        let context2;
        if (this.fill_) {
          let color = this.fill_.getColor();
          let opacity = 0;
          if (typeof color === "string") {
            color = asArray(color);
          }
          if (color === null) {
            opacity = 1;
          } else if (Array.isArray(color)) {
            opacity = color.length === 4 ? color[3] : 1;
          }
          if (opacity === 0) {
            context2 = createCanvasContext2D(renderOptions.size, renderOptions.size);
            this.drawHitDetectionCanvas_(renderOptions, context2);
          }
        }
        return context2 ? context2.canvas : this.getImage(1);
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context The context to draw in.
       */
      createPath_(context2) {
        let points = this.points_;
        const radius = this.radius;
        if (points === Infinity) {
          context2.arc(0, 0, radius, 0, 2 * Math.PI);
        } else {
          const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
          if (this.radius2_ !== void 0) {
            points *= 2;
          }
          const startAngle = this.angle_ - Math.PI / 2;
          const step = 2 * Math.PI / points;
          for (let i = 0; i < points; i++) {
            const angle0 = startAngle + i * step;
            const radiusC = i % 2 === 0 ? radius : radius2;
            context2.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
          }
          context2.closePath();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       */
      drawHitDetectionCanvas_(renderOptions, context2) {
        context2.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context2);
        context2.fillStyle = defaultFillStyle;
        context2.fill();
        if (renderOptions.strokeStyle) {
          context2.strokeStyle = renderOptions.strokeStyle;
          context2.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context2.setLineDash(renderOptions.lineDash);
            context2.lineDashOffset = renderOptions.lineDashOffset;
          }
          context2.lineJoin = renderOptions.lineJoin;
          context2.miterLimit = renderOptions.miterLimit;
          context2.stroke();
        }
      }
      /**
       * @override
       */
      ready() {
        return this.fill_ ? this.fill_.ready() : Promise.resolve();
      }
    };
    RegularShape_default = RegularShape;
  }
});

// node_modules/ol/style/Circle.js
var CircleStyle, Circle_default;
var init_Circle = __esm({
  "node_modules/ol/style/Circle.js"() {
    init_RegularShape();
    CircleStyle = class _CircleStyle extends RegularShape_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options2) {
        options2 = options2 ? options2 : { radius: 5 };
        super({
          points: Infinity,
          fill: options2.fill,
          radius: options2.radius,
          stroke: options2.stroke,
          scale: options2.scale !== void 0 ? options2.scale : 1,
          rotation: options2.rotation !== void 0 ? options2.rotation : 0,
          rotateWithView: options2.rotateWithView !== void 0 ? options2.rotateWithView : false,
          displacement: options2.displacement !== void 0 ? options2.displacement : [0, 0],
          declutterMode: options2.declutterMode
        });
      }
      /**
       * Clones the style.
       * @return {CircleStyle} The cloned style.
       * @api
       * @override
       */
      clone() {
        const scale4 = this.getScale();
        const style = new _CircleStyle({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          radius: this.getRadius(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Set the circle radius.
       *
       * @param {number} radius Circle radius.
       * @api
       */
      setRadius(radius) {
        this.radius = radius;
        this.render();
      }
    };
    Circle_default = CircleStyle;
  }
});

// node_modules/ol/style/Fill.js
var Fill, Fill_default;
var init_Fill = __esm({
  "node_modules/ol/style/Fill.js"() {
    init_ImageState();
    init_color2();
    init_util();
    init_IconImage();
    Fill = class _Fill {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options2) {
        options2 = options2 || {};
        this.patternImage_ = null;
        this.color_ = null;
        if (options2.color !== void 0) {
          this.setColor(options2.color);
        }
      }
      /**
       * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
       * @return {Fill} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Fill({
          color: Array.isArray(color) ? color.slice() : color || void 0
        });
      }
      /**
       * Get the fill color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
       * @api
       */
      setColor(color) {
        if (color !== null && typeof color === "object" && "src" in color) {
          const patternImage = get6(
            null,
            color.src,
            "anonymous",
            void 0,
            color.offset ? null : color.color ? color.color : null,
            !(color.offset && color.size)
          );
          patternImage.ready().then(() => {
            this.patternImage_ = null;
          });
          if (patternImage.getImageState() === ImageState_default.IDLE) {
            patternImage.load();
          }
          if (patternImage.getImageState() === ImageState_default.LOADING) {
            this.patternImage_ = patternImage;
          }
        }
        this.color_ = color;
      }
      /**
       * @return {string} Key of the fill for cache lookup.
       */
      getKey() {
        const fill = this.getColor();
        if (!fill) {
          return "";
        }
        return fill instanceof CanvasPattern || fill instanceof CanvasGradient ? getUid(fill) : typeof fill === "object" && "src" in fill ? fill.src + ":" + fill.offset : asArray(fill).toString();
      }
      /**
       * @return {boolean} The fill style is loading an image pattern.
       */
      loading() {
        return !!this.patternImage_;
      }
      /**
       * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
       */
      ready() {
        return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
      }
    };
    Fill_default = Fill;
  }
});

// node_modules/ol/style/Stroke.js
var Stroke, Stroke_default;
var init_Stroke = __esm({
  "node_modules/ol/style/Stroke.js"() {
    Stroke = class _Stroke {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options2) {
        options2 = options2 || {};
        this.color_ = options2.color !== void 0 ? options2.color : null;
        this.lineCap_ = options2.lineCap;
        this.lineDash_ = options2.lineDash !== void 0 ? options2.lineDash : null;
        this.lineDashOffset_ = options2.lineDashOffset;
        this.lineJoin_ = options2.lineJoin;
        this.miterLimit_ = options2.miterLimit;
        this.width_ = options2.width;
      }
      /**
       * Clones the style.
       * @return {Stroke} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Stroke({
          color: Array.isArray(color) ? color.slice() : color || void 0,
          lineCap: this.getLineCap(),
          lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
          lineDashOffset: this.getLineDashOffset(),
          lineJoin: this.getLineJoin(),
          miterLimit: this.getMiterLimit(),
          width: this.getWidth()
        });
      }
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */
      getLineCap() {
        return this.lineCap_;
      }
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>|null} Line dash.
       * @api
       */
      getLineDash() {
        return this.lineDash_;
      }
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */
      getLineDashOffset() {
        return this.lineDashOffset_;
      }
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */
      getLineJoin() {
        return this.lineJoin_;
      }
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */
      getMiterLimit() {
        return this.miterLimit_;
      }
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */
      getWidth() {
        return this.width_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      setColor(color) {
        this.color_ = color;
      }
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */
      setLineCap(lineCap) {
        this.lineCap_ = lineCap;
      }
      /**
       * Set the line dash.
       *
       * @param {Array<number>|null} lineDash Line dash.
       * @api
       */
      setLineDash(lineDash) {
        this.lineDash_ = lineDash;
      }
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */
      setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
      }
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */
      setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
      }
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */
      setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
      }
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */
      setWidth(width) {
        this.width_ = width;
      }
    };
    Stroke_default = Stroke;
  }
});

// node_modules/ol/style/Style.js
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style, Style_default;
var init_Style = __esm({
  "node_modules/ol/style/Style.js"() {
    Style = class _Style {
      /**
       * @param {Options} [options] Style options.
       */
      constructor(options2) {
        options2 = options2 || {};
        this.geometry_ = null;
        this.geometryFunction_ = defaultGeometryFunction;
        if (options2.geometry !== void 0) {
          this.setGeometry(options2.geometry);
        }
        this.fill_ = options2.fill !== void 0 ? options2.fill : null;
        this.image_ = options2.image !== void 0 ? options2.image : null;
        this.renderer_ = options2.renderer !== void 0 ? options2.renderer : null;
        this.hitDetectionRenderer_ = options2.hitDetectionRenderer !== void 0 ? options2.hitDetectionRenderer : null;
        this.stroke_ = options2.stroke !== void 0 ? options2.stroke : null;
        this.text_ = options2.text !== void 0 ? options2.text : null;
        this.zIndex_ = options2.zIndex;
      }
      /**
       * Clones the style.
       * @return {Style} The cloned style.
       * @api
       */
      clone() {
        let geometry = this.getGeometry();
        if (geometry && typeof geometry === "object") {
          geometry = /** @type {import("../geom/Geometry.js").default} */
          geometry.clone();
        }
        return new _Style({
          geometry: geometry ?? void 0,
          fill: this.getFill() ? this.getFill().clone() : void 0,
          image: this.getImage() ? this.getImage().clone() : void 0,
          renderer: this.getRenderer() ?? void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          text: this.getText() ? this.getText().clone() : void 0,
          zIndex: this.getZIndex()
        });
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setRenderer} or the `renderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getRenderer() {
        return this.renderer_;
      }
      /**
       * Sets a custom renderer function for this style. When set, `fill`, `stroke`
       * and `image` options of the style will be ignored.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setRenderer(renderer) {
        this.renderer_ = renderer;
      }
      /**
       * Sets a custom renderer function for this style used
       * in hit detection.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setHitDetectionRenderer(renderer) {
        this.hitDetectionRenderer_ = renderer;
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
      }
      /**
       * Get the geometry to be rendered.
       * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
       * Feature property or geometry or function that returns the geometry that will
       * be rendered with this style.
       * @api
       */
      getGeometry() {
        return this.geometry_;
      }
      /**
       * Get the function used to generate a geometry for rendering.
       * @return {!GeometryFunction} Function that is called with a feature
       * and returns the geometry to render instead of the feature's geometry.
       * @api
       */
      getGeometryFunction() {
        return this.geometryFunction_;
      }
      /**
       * Get the fill style.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Get the image style.
       * @return {import("./Image.js").default|null} Image style.
       * @api
       */
      getImage() {
        return this.image_;
      }
      /**
       * Set the image style.
       * @param {import("./Image.js").default} image Image style.
       * @api
       */
      setImage(image) {
        this.image_ = image;
      }
      /**
       * Get the stroke style.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Get the text style.
       * @return {import("./Text.js").default|null} Text style.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Set the text style.
       * @param {import("./Text.js").default} text Text style.
       * @api
       */
      setText(text2) {
        this.text_ = text2;
      }
      /**
       * Get the z-index for the style.
       * @return {number|undefined} ZIndex.
       * @api
       */
      getZIndex() {
        return this.zIndex_;
      }
      /**
       * Set a geometry that is rendered instead of the feature's geometry.
       *
       * @param {string|import("../geom/Geometry.js").default|GeometryFunction|null} geometry
       *     Feature property or geometry or function returning a geometry to render
       *     for this style.
       * @api
       */
      setGeometry(geometry) {
        if (typeof geometry === "function") {
          this.geometryFunction_ = geometry;
        } else if (typeof geometry === "string") {
          this.geometryFunction_ = function(feature) {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              feature.get(geometry)
            );
          };
        } else if (!geometry) {
          this.geometryFunction_ = defaultGeometryFunction;
        } else if (geometry !== void 0) {
          this.geometryFunction_ = function() {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              geometry
            );
          };
        }
        this.geometry_ = geometry;
      }
      /**
       * Set the z-index.
       *
       * @param {number|undefined} zIndex ZIndex.
       * @api
       */
      setZIndex(zIndex) {
        this.zIndex_ = zIndex;
      }
    };
    Style_default = Style;
  }
});

// .svelte-kit/output/server/chunks/MapViewport.js
function onDestroy(fn) {
  ssr_context.r.on_destroy(fn);
}
function SearchOverlay($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    const noop2 = () => {
    };
    let panelCollapsed = fallback($$props["panelCollapsed"], false);
    let searchQuery = fallback($$props["searchQuery"], "");
    let searchResults = fallback($$props["searchResults"], () => [], true);
    let searchLoading = fallback($$props["searchLoading"], false);
    let searchNotice = fallback($$props["searchNotice"], null);
    let searchNoticeType = fallback($$props["searchNoticeType"], "info");
    let appMode = fallback($$props["appMode"], "explore");
    let queueSearch = fallback($$props["queueSearch"], noop2);
    let locateUser = fallback($$props["locateUser"], noop2);
    let clearSearch = fallback($$props["clearSearch"], noop2);
    let zoomToSearchResult = fallback($$props["zoomToSearchResult"], noop2);
    let addSearchResultToAnnotations = fallback($$props["addSearchResultToAnnotations"], noop2);
    let presenting = fallback($$props["presenting"], false);
    if (!panelCollapsed && !presenting) {
      $$renderer2.push("<!--[-->");
      $$renderer2.push(`<div class="search-overlay svelte-bzaubf"><div class="search-box svelte-bzaubf"><div class="search-row svelte-bzaubf"><div class="input-wrapper svelte-bzaubf"><span class="input-icon svelte-bzaubf" aria-hidden="true"><svg viewBox="0 0 20 20" fill="currentColor" class="svelte-bzaubf"><path fill-rule="evenodd" d="M8.5 3.5a5 5 0 013.95 8.08l3.23 3.23a.75.75 0 11-1.06 1.06l-3.23-3.23A5 5 0 118.5 3.5zm0 1.5a3.5 3.5 0 100 7 3.5 3.5 0 000-7z" clip-rule="evenodd"></path></svg></span> <input type="text" placeholder="Search for a place or address\u2026"${attr("value", searchQuery)} aria-label="Search for a place or address" class="svelte-bzaubf"/></div> <button type="button" class="chip ghost svelte-bzaubf"${attr("disabled", searchLoading, true)}><span class="chip-icon" aria-hidden="true">\u{1F4CD}</span> Locate</button> <button type="button" class="chip ghost svelte-bzaubf"${attr("disabled", !searchQuery && !searchResults.length, true)}><span class="chip-icon" aria-hidden="true">\u2715</span> Clear</button></div> <div class="search-status svelte-bzaubf">`);
      if (searchLoading) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<span>Searching\u2026</span>`);
      } else {
        $$renderer2.push("<!--[!-->");
        if (searchNotice) {
          $$renderer2.push("<!--[-->");
          $$renderer2.push(`<span${attr_class("svelte-bzaubf", void 0, {
            "errored": searchNoticeType === "error",
            "success": searchNoticeType === "success"
          })}>${escape_html(searchNotice)}</span>`);
        } else {
          $$renderer2.push("<!--[!-->");
        }
        $$renderer2.push(`<!--]-->`);
      }
      $$renderer2.push(`<!--]--></div> `);
      if (searchResults.length) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<div class="search-results svelte-bzaubf"><!--[-->`);
        const each_array = ensure_array_like(searchResults);
        for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
          let result = each_array[$$index];
          $$renderer2.push(`<div class="search-result svelte-bzaubf"><button type="button" class="result-main svelte-bzaubf"><span class="result-title svelte-bzaubf">${escape_html(result.display_name)}</span> `);
          if (result.type) {
            $$renderer2.push("<!--[-->");
            $$renderer2.push(`<span class="result-type svelte-bzaubf">${escape_html(result.type)}</span>`);
          } else {
            $$renderer2.push("<!--[!-->");
          }
          $$renderer2.push(`<!--]--></button> `);
          if (appMode === "create") {
            $$renderer2.push("<!--[-->");
            $$renderer2.push(`<button type="button" class="chip add"><span class="chip-icon" aria-hidden="true">\uFF0B</span> Add</button>`);
          } else {
            $$renderer2.push("<!--[!-->");
          }
          $$renderer2.push(`<!--]--></div>`);
        }
        $$renderer2.push(`<!--]--></div>`);
      } else {
        $$renderer2.push("<!--[!-->");
      }
      $$renderer2.push(`<!--]--></div></div>`);
    } else {
      $$renderer2.push("<!--[!-->");
    }
    $$renderer2.push(`<!--]-->`);
    bind_props($$props, {
      panelCollapsed,
      searchQuery,
      searchResults,
      searchLoading,
      searchNotice,
      searchNoticeType,
      appMode,
      queueSearch,
      locateUser,
      clearSearch,
      zoomToSearchResult,
      addSearchResultToAnnotations,
      presenting
    });
  });
}
function BasemapButtons($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    let basemaps = fallback($$props["basemaps"], () => [], true);
    let selected = fallback($$props["selected"], "");
    let label = fallback($$props["label"], "Basemap selection");
    $$renderer2.push(`<div class="basemap-buttons svelte-8cdsst" role="group"${attr("aria-label", label)}><!--[-->`);
    const each_array = ensure_array_like(basemaps);
    for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
      let basemap = each_array[$$index];
      $$renderer2.push(`<button type="button"${attr("aria-pressed", selected === basemap.key)}${attr_class("svelte-8cdsst", void 0, { "selected": selected === basemap.key })}>${escape_html(basemap.label)}</button>`);
    }
    $$renderer2.push(`<!--]--></div>`);
    bind_props($$props, { basemaps, selected, label });
  });
}
function randomId(prefix = "anno") {
  const random = Math.random().toString(36).slice(2, 8);
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return `${prefix}-${crypto.randomUUID()}`;
  }
  return `${prefix}-${Date.now().toString(36)}-${random}`;
}
function ensureAnnotationDefaults(feature) {
  let id = feature.getId();
  if (!id) {
    id = randomId();
    feature.setId(id);
  }
  if (!feature.get("label")) {
    feature.set("label", "Untitled");
  }
  if (!feature.get("color")) {
    feature.set("color", DEFAULT_ANNOTATION_COLOR);
  }
  if (typeof feature.get("hidden") !== "boolean") {
    feature.set("hidden", false);
  }
}
function toAnnotationSummary(feature) {
  ensureAnnotationDefaults(feature);
  return {
    id: feature.getId(),
    label: feature.get("label") ?? "Untitled",
    type: feature.getGeometry()?.getType() ?? "Geometry",
    color: feature.get("color") ?? DEFAULT_ANNOTATION_COLOR,
    details: feature.get("details") ?? "",
    hidden: Boolean(feature.get("hidden"))
  };
}
function MapViewport($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    let visibleStoryScenes, currentStoryScene, basemapLabel, selectedMapLabel, opacityPercent, modeLabel;
    const geoJsonFormat = new GeoJSON_default();
    let initialMode2 = fallback($$props["initialMode"], "explore");
    let showWelcomeOverlay = fallback($$props["showWelcomeOverlay"], true);
    let layout = fallback($$props["layout"], "desktop");
    let basemapSelection = "g-streets";
    let mapTypeSelection = "all";
    let selectedMapId = "";
    let statusMessage = "Select a map from the list.";
    let mapList = [];
    let filteredMapList = [];
    let panelCollapsed = false;
    let statusError = false;
    let opacity = 0.8;
    let showWelcome = showWelcomeOverlay;
    let appMode = initialMode2;
    let modeMenuOpen = false;
    let selectedAnnotationId = null;
    let searchQuery = "";
    let searchResults = [];
    let searchLoading = false;
    let searchNotice = null;
    let searchNoticeType = "info";
    let searchDebounce = null;
    let searchAbortController = null;
    let storyScenes = [];
    let storyPresenting = false;
    let storyActiveSceneIndex = 0;
    let createPanelTab = "map";
    let map = null;
    let warpedLayer = null;
    let annotationSource = null;
    let searchSource = null;
    let drawInteraction = null;
    let modifyInteraction = null;
    let selectInteraction = null;
    let annotationListenerKeys = [];
    let viewMode = "overlay";
    function updateAnnotationSummaries() {
      const list = annotationSource ? annotationSource.getFeatures().map((feature) => toAnnotationSummary(feature)) : [];
      if (selectedAnnotationId && !list.some((item) => item.id === selectedAnnotationId)) {
        selectedAnnotationId = null;
      }
    }
    function applyBasemap(name) {
      if (!map) return;
      map.getLayers().getArray().forEach((layer) => {
        const props = layer.getProperties();
        if (props.base) {
          layer.setVisible(props.name === name);
        }
      });
    }
    function ensureOverlayCanvas() {
      return warpedLayer?.getCanvas() ?? null;
    }
    function updateClipMask() {
      const canvas = ensureOverlayCanvas();
      if (!canvas || !map) return;
      const size = map.getSize();
      if (!size) return;
      const [w, h] = size;
      {
        canvas.style.clipPath = "";
      }
    }
    function updateDividersAndHandles() {
      if (!map) return;
      const size = map.getSize();
      if (!size) return;
      const [w, h] = size;
    }
    function updateLens() {
      if (!map) return;
      const size = map.getSize();
      if (!size) return;
      const [w, h] = size;
    }
    function refreshDecorations() {
      updateClipMask();
      updateDividersAndHandles();
      updateLens();
    }
    function handlePointerDrag(event) {
      if (!map) return;
      return;
    }
    function stopPointerDrag() {
      return;
    }
    function removeDrawInteraction() {
      if (!map || !drawInteraction) return;
      map.removeInteraction(drawInteraction);
      drawInteraction = null;
    }
    function clearSearchResults() {
      searchResults = [];
      searchNotice = null;
      searchNoticeType = "info";
      searchLoading = false;
    }
    function featureFromSearchResult(result) {
      try {
        if (result.geojson) {
          const feature = geoJsonFormat.readFeature({ type: "Feature", geometry: result.geojson, properties: {} }, { dataProjection: "EPSG:4326", featureProjection: "EPSG:3857" });
          feature.set("label", result.display_name ?? result.type ?? "Search result");
          return feature;
        }
        if (result.lon && result.lat) {
          const point = new Point_default(fromLonLat2([Number(result.lon), Number(result.lat)]));
          const feature = new Feature_default({ geometry: point });
          feature.set("label", result.display_name ?? result.type ?? "Search result");
          return feature;
        }
      } catch (error2) {
        console.warn("Unable to create feature from search result", error2);
      }
      return null;
    }
    async function runSearch(query) {
      const trimmed = query.trim();
      searchQuery = query;
      if (!trimmed) {
        clearSearchResults();
        searchSource?.clear();
        searchAbortController?.abort();
        searchAbortController = null;
        return;
      }
      searchAbortController?.abort();
      searchAbortController = new AbortController();
      searchLoading = true;
      searchNotice = null;
      searchNoticeType = "info";
      try {
        const params2 = new URLSearchParams({
          format: "jsonv2",
          q: trimmed,
          addressdetails: "1",
          polygon_geojson: "1",
          limit: "10"
        });
        const response = await fetch(`https://nominatim.openstreetmap.org/search?${params2.toString()}`, {
          signal: searchAbortController.signal,
          headers: { Accept: "application/json" }
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        searchResults = data;
        if (!data.length) {
          searchNotice = "No results found.";
          searchNoticeType = "info";
        }
      } catch (error2) {
        if (error2.name === "AbortError") return;
        searchNotice = "Search failed. Please try again.";
        searchNoticeType = "error";
        console.error("Search error:", error2);
        searchResults = [];
      } finally {
        searchLoading = false;
      }
    }
    function queueSearch(query) {
      searchQuery = query;
      if (searchDebounce) clearTimeout(searchDebounce);
      const delay = 1e3;
      searchDebounce = window.setTimeout(
        () => {
          runSearch(query);
        },
        delay
      );
    }
    function zoomToSearchResult(result) {
      if (!map || !searchSource) return;
      const feature = featureFromSearchResult(result);
      if (!feature) return;
      searchSource.clear();
      searchSource.addFeature(feature);
      const geometry = feature.getGeometry();
      if (!geometry) return;
      if (geometry.getType() === "Point") {
        const coords = geometry.getCoordinates();
        map.getView().animate({
          center: coords,
          zoom: Math.max(map.getView().getZoom() ?? 12, 16),
          duration: 400
        });
      } else {
        map.getView().fit(geometry.getExtent(), { padding: [80, 80, 80, 80], duration: 400, maxZoom: 18 });
      }
    }
    function addSearchResultToAnnotations(result) {
      if (!annotationSource) return;
      const feature = featureFromSearchResult(result);
      if (!feature) return;
      ensureAnnotationDefaults(feature);
      annotationSource.addFeature(feature);
      selectedAnnotationId = feature.getId();
      updateAnnotationSummaries();
      clearSearchResults();
      searchNotice = "Feature added to annotations.";
      searchNoticeType = "success";
      searchSource?.clear();
      searchQuery = "";
    }
    function clearSearch() {
      searchQuery = "";
      clearSearchResults();
      searchSource?.clear();
      searchAbortController?.abort();
      searchAbortController = null;
      searchNotice = null;
      searchNoticeType = "info";
    }
    function locateUser() {
      const currentMap = map;
      const currentSearchSource = searchSource;
      if (!currentMap || !currentSearchSource) return;
      if (!("geolocation" in navigator)) {
        searchNotice = "Geolocation is not available.";
        searchNoticeType = "error";
        return;
      }
      searchLoading = true;
      searchNotice = null;
      searchNoticeType = "info";
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const { latitude, longitude } = position.coords;
          const coords = fromLonLat2([longitude, latitude]);
          currentSearchSource.clear();
          const feature = new Feature_default({ geometry: new Point_default(coords) });
          feature.set("label", "Current location");
          currentSearchSource.addFeature(feature);
          const view = currentMap.getView();
          view.animate({
            center: coords,
            zoom: Math.max(view.getZoom() ?? 12, 16),
            duration: 450
          });
          searchLoading = false;
          searchNotice = "Centered on your location.";
          searchNoticeType = "success";
        },
        (error2) => {
          searchLoading = false;
          searchNotice = `Could not get location: ${error2.message}`;
          searchNoticeType = "error";
        }
      );
    }
    onDestroy(() => {
      searchAbortController?.abort();
      window.removeEventListener("pointermove", handlePointerDrag);
      window.removeEventListener("pointerup", stopPointerDrag);
      window.removeEventListener("pointercancel", stopPointerDrag);
      annotationListenerKeys.forEach((key2) => unByKey(key2));
      annotationListenerKeys = [];
      removeDrawInteraction();
      if (map && modifyInteraction) {
        map.removeInteraction(modifyInteraction);
      }
      if (map && selectInteraction) {
        map.removeInteraction(selectInteraction);
      }
      map?.setTarget(void 0);
      map = null;
      warpedLayer = null;
      annotationSource = null;
      searchSource = null;
      modifyInteraction = null;
      selectInteraction = null;
    });
    visibleStoryScenes = storyScenes.filter((scene) => !scene.hidden);
    currentStoryScene = storyScenes[storyActiveSceneIndex] ?? null;
    currentStoryScene ? visibleStoryScenes.findIndex((scene) => scene.id === currentStoryScene.id) + 1 : 0;
    basemapLabel = BASEMAP_DEFS.find((base2) => base2.key === basemapSelection)?.label ?? "Basemap";
    selectedMapLabel = mapList.find((m) => m.id === selectedMapId)?.name ?? "Select a map";
    opacityPercent = Math.round(opacity * 100);
    modeLabel = appMode === "explore" ? "Exploring" : "Creating";
    filteredMapList = mapList;
    applyBasemap(basemapSelection);
    refreshDecorations();
    let $$settled = true;
    let $$inner_renderer;
    function $$render_inner($$renderer3) {
      $$renderer3.push(`<div${attr_class("viewer svelte-1gd50sk", void 0, {
        "layout-mobile": layout === "mobile",
        "layout-tablet": layout === "tablet",
        "layout-desktop": layout === "desktop"
      })}>`);
      if (showWelcome) {
        $$renderer3.push("<!--[-->");
        $$renderer3.push(`<div class="welcome-overlay svelte-1gd50sk"><div class="welcome-card svelte-1gd50sk"><h1 class="svelte-1gd50sk">Welcome to the viewer</h1> <p class="svelte-1gd50sk">This experience lets you explore historic maps alongside the modern web. Pick how you want to get started.</p> <div class="welcome-actions svelte-1gd50sk"><button type="button"${attr_class("svelte-1gd50sk", void 0, { "selected": appMode === "explore" })}>Exploring</button> <button type="button"${attr_class("svelte-1gd50sk", void 0, { "selected": appMode === "create" })}>Creating</button></div></div></div>`);
      } else {
        $$renderer3.push("<!--[!-->");
      }
      $$renderer3.push(`<!--]--> <div class="map-wrapper svelte-1gd50sk"><div class="map svelte-1gd50sk"></div> <div class="divider vertical svelte-1gd50sk" aria-hidden="true"></div> <div class="divider horizontal svelte-1gd50sk" aria-hidden="true"></div> <button class="handle vertical svelte-1gd50sk" type="button" aria-label="Drag vertical split" title="Drag vertical split"></button> <button class="handle horizontal svelte-1gd50sk" type="button" aria-label="Drag horizontal split" title="Drag horizontal split"></button> <div class="lens svelte-1gd50sk" aria-hidden="true"></div> <button class="lens-handle svelte-1gd50sk" type="button" aria-label="Adjust spyglass radius" title="Adjust spyglass radius"></button></div> `);
      SearchOverlay($$renderer3, {
        panelCollapsed,
        searchResults,
        searchLoading,
        searchNotice,
        searchNoticeType,
        appMode,
        queueSearch,
        locateUser,
        clearSearch,
        zoomToSearchResult,
        addSearchResultToAnnotations,
        presenting: storyPresenting,
        get searchQuery() {
          return searchQuery;
        },
        set searchQuery($$value) {
          searchQuery = $$value;
          $$settled = false;
        }
      });
      $$renderer3.push(`<!----> `);
      {
        $$renderer3.push("<!--[!-->");
      }
      $$renderer3.push(`<!--]--> <div${attr_class("control-bar svelte-1gd50sk", void 0, { "presenting": storyPresenting })}><div${attr_class("control-panel svelte-1gd50sk", void 0, {
        "collapsed": panelCollapsed,
        "disabled": searchLoading || storyPresenting
      })}><div class="panel-header svelte-1gd50sk"><div class="panel-summary svelte-1gd50sk"><span class="panel-title svelte-1gd50sk">${escape_html(selectedMapLabel)}</span> <span class="panel-sub svelte-1gd50sk">${escape_html(basemapLabel)} \xB7 ${escape_html(opacityPercent)}% \xB7 ${escape_html(modeLabel)}</span></div> <div class="panel-actions svelte-1gd50sk"><div class="mode-control svelte-1gd50sk"><button type="button" class="settings-button svelte-1gd50sk" aria-haspopup="true"${attr("aria-expanded", modeMenuOpen)}>Settings</button> `);
      {
        $$renderer3.push("<!--[!-->");
      }
      $$renderer3.push(`<!--]--></div> <button type="button" class="collapse-toggle svelte-1gd50sk"${attr("aria-expanded", !panelCollapsed)}>${escape_html("Collapse")}</button></div></div> `);
      {
        $$renderer3.push("<!--[!-->");
        $$renderer3.push(`<div class="panel-content svelte-1gd50sk">`);
        if (appMode === "create") {
          $$renderer3.push("<!--[-->");
          $$renderer3.push(`<div class="create-tabs svelte-1gd50sk" role="tablist" aria-label="Create mode sections"><button type="button" role="tab"${attr("aria-selected", createPanelTab === "map")}${attr_class("svelte-1gd50sk", void 0, { "selected": createPanelTab === "map" })}>Map</button> <button type="button" role="tab"${attr("aria-selected", createPanelTab === "annotations")}${attr_class("svelte-1gd50sk", void 0, { "selected": createPanelTab === "annotations" })}>Annotations</button> <button type="button" role="tab"${attr("aria-selected", createPanelTab === "story")}${attr_class("svelte-1gd50sk", void 0, { "selected": createPanelTab === "story" })}>Storytelling</button></div>`);
        } else {
          $$renderer3.push("<!--[!-->");
        }
        $$renderer3.push(`<!--]--> `);
        {
          $$renderer3.push("<!--[-->");
          $$renderer3.push(`<section class="control-section svelte-1gd50sk"><p class="section-title svelte-1gd50sk">Base map</p> <div class="section-body svelte-1gd50sk"><div class="control-group svelte-1gd50sk">`);
          BasemapButtons($$renderer3, { basemaps: BASEMAP_DEFS, selected: basemapSelection });
          $$renderer3.push(`<!----></div></div></section> <section class="control-section svelte-1gd50sk"><p class="section-title svelte-1gd50sk">Overlay map</p> <div class="section-body overlay-grid svelte-1gd50sk"><label class="control-group svelte-1gd50sk"><span class="control-label svelte-1gd50sk">Type</span> `);
          $$renderer3.select(
            { value: mapTypeSelection, class: "" },
            ($$renderer4) => {
              $$renderer4.option({ value: "all" }, ($$renderer5) => {
                $$renderer5.push(`All (${escape_html(mapList.length)})`);
              });
              $$renderer4.push(`<!--[-->`);
              const each_array = ensure_array_like([...new Set(mapList.map((item) => item.type))].sort());
              for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
                let type = each_array[$$index];
                $$renderer4.option({ value: type }, ($$renderer5) => {
                  $$renderer5.push(`${escape_html(type)}`);
                });
              }
              $$renderer4.push(`<!--]-->`);
            },
            "svelte-1gd50sk"
          );
          $$renderer3.push(`</label> <label class="control-group grow svelte-1gd50sk"><span class="control-label svelte-1gd50sk">Map</span> `);
          $$renderer3.select(
            { value: selectedMapId, class: "" },
            ($$renderer4) => {
              $$renderer4.option({ value: "", disabled: true, selected: true }, ($$renderer5) => {
                $$renderer5.push(`Select\u2026`);
              });
              $$renderer4.push(`<!--[-->`);
              const each_array_1 = ensure_array_like(filteredMapList);
              for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {
                let item = each_array_1[$$index_1];
                $$renderer4.option({ value: item.id }, ($$renderer5) => {
                  $$renderer5.push(`${escape_html(item.name)}`);
                });
              }
              $$renderer4.push(`<!--]-->`);
            },
            "svelte-1gd50sk"
          );
          $$renderer3.push(`</label></div></section> <section class="control-section svelte-1gd50sk"><p class="section-title svelte-1gd50sk">View Mode &amp; Opacity</p> <div class="view-grid svelte-1gd50sk"><div class="slider-group svelte-1gd50sk"><span class="control-label svelte-1gd50sk">Opacity</span> <div class="slider svelte-1gd50sk"><input type="range" min="0" max="1" step="0.05"${attr("value", opacity)} class="svelte-1gd50sk"/> <span class="svelte-1gd50sk">${escape_html(opacityPercent)}%</span></div></div> <div class="mode-buttons svelte-1gd50sk"><button type="button"${attr_class("svelte-1gd50sk", void 0, { "selected": viewMode === "overlay" })}>Overlay</button> <button type="button"${attr_class("svelte-1gd50sk", void 0, { "selected": viewMode === "side-x" })}>Side X</button> <button type="button"${attr_class("svelte-1gd50sk", void 0, { "selected": viewMode === "side-y" })}>Side Y</button> <button type="button"${attr_class("svelte-1gd50sk", void 0, { "selected": viewMode === "spy" })}>Spyglass</button></div></div></section>`);
        }
        $$renderer3.push(`<!--]--> `);
        {
          $$renderer3.push("<!--[!-->");
        }
        $$renderer3.push(`<!--]--> `);
        {
          $$renderer3.push("<!--[!-->");
        }
        $$renderer3.push(`<!--]--> <div class="panel-footer svelte-1gd50sk"><div class="footer-actions svelte-1gd50sk"><button type="button" class="btn footer svelte-1gd50sk"${attr("disabled", true, true)}>Zoom</button> <button type="button" class="btn footer ghost svelte-1gd50sk">Clear cache</button></div> <div class="status-row svelte-1gd50sk">`);
        {
          $$renderer3.push("<!--[!-->");
        }
        $$renderer3.push(`<!--]--> <p${attr_class("svelte-1gd50sk", void 0, { "errored": statusError })}>${escape_html(statusMessage)}</p></div></div></div>`);
      }
      $$renderer3.push(`<!--]--></div></div></div>`);
    }
    do {
      $$settled = true;
      $$inner_renderer = $$renderer2.copy();
      $$render_inner($$inner_renderer);
    } while (!$$settled);
    $$renderer2.subsume($$inner_renderer);
    bind_props($$props, { initialMode: initialMode2, showWelcomeOverlay, layout });
  });
}
var DEFAULT_ANNOTATION_COLOR, BASEMAP_DEFS;
var init_MapViewport = __esm({
  ".svelte-kit/output/server/chunks/MapViewport.js"() {
    init_index2();
    init_context();
    init_proj();
    init_GeoJSON();
    init_Observable();
    init_Feature();
    init_Point();
    init_dist10();
    init_dist8();
    init_dist();
    init_Tile3();
    init_XYZ();
    init_Style();
    init_Fill();
    init_Stroke();
    init_Circle();
    DEFAULT_ANNOTATION_COLOR = "#2563eb";
    fromLonLat2([106.70098, 10.77653]);
    BASEMAP_DEFS = [
      {
        key: "g-streets",
        label: "Google Maps",
        layer: () => new Tile_default3({
          source: new XYZ_default({
            urls: [
              "https://mt0.google.com/vt/lyrs=m&x={x}&y={y}&z={z}",
              "https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}",
              "https://mt2.google.com/vt/lyrs=m&x={x}&y={y}&z={z}",
              "https://mt3.google.com/vt/lyrs=m&x={x}&y={y}&z={z}"
            ],
            attributions: "Tiles \xA9 Google",
            maxZoom: 22,
            crossOrigin: "anonymous"
          }),
          visible: true,
          properties: { name: "g-streets", base: true },
          zIndex: 0
        })
      },
      {
        key: "g-satellite",
        label: "Google Satellite",
        layer: () => new Tile_default3({
          source: new XYZ_default({
            urls: [
              "https://mt0.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
              "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
              "https://mt2.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
              "https://mt3.google.com/vt/lyrs=s&x={x}&y={y}&z={z}"
            ],
            attributions: "Tiles \xA9 Google",
            maxZoom: 22,
            crossOrigin: "anonymous"
          }),
          visible: false,
          properties: { name: "g-satellite", base: true },
          zIndex: 0
        })
      }
    ];
    new Style_default({
      image: new Circle_default({
        radius: 6,
        fill: new Fill_default({ color: "#06b6d4" }),
        stroke: new Stroke_default({ color: "#0e7490", width: 2 })
      }),
      stroke: new Stroke_default({ color: "#06b6d4", width: 2 }),
      fill: new Fill_default({ color: "rgba(6, 182, 212, 0.18)" })
    });
  }
});

// .svelte-kit/output/server/entries/pages/create/_page.svelte.js
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => _page2
});
function _page2($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    var $$store_subs;
    let layout;
    layout = store_get($$store_subs ??= {}, "$screen", screen).isDesktop ? "desktop" : store_get($$store_subs ??= {}, "$screen", screen).isTablet ? "tablet" : "mobile";
    $$renderer2.push(`<div class="create-map-area svelte-jztt4t">`);
    MapViewport($$renderer2, { initialMode: "create", showWelcomeOverlay: false, layout });
    $$renderer2.push(`<!----></div>`);
    if ($$store_subs) unsubscribe_stores($$store_subs);
  });
}
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/create/_page.svelte.js"() {
    init_index2();
    init_MapViewport();
    init_breakpoints();
  }
});

// .svelte-kit/output/server/nodes/5.js
var __exports6 = {};
__export(__exports6, {
  component: () => component6,
  fonts: () => fonts6,
  imports: () => imports6,
  index: () => index6,
  stylesheets: () => stylesheets6
});
var index6, component_cache6, component6, imports6, stylesheets6, fonts6;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    index6 = 5;
    component6 = async () => component_cache6 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default;
    imports6 = ["_app/immutable/nodes/5.CAoAq8ZC.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/CVeh0obE.js", "_app/immutable/chunks/DmKfOTeo.js", "_app/immutable/chunks/CcWUXD1I.js", "_app/immutable/chunks/Ch_7xMJZ.js", "_app/immutable/chunks/DO3z0ZUX.js", "_app/immutable/chunks/DlFo6P2L.js", "_app/immutable/chunks/q2JeGk3q.js", "_app/immutable/chunks/CyJPgw3D.js", "_app/immutable/chunks/B7pDVb1P.js"];
    stylesheets6 = ["_app/immutable/assets/breakpoints.yzSdU6gv.css", "_app/immutable/assets/MapViewport.Da8W1WUS.css", "_app/immutable/assets/5.CfPEs_yZ.css"];
    fonts6 = [];
  }
});

// .svelte-kit/output/server/entries/pages/view/_page.svelte.js
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => _page3
});
function _page3($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    var $$store_subs;
    let layout;
    layout = store_get($$store_subs ??= {}, "$screen", screen).isDesktop ? "desktop" : store_get($$store_subs ??= {}, "$screen", screen).isTablet ? "tablet" : "mobile";
    $$renderer2.push(`<div class="view-map-area svelte-108px9u">`);
    MapViewport($$renderer2, { initialMode: "explore", showWelcomeOverlay: false, layout });
    $$renderer2.push(`<!----></div>`);
    if ($$store_subs) unsubscribe_stores($$store_subs);
  });
}
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/view/_page.svelte.js"() {
    init_index2();
    init_MapViewport();
    init_breakpoints();
  }
});

// .svelte-kit/output/server/nodes/6.js
var __exports7 = {};
__export(__exports7, {
  component: () => component7,
  fonts: () => fonts7,
  imports: () => imports7,
  index: () => index7,
  stylesheets: () => stylesheets7
});
var index7, component_cache7, component7, imports7, stylesheets7, fonts7;
var init__7 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    index7 = 6;
    component7 = async () => component_cache7 ??= (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default;
    imports7 = ["_app/immutable/nodes/6.Cf9TxQc7.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/CVeh0obE.js", "_app/immutable/chunks/DmKfOTeo.js", "_app/immutable/chunks/CcWUXD1I.js", "_app/immutable/chunks/Ch_7xMJZ.js", "_app/immutable/chunks/DO3z0ZUX.js", "_app/immutable/chunks/DlFo6P2L.js", "_app/immutable/chunks/q2JeGk3q.js", "_app/immutable/chunks/CyJPgw3D.js", "_app/immutable/chunks/B7pDVb1P.js"];
    stylesheets7 = ["_app/immutable/assets/breakpoints.yzSdU6gv.css", "_app/immutable/assets/MapViewport.Da8W1WUS.css", "_app/immutable/assets/6.C5u61arx.css"];
    fonts7 = [];
  }
});

// .svelte-kit/output/server/index.js
init_false();

// node_modules/@sveltejs/kit/src/exports/index.js
init_internal();

// node_modules/esm-env/true.js
var true_default = true;

// node_modules/esm-env/dev-fallback.js
var node_env = globalThis.process?.env?.NODE_ENV;
var dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");

// node_modules/@sveltejs/kit/src/runtime/utils.js
var text_encoder = new TextEncoder();
var text_decoder = new TextDecoder();

// node_modules/@sveltejs/kit/src/exports/index.js
function error(status, body2) {
  if ((!true_default || dev_fallback_default) && (isNaN(status) || status < 400 || status > 599)) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  throw new HttpError(status, body2);
}
function json(data, init36) {
  const body2 = JSON.stringify(data);
  const headers2 = new Headers(init36?.headers);
  if (!headers2.has("content-length")) {
    headers2.set("content-length", text_encoder.encode(body2).byteLength.toString());
  }
  if (!headers2.has("content-type")) {
    headers2.set("content-type", "application/json");
  }
  return new Response(body2, {
    ...init36,
    headers: headers2
  });
}
function text(body2, init36) {
  const headers2 = new Headers(init36?.headers);
  if (!headers2.has("content-length")) {
    const encoded = text_encoder.encode(body2);
    headers2.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init36,
      headers: headers2
    });
  }
  return new Response(body2, {
    ...init36,
    headers: headers2
  });
}

// .svelte-kit/output/server/index.js
init_internal();
init_server();

// .svelte-kit/output/server/chunks/environment.js
var base = "";
var assets = base;
var app_dir = "_app";
var relative = true;
var initial = { base, assets };
function override(paths) {
  base = paths.base;
  assets = paths.assets;
}
function reset() {
  base = initial.base;
  assets = initial.assets;
}

// node_modules/devalue/src/utils.js
var escaped = {
  "<": "\\u003C",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var DevalueError = class extends Error {
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys) {
    super(message);
    this.name = "DevalueError";
    this.path = keys.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i = 0; i < len; i += 1) {
    const char = str[i];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i) + replacement;
      last_pos = i + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
var is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key2) {
  return is_identifier.test(key2) ? "." + key2 : "[" + JSON.stringify(key2) + "]";
}

// node_modules/devalue/src/uneval.js
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom2 = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing, (value2) => uneval(value2, replacer));
        if (typeof str2 === "string") {
          custom2.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
        case "URL":
        case "URLSearchParams":
          return;
        case "Array":
          thing.forEach((value2, i) => {
            keys.push(`[${i}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          walk(thing.buffer);
          return;
        case "ArrayBuffer":
          return;
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          return;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(stringify_key(key2));
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  walk(value);
  const names36 = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a, b) => b[1] - a[1]).forEach((entry, i) => {
    names36.set(entry[0], get_name(i));
  });
  function stringify3(thing) {
    if (names36.has(thing)) {
      return names36.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive(thing);
    }
    if (custom2.has(thing)) {
      return custom2.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify3(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "URL":
        return `new URL(${stringify_string(thing.toString())})`;
      case "URLSearchParams":
        return `new URLSearchParams(${stringify_string(thing.toString())})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v2, i) => i in thing ? stringify3(v2) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify3).join(",")}])`;
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array": {
        let str2 = `new ${type}`;
        if (counts.get(thing.buffer) === 1) {
          const array2 = new thing.constructor(thing.buffer);
          str2 += `([${array2}])`;
        } else {
          str2 += `([${stringify3(thing.buffer)}])`;
        }
        const a = thing.byteOffset;
        const b = a + thing.byteLength;
        if (a > 0 || b !== thing.buffer.byteLength) {
          const m = +/(\d+)/.exec(type)[1] / 8;
          str2 += `.subarray(${a / m},${b / m})`;
        }
        return str2;
      }
      case "ArrayBuffer": {
        const ui8 = new Uint8Array(thing);
        return `new Uint8Array([${ui8.toString()}]).buffer`;
      }
      case "Temporal.Duration":
      case "Temporal.Instant":
      case "Temporal.PlainDate":
      case "Temporal.PlainTime":
      case "Temporal.PlainDateTime":
      case "Temporal.PlainMonthDay":
      case "Temporal.PlainYearMonth":
      case "Temporal.ZonedDateTime":
        return `${type}.from(${stringify_string(thing.toString())})`;
      default:
        const keys2 = Object.keys(thing);
        const obj = keys2.map((key2) => `${safe_key(key2)}:${stringify3(thing[key2])}`).join(",");
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return keys2.length > 0 ? `{${obj},__proto__:null}` : `{__proto__:null}`;
        }
        return `{${obj}}`;
    }
  }
  const str = stringify3(value);
  if (names36.size) {
    const params2 = [];
    const statements = [];
    const values = [];
    names36.forEach((name, thing) => {
      params2.push(name);
      if (custom2.has(thing)) {
        values.push(
          /** @type {string} */
          custom2.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify3(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v2, i) => {
            statements.push(`${name}[${i}]=${stringify3(v2)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name}.${Array.from(thing).map((v2) => `add(${stringify3(v2)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name}.${Array.from(thing).map(([k, v2]) => `set(${stringify3(k)}, ${stringify3(v2)})`).join(".")}`
          );
          break;
        case "ArrayBuffer":
          values.push(
            `new Uint8Array([${new Uint8Array(thing).join(",")}]).buffer`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name}${safe_prop(key2)}=${stringify3(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params2.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function get_name(num) {
  let name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
function escape_unsafe_char(c2) {
  return escaped[c2] || c2;
}
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
function stringify_primitive(thing) {
  if (typeof thing === "string") return stringify_string(thing);
  if (thing === void 0) return "void 0";
  if (thing === 0 && 1 / thing < 0) return "-0";
  const str = String(thing);
  if (typeof thing === "number") return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint") return thing + "n";
  return str;
}

// node_modules/devalue/src/base64.js
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    binaryString += String.fromCharCode(dv.getUint8(i));
  }
  return binaryToAscii(binaryString);
}
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    dv.setUint8(i, binaryString.charCodeAt(i));
  }
  return arraybuffer;
}
var KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i = 0; i < data.length; i++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
function binaryToAscii(str) {
  let out = "";
  for (let i = 0; i < str.length; i += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i) & 3) << 4;
    if (str.length > i + 1) {
      groupsOfSix[1] |= str.charCodeAt(i + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i + 1) & 15) << 2;
    }
    if (str.length > i + 2) {
      groupsOfSix[2] |= str.charCodeAt(i + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i + 2) & 63;
    }
    for (let j = 0; j < groupsOfSix.length; j++) {
      if (typeof groupsOfSix[j] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j]];
      }
    }
  }
  return out;
}

// node_modules/devalue/src/constants.js
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;

// node_modules/devalue/src/parse.js
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate2(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate2(index8, standalone = false) {
    if (index8 === UNDEFINED) return void 0;
    if (index8 === NAN) return NaN;
    if (index8 === POSITIVE_INFINITY) return Infinity;
    if (index8 === NEGATIVE_INFINITY) return -Infinity;
    if (index8 === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index8 !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index8 in hydrated) return hydrated[index8];
    const value = values[index8];
    if (!value || typeof value !== "object") {
      hydrated[index8] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          let i = value[1];
          if (typeof i !== "number") {
            i = values.push(value[1]) - 1;
          }
          return hydrated[index8] = reviver(hydrate2(i));
        }
        switch (type) {
          case "Date":
            hydrated[index8] = new Date(value[1]);
            break;
          case "Set":
            const set2 = /* @__PURE__ */ new Set();
            hydrated[index8] = set2;
            for (let i = 1; i < value.length; i += 1) {
              set2.add(hydrate2(value[i]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index8] = map;
            for (let i = 1; i < value.length; i += 2) {
              map.set(hydrate2(value[i]), hydrate2(value[i + 1]));
            }
            break;
          case "RegExp":
            hydrated[index8] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index8] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index8] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index8] = obj;
            for (let i = 1; i < value.length; i += 2) {
              obj[value[i]] = hydrate2(value[i + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate2(value[1]));
            hydrated[index8] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base64 = value[1];
            const arraybuffer = decode64(base64);
            hydrated[index8] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index8] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url = new URL(value[1]);
            hydrated[index8] = url;
            break;
          }
          case "URLSearchParams": {
            const url = new URLSearchParams(value[1]);
            hydrated[index8] = url;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array2 = new Array(value.length);
        hydrated[index8] = array2;
        for (let i = 0; i < value.length; i += 1) {
          const n2 = value[i];
          if (n2 === HOLE) continue;
          array2[i] = hydrate2(n2);
        }
      }
    } else {
      const object = {};
      hydrated[index8] = object;
      for (const key2 in value) {
        if (key2 === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n2 = value[key2];
        object[key2] = hydrate2(n2);
      }
    }
    return hydrated[index8];
  }
  return hydrate2(0);
}

// node_modules/devalue/src/stringify.js
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  if (reducers) {
    for (const key2 of Object.getOwnPropertyNames(reducers)) {
      custom2.push({ key: key2, fn: reducers[key2] });
    }
  }
  const keys = [];
  let p = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index9 = p++;
    indexes.set(thing, index9);
    for (const { key: key2, fn } of custom2) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index9] = `["${key2}",${flatten(value2)}]`;
        return index9;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive2(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive2(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source: source2, flags: flags2 } = thing;
          str = flags2 ? `["RegExp",${stringify_string(source2)},"${flags2}"]` : `["RegExp",${stringify_string(source2)}]`;
          break;
        case "Array":
          str = "[";
          for (let i = 0; i < thing.length; i += 1) {
            if (i > 0) str += ",";
            if (i in thing) {
              keys.push(`[${i}]`);
              str += flatten(thing[i]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive2(key2) : "..."})`
            );
            str += `,${flatten(key2)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a = thing.byteOffset;
          const b = a + thing.byteLength;
          if (a > 0 || b !== typedArray.buffer.byteLength) {
            const m = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a / m},${b / m}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base64 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base64}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key2 in thing) {
              keys.push(stringify_key(key2));
              str += `,${stringify_string(key2)},${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key2 in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key2));
              str += `${stringify_string(key2)}:${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index9] = str;
    return index9;
  }
  const index8 = flatten(value);
  if (index8 < 0) return `${index8}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive2(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}

// .svelte-kit/output/server/index.js
init_exports();
init_utils();
init_chunks();

// .svelte-kit/output/server/chunks/internal.js
init_context();
init_index2();
init_clsx();
var public_env = {};
function set_private_env(environment) {
}
function set_public_env(environment) {
  public_env = environment;
}
function hydration_mismatch(location) {
  {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function svelte_boundary_reset_noop() {
  {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    get_next_sibling(hydrate_node)
  );
}
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    if (remove) node.remove();
    node = next2;
  }
}
function createSubscriber(start2) {
  let subscribers = 0;
  let version = source(0);
  let stop;
  return () => {
    if (effect_tracking()) {
      get(version);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start2(() => increment(version)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop?.();
              stop = void 0;
              increment(version);
            }
          });
        };
      });
    }
  };
}
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
var Boundary = class {
  /** @type {Boundary | null} */
  parent;
  #pending = false;
  /** @type {TemplateNode} */
  #anchor;
  /** @type {TemplateNode | null} */
  #hydrate_open = hydrating ? hydrate_node : null;
  /** @type {BoundaryProps} */
  #props;
  /** @type {((anchor: Node) => void)} */
  #children;
  /** @type {Effect} */
  #effect;
  /** @type {Effect | null} */
  #main_effect = null;
  /** @type {Effect | null} */
  #pending_effect = null;
  /** @type {Effect | null} */
  #failed_effect = null;
  /** @type {DocumentFragment | null} */
  #offscreen_fragment = null;
  /** @type {TemplateNode | null} */
  #pending_anchor = null;
  #local_pending_count = 0;
  #pending_count = 0;
  #is_creating_fallback = false;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #effect_pending = null;
  #effect_pending_update = () => {
    if (this.#effect_pending) {
      internal_set(this.#effect_pending, this.#local_pending_count);
    }
  };
  #effect_pending_subscriber = createSubscriber(() => {
    this.#effect_pending = source(this.#local_pending_count);
    return () => {
      this.#effect_pending = null;
    };
  });
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(node, props, children) {
    this.#anchor = node;
    this.#props = props;
    this.#children = children;
    this.parent = /** @type {Effect} */
    active_effect.b;
    this.#pending = !!this.#props.pending;
    this.#effect = block(() => {
      active_effect.b = this;
      if (hydrating) {
        const comment = this.#hydrate_open;
        hydrate_next();
        const server_rendered_pending = (
          /** @type {Comment} */
          comment.nodeType === COMMENT_NODE && /** @type {Comment} */
          comment.data === HYDRATION_START_ELSE
        );
        if (server_rendered_pending) {
          this.#hydrate_pending_content();
        } else {
          this.#hydrate_resolved_content();
        }
      } else {
        var anchor = this.#get_anchor();
        try {
          this.#main_effect = branch(() => children(anchor));
        } catch (error2) {
          this.error(error2);
        }
        if (this.#pending_count > 0) {
          this.#show_pending_snippet();
        } else {
          this.#pending = false;
        }
      }
      return () => {
        this.#pending_anchor?.remove();
      };
    }, flags);
    if (hydrating) {
      this.#anchor = hydrate_node;
    }
  }
  #hydrate_resolved_content() {
    try {
      this.#main_effect = branch(() => this.#children(this.#anchor));
    } catch (error2) {
      this.error(error2);
    }
    this.#pending = false;
  }
  #hydrate_pending_content() {
    const pending = this.#props.pending;
    if (!pending) {
      return;
    }
    this.#pending_effect = branch(() => pending(this.#anchor));
    Batch.enqueue(() => {
      var anchor = this.#get_anchor();
      this.#main_effect = this.#run(() => {
        Batch.ensure();
        return branch(() => this.#children(anchor));
      });
      if (this.#pending_count > 0) {
        this.#show_pending_snippet();
      } else {
        pause_effect(
          /** @type {Effect} */
          this.#pending_effect,
          () => {
            this.#pending_effect = null;
          }
        );
        this.#pending = false;
      }
    });
  }
  #get_anchor() {
    var anchor = this.#anchor;
    if (this.#pending) {
      this.#pending_anchor = create_text();
      this.#anchor.before(this.#pending_anchor);
      anchor = this.#pending_anchor;
    }
    return anchor;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#pending || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#props.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #run(fn) {
    var previous_effect = active_effect;
    var previous_reaction = active_reaction;
    var previous_ctx = component_context;
    set_active_effect(this.#effect);
    set_active_reaction(this.#effect);
    set_component_context(this.#effect.ctx);
    try {
      return fn();
    } catch (e3) {
      handle_error(e3);
      return null;
    } finally {
      set_active_effect(previous_effect);
      set_active_reaction(previous_reaction);
      set_component_context(previous_ctx);
    }
  }
  #show_pending_snippet() {
    const pending = (
      /** @type {(anchor: Node) => void} */
      this.#props.pending
    );
    if (this.#main_effect !== null) {
      this.#offscreen_fragment = document.createDocumentFragment();
      this.#offscreen_fragment.append(
        /** @type {TemplateNode} */
        this.#pending_anchor
      );
      move_effect(this.#main_effect, this.#offscreen_fragment);
    }
    if (this.#pending_effect === null) {
      this.#pending_effect = branch(() => pending(this.#anchor));
    }
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #update_pending_count(d) {
    if (!this.has_pending_snippet()) {
      if (this.parent) {
        this.parent.#update_pending_count(d);
      }
      return;
    }
    this.#pending_count += d;
    if (this.#pending_count === 0) {
      this.#pending = false;
      if (this.#pending_effect) {
        pause_effect(this.#pending_effect, () => {
          this.#pending_effect = null;
        });
      }
      if (this.#offscreen_fragment) {
        this.#anchor.before(this.#offscreen_fragment);
        this.#offscreen_fragment = null;
      }
    }
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(d) {
    this.#update_pending_count(d);
    this.#local_pending_count += d;
    effect_pending_updates.add(this.#effect_pending_update);
  }
  get_effect_pending() {
    this.#effect_pending_subscriber();
    return get(
      /** @type {Source<number>} */
      this.#effect_pending
    );
  }
  /** @param {unknown} error */
  error(error2) {
    var onerror = this.#props.onerror;
    let failed = this.#props.failed;
    if (this.#is_creating_fallback || !onerror && !failed) {
      throw error2;
    }
    if (this.#main_effect) {
      destroy_effect(this.#main_effect);
      this.#main_effect = null;
    }
    if (this.#pending_effect) {
      destroy_effect(this.#pending_effect);
      this.#pending_effect = null;
    }
    if (this.#failed_effect) {
      destroy_effect(this.#failed_effect);
      this.#failed_effect = null;
    }
    if (hydrating) {
      set_hydrate_node(
        /** @type {TemplateNode} */
        this.#hydrate_open
      );
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset2 = () => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      Batch.ensure();
      this.#local_pending_count = 0;
      if (this.#failed_effect !== null) {
        pause_effect(this.#failed_effect, () => {
          this.#failed_effect = null;
        });
      }
      this.#pending = this.has_pending_snippet();
      this.#main_effect = this.#run(() => {
        this.#is_creating_fallback = false;
        return branch(() => this.#children(this.#anchor));
      });
      if (this.#pending_count > 0) {
        this.#show_pending_snippet();
      } else {
        this.#pending = false;
      }
    };
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      onerror?.(error2, reset2);
      calling_on_error = false;
    } catch (error22) {
      invoke_error_boundary(error22, this.#effect && this.#effect.parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) {
      queue_micro_task(() => {
        this.#failed_effect = this.#run(() => {
          Batch.ensure();
          this.#is_creating_fallback = true;
          try {
            return branch(() => {
              failed(
                this.#anchor,
                () => error2,
                () => reset2
              );
            });
          } catch (error22) {
            invoke_error_boundary(
              error22,
              /** @type {Effect} */
              this.#effect.parent
            );
            return null;
          } finally {
            this.#is_creating_fallback = false;
          }
        });
      });
    }
  }
};
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
var last_propagated_event = null;
function handle_event_propagation(event) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event.type;
  var path = event.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event.target
  );
  last_propagated_event = event;
  var path_idx = 0;
  var handled_at = last_propagated_event === event && event.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event.target;
  if (current_target === handler_element) return;
  define_property(event, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event.target === current_target)) {
          delegated.call(current_target, event);
        }
      } catch (error2) {
        if (throw_error) {
          other_errors.push(error2);
        } else {
          throw_error = error2;
        }
      }
      if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error2 of other_errors) {
        queueMicrotask(() => {
          throw error2;
        });
      }
      throw throw_error;
    }
  } finally {
    event.__root = handler_element;
    delete event.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function assign_nodes(start2, end) {
  var effect = (
    /** @type {Effect} */
    active_effect
  );
  if (effect.nodes_start === null) {
    effect.nodes_start = start2;
    effect.nodes_end = end;
  }
}
function mount(component8, options2) {
  return _mount(component8, options2);
}
function hydrate(component8, options2) {
  init_operations();
  options2.intro = options2.intro ?? false;
  const target = options2.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component8, { ...options2, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error2) {
    if (error2 instanceof Error && error2.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error2;
    }
    if (error2 !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error2);
    }
    if (options2.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component8, options2);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
var document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context: context2, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive });
      var n2 = document_listeners.get(event_name);
      if (n2 === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n2 + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component8 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: () => {
        }
      },
      (anchor_node2) => {
        if (context2) {
          push$1({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context2;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        component8 = Component(anchor_node2, props) || {};
        if (hydrating) {
          active_effect.nodes_end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context2) {
          pop$1();
        }
      }
    );
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n2 = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n2 === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n2);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component8, unmount2);
  return component8;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component8, options2) {
  const fn = mounted_components.get(component8);
  if (fn) {
    mounted_components.delete(component8);
    return fn(options2);
  }
  return Promise.resolve();
}
function asClassComponent$1(component8) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options2) {
      super({
        component: component8,
        ...options2
      });
    }
  };
}
var Svelte4Component = class {
  /** @type {any} */
  #events;
  /** @type {Record<string, any>} */
  #instance;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options2) {
    var sources = /* @__PURE__ */ new Map();
    var add_source = (key2, value) => {
      var s3 = mutable_source(value, false, false);
      sources.set(key2, s3);
      return s3;
    };
    const props = new Proxy(
      { ...options2.props || {}, $$events: {} },
      {
        get(target, prop) {
          return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
        },
        has(target, prop) {
          if (prop === LEGACY_PROPS) return true;
          get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
          return Reflect.has(target, prop);
        },
        set(target, prop, value) {
          set(sources.get(prop) ?? add_source(prop, value), value);
          return Reflect.set(target, prop, value);
        }
      }
    );
    this.#instance = (options2.hydrate ? hydrate : mount)(options2.component, {
      target: options2.target,
      anchor: options2.anchor,
      props,
      context: options2.context,
      intro: options2.intro ?? false,
      recover: options2.recover
    });
    if (!options2?.props?.$$host || options2.sync === false) {
      flushSync();
    }
    this.#events = props.$$events;
    for (const key2 of Object.keys(this.#instance)) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
      define_property(this, key2, {
        get() {
          return this.#instance[key2];
        },
        /** @param {any} value */
        set(value) {
          this.#instance[key2] = value;
        },
        enumerable: true
      });
    }
    this.#instance.$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    this.#instance.$destroy = () => {
      unmount(this.#instance);
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    this.#instance.$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event, callback) {
    this.#events[event] = this.#events[event] || [];
    const cb = (...args) => callback.call(this, ...args);
    this.#events[event].push(cb);
    return () => {
      this.#events[event] = this.#events[event].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    this.#instance.$destroy();
  }
};
var read_implementation = null;
function set_read_implementation(fn) {
  read_implementation = fn;
}
function asClassComponent(component8) {
  const component_constructor = asClassComponent$1(component8);
  const _render = (props, { context: context2 } = {}) => {
    const result = render(component8, { props, context: context2 });
    const munged = Object.defineProperties(
      /** @type {LegacyRenderResult & PromiseLike<LegacyRenderResult>} */
      {},
      {
        css: {
          value: { code: "", map: null }
        },
        head: {
          get: () => result.head
        },
        html: {
          get: () => result.body
        },
        then: {
          /**
           * this is not type-safe, but honestly it's the best I can do right now, and it's a straightforward function.
           *
           * @template TResult1
           * @template [TResult2=never]
           * @param { (value: LegacyRenderResult) => TResult1 } onfulfilled
           * @param { (reason: unknown) => TResult2 } onrejected
           */
          value: (onfulfilled, onrejected) => {
            {
              const user_result = onfulfilled({
                css: munged.css,
                head: munged.head,
                html: munged.html
              });
              return Promise.resolve(user_result);
            }
          }
        }
      }
    );
    return munged;
  };
  component_constructor.render = _render;
  return component_constructor;
}
function Root($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    let {
      stores: stores2,
      page: page3,
      constructors,
      components = [],
      form,
      data_0 = null,
      data_1 = null,
      data_2 = null
    } = $$props;
    {
      setContext("__svelte__", stores2);
    }
    {
      stores2.page.set(page3);
    }
    const Pyramid_2 = constructors[2];
    if (constructors[1]) {
      $$renderer2.push("<!--[-->");
      const Pyramid_0 = constructors[0];
      $$renderer2.push(`<!---->`);
      Pyramid_0($$renderer2, {
        data: data_0,
        form,
        params: page3.params,
        children: ($$renderer3) => {
          if (constructors[2]) {
            $$renderer3.push("<!--[-->");
            const Pyramid_1 = constructors[1];
            $$renderer3.push(`<!---->`);
            Pyramid_1($$renderer3, {
              data: data_1,
              form,
              params: page3.params,
              children: ($$renderer4) => {
                $$renderer4.push(`<!---->`);
                Pyramid_2($$renderer4, { data: data_2, form, params: page3.params });
                $$renderer4.push(`<!---->`);
              },
              $$slots: { default: true }
            });
            $$renderer3.push(`<!---->`);
          } else {
            $$renderer3.push("<!--[!-->");
            const Pyramid_1 = constructors[1];
            $$renderer3.push(`<!---->`);
            Pyramid_1($$renderer3, { data: data_1, form, params: page3.params });
            $$renderer3.push(`<!---->`);
          }
          $$renderer3.push(`<!--]-->`);
        },
        $$slots: { default: true }
      });
      $$renderer2.push(`<!---->`);
    } else {
      $$renderer2.push("<!--[!-->");
      const Pyramid_0 = constructors[0];
      $$renderer2.push(`<!---->`);
      Pyramid_0($$renderer2, { data: data_0, form, params: page3.params });
      $$renderer2.push(`<!---->`);
    }
    $$renderer2.push(`<!--]--> `);
    {
      $$renderer2.push("<!--[!-->");
    }
    $$renderer2.push(`<!--]-->`);
  });
}
var root = asClassComponent(Root);
var options = {
  app_template_contains_nonce: false,
  async: false,
  csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, "reportOnly": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
  csrf_check_origin: true,
  csrf_trusted_origins: [],
  embedded: false,
  env_public_prefix: "PUBLIC_",
  env_private_prefix: "",
  hash_routing: false,
  hooks: null,
  // added lazily, via `get_hooks`
  preload_strategy: "modulepreload",
  root,
  service_worker: false,
  service_worker_options: void 0,
  templates: {
    app: ({ head: head2, body: body2, assets: assets2, nonce, env }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head2 + '\n	</head>\n	<body data-sveltekit-preload-data="hover">\n		<div style="display: contents">' + body2 + "</div>\n	</body>\n</html>\n",
    error: ({ status, message }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n"
  },
  version_hash: "gz84tb"
};
async function get_hooks() {
  let handle;
  let handleFetch;
  let handleError;
  let handleValidationError;
  let init36;
  let reroute;
  let transport;
  return {
    handle,
    handleFetch,
    handleError,
    handleValidationError,
    init: init36,
    reroute,
    transport
  };
}

// .svelte-kit/output/server/chunks/shared.js
init_utils();
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
function stringify2(data, transport) {
  const encoders = Object.fromEntries(Object.entries(transport).map(([k, v2]) => [k, v2.encode]));
  return stringify(data, encoders);
}
function parse_remote_arg(string, transport) {
  if (!string) return void 0;
  const json_string = text_decoder2.decode(
    // no need to add back `=` characters, atob can handle it
    base64_decode(string.replaceAll("-", "+").replaceAll("_", "/"))
  );
  const decoders = Object.fromEntries(Object.entries(transport).map(([k, v2]) => [k, v2.decode]));
  return parse(json_string, decoders);
}
function create_remote_cache_key(id, payload) {
  return id + "/" + payload;
}

// .svelte-kit/output/server/index.js
var import_cookie = __toESM(require_cookie(), 1);
var set_cookie_parser = __toESM(require_set_cookie(), 1);
function with_resolvers() {
  let resolve2;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve2 = res;
    reject = rej;
  });
  return { promise, resolve: resolve2, reject };
}
var NULL_BODY_STATUS = [101, 103, 204, 205, 304];
var IN_WEBCONTAINER2 = !!globalThis.process?.versions?.webcontainer;
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var PAGE_METHODS = ["GET", "POST", "HEAD"];
function negotiate(accept, types) {
  const parts = [];
  accept.split(",").forEach((str, i) => {
    const match2 = /([^/ \t]+)\/([^; \t]+)[ \t]*(?:;[ \t]*q=([0-9.]+))?/.exec(str);
    if (match2) {
      const [, type, subtype, q = "1"] = match2;
      parts.push({ type, subtype, q: +q, i });
    }
  });
  parts.sort((a, b) => {
    if (a.q !== b.q) {
      return b.q - a.q;
    }
    if (a.subtype === "*" !== (b.subtype === "*")) {
      return a.subtype === "*" ? 1 : -1;
    }
    if (a.type === "*" !== (b.type === "*")) {
      return a.type === "*" ? 1 : -1;
    }
    return a.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function is_content_type(request, ...types) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types.includes(type.toLowerCase());
}
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
function coalesce_to_error(err) {
  return err instanceof Error || err && /** @type {any} */
  err.name && /** @type {any} */
  err.message ? (
    /** @type {Error} */
    err
  ) : new Error(JSON.stringify(err));
}
function normalize_error(error2) {
  return (
    /** @type {import('../exports/internal/index.js').Redirect | HttpError | SvelteKitError | Error} */
    error2
  );
}
function get_status(error2) {
  return error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : 500;
}
function get_message(error2) {
  return error2 instanceof SvelteKitError ? error2.text : "Internal Error";
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
  // Svelte also escapes < because the escape function could be called inside a `noscript` there
  // https://github.com/sveltejs/svelte/security/advisories/GHSA-8266-84wp-wv5c
  // However, that doesn't apply in SvelteKit
};
var escape_html_dict = {
  "&": "&amp;",
  "<": "&lt;"
};
var surrogates = (
  // high surrogate without paired low surrogate
  "[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]"
);
var escape_html_attr_regex = new RegExp(
  `[${Object.keys(escape_html_attr_dict).join("")}]|` + surrogates,
  "g"
);
var escape_html_regex = new RegExp(
  `[${Object.keys(escape_html_dict).join("")}]|` + surrogates,
  "g"
);
function escape_html2(str, is_attr) {
  const dict = is_attr ? escape_html_attr_dict : escape_html_dict;
  const escaped_str = str.replace(is_attr ? escape_html_attr_regex : escape_html_regex, (match2) => {
    if (match2.length === 2) {
      return match2;
    }
    return dict[match2] ?? `&#${match2.charCodeAt(0)};`;
  });
  return escaped_str;
}
function method_not_allowed(mod, method) {
  return text(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
function allowed_methods(mod) {
  const allowed = ENDPOINT_METHODS.filter((method) => method in mod);
  if ("GET" in mod && !("HEAD" in mod)) {
    allowed.push("HEAD");
  }
  return allowed;
}
function get_global_name(options2) {
  return `__sveltekit_${options2.version_hash}`;
}
function static_error_page(options2, status, message) {
  let page3 = options2.templates.error({ status, message: escape_html2(message) });
  return text(page3, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
async function handle_fatal_error(event, state2, options2, error2) {
  error2 = error2 instanceof HttpError ? error2 : coalesce_to_error(error2);
  const status = get_status(error2);
  const body2 = await handle_error_and_jsonify(event, state2, options2, error2);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json(body2, {
      status
    });
  }
  return static_error_page(options2, status, body2.message);
}
async function handle_error_and_jsonify(event, state2, options2, error2) {
  if (error2 instanceof HttpError) {
    return { message: "Unknown Error", ...error2.body };
  }
  const status = get_status(error2);
  const message = get_message(error2);
  return await with_request_store(
    { event, state: state2 },
    () => options2.hooks.handleError({ error: error2, event, status, message })
  ) ?? { message };
}
function redirect_response(status, location) {
  const response = new Response(void 0, {
    status,
    headers: { location }
  });
  return response;
}
function clarify_devalue_error(event, error2) {
  if (error2.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error2.message} (${error2.path}). If you need to serialize/deserialize custom types, use transport hooks: https://svelte.dev/docs/kit/hooks#Universal-hooks-transport.`;
  }
  if (error2.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error2.message;
}
function serialize_uses(node) {
  const uses = {};
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.dependencies = Array.from(node.uses.dependencies);
  }
  if (node.uses && node.uses.search_params.size > 0) {
    uses.search_params = Array.from(node.uses.search_params);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.params = Array.from(node.uses.params);
  }
  if (node.uses?.parent) uses.parent = 1;
  if (node.uses?.route) uses.route = 1;
  if (node.uses?.url) uses.url = 1;
  return uses;
}
function has_prerendered_path(manifest2, pathname) {
  return manifest2._.prerendered_routes.has(pathname) || pathname.at(-1) === "/" && manifest2._.prerendered_routes.has(pathname.slice(0, -1));
}
function format_server_error(status, error2, event) {
  const formatted_text = `
\x1B[1;31m[${status}] ${event.request.method} ${event.url.pathname}\x1B[0m`;
  if (status === 404) {
    return formatted_text;
  }
  return `${formatted_text}
${error2.stack}`;
}
function get_node_type(node_id) {
  const parts = node_id?.split("/");
  const filename = parts?.at(-1);
  if (!filename) return "unknown";
  const dot_parts = filename.split(".");
  return dot_parts.slice(0, -1).join(".");
}
async function render_endpoint(event, event_state, mod, state2) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && !mod.HEAD && mod.GET) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state2.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state2.prerendering && !state2.prerendering.inside_reroute && !prerender) {
    if (state2.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  event_state.is_endpoint_request = true;
  try {
    const response = await with_request_store(
      { event, state: event_state },
      () => handler(
        /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
        event
      )
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state2.prerendering && (!state2.prerendering.inside_reroute || prerender)) {
      const cloned = new Response(response.clone().body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      cloned.headers.set("x-sveltekit-prerender", String(prerender));
      if (state2.prerendering.inside_reroute && prerender) {
        cloned.headers.set(
          "x-sveltekit-routeid",
          encodeURI(
            /** @type {string} */
            event.route.id
          )
        );
        state2.prerendering.dependencies.set(event.url.pathname, { response: cloned, body: null });
      } else {
        return cloned;
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return new Response(void 0, {
        status: e3.status,
        headers: { location: e3.location }
      });
    }
    throw e3;
  }
}
function is_endpoint_request(event) {
  const { method, headers: headers2 } = event.request;
  if (ENDPOINT_METHODS.includes(method) && !PAGE_METHODS.includes(method)) {
    return true;
  }
  if (method === "POST" && headers2.get("x-sveltekit-action") === "true") return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
function compact(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
var DATA_SUFFIX = "/__data.json";
var HTML_DATA_SUFFIX = ".html__data.json";
function has_data_suffix2(pathname) {
  return pathname.endsWith(DATA_SUFFIX) || pathname.endsWith(HTML_DATA_SUFFIX);
}
function add_data_suffix2(pathname) {
  if (pathname.endsWith(".html")) return pathname.replace(/\.html$/, HTML_DATA_SUFFIX);
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
function strip_data_suffix2(pathname) {
  if (pathname.endsWith(HTML_DATA_SUFFIX)) {
    return pathname.slice(0, -HTML_DATA_SUFFIX.length) + ".html";
  }
  return pathname.slice(0, -DATA_SUFFIX.length);
}
var ROUTE_SUFFIX = "/__route.js";
function has_resolution_suffix2(pathname) {
  return pathname.endsWith(ROUTE_SUFFIX);
}
function add_resolution_suffix2(pathname) {
  return pathname.replace(/\/$/, "") + ROUTE_SUFFIX;
}
function strip_resolution_suffix2(pathname) {
  return pathname.slice(0, -ROUTE_SUFFIX.length);
}
var noop_span = {
  spanContext() {
    return noop_span_context;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  }
};
var noop_span_context = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
async function record_span({ name, attributes: attributes2, fn }) {
  {
    return fn(noop_span);
  }
}
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
async function handle_action_json_request(event, event_state, options2, server2) {
  const actions = server2?.actions;
  if (!actions) {
    const no_actions_error = new SvelteKitError(
      405,
      "Method Not Allowed",
      `POST method not allowed. No form actions exist for ${"this page"}`
    );
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, event_state, options2, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions);
  try {
    const data = await call_action(event, event_state, actions);
    if (BROWSER) ;
    if (data instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data.data,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        )
      });
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return action_json_redirect(err);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(
          event,
          event_state,
          options2,
          check_incorrect_fail_use(err)
        )
      },
      {
        status: get_status(err)
      }
    );
  }
}
function check_incorrect_fail_use(error2) {
  return error2 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error2;
}
function action_json_redirect(redirect) {
  return action_json({
    type: "redirect",
    status: redirect.status,
    location: redirect.location
  });
}
function action_json(data, init210) {
  return json(data, init210);
}
function is_action_request(event) {
  return event.request.method === "POST";
}
async function handle_action_request(event, event_state, server2) {
  const actions = server2?.actions;
  if (!actions) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        `POST method not allowed. No form actions exist for ${"this page"}`
      )
    };
  }
  check_named_default_separate(actions);
  try {
    const data = await call_action(event, event_state, actions);
    if (BROWSER) ;
    if (data instanceof ActionFailure) {
      return {
        type: "failure",
        status: data.status,
        data: data.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data
      };
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
function check_named_default_separate(actions) {
  if (actions.default && Object.keys(actions).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://svelte.dev/docs/kit/form-actions#named-actions"
    );
  }
}
async function call_action(event, event_state, actions) {
  const url = new URL(event.request.url);
  let name = "default";
  for (const param of url.searchParams) {
    if (param[0].startsWith("/")) {
      name = param[0].slice(1);
      if (name === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions[name];
  if (!action) {
    throw new SvelteKitError(404, "Not Found", `No action with name '${name}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new SvelteKitError(
      415,
      "Unsupported Media Type",
      `Form actions expect form-encoded data \u2014 received ${event.request.headers.get(
        "content-type"
      )}`
    );
  }
  return record_span({
    name: "sveltekit.form_action",
    attributes: {
      "http.route": event.route.id || "unknown"
    },
    fn: async (current22) => {
      const traced_event = merge_tracing(event, current22);
      const result = await with_request_store(
        { event: traced_event, state: event_state },
        () => action(traced_event)
      );
      if (result instanceof ActionFailure) {
        current22.setAttributes({
          "sveltekit.form_action.result.type": "failure",
          "sveltekit.form_action.result.status": result.status
        });
      }
      return result;
    }
  });
}
function uneval_action_response(data, route_id, transport) {
  const replacer = (thing) => {
    for (const key2 in transport) {
      const encoded = transport[key2].encode(thing);
      if (encoded) {
        return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
      }
    }
  };
  return try_serialize(data, (value) => uneval(value, replacer), route_id);
}
function stringify_action_response(data, route_id, transport) {
  const encoders = Object.fromEntries(
    Object.entries(transport).map(([key2, value]) => [key2, value.encode])
  );
  return try_serialize(data, (value) => stringify(value, encoders), route_id);
}
function try_serialize(data, fn, route_id) {
  try {
    return fn(data);
  } catch (e3) {
    const error2 = (
      /** @type {any} */
      e3
    );
    if (data instanceof Response) {
      throw new Error(
        `Data returned from action inside ${route_id} is not serializable. Form actions need to return plain objects or fail(). E.g. return { success: true } or return fail(400, { message: "invalid" });`
      );
    }
    if ("path" in error2) {
      let message = `Data returned from action inside ${route_id} is not serializable: ${error2.message}`;
      if (error2.path !== "") message += ` (data.${error2.path})`;
      throw new Error(message);
    }
    throw error2;
  }
}
function create_async_iterator() {
  let resolved = -1;
  let returned = -1;
  const deferred2 = [];
  return {
    iterate: (transform3 = (x) => x) => {
      return {
        [Symbol.asyncIterator]() {
          return {
            next: async () => {
              const next2 = deferred2[++returned];
              if (!next2) return { value: null, done: true };
              const value = await next2.promise;
              return { value: transform3(value), done: false };
            }
          };
        }
      };
    },
    add: (promise) => {
      deferred2.push(with_resolvers());
      void promise.then((value) => {
        deferred2[++resolved].resolve(value);
      });
    }
  };
}
function server_data_serializer(event, event_state, options2) {
  let promise_id = 1;
  let max_nodes = -1;
  const iterator = create_async_iterator();
  const global = get_global_name(options2);
  function get_replacer(index8) {
    return function replacer(thing) {
      if (typeof thing?.then === "function") {
        const id = promise_id++;
        const promise = thing.then(
          /** @param {any} data */
          (data) => ({ data })
        ).catch(
          /** @param {any} error */
          async (error2) => ({
            error: await handle_error_and_jsonify(event, event_state, options2, error2)
          })
        ).then(
          /**
           * @param {{data: any; error: any}} result
           */
          async ({ data, error: error2 }) => {
            let str;
            try {
              str = uneval(error2 ? [, error2] : [data], replacer);
            } catch {
              error2 = await handle_error_and_jsonify(
                event,
                event_state,
                options2,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              data = void 0;
              str = uneval([, error2], replacer);
            }
            return {
              index: index8,
              str: `${global}.resolve(${id}, ${str.includes("app.decode") ? `(app) => ${str}` : `() => ${str}`})`
            };
          }
        );
        iterator.add(promise);
        return `${global}.defer(${id})`;
      } else {
        for (const key2 in options2.hooks.transport) {
          const encoded = options2.hooks.transport[key2].encode(thing);
          if (encoded) {
            return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
          }
        }
      }
    };
  }
  const strings = (
    /** @type {string[]} */
    []
  );
  return {
    set_max_nodes(i) {
      max_nodes = i;
    },
    add_node(i, node) {
      try {
        if (!node) {
          strings[i] = "null";
          return;
        }
        const payload = { type: "data", data: node.data, uses: serialize_uses(node) };
        if (node.slash) payload.slash = node.slash;
        strings[i] = uneval(payload, get_replacer(i));
      } catch (e3) {
        e3.path = e3.path.slice(1);
        throw new Error(clarify_devalue_error(
          event,
          /** @type {any} */
          e3
        ));
      }
    },
    get_data(csp) {
      const open = `<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>`;
      const close = `<\/script>
`;
      return {
        data: `[${compact(max_nodes > -1 ? strings.slice(0, max_nodes) : strings).join(",")}]`,
        chunks: promise_id > 1 ? iterator.iterate(({ index: index8, str }) => {
          if (max_nodes > -1 && index8 >= max_nodes) {
            return "";
          }
          return open + str + close;
        }) : null
      };
    }
  };
}
function server_data_serializer_json(event, event_state, options2) {
  let promise_id = 1;
  const iterator = create_async_iterator();
  const reducers = {
    ...Object.fromEntries(
      Object.entries(options2.hooks.transport).map(([key2, value]) => [key2, value.encode])
    ),
    /** @param {any} thing */
    Promise: (thing) => {
      if (typeof thing?.then !== "function") {
        return;
      }
      const id = promise_id++;
      let key2 = "data";
      const promise = thing.catch(
        /** @param {any} e */
        async (e3) => {
          key2 = "error";
          return handle_error_and_jsonify(
            event,
            event_state,
            options2,
            /** @type {any} */
            e3
          );
        }
      ).then(
        /** @param {any} value */
        async (value) => {
          let str;
          try {
            str = stringify(value, reducers);
          } catch {
            const error2 = await handle_error_and_jsonify(
              event,
              event_state,
              options2,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            key2 = "error";
            str = stringify(error2, reducers);
          }
          return `{"type":"chunk","id":${id},"${key2}":${str}}
`;
        }
      );
      iterator.add(promise);
      return id;
    }
  };
  const strings = (
    /** @type {string[]} */
    []
  );
  return {
    add_node(i, node) {
      try {
        if (!node) {
          strings[i] = "null";
          return;
        }
        if (node.type === "error" || node.type === "skip") {
          strings[i] = JSON.stringify(node);
          return;
        }
        strings[i] = `{"type":"data","data":${stringify(node.data, reducers)},"uses":${JSON.stringify(
          serialize_uses(node)
        )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
      } catch (e3) {
        e3.path = "data" + e3.path;
        throw new Error(clarify_devalue_error(
          event,
          /** @type {any} */
          e3
        ));
      }
    },
    get_data() {
      return {
        data: `{"type":"data","nodes":[${strings.join(",")}]}
`,
        chunks: promise_id > 1 ? iterator.iterate() : null
      };
    }
  };
}
async function load_server_data({ event, event_state, state: state2, node, parent }) {
  if (!node?.server) return null;
  let is_tracking = true;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false,
    search_params: /* @__PURE__ */ new Set()
  };
  const load2 = node.server.load;
  const slash = node.server.trailingSlash;
  if (!load2) {
    return { type: "data", data: null, uses, slash };
  }
  const url = make_trackable(
    event.url,
    () => {
      if (is_tracking) {
        uses.url = true;
      }
    },
    (param) => {
      if (is_tracking) {
        uses.search_params.add(param);
      }
    }
  );
  if (state2.prerendering) {
    disable_search(url);
  }
  const result = await record_span({
    name: "sveltekit.load",
    attributes: {
      "sveltekit.load.node_id": node.server_id || "unknown",
      "sveltekit.load.node_type": get_node_type(node.server_id),
      "http.route": event.route.id || "unknown"
    },
    fn: async (current22) => {
      const traced_event = merge_tracing(event, current22);
      const result2 = await with_request_store(
        { event: traced_event, state: event_state },
        () => load2.call(null, {
          ...traced_event,
          fetch: (info, init210) => {
            new URL(info instanceof Request ? info.url : info, event.url);
            return event.fetch(info, init210);
          },
          /** @param {string[]} deps */
          depends: (...deps) => {
            for (const dep of deps) {
              const { href } = new URL(dep, event.url);
              uses.dependencies.add(href);
            }
          },
          params: new Proxy(event.params, {
            get: (target, key2) => {
              if (is_tracking) {
                uses.params.add(key2);
              }
              return target[
                /** @type {string} */
                key2
              ];
            }
          }),
          parent: async () => {
            if (is_tracking) {
              uses.parent = true;
            }
            return parent();
          },
          route: new Proxy(event.route, {
            get: (target, key2) => {
              if (is_tracking) {
                uses.route = true;
              }
              return target[
                /** @type {'id'} */
                key2
              ];
            }
          }),
          url,
          untrack(fn) {
            is_tracking = false;
            try {
              return fn();
            } finally {
              is_tracking = true;
            }
          }
        })
      );
      return result2;
    }
  });
  return {
    type: "data",
    data: result ?? null,
    uses,
    slash
  };
}
async function load_data({
  event,
  event_state,
  fetched,
  node,
  parent,
  server_data_promise,
  state: state2,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  const load2 = node?.universal?.load;
  if (!load2) {
    return server_data_node?.data ?? null;
  }
  const result = await record_span({
    name: "sveltekit.load",
    attributes: {
      "sveltekit.load.node_id": node.universal_id || "unknown",
      "sveltekit.load.node_type": get_node_type(node.universal_id),
      "http.route": event.route.id || "unknown"
    },
    fn: async (current22) => {
      const traced_event = merge_tracing(event, current22);
      return await with_request_store(
        { event: traced_event, state: event_state },
        () => load2.call(null, {
          url: event.url,
          params: event.params,
          data: server_data_node?.data ?? null,
          route: event.route,
          fetch: create_universal_fetch(event, state2, fetched, csr, resolve_opts),
          setHeaders: event.setHeaders,
          depends: () => {
          },
          parent,
          untrack: (fn) => fn(),
          tracing: traced_event.tracing
        })
      );
    }
  });
  return result ?? null;
}
function create_universal_fetch(event, state2, fetched, csr, resolve_opts) {
  const universal_fetch = async (input, init210) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init210?.headers;
    let response = await event.fetch(input, init210);
    const url = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state2.prerendering) {
        dependency = { response, body: null };
        state2.prerendering.dependencies.set(url.pathname, dependency);
      }
    } else if (url.protocol === "https:" || url.protocol === "http:") {
      const mode2 = input instanceof Request ? input.mode : init210?.mode ?? "cors";
      if (mode2 === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    let teed_body;
    const proxy2 = new Proxy(response, {
      get(response2, key2, _receiver) {
        async function push_fetched(body2, is_b64) {
          const status_number = Number(response2.status);
          if (isNaN(status_number)) {
            throw new Error(
              `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
            );
          }
          fetched.push({
            url: same_origin ? url.href.slice(event.url.origin.length) : url.href,
            method: event.request.method,
            request_body: (
              /** @type {string | ArrayBufferView | undefined} */
              input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init210?.body
            ),
            request_headers: cloned_headers,
            response_body: body2,
            response: response2,
            is_b64
          });
        }
        if (key2 === "body") {
          if (response2.body === null) {
            return null;
          }
          if (teed_body) {
            return teed_body;
          }
          const [a, b] = response2.body.tee();
          void (async () => {
            let result = new Uint8Array();
            for await (const chunk of a) {
              const combined = new Uint8Array(result.length + chunk.length);
              combined.set(result, 0);
              combined.set(chunk, result.length);
              result = combined;
            }
            if (dependency) {
              dependency.body = new Uint8Array(result);
            }
            void push_fetched(base64_encode(result), true);
          })();
          return teed_body = b;
        }
        if (key2 === "arrayBuffer") {
          return async () => {
            const buffer = await response2.arrayBuffer();
            const bytes = new Uint8Array(buffer);
            if (dependency) {
              dependency.body = bytes;
            }
            if (buffer instanceof ArrayBuffer) {
              await push_fetched(base64_encode(bytes), true);
            }
            return buffer;
          };
        }
        async function text2() {
          const body2 = await response2.text();
          if (body2 === "" && NULL_BODY_STATUS.includes(response2.status)) {
            await push_fetched(void 0, false);
            return void 0;
          }
          if (!body2 || typeof body2 === "string") {
            await push_fetched(body2, false);
          }
          if (dependency) {
            dependency.body = body2;
          }
          return body2;
        }
        if (key2 === "text") {
          return text2;
        }
        if (key2 === "json") {
          return async () => {
            const body2 = await text2();
            return body2 ? JSON.parse(body2) : void 0;
          };
        }
        return Reflect.get(response2, key2, response2);
      }
    });
    if (csr) {
      const get7 = response.headers.get;
      response.headers.get = (key2) => {
        const lower = key2.toLowerCase();
        const value = get7.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://svelte.dev/docs/kit/hooks#Server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy2;
  };
  return (input, init210) => {
    const response = universal_fetch(input, init210);
    response.catch(() => {
    });
    return response;
  };
}
async function stream_to_string(stream) {
  let result = "";
  const reader = stream.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += text_decoder2.decode(value);
  }
  return result;
}
function hash(...values) {
  let hash22 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i = value.length;
      while (i) hash22 = hash22 * 33 ^ value.charCodeAt(--i);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i = buffer.length;
      while (i) hash22 = hash22 * 33 ^ buffer[--i];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash22 >>> 0).toString(36);
}
var replacements2 = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements2).join("")}]`, "g");
function serialize_data(fetched, filter, prerendering = false) {
  const headers2 = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key2, value] of fetched.response.headers) {
    if (filter(key2, value)) {
      headers2[key2] = value;
    }
    if (key2 === "cache-control") cache_control = value;
    else if (key2 === "age") age = value;
    else if (key2 === "vary" && value.trim() === "*") varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers: headers2,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match2) => replacements2[match2]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url="${escape_html2(fetched.url, true)}"`
  ];
  if (fetched.is_b64) {
    attrs.push("data-b64");
  }
  if (fetched.request_headers || fetched.request_body) {
    const values = [];
    if (fetched.request_headers) {
      values.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash(...values)}"`);
  }
  if (!prerendering && fetched.method === "GET" && cache_control && !varyAny) {
    const match2 = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match2) {
      const ttl = +match2[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
var s = JSON.stringify;
function sha256(data) {
  if (!key[0]) precompute();
  const out = init.slice(0);
  const array2 = encode(data);
  for (let i = 0; i < array2.length; i += 16) {
    const w = array2.subarray(i, i + 16);
    let tmp;
    let a;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i2 = 0; i2 < 64; i2++) {
      if (i2 < 16) {
        tmp = w[i2];
      } else {
        a = w[i2 + 1 & 15];
        b = w[i2 + 14 & 15];
        tmp = w[i2 & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i2 & 15] + w[i2 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i2];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return btoa(String.fromCharCode(...bytes));
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x) {
    return (x - Math.floor(x)) * 4294967296;
  }
  let prime = 2;
  for (let i = 0; i < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i < 8) {
        init[i] = frac(prime ** (1 / 2));
      }
      key[i] = frac(prime ** (1 / 3));
      i++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i = 0; i < bytes.length; i += 4) {
    const a = bytes[i + 0];
    const b = bytes[i + 1];
    const c2 = bytes[i + 2];
    const d = bytes[i + 3];
    bytes[i + 0] = d;
    bytes[i + 1] = c2;
    bytes[i + 2] = b;
    bytes[i + 3] = a;
  }
}
function encode(str) {
  const encoded = text_encoder2.encode(str);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return btoa(String.fromCharCode(...array));
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var BaseProvider = class {
  /** @type {boolean} */
  #use_hashes;
  /** @type {boolean} */
  #script_needs_csp;
  /** @type {boolean} */
  #script_src_needs_csp;
  /** @type {boolean} */
  #script_src_elem_needs_csp;
  /** @type {boolean} */
  #style_needs_csp;
  /** @type {boolean} */
  #style_src_needs_csp;
  /** @type {boolean} */
  #style_src_attr_needs_csp;
  /** @type {boolean} */
  #style_src_elem_needs_csp;
  /** @type {import('types').CspDirectives} */
  #directives;
  /** @type {import('types').Csp.Source[]} */
  #script_src;
  /** @type {import('types').Csp.Source[]} */
  #script_src_elem;
  /** @type {import('types').Csp.Source[]} */
  #style_src;
  /** @type {import('types').Csp.Source[]} */
  #style_src_attr;
  /** @type {import('types').Csp.Source[]} */
  #style_src_elem;
  /** @type {string} */
  #nonce;
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    this.#use_hashes = use_hashes;
    this.#directives = directives;
    const d = this.#directives;
    this.#script_src = [];
    this.#script_src_elem = [];
    this.#style_src = [];
    this.#style_src_attr = [];
    this.#style_src_elem = [];
    const effective_script_src = d["script-src"] || d["default-src"];
    const script_src_elem = d["script-src-elem"];
    const effective_style_src = d["style-src"] || d["default-src"];
    const style_src_attr = d["style-src-attr"];
    const style_src_elem = d["style-src-elem"];
    const needs_csp = (directive) => !!directive && !directive.some((value) => value === "unsafe-inline");
    this.#script_src_needs_csp = needs_csp(effective_script_src);
    this.#script_src_elem_needs_csp = needs_csp(script_src_elem);
    this.#style_src_needs_csp = needs_csp(effective_style_src);
    this.#style_src_attr_needs_csp = needs_csp(style_src_attr);
    this.#style_src_elem_needs_csp = needs_csp(style_src_elem);
    this.#script_needs_csp = this.#script_src_needs_csp || this.#script_src_elem_needs_csp;
    this.#style_needs_csp = this.#style_src_needs_csp || this.#style_src_attr_needs_csp || this.#style_src_elem_needs_csp;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    this.#nonce = nonce;
  }
  /** @param {string} content */
  add_script(content) {
    if (!this.#script_needs_csp) return;
    const source2 = this.#use_hashes ? `sha256-${sha256(content)}` : `nonce-${this.#nonce}`;
    if (this.#script_src_needs_csp) {
      this.#script_src.push(source2);
    }
    if (this.#script_src_elem_needs_csp) {
      this.#script_src_elem.push(source2);
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (!this.#style_needs_csp) return;
    const source2 = this.#use_hashes ? `sha256-${sha256(content)}` : `nonce-${this.#nonce}`;
    if (this.#style_src_needs_csp) {
      this.#style_src.push(source2);
    }
    if (this.#style_src_attr_needs_csp) {
      this.#style_src_attr.push(source2);
    }
    if (this.#style_src_elem_needs_csp) {
      const sha256_empty_comment_hash = "sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=";
      const d = this.#directives;
      if (d["style-src-elem"] && !d["style-src-elem"].includes(sha256_empty_comment_hash) && !this.#style_src_elem.includes(sha256_empty_comment_hash)) {
        this.#style_src_elem.push(sha256_empty_comment_hash);
      }
      if (source2 !== sha256_empty_comment_hash) {
        this.#style_src_elem.push(source2);
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#style_src_attr.length > 0) {
      directives["style-src-attr"] = [
        ...directives["style-src-attr"] || [],
        ...this.#style_src_attr
      ];
    }
    if (this.#style_src_elem.length > 0) {
      directives["style-src-elem"] = [
        ...directives["style-src-elem"] || [],
        ...this.#style_src_elem
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    if (this.#script_src_elem.length > 0) {
      directives["script-src-elem"] = [
        ...directives["script-src-elem"] || [],
        ...this.#script_src_elem
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key2]
      );
      if (!value) continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
};
var CspProvider = class extends BaseProvider {
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content="${escape_html2(content, true)}">`;
  }
};
var CspReportOnlyProvider = class extends BaseProvider {
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v2) => !!v2).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
};
var Csp = class {
  /** @readonly */
  nonce = generate_nonce();
  /** @type {CspProvider} */
  csp_provider;
  /** @type {CspReportOnlyProvider} */
  report_only_provider;
  /**
   * @param {import('./types.js').CspConfig} config
   * @param {import('./types.js').CspOpts} opts
   */
  constructor({ mode: mode2, directives, reportOnly }, { prerender }) {
    const use_hashes = mode2 === "hash" || mode2 === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
};
function exec(match2, params2, matchers) {
  const result = {};
  const values = match2.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i = 0; i < params2.length; i += 1) {
    const param = params2[i];
    let value = values[i - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i - buffered, i + 1).filter((s22) => s22).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest) result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params2[i + 1];
      const next_value = values[i + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered) return;
  return result;
}
function generate_route_object(route, url, manifest2) {
  const { errors, layouts, leaf } = route;
  const nodes = [...errors, ...layouts.map((l) => l?.[1]), leaf[1]].filter((n2) => typeof n2 === "number").map((n2) => `'${n2}': () => ${create_client_import(manifest2._.client.nodes?.[n2], url)}`).join(",\n		");
  return [
    `{
	id: ${s(route.id)}`,
    `errors: ${s(route.errors)}`,
    `layouts: ${s(route.layouts)}`,
    `leaf: ${s(route.leaf)}`,
    `nodes: {
		${nodes}
	}
}`
  ].join(",\n	");
}
function create_client_import(import_path, url) {
  if (!import_path) return "Promise.resolve({})";
  if (import_path[0] === "/") {
    return `import('${import_path}')`;
  }
  if (assets !== "") {
    return `import('${assets}/${import_path}')`;
  }
  let path = get_relative_path(url.pathname, `${base}/${import_path}`);
  if (path[0] !== ".") path = `./${path}`;
  return `import('${path}')`;
}
async function resolve_route(resolved_path, url, manifest2) {
  if (!manifest2._.client.routes) {
    return text("Server-side route resolution disabled", { status: 400 });
  }
  let route = null;
  let params2 = {};
  const matchers = await manifest2._.matchers();
  for (const candidate of manifest2._.client.routes) {
    const match2 = candidate.pattern.exec(resolved_path);
    if (!match2) continue;
    const matched = exec(match2, candidate.params, matchers);
    if (matched) {
      route = candidate;
      params2 = decode_params(matched);
      break;
    }
  }
  return create_server_routing_response(route, params2, url, manifest2).response;
}
function create_server_routing_response(route, params2, url, manifest2) {
  const headers2 = new Headers({
    "content-type": "application/javascript; charset=utf-8"
  });
  if (route) {
    const csr_route = generate_route_object(route, url, manifest2);
    const body2 = `${create_css_import(route, url, manifest2)}
export const route = ${csr_route}; export const params = ${JSON.stringify(params2)};`;
    return { response: text(body2, { headers: headers2 }), body: body2 };
  } else {
    return { response: text("", { headers: headers2 }), body: "" };
  }
}
function create_css_import(route, url, manifest2) {
  const { errors, layouts, leaf } = route;
  let css = "";
  for (const node of [...errors, ...layouts.map((l) => l?.[1]), leaf[1]]) {
    if (typeof node !== "number") continue;
    const node_css = manifest2._.client.css?.[node];
    for (const css_path of node_css ?? []) {
      css += `'${assets || base}/${css_path}',`;
    }
  }
  if (!css) return "";
  return `${create_client_import(
    /** @type {string} */
    manifest2._.client.start,
    url
  )}.then(x => x.load_css([${css}]));`;
}
var updated = {
  ...readable(false),
  check: () => false
};
async function render_response({
  branch: branch2,
  fetched,
  options: options2,
  manifest: manifest2,
  state: state2,
  page_config,
  status,
  error: error2 = null,
  event,
  event_state,
  resolve_opts,
  action_result,
  data_serializer
}) {
  if (state2.prerendering) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client } = manifest2._;
  const modulepreloads = new Set(client.imports);
  const stylesheets8 = new Set(client.stylesheets);
  const fonts8 = new Set(client.fonts);
  const link_headers = /* @__PURE__ */ new Set();
  const link_tags = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  {
    if (!state2.prerendering?.fallback) {
      const segments = event.url.pathname.slice(base.length).split("/").slice(2);
      base$1 = segments.map(() => "..").join("/") || ".";
      base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
      if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
        assets$1 = base$1;
      }
    } else if (options2.hash_routing) {
      base_expression = "new URL('.', location).pathname.slice(0, -1)";
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(
        branch2.map(({ node }) => {
          if (!node.component) {
            throw new Error(`Missing +page.svelte component for route ${event.route.id}`);
          }
          return node.component();
        })
      ),
      form: form_value
    };
    let data2 = {};
    for (let i = 0; i < branch2.length; i += 1) {
      data2 = { ...data2, ...branch2[i].data };
      props[`data_${i}`] = data2;
    }
    props.page = {
      error: error2,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data2,
      form: form_value,
      state: {}
    };
    const render_opts = {
      context: /* @__PURE__ */ new Map([
        [
          "__request__",
          {
            page: props.page
          }
        ]
      ])
    };
    const fetch2 = globalThis.fetch;
    try {
      if (BROWSER) ;
      rendered = await with_request_store({ event, state: event_state }, async () => {
        if (relative) override({ base: base$1, assets: assets$1 });
        const maybe_promise = options2.root.render(props, render_opts);
        const rendered2 = options2.async && "then" in maybe_promise ? (
          /** @type {ReturnType<typeof options.root.render> & Promise<any>} */
          maybe_promise.then((r3) => r3)
        ) : maybe_promise;
        if (options2.async) {
          reset();
        }
        const { head: head22, html: html2, css } = options2.async ? await rendered2 : rendered2;
        return { head: head22, html: html2, css };
      });
    } finally {
      reset();
    }
    for (const { node } of branch2) {
      for (const url of node.imports) modulepreloads.add(url);
      for (const url of node.stylesheets) stylesheets8.add(url);
      for (const url of node.fonts) fonts8.add(url);
      if (node.inline_styles && !client.inline) {
        Object.entries(await node.inline_styles()).forEach(([k, v2]) => inline_styles.set(k, v2));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head2 = "";
  let body2 = rendered.html;
  const csp = new Csp(options2.csp, {
    prerender: !!state2.prerendering
  });
  const prefixed = (path) => {
    if (path.startsWith("/")) {
      return base + path;
    }
    return `${assets$1}/${path}`;
  };
  const style = client.inline ? client.inline?.style : Array.from(inline_styles.values()).join("\n");
  if (style) {
    const attributes2 = [];
    if (csp.style_needs_nonce) attributes2.push(` nonce="${csp.nonce}"`);
    csp.add_style(style);
    head2 += `
	<style${attributes2.join("")}>${style}</style>`;
  }
  for (const dep of stylesheets8) {
    const path = prefixed(dep);
    const attributes2 = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes2.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path })) {
        link_headers.add(`<${encodeURI(path)}>; rel="preload"; as="style"; nopush`);
      }
    }
    head2 += `
		<link href="${path}" ${attributes2.join(" ")}>`;
  }
  for (const dep of fonts8) {
    const path = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      link_tags.add(`<link rel="preload" as="font" type="font/${ext}" href="${path}" crossorigin>`);
      link_headers.add(
        `<${encodeURI(path)}>; rel="preload"; as="font"; type="font/${ext}"; crossorigin; nopush`
      );
    }
  }
  const global = get_global_name(options2);
  const { data, chunks } = data_serializer.get_data(csp);
  if (page_config.ssr && page_config.csr) {
    body2 += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state2.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    const route = manifest2._.client.routes?.find((r3) => r3.id === event.route.id) ?? null;
    if (client.uses_env_dynamic_public && state2.prerendering) {
      modulepreloads.add(`${app_dir}/env.js`);
    }
    if (!client.inline) {
      const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
        (path) => resolve_opts.preload({ type: "js", path })
      );
      for (const path of included_modulepreloads) {
        link_headers.add(`<${encodeURI(path)}>; rel="modulepreload"; nopush`);
        if (options2.preload_strategy !== "modulepreload") {
          head2 += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path}">`;
        } else {
          link_tags.add(`<link rel="modulepreload" href="${path}">`);
        }
      }
    }
    if (state2.prerendering && link_tags.size > 0) {
      head2 += Array.from(link_tags).map((tag) => `
		${tag}`).join("");
    }
    if (manifest2._.client.routes && state2.prerendering && !state2.prerendering.fallback) {
      const pathname = add_resolution_suffix2(event.url.pathname);
      state2.prerendering.dependencies.set(
        pathname,
        create_server_routing_response(route, event.params, new URL(pathname, event.url), manifest2)
      );
    }
    const blocks = [];
    const load_env_eagerly = client.uses_env_dynamic_public && state2.prerendering;
    const properties = [`base: ${base_expression}`];
    if (assets) {
      properties.push(`assets: ${s(assets)}`);
    }
    if (client.uses_env_dynamic_public) {
      properties.push(`env: ${load_env_eagerly ? "null" : s(public_env)}`);
    }
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      let app_declaration = "";
      if (Object.keys(options2.hooks.transport).length > 0) {
        if (client.inline) {
          app_declaration = `const app = __sveltekit_${options2.version_hash}.app.app;`;
        } else if (client.app) {
          app_declaration = `const app = await import(${s(prefixed(client.app))});`;
        } else {
          app_declaration = `const { app } = await import(${s(prefixed(client.start))});`;
        }
      }
      const prelude = app_declaration ? `${app_declaration}
							const [data, error] = fn(app);` : `const [data, error] = fn();`;
      properties.push(`resolve: async (id, fn) => {
							${prelude}

							const try_to_resolve = () => {
								if (!deferred.has(id)) {
									setTimeout(try_to_resolve, 0);
									return;
								}
								const { fulfil, reject } = deferred.get(id);
								deferred.delete(id);
								if (error) reject(error);
								else fulfil(data);
							}
							try_to_resolve();
						}`);
    }
    blocks.push(`${global} = {
						${properties.join(",\n						")}
					};`);
    const args = ["element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        );
      }
      if (error2) {
        serialized.error = uneval(error2);
      }
      const hydrate2 = [
        `node_ids: [${branch2.map(({ node }) => node.index).join(", ")}]`,
        `data: ${data}`,
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate2.push(`status: ${status}`);
      }
      if (manifest2._.client.routes) {
        if (route) {
          const stringified = generate_route_object(route, event.url, manifest2).replaceAll(
            "\n",
            "\n							"
          );
          hydrate2.push(`params: ${uneval(event.params)}`, `server_route: ${stringified}`);
        }
      } else if (options2.embedded) {
        hydrate2.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      const indent = "	".repeat(load_env_eagerly ? 7 : 6);
      args.push(`{
${indent}	${hydrate2.join(`,
${indent}	`)}
${indent}}`);
    }
    const { remote_data: remote_cache } = event_state;
    let serialized_remote_data = "";
    if (remote_cache) {
      const remote = {};
      for (const [info, cache3] of remote_cache) {
        if (!info.id) continue;
        for (const key2 in cache3) {
          remote[create_remote_cache_key(info.id, key2)] = await cache3[key2];
        }
      }
      const replacer = (thing) => {
        for (const key2 in options2.hooks.transport) {
          const encoded = options2.hooks.transport[key2].encode(thing);
          if (encoded) {
            return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
          }
        }
      };
      serialized_remote_data = `${global}.data = ${uneval(remote, replacer)};

						`;
    }
    const boot = client.inline ? `${client.inline.script}

					${serialized_remote_data}${global}.app.start(${args.join(", ")});` : client.app ? `Promise.all([
						import(${s(prefixed(client.start))}),
						import(${s(prefixed(client.app))})
					]).then(([kit, app]) => {
						${serialized_remote_data}kit.start(app, ${args.join(", ")});
					});` : `import(${s(prefixed(client.start))}).then((app) => {
						${serialized_remote_data}app.start(${args.join(", ")})
					});`;
    if (load_env_eagerly) {
      blocks.push(`import(${s(`${base$1}/${app_dir}/env.js`)}).then(({ env }) => {
						${global}.env = env;

						${boot.replace(/\n/g, "\n	")}
					});`);
    } else {
      blocks.push(boot);
    }
    if (options2.service_worker) {
      let opts = "";
      if (options2.service_worker_options != null) {
        const service_worker_options = { ...options2.service_worker_options };
        opts = `, ${s(service_worker_options)}`;
      }
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body2 += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers2 = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state2.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state2.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state2.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head2 = http_equiv.join("\n") + head2;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers2.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers2.set("content-security-policy-report-only", report_only_header);
    }
    if (link_headers.size) {
      headers2.set("link", Array.from(link_headers).join(", "));
    }
  }
  head2 += rendered.head;
  const html = options2.templates.app({
    head: head2,
    body: body2,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers2.set("etag", `"${hash(transformed)}"`);
  }
  return !chunks ? text(transformed, {
    status,
    headers: headers2
  }) : new Response(
    new ReadableStream({
      async start(controller2) {
        controller2.enqueue(text_encoder2.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          if (chunk.length) controller2.enqueue(text_encoder2.encode(chunk));
        }
        controller2.close();
      },
      type: "bytes"
    }),
    {
      headers: headers2
    }
  );
}
var PageNodes = class {
  data;
  /**
   * @param {Array<import('types').SSRNode | undefined>} nodes
   */
  constructor(nodes) {
    this.data = nodes;
  }
  layouts() {
    return this.data.slice(0, -1);
  }
  page() {
    return this.data.at(-1);
  }
  validate() {
    for (const layout of this.layouts()) {
      if (layout) {
        validate_layout_server_exports(
          layout.server,
          /** @type {string} */
          layout.server_id
        );
        validate_layout_exports(
          layout.universal,
          /** @type {string} */
          layout.universal_id
        );
      }
    }
    const page3 = this.page();
    if (page3) {
      validate_page_server_exports(
        page3.server,
        /** @type {string} */
        page3.server_id
      );
      validate_page_exports(
        page3.universal,
        /** @type {string} */
        page3.universal_id
      );
    }
  }
  /**
   * @template {'prerender' | 'ssr' | 'csr' | 'trailingSlash'} Option
   * @param {Option} option
   * @returns {Value | undefined}
   */
  #get_option(option) {
    return this.data.reduce(
      (value, node) => {
        return node?.universal?.[option] ?? node?.server?.[option] ?? value;
      },
      /** @type {Value | undefined} */
      void 0
    );
  }
  csr() {
    return this.#get_option("csr") ?? true;
  }
  ssr() {
    return this.#get_option("ssr") ?? true;
  }
  prerender() {
    return this.#get_option("prerender") ?? false;
  }
  trailing_slash() {
    return this.#get_option("trailingSlash") ?? "never";
  }
  get_config() {
    let current22 = {};
    for (const node of this.data) {
      if (!node?.universal?.config && !node?.server?.config) continue;
      current22 = {
        ...current22,
        // TODO: should we override the server config value with the universal value similar to other page options?
        ...node?.universal?.config,
        ...node?.server?.config
      };
    }
    return Object.keys(current22).length ? current22 : void 0;
  }
  should_prerender_data() {
    return this.data.some(
      // prerender in case of trailingSlash because the client retrieves that value from the server
      (node) => node?.server?.load || node?.server?.trailingSlash !== void 0
    );
  }
};
async function respond_with_error({
  event,
  event_state,
  options: options2,
  manifest: manifest2,
  state: state2,
  status,
  error: error2,
  resolve_opts
}) {
  if (event.request.headers.get("x-sveltekit-error")) {
    return static_error_page(
      options2,
      status,
      /** @type {Error} */
      error2.message
    );
  }
  const fetched = [];
  try {
    const branch2 = [];
    const default_layout = await manifest2._.nodes[0]();
    const nodes = new PageNodes([default_layout]);
    const ssr = nodes.ssr();
    const csr = nodes.csr();
    const data_serializer = server_data_serializer(event, event_state, options2);
    if (ssr) {
      state2.error = true;
      const server_data_promise = load_server_data({
        event,
        event_state,
        state: state2,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: async () => ({})
      });
      const server_data = await server_data_promise;
      data_serializer.add_node(0, server_data);
      const data = await load_data({
        event,
        event_state,
        fetched,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: async () => ({}),
        resolve_opts,
        server_data_promise,
        state: state2,
        csr
      });
      branch2.push(
        {
          node: default_layout,
          server_data,
          data
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options2,
      manifest: manifest2,
      state: state2,
      page_config: {
        ssr,
        csr
      },
      status,
      error: await handle_error_and_jsonify(event, event_state, options2, error2),
      branch: branch2,
      fetched,
      event,
      event_state,
      resolve_opts,
      data_serializer
    });
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return redirect_response(e3.status, e3.location);
    }
    return static_error_page(
      options2,
      get_status(e3),
      (await handle_error_and_jsonify(event, event_state, options2, e3)).message
    );
  }
}
async function handle_remote_call(event, state2, options2, manifest2, id) {
  return record_span({
    name: "sveltekit.remote.call",
    attributes: {},
    fn: (current22) => {
      const traced_event = merge_tracing(event, current22);
      return with_request_store(
        { event: traced_event, state: state2 },
        () => handle_remote_call_internal(traced_event, state2, options2, manifest2, id)
      );
    }
  });
}
async function handle_remote_call_internal(event, state2, options2, manifest2, id) {
  const [hash22, name, additional_args] = id.split("/");
  const remotes = manifest2._.remotes;
  if (!remotes[hash22]) error(404);
  const module = await remotes[hash22]();
  const fn = module.default[name];
  if (!fn) error(404);
  const info = fn.__;
  const transport = options2.hooks.transport;
  event.tracing.current.setAttributes({
    "sveltekit.remote.call.type": info.type,
    "sveltekit.remote.call.name": info.name
  });
  let form_client_refreshes;
  try {
    if (info.type === "query_batch") {
      if (event.request.method !== "POST") {
        throw new SvelteKitError(
          405,
          "Method Not Allowed",
          `\`query.batch\` functions must be invoked via POST request, not ${event.request.method}`
        );
      }
      const { payloads } = await event.request.json();
      const args = payloads.map((payload2) => parse_remote_arg(payload2, transport));
      const get_result = await with_request_store({ event, state: state2 }, () => info.run(args));
      const results = await Promise.all(
        args.map(async (arg, i) => {
          try {
            return { type: "result", data: get_result(arg, i) };
          } catch (error2) {
            return {
              type: "error",
              error: await handle_error_and_jsonify(event, state2, options2, error2),
              status: error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : 500
            };
          }
        })
      );
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "result",
          result: stringify2(results, transport)
        }
      );
    }
    if (info.type === "form") {
      if (event.request.method !== "POST") {
        throw new SvelteKitError(
          405,
          "Method Not Allowed",
          `\`form\` functions must be invoked via POST request, not ${event.request.method}`
        );
      }
      if (!is_form_content_type(event.request)) {
        throw new SvelteKitError(
          415,
          "Unsupported Media Type",
          `\`form\` functions expect form-encoded data \u2014 received ${event.request.headers.get(
            "content-type"
          )}`
        );
      }
      const form_data = await event.request.formData();
      form_client_refreshes = /** @type {string[]} */
      JSON.parse(
        /** @type {string} */
        form_data.get("sveltekit:remote_refreshes") ?? "[]"
      );
      form_data.delete("sveltekit:remote_refreshes");
      if (additional_args) {
        form_data.set("sveltekit:id", decodeURIComponent(additional_args));
      }
      const fn2 = info.fn;
      const data2 = await with_request_store({ event, state: state2 }, () => fn2(form_data));
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "result",
          result: stringify2(data2, transport),
          refreshes: data2.issues ? {} : await serialize_refreshes(form_client_refreshes)
        }
      );
    }
    if (info.type === "command") {
      const { payload: payload2, refreshes } = await event.request.json();
      const arg = parse_remote_arg(payload2, transport);
      const data2 = await with_request_store({ event, state: state2 }, () => fn(arg));
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "result",
          result: stringify2(data2, transport),
          refreshes: await serialize_refreshes(refreshes)
        }
      );
    }
    const payload = info.type === "prerender" ? additional_args : (
      /** @type {string} */
      // new URL(...) necessary because we're hiding the URL from the user in the event object
      new URL(event.request.url).searchParams.get("payload")
    );
    const data = await with_request_store(
      { event, state: state2 },
      () => fn(parse_remote_arg(payload, transport))
    );
    return json(
      /** @type {RemoteFunctionResponse} */
      {
        type: "result",
        result: stringify2(data, transport)
      }
    );
  } catch (error2) {
    if (error2 instanceof Redirect) {
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "redirect",
          location: error2.location,
          refreshes: await serialize_refreshes(form_client_refreshes ?? [])
        }
      );
    }
    const status = error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : 500;
    return json(
      /** @type {RemoteFunctionResponse} */
      {
        type: "error",
        error: await handle_error_and_jsonify(event, state2, options2, error2),
        status
      },
      {
        // By setting a non-200 during prerendering we fail the prerender process (unless handleHttpError handles it).
        // Errors at runtime will be passed to the client and are handled there
        status: state2.prerendering ? status : void 0,
        headers: {
          "cache-control": "private, no-store"
        }
      }
    );
  }
  async function serialize_refreshes(client_refreshes) {
    const refreshes = state2.refreshes ?? {};
    for (const key2 of client_refreshes) {
      if (refreshes[key2] !== void 0) continue;
      const [hash3, name2, payload] = key2.split("/");
      const loader = manifest2._.remotes[hash3];
      const fn2 = (await loader?.())?.default?.[name2];
      if (!fn2) error(400, "Bad Request");
      refreshes[key2] = with_request_store(
        { event, state: state2 },
        () => fn2(parse_remote_arg(payload, transport))
      );
    }
    if (Object.keys(refreshes).length === 0) {
      return void 0;
    }
    return stringify2(
      Object.fromEntries(
        await Promise.all(
          Object.entries(refreshes).map(async ([key2, promise]) => [key2, await promise])
        )
      ),
      transport
    );
  }
}
async function handle_remote_form_post(event, state2, manifest2, id) {
  return record_span({
    name: "sveltekit.remote.form.post",
    attributes: {},
    fn: (current22) => {
      const traced_event = merge_tracing(event, current22);
      return with_request_store(
        { event: traced_event, state: state2 },
        () => handle_remote_form_post_internal(traced_event, state2, manifest2, id)
      );
    }
  });
}
async function handle_remote_form_post_internal(event, state2, manifest2, id) {
  const [hash22, name, action_id] = id.split("/");
  const remotes = manifest2._.remotes;
  const module = await remotes[hash22]?.();
  let form = (
    /** @type {RemoteForm<any, any>} */
    module?.default[name]
  );
  if (!form) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        `POST method not allowed. No form actions exist for ${"this page"}`
      )
    };
  }
  if (action_id) {
    form = with_request_store({ event, state: state2 }, () => form.for(JSON.parse(action_id)));
  }
  try {
    const form_data = await event.request.formData();
    const fn = (
      /** @type {RemoteInfo & { type: 'form' }} */
      /** @type {any} */
      form.__.fn
    );
    if (action_id && !form_data.has("id")) {
      form_data.set("sveltekit:id", decodeURIComponent(action_id));
    }
    await with_request_store({ event, state: state2 }, () => fn(form_data));
    return {
      type: "success",
      status: 200
    };
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
function get_remote_id(url) {
  return url.pathname.startsWith(`${base}/${app_dir}/remote/`) && url.pathname.replace(`${base}/${app_dir}/remote/`, "");
}
function get_remote_action(url) {
  return url.searchParams.get("/remote");
}
var MAX_DEPTH = 10;
async function render_page(event, event_state, page3, options2, manifest2, state2, nodes, resolve_opts) {
  if (state2.depth > MAX_DEPTH) {
    return text(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page3.leaf]();
    return handle_action_json_request(event, event_state, options2, node?.server);
  }
  try {
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.page()
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      const remote_id = get_remote_action(event.url);
      if (remote_id) {
        action_result = await handle_remote_form_post(event, event_state, manifest2, remote_id);
      } else {
        action_result = await handle_action_request(event, event_state, leaf_node.server);
      }
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        status = get_status(action_result.error);
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender = nodes.prerender();
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state2.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state2.prerender_default = should_prerender;
    const should_prerender_data = nodes.should_prerender_data();
    const data_pathname = add_data_suffix2(event.url.pathname);
    const fetched = [];
    const ssr = nodes.ssr();
    const csr = nodes.csr();
    if (ssr === false && !(state2.prerendering && should_prerender_data)) {
      if (BROWSER && action_result && !event.request.headers.has("x-sveltekit-action")) ;
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr
        },
        status,
        error: null,
        event,
        event_state,
        options: options2,
        manifest: manifest2,
        state: state2,
        resolve_opts,
        data_serializer: server_data_serializer(event, event_state, options2)
      });
    }
    const branch2 = [];
    let load_error = null;
    const data_serializer = server_data_serializer(event, event_state, options2);
    const data_serializer_json = state2.prerendering && should_prerender_data ? server_data_serializer_json(event, event_state, options2) : null;
    const server_promises = nodes.data.map((node, i) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          const server_data = await load_server_data({
            event,
            event_state,
            state: state2,
            node,
            parent: async () => {
              const data = {};
              for (let j = 0; j < i; j += 1) {
                const parent = await server_promises[j];
                if (parent) Object.assign(data, parent.data);
              }
              return data;
            }
          });
          if (node) {
            data_serializer.add_node(i, server_data);
          }
          data_serializer_json?.add_node(i, server_data);
          return server_data;
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    const load_promises = nodes.data.map((node, i) => {
      if (load_error) throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            event_state,
            fetched,
            node,
            parent: async () => {
              const data = {};
              for (let j = 0; j < i; j += 1) {
                Object.assign(data, await load_promises[j]);
              }
              return data;
            },
            resolve_opts,
            server_data_promise: server_promises[i],
            state: state2,
            csr
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    for (const p of server_promises) p.catch(() => {
    });
    for (const p of load_promises) p.catch(() => {
    });
    for (let i = 0; i < nodes.data.length; i += 1) {
      const node = nodes.data[i];
      if (node) {
        try {
          const server_data = await server_promises[i];
          const data = await load_promises[i];
          branch2.push({ node, server_data, data });
        } catch (e3) {
          const err = normalize_error(e3);
          if (err instanceof Redirect) {
            if (state2.prerendering && should_prerender_data) {
              const body2 = JSON.stringify({
                type: "redirect",
                location: err.location
              });
              state2.prerendering.dependencies.set(data_pathname, {
                response: text(body2),
                body: body2
              });
            }
            return redirect_response(err.status, err.location);
          }
          const status2 = get_status(err);
          const error2 = await handle_error_and_jsonify(event, event_state, options2, err);
          while (i--) {
            if (page3.errors[i]) {
              const index8 = (
                /** @type {number} */
                page3.errors[i]
              );
              const node2 = await manifest2._.nodes[index8]();
              let j = i;
              while (!branch2[j]) j -= 1;
              data_serializer.set_max_nodes(j + 1);
              const layouts = compact(branch2.slice(0, j + 1));
              const nodes2 = new PageNodes(layouts.map((layout) => layout.node));
              return await render_response({
                event,
                event_state,
                options: options2,
                manifest: manifest2,
                state: state2,
                resolve_opts,
                page_config: {
                  ssr: nodes2.ssr(),
                  csr: nodes2.csr()
                },
                status: status2,
                error: error2,
                branch: layouts.concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched,
                data_serializer
              });
            }
          }
          return static_error_page(options2, status2, error2.message);
        }
      } else {
        branch2.push(null);
      }
    }
    if (state2.prerendering && data_serializer_json) {
      let { data, chunks } = data_serializer_json.get_data();
      if (chunks) {
        for await (const chunk of chunks) {
          data += chunk;
        }
      }
      state2.prerendering.dependencies.set(data_pathname, {
        response: text(data),
        body: data
      });
    }
    return await render_response({
      event,
      event_state,
      options: options2,
      manifest: manifest2,
      state: state2,
      resolve_opts,
      page_config: {
        csr,
        ssr
      },
      status,
      error: null,
      branch: ssr === false ? [] : compact(branch2),
      action_result,
      fetched,
      data_serializer: ssr === false ? server_data_serializer(event, event_state, options2) : data_serializer
    });
  } catch (e3) {
    return await respond_with_error({
      event,
      event_state,
      options: options2,
      manifest: manifest2,
      state: state2,
      status: 500,
      error: e3,
      resolve_opts
    });
  }
}
function once(fn) {
  let done = false;
  let result;
  return () => {
    if (done) return result;
    done = true;
    return result = fn();
  };
}
async function render_data(event, event_state, route, options2, manifest2, state2, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted = false;
    const url = new URL(event.url);
    url.pathname = normalize_path(url.pathname, trailing_slash);
    const new_event = { ...event, url };
    const functions = node_ids.map((n2, i) => {
      return once(async () => {
        try {
          if (aborted) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n2 == void 0 ? n2 : await manifest2._.nodes[n2]();
          return load_server_data({
            event: new_event,
            event_state,
            state: state2,
            node,
            parent: async () => {
              const data2 = {};
              for (let j = 0; j < i; j += 1) {
                const parent = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions[j]()
                );
                if (parent) {
                  Object.assign(data2, parent.data);
                }
              }
              return data2;
            }
          });
        } catch (e3) {
          aborted = true;
          throw e3;
        }
      });
    });
    const promises = functions.map(async (fn, i) => {
      if (!invalidated[i]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p, i) => p.catch(async (error2) => {
          if (error2 instanceof Redirect) {
            throw error2;
          }
          length = Math.min(length, i + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, event_state, options2, error2),
              status: error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : void 0
            }
          );
        })
      )
    );
    const data_serializer = server_data_serializer_json(event, event_state, options2);
    for (let i = 0; i < nodes.length; i++) data_serializer.add_node(i, nodes[i]);
    const { data, chunks } = data_serializer.get_data();
    if (!chunks) {
      return json_response(data);
    }
    return new Response(
      new ReadableStream({
        async start(controller2) {
          controller2.enqueue(text_encoder2.encode(data));
          for await (const chunk of chunks) {
            controller2.enqueue(text_encoder2.encode(chunk));
          }
          controller2.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e3) {
    const error2 = normalize_error(e3);
    if (error2 instanceof Redirect) {
      return redirect_json_response(error2);
    } else {
      return json_response(await handle_error_and_jsonify(event, event_state, options2, error2), 500);
    }
  }
}
function json_response(json2, status = 200) {
  return text(typeof json2 === "string" ? json2 : JSON.stringify(json2), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
function redirect_json_response(redirect) {
  return json_response(
    /** @type {import('types').ServerRedirectNode} */
    {
      type: "redirect",
      location: redirect.location
    }
  );
}
var INVALID_COOKIE_CHARACTER_REGEX = /[\x00-\x1F\x7F()<>@,;:"/[\]?={} \t]/;
function validate_options(options2) {
  if (options2?.path === void 0) {
    throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
  }
}
function generate_cookie_key(domain, path, name) {
  return `${domain || ""}${path}?${encodeURIComponent(name)}`;
}
function get_cookies(request, url) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = (0, import_cookie.parse)(header, { decode: (value) => value });
  let normalized_url;
  const new_cookies = /* @__PURE__ */ new Map();
  const defaults = {
    httpOnly: true,
    sameSite: "lax",
    secure: url.hostname === "localhost" && url.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} [opts]
     */
    get(name, opts) {
      const best_match = Array.from(new_cookies.values()).filter((c2) => {
        return c2.name === name && domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path);
      }).sort((a, b) => b.options.path.length - a.options.path.length)[0];
      if (best_match) {
        return best_match.options.maxAge === 0 ? void 0 : best_match.value;
      }
      const req_cookies = (0, import_cookie.parse)(header, { decode: opts?.decode });
      const cookie = req_cookies[name];
      return cookie;
    },
    /**
     * @param {import('cookie').CookieParseOptions} [opts]
     */
    getAll(opts) {
      const cookies2 = (0, import_cookie.parse)(header, { decode: opts?.decode });
      const lookup = /* @__PURE__ */ new Map();
      for (const c2 of new_cookies.values()) {
        if (domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
          const existing = lookup.get(c2.name);
          if (!existing || c2.options.path.length > existing.options.path.length) {
            lookup.set(c2.name, c2);
          }
        }
      }
      for (const c2 of lookup.values()) {
        cookies2[c2.name] = c2.value;
      }
      return Object.entries(cookies2).map(([name, value]) => ({ name, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('./page/types.js').Cookie['options']} options
     */
    set(name, value, options2) {
      const illegal_characters = name.match(INVALID_COOKIE_CHARACTER_REGEX);
      if (illegal_characters) {
        console.warn(
          `The cookie name "${name}" will be invalid in SvelteKit 3.0 as it contains ${illegal_characters.join(
            " and "
          )}. See RFC 2616 for more details https://datatracker.ietf.org/doc/html/rfc2616#section-2.2`
        );
      }
      validate_options(options2);
      set_internal(name, value, { ...defaults, ...options2 });
    },
    /**
     * @param {string} name
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    delete(name, options2) {
      validate_options(options2);
      cookies.set(name, "", { ...options2, maxAge: 0 });
    },
    /**
     * @param {string} name
     * @param {string} value
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    serialize(name, value, options2) {
      validate_options(options2);
      let path = options2.path;
      if (!options2.domain || options2.domain === url.hostname) {
        if (!normalized_url) {
          throw new Error("Cannot serialize cookies until after the route is determined");
        }
        path = resolve(normalized_url, path);
      }
      return (0, import_cookie.serialize)(name, value, { ...defaults, ...options2, path });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const cookie of new_cookies.values()) {
      if (!domain_matches(destination.hostname, cookie.options.domain)) continue;
      if (!path_matches(destination.pathname, cookie.options.path)) continue;
      const encoder = cookie.options.encode || encodeURIComponent;
      combined_cookies[cookie.name] = encoder(cookie.value);
    }
    if (header2) {
      const parsed = (0, import_cookie.parse)(header2, { decode: (value) => value });
      for (const name in parsed) {
        combined_cookies[name] = parsed[name];
      }
    }
    return Object.entries(combined_cookies).map(([name, value]) => `${name}=${value}`).join("; ");
  }
  const internal_queue = [];
  function set_internal(name, value, options2) {
    if (!normalized_url) {
      internal_queue.push(() => set_internal(name, value, options2));
      return;
    }
    let path = options2.path;
    if (!options2.domain || options2.domain === url.hostname) {
      path = resolve(normalized_url, path);
    }
    const cookie_key = generate_cookie_key(options2.domain, path, name);
    const cookie = { name, value, options: { ...options2, path } };
    new_cookies.set(cookie_key, cookie);
  }
  function set_trailing_slash(trailing_slash) {
    normalized_url = normalize_path(url.pathname, trailing_slash);
    internal_queue.forEach((fn) => fn());
  }
  return { cookies, new_cookies, get_cookie_header, set_internal, set_trailing_slash };
}
function domain_matches(hostname, constraint) {
  if (!constraint) return true;
  const normalized = constraint[0] === "." ? constraint.slice(1) : constraint;
  if (hostname === normalized) return true;
  return hostname.endsWith("." + normalized);
}
function path_matches(path, constraint) {
  if (!constraint) return true;
  const normalized = constraint.endsWith("/") ? constraint.slice(0, -1) : constraint;
  if (path === normalized) return true;
  return path.startsWith(normalized + "/");
}
function add_cookies_to_headers(headers2, cookies) {
  for (const new_cookie of cookies) {
    const { name, value, options: options2 } = new_cookie;
    headers2.append("set-cookie", (0, import_cookie.serialize)(name, value, options2));
    if (options2.path.endsWith(".html")) {
      const path = add_data_suffix2(options2.path);
      headers2.append("set-cookie", (0, import_cookie.serialize)(name, value, { ...options2, path }));
    }
  }
}
function create_fetch({ event, options: options2, manifest: manifest2, state: state2, get_cookie_header, set_internal }) {
  const server_fetch = async (info, init210) => {
    const original_request = normalize_fetch_input(info, init210, event.url);
    let mode2 = (info instanceof Request ? info.mode : init210?.mode) ?? "cors";
    let credentials = (info instanceof Request ? info.credentials : init210?.credentials) ?? "same-origin";
    return options2.hooks.handleFetch({
      event,
      request: original_request,
      fetch: async (info2, init36) => {
        const request = normalize_fetch_input(info2, init36, event.url);
        const url = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info2 !== original_request) {
          mode2 = (info2 instanceof Request ? info2.mode : init36?.mode) ?? "cors";
          credentials = (info2 instanceof Request ? info2.credentials : init36?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode2 === "no-cors" && url.origin !== event.url.origin || url.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url.origin !== event.url.origin) {
          if (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie = get_cookie_header(url, request.headers.get("cookie"));
            if (cookie) request.headers.set("cookie", cookie);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename) || filename in manifest2._.server_assets;
        const is_asset_html = manifest2.assets.has(filename_html) || filename_html in manifest2._.server_assets;
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (state2.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state2.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          } else if (read_implementation && file in manifest2._.server_assets) {
            const length = manifest2._.server_assets[file];
            const type = manifest2.mimeTypes[file.slice(file.lastIndexOf("."))];
            return new Response(read_implementation(file), {
              headers: {
                "Content-Length": "" + length,
                "Content-Type": type
              }
            });
          }
          return await fetch(request);
        }
        if (has_prerendered_path(manifest2, base + decoded)) {
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie = get_cookie_header(url, request.headers.get("cookie"));
          if (cookie) {
            request.headers.set("cookie", cookie);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await internal_fetch(request, options2, manifest2, state2);
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str of set_cookie_parser.splitCookiesString(set_cookie)) {
            const { name, value, ...options3 } = set_cookie_parser.parseString(str, {
              decodeValues: false
            });
            const path = options3.path ?? (url.pathname.split("/").slice(0, -1).join("/") || "/");
            set_internal(name, value, {
              path,
              encode: (value2) => value2,
              .../** @type {import('cookie').CookieSerializeOptions} */
              options3
            });
          }
        }
        return response;
      }
    });
  };
  return (input, init210) => {
    const response = server_fetch(input, init210);
    response.catch(() => {
    });
    return response;
  };
}
function normalize_fetch_input(info, init210, url) {
  if (info instanceof Request) {
    return info;
  }
  return new Request(typeof info === "string" ? new URL(info, url) : info, init210);
}
async function internal_fetch(request, options2, manifest2, state2) {
  if (request.signal) {
    if (request.signal.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
    let remove_abort_listener = () => {
    };
    const abort_promise = new Promise((_, reject) => {
      const on_abort = () => {
        reject(new DOMException("The operation was aborted.", "AbortError"));
      };
      request.signal.addEventListener("abort", on_abort, { once: true });
      remove_abort_listener = () => request.signal.removeEventListener("abort", on_abort);
    });
    const result = await Promise.race([
      respond(request, options2, manifest2, {
        ...state2,
        depth: state2.depth + 1
      }),
      abort_promise
    ]);
    remove_abort_listener();
    return result;
  } else {
    return await respond(request, options2, manifest2, {
      ...state2,
      depth: state2.depth + 1
    });
  }
}
var body;
var etag;
var headers;
function get_public_env(request) {
  body ??= `export const env=${JSON.stringify(public_env)}`;
  etag ??= `W/${Date.now()}`;
  headers ??= new Headers({
    "content-type": "application/javascript; charset=utf-8",
    etag
  });
  if (request.headers.get("if-none-match") === etag) {
    return new Response(void 0, { status: 304, headers });
  }
  return new Response(body, { headers });
}
var default_transform = ({ html }) => html;
var default_filter = () => false;
var default_preload = ({ type }) => type === "js" || type === "css";
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
var respond = propagate_context(internal_respond);
async function internal_respond(request, options2, manifest2, state2) {
  const url = new URL(request.url);
  const is_route_resolution_request = has_resolution_suffix2(url.pathname);
  const is_data_request = has_data_suffix2(url.pathname);
  const remote_id = get_remote_id(url);
  {
    const request_origin = request.headers.get("origin");
    if (remote_id) {
      if (request.method !== "GET" && request_origin !== url.origin) {
        const message = "Cross-site remote requests are forbidden";
        return json({ message }, { status: 403 });
      }
    } else if (options2.csrf_check_origin) {
      const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request_origin !== url.origin && (!request_origin || !options2.csrf_trusted_origins.includes(request_origin));
      if (forbidden) {
        const message = `Cross-site ${request.method} form submissions are forbidden`;
        const opts = { status: 403 };
        if (request.headers.get("accept") === "application/json") {
          return json({ message }, opts);
        }
        return text(message, opts);
      }
    }
  }
  if (options2.hash_routing && url.pathname !== base + "/" && url.pathname !== "/[fallback]") {
    return text("Not found", { status: 404 });
  }
  let invalidated_data_nodes;
  if (is_route_resolution_request) {
    url.pathname = strip_resolution_suffix2(url.pathname);
  } else if (is_data_request) {
    url.pathname = strip_data_suffix2(url.pathname) + (url.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url.searchParams.delete(INVALIDATED_PARAM);
  } else if (remote_id) {
    url.pathname = request.headers.get("x-sveltekit-pathname") ?? base;
    url.search = request.headers.get("x-sveltekit-search") ?? "";
  }
  const headers2 = {};
  const { cookies, new_cookies, get_cookie_header, set_internal, set_trailing_slash } = get_cookies(
    request,
    url
  );
  const event_state = {
    prerendering: state2.prerendering,
    transport: options2.hooks.transport,
    handleValidationError: options2.hooks.handleValidationError,
    tracing: {
      record_span
    },
    is_in_remote_function: false
  };
  const event = {
    cookies,
    // @ts-expect-error `fetch` needs to be created after the `event` itself
    fetch: null,
    getClientAddress: state2.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-cloudflare"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params: {},
    platform: state2.platform,
    request,
    route: { id: null },
    setHeaders: (new_headers) => {
      for (const key2 in new_headers) {
        const lower = key2.toLowerCase();
        const value = new_headers[key2];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers2) {
          throw new Error(`"${key2}" header is already set`);
        } else {
          headers2[lower] = value;
          if (state2.prerendering && lower === "cache-control") {
            state2.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    },
    url,
    isDataRequest: is_data_request,
    isSubRequest: state2.depth > 0,
    isRemoteRequest: !!remote_id
  };
  event.fetch = create_fetch({
    event,
    options: options2,
    manifest: manifest2,
    state: state2,
    get_cookie_header,
    set_internal
  });
  if (state2.emulator?.platform) {
    event.platform = await state2.emulator.platform({
      config: {},
      prerender: !!state2.prerendering?.fallback
    });
  }
  let resolved_path = url.pathname;
  if (!remote_id) {
    const prerendering_reroute_state = state2.prerendering?.inside_reroute;
    try {
      if (state2.prerendering) state2.prerendering.inside_reroute = true;
      resolved_path = await options2.hooks.reroute({ url: new URL(url), fetch: event.fetch }) ?? url.pathname;
    } catch {
      return text("Internal Server Error", {
        status: 500
      });
    } finally {
      if (state2.prerendering) state2.prerendering.inside_reroute = prerendering_reroute_state;
    }
  }
  try {
    resolved_path = decode_pathname(resolved_path);
  } catch {
    return text("Malformed URI", { status: 400 });
  }
  if (resolved_path !== url.pathname && !state2.prerendering?.fallback && has_prerendered_path(manifest2, resolved_path)) {
    const url2 = new URL(request.url);
    url2.pathname = is_data_request ? add_data_suffix2(resolved_path) : is_route_resolution_request ? add_resolution_suffix2(resolved_path) : resolved_path;
    const response = await fetch(url2, request);
    const headers22 = new Headers(response.headers);
    if (headers22.has("content-encoding")) {
      headers22.delete("content-encoding");
      headers22.delete("content-length");
    }
    return new Response(response.body, {
      headers: headers22,
      status: response.status,
      statusText: response.statusText
    });
  }
  let route = null;
  if (base && !state2.prerendering?.fallback) {
    if (!resolved_path.startsWith(base)) {
      return text("Not found", { status: 404 });
    }
    resolved_path = resolved_path.slice(base.length) || "/";
  }
  if (is_route_resolution_request) {
    return resolve_route(resolved_path, new URL(request.url), manifest2);
  }
  if (resolved_path === `/${app_dir}/env.js`) {
    return get_public_env(request);
  }
  if (!remote_id && resolved_path.startsWith(`/${app_dir}`)) {
    const headers22 = new Headers();
    headers22.set("cache-control", "public, max-age=0, must-revalidate");
    return text("Not found", { status: 404, headers: headers22 });
  }
  if (!state2.prerendering?.fallback) {
    const matchers = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match2 = candidate.pattern.exec(resolved_path);
      if (!match2) continue;
      const matched = exec(match2, candidate.params, matchers);
      if (matched) {
        route = candidate;
        event.route = { id: route.id };
        event.params = decode_params(matched);
        break;
      }
    }
  }
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  let trailing_slash = "never";
  try {
    const page_nodes = route?.page ? new PageNodes(await load_page_nodes(route.page, manifest2)) : void 0;
    if (route && !remote_id) {
      if (url.pathname === base || url.pathname === base + "/") {
        trailing_slash = "always";
      } else if (page_nodes) {
        if (BROWSER) ;
        trailing_slash = page_nodes.trailing_slash();
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash ?? "never";
        if (BROWSER) ;
      }
      if (!is_data_request) {
        const normalized = normalize_path(url.pathname, trailing_slash);
        if (normalized !== url.pathname && !state2.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
              )
            }
          });
        }
      }
      if (state2.before_handle || state2.emulator?.platform) {
        let config = {};
        let prerender = false;
        if (route.endpoint) {
          const node = await route.endpoint();
          config = node.config ?? config;
          prerender = node.prerender ?? prerender;
        } else if (page_nodes) {
          config = page_nodes.get_config() ?? config;
          prerender = page_nodes.prerender();
        }
        if (state2.before_handle) {
          state2.before_handle(event, config, prerender);
        }
        if (state2.emulator?.platform) {
          event.platform = await state2.emulator.platform({ config, prerender });
        }
      }
    }
    set_trailing_slash(trailing_slash);
    if (state2.prerendering && !state2.prerendering.fallback && !state2.prerendering.inside_reroute) {
      disable_search(url);
    }
    const response = await record_span({
      name: "sveltekit.handle.root",
      attributes: {
        "http.route": event.route.id || "unknown",
        "http.method": event.request.method,
        "http.url": event.url.href,
        "sveltekit.is_data_request": is_data_request,
        "sveltekit.is_sub_request": event.isSubRequest
      },
      fn: async (root_span) => {
        const traced_event = {
          ...event,
          tracing: {
            enabled: false,
            root: root_span,
            current: root_span
          }
        };
        return await with_request_store(
          { event: traced_event, state: event_state },
          () => options2.hooks.handle({
            event: traced_event,
            resolve: (event2, opts) => {
              return record_span({
                name: "sveltekit.resolve",
                attributes: {
                  "http.route": event2.route.id || "unknown"
                },
                fn: (resolve_span) => {
                  return with_request_store(
                    null,
                    () => resolve2(merge_tracing(event2, resolve_span), page_nodes, opts).then(
                      (response2) => {
                        for (const key2 in headers2) {
                          const value = headers2[key2];
                          response2.headers.set(
                            key2,
                            /** @type {string} */
                            value
                          );
                        }
                        add_cookies_to_headers(response2.headers, new_cookies.values());
                        if (state2.prerendering && event2.route.id !== null) {
                          response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
                        }
                        resolve_span.setAttributes({
                          "http.response.status_code": response2.status,
                          "http.response.body.size": response2.headers.get("content-length") || "unknown"
                        });
                        return response2;
                      }
                    )
                  );
                }
              });
            }
          })
        );
      }
    });
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag2 = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag2) {
        const headers22 = new Headers({ etag: etag2 });
        for (const key2 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key2);
          if (value) headers22.set(key2, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers22
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location = response.headers.get("location");
      if (location) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location
        ));
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      const response = is_data_request || remote_id ? redirect_json_response(e3) : route?.page && is_action_json_request(event) ? action_json_redirect(e3) : redirect_response(e3.status, e3.location);
      add_cookies_to_headers(response.headers, new_cookies.values());
      return response;
    }
    return await handle_fatal_error(event, event_state, options2, e3);
  }
  async function resolve2(event2, page_nodes, opts) {
    try {
      if (opts) {
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (options2.hash_routing || state2.prerendering?.fallback) {
        return await render_response({
          event: event2,
          event_state,
          options: options2,
          manifest: manifest2,
          state: state2,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts,
          data_serializer: server_data_serializer(event2, event_state, options2)
        });
      }
      if (remote_id) {
        return await handle_remote_call(event2, event_state, options2, manifest2, remote_id);
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response2;
        if (is_data_request) {
          response2 = await render_data(
            event2,
            event_state,
            route,
            options2,
            manifest2,
            state2,
            invalidated_data_nodes,
            trailing_slash
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response2 = await render_endpoint(event2, event_state, await route.endpoint(), state2);
        } else if (route.page) {
          if (!page_nodes) {
            throw new Error("page_nodes not found. This should never happen");
          } else if (page_methods.has(method)) {
            response2 = await render_page(
              event2,
              event_state,
              route.page,
              options2,
              manifest2,
              state2,
              page_nodes,
              resolve_opts
            );
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response2 = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response2 = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("Route is neither page nor endpoint. This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response2.headers.get("vary")?.split(",")?.map((v2) => v2.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response2 = new Response(response2.body, {
              status: response2.status,
              statusText: response2.statusText,
              headers: new Headers(response2.headers)
            });
            response2.headers.append("Vary", "Accept");
          }
        }
        return response2;
      }
      if (state2.error && event2.isSubRequest) {
        const headers22 = new Headers(request.headers);
        headers22.set("x-sveltekit-error", "true");
        return await fetch(request, { headers: headers22 });
      }
      if (state2.error) {
        return text("Internal Server Error", {
          status: 500
        });
      }
      if (state2.depth === 0) {
        if (BROWSER && event2.url.pathname === "/.well-known/appspecific/com.chrome.devtools.json") ;
        return await respond_with_error({
          event: event2,
          event_state,
          options: options2,
          manifest: manifest2,
          state: state2,
          status: 404,
          error: new SvelteKitError(404, "Not Found", `Not found: ${event2.url.pathname}`),
          resolve_opts
        });
      }
      if (state2.prerendering) {
        return text("not found", { status: 404 });
      }
      const response = await fetch(request);
      return new Response(response.body, response);
    } catch (e3) {
      return await handle_fatal_error(event2, event_state, options2, e3);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
}
function load_page_nodes(page3, manifest2) {
  return Promise.all([
    // we use == here rather than === because [undefined] serializes as "[null]"
    ...page3.layouts.map((n2) => n2 == void 0 ? n2 : manifest2._.nodes[n2]()),
    manifest2._.nodes[page3.leaf]()
  ]);
}
function propagate_context(fn) {
  return async (req, ...rest) => {
    {
      return fn(req, ...rest);
    }
  };
}
function filter_env(env, allowed, disallowed) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k]) => k.startsWith(allowed) && (disallowed === "" || !k.startsWith(disallowed))
    )
  );
}
function set_app(value) {
}
var init_promise;
var current = null;
var Server = class {
  /** @type {import('types').SSROptions} */
  #options;
  /** @type {import('@sveltejs/kit').SSRManifest} */
  #manifest;
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    this.#options = options;
    this.#manifest = manifest2;
    if (IN_WEBCONTAINER2) {
      const respond2 = this.respond.bind(this);
      this.respond = async (...args) => {
        const { promise, resolve: resolve2 } = (
          /** @type {PromiseWithResolvers<void>} */
          with_resolvers()
        );
        const previous = current;
        current = promise;
        await previous;
        return respond2(...args).finally(resolve2);
      };
    }
  }
  /**
   * @param {import('@sveltejs/kit').ServerInitOptions} opts
   */
  async init({ env, read }) {
    const { env_public_prefix, env_private_prefix } = this.#options;
    set_private_env(filter_env(env, env_private_prefix, env_public_prefix));
    set_public_env(filter_env(env, env_public_prefix, env_private_prefix));
    if (read) {
      const wrapped_read = (file) => {
        const result = read(file);
        if (result instanceof ReadableStream) {
          return result;
        } else {
          return new ReadableStream({
            async start(controller2) {
              try {
                const stream = await Promise.resolve(result);
                if (!stream) {
                  controller2.close();
                  return;
                }
                const reader = stream.getReader();
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) break;
                  controller2.enqueue(value);
                }
                controller2.close();
              } catch (error2) {
                controller2.error(error2);
              }
            }
          });
        }
      };
      set_read_implementation(wrapped_read);
    }
    await (init_promise ??= (async () => {
      try {
        const module = await get_hooks();
        this.#options.hooks = {
          handle: module.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
          handleError: module.handleError || (({ status, error: error2, event }) => {
            const error_message = format_server_error(
              status,
              /** @type {Error} */
              error2,
              event
            );
            console.error(error_message);
          }),
          handleFetch: module.handleFetch || (({ request, fetch: fetch2 }) => fetch2(request)),
          handleValidationError: module.handleValidationError || (({ issues }) => {
            console.error("Remote function schema validation failed:", issues);
            return { message: "Bad Request" };
          }),
          reroute: module.reroute || (() => {
          }),
          transport: module.transport || {}
        };
        set_app({
          decoders: module.transport ? Object.fromEntries(Object.entries(module.transport).map(([k, v2]) => [k, v2.decode])) : {}
        });
        if (module.init) {
          await module.init();
        }
      } catch (e3) {
        {
          throw e3;
        }
      }
    })());
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options2) {
    return respond(request, this.#options, this.#manifest, {
      ...options2,
      error: false,
      depth: 0
    });
  }
};

// .svelte-kit/cloudflare-tmp/manifest.js
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ??= value = fn();
  }
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["robots.txt"]),
    mimeTypes: { ".txt": "text/plain" },
    _: {
      client: { start: "_app/immutable/entry/start.C79mKIp-.js", app: "_app/immutable/entry/app.A0HmRYif.js", imports: ["_app/immutable/entry/start.C79mKIp-.js", "_app/immutable/chunks/D-pHkSQu.js", "_app/immutable/chunks/Ch_7xMJZ.js", "_app/immutable/chunks/DmKfOTeo.js", "_app/immutable/entry/app.A0HmRYif.js", "_app/immutable/chunks/DmKfOTeo.js", "_app/immutable/chunks/Ch_7xMJZ.js", "_app/immutable/chunks/DsnmJJEf.js", "_app/immutable/chunks/DlFo6P2L.js", "_app/immutable/chunks/B7pDVb1P.js", "_app/immutable/chunks/CcWUXD1I.js"], stylesheets: [], fonts: [], uses_env_dynamic_public: false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5))),
        __memo(() => Promise.resolve().then(() => (init__6(), __exports6))),
        __memo(() => Promise.resolve().then(() => (init__7(), __exports7)))
      ],
      remotes: {},
      routes: [
        {
          id: "/",
          pattern: /^\/$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 4 },
          endpoint: null
        },
        {
          id: "/create",
          pattern: /^\/create\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 5 },
          endpoint: null
        },
        {
          id: "/view",
          pattern: /^\/view\/?$/,
          params: [],
          page: { layouts: [0, 3], errors: [1, ,], leaf: 6 },
          endpoint: null
        }
      ],
      prerendered_routes: /* @__PURE__ */ new Set([]),
      matchers: async () => {
        return {};
      },
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var base_path = "";

// .svelte-kit/cloudflare-tmp/_worker.js
async function e(e3, t2) {
  let n2 = "string" != typeof t2 && "HEAD" === t2.method;
  n2 && (t2 = new Request(t2, { method: "GET" }));
  let r3 = await e3.match(t2);
  return n2 && r3 && (r3 = new Response(null, r3)), r3;
}
function t(e3, t2, n2, o2) {
  return ("string" == typeof t2 || "GET" === t2.method) && r2(n2) && (n2.headers.has("Set-Cookie") && (n2 = new Response(n2.body, n2)).headers.append("Cache-Control", "private=Set-Cookie"), o2.waitUntil(e3.put(t2, n2.clone()))), n2;
}
var n = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r2(e3) {
  if (!n.has(e3.status)) return false;
  if (~(e3.headers.get("Vary") || "").indexOf("*")) return false;
  let t2 = e3.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t2);
}
function o(n2) {
  return async function(r3, o2) {
    let a = await e(n2, r3);
    if (a) return a;
    o2.defer((e3) => {
      t(n2, r3, e3, o2);
    });
  };
}
var s2 = caches.default;
var c = t.bind(0, s2);
var r22 = e.bind(0, s2);
var e2 = o.bind(0, s2);
var server = new Server(manifest);
var app_path = `/${manifest.appPath}`;
var immutable = `${app_path}/immutable/`;
var version_file = `${app_path}/version.json`;
var worker = {
  async fetch(req, env, context2) {
    await server.init({ env });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r22(req);
    if (res) return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.slice(base_path.length + 1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
    }
    let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env.ASSETS.fetch(req);
    } else if (location && prerendered.has(location)) {
      if (search) location += search;
      res = new Response("", {
        status: 308,
        headers: {
          location
        }
      });
    } else {
      res = await server.respond(req, {
        // @ts-ignore
        platform: { env, context: context2, caches, cf: req.cf },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c(req, res, context2) : res;
  }
};
var worker_default = worker;
export {
  worker_default as default
};
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=_worker.js.map
